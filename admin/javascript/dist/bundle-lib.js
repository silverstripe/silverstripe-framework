require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

require('../../../../thirdparty/jquery/jquery.js');
require('../../../../thirdparty/jquery-ondemand/jquery.ondemand.js');
require('../../src/sspath.js');
require('../../../../thirdparty/jquery-ui/jquery-ui.js');
require('../../../../thirdparty/json-js/json2.js');
require('../../../../thirdparty/jquery-entwine/dist/jquery.entwine-dist.js');
require('../../../../thirdparty/jquery-cookie/jquery.cookie.js');
require('../../../../thirdparty/jquery-query/jquery.query.js');
require('../../../../thirdparty/jquery-form/jquery.form.js');
require('../../../thirdparty/jquery-notice/jquery.notice.js');
require('../../../thirdparty/jsizes/lib/jquery.sizes.js');
require('../../../thirdparty/jlayout/lib/jlayout.border.js');
require('../../../thirdparty/jlayout/lib/jquery.jlayout.js');
require('../../../../thirdparty/jstree/jquery.jstree.js');
require('../../../thirdparty/chosen/chosen/chosen.jquery.js');
require('../../../thirdparty/jquery-hoverIntent/jquery.hoverIntent.js');
require('../../../../thirdparty/jquery-changetracker/lib/jquery.changetracker.js');
require('../../../../javascript/src/TreeDropdownField.js');
require('../../../../javascript/src/DateField.js');
require('../../../../javascript/src/HtmlEditorField.js');
require('../../../../javascript/src/TabSet.js');
require('../../src/ssui.core.js');
require('../../../../javascript/src/GridField.js');

},{"../../../../javascript/src/DateField.js":10,"../../../../javascript/src/GridField.js":11,"../../../../javascript/src/HtmlEditorField.js":12,"../../../../javascript/src/TabSet.js":13,"../../../../javascript/src/TreeDropdownField.js":14,"../../../../thirdparty/jquery-changetracker/lib/jquery.changetracker.js":18,"../../../../thirdparty/jquery-cookie/jquery.cookie.js":19,"../../../../thirdparty/jquery-entwine/dist/jquery.entwine-dist.js":20,"../../../../thirdparty/jquery-form/jquery.form.js":21,"../../../../thirdparty/jquery-ondemand/jquery.ondemand.js":22,"../../../../thirdparty/jquery-query/jquery.query.js":23,"../../../../thirdparty/jquery-ui/jquery-ui.js":24,"../../../../thirdparty/jquery/jquery.js":25,"../../../../thirdparty/json-js/json2.js":26,"../../../../thirdparty/jstree/jquery.jstree.js":27,"../../../thirdparty/chosen/chosen/chosen.jquery.js":4,"../../../thirdparty/jlayout/lib/jlayout.border.js":5,"../../../thirdparty/jlayout/lib/jquery.jlayout.js":6,"../../../thirdparty/jquery-hoverIntent/jquery.hoverIntent.js":7,"../../../thirdparty/jquery-notice/jquery.notice.js":8,"../../../thirdparty/jsizes/lib/jquery.sizes.js":9,"../../src/sspath.js":2,"../../src/ssui.core.js":3}],2:[function(require,module,exports){
'use strict';

var _jQuery = require('jQuery');

var _jQuery2 = _interopRequireDefault(_jQuery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var $window = (0, _jQuery2.default)(window),
    $html = (0, _jQuery2.default)('html'),
    $head = (0, _jQuery2.default)('head'),
    path = {
	urlParseRE: /^(((([^:\/#\?]+:)?(?:(\/\/)((?:(([^:@\/#\?]+)(?:\:([^:@\/#\?]+))?)@)?(([^:\/#\?\]\[]+|\[[^\/\]@#?]+\])(?:\:([0-9]+))?))?)?)?((\/?(?:[^\/\?#]+\/+)*)([^\?#]*)))?(\?[^#]+)?)(#.*)?/,

	parseUrl: function parseUrl(url) {
		if (_jQuery2.default.type(url) === "object") {
			return url;
		}

		var matches = path.urlParseRE.exec(url || "") || [];

		return {
			href: matches[0] || "",
			hrefNoHash: matches[1] || "",
			hrefNoSearch: matches[2] || "",
			domain: matches[3] || "",
			protocol: matches[4] || "",
			doubleSlash: matches[5] || "",
			authority: matches[6] || "",
			username: matches[8] || "",
			password: matches[9] || "",
			host: matches[10] || "",
			hostname: matches[11] || "",
			port: matches[12] || "",
			pathname: matches[13] || "",
			directory: matches[14] || "",
			filename: matches[15] || "",
			search: matches[16] || "",
			hash: matches[17] || ""
		};
	},

	makePathAbsolute: function makePathAbsolute(relPath, absPath) {
		if (relPath && relPath.charAt(0) === "/") {
			return relPath;
		}

		relPath = relPath || "";
		absPath = absPath ? absPath.replace(/^\/|(\/[^\/]*|[^\/]+)$/g, "") : "";

		var absStack = absPath ? absPath.split("/") : [],
		    relStack = relPath.split("/");
		for (var i = 0; i < relStack.length; i++) {
			var d = relStack[i];
			switch (d) {
				case ".":
					break;
				case "..":
					if (absStack.length) {
						absStack.pop();
					}
					break;
				default:
					absStack.push(d);
					break;
			}
		}
		return "/" + absStack.join("/");
	},

	isSameDomain: function isSameDomain(absUrl1, absUrl2) {
		return path.parseUrl(absUrl1).domain === path.parseUrl(absUrl2).domain;
	},

	isRelativeUrl: function isRelativeUrl(url) {
		return path.parseUrl(url).protocol === "";
	},

	isAbsoluteUrl: function isAbsoluteUrl(url) {
		return path.parseUrl(url).protocol !== "";
	},

	makeUrlAbsolute: function makeUrlAbsolute(relUrl, absUrl) {
		if (!path.isRelativeUrl(relUrl)) {
			return relUrl;
		}

		var relObj = path.parseUrl(relUrl),
		    absObj = path.parseUrl(absUrl),
		    protocol = relObj.protocol || absObj.protocol,
		    doubleSlash = relObj.protocol ? relObj.doubleSlash : relObj.doubleSlash || absObj.doubleSlash,
		    authority = relObj.authority || absObj.authority,
		    hasPath = relObj.pathname !== "",
		    pathname = path.makePathAbsolute(relObj.pathname || absObj.filename, absObj.pathname),
		    search = relObj.search || !hasPath && absObj.search || "",
		    hash = relObj.hash;

		return protocol + doubleSlash + authority + pathname + search + hash;
	},

	addSearchParams: function addSearchParams(url, params) {
		var u = path.parseUrl(url),
		    params = typeof params === "string" ? path.convertSearchToArray(params) : params,
		    newParams = _jQuery2.default.extend(path.convertSearchToArray(u.search), params);
		return u.hrefNoSearch + '?' + _jQuery2.default.param(newParams) + (u.hash || "");
	},

	getSearchParams: function getSearchParams(url) {
		var u = path.parseUrl(url);
		return path.convertSearchToArray(u.search);
	},

	convertSearchToArray: function convertSearchToArray(search) {
		var params = {},
		    search = search.replace(/^\?/, ''),
		    parts = search ? search.split('&') : [],
		    i,
		    tmp;
		for (i = 0; i < parts.length; i++) {
			tmp = parts[i].split('=');
			params[tmp[0]] = tmp[1];
		}
		return params;
	},

	convertUrlToDataUrl: function convertUrlToDataUrl(absUrl) {
		var u = path.parseUrl(absUrl);
		if (path.isEmbeddedPage(u)) {
			return u.hash.split(dialogHashKey)[0].replace(/^#/, "");
		} else if (path.isSameDomain(u, document)) {
			return u.hrefNoHash.replace(document.domain, "");
		}
		return absUrl;
	},

	get: function get(newPath) {
		if (newPath === undefined) {
			newPath = location.hash;
		}
		return path.stripHash(newPath).replace(/[^\/]*\.[^\/*]+$/, '');
	},

	getFilePath: function getFilePath(path) {
		var splitkey = '&' + _jQuery2.default.mobile.subPageUrlKey;
		return path && path.split(splitkey)[0].split(dialogHashKey)[0];
	},

	set: function set(path) {
		location.hash = path;
	},

	isPath: function isPath(url) {
		return (/\//.test(url)
		);
	},

	clean: function clean(url) {
		return url.replace(document.domain, "");
	},

	stripHash: function stripHash(url) {
		return url.replace(/^#/, "");
	},

	cleanHash: function cleanHash(hash) {
		return path.stripHash(hash.replace(/\?.*$/, "").replace(dialogHashKey, ""));
	},

	isExternal: function isExternal(url) {
		var u = path.parseUrl(url);
		return u.protocol && u.domain !== document.domain ? true : false;
	},

	hasProtocol: function hasProtocol(url) {
		return (/^(:?\w+:)/.test(url)
		);
	}
};

_jQuery2.default.path = path;

},{"jQuery":"jQuery"}],3:[function(require,module,exports){
'use strict';

var _jQuery = require('jQuery');

var _jQuery2 = _interopRequireDefault(_jQuery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_jQuery2.default.widget('ssui.button', _jQuery2.default.ui.button, {
	options: {
		alternate: {
			icon: null,
			text: null
		},
		showingAlternate: false
	},

	toggleAlternate: function toggleAlternate() {
		if (this._trigger('ontogglealternate') === false) return;

		if (!this.options.alternate.icon && !this.options.alternate.text) return;

		this.options.showingAlternate = !this.options.showingAlternate;
		this.refresh();
	},

	_refreshAlternate: function _refreshAlternate() {
		this._trigger('beforerefreshalternate');

		if (!this.options.alternate.icon && !this.options.alternate.text) return;

		if (this.options.showingAlternate) {
			this.element.find('.ui-button-icon-primary').hide();
			this.element.find('.ui-button-text').hide();
			this.element.find('.ui-button-icon-alternate').show();
			this.element.find('.ui-button-text-alternate').show();
		} else {
			this.element.find('.ui-button-icon-primary').show();
			this.element.find('.ui-button-text').show();
			this.element.find('.ui-button-icon-alternate').hide();
			this.element.find('.ui-button-text-alternate').hide();
		}

		this._trigger('afterrefreshalternate');
	},

	_resetButton: function _resetButton() {
		var iconPrimary = this.element.data('icon-primary'),
		    iconSecondary = this.element.data('icon-secondary');

		if (!iconPrimary) iconPrimary = this.element.data('icon');

		if (iconPrimary) this.options.icons.primary = 'btn-icon-' + iconPrimary;
		if (iconSecondary) this.options.icons.secondary = 'btn-icon-' + iconSecondary;

		_jQuery2.default.ui.button.prototype._resetButton.call(this);

		if (!this.options.alternate.text) {
			this.options.alternate.text = this.element.data('text-alternate');
		}
		if (!this.options.alternate.icon) {
			this.options.alternate.icon = this.element.data('icon-alternate');
		}
		if (!this.options.showingAlternate) {
			this.options.showingAlternate = this.element.hasClass('ss-ui-alternate');
		}

		if (this.options.alternate.icon) {
			this.buttonElement.append("<span class='ui-button-icon-alternate ui-button-icon-primary ui-icon btn-icon-" + this.options.alternate.icon + "'></span>");
		}
		if (this.options.alternate.text) {
			this.buttonElement.append("<span class='ui-button-text-alternate ui-button-text'>" + this.options.alternate.text + "</span>");
		}

		this._refreshAlternate();
	},

	refresh: function refresh() {
		_jQuery2.default.ui.button.prototype.refresh.call(this);

		this._refreshAlternate();
	},

	destroy: function destroy() {
		this.element.find('.ui-button-text-alternate').remove();
		this.element.find('.ui-button-icon-alternate').remove();

		_jQuery2.default.ui.button.prototype.destroy.call(this);
	}
});

_jQuery2.default.widget("ssui.ssdialog", _jQuery2.default.ui.dialog, {
	options: {
		iframeUrl: '',
		reloadOnOpen: true,
		dialogExtraClass: '',

		modal: true,
		bgiframe: true,
		autoOpen: false,
		autoPosition: true,
		minWidth: 500,
		maxWidth: 800,
		minHeight: 300,
		maxHeight: 700,
		widthRatio: 0.8,
		heightRatio: 0.8,
		resizable: false
	},
	_create: function _create() {
		_jQuery2.default.ui.dialog.prototype._create.call(this);

		var self = this;

		var iframe = (0, _jQuery2.default)('<iframe marginWidth="0" marginHeight="0" frameBorder="0" scrolling="auto"></iframe>');
		iframe.bind('load', function (e) {
			if ((0, _jQuery2.default)(this).attr('src') == 'about:blank') return;

			iframe.addClass('loaded').show();
			self._resizeIframe();
			self.uiDialog.removeClass('loading');
		}).hide();

		if (this.options.dialogExtraClass) this.uiDialog.addClass(this.options.dialogExtraClass);
		this.element.append(iframe);

		if (this.options.iframeUrl) this.element.css('overflow', 'hidden');
	},
	open: function open() {
		_jQuery2.default.ui.dialog.prototype.open.call(this);

		var self = this,
		    iframe = this.element.children('iframe');

		if (this.options.iframeUrl && (!iframe.hasClass('loaded') || this.options.reloadOnOpen)) {
			iframe.hide();
			iframe.attr('src', this.options.iframeUrl);
			this.uiDialog.addClass('loading');
		}

		(0, _jQuery2.default)(window).bind('resize.ssdialog', function () {
			self._resizeIframe();
		});
	},
	close: function close() {
		_jQuery2.default.ui.dialog.prototype.close.call(this);

		this.uiDialog.unbind('resize.ssdialog');
		(0, _jQuery2.default)(window).unbind('resize.ssdialog');
	},
	_resizeIframe: function _resizeIframe() {
		var opts = {},
		    newWidth,
		    newHeight,
		    iframe = this.element.children('iframe');;
		if (this.options.widthRatio) {
			newWidth = (0, _jQuery2.default)(window).width() * this.options.widthRatio;
			if (this.options.minWidth && newWidth < this.options.minWidth) {
				opts.width = this.options.minWidth;
			} else if (this.options.maxWidth && newWidth > this.options.maxWidth) {
				opts.width = this.options.maxWidth;
			} else {
				opts.width = newWidth;
			}
		}
		if (this.options.heightRatio) {
			newHeight = (0, _jQuery2.default)(window).height() * this.options.heightRatio;
			if (this.options.minHeight && newHeight < this.options.minHeight) {
				opts.height = this.options.minHeight;
			} else if (this.options.maxHeight && newHeight > this.options.maxHeight) {
				opts.height = this.options.maxHeight;
			} else {
				opts.height = newHeight;
			}
		}

		if (!jQuery.isEmptyObject(opts)) {
			this._setOptions(opts);

			iframe.attr('width', opts.width - parseFloat(this.element.css('paddingLeft')) - parseFloat(this.element.css('paddingRight')));
			iframe.attr('height', opts.height - parseFloat(this.element.css('paddingTop')) - parseFloat(this.element.css('paddingBottom')));

			if (this.options.autoPosition) {
				this._setOption("position", this.options.position);
			}
		}
	}
});

_jQuery2.default.widget("ssui.titlebar", {
	_create: function _create() {
		this.originalTitle = this.element.attr('title');

		var self = this;
		var options = this.options;

		var title = options.title || this.originalTitle || '&nbsp;';
		var titleId = _jQuery2.default.ui.dialog.getTitleId(this.element);

		this.element.parent().addClass('ui-dialog');

		var uiDialogTitlebar = this.element.addClass('ui-dialog-titlebar ' + 'ui-widget-header ' + 'ui-corner-all ' + 'ui-helper-clearfix');

		if (options.closeButton) {
			var uiDialogTitlebarClose = (0, _jQuery2.default)('<a href="#"/>').addClass('ui-dialog-titlebar-close ' + 'ui-corner-all').attr('role', 'button').hover(function () {
				uiDialogTitlebarClose.addClass('ui-state-hover');
			}, function () {
				uiDialogTitlebarClose.removeClass('ui-state-hover');
			}).focus(function () {
				uiDialogTitlebarClose.addClass('ui-state-focus');
			}).blur(function () {
				uiDialogTitlebarClose.removeClass('ui-state-focus');
			}).mousedown(function (ev) {
				ev.stopPropagation();
			}).appendTo(uiDialogTitlebar);

			var uiDialogTitlebarCloseText = (this.uiDialogTitlebarCloseText = (0, _jQuery2.default)('<span/>')).addClass('ui-icon ' + 'ui-icon-closethick').text(options.closeText).appendTo(uiDialogTitlebarClose);
		}

		var uiDialogTitle = (0, _jQuery2.default)('<span/>').addClass('ui-dialog-title').attr('id', titleId).html(title).prependTo(uiDialogTitlebar);

		uiDialogTitlebar.find("*").add(uiDialogTitlebar).disableSelection();
	},

	destroy: function destroy() {
		this.element.unbind('.dialog').removeData('dialog').removeClass('ui-dialog-content ui-widget-content').hide().appendTo('body');

		this.originalTitle && this.element.attr('title', this.originalTitle);
	}
});

_jQuery2.default.extend(_jQuery2.default.ssui.titlebar, {
	version: "0.0.1",
	options: {
		title: '',
		closeButton: false,
		closeText: 'close'
	},

	uuid: 0,

	getTitleId: function getTitleId($el) {
		return 'ui-dialog-title-' + ($el.attr('id') || ++this.uuid);
	}
});

},{"jQuery":"jQuery"}],4:[function(require,module,exports){
// Chosen, a Select Box Enhancer for jQuery and Protoype
// by Patrick Filler for Harvest, http://getharvest.com
// 
// Version 0.9.8
// Full source at https://github.com/harvesthq/chosen
// Copyright (c) 2011 Harvest http://getharvest.com

// MIT License, https://github.com/harvesthq/chosen/blob/master/LICENSE.md
// based on version 0.9.8, applied a very simple patch that fixes percentage width support on select tag, and enables rise-up functionality
// This file is generated by `cake build`, do not edit it by hand.
(function() {
  var SelectParser;

  SelectParser = (function() {

    // Origional - You can't assign to functions like this in strict mode.
    //SelectParser.name = 'SelectParser';

    function SelectParser() {
      this.options_index = 0;
      this.parsed = [];
    }

    // SilverStripe custom
    SelectParser.prototype.name = 'SelectParser';

    SelectParser.prototype.add_node = function(child) {
      if (child.nodeName.toUpperCase() === "OPTGROUP") {
        return this.add_group(child);
      } else {
        return this.add_option(child);
      }
    };

    SelectParser.prototype.add_group = function(group) {
      var group_position, option, _i, _len, _ref, _results;
      group_position = this.parsed.length;
      this.parsed.push({
        array_index: group_position,
        group: true,
        label: group.label,
        children: 0,
        disabled: group.disabled
      });
      _ref = group.childNodes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        _results.push(this.add_option(option, group_position, group.disabled));
      }
      return _results;
    };

    SelectParser.prototype.add_option = function(option, group_position, group_disabled) {
      if (option.nodeName.toUpperCase() === "OPTION") {
        // workaround for https://github.com/harvesthq/chosen/issues/2125
        if (!option.text.match(/^\s*$/g)) {
          if (group_position != null) {
            this.parsed[group_position].children += 1;
          }
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            value: option.value,
            text: option.text,
            html: option.innerHTML,
            selected: option.selected,
            disabled: group_disabled === true ? group_disabled : option.disabled,
            group_array_index: group_position,
            classes: option.className,
            style: option.style.cssText
          });
        } else {
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            empty: true
          });
        }
        return this.options_index += 1;
      }
    };

    return SelectParser;

  })();

  SelectParser.select_to_array = function(select) {
    var child, parser, _i, _len, _ref;
    parser = new SelectParser();
    _ref = select.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      parser.add_node(child);
    }
    return parser.parsed;
  };

  this.SelectParser = SelectParser;

// Origional - 'this' !== 'window' in browserify
//}).call(this);

// SilverStripe custom
}).call(window);

/*
Chosen source: generate output using 'cake build'
Copyright (c) 2011 by Harvest
*/


(function() {
  var AbstractChosen, root;

  root = this;

  AbstractChosen = (function() {

    // Origional - You can't assign to functions like this in strict mode.
    //AbstractChosen.name = 'AbstractChosen';

    function AbstractChosen(form_field, options) {
      this.form_field = form_field;
      this.options = options != null ? options : {};
      this.set_default_values();
      this.is_multiple = this.form_field.multiple;
      this.set_default_text();
      this.setup();
      this.set_up_html();
      this.register_observers();
      this.finish_setup();
    }

    // SilverStripe custom
    AbstractChosen.prototype.name = 'AbstractChosen';

    AbstractChosen.prototype.set_default_values = function() {
      var _this = this;
      this.click_test_action = function(evt) {
        return _this.test_active_click(evt);
      };
      this.activate_action = function(evt) {
        return _this.activate_field(evt);
      };
      this.active_field = false;
      this.mouse_on_container = false;
      this.results_showing = false;
      this.result_highlighted = null;
      this.result_single_selected = null;
      this.allow_single_deselect = (this.options.allow_single_deselect != null)
			  && (this.form_field.options[0] != null)
			  // workaround for https://github.com/harvesthq/chosen/issues/2125
			  && this.form_field.options[0].text.match(/^\s*$/g)
				? this.options.allow_single_deselect
				: false;
      this.disable_search_threshold = this.options.disable_search_threshold || 0;
      this.disable_search = this.options.disable_search || false;
      this.search_contains = this.options.search_contains || false;
      this.choices = 0;
      this.single_backstroke_delete = this.options.single_backstroke_delete || false;
      return this.max_selected_options = this.options.max_selected_options || Infinity;
    };

    AbstractChosen.prototype.set_default_text = function() {
      if (this.form_field.getAttribute("data-placeholder")) {
        this.default_text = this.form_field.getAttribute("data-placeholder");
      } else if (this.is_multiple) {
        this.default_text = this.options.placeholder_text_multiple || this.options.placeholder_text || "Select Some Options";
      } else {
        this.default_text = this.options.placeholder_text_single || this.options.placeholder_text || "Select an Option";
      }
      return this.results_none_found = this.form_field.getAttribute("data-no_results_text") || this.options.no_results_text || "No results match";
    };

    AbstractChosen.prototype.mouse_enter = function() {
      return this.mouse_on_container = true;
    };

    AbstractChosen.prototype.mouse_leave = function() {
      return this.mouse_on_container = false;
    };

    AbstractChosen.prototype.input_focus = function(evt) {
      var _this = this;
      if (this.is_multiple) {
        if (!this.active_field) {
          return setTimeout((function() {
            return _this.container_mousedown();
          }), 50);
        }
      } else {
        if (!this.active_field) {
          return this.activate_field();
        }
      }
    };

    AbstractChosen.prototype.input_blur = function(evt) {
      var _this = this;
      if (!this.mouse_on_container) {
        this.active_field = false;
        return setTimeout((function() {
          return _this.blur_test();
        }), 100);
      }
    };

    AbstractChosen.prototype.result_add_option = function(option) {
      var classes, style;
      if (!option.disabled) {
        option.dom_id = this.container_id + "_o_" + option.array_index;
        classes = option.selected && this.is_multiple ? [] : ["active-result"];
        if (option.selected) {
          classes.push("result-selected");
        }
        if (option.group_array_index != null) {
          classes.push("group-option");
        }
        if (option.classes !== "") {
          classes.push(option.classes);
        }
        style = option.style.cssText !== "" ? " style=\"" + option.style + "\"" : "";
        return '<li id="' + option.dom_id + '" class="' + classes.join(' ') + '"' + style + '>' + option.html + '</li>';
      } else {
        return "";
      }
    };

    AbstractChosen.prototype.results_update_field = function() {
      if (!this.is_multiple) {
        this.results_reset_cleanup();
      }
      this.result_clear_highlight();
      this.result_single_selected = null;
      return this.results_build();
    };

    AbstractChosen.prototype.results_toggle = function() {
      if (this.results_showing) {
        return this.results_hide();
      } else {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.results_search = function(evt) {
      if (this.results_showing) {
        return this.winnow_results();
      } else {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.keyup_checker = function(evt) {
      var stroke, _ref;
      stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
      this.search_field_scale();
      switch (stroke) {
        case 8:
          if (this.is_multiple && this.backstroke_length < 1 && this.choices > 0) {
            return this.keydown_backstroke();
          } else if (!this.pending_backstroke) {
            this.result_clear_highlight();
            return this.results_search();
          }
          break;
        case 13:
          evt.preventDefault();
          if (this.results_showing) {
            return this.result_select(evt);
          }
          break;
        case 27:
          if (this.results_showing) {
            this.results_hide();
          }
          return true;
        case 9:
        case 38:
        case 40:
        case 16:
        case 91:
        case 17:
          break;
        default:
          return this.results_search();
      }
    };

    AbstractChosen.prototype.generate_field_id = function() {
      var new_id;
      new_id = this.generate_random_id();
      this.form_field.id = new_id;
      return new_id;
    };

    AbstractChosen.prototype.generate_random_char = function() {
      var chars, newchar, rand;
      chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      rand = Math.floor(Math.random() * chars.length);
      return newchar = chars.substring(rand, rand + 1);
    };

    return AbstractChosen;

  })();

  root.AbstractChosen = AbstractChosen;

// Origional - 'this' !== 'window' in browserify
//}).call(this);

// SilverStripe custom
}).call(window);

/*
Chosen source: generate output using 'cake build'
Copyright (c) 2011 by Harvest
*/


(function() {
  var $, Chosen, get_side_border_padding, root,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  root = this;

  $ = jQuery;

  $.fn.extend({
    chosen: function(options) {
      if ($.browser.msie && ($.browser.version === "6.0" || ($.browser.version === "7.0" && document.documentMode === 7))) {
        return this;
      }
      return this.each(function(input_field) {
        var $this;
        $this = $(this);
        if (!$this.hasClass("chzn-done")) {
          return $this.data('chosen', new Chosen(this, options));
        }
      });
    }
  });

  Chosen = (function(_super) {

    __extends(Chosen, _super);

    // Origional - You can't assign to functions like this in strict mode.
    //Chosen.name = 'Chosen';

    function Chosen() {
      return Chosen.__super__.constructor.apply(this, arguments);
    }

    // SilverStripe custom
    Chosen.prototype.name = 'Chosen';

    Chosen.prototype.setup = function() {
      this.form_field_jq = $(this.form_field);
      this.current_value = this.form_field_jq.val();
      return this.is_rtl = this.form_field_jq.hasClass("chzn-rtl");
    };

    Chosen.prototype.finish_setup = function() {
      return this.form_field_jq.addClass("chzn-done");
    };

    Chosen.prototype.set_up_html = function() {
      var container_div, dd_top, dd_width, rise, sf_width;
      this.container_id = this.form_field.id.length ? this.form_field.id.replace(/(:|\.)/g, '_') : this.generate_field_id();
      this.container_id += "_chzn";
      this.f_width = this.form_field_jq.outerWidth();
      this.default_text = this.form_field_jq.data('placeholder') ? this.form_field_jq.data('placeholder') : this.default_text_default;
      container_div = $("<div />", {
        id: this.container_id,
        "class": "chzn-container" + (this.is_rtl ? ' chzn-rtl' : ''),
        style: 'width: ' + (this.options.width || this.f_width) + 'px;'
      });
      if (this.is_multiple) {
        container_div.html('<ul class="chzn-choices"><li class="search-field"><input type="text" value="' + this.default_text + '" class="default" autocomplete="off" style="width:25px;" /></li></ul><div class="chzn-drop" style="left:-9000px;"><ul class="chzn-results"></ul></div>');
      } else {
        container_div.html('<a href="javascript:void(0)" class="chzn-single chzn-default" tabindex="-1"><span>' + this.default_text + '</span><div><b></b></div></a><div class="chzn-drop" style="left:-9000px;"><div class="chzn-search"><input type="text" autocomplete="off" /></div><ul class="chzn-results"></ul></div>');
      }
      this.form_field_jq.hide().after(container_div);
      this.container = $('#' + this.container_id);
      this.container.addClass("chzn-container-" + (this.is_multiple ? "multi" : "single"));
      this.dropdown = this.container.find('div.chzn-drop').first();
      /*
            CALL CUSTOM FUNCTION: rise_up
              # if rise-up true, reverse drop-up direction
      */

      rise = this.rise_up(this.container, this.dropdown);
      dd_top = rise ? -this.container.find('.chzn-drop').height() : this.container.height();
      dd_width = this.container.width() - get_side_border_padding(this.dropdown);
      this.dropdown.css({
        "width": dd_width + "px",
        "top": dd_top + "px"
      });
      this.search_field = this.container.find('input').first();
      this.search_results = this.container.find('ul.chzn-results').first();
      this.search_field_scale();
      this.search_no_results = this.container.find('li.no-results').first();
      if (this.is_multiple) {
        this.search_choices = this.container.find('ul.chzn-choices').first();
        this.search_container = this.container.find('li.search-field').first();
      } else {
        this.search_container = this.container.find('div.chzn-search').first();
        this.selected_item = this.container.find('.chzn-single').first();
        sf_width = dd_width - get_side_border_padding(this.search_container) - get_side_border_padding(this.search_field);
        this.search_field.css({
          "width": sf_width + "px"
        });
      }
      this.results_build();
      this.set_tab_index();
      return this.form_field_jq.trigger("liszt:ready", {
        chosen: this
      });
    };

    Chosen.prototype.register_observers = function() {
      var _this = this;
      this.container.mousedown(function(evt) {
        return _this.container_mousedown(evt);
      });
      this.container.mouseup(function(evt) {
        return _this.container_mouseup(evt);
      });
      this.container.mouseenter(function(evt) {
        return _this.mouse_enter(evt);
      });
      this.container.mouseleave(function(evt) {
        return _this.mouse_leave(evt);
      });
      this.search_results.mouseup(function(evt) {
        return _this.search_results_mouseup(evt);
      });
      this.search_results.mouseover(function(evt) {
        return _this.search_results_mouseover(evt);
      });
      this.search_results.mouseout(function(evt) {
        return _this.search_results_mouseout(evt);
      });
      this.form_field_jq.bind("liszt:updated", function(evt) {
        return _this.results_update_field(evt);
      });
      this.form_field_jq.bind("liszt:activate", function(evt) {
        return _this.activate_field(evt);
      });
      this.form_field_jq.bind("liszt:open", function(evt) {
        return _this.container_mousedown(evt);
      });
      this.search_field.blur(function(evt) {
        return _this.input_blur(evt);
      });
      this.search_field.keyup(function(evt) {
        return _this.keyup_checker(evt);
      });
      this.search_field.keydown(function(evt) {
        return _this.keydown_checker(evt);
      });
      this.search_field.focus(function(evt) {
        return _this.input_focus(evt);
      });
      if (this.is_multiple) {
        return this.search_choices.click(function(evt) {
          return _this.choices_click(evt);
        });
      } else {
        return this.container.click(function(evt) {
          return evt.preventDefault();
        });
      }
    };

    Chosen.prototype.search_field_disabled = function() {
      this.is_disabled = this.form_field_jq[0].disabled;
      if (this.is_disabled) {
        this.container.addClass('chzn-disabled');
        this.search_field[0].disabled = true;
        if (!this.is_multiple) {
          this.selected_item.unbind("focus", this.activate_action);
        }
        return this.close_field();
      } else {
        this.container.removeClass('chzn-disabled');
        this.search_field[0].disabled = false;
        if (!this.is_multiple) {
          return this.selected_item.bind("focus", this.activate_action);
        }
      }
    };

    Chosen.prototype.container_mousedown = function(evt) {
      var target_closelink;
      if (!this.is_disabled) {
        target_closelink = evt != null ? ($(evt.target)).hasClass("search-choice-close") : false;
        if (evt && evt.type === "mousedown" && !this.results_showing) {
          evt.stopPropagation();
        }
        if (!this.pending_destroy_click && !target_closelink) {
          if (!this.active_field) {
            if (this.is_multiple) {
              this.search_field.val("");
            }
            $(document).click(this.click_test_action);
            this.results_show();
          } else if (!this.is_multiple && evt && (($(evt.target)[0] === this.selected_item[0]) || $(evt.target).parents("a.chzn-single").length)) {
            evt.preventDefault();
            this.results_toggle();
          }
          return this.activate_field();
        } else {
          return this.pending_destroy_click = false;
        }
      }
    };

    Chosen.prototype.container_mouseup = function(evt) {
      if (evt.target.nodeName === "ABBR" && !this.is_disabled) {
        return this.results_reset(evt);
      }
    };

    Chosen.prototype.blur_test = function(evt) {
      if (!this.active_field && this.container.hasClass("chzn-container-active")) {
        return this.close_field();
      }
    };

    Chosen.prototype.close_field = function() {
      $(document).unbind("click", this.click_test_action);
      if (!this.is_multiple) {
        this.selected_item.attr("tabindex", this.search_field.attr("tabindex"));
        this.search_field.attr("tabindex", -1);
      }
      this.active_field = false;
      this.results_hide();
      this.container.removeClass("chzn-container-active");
      this.winnow_results_clear();
      this.clear_backstroke();
      this.show_search_field_default();
      return this.search_field_scale();
    };

    Chosen.prototype.activate_field = function() {
      this.container.addClass("chzn-container-active");
      this.active_field = true;
      this.search_field.val(this.search_field.val());
      return this.search_field.focus();
    };

    Chosen.prototype.test_active_click = function(evt) {
      if ($(evt.target).parents('#' + this.container_id).length) {
        return this.active_field = true;
      } else {
        return this.close_field();
      }
    };

    Chosen.prototype.results_build = function() {
      var content, data, _i, _len, _ref;
      this.parsing = true;
      this.results_data = root.SelectParser.select_to_array(this.form_field);
      if (this.is_multiple && this.choices > 0) {
        this.search_choices.find("li.search-choice").remove();
        this.choices = 0;
      } else if (!this.is_multiple) {
        this.selected_item.addClass("chzn-default").find("span").text(this.default_text);
        if (this.disable_search || this.form_field.options.length <= this.disable_search_threshold) {
          this.container.addClass("chzn-container-single-nosearch");
        } else {
          this.container.removeClass("chzn-container-single-nosearch");
        }
      }
      content = '';
      _ref = this.results_data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        data = _ref[_i];
        if (data.group) {
          content += this.result_add_group(data);
        } else if (!data.empty) {
          content += this.result_add_option(data);
          if (data.selected && this.is_multiple) {
            this.choice_build(data);
          } else if (data.selected && !this.is_multiple) {
            this.selected_item.removeClass("chzn-default").find("span").text(data.text);
            if (this.allow_single_deselect) {
              this.single_deselect_control_build();
            }
          }
        }
      }
      this.search_field_disabled();
      this.show_search_field_default();
      this.search_field_scale();
      this.search_results.html(content);
      return this.parsing = false;
    };

    Chosen.prototype.result_add_group = function(group) {
      if (!group.disabled) {
        group.dom_id = this.container_id + "_g_" + group.array_index;
        return '<li id="' + group.dom_id + '" class="group-result">' + $("<div />").text(group.label).html() + '</li>';
      } else {
        return "";
      }
    };

    Chosen.prototype.result_do_highlight = function(el) {
      var high_bottom, high_top, maxHeight, visible_bottom, visible_top;
      if (el.length) {
        this.result_clear_highlight();
        this.result_highlight = el;
        this.result_highlight.addClass("highlighted");
        maxHeight = parseInt(this.search_results.css("maxHeight"), 10);
        visible_top = this.search_results.scrollTop();
        visible_bottom = maxHeight + visible_top;
        high_top = this.result_highlight.position().top + this.search_results.scrollTop();
        high_bottom = high_top + this.result_highlight.outerHeight();
        if (high_bottom >= visible_bottom) {
          return this.search_results.scrollTop((high_bottom - maxHeight) > 0 ? high_bottom - maxHeight : 0);
        } else if (high_top < visible_top) {
          return this.search_results.scrollTop(high_top);
        }
      }
    };

    Chosen.prototype.result_clear_highlight = function() {
      if (this.result_highlight) {
        this.result_highlight.removeClass("highlighted");
      }
      return this.result_highlight = null;
    };

    Chosen.prototype.results_show = function() {
      var dd_top, dd_width, rise;
      if (!this.is_multiple) {
        this.selected_item.addClass("chzn-single-with-drop");
        if (this.result_single_selected) {
          this.result_do_highlight(this.result_single_selected);
        }
      }
      dd_width = this.container.width() - get_side_border_padding(this.dropdown);
      /*
            CALL CUSTOM FUNCTION: rise_up
              # if rise-up true, reverse drop-up direction
      */

      rise = this.rise_up(this.container, this.dropdown);
      dd_top = rise ? -this.container.find('.chzn-drop').height() : this.is_multiple ? this.container.height() : this.container.height() - 1;
      this.form_field_jq.trigger("liszt:showing_dropdown", {
        chosen: this
      });
      this.dropdown.css({
        "top": dd_top + "px",
        "left": 0
      });
      this.results_showing = true;
      this.search_field.css('width', (dd_width - get_side_border_padding(this.search_container) - get_side_border_padding(this.search_field)) + 'px');
      this.search_field.focus();
      this.search_field.val(this.search_field.val());
      return this.winnow_results();
    };

    Chosen.prototype.results_hide = function() {
      if (!this.is_multiple) {
        this.selected_item.removeClass("chzn-single-with-drop");
      }
      this.result_clear_highlight();
      this.form_field_jq.trigger("liszt:hiding_dropdown", {
        chosen: this
      });
      this.dropdown.css({
        "left": "-9000px"
      });
      return this.results_showing = false;
    };

    Chosen.prototype.set_tab_index = function(el) {
      var ti;
      if (this.form_field_jq.attr("tabindex")) {
        ti = this.form_field_jq.attr("tabindex");
        this.form_field_jq.attr("tabindex", -1);
        return this.search_field.attr("tabindex", ti);
      }
    };

    Chosen.prototype.show_search_field_default = function() {
      if (this.is_multiple && this.choices < 1 && !this.active_field) {
        this.search_field.val(this.default_text);
        return this.search_field.addClass("default");
      } else {
        this.search_field.val("");
        return this.search_field.removeClass("default");
      }
    };

    Chosen.prototype.search_results_mouseup = function(evt) {
      var target;
      target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
      if (target.length) {
        this.result_highlight = target;
        this.result_select(evt);
        return this.search_field.focus();
      }
    };

    Chosen.prototype.search_results_mouseover = function(evt) {
      var target;
      target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
      if (target) {
        return this.result_do_highlight(target);
      }
    };

    Chosen.prototype.search_results_mouseout = function(evt) {
      if ($(evt.target).hasClass("active-result" || $(evt.target).parents('.active-result').first())) {
        return this.result_clear_highlight();
      }
    };

    Chosen.prototype.choices_click = function(evt) {
      evt.preventDefault();
      if (this.active_field && !($(evt.target).hasClass("search-choice" || $(evt.target).parents('.search-choice').first)) && !this.results_showing) {
        return this.results_show();
      }
    };

    Chosen.prototype.choice_build = function(item) {
      var choice_id, html, link,
        _this = this;
      choice_id = this.container_id + "_c_" + item.array_index;
      this.choices += 1;
      if (item.disabled) {
        html = '<li class="search-choice search-choice-disabled" id="' + choice_id + '"><span>' + item.html + '</span></li>';
      } else {
        html = '<li class="search-choice" id="' + choice_id + '"><span>' + item.html + '</span><a href="javascript:void(0)" class="search-choice-close" rel="' + item.array_index + '"></a></li>';
      }
      this.search_container.before(html);
      link = $('#' + choice_id).find("a").first();
      return link.click(function(evt) {
        return _this.choice_destroy_link_click(evt);
      });
    };

    Chosen.prototype.choice_destroy_link_click = function(evt) {
      evt.preventDefault();
      if (!this.is_disabled) {
        this.pending_destroy_click = true;
        return this.choice_destroy($(evt.target));
      } else {
        return evt.stopPropagation;
      }
    };

    Chosen.prototype.choice_destroy = function(link) {
      if (this.result_deselect(link.attr("rel"))) {
        this.choices -= 1;
        this.show_search_field_default();
        if (this.is_multiple && this.choices > 0 && this.search_field.val().length < 1) {
          this.results_hide();
        }
        return link.parents('li').first().remove();
      }
    };

    Chosen.prototype.results_reset = function() {
      this.form_field.options[0].selected = true;
      this.selected_item.find("span").text(this.default_text);
      if (!this.is_multiple) {
        this.selected_item.addClass("chzn-default");
      }
      this.show_search_field_default();
      this.results_reset_cleanup();
      this.form_field_jq.trigger("change");
      if (this.active_field) {
        return this.results_hide();
      }
    };

    Chosen.prototype.results_reset_cleanup = function() {
      this.current_value = this.form_field_jq.val();
      return this.selected_item.find("abbr").remove();
    };

    Chosen.prototype.result_select = function(evt) {
      var high, high_id, item, position;
      if (this.result_highlight) {
        high = this.result_highlight;
        high_id = high.attr("id");
        this.result_clear_highlight();
        if (this.is_multiple) {
          this.result_deactivate(high);
        } else {
          this.search_results.find(".result-selected").removeClass("result-selected");
          this.result_single_selected = high;
          this.selected_item.removeClass("chzn-default");
        }
        high.addClass("result-selected");
        position = high_id.substr(high_id.lastIndexOf("_") + 1);
        item = this.results_data[position];
        item.selected = true;
        this.form_field.options[item.options_index].selected = true;
        if (this.is_multiple) {
          this.choice_build(item);
        } else {
          this.selected_item.find("span").first().text(item.text);
          if (this.allow_single_deselect) {
            this.single_deselect_control_build();
          }
        }
        if (!(evt.metaKey && this.is_multiple)) {
          this.results_hide();
        }
        this.search_field.val("");
        if (this.is_multiple || this.form_field_jq.val() !== this.current_value) {
          this.form_field_jq.trigger("change", {
            'selected': this.form_field.options[item.options_index].value
          });
        }
        this.current_value = this.form_field_jq.val();
        return this.search_field_scale();
      }
    };

    Chosen.prototype.result_activate = function(el) {
      return el.addClass("active-result");
    };

    Chosen.prototype.result_deactivate = function(el) {
      return el.removeClass("active-result");
    };

    Chosen.prototype.result_deselect = function(pos) {
      var result, result_data;
      result_data = this.results_data[pos];
      if (!this.form_field.options[result_data.options_index].disabled) {
        result_data.selected = false;
        this.form_field.options[result_data.options_index].selected = false;
        result = $("#" + this.container_id + "_o_" + pos);
        result.removeClass("result-selected").addClass("active-result").show();
        this.result_clear_highlight();
        this.winnow_results();
        this.form_field_jq.trigger("change", {
          deselected: this.form_field.options[result_data.options_index].value
        });
        this.search_field_scale();
        return true;
      } else {
        return false;
      }
    };

    Chosen.prototype.single_deselect_control_build = function() {
      if (this.allow_single_deselect && this.selected_item.find("abbr").length < 1) {
        return this.selected_item.find("span").first().after("<abbr class=\"search-choice-close\"></abbr>");
      }
    };

    Chosen.prototype.winnow_results = function() {
      var found, option, part, parts, regex, regexAnchor, result, result_id, results, searchText, startpos, text, zregex, _i, _j, _len, _len1, _ref;
      this.no_results_clear();
      results = 0;
      searchText = this.search_field.val() === this.default_text ? "" : $('<div/>').text($.trim(this.search_field.val())).html();
      regexAnchor = this.search_contains ? "" : "^";
      regex = new RegExp(regexAnchor + searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), 'i');
      zregex = new RegExp(searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), 'i');
      _ref = this.results_data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        if (!option.disabled && !option.empty) {
          if (option.group) {
            $('#' + option.dom_id).css('display', 'none');
          } else if (!(this.is_multiple && option.selected)) {
            found = false;
            result_id = option.dom_id;
            result = $("#" + result_id);
            if (regex.test(option.html)) {
              found = true;
              results += 1;
            } else if (option.html.indexOf(" ") >= 0 || option.html.indexOf("[") === 0) {
              parts = option.html.replace(/\[|\]/g, "").split(" ");
              if (parts.length) {
                for (_j = 0, _len1 = parts.length; _j < _len1; _j++) {
                  part = parts[_j];
                  if (regex.test(part)) {
                    found = true;
                    results += 1;
                  }
                }
              }
            }
            if (found) {
              if (searchText.length) {
                startpos = option.html.search(zregex);
                text = option.html.substr(0, startpos + searchText.length) + '</em>' + option.html.substr(startpos + searchText.length);
                text = text.substr(0, startpos) + '<em>' + text.substr(startpos);
              } else {
                text = option.html;
              }
              result.html(text);
              this.result_activate(result);
              if (option.group_array_index != null) {
                $("#" + this.results_data[option.group_array_index].dom_id).css('display', 'list-item');
              }
            } else {
              if (this.result_highlight && result_id === this.result_highlight.attr('id')) {
                this.result_clear_highlight();
              }
              this.result_deactivate(result);
            }
          }
        }
      }
      if (results < 1 && searchText.length) {
        return this.no_results(searchText);
      } else {
        return this.winnow_results_set_highlight();
      }
    };

    Chosen.prototype.winnow_results_clear = function() {
      var li, lis, _i, _len, _results;
      this.search_field.val("");
      lis = this.search_results.find("li");
      _results = [];
      for (_i = 0, _len = lis.length; _i < _len; _i++) {
        li = lis[_i];
        li = $(li);
        if (li.hasClass("group-result")) {
          _results.push(li.css('display', 'auto'));
        } else if (!this.is_multiple || !li.hasClass("result-selected")) {
          _results.push(this.result_activate(li));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Chosen.prototype.winnow_results_set_highlight = function() {
      var do_high, selected_results;
      if (!this.result_highlight) {
        selected_results = !this.is_multiple ? this.search_results.find(".result-selected.active-result") : [];
        do_high = selected_results.length ? selected_results.first() : this.search_results.find(".active-result").first();
        if (do_high != null) {
          return this.result_do_highlight(do_high);
        }
      }
    };

    Chosen.prototype.no_results = function(terms) {
      var no_results_html;
      no_results_html = $('<li class="no-results">' + this.results_none_found + ' "<span></span>"</li>');
      no_results_html.find("span").first().html(terms);
      return this.search_results.append(no_results_html);
    };

    Chosen.prototype.no_results_clear = function() {
      return this.search_results.find(".no-results").remove();
    };

    Chosen.prototype.keydown_arrow = function() {
      var first_active, next_sib;
      if (!this.result_highlight) {
        first_active = this.search_results.find("li.active-result").first();
        if (first_active) {
          this.result_do_highlight($(first_active));
        }
      } else if (this.results_showing) {
        next_sib = this.result_highlight.nextAll("li.active-result").first();
        if (next_sib) {
          this.result_do_highlight(next_sib);
        }
      }
      if (!this.results_showing) {
        return this.results_show();
      }
    };

    Chosen.prototype.keyup_arrow = function() {
      var prev_sibs;
      if (!this.results_showing && !this.is_multiple) {
        return this.results_show();
      } else if (this.result_highlight) {
        prev_sibs = this.result_highlight.prevAll("li.active-result");
        if (prev_sibs.length) {
          return this.result_do_highlight(prev_sibs.first());
        } else {
          if (this.choices > 0) {
            this.results_hide();
          }
          return this.result_clear_highlight();
        }
      }
    };

    Chosen.prototype.keydown_backstroke = function() {
      var next_available_destroy;
      if (this.pending_backstroke) {
        this.choice_destroy(this.pending_backstroke.find("a").first());
        return this.clear_backstroke();
      } else {
        next_available_destroy = this.search_container.siblings("li.search-choice").last();
        if (next_available_destroy.length && !next_available_destroy.hasClass("search-choice-disabled")) {
          this.pending_backstroke = next_available_destroy;
          if (this.single_backstroke_delete) {
            return this.keydown_backstroke();
          } else {
            return this.pending_backstroke.addClass("search-choice-focus");
          }
        }
      }
    };

    Chosen.prototype.clear_backstroke = function() {
      if (this.pending_backstroke) {
        this.pending_backstroke.removeClass("search-choice-focus");
      }
      return this.pending_backstroke = null;
    };

    Chosen.prototype.keydown_checker = function(evt) {
      var stroke, _ref;
      stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
      this.search_field_scale();
      if (stroke !== 8 && this.pending_backstroke) {
        this.clear_backstroke();
      }
      switch (stroke) {
        case 8:
          this.backstroke_length = this.search_field.val().length;
          break;
        case 9:
          if (this.results_showing && !this.is_multiple) {
            this.result_select(evt);
          }
          this.mouse_on_container = false;
          break;
        case 13:
          evt.preventDefault();
          break;
        case 38:
          evt.preventDefault();
          this.keyup_arrow();
          break;
        case 40:
          this.keydown_arrow();
          break;
      }
    };

    Chosen.prototype.search_field_scale = function() {
      var dd_top, div, h, rise, style, style_block, styles, w, _i, _len;
      if (this.is_multiple) {
        h = 0;
        w = 0;
        style_block = "position:absolute; left: -1000px; top: -1000px; display:none;";
        styles = ['font-size', 'font-style', 'font-weight', 'font-family', 'line-height', 'text-transform', 'letter-spacing'];
        for (_i = 0, _len = styles.length; _i < _len; _i++) {
          style = styles[_i];
          style_block += style + ":" + this.search_field.css(style) + ";";
        }
        div = $('<div />', {
          'style': style_block
        });
        div.text(this.search_field.val());
        $('body').append(div);
        w = div.width() + 25;
        div.remove();
        if (w > this.f_width - 10) {
          w = this.f_width - 10;
        }
        this.search_field.css({
          'width': w + 'px'
        });
        /*
                CALL CUSTOM FUNCTION: rise_up
                  # if rise-up true, reverse drop-up direction
        */

        rise = this.rise_up(this.container, this.dropdown);
        dd_top = rise ? -this.container.find('.chzn-drop').height() : this.container.height();
        return this.dropdown.css({
          "top": dd_top + "px"
        });
      }
    };

    Chosen.prototype.generate_random_id = function() {
      var string;
      string = "sel" + this.generate_random_char() + this.generate_random_char() + this.generate_random_char();
      while ($("#" + string).length > 0) {
        string += this.generate_random_char();
      }
      return string;
    };

    /*
      SILVERSTRIPE CUSTOM FUNCTION
        Rise_up function handles the case where a dropdown exceeds the height of the window
          # Adds class if true, returns true
          # Removes class if false, returns false 
        This facilitates the behaviour where the drop-down will drop up if there is no room 
        to drop down
    */


    Chosen.prototype.rise_up = function(container, dropdown) {
      var elHeight, elPos, endOfWindow, trigger;
      trigger = container.find('a.chzn-single');
      if (trigger.length > 0) {
        endOfWindow = ($(window).height() + $(document).scrollTop()) - container.find('a').innerHeight();
        elPos = trigger.offset().top;
        elHeight = dropdown.innerHeight();
        if (elPos + elHeight > endOfWindow && elPos - elHeight > 0) {
          container.addClass('chzn-with-rise');
          return true;
        } else {
          container.removeClass('chzn-with-rise');
          return false;
        }
      } else {
        return false;
      }
    };

    return Chosen;

  })(AbstractChosen);

  get_side_border_padding = function(elmt) {
    var side_border_padding;
    return side_border_padding = elmt.outerWidth() - elmt.width();
  };

  root.get_side_border_padding = get_side_border_padding;

// Origional - 'this' !== 'window' in browserify
//}).call(this);

// SilverStripe custom
}).call(window);

},{}],5:[function(require,module,exports){
/**
 * @preserve jLayout Border Layout - JavaScript Layout Algorithms v0.4
 *
 * Licensed under the new BSD License.
 * Copyright 2008-2009, Bram Stein
 * All rights reserved.
 */
/*global jLayout:true */
(function () {
	// Customised
	// Defining global alias because Browserify adds 'use strict'
	// which throws a runtime error if globals are undefined and not declared.

	// Original
	// jLayout = (typeof jLayout === 'undefined') ? {} : jLayout;

	window.jLayout = (typeof window.jLayout === 'undefined') ? {} : window.jLayout;

	jLayout.border = function (spec) {
		var my = {},
			that = {},
			east = spec.east,
			west = spec.west,
			north = spec.north,
			south = spec.south,
			center = spec.center;

		my.hgap = spec.hgap || 0;
		my.vgap = spec.vgap || 0;

		that.items = function () {
			var items = [];
			if (east) {
				items.push(east);
			}

			if (west) {
				items.push(west);
			}

			if (north) {
				items.push(north);
			}

			if (south) {
				items.push(south);
			}

			if (center) {
				items.push(center);
			}
			return items;
		};		

		that.layout = function (container) {
			var size = container.bounds(),
				insets = container.insets(),
				top = insets.top,
				bottom = size.height - insets.bottom,
				left = insets.left,
				right = size.width - insets.right,
				tmp;

			if (north && north.isVisible()) {
				tmp = north.preferredSize();
				north.bounds({'x': left, 'y': top, 'width': right - left, 'height': tmp.height});
				north.doLayout();

				top += tmp.height + my.vgap;
			}
			if (south && south.isVisible()) {
				tmp = south.preferredSize();
				south.bounds({'x': left, 'y': bottom - tmp.height, 'width': right - left, 'height': tmp.height});
				south.doLayout();

				bottom -= tmp.height + my.vgap;
			}
			if (east && east.isVisible()) {
				tmp = east.preferredSize();
				east.bounds({'x': right - tmp.width, 'y': top, 'width': tmp.width, 'height': bottom - top});
				east.doLayout();

				right -= tmp.width + my.hgap;
			}
			if (west && west.isVisible()) {
				tmp = west.preferredSize();
				west.bounds({'x': left, 'y': top, 'width': tmp.width, 'height': bottom - top});
				west.doLayout();

				left += tmp.width + my.hgap;
			}
			if (center && center.isVisible()) {
				center.bounds({'x': left, 'y': top, 'width': right - left, 'height': bottom - top});
				center.doLayout();
			}
			return container;
		};

		function typeLayout(type) {
			return function (container) {
				var insets = container.insets(),
					width = 0,
					height = 0,
					type_size;

				if (east && east.isVisible()) {
					type_size = east[type + 'Size']();
					width += type_size.width + my.hgap;
					height = type_size.height;
				}
				if (west && west.isVisible()) {
					type_size = west[type + 'Size']();
					width += type_size.width + my.hgap;
					height = Math.max(type_size.height, height);
				}
				if (center && center.isVisible()) {
					type_size = center[type + 'Size']();
					width += type_size.width;
					height = Math.max(type_size.height, height);
				}
				if (north && north.isVisible()) {
					type_size = north[type + 'Size']();
					width = Math.max(type_size.width, width);
					height += type_size.height + my.vgap;
				}
				if (south && south.isVisible()) {
					type_size = south[type + 'Size']();
					width = Math.max(type_size.width, width);
					height += type_size.height + my.vgap;
				}

				return {
					'width': width + insets.left + insets.right, 
					'height': height + insets.top + insets.bottom
				};
			};
		}
		that.preferred = typeLayout('preferred');
		that.minimum = typeLayout('minimum');
		that.maximum = typeLayout('maximum');
		return that;
	};
}());

},{}],6:[function(require,module,exports){
/**
 * @preserve jLayout JQuery Plugin v0.17
 *
 * Licensed under the new BSD License.
 * Copyright 2008-2009 Bram Stein
 * All rights reserved.
 */
/*global jQuery jLayout*/

// Customised
// Defining global alias because Browserify adds 'use strict'
// which throws a runtime error if globals are undefined and not declared.
var jQuery = window.jQuery,
	jLayout = window.jLayout;

if (jQuery && jLayout) {
	(function ($) {
		/**
		 * This wraps jQuery objects in another object that supplies
		 * the methods required for the layout algorithms.
		 */
		// CUSTOM hfriedlander 2012-10-26 for side-by-side editing.
		// function wrap(item, resize) {
		var wrap = $.jLayoutWrap = function(item, resize) {
		// CUSTOM END
			var that = {};
			// CUSTOM hfriedlander 2012-10-26 for side-by-side editing.
			that.item = item;
			// CUSTOM END

			$.each(['min', 'max'], function (i, name) {
				that[name + 'imumSize'] = function (value) {
                    var l = item.data('jlayout');
                    
					if (l) {
						return l[name + 'imum'](that);
					} else {
						return item[name + 'Size'](value);
					}
				};
			});

			$.extend(that, {
				doLayout: function () {
					// CUSTOM hfriedlander 2012-10-26 for side-by-side editing.
					//var l = item.data('jlayout');
					//
					//if (l) {
					//	l.layout(that);
					//}
					//
					var l = item.data('jlayout');
					if (l) l.layout(that);
					else if (item.is('[data-layout-type]')) {
						item.layout({resize: false});
					}
					// CUSTOM END

					item.css({position: 'absolute'});
				},
				isVisible: function () {
					return item.isVisible();
				},
				insets: function () {
					var p = item.padding(),
						b = item.border();

					return {
                        'top': p.top, 
						'bottom': p.bottom + b.bottom + b.top, 
						'left': p.left, 
						'right': p.right + b.right + b.left
                    };
				},
				bounds: function (value) {
					var tmp = {};

					if (value) {
						if (typeof value.x === 'number') {
							tmp.left = value.x;
						}
						if (typeof value.y === 'number') {
							tmp.top = value.y;
						}
						if (typeof value.width === 'number') {
							tmp.width = (value.width - (item.outerWidth(true) - item.width()));
							tmp.width = (tmp.width >= 0) ? tmp.width : 0;
						}
						if (typeof value.height === 'number') {
							tmp.height = value.height - (item.outerHeight(true) - item.height());
							tmp.height = (tmp.height >= 0) ? tmp.height : 0;
						}
						item.css(tmp);
						return item;
					} else {
						tmp = item.position();
						return {
							'x': tmp.left,
							'y': tmp.top,
							'width': item.outerWidth(false),
							'height': item.outerHeight(false)
                        };
					}
				},
				preferredSize: function () {
					var minSize,
						maxSize,
						margin = item.margin(),
						size = {width: 0, height: 0},
                        l = item.data('jlayout');

					if (l && resize) {
						size = l.preferred(that);

						minSize = that.minimumSize();
						maxSize = that.maximumSize();

						size.width += margin.left + margin.right;
						size.height += margin.top + margin.bottom;

						if (size.width < minSize.width || size.height < minSize.height) {
							size.width = Math.max(size.width, minSize.width);
							size.height = Math.max(size.height, minSize.height);
						} else if (size.width > maxSize.width || size.height > maxSize.height) {
							size.width = Math.min(size.width, maxSize.width);
							size.height = Math.min(size.height, maxSize.height);
						}
					} else {
                        size = that.bounds();
						size.width += margin.left + margin.right;
						size.height += margin.top + margin.bottom;
					}
					return size;
				}
			});
			return that;
		}

		$.fn.layout = function (options) {
			var opts = $.extend({}, $.fn.layout.defaults, options);
			return $.each(this, function () {
				var element = $(this),
					o = $.metadata && element.metadata().layout ? $.extend(opts, element.metadata().layout) : opts,
					// CUSTOM ischommer 2012-16-02 Allow type setting throgh built-in jQuery HTML5 data getters, to avoid including jQuery.metadata.js
					o = element.data('layoutType') ? $.extend(o, {type: element.data('layoutType')}) : o,
					// CUSTOM END
					elementWrapper = wrap(element, o.resize);
				if (o.type === 'border' && typeof jLayout.border !== 'undefined') {                
					$.each(['north', 'south', 'west', 'east', 'center'], function (i, name) {
						if (element.children().hasClass(name)) {
							o[name] = wrap(element.children('.' + name + ':first'));
						}
					});
					element.data('jlayout', jLayout.border(o));
				} else if (o.type === 'grid' && typeof jLayout.grid !== 'undefined') {
					o.items = [];
					element.children().each(function (i) {
						if (!$(this).hasClass('ui-resizable-handle')) {
							o.items[i] = wrap($(this));
						}
					});
					element.data('jlayout', jLayout.grid(o));
				} else if (o.type === 'flexGrid' && typeof jLayout.flexGrid !== 'undefined') {
					o.items = [];
					element.children().each(function (i) {
						if (!$(this).hasClass('ui-resizable-handle')) {
							o.items[i] = wrap($(this));
						}
					});
					element.data('jlayout', jLayout.flexGrid(o));
				} else if (o.type === 'column' && typeof jLayout.column !== 'undefined') {
					o.items = [];
					element.children().each(function (i) {
						if (!$(this).hasClass('ui-resizable-handle')) {
							o.items[i] = wrap($(this));
						}
					});
					element.data('jlayout', jLayout.column(o));
				} else if (o.type === 'flow' && typeof jLayout.flow !== 'undefined') {
					o.items = [];
					element.children().each(function (i) {
						if (!$(this).hasClass('ui-resizable-handle')) {
							o.items[i] = wrap($(this));
						}
					});
					element.data('jlayout', jLayout.flow(o));					
				}
                
				if (o.resize) {
					elementWrapper.bounds(elementWrapper.preferredSize());
				}
                
				elementWrapper.doLayout();
				element.css({position: 'relative'});
				if ($.ui !== undefined) {
					element.addClass('ui-widget');
				}
			});
		};

		$.fn.layout.defaults = {
			resize: true,
			type: 'grid'
		};
	}(jQuery));
}

},{}],7:[function(require,module,exports){
/**
* hoverIntent is similar to jQuery's built-in "hover" function except that
* instead of firing the onMouseOver event immediately, hoverIntent checks
* to see if the user's mouse has slowed down (beneath the sensitivity
* threshold) before firing the onMouseOver event.
*
* hoverIntent r6 // 2011.02.26 // jQuery 1.5.1+
* <http://cherne.net/brian/resources/jquery.hoverIntent.html>
*
* hoverIntent is currently available for use in all personal or commercial
* projects under both MIT and GPL licenses. This means that you can choose
* the license that best suits your project, and use it accordingly.
*
* // basic usage (just like .hover) receives onMouseOver and onMouseOut functions
* $("ul li").hoverIntent( showNav , hideNav );
*
* // advanced usage receives configuration object only
* $("ul li").hoverIntent({
*	sensitivity: 7, // number = sensitivity threshold (must be 1 or higher)
*	interval: 100,   // number = milliseconds of polling interval
*	over: showNav,  // function = onMouseOver callback (required)
*	timeout: 350,   // number = milliseconds delay before onMouseOut function call
*	out: hideNav    // function = onMouseOut callback (required)
* });
*
* @param  f  onMouseOver function || An object with configuration options
* @param  g  onMouseOut function  || Nothing (use configuration options object)
* @author    Brian Cherne brian(at)cherne(dot)net
*/
(function($) {
	$.fn.hoverIntent = function(f,g) {
		// default configuration options
		var cfg = {
			sensitivity: 7,
			interval: 100,
			timeout: 350
		};
		// override configuration options with user supplied object
		cfg = $.extend(cfg, g ? { over: f, out: g } : f );

		// instantiate variables
		// cX, cY = current X and Y position of mouse, updated by mousemove event
		// pX, pY = previous X and Y position of mouse, set by mouseover and polling interval
		var cX, cY, pX, pY;

		// A private function for getting mouse position
		var track = function(ev) {
			cX = ev.pageX;
			cY = ev.pageY;
		};

		// A private function for comparing current and previous mouse position
		var compare = function(ev,ob) {
			ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
			// compare mouse positions to see if they've crossed the threshold
			if ( ( Math.abs(pX-cX) + Math.abs(pY-cY) ) < cfg.sensitivity ) {
				$(ob).unbind("mousemove",track);
				// set hoverIntent state to true (so mouseOut can be called)
				ob.hoverIntent_s = 1;
				return cfg.over.apply(ob,[ev]);
			} else {
				// set previous coordinates for next time
				pX = cX; pY = cY;
				// use self-calling timeout, guarantees intervals are spaced out properly (avoids JavaScript timer bugs)
				ob.hoverIntent_t = setTimeout( function(){compare(ev, ob);} , cfg.interval );
			}
		};

		// A private function for delaying the mouseOut function
		var delay = function(ev,ob) {
			ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
			ob.hoverIntent_s = 0;
			return cfg.out.apply(ob,[ev]);
		};

		// A private function for handling mouse 'hovering'
		var handleHover = function(e) {
			// copy objects to be passed into t (required for event object to be passed in IE)
			var ev = jQuery.extend({},e);
			var ob = this;

			// cancel hoverIntent timer if it exists
			if (ob.hoverIntent_t) { ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t); }

			// if e.type == "mouseenter"
			if (e.type == "mouseenter") {
				// set "previous" X and Y position based on initial entry point
				pX = ev.pageX; pY = ev.pageY;
				// update "current" X and Y position based on mousemove
				$(ob).bind("mousemove",track);
				// start polling interval (self-calling timeout) to compare mouse coordinates over time
				if (ob.hoverIntent_s != 1) { ob.hoverIntent_t = setTimeout( function(){compare(ev,ob);} , cfg.interval );}

			// else e.type == "mouseleave"
			} else {
				// unbind expensive mousemove event
				$(ob).unbind("mousemove",track);
				// if hoverIntent state is true, then call the mouseOut function after the specified delay
				if (ob.hoverIntent_s == 1) { ob.hoverIntent_t = setTimeout( function(){delay(ev,ob);} , cfg.timeout );}
			}
		};

		// bind the function to the two event listeners
		return this.bind('mouseenter',handleHover).bind('mouseleave',handleHover);
	};
})(jQuery);
},{}],8:[function(require,module,exports){
/**
*	jQuery.noticeAdd() and jQuery.noticeRemove()
*	These functions create and remove growl-like notices
*		
*   Copyright (c) 2009 Tim Benniks
*
*	Permission is hereby granted, free of charge, to any person obtaining a copy
*	of this software and associated documentation files (the "Software"), to deal
*	in the Software without restriction, including without limitation the rights
*	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*	copies of the Software, and to permit persons to whom the Software is
*	furnished to do so, subject to the following conditions:
*
*	The above copyright notice and this permission notice shall be included in
*	all copies or substantial portions of the Software.
*
*	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*	THE SOFTWARE.
*	
*	@author 	Tim Benniks <tim@timbenniks.com>
* 	@copyright  2009 timbenniks.com
*	@version    $Id: jquery.notice.js 1 2009-01-24 12:24:18Z timbenniks $
**/
(function(jQuery)
{
	jQuery.extend({			
		noticeAdd: function(options)
		{	
			var defaults = {
				inEffect: 			{opacity: 'show'},	// in effect
				inEffectDuration: 	600,				// in effect duration in miliseconds
				stayTime: 			3000,				// time in miliseconds before the item has to disappear
				text: 				'',					// content of the item
				stay: 				false,				// should the notice item stay or not?
				type: 				'notice' 			// could also be error, succes
			}
			
			// declare varaibles
			var options, noticeWrapAll, noticeItemOuter, noticeItemInner, noticeItemClose, hover = false;
			
			options 		= jQuery.extend({}, defaults, options);
			noticeWrapAll	= (!jQuery('.notice-wrap').length) ? jQuery('<div></div>').addClass('notice-wrap').appendTo('body') : jQuery('.notice-wrap');
			noticeItemOuter	= jQuery('<div></div>').addClass('notice-item-wrapper');
			noticeItemInner	= jQuery('<div></div>').hide().addClass('notice-item ' + options.type).appendTo(noticeWrapAll).html('<p>'+options.text+'</p>').animate(options.inEffect, options.inEffectDuration).wrap(noticeItemOuter);
			noticeItemClose	= jQuery('<div></div>').addClass('notice-item-close').prependTo(noticeItemInner).html('x').click(function() { jQuery.noticeRemove(noticeItemInner) });
			
			noticeItemInner.hover(function() {
				hover = true;
			}, function () {
				hover = false;
			});

			if (!options.stay) {
				setTimeout( function () {
					var noticeHover = setInterval(function () {
						if(!hover) {
							jQuery.noticeRemove(noticeItemInner);
							clearInterval(noticeHover);
						}
					}, 1000);
				}, options.stayTime);
			}
		},
		
		noticeRemove: function(obj)
		{
			obj.animate({opacity: '0'}, 600, function()
			{
				obj.parent().animate({height: '0px'}, 300, function()
				{
					obj.parent().remove();
				});
			});
		}
	});
})(jQuery);
},{}],9:[function(require,module,exports){
/**
 * @preserve JSizes - JQuery plugin v0.33
 *
 * Licensed under the revised BSD License.
 * Copyright 2008-2010 Bram Stein
 * All rights reserved.
 */
/*global jQuery*/
(function ($) {
	'use strict';
	var num = function (value) {
			return parseInt(value, 10) || 0;
		};

	/**
	 * Sets or gets the values for min-width, min-height, max-width
	 * and max-height.
	 */
	$.each(['min', 'max'], function (i, name) {
		$.fn[name + 'Size'] = function (value) {
			var width, height;
			if (value) {
				if (value.width !== undefined) {
					this.css(name + '-width', value.width);
				}
				if (value.height !== undefined) {
					this.css(name + '-height', value.height);
				}
			} else {
				width = this.css(name + '-width');
				height = this.css(name + '-height');
				// Apparently:
				//  * Opera returns -1px instead of none
				//  * IE6 returns undefined instead of none
				return {'width': (name === 'max' && (width === undefined || width === 'none' || num(width) === -1) && Number.MAX_VALUE) || num(width), 
						'height': (name === 'max' && (height === undefined || height === 'none' || num(height) === -1) && Number.MAX_VALUE) || num(height)};
			}
			return this;
		};
	});

	/**
	 * Returns whether or not an element is visible.
	 */
	$.fn.isVisible = function () {
		return this.is(':visible');
	};

	/**
	 * Sets or gets the values for border, margin and padding.
	 */
	$.each(['border', 'margin', 'padding'], function (i, name) {
		$.fn[name] = function (value) {
			if (value) {
				if (value.top !== undefined) {
					this.css(name + '-top' + (name === 'border' ? '-width' : ''), value.top);
				}
				if (value.bottom !== undefined) {
					this.css(name + '-bottom' + (name === 'border' ? '-width' : ''), value.bottom);
				}
				if (value.left !== undefined) {
					this.css(name + '-left' + (name === 'border' ? '-width' : ''), value.left);
				}
				if (value.right !== undefined) {
					this.css(name + '-right' + (name === 'border' ? '-width' : ''), value.right);
				}
			} else {
				return {top: num(this.css(name + '-top' + (name === 'border' ? '-width' : ''))),
						bottom: num(this.css(name + '-bottom' + (name === 'border' ? '-width' : ''))),
						left: num(this.css(name + '-left' + (name === 'border' ? '-width' : ''))),
						right: num(this.css(name + '-right' + (name === 'border' ? '-width' : '')))};
			}
			return this;
		};
	});
}(jQuery));

},{}],10:[function(require,module,exports){
'use strict';

var _jQuery = require('./jQuery');

var _jQuery2 = _interopRequireDefault(_jQuery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_jQuery2.default.fn.extend({
	ssDatepicker: function ssDatepicker(opts) {
		return (0, _jQuery2.default)(this).each(function () {
			if ((0, _jQuery2.default)(this).data('datepicker')) return;

			(0, _jQuery2.default)(this).siblings("button").addClass("ui-icon ui-icon-calendar");

			var holder = (0, _jQuery2.default)(this).parents('.field.date:first'),
			    config = _jQuery2.default.extend(opts || {}, (0, _jQuery2.default)(this).data(), (0, _jQuery2.default)(this).data('jqueryuiconfig'), {});
			if (!config.showcalendar) return;

			if (config.locale && _jQuery2.default.datepicker.regional[config.locale]) {
				config = _jQuery2.default.extend(config, _jQuery2.default.datepicker.regional[config.locale], {});
			}

			if (config.min) config.minDate = _jQuery2.default.datepicker.parseDate('yy-mm-dd', config.min);
			if (config.max) config.maxDate = _jQuery2.default.datepicker.parseDate('yy-mm-dd', config.max);

			config.dateFormat = config.jquerydateformat;
			(0, _jQuery2.default)(this).datepicker(config);
		});
	}
});

(0, _jQuery2.default)(document).on("click", ".field.date input.text,input.text.date", function () {
	(0, _jQuery2.default)(this).ssDatepicker();

	if ((0, _jQuery2.default)(this).data('datepicker')) {
		(0, _jQuery2.default)(this).datepicker('show');
	}
});

},{"./jQuery":"jQuery"}],11:[function(require,module,exports){
'use strict';

var _jQuery = require('./jQuery');

var _jQuery2 = _interopRequireDefault(_jQuery);

var _i18n = require('./i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_jQuery2.default.entwine('ss', function ($) {
	$('.ss-gridfield').entwine({

		reload: function reload(ajaxOpts, successCallback) {
			var self = this,
			    form = this.closest('form'),
			    focusedElName = this.find(':input:focus').attr('name'),
			    data = form.find(':input').serializeArray();

			if (!ajaxOpts) ajaxOpts = {};
			if (!ajaxOpts.data) ajaxOpts.data = [];
			ajaxOpts.data = ajaxOpts.data.concat(data);

			if (window.location.search) {
				ajaxOpts.data = window.location.search.replace(/^\?/, '') + '&' + $.param(ajaxOpts.data);
			}

			form.addClass('loading');

			$.ajax($.extend({}, {
				headers: { "X-Pjax": 'CurrentField' },
				type: "POST",
				url: this.data('url'),
				dataType: 'html',
				success: function success(data) {
					self.empty().append($(data).children());

					if (focusedElName) self.find(':input[name="' + focusedElName + '"]').focus();

					if (self.find('.filter-header').length) {
						var content;
						if (ajaxOpts.data[0].filter == "show") {
							content = '<span class="non-sortable"></span>';
							self.addClass('show-filter').find('.filter-header').show();
						} else {
							content = '<button type="button" name="showFilter" class="ss-gridfield-button-filter trigger"></button>';
							self.removeClass('show-filter').find('.filter-header').hide();
						}

						self.find('.sortable-header th:last').html(content);
					}

					form.removeClass('loading');
					if (successCallback) successCallback.apply(this, arguments);
					self.trigger('reload', self);
				},
				error: function error(e) {
					alert(_i18n2.default._t('GRIDFIELD.ERRORINTRANSACTION'));
					form.removeClass('loading');
				}
			}, ajaxOpts));
		},
		showDetailView: function showDetailView(url) {
			window.location.href = url;
		},
		getItems: function getItems() {
			return this.find('.ss-gridfield-item');
		},

		setState: function setState(k, v) {
			var state = this.getState();
			state[k] = v;
			this.find(':input[name="' + this.data('name') + '[GridState]"]').val(JSON.stringify(state));
		},

		getState: function getState() {
			return JSON.parse(this.find(':input[name="' + this.data('name') + '[GridState]"]').val());
		}
	});

	$('.ss-gridfield *').entwine({
		getGridField: function getGridField() {
			return this.closest('.ss-gridfield');
		}
	});

	$('.ss-gridfield :button[name=showFilter]').entwine({
		onclick: function onclick(e) {
			$('.filter-header').show('slow').find(':input:first').focus();
			this.closest('.ss-gridfield').addClass('show-filter');
			this.parent().html('<span class="non-sortable"></span>');
			e.preventDefault();
		}
	});

	$('.ss-gridfield .ss-gridfield-item').entwine({
		onclick: function onclick(e) {
			if ($(e.target).closest('.action').length) {
				this._super(e);
				return false;
			}

			var editLink = this.find('.edit-link');
			if (editLink.length) this.getGridField().showDetailView(editLink.prop('href'));
		},
		onmouseover: function onmouseover() {
			if (this.find('.edit-link').length) this.css('cursor', 'pointer');
		},
		onmouseout: function onmouseout() {
			this.css('cursor', 'default');
		}
	});

	$('.ss-gridfield .action').entwine({
		onclick: function onclick(e) {
			var filterState = 'show';
			if (this.button('option', 'disabled')) {
				e.preventDefault();
				return;
			}

			if (this.hasClass('ss-gridfield-button-close') || !this.closest('.ss-gridfield').hasClass('show-filter')) {
				filterState = 'hidden';
			}

			this.getGridField().reload({ data: [{ name: this.attr('name'), value: this.val(), filter: filterState }] });
			e.preventDefault();
		},

		actionurl: function actionurl() {
			var btn = this.closest(':button'),
			    grid = this.getGridField(),
			    form = this.closest('form'),
			    data = form.find(':input.gridstate').serialize(),
			    csrf = form.find('input[name="SecurityID"]').val();

			data += "&" + encodeURIComponent(btn.attr('name')) + '=' + encodeURIComponent(btn.val());

			if (csrf) {
				data += "&SecurityID=" + encodeURIComponent(csrf);
			}

			if (window.location.search) {
				data = window.location.search.replace(/^\?/, '') + '&' + data;
			}

			var connector = grid.data('url').indexOf('?') == -1 ? '?' : '&';

			return $.path.makeUrlAbsolute(grid.data('url') + connector + data, $('base').attr('href'));
		}

	});

	$('.ss-gridfield .add-existing-autocompleter').entwine({
		onbuttoncreate: function onbuttoncreate() {
			var self = this;

			this.toggleDisabled();

			this.find('input[type="text"]').on('keyup', function () {
				self.toggleDisabled();
			});
		},
		onunmatch: function onunmatch() {
			this.find('input[type="text"]').off('keyup');
		},
		toggleDisabled: function toggleDisabled() {
			var $button = this.find('.ss-ui-button'),
			    $input = this.find('input[type="text"]'),
			    inputHasValue = $input.val() !== '',
			    buttonDisabled = $button.is(':disabled');

			if (inputHasValue && buttonDisabled || !inputHasValue && !buttonDisabled) {
				$button.button("option", "disabled", !buttonDisabled);
			}
		}
	});

	$('.ss-gridfield .col-buttons .action.gridfield-button-delete, .cms-edit-form .Actions button.action.action-delete').entwine({
		onclick: function onclick(e) {
			if (!confirm(_i18n2.default._t('TABLEFIELD.DELETECONFIRMMESSAGE'))) {
				e.preventDefault();
				return false;
			} else {
				this._super(e);
			}
		}
	});

	$('.ss-gridfield .action.gridfield-button-print').entwine({
		UUID: null,
		onmatch: function onmatch() {
			this._super();
			this.setUUID(new Date().getTime());
		},
		onunmatch: function onunmatch() {
			this._super();
		},
		onclick: function onclick(e) {
			var url = this.actionurl();
			window.open(url);
			e.preventDefault();
			return false;
		}
	});

	$('.ss-gridfield-print-iframe').entwine({
		onmatch: function onmatch() {
			this._super();

			this.hide().bind('load', function () {
				this.focus();
				var ifWin = this.contentWindow || this;
				ifWin.print();
			});
		},
		onunmatch: function onunmatch() {
			this._super();
		}
	});

	$('.ss-gridfield .action.no-ajax').entwine({
		onclick: function onclick(e) {
			window.location.href = this.actionurl();
			e.preventDefault();
			return false;
		}
	});

	$('.ss-gridfield .action-detail').entwine({
		onclick: function onclick() {
			this.getGridField().showDetailView($(this).prop('href'));
			return false;
		}
	});

	$('.ss-gridfield[data-selectable]').entwine({
		getSelectedItems: function getSelectedItems() {
			return this.find('.ss-gridfield-item.ui-selected');
		},

		getSelectedIDs: function getSelectedIDs() {
			return $.map(this.getSelectedItems(), function (el) {
				return $(el).data('id');
			});
		}
	});
	$('.ss-gridfield[data-selectable] .ss-gridfield-items').entwine({
		onadd: function onadd() {
			this._super();

			this.selectable();
		},
		onremove: function onremove() {
			this._super();
			if (this.data('selectable')) this.selectable('destroy');
		}
	});

	$('.ss-gridfield .filter-header :input').entwine({
		onmatch: function onmatch() {
			var filterbtn = this.closest('.fieldgroup').find('.ss-gridfield-button-filter'),
			    resetbtn = this.closest('.fieldgroup').find('.ss-gridfield-button-reset');

			if (this.val()) {
				filterbtn.addClass('filtered');
				resetbtn.addClass('filtered');
			}
			this._super();
		},
		onunmatch: function onunmatch() {
			this._super();
		},
		onkeydown: function onkeydown(e) {
			if (this.closest('.ss-gridfield-button-reset').length) return;

			var filterbtn = this.closest('.fieldgroup').find('.ss-gridfield-button-filter'),
			    resetbtn = this.closest('.fieldgroup').find('.ss-gridfield-button-reset');

			if (e.keyCode == '13') {
				var btns = this.closest('.filter-header').find('.ss-gridfield-button-filter');
				var filterState = 'show';
				if (this.hasClass('ss-gridfield-button-close') || !this.closest('.ss-gridfield').hasClass('show-filter')) {
					filterState = 'hidden';
				}

				this.getGridField().reload({ data: [{ name: btns.attr('name'), value: btns.val(), filter: filterState }] });
				return false;
			} else {
				filterbtn.addClass('hover-alike');
				resetbtn.addClass('hover-alike');
			}
		}
	});

	$(".ss-gridfield .relation-search").entwine({
		onfocusin: function onfocusin(event) {
			this.autocomplete({
				source: function source(request, response) {
					var searchField = $(this.element);
					var form = $(this.element).closest("form");
					$.ajax({
						headers: {
							"X-Pjax": 'Partial'
						},
						type: "GET",
						url: $(searchField).data('searchUrl'),
						data: encodeURIComponent(searchField.attr('name')) + '=' + encodeURIComponent(searchField.val()),
						success: function success(data) {
							response($.map(JSON.parse(data), function (name, id) {
								return { label: name, value: name, id: id };
							}));
						},
						error: function error(e) {
							alert(_i18n2.default._t('GRIDFIELD.ERRORINTRANSACTION', 'An error occured while fetching data from the server\n Please try again later.'));
						}
					});
				},
				select: function select(event, ui) {
					$(this).closest(".ss-gridfield").find("#action_gridfield_relationfind").replaceWith('<input type="hidden" name="relationID" value="' + ui.item.id + '" id="relationID"/>');
					var addbutton = $(this).closest(".ss-gridfield").find("#action_gridfield_relationadd");
					if (addbutton.data('button')) {
						addbutton.button('enable');
					} else {
						addbutton.removeAttr('disabled');
					}
				}
			});
		}
	});

	$(".ss-gridfield .pagination-page-number input").entwine({
		onkeydown: function onkeydown(event) {
			if (event.keyCode == 13) {
				var newpage = parseInt($(this).val(), 10);

				var gridfield = $(this).getGridField();
				gridfield.setState('GridFieldPaginator', { currentPage: newpage });
				gridfield.reload();

				return false;
			}
		}
	});
});

},{"./i18n":"i18n","./jQuery":"jQuery"}],12:[function(require,module,exports){
'use strict';

var _jQuery = require('./jQuery');

var _jQuery2 = _interopRequireDefault(_jQuery);

var _i18n = require('./i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ss = typeof window.ss !== 'undefined' ? window.ss : {};

ss.editorWrappers = {};
ss.editorWrappers.tinyMCE = function () {
	var editorID;

	return {
		init: function init(ID) {
			editorID = ID;

			this.create();
		},

		destroy: function destroy() {
			tinymce.EditorManager.execCommand('mceRemoveEditor', false, editorID);
		},

		getInstance: function getInstance() {
			return tinymce.EditorManager.get(editorID);
		},

		onopen: function onopen() {},

		onclose: function onclose() {},

		getConfig: function getConfig() {
			var selector = "#" + editorID,
			    config = (0, _jQuery2.default)(selector).data('config'),
			    self = this;

			config.selector = selector;

			config.setup = function (ed) {
				ed.on('change', function () {
					self.save();
				});
			};
			return config;
		},

		save: function save() {
			var instance = this.getInstance();
			instance.save();

			(0, _jQuery2.default)(instance.getElement()).trigger("change");
		},

		create: function create() {
			var config = this.getConfig();

			if (typeof config.baseURL !== 'undefined') {
				tinymce.EditorManager.baseURL = config.baseURL;
			}
			tinymce.init(config);
		},

		repaint: function repaint() {},

		isDirty: function isDirty() {
			return this.getInstance().isDirty();
		},

		getContent: function getContent() {
			return this.getInstance().getContent();
		},

		getDOM: function getDOM() {
			return this.getInstance().getElement();
		},

		getContainer: function getContainer() {
			return this.getInstance().getContainer();
		},

		getSelectedNode: function getSelectedNode() {
			return this.getInstance().selection.getNode();
		},

		selectNode: function selectNode(node) {
			this.getInstance().selection.select(node);
		},

		setContent: function setContent(html, opts) {
			this.getInstance().setContent(html, opts);
		},

		insertContent: function insertContent(html, opts) {
			this.getInstance().insertContent(html, opts);
		},

		replaceContent: function replaceContent(html, opts) {
			this.getInstance().execCommand('mceReplaceContent', false, html, opts);
		},

		insertLink: function insertLink(attrs, opts) {
			this.getInstance().execCommand("mceInsertLink", false, attrs, opts);
		},

		removeLink: function removeLink() {
			this.getInstance().execCommand('unlink', false);
		},

		cleanLink: function cleanLink(href, node) {
			var settings = this.getConfig,
			    cb = settings['urlconverter_callback'];
			if (cb) href = eval(cb + "(href, node, true);");

			if (href.match(new RegExp('^' + tinyMCE.settings['document_base_url'] + '(.*)$'))) {
				href = RegExp.$1;
			}

			if (href.match(/^javascript:\s*mctmp/)) href = '';

			return href;
		},

		createBookmark: function createBookmark() {
			return this.getInstance().selection.getBookmark();
		},

		moveToBookmark: function moveToBookmark(bookmark) {
			this.getInstance().selection.moveToBookmark(bookmark);
			this.getInstance().focus();
		},

		blur: function blur() {
			this.getInstance().selection.collapse();
		},

		addUndo: function addUndo() {
			this.getInstance().undoManager.add();
		}
	};
};

ss.editorWrappers['default'] = ss.editorWrappers.tinyMCE;

_jQuery2.default.entwine('ss', function ($) {
	$('textarea.htmleditor').entwine({

		Editor: null,

		onadd: function onadd() {
			var edClass = this.data('editor') || 'default',
			    ed = ss.editorWrappers[edClass]();
			this.setEditor(ed);

			ed.init(this.attr('id'));

			this._super();
		},

		onremove: function onremove() {
			this.getEditor().destroy();
			this._super();
		},

		'from .cms-edit-form': {
			onbeforesubmitform: function onbeforesubmitform() {
				this.getEditor().save();
				this._super();
			}
		},

		openLinkDialog: function openLinkDialog() {
			this.openDialog('link');
		},

		openMediaDialog: function openMediaDialog() {
			this.openDialog('media');
		},

		openDialog: function openDialog(type) {
			var capitalize = function capitalize(text) {
				return text.charAt(0).toUpperCase() + text.slice(1).toLowerCase();
			};

			var self = this,
			    url = $('#cms-editor-dialogs').data('url' + capitalize(type) + 'form'),
			    dialog = $('.htmleditorfield-' + type + 'dialog');

			if (dialog.length) {
				dialog.getForm().setElement(this);
				dialog.html('');
				dialog.addClass('loading');
				dialog.open();
			} else {
				dialog = $('<div class="htmleditorfield-dialog htmleditorfield-' + type + 'dialog loading">');
				$('body').append(dialog);
			}

			$.ajax({
				url: url,
				complete: function complete() {
					dialog.removeClass('loading');
				},
				success: function success(html) {
					dialog.html(html);
					dialog.getForm().setElement(self);
					dialog.trigger('ssdialogopen');
				}
			});
		}
	});

	$('.htmleditorfield-dialog').entwine({
		onadd: function onadd() {
			if (!this.is('.ui-dialog-content')) {
				this.ssdialog({
					autoOpen: true,
					buttons: {
						'insert': {
							text: _i18n2.default._t('HtmlEditorField.INSERT', 'Insert'),
							'data-icon': 'accept',
							class: 'ss-ui-action-constructive media-insert',
							click: function click() {
								$(this).find('form').submit();
							}
						}
					}
				});
			}

			this._super();
		},

		getForm: function getForm() {
			return this.find('form');
		},
		open: function open() {
			this.ssdialog('open');
		},
		close: function close() {
			this.ssdialog('close');
		},
		toggle: function toggle(bool) {
			if (this.is(':visible')) this.close();else this.open();
		},
		onscroll: function onscroll() {
			this.animate({
				scrollTop: this.find('form').height()
			}, 500);
		}
	});

	$('form.htmleditorfield-form').entwine({
		Selection: null,

		Bookmark: null,

		Element: null,

		setSelection: function setSelection(node) {
			return this._super($(node));
		},

		onadd: function onadd() {
			var titleEl = this.find(':header:first');
			this.getDialog().attr('title', titleEl.text());

			this._super();
		},
		onremove: function onremove() {
			this.setSelection(null);
			this.setBookmark(null);
			this.setElement(null);

			this._super();
		},

		getDialog: function getDialog() {
			return this.closest('.htmleditorfield-dialog');
		},

		fromDialog: {
			onssdialogopen: function onssdialogopen() {
				var ed = this.getEditor();

				this.setSelection(ed.getSelectedNode());
				this.setBookmark(ed.createBookmark());

				ed.blur();

				this.find(':input:not(:submit)[data-skip-autofocus!="true"]').filter(':visible:enabled').eq(0).focus();

				this.redraw();
				this.updateFromEditor();
			},

			onssdialogclose: function onssdialogclose() {
				var ed = this.getEditor();

				ed.moveToBookmark(this.getBookmark());

				this.setSelection(null);
				this.setBookmark(null);

				this.resetFields();
			}
		},

		getEditor: function getEditor() {
			return this.getElement().getEditor();
		},

		modifySelection: function modifySelection(callback) {
			var ed = this.getEditor();

			ed.moveToBookmark(this.getBookmark());
			callback.call(this, ed);

			this.setSelection(ed.getSelectedNode());
			this.setBookmark(ed.createBookmark());

			ed.blur();
		},

		updateFromEditor: function updateFromEditor() {},
		redraw: function redraw() {},
		resetFields: function resetFields() {
			this.find('.tree-holder').empty();
		}
	});

	$('form.htmleditorfield-linkform').entwine({
		onsubmit: function onsubmit(e) {
			this.insertLink();
			this.getDialog().close();
			return false;
		},
		resetFields: function resetFields() {
			this._super();

			this[0].reset();
		},
		redraw: function redraw() {
			this._super();

			var linkType = this.find(':input[name=LinkType]:checked').val();

			this.addAnchorSelector();

			this.resetFileField();

			this.find('div.content .field').hide();
			this.find('.field[id$="LinkType"]').show();
			this.find('.field[id$="' + linkType + '_Holder"]').show();

			if (linkType == 'internal' || linkType == 'anchor') {
				this.find('.field[id$="Anchor_Holder"]').show();
			}

			if (linkType == 'email') {
				this.find('.field[id$="Subject_Holder"]').show();
			} else {
				this.find('.field[id$="TargetBlank_Holder"]').show();
			}

			if (linkType == 'anchor') {
				this.find('.field[id$="AnchorSelector_Holder"]').show();
			}
			this.find('.field[id$="Description_Holder"]').show();
		},

		getLinkAttributes: function getLinkAttributes() {
			var href,
			    target = null,
			    subject = this.find(':input[name=Subject]').val(),
			    anchor = this.find(':input[name=Anchor]').val();

			if (this.find(':input[name=TargetBlank]').is(':checked')) {
				target = '_blank';
			}

			switch (this.find(':input[name=LinkType]:checked').val()) {
				case 'internal':
					href = '[sitetree_link,id=' + this.find(':input[name=internal]').val() + ']';

					if (anchor) {
						href += '#' + anchor;
					}

					break;

				case 'anchor':
					href = '#' + anchor;
					break;

				case 'file':
					var fileid = this.find('.ss-uploadfield .ss-uploadfield-item').attr('data-fileid');
					href = fileid ? '[file_link,id=' + fileid + ']' : '';
					break;

				case 'email':
					href = 'mailto:' + this.find(':input[name=email]').val();
					if (subject) {
						href += '?subject=' + encodeURIComponent(subject);
					}
					target = null;
					break;

				default:
					href = this.find(':input[name=external]').val();

					if (href.indexOf('://') == -1) href = 'http://' + href;
					break;
			}

			return {
				href: href,
				target: target,
				title: this.find(':input[name=Description]').val()
			};
		},
		insertLink: function insertLink() {
			this.modifySelection(function (ed) {
				ed.insertLink(this.getLinkAttributes());
			});
		},
		removeLink: function removeLink() {
			this.modifySelection(function (ed) {
				ed.removeLink();
			});

			this.resetFileField();
			this.close();
		},

		resetFileField: function resetFileField() {
			var fileField = this.find('.ss-uploadfield[id$="file_Holder"]'),
			    fileUpload = fileField.data('fileupload'),
			    currentItem = fileField.find('.ss-uploadfield-item[data-fileid]');

			if (currentItem.length) {
				fileUpload._trigger('destroy', null, { context: currentItem });
				fileField.find('.ss-uploadfield-addfile').removeClass('borderTop');
			}
		},

		addAnchorSelector: function addAnchorSelector() {
			if (this.find(':input[name=AnchorSelector]').length) return;

			var self = this;
			var anchorSelector = $('<select id="Form_EditorToolbarLinkForm_AnchorSelector" name="AnchorSelector"></select>');
			this.find(':input[name=Anchor]').parent().append(anchorSelector);

			this.updateAnchorSelector();

			anchorSelector.change(function (e) {
				self.find(':input[name="Anchor"]').val($(this).val());
			});
		},

		getAnchors: function getAnchors() {
			var linkType = this.find(':input[name=LinkType]:checked').val();
			var dfdAnchors = $.Deferred();

			switch (linkType) {
				case 'anchor':
					var collectedAnchors = [];
					var ed = this.getEditor();


					if (ed) {
						var raw = ed.getContent().match(/\s+(name|id)\s*=\s*(["'])([^\2\s>]*?)\2|\s+(name|id)\s*=\s*([^"']+)[\s +>]/gim);
						if (raw && raw.length) {
							for (var i = 0; i < raw.length; i++) {
								var indexStart = raw[i].indexOf('id=') == -1 ? 7 : 5;
								collectedAnchors.push(raw[i].substr(indexStart).replace(/"$/, ''));
							}
						}
					}

					dfdAnchors.resolve(collectedAnchors);
					break;

				case 'internal':
					var pageId = this.find(':input[name=internal]').val();

					if (pageId) {
						$.ajax({
							url: $.path.addSearchParams(this.attr('action').replace('LinkForm', 'getanchors'), { 'PageID': parseInt(pageId) }),
							success: function success(body, status, xhr) {
								dfdAnchors.resolve($.parseJSON(body));
							},
							error: function error(xhr, status) {
								dfdAnchors.reject(xhr.responseText);
							}
						});
					} else {
						dfdAnchors.resolve([]);
					}
					break;

				default:
					dfdAnchors.reject(_i18n2.default._t('HtmlEditorField.ANCHORSNOTSUPPORTED', 'Anchors are not supported for this link type.'));
					break;
			}

			return dfdAnchors.promise();
		},

		updateAnchorSelector: function updateAnchorSelector() {
			var self = this;
			var selector = this.find(':input[name=AnchorSelector]');
			var dfdAnchors = this.getAnchors();

			selector.empty();
			selector.append($('<option value="" selected="1">' + _i18n2.default._t('HtmlEditorField.LOOKINGFORANCHORS', 'Looking for anchors...') + '</option>'));

			dfdAnchors.done(function (anchors) {
				selector.empty();
				selector.append($('<option value="" selected="1">' + _i18n2.default._t('HtmlEditorField.SelectAnchor') + '</option>'));

				if (anchors) {
					for (var j = 0; j < anchors.length; j++) {
						selector.append($('<option value="' + anchors[j] + '">' + anchors[j] + '</option>'));
					}
				}
			}).fail(function (message) {
				selector.empty();
				selector.append($('<option value="" selected="1">' + message + '</option>'));
			});

			if ($.browser.msie) selector.hide().show();
		},

		updateFromEditor: function updateFromEditor() {
			var htmlTagPattern = /<\S[^><]*>/g,
			    fieldName,
			    data = this.getCurrentLink();

			if (data) {
				for (fieldName in data) {
					var el = this.find(':input[name=' + fieldName + ']'),
					    selected = data[fieldName];

					if (typeof selected == 'string') selected = selected.replace(htmlTagPattern, '');

					if (el.is(':checkbox')) {
						el.prop('checked', selected).change();
					} else if (el.is(':radio')) {
						el.val([selected]).change();
					} else if (fieldName == 'file') {
						el = this.find(':input[name="' + fieldName + '[Uploads][]"]');

						el = el.parents('.ss-uploadfield');

						(function attach(el, selected) {
							if (!el.getConfig()) {
								setTimeout(function () {
									attach(el, selected);
								}, 50);
							} else {
								el.attachFiles([selected]);
							}
						})(el, selected);
					} else {
						el.val(selected).change();
					}
				}
			}
		},

		getCurrentLink: function getCurrentLink() {
			var selectedEl = this.getSelection(),
			    href = "",
			    target = "",
			    title = "",
			    action = "insert",
			    style_class = "";

			var linkDataSource = null;
			if (selectedEl.length) {
				if (selectedEl.is('a')) {
					linkDataSource = selectedEl;
				} else {
						linkDataSource = selectedEl = selectedEl.parents('a:first');
					}
			}
			if (linkDataSource && linkDataSource.length) this.modifySelection(function (ed) {
				ed.selectNode(linkDataSource[0]);
			});

			if (!linkDataSource.attr('href')) linkDataSource = null;

			if (linkDataSource) {
				href = linkDataSource.attr('href');
				target = linkDataSource.attr('target');
				title = linkDataSource.attr('title');
				style_class = linkDataSource.attr('class');
				href = this.getEditor().cleanLink(href, linkDataSource);
				action = "update";
			}

			if (href.match(/^mailto:(.*)$/)) {
				return {
					LinkType: 'email',
					email: RegExp.$1,
					Description: title
				};
			} else if (href.match(/^(assets\/.*)$/) || href.match(/^\[file_link\s*(?:\s*|%20|,)?id=([0-9]+)\]?(#.*)?$/)) {
				return {
					LinkType: 'file',
					file: RegExp.$1,
					Description: title,
					TargetBlank: target ? true : false
				};
			} else if (href.match(/^#(.*)$/)) {
				return {
					LinkType: 'anchor',
					Anchor: RegExp.$1,
					Description: title,
					TargetBlank: target ? true : false
				};
			} else if (href.match(/^\[sitetree_link(?:\s*|%20|,)?id=([0-9]+)\]?(#.*)?$/i)) {
				return {
					LinkType: 'internal',
					internal: RegExp.$1,
					Anchor: RegExp.$2 ? RegExp.$2.substr(1) : '',
					Description: title,
					TargetBlank: target ? true : false
				};
			} else if (href) {
				return {
					LinkType: 'external',
					external: href,
					Description: title,
					TargetBlank: target ? true : false
				};
			} else {
				return null;
			}
		}
	});

	$('form.htmleditorfield-linkform input[name=LinkType]').entwine({
		onclick: function onclick(e) {
			this.parents('form:first').redraw();
			this._super();
		},
		onchange: function onchange() {
			this.parents('form:first').redraw();

			var linkType = this.parent().find(':checked').val();
			if (linkType === 'anchor' || linkType === 'internal') {
				this.parents('form.htmleditorfield-linkform').updateAnchorSelector();
			}
			this._super();
		}
	});

	$('form.htmleditorfield-linkform input[name=internal]').entwine({
		onvalueupdated: function onvalueupdated() {
			this.parents('form.htmleditorfield-linkform').updateAnchorSelector();
			this._super();
		}
	});

	$('form.htmleditorfield-linkform :submit[name=action_remove]').entwine({
		onclick: function onclick(e) {
			this.parents('form:first').removeLink();
			this._super();
			return false;
		}
	});

	$('form.htmleditorfield-mediaform').entwine({
		toggleCloseButton: function toggleCloseButton() {
			var updateExisting = Boolean(this.find('.ss-htmleditorfield-file').length);
			this.find('.overview .action-delete')[updateExisting ? 'hide' : 'show']();
		},
		onsubmit: function onsubmit() {
			this.modifySelection(function (ed) {
				this.find('.ss-htmleditorfield-file').each(function () {
					$(this).insertHTML(ed);
				});
			});

			this.getDialog().close();
			return false;
		},
		updateFromEditor: function updateFromEditor() {
			var self = this,
			    node = this.getSelection();

			if (node.is('img')) {
				var idOrUrl = node.data('id') || node.data('url') || node.attr('src');
				this.showFileView(idOrUrl).done(function (filefield) {
					filefield.updateFromNode(node);
					self.toggleCloseButton();
					self.redraw();
				});
			}
			this.redraw();
		},
		redraw: function redraw(updateExisting) {
			this._super();

			var node = this.getSelection(),
			    hasItems = Boolean(this.find('.ss-htmleditorfield-file').length),
			    editingSelected = node.is('img'),
			    insertingURL = this.hasClass('insertingURL'),
			    header = this.find('.header-edit');

			header[hasItems ? 'show' : 'hide']();

			this.closest('ui-dialog').find('ui-dialog-buttonpane .media-insert').button(hasItems ? 'enable' : 'disable').toggleClass('ui-state-disabled', !hasItems);

			this.find('.htmleditorfield-default-panel')[editingSelected || insertingURL ? 'hide' : 'show']();
			this.find('.htmleditorfield-web-panel')[editingSelected || !insertingURL ? 'hide' : 'show']();

			var mediaFormHeading = this.find('.htmleditorfield-mediaform-heading.insert');

			if (editingSelected) {
				mediaFormHeading.hide();
			} else if (insertingURL) {
				mediaFormHeading.show().text(_i18n2.default._t("HtmlEditorField.INSERTURL")).prepend('<button class="back-button font-icon-left-open no-text" title="' + _i18n2.default._t("HtmlEditorField.BACK") + '"></button>');

				this.find('.htmleditorfield-web-panel input.remoteurl').focus();
			} else {
				mediaFormHeading.show().text(_i18n2.default._t("HtmlEditorField.INSERTFROM")).find('.back-button').remove();
			}

			this.find('.htmleditorfield-mediaform-heading.update')[editingSelected ? 'show' : 'hide']();
			this.find('.ss-uploadfield-item-actions')[editingSelected ? 'hide' : 'show']();
			this.find('.ss-uploadfield-item-name')[editingSelected ? 'hide' : 'show']();
			this.find('.ss-uploadfield-item-preview')[editingSelected ? 'hide' : 'show']();
			this.find('.Actions .media-update')[editingSelected ? 'show' : 'hide']();
			this.find('.ss-uploadfield-item-editform').toggleEditForm(editingSelected);
			this.find('.htmleditorfield-from-cms .field.treedropdown').css('left', $('.htmleditorfield-mediaform-heading:visible').outerWidth());
			this.closest('.ui-dialog').addClass('ss-uploadfield-dropzone');
			this.closest('.ui-dialog').find('.ui-dialog-buttonpane .media-insert .ui-button-text').text([editingSelected ? _i18n2.default._t('HtmlEditorField.UPDATE', 'Update') : _i18n2.default._t('HtmlEditorField.INSERT', 'Insert')]);
		},
		resetFields: function resetFields() {
			this.find('.ss-htmleditorfield-file').remove();
			this.find('.ss-gridfield-items .ui-selected').removeClass('ui-selected');
			this.find('li.ss-uploadfield-item').remove();
			this.redraw();

			this._super();
		},
		getFileView: function getFileView(idOrUrl) {
			return this.find('.ss-htmleditorfield-file[data-id=' + idOrUrl + ']');
		},
		showFileView: function showFileView(idOrUrl) {
			var self = this,
			    params = Number(idOrUrl) == idOrUrl ? { ID: idOrUrl } : { FileURL: idOrUrl };

			var item = $('<div class="ss-htmleditorfield-file loading" />');
			this.find('.content-edit').prepend(item);

			var dfr = $.Deferred();

			$.ajax({
				url: $.path.addSearchParams(this.attr('action').replace(/MediaForm/, 'viewfile'), params),
				success: function success(html, status, xhr) {
					var newItem = $(html).filter('.ss-htmleditorfield-file');
					item.replaceWith(newItem);
					self.redraw();
					dfr.resolve(newItem);
				},
				error: function error() {
					item.remove();
					dfr.reject();
				}
			});

			return dfr.promise();
		}
	});

	$('form.htmleditorfield-mediaform div.ss-upload .upload-url').entwine({
		onclick: function onclick() {
			var form = this.closest('form');

			form.addClass('insertingURL');
			form.redraw();
		}
	});

	$('form.htmleditorfield-mediaform .htmleditorfield-mediaform-heading .back-button').entwine({
		onclick: function onclick() {
			var form = this.closest('form');

			form.removeClass('insertingURL');
			form.redraw();
		}
	});

	$('form.htmleditorfield-mediaform .ss-gridfield-items').entwine({
		onselectableselected: function onselectableselected(e, ui) {
			var form = this.closest('form'),
			    item = $(ui.selected);
			if (!item.is('.ss-gridfield-item')) return;
			form.closest('form').showFileView(item.data('id'));
			form.redraw();

			form.parent().trigger('scroll');
		},
		onselectableunselected: function onselectableunselected(e, ui) {
			var form = this.closest('form'),
			    item = $(ui.unselected);
			if (!item.is('.ss-gridfield-item')) return;
			form.getFileView(item.data('id')).remove();
			form.redraw();
		}
	});

	$('form.htmleditorfield-form.htmleditorfield-mediaform div.ss-assetuploadfield').entwine({
		onfileuploadstop: function onfileuploadstop(e) {
			var form = this.closest('form');

			var editFieldIDs = [];
			form.find('div.content-edit').find('div.ss-htmleditorfield-file').each(function () {
				editFieldIDs.push($(this).data('id'));
			});

			var uploadedFiles = $('.ss-uploadfield-files', this).children('.ss-uploadfield-item');
			uploadedFiles.each(function () {
				var uploadedID = $(this).data('fileid');
				if (uploadedID && $.inArray(uploadedID, editFieldIDs) == -1) {
					$(this).remove();
					form.showFileView(uploadedID);
				}
			});

			form.parent().trigger('scroll');

			form.redraw();
		}

	});

	$('form.htmleditorfield-form.htmleditorfield-mediaform input.remoteurl').entwine({
		onadd: function onadd() {
			this._super();
			this.validate();
		},

		onkeyup: function onkeyup() {
			this.validate();
		},

		onchange: function onchange() {
			this.validate();
		},

		getAddButton: function getAddButton() {
			return this.closest('.CompositeField').find('button.add-url');
		},

		validate: function validate() {
			var val = this.val(),
			    orig = val;

			val = $.trim(val);
			val = val.replace(/^https?:\/\//i, '');
			if (orig !== val) this.val(val);

			this.getAddButton().button(!!val ? 'enable' : 'disable');
			return !!val;
		}
	});

	$('form.htmleditorfield-form.htmleditorfield-mediaform .add-url').entwine({
		getURLField: function getURLField() {
			return this.closest('.CompositeField').find('input.remoteurl');
		},

		onclick: function onclick(e) {
			var urlField = this.getURLField(),
			    container = this.closest('.CompositeField'),
			    form = this.closest('form');

			if (urlField.validate()) {
				container.addClass('loading');
				form.showFileView('http://' + urlField.val()).done(function () {
					container.removeClass('loading');

					form.parent().trigger('scroll');
				});
				form.redraw();
			}

			return false;
		}
	});

	$('form.htmleditorfield-mediaform .ss-htmleditorfield-file').entwine({
		getAttributes: function getAttributes() {},

		getExtraData: function getExtraData() {},

		getHTML: function getHTML() {
			return $('<div>').append($('<a/>').attr({ href: this.data('url') }).text(this.find('.name').text())).html();
		},

		insertHTML: function insertHTML(ed) {
			ed.replaceContent(this.getHTML());
		},

		updateFromNode: function updateFromNode(node) {},

		updateDimensions: function updateDimensions(constrainBy, maxW, maxH) {
			var widthEl = this.find(':input[name=Width]'),
			    heightEl = this.find(':input[name=Height]'),
			    w = widthEl.val(),
			    h = heightEl.val(),
			    aspect;

			if (w && h) {
				if (constrainBy) {
					aspect = heightEl.getOrigVal() / widthEl.getOrigVal();

					if (constrainBy == 'Width') {
						if (maxW && w > maxW) w = maxW;
						h = Math.floor(w * aspect);
					} else if (constrainBy == 'Height') {
						if (maxH && h > maxH) h = maxH;
						w = Math.ceil(h / aspect);
					}
				} else {
					if (maxW && w > maxW) w = maxW;
					if (maxH && h > maxH) h = maxH;
				}

				widthEl.val(w);
				heightEl.val(h);
			}
		}
	});

	$('form.htmleditorfield-mediaform .ss-htmleditorfield-file.image').entwine({
		getAttributes: function getAttributes() {
			var width = this.find(':input[name=Width]').val(),
			    height = this.find(':input[name=Height]').val();
			return {
				'src': this.find(':input[name=URL]').val(),
				'alt': this.find(':input[name=AltText]').val(),
				'width': width ? parseInt(width, 10) : null,
				'height': height ? parseInt(height, 10) : null,
				'title': this.find(':input[name=Title]').val(),
				'class': this.find(':input[name=CSSClass]').val(),
				'data-id': this.find(':input[name=FileID]').val()
			};
		},
		getExtraData: function getExtraData() {
			return {
				'CaptionText': this.find(':input[name=CaptionText]').val()
			};
		},
		getHTML: function getHTML() {},

		insertHTML: function insertHTML(ed) {
			var form = this.closest('form');
			var node = form.getSelection();
			if (!ed) ed = form.getEditor();

			var attrs = this.getAttributes(),
			    extraData = this.getExtraData();

			var replacee = node && node.is('img') ? node : null;
			if (replacee && replacee.parent().is('.captionImage')) replacee = replacee.parent();

			var img = node && node.is('img') ? node : $('<img />');
			img.attr(attrs);

			var container = img.parent('.captionImage'),
			    caption = container.find('.caption');

			if (extraData.CaptionText) {
				if (!container.length) {
					container = $('<div></div>');
				}

				container.attr('class', 'captionImage ' + attrs['class']).css('width', attrs.width);

				if (!caption.length) {
					caption = $('<p class="caption"></p>').appendTo(container);
				}

				caption.attr('class', 'caption ' + attrs['class']).text(extraData.CaptionText);
			} else {
					container = caption = null;
				}

			var replacer = container ? container : img;

			if (replacee && replacee.not(replacer).length) {
				replacee.replaceWith(replacer);
			}

			if (container) {
				container.prepend(img);
			}

			if (!replacee) {
				ed.repaint();
				ed.insertContent($('<div />').append(replacer).html(), { skip_undo: 1 });
			}

			ed.addUndo();
			ed.repaint();
		},
		updateFromNode: function updateFromNode(node) {
			this.find(':input[name=AltText]').val(node.attr('alt'));
			this.find(':input[name=Title]').val(node.attr('title'));
			this.find(':input[name=CSSClass]').val(node.attr('class'));
			this.find(':input[name=Width]').val(node.width());
			this.find(':input[name=Height]').val(node.height());
			this.find(':input[name=CaptionText]').val(node.siblings('.caption:first').text());
			this.find(':input[name=FileID]').val(node.data('id'));
		}
	});

	$('form.htmleditorfield-mediaform .ss-htmleditorfield-file.flash').entwine({
		getAttributes: function getAttributes() {
			var width = this.find(':input[name=Width]').val(),
			    height = this.find(':input[name=Height]').val();
			return {
				'src': this.find(':input[name=URL]').val(),
				'width': width ? parseInt(width, 10) : null,
				'height': height ? parseInt(height, 10) : null,
				'data-fileid': this.find(':input[name=FileID]').val()
			};
		},
		getHTML: function getHTML() {
			var attrs = this.getAttributes();

			var el = tinyMCE.activeEditor.plugins.media.dataToImg({
				'type': 'flash',
				'width': attrs.width,
				'height': attrs.height,
				'params': { 'src': attrs.src },
				'video': { 'sources': [] }
			});

			return $('<div />').append(el).html();
		},
		updateFromNode: function updateFromNode(node) {}
	});

	$('form.htmleditorfield-mediaform .ss-htmleditorfield-file.embed').entwine({
		getAttributes: function getAttributes() {
			var width = this.find(':input[name=Width]').val(),
			    height = this.find(':input[name=Height]').val();
			return {
				'src': this.find('.thumbnail-preview').attr('src'),
				'width': width ? parseInt(width, 10) : null,
				'height': height ? parseInt(height, 10) : null,
				'class': this.find(':input[name=CSSClass]').val(),
				'alt': this.find(':input[name=AltText]').val(),
				'title': this.find(':input[name=Title]').val(),
				'data-fileid': this.find(':input[name=FileID]').val()
			};
		},
		getExtraData: function getExtraData() {
			var width = this.find(':input[name=Width]').val(),
			    height = this.find(':input[name=Height]').val();
			return {
				'CaptionText': this.find(':input[name=CaptionText]').val(),
				'Url': this.find(':input[name=URL]').val(),
				'thumbnail': this.find('.thumbnail-preview').attr('src'),
				'width': width ? parseInt(width, 10) : null,
				'height': height ? parseInt(height, 10) : null,
				'cssclass': this.find(':input[name=CSSClass]').val()
			};
		},
		getHTML: function getHTML() {
			var el,
			    attrs = this.getAttributes(),
			    extraData = this.getExtraData(),
			    imgEl = $('<img />').attr(attrs).addClass('ss-htmleditorfield-file embed');

			$.each(extraData, function (key, value) {
				imgEl.attr('data-' + key, value);
			});

			if (extraData.CaptionText) {
				el = $('<div style="width: ' + attrs['width'] + 'px;" class="captionImage ' + attrs['class'] + '"><p class="caption">' + extraData.CaptionText + '</p></div>').prepend(imgEl);
			} else {
				el = imgEl;
			}
			return $('<div />').append(el).html();
		},
		updateFromNode: function updateFromNode(node) {
			this.find(':input[name=AltText]').val(node.attr('alt'));
			this.find(':input[name=Title]').val(node.attr('title'));
			this.find(':input[name=Width]').val(node.width());
			this.find(':input[name=Height]').val(node.height());
			this.find(':input[name=Title]').val(node.attr('title'));
			this.find(':input[name=CSSClass]').val(node.data('cssclass'));
			this.find(':input[name=FileID]').val(node.data('fileid'));
		}
	});

	$('form.htmleditorfield-mediaform .ss-htmleditorfield-file .dimensions :input').entwine({
		OrigVal: null,
		onmatch: function onmatch() {
			this._super();

			this.setOrigVal(parseInt(this.val(), 10));
		},
		onunmatch: function onunmatch() {
			this._super();
		},
		onfocusout: function onfocusout(e) {
			this.closest('.ss-htmleditorfield-file').updateDimensions(this.attr('name'));
		}
	});

	$('form.htmleditorfield-mediaform .ss-uploadfield-item .ss-uploadfield-item-cancel').entwine({
		onclick: function onclick(e) {
			var form = this.closest('form'),
			    file = this.closest('ss-uploadfield-item');
			form.find('.ss-gridfield-item[data-id=' + file.data('id') + ']').removeClass('ui-selected');
			this.closest('.ss-uploadfield-item').remove();
			form.redraw();
			e.preventDefault();
		}
	});

	$('div.ss-assetuploadfield .ss-uploadfield-item-edit, div.ss-assetuploadfield .ss-uploadfield-item-name').entwine({
		getEditForm: function getEditForm() {
			return this.closest('.ss-uploadfield-item').find('.ss-uploadfield-item-editform');
		},

		fromEditForm: {
			onchange: function onchange(e) {
				var form = $(e.target);
				form.removeClass('edited');
				form.addClass('edited');
			}
		},

		onclick: function onclick(e) {
			var editForm = this.getEditForm();

			if (this.closest('.ss-uploadfield-item').hasClass('ss-htmleditorfield-file')) {
				editForm.parent('ss-uploadfield-item').removeClass('ui-state-warning');

				editForm.toggleEditForm();

				e.preventDefault();

				return false;
			}

			this._super(e);
		}
	});

	$('div.ss-assetuploadfield .ss-uploadfield-item-editform').entwine({
		toggleEditForm: function toggleEditForm(bool) {
			var itemInfo = this.prev('.ss-uploadfield-item-info'),
			    status = itemInfo.find('.ss-uploadfield-item-status');
			var text = "";

			if (bool === true || bool !== false && this.height() === 0) {
				text = _i18n2.default._t('UploadField.Editing', "Editing ...");
				this.height('auto');
				itemInfo.find('.toggle-details-icon').addClass('opened');
				status.removeClass('ui-state-success-text').removeClass('ui-state-warning-text');
			} else {
				this.height(0);
				itemInfo.find('.toggle-details-icon').removeClass('opened');
				if (!this.hasClass('edited')) {
					text = _i18n2.default._t('UploadField.NOCHANGES', 'No Changes');
					status.addClass('ui-state-success-text');
				} else {
					text = _i18n2.default._t('UploadField.CHANGESSAVED', 'Changes Made');
					this.removeClass('edited');
					status.addClass('ui-state-success-text');
				}
			}
			status.attr('title', text).text(text);
		}
	});

	$('form.htmleditorfield-mediaform .field[id$="ParentID_Holder"] .TreeDropdownField').entwine({
		onadd: function onadd() {
			this._super();

			var self = this;
			this.bind('change', function () {
				var fileList = self.closest('form').find('.ss-gridfield');
				fileList.setState('ParentID', self.getValue());
				fileList.reload();
			});
		}
	});
});

},{"./i18n":"i18n","./jQuery":"jQuery"}],13:[function(require,module,exports){
'use strict';

var _jQuery = require('./jQuery');

var _jQuery2 = _interopRequireDefault(_jQuery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_jQuery2.default.entwine('ss', function ($) {
	$('.ss-tabset').entwine({
		IgnoreTabState: false,

		onadd: function onadd() {
			var hash = window.location.hash;

			this.redrawTabs();

			if (hash !== '') {
				this.openTabFromURL(hash);
			}

			this._super();
		},

		onremove: function onremove() {
			if (this.data('tabs')) this.tabs('destroy');
			this._super();
		},

		redrawTabs: function redrawTabs() {
			this.rewriteHashlinks();
			this.tabs();
		},

		openTabFromURL: function openTabFromURL(hash) {
			var $trigger;

			$.each(this.find('.cms-panel-link'), function () {
				if (this.href.indexOf(hash) !== -1 && $(hash).length === 1) {
					$trigger = $(this);
					return false;
				}
			});

			if ($trigger === void 0) {
				return;
			}

			$(window).one('ajaxComplete', function () {
				$trigger.click();
			});
		},

		rewriteHashlinks: function rewriteHashlinks() {
			$(this).find('ul a').each(function () {
				if (!$(this).attr('href')) return;

				var matches = $(this).attr('href').match(/#.*/);
				if (!matches) return;
				$(this).attr('href', document.location.href.replace(/#.*/, '') + matches[0]);
			});
		}
	});
});

},{"./jQuery":"jQuery"}],14:[function(require,module,exports){
'use strict';

var _jQuery = require('./jQuery');

var _jQuery2 = _interopRequireDefault(_jQuery);

var _i18n = require('./i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_jQuery2.default.entwine('ss', function ($) {
	var windowWidth, windowHeight;
	$(window).bind('resize.treedropdownfield', function () {
		var cb = function cb() {
			$('.TreeDropdownField').closePanel();
		};

		if ($.browser.msie && parseInt($.browser.version, 10) < 9) {
			var newWindowWidth = $(window).width(),
			    newWindowHeight = $(window).height();
			if (newWindowWidth != windowWidth || newWindowHeight != windowHeight) {
				windowWidth = newWindowWidth;
				windowHeight = newWindowHeight;
				cb();
			}
		} else {
			cb();
		}
	});

	var strings = {
		'openlink': _i18n2.default._t('TreeDropdownField.OpenLink'),
		'fieldTitle': '(' + _i18n2.default._t('TreeDropdownField.FieldTitle') + ')',
		'searchFieldTitle': '(' + _i18n2.default._t('TreeDropdownField.SearchFieldTitle') + ')'
	};

	var _clickTestFn = function _clickTestFn(e) {
		if (!$(e.target).parents('.TreeDropdownField').length) $('.TreeDropdownField').closePanel();
	};

	$('.TreeDropdownField').entwine({
		CurrentXhr: null,

		onadd: function onadd() {
			this.append('<span class="treedropdownfield-title"></span>' + '<div class="treedropdownfield-toggle-panel-link"><a href="#" class="ui-icon ui-icon-triangle-1-s"></a></div>' + '<div class="treedropdownfield-panel"><div class="tree-holder"></div></div>');

			var linkTitle = strings.openLink;
			if (linkTitle) this.find("treedropdownfield-toggle-panel-link a").attr('title', linkTitle);
			if (this.data('title')) this.setTitle(this.data('title'));

			this.getPanel().hide();
			this._super();
		},
		getPanel: function getPanel() {
			return this.find('.treedropdownfield-panel');
		},
		openPanel: function openPanel() {
			$('.TreeDropdownField').closePanel();

			$('body').bind('click', _clickTestFn);

			var panel = this.getPanel(),
			    tree = this.find('.tree-holder');

			panel.css('width', this.width());

			panel.show();

			var toggle = this.find(".treedropdownfield-toggle-panel-link");
			toggle.addClass('treedropdownfield-open-tree');
			this.addClass("treedropdownfield-open-tree");

			toggle.find("a").removeClass('ui-icon-triangle-1-s').addClass('ui-icon-triangle-1-n');

			if (tree.is(':empty') && !panel.hasClass('loading')) {
				this.loadTree(null, this._riseUp);
			} else {
				this._riseUp();
			}

			this.trigger('panelshow');
		},
		_riseUp: function _riseUp() {
			var container = this,
			    dropdown = this.getPanel(),
			    toggle = this.find(".treedropdownfield-toggle-panel-link"),
			    offsetTop = toggle.innerHeight(),
			    elHeight,
			    elPos,
			    endOfWindow;

			if (toggle.length > 0) {
				endOfWindow = $(window).height() + $(document).scrollTop() - toggle.innerHeight();
				elPos = toggle.offset().top;
				elHeight = dropdown.innerHeight();

				if (elPos + elHeight > endOfWindow && elPos - elHeight > 0) {
					container.addClass('treedropdownfield-with-rise');
					offsetTop = -dropdown.outerHeight();
				} else {
					container.removeClass('treedropdownfield-with-rise');
				}
			}
			dropdown.css({ "top": offsetTop + "px" });
		},
		closePanel: function closePanel() {
			jQuery('body').unbind('click', _clickTestFn);

			var toggle = this.find(".treedropdownfield-toggle-panel-link");
			toggle.removeClass('treedropdownfield-open-tree');
			this.removeClass('treedropdownfield-open-tree treedropdownfield-with-rise');

			toggle.find("a").removeClass('ui-icon-triangle-1-n').addClass('ui-icon-triangle-1-s');

			this.getPanel().hide();
			this.trigger('panelhide');
		},
		togglePanel: function togglePanel() {
			this[this.getPanel().is(':visible') ? 'closePanel' : 'openPanel']();
		},
		setTitle: function setTitle(title) {
			title = title || this.data('title') || strings.fieldTitle;

			this.find('.treedropdownfield-title').html(title);
			this.data('title', title);
		},
		getTitle: function getTitle() {
			return this.find('.treedropdownfield-title').text();
		},

		updateTitle: function updateTitle() {
			var self = this,
			    tree = self.find('.tree-holder'),
			    val = this.getValue();
			var updateFn = function updateFn() {
				var val = self.getValue();
				if (val) {

					var node = tree.find('*[data-id="' + val + '"]'),
					    title = node.children('a').find("span.jstree_pageicon") ? node.children('a').find("span.item").html() : null;
					if (!title) title = node.length > 0 ? tree.jstree('get_text', node[0]) : null;

					if (title) {
						self.setTitle(title);
						self.data('title', title);
					}
					if (node) tree.jstree('select_node', node);
				} else {
					self.setTitle(self.data('empty-title'));
					self.removeData('title');
				}
			};

			if (!tree.is(':empty') || !val) updateFn();else this.loadTree({ forceValue: val }, updateFn);
		},
		setValue: function setValue(val) {
			this.data('metadata', $.extend(this.data('metadata'), { id: val }));
			this.find(':input:hidden').val(val).trigger('valueupdated').trigger('change');
		},
		getValue: function getValue() {
			return this.find(':input:hidden').val();
		},
		loadTree: function loadTree(params, callback) {
			var self = this,
			    panel = this.getPanel(),
			    treeHolder = $(panel).find('.tree-holder'),
			    params = params ? $.extend({}, this.getRequestParams(), params) : this.getRequestParams(),
			    xhr;

			if (this.getCurrentXhr()) this.getCurrentXhr().abort();
			panel.addClass('loading');
			xhr = $.ajax({
				url: this.data('urlTree'),
				data: params,
				complete: function complete(xhr, status) {
					panel.removeClass('loading');
				},
				success: function success(html, status, xhr) {
					treeHolder.html(html);
					var firstLoad = true;
					treeHolder.jstree('destroy').bind('loaded.jstree', function (e, data) {
						var val = self.getValue(),
						    selectNode = treeHolder.find('*[data-id="' + val + '"]'),
						    currentNode = data.inst.get_selected();
						if (val && selectNode != currentNode) data.inst.select_node(selectNode);
						firstLoad = false;
						if (callback) callback.apply(self);
					}).jstree(self.getTreeConfig()).bind('select_node.jstree', function (e, data) {
						var node = data.rslt.obj,
						    id = $(node).data('id');
						if (!firstLoad && self.getValue() == id) {
							self.data('metadata', null);
							self.setTitle(null);
							self.setValue(null);
							data.inst.deselect_node(node);
						} else {
							self.data('metadata', $.extend({ id: id }, $(node).getMetaData()));
							self.setTitle(data.inst.get_text(node));
							self.setValue(id);
						}

						if (!firstLoad) self.closePanel();
						firstLoad = false;
					});

					self.setCurrentXhr(null);
				}
			});
			this.setCurrentXhr(xhr);
		},
		getTreeConfig: function getTreeConfig() {
			var self = this;
			return {
				'core': {
					'html_titles': true,

					'animation': 0
				},
				'html_data': {
					'data': this.getPanel().find('.tree-holder').html(),
					'ajax': {
						'url': function url(node) {
							var url = $.path.parseUrl(self.data('urlTree')).hrefNoSearch;
							return url + '/' + ($(node).data("id") ? $(node).data("id") : 0);
						},
						'data': function data(node) {
							var query = $.query.load(self.data('urlTree')).keys;
							var params = self.getRequestParams();
							params = $.extend({}, query, params, { ajax: 1 });
							return params;
						}
					}
				},
				'ui': {
					"select_limit": 1,
					'initially_select': [this.getPanel().find('.current').attr('id')]
				},
				'themes': {
					'theme': 'apple'
				},
				'types': {
					'types': {
						'default': {
							'check_node': function check_node(node) {
								return !node.hasClass('disabled');
							},
							'uncheck_node': function uncheck_node(node) {
								return !node.hasClass('disabled');
							},
							'select_node': function select_node(node) {
								return !node.hasClass('disabled');
							},
							'deselect_node': function deselect_node(node) {
								return !node.hasClass('disabled');
							}
						}
					}
				},
				'plugins': ['html_data', 'ui', 'themes', 'types']
			};
		},

		getRequestParams: function getRequestParams() {
			return {};
		}
	});

	$('.TreeDropdownField .tree-holder li').entwine({
		getMetaData: function getMetaData() {
			var matches = this.attr('class').match(/class-([^\s]*)/i);
			var klass = matches ? matches[1] : '';
			return { ClassName: klass };
		}
	});

	$('.TreeDropdownField *').entwine({
		getField: function getField() {
			return this.parents('.TreeDropdownField:first');
		}
	});

	$('.TreeDropdownField').entwine({
		onclick: function onclick(e) {
			this.togglePanel();

			return false;
		}
	});

	$('.TreeDropdownField .treedropdownfield-panel').entwine({
		onclick: function onclick(e) {
			return false;
		}
	});

	$('.TreeDropdownField.searchable').entwine({
		onadd: function onadd() {
			this._super();
			var title = _i18n2.default._t('TreeDropdownField.ENTERTOSEARCH');
			this.find('.treedropdownfield-panel').prepend($('<input type="text" class="search treedropdownfield-search" data-skip-autofocus="true" placeholder="' + title + '" value="" />'));
		},
		search: function search(str, callback) {
			this.openPanel();
			this.loadTree({ search: str }, callback);
		},
		cancelSearch: function cancelSearch() {
			this.closePanel();
			this.loadTree();
		}
	});

	$('.TreeDropdownField.searchable input.search').entwine({
		onkeydown: function onkeydown(e) {
			var field = this.getField();
			if (e.keyCode == 13) {
				field.search(this.val());
				return false;
			} else if (e.keyCode == 27) {
				field.cancelSearch();
			}
		}
	});

	$('.TreeDropdownField.multiple').entwine({
		getTreeConfig: function getTreeConfig() {
			var cfg = this._super();
			cfg.checkbox = { override_ui: true, two_state: true };
			cfg.plugins.push('checkbox');
			cfg.ui.select_limit = -1;
			return cfg;
		},
		loadTree: function loadTree(params, callback) {
			var self = this,
			    panel = this.getPanel(),
			    treeHolder = $(panel).find('.tree-holder');
			var params = params ? $.extend({}, this.getRequestParams(), params) : this.getRequestParams(),
			    xhr;

			if (this.getCurrentXhr()) this.getCurrentXhr().abort();
			panel.addClass('loading');
			xhr = $.ajax({
				url: this.data('urlTree'),
				data: params,
				complete: function complete(xhr, status) {
					panel.removeClass('loading');
				},
				success: function success(html, status, xhr) {
					treeHolder.html(html);
					var firstLoad = true;
					self.setCurrentXhr(null);
					treeHolder.jstree('destroy').bind('loaded.jstree', function (e, data) {
						$.each(self.getValue(), function (i, val) {
							data.inst.check_node(treeHolder.find('*[data-id=' + val + ']'));
						});
						firstLoad = false;
						if (callback) callback.apply(self);
					}).jstree(self.getTreeConfig()).bind('uncheck_node.jstree check_node.jstree', function (e, data) {
						var nodes = data.inst.get_checked(null, true);
						self.setValue($.map(nodes, function (el, i) {
							return $(el).data('id');
						}));
						self.setTitle($.map(nodes, function (el, i) {
							return data.inst.get_text(el);
						}));
						self.data('metadata', $.map(nodes, function (el, i) {
							return { id: $(el).data('id'), metadata: $(el).getMetaData() };
						}));
					});
				}
			});
			this.setCurrentXhr(xhr);
		},
		getValue: function getValue() {
			var val = this._super();
			return val.split(/ *, */);
		},
		setValue: function setValue(val) {
			this._super($.isArray(val) ? val.join(',') : val);
		},
		setTitle: function setTitle(title) {
			this._super($.isArray(title) ? title.join(', ') : title);
		},
		updateTitle: function updateTitle() {}
	});

	$('.TreeDropdownField input[type=hidden]').entwine({
		onadd: function onadd() {
			this._super();
			this.bind('change.TreeDropdownField', function () {
				$(this).getField().updateTitle();
			});
		},
		onremove: function onremove() {
			this._super();
			this.unbind('.TreeDropdownField');
		}
	});
});

},{"./i18n":"i18n","./jQuery":"jQuery"}],15:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],16:[function(require,module,exports){
(function (process){
  /* globals require, module */

  'use strict';

  /**
   * Module dependencies.
   */

  var pathtoRegexp = require('path-to-regexp');

  /**
   * Module exports.
   */

  module.exports = page;

  /**
   * Detect click event
   */
  var clickEvent = ('undefined' !== typeof document) && document.ontouchstart ? 'touchstart' : 'click';

  /**
   * To work properly with the URL
   * history.location generated polyfill in https://github.com/devote/HTML5-History-API
   */

  var location = ('undefined' !== typeof window) && (window.history.location || window.location);

  /**
   * Perform initial dispatch.
   */

  var dispatch = true;


  /**
   * Decode URL components (query string, pathname, hash).
   * Accommodates both regular percent encoding and x-www-form-urlencoded format.
   */
  var decodeURLComponents = true;

  /**
   * Base path.
   */

  var base = '';

  /**
   * Running flag.
   */

  var running;

  /**
   * HashBang option
   */

  var hashbang = false;

  /**
   * Previous context, for capturing
   * page exit events.
   */

  var prevContext;

  /**
   * Register `path` with callback `fn()`,
   * or route `path`, or redirection,
   * or `page.start()`.
   *
   *   page(fn);
   *   page('*', fn);
   *   page('/user/:id', load, user);
   *   page('/user/' + user.id, { some: 'thing' });
   *   page('/user/' + user.id);
   *   page('/from', '/to')
   *   page();
   *
   * @param {String|Function} path
   * @param {Function} fn...
   * @api public
   */

  function page(path, fn) {
    // <callback>
    if ('function' === typeof path) {
      return page('*', path);
    }

    // route <path> to <callback ...>
    if ('function' === typeof fn) {
      var route = new Route(path);
      for (var i = 1; i < arguments.length; ++i) {
        page.callbacks.push(route.middleware(arguments[i]));
      }
      // show <path> with [state]
    } else if ('string' === typeof path) {
      page['string' === typeof fn ? 'redirect' : 'show'](path, fn);
      // start [options]
    } else {
      page.start(path);
    }
  }

  /**
   * Callback functions.
   */

  page.callbacks = [];
  page.exits = [];

  /**
   * Current path being processed
   * @type {String}
   */
  page.current = '';

  /**
   * Number of pages navigated to.
   * @type {number}
   *
   *     page.len == 0;
   *     page('/login');
   *     page.len == 1;
   */

  page.len = 0;

  /**
   * Get or set basepath to `path`.
   *
   * @param {String} path
   * @api public
   */

  page.base = function(path) {
    if (0 === arguments.length) return base;
    base = path;
  };

  /**
   * Bind with the given `options`.
   *
   * Options:
   *
   *    - `click` bind to click events [true]
   *    - `popstate` bind to popstate [true]
   *    - `dispatch` perform initial dispatch [true]
   *
   * @param {Object} options
   * @api public
   */

  page.start = function(options) {
    options = options || {};
    if (running) return;
    running = true;
    if (false === options.dispatch) dispatch = false;
    if (false === options.decodeURLComponents) decodeURLComponents = false;
    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);
    if (false !== options.click) {
      document.addEventListener(clickEvent, onclick, false);
    }
    if (true === options.hashbang) hashbang = true;
    if (!dispatch) return;
    var url = (hashbang && ~location.hash.indexOf('#!')) ? location.hash.substr(2) + location.search : location.pathname + location.search + location.hash;
    page.replace(url, null, true, dispatch);
  };

  /**
   * Unbind click and popstate event handlers.
   *
   * @api public
   */

  page.stop = function() {
    if (!running) return;
    page.current = '';
    page.len = 0;
    running = false;
    document.removeEventListener(clickEvent, onclick, false);
    window.removeEventListener('popstate', onpopstate, false);
  };

  /**
   * Show `path` with optional `state` object.
   *
   * @param {String} path
   * @param {Object} state
   * @param {Boolean} dispatch
   * @return {Context}
   * @api public
   */

  page.show = function(path, state, dispatch, push) {
    var ctx = new Context(path, state);
    page.current = ctx.path;
    if (false !== dispatch) page.dispatch(ctx);
    if (false !== ctx.handled && false !== push) ctx.pushState();
    return ctx;
  };

  /**
   * Goes back in the history
   * Back should always let the current route push state and then go back.
   *
   * @param {String} path - fallback path to go back if no more history exists, if undefined defaults to page.base
   * @param {Object} [state]
   * @api public
   */

  page.back = function(path, state) {
    if (page.len > 0) {
      // this may need more testing to see if all browsers
      // wait for the next tick to go back in history
      history.back();
      page.len--;
    } else if (path) {
      setTimeout(function() {
        page.show(path, state);
      });
    }else{
      setTimeout(function() {
        page.show(base, state);
      });
    }
  };


  /**
   * Register route to redirect from one path to other
   * or just redirect to another route
   *
   * @param {String} from - if param 'to' is undefined redirects to 'from'
   * @param {String} [to]
   * @api public
   */
  page.redirect = function(from, to) {
    // Define route from a path to another
    if ('string' === typeof from && 'string' === typeof to) {
      page(from, function(e) {
        setTimeout(function() {
          page.replace(to);
        }, 0);
      });
    }

    // Wait for the push state and replace it with another
    if ('string' === typeof from && 'undefined' === typeof to) {
      setTimeout(function() {
        page.replace(from);
      }, 0);
    }
  };

  /**
   * Replace `path` with optional `state` object.
   *
   * @param {String} path
   * @param {Object} state
   * @return {Context}
   * @api public
   */


  page.replace = function(path, state, init, dispatch) {
    var ctx = new Context(path, state);
    page.current = ctx.path;
    ctx.init = init;
    ctx.save(); // save before dispatching, which may redirect
    if (false !== dispatch) page.dispatch(ctx);
    return ctx;
  };

  /**
   * Dispatch the given `ctx`.
   *
   * @param {Object} ctx
   * @api private
   */

  page.dispatch = function(ctx) {
    var prev = prevContext,
      i = 0,
      j = 0;

    prevContext = ctx;

    function nextExit() {
      var fn = page.exits[j++];
      if (!fn) return nextEnter();
      fn(prev, nextExit);
    }

    function nextEnter() {
      var fn = page.callbacks[i++];

      if (ctx.path !== page.current) {
        ctx.handled = false;
        return;
      }
      if (!fn) return unhandled(ctx);
      fn(ctx, nextEnter);
    }

    if (prev) {
      nextExit();
    } else {
      nextEnter();
    }
  };

  /**
   * Unhandled `ctx`. When it's not the initial
   * popstate then redirect. If you wish to handle
   * 404s on your own use `page('*', callback)`.
   *
   * @param {Context} ctx
   * @api private
   */

  function unhandled(ctx) {
    if (ctx.handled) return;
    var current;

    if (hashbang) {
      current = base + location.hash.replace('#!', '');
    } else {
      current = location.pathname + location.search;
    }

    if (current === ctx.canonicalPath) return;
    page.stop();
    ctx.handled = false;
    location.href = ctx.canonicalPath;
  }

  /**
   * Register an exit route on `path` with
   * callback `fn()`, which will be called
   * on the previous context when a new
   * page is visited.
   */
  page.exit = function(path, fn) {
    if (typeof path === 'function') {
      return page.exit('*', path);
    }

    var route = new Route(path);
    for (var i = 1; i < arguments.length; ++i) {
      page.exits.push(route.middleware(arguments[i]));
    }
  };

  /**
   * Remove URL encoding from the given `str`.
   * Accommodates whitespace in both x-www-form-urlencoded
   * and regular percent-encoded form.
   *
   * @param {str} URL component to decode
   */
  function decodeURLEncodedURIComponent(val) {
    if (typeof val !== 'string') { return val; }
    return decodeURLComponents ? decodeURIComponent(val.replace(/\+/g, ' ')) : val;
  }

  /**
   * Initialize a new "request" `Context`
   * with the given `path` and optional initial `state`.
   *
   * @param {String} path
   * @param {Object} state
   * @api public
   */

  function Context(path, state) {
    if ('/' === path[0] && 0 !== path.indexOf(base)) path = base + (hashbang ? '#!' : '') + path;
    var i = path.indexOf('?');

    this.canonicalPath = path;
    this.path = path.replace(base, '') || '/';
    if (hashbang) this.path = this.path.replace('#!', '') || '/';

    this.title = document.title;
    this.state = state || {};
    this.state.path = path;
    this.querystring = ~i ? decodeURLEncodedURIComponent(path.slice(i + 1)) : '';
    this.pathname = decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);
    this.params = {};

    // fragment
    this.hash = '';
    if (!hashbang) {
      if (!~this.path.indexOf('#')) return;
      var parts = this.path.split('#');
      this.path = parts[0];
      this.hash = decodeURLEncodedURIComponent(parts[1]) || '';
      this.querystring = this.querystring.split('#')[0];
    }
  }

  /**
   * Expose `Context`.
   */

  page.Context = Context;

  /**
   * Push state.
   *
   * @api private
   */

  Context.prototype.pushState = function() {
    page.len++;
    history.pushState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
  };

  /**
   * Save the context state.
   *
   * @api public
   */

  Context.prototype.save = function() {
    history.replaceState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
  };

  /**
   * Initialize `Route` with the given HTTP `path`,
   * and an array of `callbacks` and `options`.
   *
   * Options:
   *
   *   - `sensitive`    enable case-sensitive routes
   *   - `strict`       enable strict matching for trailing slashes
   *
   * @param {String} path
   * @param {Object} options.
   * @api private
   */

  function Route(path, options) {
    options = options || {};
    this.path = path;
    this.method = 'GET';
    this.regexp = pathtoRegexp(this.path,
      this.keys = [],
      options.sensitive,
      options.strict);
  }

  /**
   * Expose `Route`.
   */

  page.Route = Route;

  /**
   * Return route middleware with
   * the given callback `fn()`.
   *
   * @param {Function} fn
   * @return {Function}
   * @api public
   */

  Route.prototype.middleware = function(fn) {
    var self = this;
    return function(ctx, next) {
      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);
      next();
    };
  };

  /**
   * Check if this route matches `path`, if so
   * populate `params`.
   *
   * @param {String} path
   * @param {Object} params
   * @return {Boolean}
   * @api private
   */

  Route.prototype.match = function(path, params) {
    var keys = this.keys,
      qsIndex = path.indexOf('?'),
      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,
      m = this.regexp.exec(decodeURIComponent(pathname));

    if (!m) return false;

    for (var i = 1, len = m.length; i < len; ++i) {
      var key = keys[i - 1];
      if (key) {
        var val = decodeURLEncodedURIComponent(m[i]);
        if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {
          params[key.name] = val;
        }        
      }

    }

    return true;
  };


  /**
   * Handle "populate" events.
   */

  var onpopstate = (function () {
    var loaded = false;
    if ('undefined' === typeof window) {
      return;
    }
    if (document.readyState === 'complete') {
      loaded = true;
    } else {
      window.addEventListener('load', function() {
        setTimeout(function() {
          loaded = true;
        }, 0);
      });
    }
    return function onpopstate(e) {
      if (!loaded) return;
      if (e.state) {
        var path = e.state.path;
        page.replace(path, e.state);
      } else {
        page.show(location.pathname + location.hash, undefined, undefined, false);
      }
    };
  })();
  /**
   * Handle "click" events.
   */

  function onclick(e) {

    if (1 !== which(e)) return;

    if (e.metaKey || e.ctrlKey || e.shiftKey) return;
    if (e.defaultPrevented) return;



    // ensure link
    var el = e.target;
    while (el && 'A' !== el.nodeName) el = el.parentNode;
    if (!el || 'A' !== el.nodeName) return;



    // Ignore if tag has
    // 1. "download" attribute
    // 2. rel="external" attribute
    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;

    // ensure non-hash for the same path
    var link = el.getAttribute('href');
    if (!hashbang && el.pathname === location.pathname && (el.hash || '#' === link)) return;



    // Check for mailto: in the href
    if (link && link.indexOf('mailto:') > -1) return;

    // check target
    if (el.target) return;

    // x-origin
    if (!sameOrigin(el.href)) return;



    // rebuild path
    var path = el.pathname + el.search + (el.hash || '');

    // strip leading "/[drive letter]:" on NW.js on Windows
    if (typeof process !== 'undefined' && path.match(/^\/[a-zA-Z]:\//)) {
      path = path.replace(/^\/[a-zA-Z]:\//, '/');
    }

    // same page
    var orig = path;

    if (path.indexOf(base) === 0) {
      path = path.substr(base.length);
    }

    if (hashbang) path = path.replace('#!', '');

    if (base && orig === path) return;

    e.preventDefault();
    page.show(orig);
  }

  /**
   * Event button.
   */

  function which(e) {
    e = e || window.event;
    return null === e.which ? e.button : e.which;
  }

  /**
   * Check if `href` is the same origin.
   */

  function sameOrigin(href) {
    var origin = location.protocol + '//' + location.hostname;
    if (location.port) origin += ':' + location.port;
    return (href && (0 === href.indexOf(origin)));
  }

  page.sameOrigin = sameOrigin;

}).call(this,require('_process'))

},{"_process":15,"path-to-regexp":17}],17:[function(require,module,exports){
/**
 * Expose `pathtoRegexp`.
 */

module.exports = pathtoRegexp;

/**
 * Match matching groups in a regular expression.
 */
var MATCHING_GROUP_REGEXP = /\((?!\?)/g;

/**
 * Normalize the given path string,
 * returning a regular expression.
 *
 * An empty array should be passed,
 * which will contain the placeholder
 * key names. For example "/user/:id" will
 * then contain ["id"].
 *
 * @param  {String|RegExp|Array} path
 * @param  {Array} keys
 * @param  {Object} options
 * @return {RegExp}
 * @api private
 */

function pathtoRegexp(path, keys, options) {
  options = options || {};
  keys = keys || [];
  var strict = options.strict;
  var end = options.end !== false;
  var flags = options.sensitive ? '' : 'i';
  var extraOffset = 0;
  var keysOffset = keys.length;
  var i = 0;
  var name = 0;
  var m;

  if (path instanceof RegExp) {
    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {
      keys.push({
        name: name++,
        optional: false,
        offset: m.index
      });
    }

    return path;
  }

  if (Array.isArray(path)) {
    // Map array parts into regexps and return their source. We also pass
    // the same keys and options instance into every generation to get
    // consistent matching groups before we join the sources together.
    path = path.map(function (value) {
      return pathtoRegexp(value, keys, options).source;
    });

    return new RegExp('(?:' + path.join('|') + ')', flags);
  }

  path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?'))
    .replace(/\/\(/g, '/(?:')
    .replace(/([\/\.])/g, '\\$1')
    .replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function (match, slash, format, key, capture, star, optional, offset) {
      slash = slash || '';
      format = format || '';
      capture = capture || '([^\\/' + format + ']+?)';
      optional = optional || '';

      keys.push({
        name: key,
        optional: !!optional,
        offset: offset + extraOffset
      });

      var result = ''
        + (optional ? '' : slash)
        + '(?:'
        + format + (optional ? slash : '') + capture
        + (star ? '((?:[\\/' + format + '].+?)?)' : '')
        + ')'
        + optional;

      extraOffset += result.length - match.length;

      return result;
    })
    .replace(/\*/g, function (star, index) {
      var len = keys.length

      while (len-- > keysOffset && keys[len].offset > index) {
        keys[len].offset += 3; // Replacement length minus asterisk length.
      }

      return '(.*)';
    });

  // This is a workaround for handling unnamed matching groups.
  while (m = MATCHING_GROUP_REGEXP.exec(path)) {
    var escapeCount = 0;
    var index = m.index;

    while (path.charAt(--index) === '\\') {
      escapeCount++;
    }

    // It's possible to escape the bracket.
    if (escapeCount % 2 === 1) {
      continue;
    }

    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {
      keys.splice(keysOffset + i, 0, {
        name: name++, // Unnamed matching groups must be consistently linear.
        optional: false,
        offset: m.index
      });
    }

    i++;
  }

  // If the path is non-ending, match until the end or a slash.
  path += (end ? '$' : (path[path.length - 1] === '/' ? '' : '(?=\\/|$)'));

  return new RegExp(path, flags);
};

},{}],18:[function(require,module,exports){
// Copyright (c) 2009, SilverStripe Ltd.
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the <organization> nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY SilverStripe Ltd. ''AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL SilverStripe Ltd. BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/**
 * @class Tracks onchange events on all form fields.
 * 
 * @todo Implement form reset handling
 *  
 * @name jQuery.changetracker
 * @author Ingo Schommer, SilverStripe Ltd.
 * @license BSD License
 */
(function($) {
	$.fn.changetracker = function(_options) {
		var self = this;

		if(this.length > 1){
			this.each(function(i, item) {
				this.changetracker(_options);
			});
			return this;
		}

		this.defaults = {
			fieldSelector: ':input:not(:submit)',
			ignoreFieldSelector: "",
			changedCssClass: 'changed'
		};

		var options = $.extend({}, this.defaults, _options);

		this.initialize = function() {
			// optional metadata plugin support
			if ($.meta) options = $.extend({}, options, this.data());

			// Flag indicating this form was dirtied by an external component
			var dirty = false;

			var onchange = function(e) {
				var $field = $(e.target);
				var origVal = $field.data('changetracker.origVal'), newVal;

				// Determine value based on field type
				if($field.is(':checkbox')) {
					newVal = $field.is(':checked') ? 1 : 0;
				} else {
					newVal = $field.val();
				}

				// Determine changed state based on value comparisons
				if(origVal === null || newVal != origVal) {
					$field.addClass(options.changedCssClass);
					self.addClass(options.changedCssClass);
				} else {
					$field.removeClass(options.changedCssClass);
					// Unset changed state on all radio buttons of the same name
					if($field.is(':radio')) {
						self.find(':radio[name=' + $field.attr('name') + ']').removeClass(options.changedCssClass);
					}
					// Only unset form state if no other fields are changed as well and the form isn't explicitly dirty
					if(!dirty && !self.getFields().filter('.' + options.changedCssClass).length) {
						self.removeClass(options.changedCssClass);
					}
				}
			};

			// setup original values
			var fields = this.getFields(), origVal;
			fields.filter(':radio,:checkbox').bind('click.changetracker', onchange);
			fields.not(':radio,:checkbox').bind('change.changetracker', onchange);
			fields.each(function() {
				if($(this).is(':radio,:checkbox')) {
					origVal = self.find(':input[name=' + $(this).attr('name') + ']:checked').val();
				} else {
					origVal = $(this).val();
				}
				$(this).data('changetracker.origVal', origVal);
			});

			self.bind('dirty.changetracker', function() {
				dirty = true;
				self.addClass(options.changedCssClass);
			});

			this.data('changetracker', true);
		};

		this.destroy = function() {
			this.getFields()
				.unbind('.changetracker')
				.removeClass(options.changedCssClass)
				.removeData('changetracker.origVal');
			this.unbind('.changetracker')
				.removeData('changetracker');
		};

		/**
		 * Reset change state of all form fields and the form itself.
		 */
		this.reset = function() {
			this.getFields().each(function() {
				self.resetField(this);
			});

			this.removeClass(options.changedCssClass);
		};

		/**
		 * Reset the change single form field.
		 * Does not reset to the original value.
		 *
		 * @param DOMElement field
		 */
		this.resetField = function(field) {
			return $(field).removeData('changetracker.origVal').removeClass('changed');
		};

		/**
		 * @return jQuery Collection of fields
		 */
		this.getFields = function() {
			return this.find(options.fieldSelector).not(options.ignoreFieldSelector);
		};

		// Support invoking "public" methods as string arguments
		if (typeof arguments[0] === 'string') {
			var property = arguments[1];
			var args = Array.prototype.slice.call(arguments);
			args.splice(0, 1);
			return this[arguments[0]].apply(this, args);
		} else {
			return this.initialize();
		}

	};
}(jQuery));

},{}],19:[function(require,module,exports){
/**
 * Cookie plugin
 *
 * Copyright (c) 2006 Klaus Hartl (stilbuero.de)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

/**
 * Create a cookie with the given name and value and other optional parameters.
 *
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Set the value of a cookie.
 * @example $.cookie('the_cookie', 'the_value', { expires: 7, path: '/', domain: 'jquery.com', secure: true });
 * @desc Create a cookie with all available options.
 * @example $.cookie('the_cookie', 'the_value');
 * @desc Create a session cookie.
 * @example $.cookie('the_cookie', null);
 * @desc Delete a cookie by passing null as value. Keep in mind that you have to use the same path and domain
 *       used when the cookie was set.
 *
 * @param String name The name of the cookie.
 * @param String value The value of the cookie.
 * @param Object options An object literal containing key/value pairs to provide optional cookie attributes.
 * @option Number|Date expires Either an integer specifying the expiration date from now on in days or a Date object.
 *                             If a negative value is specified (e.g. a date in the past), the cookie will be deleted.
 *                             If set to null or omitted, the cookie will be a session cookie and will not be retained
 *                             when the the browser exits.
 * @option String path The value of the path atribute of the cookie (default: path of page that created the cookie).
 * @option String domain The value of the domain attribute of the cookie (default: domain of page that created the cookie).
 * @option Boolean secure If true, the secure attribute of the cookie will be set and the cookie transmission will
 *                        require a secure protocol (like HTTPS).
 * @type undefined
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */

/**
 * Get the value of a cookie with the given name.
 *
 * @example $.cookie('the_cookie');
 * @desc Get the value of a cookie.
 *
 * @param String name The name of the cookie.
 * @return The value of the cookie.
 * @type String
 *
 * @name $.cookie
 * @cat Plugins/Cookie
 * @author Klaus Hartl/klaus.hartl@stilbuero.de
 */
jQuery.cookie = function(name, value, options) {
    if (typeof value != 'undefined') { // name and value given, set cookie
        options = options || {};
        if (value === null) {
            value = '';
            options = jQuery.extend({}, options); // clone object since it's unexpected behavior if the expired property were changed
            options.expires = -1;
        }
        var expires = '';
        if (options.expires && (typeof options.expires == 'number' || options.expires.toUTCString)) {
            var date;
            if (typeof options.expires == 'number') {
                date = new Date();
                date.setTime(date.getTime() + (options.expires * 24 * 60 * 60 * 1000));
            } else {
                date = options.expires;
            }
            expires = '; expires=' + date.toUTCString(); // use expires attribute, max-age is not supported by IE
        }
        // NOTE Needed to parenthesize options.path and options.domain
        // in the following expressions, otherwise they evaluate to undefined
        // in the packed version for some reason...
        var path = options.path ? '; path=' + (options.path) : '';
        var domain = options.domain ? '; domain=' + (options.domain) : '';
        var secure = options.secure ? '; secure' : '';
        document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join('');
    } else { // only name given, get cookie
        var cookieValue = null;
        if (document.cookie && document.cookie != '') {
            var cookies = document.cookie.split(';');
            for (var i = 0; i < cookies.length; i++) {
                var cookie = jQuery.trim(cookies[i]);
                // Does this cookie string begin with the name we want?
                if (cookie.substring(0, name.length + 1) == (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
};
},{}],20:[function(require,module,exports){
/* jQuery.Entwine - Copyright 2009-2011 Hamish Friedlander and SilverStripe. Version . */

/* vendor/jquery.selector/jquery.class.js */

/**
 * Very basic Class utility. Based on base and jquery.class.
 * 
 * Class definition: var Foo = Base.extend({ init: function(){ Constructor }; method_name: function(){ Method } });
 *
 * Inheritance: var Bar = Foo.extend({ method_name: function(){ this._super(); } });
 * 
 * new-less Constructor: new Foo(arg) <-same as-> Foo(arg)
 */  	

var Base;

(function(){
	
	var marker = {}, fnTest = /xyz/.test(function(){var xyz;}) ? /\b_super\b/ : /.*/;

	// The base Class implementation (does nothing)
	Base = function(){};
 
	Base.addMethod = function(name, func) {
		var parent = this._super && this._super.prototype;
		
		if (parent && fnTest.test(func)) {
			this.prototype[name] = function(){
				var tmp = this._super;
				this._super = parent[name];
				try {
					var ret = func.apply(this, arguments);
				}
				finally {
					this._super = tmp;
				}
				return ret;
			};
		}
		else this.prototype[name] = func;
	};

	Base.addMethods = function(props) {
		for (var name in props) {
			if (typeof props[name] == 'function') this.addMethod(name, props[name]);
			else this.prototype[name] = props[name];
		}
	};

	Base.subclassOf = function(parentkls) {
		var kls = this;
		while (kls) {
			if (kls === parentkls) return true;
			kls = kls._super;
		}
	};
 
	// Create a new Class that inherits from this class
	Base.extend = function(props) {
  	
		// The dummy class constructor
		var Kls = function() {
			if (arguments[0] === marker) return;
			
			if (this instanceof Kls) {
				if (this.init) this.init.apply(this, arguments);
			}
			else {
				var ret = new Kls(marker); if (ret.init) ret.init.apply(ret, arguments); return ret;
			}
		};
   
		// Add the common class variables and methods
		Kls.constructor = Kls;
		Kls.extend = Base.extend;
		Kls.addMethod = Base.addMethod;
		Kls.addMethods = Base.addMethods;
		Kls.subclassOf = Base.subclassOf;
		
		Kls._super = this;
	
		// Attach the parent object to the inheritance chain
		Kls.prototype = new this(marker);
		Kls.prototype.constructor = Kls;

		// Copy the properties over onto the new prototype
		Kls.addMethods(props);
		
		return Kls;
	}; 
})();;


/* vendor/jquery.selector/jquery.selector.js */

(function($){

	var tokens = {
		UNICODE: /\\[0-9a-f]{1,6}(?:\r\n|[ \n\r\t\f])?/,
		ESCAPE: /(?:UNICODE)|\\[^\n\r\f0-9a-f]/,
		NONASCII: /[^\x00-\x7F]/,
		NMSTART: /[_a-z]|(?:NONASCII)|(?:ESCAPE)/,
		NMCHAR: /[_a-z0-9-]|(?:NONASCII)|(?:ESCAPE)/,
		IDENT: /-?(?:NMSTART)(?:NMCHAR)*/,
		
		NL: /\n|\r\n|\r|\f/,

		STRING: /(?:STRING1)|(?:STRING2)|(?:STRINGBARE)/,
		STRING1: /"(?:(?:ESCAPE)|\\(?:NL)|[^\n\r\f\"])*"/,
		STRING2: /'(?:(?:ESCAPE)|\\(?:NL)|[^\n\r\f\'])*'/,
		STRINGBARE: /(?:(?:ESCAPE)|\\(?:NL)|[^\n\r\f\]])*/,
		
		FUNCTION: /(?:IDENT)\(\)/,
		
		INTEGER: /[0-9]+/,
		
		WITHN: /([-+])?(INTEGER)?(n)\s*(?:([-+])\s*(INTEGER))?/,
		WITHOUTN: /([-+])?(INTEGER)/
	};
	
	var rx = {
		not: /:not\(/,
		not_end: /\)/,
		
 		tag: /((?:IDENT)|\*)/,
		id: /#(IDENT)/,
		cls: /\.(IDENT)/,
		attr: /\[\s*(IDENT)\s*(?:([^=]?=)\s*(STRING)\s*)?\]/,
		pseudo_el: /(?::(first-line|first-letter|before|after))|(?:::((?:FUNCTION)|(?:IDENT)))/,
		pseudo_cls_nth: /:nth-child\(\s*(?:(?:WITHN)|(?:WITHOUTN)|(odd|even))\s*\)/,
		pseudo_cls: /:(IDENT)/,

		comb: /\s*(\+|~|>)\s*|\s+/,
		comma: /\s*,\s*/,
		important: /\s+!important\s*$/
	};

	/* Replace placeholders with actual regex, and mark all as case insensitive */
	var token = /[A-Z][A-Z0-9]+/;
	for (var k in rx) {
		var m, src = rx[k].source;
		while (m = src.match(token)) src = src.replace(m[0], tokens[m[0]].source);
		rx[k] = new RegExp(src, 'gi');
	}

	/**
	 * A string that matches itself against regexii, and keeps track of how much of itself has been matched
	 */
	var ConsumableString = Base.extend({
		init: function(str) {
			this.str = str;
			this.pos = 0;
		},
		match: function(rx) {
			var m;
			rx.lastIndex = this.pos;
			if ((m = rx.exec(this.str)) && m.index == this.pos ) {
				this.pos = rx.lastIndex ? rx.lastIndex : this.str.length ;
				return m;
			}
			return null;
		},
		peek: function(rx) {
			var m;
			rx.lastIndex = this.pos;
			if ((m = rx.exec(this.str)) && m.index == this.pos ) return m;
			return null;
		},
		showpos: function() {
			return this.str.slice(0,this.pos)+'<HERE>' + this.str.slice(this.pos);
		},
		done: function() {
			return this.pos == this.str.length;
		}
	});
	
	/* A base class that all Selectors inherit off */
	var SelectorBase = Base.extend({});
	
	/**
	 * A class representing a Simple Selector, as per the CSS3 selector spec
	 */
	var SimpleSelector = SelectorBase.extend({
		init: function() {
			this.tag = null;
			this.id = null;
			this.classes = [];
			this.attrs = [];
			this.nots = [];
			this.pseudo_classes = [];
			this.pseudo_els = [];
		},
		parse: function(selector) {
			var m;
			
			/* Pull out the initial tag first, if there is one */
			if (m = selector.match(rx.tag)) this.tag = m[1];
			
			/* Then for each selection type, try and find a match */
			do {
				if (m = selector.match(rx.not)) {
					this.nots[this.nots.length] = SelectorsGroup().parse(selector);
					if (!(m = selector.match(rx.not_end))) {
						throw 'Invalid :not term in selector';
					}
				}
				else if (m = selector.match(rx.id))         this.id = m[1];
				else if (m = selector.match(rx.cls))        this.classes[this.classes.length] = m[1];
				else if (m = selector.match(rx.attr))       this.attrs[this.attrs.length] = [ m[1], m[2], m[3] ];
				else if (m = selector.match(rx.pseudo_el))  this.pseudo_els[this.pseudo_els.length] = m[1] || m[2];
				else if (m = selector.match(rx.pseudo_cls_nth)) {
					if (m[3]) {
						var a = parseInt((m[1]||'')+(m[2]||'1'));
						var b = parseInt((m[4]||'')+(m[5]||'0'));
					}
					else {
						var a = m[8] ? 2 : 0;
						var b = m[8] ? (4-m[8].length) : parseInt((m[6]||'')+m[7]);
					}
					this.pseudo_classes[this.pseudo_classes.length] = ['nth-child', [a, b]];
				}
				else if (m = selector.match(rx.pseudo_cls)) this.pseudo_classes[this.pseudo_classes.length] = [m[1]];
				
			} while(m && !selector.done());
			
			return this;
		}
	});

	/**
	 * A class representing a Selector, as per the CSS3 selector spec
	 */
	var Selector = SelectorBase.extend({ 
		init: function(){
			this.parts = [];
		},
		parse: function(cons){
			this.parts[this.parts.length] = SimpleSelector().parse(cons);
			
			while (!cons.done() && !cons.peek(rx.comma) && (m = cons.match(rx.comb))) {
				this.parts[this.parts.length] = m[1] || ' ';
				this.parts[this.parts.length] = SimpleSelector().parse(cons);
			}
			
			return this.parts.length == 1 ? this.parts[0] : this;
		}
	});
	
	/**
	 * A class representing a sequence of selectors, as per the CSS3 selector spec
	 */
	var SelectorsGroup = SelectorBase.extend({ 
		init: function(){
			this.parts = [];
		},
		parse: function(cons){
			this.parts[this.parts.length] = Selector().parse(cons);
			
			while (!cons.done() && (m = cons.match(rx.comma))) {
				this.parts[this.parts.length] = Selector().parse(cons);
			}
			
			return this.parts.length == 1 ? this.parts[0] : this;
		}
	});

	
	$.selector = function(s){
		var cons = ConsumableString(s);
		var res = SelectorsGroup().parse(cons); 
		
		res.selector = s;
		
		if (!cons.done()) throw 'Could not parse selector - ' + cons.showpos() ;
		else return res;
	};
	
	$.selector.SelectorBase = SelectorBase;
	$.selector.SimpleSelector = SimpleSelector;
	$.selector.Selector = Selector;
	$.selector.SelectorsGroup = SelectorsGroup;
	
})(jQuery);
;


/* vendor/jquery.selector/jquery.selector.specifity.js */

(function($) {

	$.selector.SimpleSelector.addMethod('specifity', function() {
		if (this.spec) return this.spec;
		
		var spec = [
			this.id ? 1 : 0, 
			this.classes.length + this.attrs.length + this.pseudo_classes.length, 
			((this.tag && this.tag != '*') ? 1 : 0) + this.pseudo_els.length
		];
		$.each(this.nots, function(i,not){
			var ns = not.specifity(); spec[0] += ns[0]; spec[1] += ns[1]; spec[2] += ns[2]; 
		});
		
		return this.spec = spec;
	});

	$.selector.Selector.addMethod('specifity', function(){
		if (this.spec) return this.spec;
		
		var spec = [0,0,0];
		$.each(this.parts, function(i,part){
			if (i%2) return;
			var ps = part.specifity(); spec[0] += ps[0]; spec[1] += ps[1]; spec[2] += ps[2]; 
		});
		
		return this.spec = spec;	
	});
	
	$.selector.SelectorsGroup.addMethod('specifity', function(){
		if (this.spec) return this.spec;
		
		var spec = [0,0,0];
		$.each(this.parts, function(i,part){
			var ps = part.specifity(); spec[0] += ps[0]; spec[1] += ps[1]; spec[2] += ps[2]; 
		});
		
		return this.spec = spec;	
	});
	
	
})(jQuery);
;


/* vendor/jquery.selector/jquery.selector.matches.js */

/*
This attempts to do the opposite of Sizzle.
Sizzle is good for finding elements for a selector, but not so good for telling if an individual element matches a selector
*/

(function($) {
	
	/**** CAPABILITY TESTS ****/
	var div = document.createElement('div');
	div.innerHTML = '<form id="test"><input name="id" type="text"/></form>';
	
	// In IE 6-7, getAttribute often does the wrong thing (returns similar to el.attr), so we need to use getAttributeNode on that browser
	var getAttributeDodgy = div.firstChild.getAttribute('id') !== 'test';
	
	// Does browser support Element.firstElementChild, Element.previousElementSibling, etc.
	var hasElementTraversal = div.firstElementChild && div.firstElementChild.tagName == 'FORM';
	
	// Does browser support Element.children
	var hasChildren = div.children && div.children[0].tagName == 'FORM';

	/**** INTRO ****/
	
	var GOOD = /GOOD/g;
	var BAD = /BAD/g;
	
	var STARTS_WITH_QUOTES = /^['"]/g;
	
	var join = function(js) {
		return js.join('\n');
	};
	
	var join_complex = function(js) {
		var code = new String(js.join('\n')); // String objects can have properties set. strings can't
		code.complex = true;
		return code;
	};
	
	/**** ATTRIBUTE ACCESSORS ****/
	
	// Not all attribute names can be used as identifiers, so we encode any non-acceptable characters as hex
	var varForAttr = function(attr) {
		return '_' + attr.replace(/^[^A-Za-z]|[^A-Za-z0-9]/g, function(m){ return '_0x' + m.charCodeAt(0).toString(16) + '_'; });
	};
	
	var getAttr;
	
	// Good browsers
	if (!getAttributeDodgy) {
		getAttr = function(attr){ return 'var '+varForAttr(attr)+' = el.getAttribute("'+attr+'");' ; };
	}
	// IE 6, 7
	else {
		// On IE 6 + 7, getAttribute still has to be called with DOM property mirror name, not attribute name. Map attributes to those names
		var getAttrIEMap = { 'class': 'className', 'for': 'htmlFor' };
		
		getAttr = function(attr) {
			var ieattr = getAttrIEMap[attr] || attr;
			return 'var '+varForAttr(attr)+' = el.getAttribute("'+ieattr+'",2) || (el.getAttributeNode("'+attr+'")||{}).nodeValue;';
		};
	}
	
	/**** ATTRIBUTE COMPARITORS ****/
	
	var attrchecks = {
		'-':  '!K',
		'=':  'K != "V"',
		'!=': 'K == "V"',
		'~=': '_WS_K.indexOf(" V ") == -1',
		'^=': '!K || K.indexOf("V") != 0',
		'*=': '!K || K.indexOf("V") == -1',
		'$=': '!K || K.substr(K.length-"V".length) != "V"'
	};

	/**** STATE TRACKER ****/
	
	var State = $.selector.State = Base.extend({
		init: function(){ 
			this.reset(); 
		},
		reset: function() {
			this.attrs = {}; this.wsattrs = {};
		},

		prev: function(){
			this.reset();
			if (hasElementTraversal) return 'el = el.previousElementSibling';
			return 'while((el = el.previousSibling) && el.nodeType != 1) {}';
		},
		next: function() {
			this.reset();
			if (hasElementTraversal) return 'el = el.nextElementSibling';
			return 'while((el = el.nextSibling) && el.nodeType != 1) {}';
		},
		prevLoop: function(body){
			this.reset();
			if (hasElementTraversal) return join([ 'while(el = el.previousElementSibling){', body]);
			return join([
				'while(el = el.previousSibling){',
					'if (el.nodeType != 1) continue;',
					body
			]);
		},
		parent: function() {
			this.reset();
			return 'el = el.parentNode;';
		},
		parentLoop: function(body) {
			this.reset();
			return join([
				'while((el = el.parentNode) && el.nodeType == 1){',
					body,
				'}'
			]);
		},
		
		uses_attr: function(attr) {
			if (this.attrs[attr]) return;
			this.attrs[attr] = true;
			return getAttr(attr); 
		},
		uses_wsattr: function(attr) {
			if (this.wsattrs[attr]) return;
			this.wsattrs[attr] = true;
			return join([this.uses_attr(attr), 'var _WS_'+varForAttr(attr)+' = " "+'+varForAttr(attr)+'+" ";']); 
		},

		uses_jqueryFilters: function() {
			if (this.jqueryFiltersAdded) return;
			this.jqueryFiltersAdded = true;
			return 'var _$filters = jQuery.find.selectors.filters;';
		},

		save: function(lbl) {
			return 'var el'+lbl+' = el;';
		},
		restore: function(lbl) {
			this.reset();
			return 'el = el'+lbl+';';
		}
	});
	
	/**** PSEUDO-CLASS DETAILS ****/
	
	var pseudoclschecks = {
		'first-child': join([
			'var cel = el;',
			'while(cel = cel.previousSibling){ if (cel.nodeType === 1) BAD; }'
		]),
		'last-child': join([
			'var cel = el;',
			'while(cel = cel.nextSibling){ if (cel.nodeType === 1) BAD; }'
		]),
		'nth-child': function(a,b) {
			var get_i = join([
				'var i = 1, cel = el;',
				'while(cel = cel.previousSibling){',
					'if (cel.nodeType === 1) i++;',
				'}'
			]);
			
			if (a == 0) return join([
				get_i,
				'if (i- '+b+' != 0) BAD;'
			]);
			else if (b == 0 && a >= 0) return join([
				get_i,
				'if (i%'+a+' != 0 || i/'+a+' < 0) BAD;'
			]);
			else if (b == 0 && a < 0) return join([
				'BAD;'
			]);
			else return join([
				get_i,
				'if ((i- '+b+')%'+a+' != 0 || (i- '+b+')/'+a+' < 0) BAD;'
			]);
		}
	};
	
	// Needs to refence contents of object, so must be injected after definition
	pseudoclschecks['only-child'] = join([
		pseudoclschecks['first-child'],
		pseudoclschecks['last-child']
	]);
	
	/**** SimpleSelector ****/
	
	$.selector.SimpleSelector.addMethod('compile', function(el) {
		var js = [];
		
		/* Check against element name */			
		if (this.tag && this.tag != '*') {
			js[js.length] = 'if (el.tagName != "'+this.tag.toUpperCase()+'") BAD;';
		}

		/* Check against ID */
		if (this.id) {
			js[js.length] = el.uses_attr('id');
			js[js.length] = 'if (_id !== "'+this.id+'") BAD;';
		}
		
		/* Build className checking variable */
		if (this.classes.length) {
			js[js.length] = el.uses_wsattr('class');
			
			/* Check against class names */
			$.each(this.classes, function(i, cls){
				js[js.length] = 'if (_WS__class.indexOf(" '+cls+' ") == -1) BAD;';
			});
		}
		
		/* Check against attributes */
		$.each(this.attrs, function(i, attr){
			js[js.length] = (attr[1] == '~=') ? el.uses_wsattr(attr[0]) : el.uses_attr(attr[0]);
			var check = attrchecks[ attr[1] || '-' ];
			check = check.replace( /K/g, varForAttr(attr[0])).replace( /V/g, attr[2] && attr[2].match(STARTS_WITH_QUOTES) ? attr[2].slice(1,-1) : attr[2] );
			js[js.length] = 'if ('+check+') BAD;';
		});
		
		/* Check against nots */
		$.each(this.nots, function(i, not){
			var lbl = ++lbl_id;
			var func = join([
				'l'+lbl+':{',
					not.compile(el).replace(BAD, 'break l'+lbl).replace(GOOD, 'BAD'),
				'}'
			]);
			
			if (!(not instanceof $.selector.SimpleSelector)) func = join([
				el.save(lbl),
				func,
				el.restore(lbl)
			]);
				
			js[js.length] = func;
		});
		
		/* Check against pseudo-classes */
		$.each(this.pseudo_classes, function(i, pscls){
			var check = pseudoclschecks[pscls[0]];
			if (check) {
				js[js.length] = ( typeof check == 'function' ? check.apply(this, pscls[1]) : check );
			}
			else if (check = $.find.selectors.filters[pscls[0]]) {
				js[js.length] = el.uses_jqueryFilters();
				js[js.length] = 'if (!_$filters.'+pscls[0]+'(el)) BAD;';
			}
		});
		
		js[js.length] = 'GOOD';
		
		/* Pass */
		return join(js);
	});
	
	var lbl_id = 0;
	/** Turns an compiled fragment into the first part of a combination */
	function as_subexpr(f) {
		if (f.complex)
			return join([
				'l'+(++lbl_id)+':{',
					f.replace(GOOD, 'break l'+lbl_id),
				'}'
			]);
		else
			return f.replace(GOOD, '');
	}
	
	var combines = {
		' ': function(el, f1, f2) {
			return join_complex([
				f2,
				'while(true){',
					el.parent(),
					'if (!el || el.nodeType !== 1) BAD;',
					f1.compile(el).replace(BAD, 'continue'),
				'}'
			]);
		},
		
		'>': function(el, f1, f2) {
			return join([
				f2,
				el.parent(),
				'if (!el || el.nodeType !== 1) BAD;',
				f1.compile(el)
			]);
		},
		
		'~': function(el, f1, f2) {
			return join_complex([
				f2,
				el.prevLoop(),
					f1.compile(el).replace(BAD, 'continue'),
				'}',
				'BAD;'
			]);
		},
		
		'+': function(el, f1, f2) {
			return join([
				f2,
				el.prev(),
				'if (!el) BAD;',
				f1.compile(el)
			]);
		}
	};
	
	$.selector.Selector.addMethod('compile', function(el) {
		var l = this.parts.length;
		
		var expr = this.parts[--l].compile(el);
		while (l) {
			var combinator = this.parts[--l];
			expr = combines[combinator](el, this.parts[--l], as_subexpr(expr));
		}
		
		return expr;
	});

	$.selector.SelectorsGroup.addMethod('compile', function(el) {
		var expr = [], lbl = ++lbl_id;
		
		for (var i=0; i < this.parts.length; i++) {
			expr[expr.length] = join([
				i == 0 ? el.save(lbl) : el.restore(lbl), 
				'l'+lbl+'_'+i+':{',
					this.parts[i].compile(el).replace(BAD, 'break l'+lbl+'_'+i),
				'}'
			]);
		}
		
		expr[expr.length] = 'BAD;';
		return join(expr);
	});

	$.selector.SelectorBase.addMethod('matches', function(el){	
		this.matches = new Function('el', join([ 
			'if (!el) return false;',
			this.compile(new State()).replace(BAD, 'return false').replace(GOOD, 'return true')
		]));
		return this.matches(el);
	});
	
})(jQuery);

;


/* src/jquery.selector.affectedby.js */

(function($) {

	// TODO:
	// Make attributes & IDs work

	var DIRECT = /DIRECT/g;
	var CONTEXT = /CONTEXT/g;
	var EITHER = /DIRECT|CONTEXT/g;

	$.selector.SelectorBase.addMethod('affectedBy', function(props) {
		this.affectedBy = new Function('props', ([
			'var direct_classes, context_classes, direct_attrs, context_attrs, t;',
			this.ABC_compile().replace(DIRECT, 'direct').replace(CONTEXT, 'context'),
			'return {classes: {context: context_classes, direct: direct_classes}, attrs: {context: context_attrs, direct: direct_attrs}};'
		]).join("\n"));

		// DEBUG: Print out the compiled funciton
		// console.log(this.selector, ''+this.affectedBy);

		return this.affectedBy(props);
	});

	$.selector.SimpleSelector.addMethod('ABC_compile', function() {
		var parts = [];

		$.each(this.classes, function(i, cls){
			parts[parts.length] = "if (t = props.classes['"+cls+"']) (DIRECT_classes || (DIRECT_classes = {}))['"+cls+"'] = t;";
		});

		$.each(this.nots, function(i, not){
			parts[parts.length] = not.ABC_compile();
		});

		return parts.join("\n");
	});

	$.selector.Selector.addMethod('ABC_compile', function(arg){
		var parts = [];
		var i = this.parts.length-1;

		parts[parts.length] = this.parts[i].ABC_compile();
		while ((i = i - 2) >= 0) parts[parts.length] = this.parts[i].ABC_compile().replace(EITHER, 'CONTEXT');

		return parts.join("\n");
	});

	$.selector.SelectorsGroup.addMethod('ABC_compile', function(){
		var parts = [];

		$.each(this.parts, function(i,part){
			parts[parts.length] = part.ABC_compile();
		});

		return parts.join("\n");
	});


})(jQuery);
;


/* src/jquery.focusinout.js */

(function($){	
	
	/**
	 * Add focusin and focusout support to bind and live for browers other than IE. Designed to be usable in a delegated fashion (like $.live)
	 * Copyright (c) 2007 Jörn Zaefferer
	 */
	if ($.support.focusinBubbles === undefined)  {
		$.support.focusinBubbles = !!($.browser.msie);
	}

	if (!$.support.focusinBubbles && !$.event.special.focusin) {
		// Emulate focusin and focusout by binding focus and blur in capturing mode
		$.each({focus: 'focusin', blur: 'focusout'}, function(original, fix){
			$.event.special[fix] = {
				setup: function(){
					if (!this.addEventListener) return false;
					this.addEventListener(original, $.event.special[fix].handler, true);
				},
				teardown: function(){
					if (!this.removeEventListener) return false;
					this.removeEventListener(original, $.event.special[fix].handler, true);
				},
				handler: function(e){
					arguments[0] = $.event.fix(e);
					arguments[0].type = fix;
					return $.event.handle.apply(this, arguments);
				}
			};
		});
	}
		
	(function(){
		//IE has some trouble with focusout with select and keyboard navigation
		var activeFocus = null;
	
		$(document)
			.bind('focusin', function(e){
				var target = e.realTarget || e.target;
				if (activeFocus && activeFocus !== target) {
					e.type = 'focusout';
					$(activeFocus).trigger(e);
					e.type = 'focusin';
					e.target = target;
				}
				activeFocus = target;
			})
			.bind('focusout', function(e){
				activeFocus = null;
			});
	})();
	
})(jQuery);;


/* src/jquery.entwine.js */

try {
	console.log;
}
catch (e) {
	window.console = undefined;
}

(function($) {

	/* Create a subclass of the jQuery object. This was introduced in jQuery 1.5, but removed again in 1.9 */
	var sub = function() {
		function jQuerySub( selector, context ) {
			return new jQuerySub.fn.init( selector, context );
		}

		jQuery.extend( true, jQuerySub, $ );
		jQuerySub.superclass = $;
		jQuerySub.fn = jQuerySub.prototype = $();
		jQuerySub.fn.constructor = jQuerySub;
		jQuerySub.fn.init = function init( selector, context ) {
			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
				context = jQuerySub( context );
			}

			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
		};
		jQuerySub.fn.init.prototype = jQuerySub.fn;
		var rootjQuerySub = jQuerySub(document);
		return jQuerySub;
	};

	var namespaces = {};

	$.entwine = function() {
		$.fn.entwine.apply(null, arguments);
	};
	
	/**
	 * A couple of utility functions for accessing the store outside of this closure, and for making things
	 * operate in a little more easy-to-test manner
	 */
	$.extend($.entwine, {
		/**
		 * Get all the namespaces. Useful for introspection? Internal interface of Namespace not guaranteed consistant
		 */
		namespaces: namespaces,
		
		/**
		 * Remove all entwine rules
		 */
		clear_all_rules: function() { 
			// Remove proxy functions
			for (var k in $.fn) { if ($.fn[k].isentwinemethod) delete $.fn[k]; }
			// Remove bound events - TODO: Make this pluggable, so this code can be moved to jquery.entwine.events.js
			$(document).unbind('.entwine');
			$(window).unbind('.entwine');
			// Remove namespaces, and start over again
			for (var k in namespaces) delete namespaces[k];
			for (var k in $.entwine.capture_bindings) delete $.entwine.capture_bindings[k];
		},
		
		WARN_LEVEL_NONE: 0,
		WARN_LEVEL_IMPORTANT: 1,
		WARN_LEVEL_BESTPRACTISE: 2,
		
		/** 
		 * Warning level. Set to a higher level to get warnings dumped to console.
		 */
		warningLevel: 0,
		
		/** Utility to optionally display warning messages depending on level */
		warn: function(message, level) {
			if (level <= $.entwine.warningLevel && console && console.warn) { 
				console.warn(message);
				if (console.trace) console.trace();
			}
		},
		
		warn_exception: function(where, /* optional: */ on, e) {
			if ($.entwine.WARN_LEVEL_IMPORTANT <= $.entwine.warningLevel && console && console.warn) {
				if (arguments.length == 2) { e = on; on = null; }
				
				if (on) console.warn('Uncaught exception',e,'in',where,'on',on);
				else    console.warn('Uncaught exception',e,'in',where);
				
				if (e.stack) console.warn("Stack Trace:\n" + e.stack);
			}
		}
	});
	

	/** Stores a count of definitions, so that we can sort identical selectors by definition order */
	var rulecount = 0;
	
	var Rule = Base.extend({
		init: function(selector, name) {
			this.selector = selector;
			this.specifity = selector.specifity();
			this.important = 0;
			this.name = name;
			this.rulecount = rulecount++;
		}
	});
	
	Rule.compare = function(a, b) {
		var as = a.specifity, bs = b.specifity;
		
		return (a.important - b.important) ||
		       (as[0] - bs[0]) ||
		       (as[1] - bs[1]) ||
		       (as[2] - bs[2]) ||
		       (a.rulecount - b.rulecount) ;
	};

	$.entwine.RuleList = function() {
		var list = [];
		
		list.addRule = function(selector, name){ 
			var rule = Rule(selector, name);
			
			list[list.length] = rule; 
			list.sort(Rule.compare); 
			
			return rule;
		};
		
		return list;
	};

	var handlers = [];
	
	/**
	 * A Namespace holds all the information needed for adding entwine methods to a namespace (including the _null_ namespace)
	 */
	$.entwine.Namespace = Base.extend({
		init: function(name){
			if (name && !name.match(/^[A-Za-z0-9.]+$/)) $.entwine.warn('Entwine namespace '+name+' is not formatted as period seperated identifiers', $.entwine.WARN_LEVEL_BESTPRACTISE);
			name = name || '__base';
			
			this.name = name;
			this.store = {};
			
			namespaces[name] = this;
			
			if (name == "__base") {
				this.injectee = $.fn;
				this.$ = $;
			}
			else {
				// We're in a namespace, so we build a Class that subclasses the jQuery Object Class to inject namespace functions into
				this.$ = $.sub ? $.sub() : sub();
				// Work around bug in sub() - subclass must share cache with root or data won't get cleared by cleanData
				this.$.cache = $.cache;

				this.injectee = this.$.prototype;

				// We override entwine to inject the name of this namespace when defining blocks inside this namespace
				var entwine_wrapper = this.injectee.entwine = function(spacename) {
					var args = arguments;
					
					if (!spacename || typeof spacename != 'string') { args = $.makeArray(args); args.unshift(name); }
					else if (spacename.charAt(0) != '.') args[0] = name+'.'+spacename;
					
					return $.fn.entwine.apply(this, args);
				};
				
				this.$.entwine = function() {
					entwine_wrapper.apply(null, arguments);
				};
				
				for (var i = 0; i < handlers.length; i++) {
					var handler = handlers[i], builder;

					// Inject jQuery object method overrides
					if (builder = handler.namespaceMethodOverrides) {
						var overrides = builder(this);
						for (var k in overrides) this.injectee[k] = overrides[k];
					}
					
					// Inject $.entwine function overrides
					if (builder = handler.namespaceStaticOverrides) {
						var overrides = builder(this);
						for (var k in overrides) this.$.entwine[k] = overrides[k];
					}
				}
			}
		},
		
		/**
		 * Returns a function that does selector matching against the function list for a function name
		 * Used by proxy for all calls, and by ctorProxy to handle _super calls
		 * @param {String} name - name of the function as passed in the construction object
		 * @param {String} funcprop - the property on the Rule object that gives the actual function to call
		 * @param {function} basefunc - the non-entwine function to use as the catch-all function at the bottom of the stack
		 */
		one: function(name, funcprop, basefunc) {
			var namespace = this;
			var funcs = this.store[name];
			
			var one = function(el, args, i){
				if (i === undefined) i = funcs.length;
				while (i--) {
					if (funcs[i].selector.matches(el)) {
						var ret, tmp_i = el.i, tmp_f = el.f;
						el.i = i; el.f = one;
						try { ret = funcs[i][funcprop].apply(namespace.$(el), args); }
						finally { el.i = tmp_i; el.f = tmp_f; }
						return ret;
					}
				}
				// If we didn't find a entwine-defined function, but there is a non-entwine function to use as a base, try that
				if (basefunc) return basefunc.apply(namespace.$(el), args);
			};
			
			return one;
		},
		
		/**
		 * A proxy is a function attached to a callable object (either the base jQuery.fn or a subspace object) which handles
		 * finding and calling the correct function for each member of the current jQuery context
		 * @param {String} name - name of the function as passed in the construction object
		 * @param {function} basefunc - the non-entwine function to use as the catch-all function at the bottom of the stack
		 */
		build_proxy: function(name, basefunc) {
			var one = this.one(name, 'func', basefunc);
			
			var prxy = function() {
				var rv, ctx = $(this); 
				
				var i = ctx.length;
				while (i--) rv = one(ctx[i], arguments);
				return rv;
			};
			
			return prxy;
		},
		
		bind_proxy: function(selector, name, func) {
			var rulelist = this.store[name] || (this.store[name] = $.entwine.RuleList());
			
			var rule = rulelist.addRule(selector, name); rule.func = func;
			
			if (!this.injectee.hasOwnProperty(name) || !this.injectee[name].isentwinemethod) {
				this.injectee[name] = this.build_proxy(name, this.injectee.hasOwnProperty(name) ? this.injectee[name] : null);
				this.injectee[name].isentwinemethod = true;
			}

			if (!this.injectee[name].isentwinemethod) {
				$.entwine.warn('Warning: Entwine function '+name+' clashes with regular jQuery function - entwine function will not be callable directly on jQuery object', $.entwine.WARN_LEVEL_IMPORTANT);
			}
		},
		
		add: function(selector, data) {
			// For every item in the hash, try ever method handler, until one returns true
			for (var k in data) {
				var v = data[k];
				
				for (var i = 0; i < handlers.length; i++) {
					if (handlers[i].bind && handlers[i].bind.call(this, selector, k, v)) break;
				}
			}
		},
		
		has: function(ctx, name) {
			var rulelist = this.store[name];
			if (!rulelist) return false;
			
			/* We go forward this time, since low specifity is likely to knock out a bunch of elements quickly */
			for (var i = 0 ; i < rulelist.length; i++) {
				ctx = ctx.not(rulelist[i].selector);
				if (!ctx.length) return true;
			}
			return false;
		}
	});
	
	/**
	 * A handler is some javascript code that adds support for some time of key / value pair passed in the hash to the Namespace add method.
	 * The default handlers provided (and included by default) are event, ctor and properties
	 */
	$.entwine.Namespace.addHandler = function(handler) {
		for (var i = 0; i < handlers.length && handlers[i].order < handler.order; i++) { /* Pass */ }
		handlers.splice(i, 0, handler);
	};
	
	$.entwine.Namespace.addHandler({
		order: 50,
		
		bind: function(selector, k, v){
			if ($.isFunction(v)) {
				this.bind_proxy(selector, k, v);
				return true;
			}
		}
	});

	$.extend($.fn, {
		/**
		 * Main entwine function. Used for new definitions, calling into a namespace (or forcing the base namespace) and entering a using block
		 * 
		 */
		entwine: function(spacename) {
			var i = 0;
			/* Don't actually work out selector until we try and define something on it - we might be opening a namespace on an function-traveresed object
			   which have non-standard selectors like .parents(.foo).slice(0,1) */
			var selector = null;  
		
			/* By default we operator on the base namespace */
			var namespace = namespaces.__base || $.entwine.Namespace();
			
			/* If the first argument is a string, then it's the name of a namespace. Look it up */
			if (typeof spacename == 'string') {
				if (spacename.charAt('0') == '.') spacename = spacename.substr(1);
				if (spacename) namespace = namespaces[spacename] || $.entwine.Namespace(spacename);
				i=1;
			}
		
			/* All remaining arguments should either be using blocks or definition hashs */
			while (i < arguments.length) {
				var res = arguments[i++];
				
				// If it's a function, call it - either it's a using block or it's a namespaced entwine definition
				if ($.isFunction(res)) {
					if (res.length != 1) $.entwine.warn('Function block inside entwine definition does not take $ argument properly', $.entwine.WARN_LEVEL_IMPORTANT);
					res = res.call(namespace.$(this), namespace.$);
				}
				
				// If we have a entwine definition hash, inject it into namespace
				if (res) {
					if (selector === null) selector = this.selector ? $.selector(this.selector) : false;
					
					if (selector) namespace.add(selector, res);
					else $.entwine.warn('Entwine block given to entwine call without selector. Make sure you call $(selector).entwine when defining blocks', $.entwine.WARN_LEVEL_IMPORTANT);
				}
			}
		
			/* Finally, return the jQuery object 'this' refers to, wrapped in the new namespace */
			return namespace.$(this);
		},
		
		/** 
		 * Calls the next most specific version of the current entwine method
		 */
		_super: function(){
			var rv, i = this.length;
			while (i--) {
				var el = this[0];
				rv = el.f(el, arguments, el.i);
			}
			return rv;
		}
	});
	
})(jQuery);
;


/* src/domevents/jquery.entwine.domevents.addrem.js */

(function($){

	// Gets all the child elements of a particular elements, stores it in an array
	function getElements(store, original) {
		var node, i = store.length, next = original.firstChild;

		while ((node = next)) {
			if (node.nodeType === 1) store[i++] = node;
			next = node.firstChild || node.nextSibling;
			while (!next && (node = node.parentNode) && node !== original) next = node.nextSibling;
		}
	}

	// This might be faster? Or slower? @todo: benchmark.
	function getElementsAlt(store, node) {
		if (node.getElementsByTagName) {
			var els = node.getElementsByTagName('*'), len = els.length, i = 0, j = store.length;
			for(; i < len; i++, j++) {
				store[j] = els[i];
			}
		}
		else if (node.childNodes) {
			var els = node.childNodes, len = els.length, i = 0;
			for(; i < len; i++) {
				getElements(store, els[i]);
			}
		}
	}

	var dontTrigger = false;

	var patchDomManipCallback = function(original) {
		var patched = function(elem){
			var added = [];

			if (!dontTrigger) {
				if (elem.nodeType == 1) added[added.length] = elem;
				getElements(added, elem);
			}

			var rv = original.apply(this, arguments);

			if (!dontTrigger && added.length) {
				var event = $.Event('EntwineElementsAdded');
				event.targets = added;
				$(document).triggerHandler(event);
			}

			return rv;
		}
		patched.patched = true;

		return patched;
	}

	var version = $.prototype.jquery.split('.');
	var callbackIdx = (version[0] > 1 || version[1] >= 10 ? 1 : 2);

	// Monkey patch $.fn.domManip to catch all regular jQuery add element calls
	var _domManip = $.prototype.domManip;
	$.prototype.domManip = function() {
		if (!arguments[callbackIdx].patched) arguments[callbackIdx] = patchDomManipCallback(arguments[callbackIdx]);
		return _domManip.apply(this, arguments);
	}

	// Monkey patch $.fn.html to catch when jQuery sets innerHTML directly
	var _html = $.prototype.html;
	$.prototype.html = function(value) {
		if (value === undefined) return _html.apply(this, arguments);

		dontTrigger = true;
		var res = _html.apply(this, arguments);
		dontTrigger = false;

		var added = [];

		var i = 0, length = this.length;
		for (; i < length; i++ ) getElements(added, this[i]);

		var event = $.Event('EntwineElementsAdded');
		event.targets = added;
		$(document).triggerHandler(event);

		return res;
	}

	// If this is true, we've changed something to call cleanData so that we can catch the elements, but we don't
	// want to call the underlying original $.cleanData
	var supressActualClean = false;

	// Monkey patch $.cleanData to catch element removal
	var _cleanData = $.cleanData;
	$.cleanData = function( elems ) {
		// By default we can assume all elements passed are legitimately being removeed
		var removed = elems;

		// Except if we're supressing actual clean - we might be being called by jQuery "being careful" about detaching nodes
		// before attaching them. So we need to check to make sure these nodes currently are in a document
		if (supressActualClean) {
			var i = 0, len = elems.length, removed = [], ri = 0;
			for(; i < len; i++) {
				var node = elems[i], current = node;
				while (current = current.parentNode) {
					if (current.nodeType == 9) { removed[ri++] = node; break; }
				}
			}
		}

		if (removed.length) {
			var event = $.Event('EntwineElementsRemoved');
			event.targets = removed;
			$(document).triggerHandler(event);
		}

		if (!supressActualClean) _cleanData.apply(this, arguments);
	}

	// Monkey patch $.fn.remove to catch when we're just detaching (keepdata == 1) -
	// this doesn't call cleanData but still needs to trigger event
	var _remove = $.prototype.remove;
	$.prototype.remove = function(selector, keepdata) {
		supressActualClean = keepdata;
		var rv = _remove.call(this, selector);
		supressActualClean = false;
		return rv;
	}

	// And on DOM ready, trigger adding once
	$(function(){
		var added = []; getElements(added, document);

		var event = $.Event('EntwineElementsAdded');
		event.targets = added;
		$(document).triggerHandler(event);
	});


})(jQuery);;


/* src/domevents/jquery.entwine.domevents.maybechanged.js */

(function($){

	/** Utility function to monkey-patch a jQuery method */
	var monkey = function( /* method, method, ...., patch */){
		var methods = $.makeArray(arguments);
		var patch = methods.pop();

		$.each(methods, function(i, method){
			var old = $.fn[method];

			$.fn[method] = function() {
				var self = this, args = $.makeArray(arguments);

				var rv = old.apply(self, args);
				patch.apply(self, args);
				return rv;
			}
		});
	}

	/** What to call to run a function 'soon'. Normally setTimeout, but for syncronous mode we override so soon === now */
	var runSoon = window.setTimeout;
	
	/** The timer handle for the asyncronous matching call */
	var ChangeDetails = Base.extend({

		init: function() {
			this.global = false;
			this.attrs = {};
			this.classes = {};
		},

		/** Fire the change event. Only fires on the document node, so bind to that */
		triggerEvent: function() {
			// If we're not the active changes instance any more, don't trigger
			if (changes != this) return;

			// Cancel any pending timeout (if we're directly called in the mean time)
			if (this.check_id) clearTimeout(this.check_id);

			// Reset the global changes object to be a new instance (do before trigger, in case trigger fires changes itself)
			changes = new ChangeDetails();

			// Fire event
			$(document).triggerHandler("EntwineSubtreeMaybeChanged", [this]);
		},

		changed: function() {
			if (!this.check_id) {
				var self = this;
				this.check_id = runSoon(function(){ self.check_id = null; self.triggerEvent(); }, 10);
			}
		},

		addAll: function() {
			if (this.global) return this; // If we've already flagged as a global change, just skip

			this.global = true;
			this.changed();
			return this;
		},

		addSubtree: function(node) {
			return this.addAll();
		},

		/* For now we don't do this. It's expensive, and jquery.entwine.ctors doesn't use this information anyway */
		addSubtreeFuture: function(node) {
			if (this.global) return this; // If we've already flagged as a global change, just skip

			this.subtree = this.subtree ? this.subtree.add(node) : $(node);
			this.changed();
			return this;
		},

		addAttr: function(attr, node) {
			if (this.global) return this;

			this.attrs[attr] = (attr in this.attrs) ? this.attrs[attr].add(node) : $(node);
			this.changed();
			return this;
		},

		addClass: function(klass, node) {
			if (this.global) return this;

			this.classes[klass] = (klass in this.classes) ? this.classes[klass].add(node) : $(node);
			this.changed();
			return this;
		}
	});

	var changes = new ChangeDetails();

	// Element add events trigger maybechanged events

	$(document).bind('EntwineElementsAdded', function(e){ changes.addSubtree(e.targets); });

	// Element remove events trigger maybechanged events, but we have to wait until after the nodes are actually removed
	// (EntwineElementsRemoved fires _just before_ the elements are removed so the data still exists), especially in syncronous mode

	var removed = null;
	$(document).bind('EntwineElementsRemoved', function(e){ removed = e.targets; });

	monkey('remove', 'html', 'empty', function(){
		var subtree = removed; removed = null;
		if (subtree) changes.addSubtree(subtree);
	});

	// We also need to know when an attribute, class, etc changes. Patch the relevant jQuery methods here

	monkey('removeAttr', function(attr){
		changes.addAttr(attr, this);
	});

	monkey('addClass', 'removeClass', 'toggleClass', function(klass){
		if (typeof klass == 'string') changes.addClass(klass, this);
	});

	monkey('attr', function(a, b){
		if (b !== undefined && typeof a == 'string') changes.addAttr(a, this);
		else if (typeof a != 'string') { for (var k in a) changes.addAttr(k, this); }
	});

	// Add some usefull accessors to $.entwine

	$.extend($.entwine, {
		/**
		 * Make onmatch and onunmatch work in synchronous mode - that is, new elements will be detected immediately after
		 * the DOM manipulation that made them match. This is only really useful for during testing, since it's pretty slow
		 * (otherwise we'd make it the default).
		 */
		synchronous_mode: function() {
			if (changes && changes.check_id) clearTimeout(changes.check_id);
			changes = new ChangeDetails();

			runSoon = function(func, delay){ func.call(this); return null; };
		},

		/**
		 * Trigger onmatch and onunmatch now - usefull for after DOM manipulation by methods other than through jQuery.
		 * Called automatically on document.ready
		 */
		triggerMatching: function() {
			changes.addAll();
		}
	});

})(jQuery);;


/* src/jquery.entwine.events.js */

(function($) {	

	/** Taken from jQuery 1.5.2 for backwards compatibility */
	if ($.support.changeBubbles == undefined) {
		$.support.changeBubbles = true;

		var el = document.createElement("div");
		eventName = "onchange";

		if (el.attachEvent) {
			var isSupported = (eventName in el);
			if (!isSupported) {
				el.setAttribute(eventName, "return;");
				isSupported = typeof el[eventName] === "function";
			}

			$.support.changeBubbles = isSupported;
		}
	}

	/* Return true if node b is the same as, or is a descendant of, node a */
	if (document.compareDocumentPosition) {
		var is_or_contains = function(a, b) {
			return a && b && (a == b || !!(a.compareDocumentPosition(b) & 16));
		};
	}
	else {
		var is_or_contains = function(a, b) {
			return a && b && (a == b || (a.contains ? a.contains(b) : true));
		};
	}

	/* Add the methods to handle event binding to the Namespace class */
	$.entwine.Namespace.addMethods({
		build_event_proxy: function(name) {
			var one = this.one(name, 'func');
			
			var prxy = function(e, data) {
				// For events that do not bubble we manually trigger delegation (see delegate_submit below) 
				// If this event is a manual trigger, the event we actually want to bubble is attached as a property of the passed event
				e = e.delegatedEvent || e;
				
				var el = e.target;
				while (el && el.nodeType == 1 && !e.isPropagationStopped()) {
					var ret = one(el, arguments);
					if (ret !== undefined) e.result = ret;
					if (ret === false) { e.preventDefault(); e.stopPropagation(); }
					
					el = el.parentNode;
				}
			};
			
			return prxy;
		},
		
		build_mouseenterleave_proxy: function(name) {
			var one = this.one(name, 'func');
			
			var prxy = function(e) {
				var el = e.target;
				var rel = e.relatedTarget;
				
				while (el && el.nodeType == 1 && !e.isPropagationStopped()) {
					/* We know el contained target. If it also contains relatedTarget then we didn't mouseenter / leave. What's more, every ancestor will also
					contan el and rel, and so we can just stop bubbling */
					if (is_or_contains(el, rel)) break;
					
					var ret = one(el, arguments);
					if (ret !== undefined) e.result = ret;
					if (ret === false) { e.preventDefault(); e.stopPropagation(); }
					
					el = el.parentNode;
				}
			};
			
			return prxy;
		},
		
		build_change_proxy: function(name) {
			var one = this.one(name, 'func');

			/*
			This change bubble emulation code is taken mostly from jQuery 1.6 - unfortunately we can't easily reuse any of
			it without duplication, so we'll have to re-migrate any bugfixes
			*/

			// Get the value of an item. Isn't supposed to be interpretable, just stable for some value, and different
			// once the value changes
			var getVal = function( elem ) {
				var type = elem.type, val = elem.value;

				if (type === "radio" || type === "checkbox") {
					val = elem.checked;
				}
				else if (type === "select-multiple") {
					val = "";
					if (elem.selectedIndex > -1) {
						val = jQuery.map(elem.options, function(elem){ return elem.selected; }).join("-");
					}
				}
				else if (jQuery.nodeName(elem, "select")) {
					val = elem.selectedIndex;
				}

				return val;
			};

			// Test if a node name is a form input
			var rformElems = /^(?:textarea|input|select)$/i;

			// Check if this event is a change, and bubble the change event if it is
			var testChange = function(e) {
				var elem = e.target, data, val;

				if (!rformElems.test(elem.nodeName) || elem.readOnly) return;

				data = jQuery.data(elem, "_entwine_change_data");
				val = getVal(elem);

				// the current data will be also retrieved by beforeactivate
				if (e.type !== "focusout" || elem.type !== "radio") {
					jQuery.data(elem, "_entwine_change_data", val);
				}

				if (data === undefined || val === data) return;

				if (data != null || val) {
					e.type = "change";

					while (elem && elem.nodeType == 1 && !e.isPropagationStopped()) {
						var ret = one(elem, arguments);
						if (ret !== undefined) e.result = ret;
						if (ret === false) { e.preventDefault(); e.stopPropagation(); }

						elem = elem.parentNode;
					}
				}
			};

			// The actual proxy - responds to several events, some of which triger a change check, some
			// of which just store the value for future change checks
			var prxy = function(e) {
				var event = e.type, elem = e.target, type = jQuery.nodeName( elem, "input" ) ? elem.type : "";

				switch (event) {
					case 'focusout':
					case 'beforedeactivate':
						testChange.apply(this, arguments);
						break;

					case 'click':
						if ( type === "radio" || type === "checkbox" || jQuery.nodeName( elem, "select" ) ) {
							testChange.apply(this, arguments);
						}
						break;

					// Change has to be called before submit
					// Keydown will be called before keypress, which is used in submit-event delegation
					case 'keydown':
						if (
							(e.keyCode === 13 && !jQuery.nodeName( elem, "textarea" ) ) ||
							(e.keyCode === 32 && (type === "checkbox" || type === "radio")) ||
							type === "select-multiple"
						) {
							testChange.apply(this, arguments);
						}
						break;

					// Beforeactivate happens also before the previous element is blurred
					// with this event you can't trigger a change event, but you can store
					// information
					case 'focusin':
					case 'beforeactivate':
						jQuery.data( elem, "_entwine_change_data", getVal(elem) );
						break;
				}
			}

			return prxy;
		},
		
		bind_event: function(selector, name, func, event) {
			var funcs = this.store[name] || (this.store[name] = $.entwine.RuleList()) ;
			var proxies = funcs.proxies || (funcs.proxies = {});
			
			var rule = funcs.addRule(selector, name); rule.func = func;
			
			if (!proxies[name]) {
				switch (name) {
					case 'onmouseenter':
						proxies[name] = this.build_mouseenterleave_proxy(name);
						event = 'mouseover';
						break;
					case 'onmouseleave':
						proxies[name] = this.build_mouseenterleave_proxy(name);
						event = 'mouseout';
						break;
					case 'onchange':
						if (!$.support.changeBubbles) {
							proxies[name] = this.build_change_proxy(name);
							event = 'click keydown focusin focusout beforeactivate beforedeactivate';
						}
						break;
					case 'onsubmit':
						event = 'delegatedSubmit';
						break;
					case 'onfocus':
					case 'onblur':
						$.entwine.warn('Event '+event+' not supported - using focusin / focusout instead', $.entwine.WARN_LEVEL_IMPORTANT);
				}
				
				// If none of the special handlers created a proxy, use the generic proxy
				if (!proxies[name]) proxies[name] = this.build_event_proxy(name);

				$(document).bind(event.replace(/(\s+|$)/g, '.entwine$1'), proxies[name]);
			}
		}
	});
	
	$.entwine.Namespace.addHandler({
		order: 40,
		
		bind: function(selector, k, v){
			var match, event;
			if ($.isFunction(v) && (match = k.match(/^on(.*)/))) {
				event = match[1];
				this.bind_event(selector, k, v, event);
				return true;
			}
		}
	});
	
	// Find all forms and bind onsubmit to trigger on the document too. 
	// This is the only event that can't be grabbed via delegation
	
	var delegate_submit = function(e, data){
		var delegationEvent = $.Event('delegatedSubmit'); delegationEvent.delegatedEvent = e;
		return $(document).trigger(delegationEvent, data); 
	};

	$(document).bind('EntwineElementsAdded', function(e){
		var forms = $(e.targets).filter('form');
		if (!forms.length) return;

		forms.bind('submit.entwine_delegate_submit', delegate_submit);
	});

})(jQuery);
	;


/* src/jquery.entwine.eventcapture.js */

(function($) {

	$.entwine.Namespace.addMethods({
		bind_capture: function(selector, event, name, capture) {
			var store  = this.captures || (this.captures = {});
			var rulelists = store[event] || (store[event] = {});
			var rulelist = rulelists[name] || (rulelists[name] = $.entwine.RuleList());

			var rule = rulelist.addRule(selector, event);
			rule.handler = name;

			this.bind_proxy(selector, name, capture);
		}
	});

	var bindings = $.entwine.capture_bindings = {};

	var event_proxy = function(event) {
		return function(e) {
			var namespace, capturelists, forevent, capturelist, rule, handler, sel;

			for (var k in $.entwine.namespaces) {
				namespace = $.entwine.namespaces[k];
				capturelists = namespace.captures;

				if (capturelists && (forevent = capturelists[event])) {
					for (var k in forevent) {
						var capturelist = forevent[k];
						var triggered = namespace.$([]);

						// Stepping through each selector from most to least specific
						var j = capturelist.length;
						while (j--) {
							rule = capturelist[j];
							handler = rule.handler;
							sel = rule.selector.selector;

							var matching = namespace.$(sel).not(triggered);
							matching[handler].apply(matching, arguments);

							triggered = triggered.add(matching);
						}
					}
				}
			}
		}
	};

	var selector_proxy = function(selector, handler, includechildren) {
		var matcher = $.selector(selector);
		return function(e){
			if (matcher.matches(e.target)) return handler.apply(this, arguments);
		}
	};

	var document_proxy = function(selector, handler, includechildren) {
		return function(e){
			if (e.target === document) return handler.apply(this, arguments);
		}
	};

	var window_proxy = function(selector, handler, includechildren) {
		return function(e){
			if (e.target === window) return handler.apply(this, arguments);
		}
	};

	var property_proxy = function(property, handler, includechildren) {
		var matcher;

		return function(e){
			var match = this['get'+property]();

			if (typeof(match) == 'string') {
				var matcher = (matcher && match == matcher.selector) ? matcher : $.selector(match);
				if (matcher.matches(e.target)) return handler.apply(this, arguments);
			}
			else {
				if ($.inArray(e.target, match) !== -1) return handler.apply(this, arguments);
			}
		}
	};

	$.entwine.Namespace.addHandler({
		order: 10,

		bind: function(selector, k, v) {
			var match;
			if ($.isPlainObject(v) && (match = k.match(/^from\s*(.*)/))) {
				var from = match[1];
				var proxyGen;

				if (from.match(/[^\w]/)) proxyGen = selector_proxy;
				else if (from == 'Window' || from == 'window') proxyGen = window_proxy;
				else if (from == 'Document' || from == 'document') proxyGen = document_proxy;
				else proxyGen = property_proxy;

				for (var onevent in v) {
					var handler = v[onevent];
					match = onevent.match(/^on(.*)/);
					var event = match[1];

					this.bind_capture(selector, event, k + '_' + event, proxyGen(from, handler));

					if (!bindings[event]) {
						var namespaced = event.replace(/(\s+|$)/g, '.entwine$1');
						bindings[event] = event_proxy(event);

						$(proxyGen == window_proxy ? window : document).bind(namespaced, bindings[event]);
					}
				}

				return true;
			}
		}
	});

})(jQuery);
;


/* src/jquery.entwine.ctors.js */

(function($) {	

	/* Add the methods to handle constructor & destructor binding to the Namespace class */
	$.entwine.Namespace.addMethods({
		bind_condesc: function(selector, name, func) {
			var ctors = this.store.ctors || (this.store.ctors = $.entwine.RuleList()) ;
			
			var rule;
			for (var i = 0 ; i < ctors.length; i++) {
				if (ctors[i].selector.selector == selector.selector) {
					rule = ctors[i]; break;
				}
			}
			if (!rule) {
				rule = ctors.addRule(selector, 'ctors');
			}
			
			rule[name] = func;
			
			if (!ctors[name+'proxy']) {
				var one = this.one('ctors', name);
				var namespace = this;
				
				var proxy = function(els, i, func) {
					var j = els.length;
					while (j--) {
						var el = els[j];
						
						var tmp_i = el.i, tmp_f = el.f;
						el.i = i; el.f = one;
						
						try      { func.call(namespace.$(el)); }
						catch(e) { $.entwine.warn_exception(name, el, e); } 
						finally  { el.i = tmp_i; el.f = tmp_f; }					
					}
				};
				
				ctors[name+'proxy'] = proxy;
			}
		}
	});
	
	$.entwine.Namespace.addHandler({
		order: 30,
		
		bind: function(selector, k, v) {
			if ($.isFunction(v) && (k == 'onmatch' || k == 'onunmatch')) {
				// When we add new matchers we need to trigger a full global recalc once, regardless of the DOM changes that triggered the event
				this.matchersDirty = true;

				this.bind_condesc(selector, k, v);
				return true;
			}
		}
	});

	/**
	 * Finds all the elements that now match a different rule (or have been removed) and call onmatch on onunmatch as appropriate
	 * 
	 * Because this has to scan the DOM, and is therefore fairly slow, this is normally triggered off a short timeout, so that
	 * a series of DOM manipulations will only trigger this once.
	 * 
	 * The downside of this is that things like:
	 *   $('#foo').addClass('tabs'); $('#foo').tabFunctionBar();
	 * won't work.
	 */
	$(document).bind('EntwineSubtreeMaybeChanged', function(e, changes){
		// var start = (new Date).getTime();

		// For every namespace
		for (var k in $.entwine.namespaces) {
			var namespace = $.entwine.namespaces[k];

			// That has constructors or destructors
			var ctors = namespace.store.ctors;
			if (ctors) {
			
				// Keep a record of elements that have matched some previous more specific rule.
				// Not that we _don't_ actually do that until this is needed. If matched is null, it's not been calculated yet.
				// We also keep track of any elements that have newly been taken or released by a specific rule
				var matched = null, taken = $([]), released = $([]);

				// Updates matched to contain all the previously matched elements as if we'd been keeping track all along
				var calcmatched = function(j){
					if (matched !== null) return;
					matched = $([]);

					var cache, k = ctors.length;
					while ((--k) > j) {
						if (cache = ctors[k].cache) matched = matched.add(cache);
					}
				}

				// Some declared variables used in the loop
				var add, rem, res, rule, sel, ctor, dtor, full;

				// Stepping through each selector from most to least specific
				var j = ctors.length;
				while (j--) {
					// Build some quick-access variables
					rule = ctors[j];
					sel = rule.selector.selector;
					ctor = rule.onmatch; 
					dtor = rule.onunmatch;

					/*
						Rule.cache might be stale or fresh. It'll be stale if
					   - some more specific selector now has some of rule.cache in it
						- some change has happened that means new elements match this selector now
						- some change has happened that means elements no longer match this selector

						The first we can just compare rules.cache with matched, removing anything that's there already.
					*/

					// Reset the "elements that match this selector and no more specific selector with an onmatch rule" to null.
					// Staying null means this selector is fresh.
					res = null;

					// If this gets changed to true, it's too hard to do a delta update, so do a full update
					full = false;

					if (namespace.matchersDirty || changes.global) {
						// For now, just fall back to old version. We need to do something like changed.Subtree.find('*').andSelf().filter(sel), but that's _way_ slower on modern browsers than the below
						full = true;
					}
					else {
						// We don't deal with attributes yet, so any attribute change means we need to do a full recalc
						for (var k in changes.attrs) {	full = true; break; }

						/*
						 If a class changes, but it isn't listed in our selector, we don't care - the change couldn't affect whether or not any element matches

						 If it is listed on our selector
							- If it is on the direct match part, it could have added or removed the node it changed on
							- If it is on the context part, it could have added or removed any node that were previously included or excluded because of a match or failure to match with the context required on that node
							- NOTE: It might be on _both_
						 */

						var method = rule.selector.affectedBy(changes);

						if (method.classes.context) {
							full = true;
						}
						else {
							for (var k in method.classes.direct) {
								calcmatched(j);
								var recheck = changes.classes[k].not(matched);

								if (res === null) {
									res = rule.cache ? rule.cache.not(taken).add(released.filter(sel)) : $([]);
								}

								res = res.not(recheck).add(recheck.filter(sel));
							}
						}
					}

					if (full) {
						calcmatched(j);
						res = $(sel).not(matched);
					}
					else {
						if (!res) {
							// We weren't stale because of any changes to the DOM that affected this selector, but more specific
							// onmatches might have caused stale-ness

							// Do any of the previous released elements match this selector?
							add = released.length && released.filter(sel);

							if (add && add.length) {
								// Yes, so we're stale as we need to include them. Filter for any possible taken value at the same time
								res = rule.cache ? rule.cache.not(taken).add(add) : add;
							}
							else {
								// Do we think we own any of the elements now taken by more specific rules?
								rem = taken.length && rule.cache && rule.cache.filter(taken);

								if (rem && rem.length) {
									// Yes, so we're stale as we need to exclude them.
									res = rule.cache.not(rem);
								}
							}
						}
					}

					// Res will be null if we know we are fresh (no full needed, selector not affectedBy changes)
					if (res === null) {
						// If we are tracking matched, add ourselves
						if (matched && rule.cache) matched = matched.add(rule.cache);
					}
					else {
						// If this selector has a list of elements it matched against last time
						if (rule.cache) {
							// Find the ones that are extra this time
							add = res.not(rule.cache);
							rem = rule.cache.not(res);
						}
						else {
							add = res; rem = null;
						}

						if ((add && add.length) || (rem && rem.length)) {
							if (rem && rem.length) {
								released = released.add(rem);

								if (dtor && !rule.onunmatchRunning) {
									rule.onunmatchRunning = true;
									ctors.onunmatchproxy(rem, j, dtor);
									rule.onunmatchRunning = false;
								}
							}

							// Call the constructor on the newly matched ones
							if (add && add.length) {
								taken = taken.add(add);
								released = released.not(add);

								if (ctor && !rule.onmatchRunning) {
									rule.onmatchRunning = true;
									ctors.onmatchproxy(add, j, ctor);
									rule.onmatchRunning = false;
								}
							}
						}

						// If we are tracking matched, add ourselves
						if (matched) matched = matched.add(res);

						// And remember this list of matching elements again this selector, so next matching we can find the unmatched ones
						rule.cache = res;
					}
				}

				namespace.matchersDirty = false;
			}
		}

		// console.log((new Date).getTime() - start);
	});
	

})(jQuery);
;


/* src/jquery.entwine.addrem.js */

(function($) {

	$.entwine.Namespace.addMethods({
		build_addrem_proxy: function(name) {
			var one = this.one(name, 'func');

			return function() {
				if (this.length === 0){
					return;
				}
				else if (this.length) {
					var rv, i = this.length;
					while (i--) rv = one(this[i], arguments);
					return rv;
				}
				else {
					return one(this, arguments);
				}
			};
		},

		bind_addrem_proxy: function(selector, name, func) {
			var rulelist = this.store[name] || (this.store[name] = $.entwine.RuleList());

			var rule = rulelist.addRule(selector, name); rule.func = func;

			if (!this.injectee.hasOwnProperty(name)) {
				this.injectee[name] = this.build_addrem_proxy(name);
				this.injectee[name].isentwinemethod = true;
			}
		}
	});

	$.entwine.Namespace.addHandler({
		order: 30,

		bind: function(selector, k, v) {
			if ($.isFunction(v) && (k == 'onadd' || k == 'onremove')) {
				this.bind_addrem_proxy(selector, k, v);
				return true;
			}
		}
	});

	$(document).bind('EntwineElementsAdded', function(e){
		// For every namespace
		for (var k in $.entwine.namespaces) {
			var namespace = $.entwine.namespaces[k];
			if (namespace.injectee.onadd) namespace.injectee.onadd.call(e.targets);
		}
	});

	$(document).bind('EntwineElementsRemoved', function(e){
		for (var k in $.entwine.namespaces) {
			var namespace = $.entwine.namespaces[k];
			if (namespace.injectee.onremove) namespace.injectee.onremove.call(e.targets);
		}
	});




})(jQuery);
;


/* src/jquery.entwine.properties.js */

(function($) {	

	var entwine_prepend = '__entwine!';
	
	var getEntwineData = function(el, namespace, property) {
		return el.data(entwine_prepend + namespace + '!' + property);
	};
	
	var setEntwineData = function(el, namespace, property, value) {
		return el.data(entwine_prepend + namespace + '!' + property, value);
	};
	
	var getEntwineDataAsHash = function(el, namespace) {
		var hash = {};
		var id = jQuery.data(el[0]);
		
		var matchstr = entwine_prepend + namespace + '!';
		var matchlen = matchstr.length;
		
		var cache = jQuery.cache[id];
		for (var k in cache) {
			if (k.substr(0,matchlen) == matchstr) hash[k.substr(matchlen)] = cache[k];
		}
		
		return hash;
	};
	
	var setEntwineDataFromHash = function(el, namespace, hash) {
		for (var k in hash) setEntwineData(namespace, k, hash[k]);
	};

	var entwineData = function(el, namespace, args) {
		switch (args.length) {
			case 0:
				return getEntwineDataAsHash(el, namespace);
			case 1:
				if (typeof args[0] == 'string') return getEntwineData(el, namespace, args[0]);
				else                            return setEntwineDataFromHash(el, namespace, args[0]);
			default:
				return setEntwineData(el, namespace, args[0], args[1]);
		}
	};
 
	$.extend($.fn, {
		entwineData: function() {
			return entwineData(this, '__base', arguments);
		}
	});
	
	$.entwine.Namespace.addHandler({
		order: 60,
		
		bind: function(selector, k, v) {
			if (k.charAt(0) != k.charAt(0).toUpperCase()) $.entwine.warn('Entwine property '+k+' does not start with a capital letter', $.entwine.WARN_LEVEL_BESTPRACTISE);

			// Create the getters and setters

			var getterName = 'get'+k;
			var setterName = 'set'+k;

			this.bind_proxy(selector, getterName, function() { var r = this.entwineData(k); return r === undefined ? v : r; });
			this.bind_proxy(selector, setterName, function(v){ return this.entwineData(k, v); });
			
			// Get the get and set proxies we just created
			
			var getter = this.injectee[getterName];
			var setter = this.injectee[setterName];
			
			// And bind in the jQuery-style accessor
			
			this.bind_proxy(selector, k, function(v){ return (arguments.length == 1 ? setter : getter).call(this, v) ; });

			return true;
		},
		
		namespaceMethodOverrides: function(namespace){
			return {
				entwineData: function() {
					return entwineData(this, namespace.name, arguments);
				}
			};
		}
	});
	
})(jQuery);
;


/* src/jquery.entwine.legacy.js */

(function($) {	
	
	// Adds back concrete methods for backwards compatibility
	$.concrete = $.entwine;
	$.fn.concrete = $.fn.entwine;
	$.fn.concreteData = $.fn.entwineData;
	
	// Use addHandler to hack in the namespace.$.concrete equivilent to the namespace.$.entwine namespace-injection
	$.entwine.Namespace.addHandler({
		order: 100,
		bind: function(selector, k, v) { return false; },
	
		namespaceMethodOverrides: function(namespace){
			namespace.$.concrete = namespace.$.entwine;
			namespace.injectee.concrete = namespace.injectee.entwine;
			namespace.injectee.concreteData = namespace.injectee.entwineData;
			return {};
		}
	});

})(jQuery);
;


},{}],21:[function(require,module,exports){
/*!
 * jQuery Form Plugin
 * version: 2.96 (16-FEB-2012)
 * @requires jQuery v1.3.2 or later
 *
 * Examples and documentation at: http://malsup.com/jquery/form/
 * Dual licensed under the MIT and GPL licenses:
 *	http://www.opensource.org/licenses/mit-license.php
 *	http://www.gnu.org/licenses/gpl.html
 */
;(function($) {

/*
	Usage Note:
	-----------
	Do not use both ajaxSubmit and ajaxForm on the same form.  These
	functions are mutually exclusive.  Use ajaxSubmit if you want
	to bind your own submit handler to the form.  For example,

	$(document).ready(function() {
		$('#myForm').bind('submit', function(e) {
			e.preventDefault(); // <-- important
			$(this).ajaxSubmit({
				target: '#output'
			});
		});
	});

	Use ajaxForm when you want the plugin to manage all the event binding
	for you.  For example,

	$(document).ready(function() {
		$('#myForm').ajaxForm({
			target: '#output'
		});
	});
	
	You can also use ajaxForm with delegation (requires jQuery v1.7+), so the
	form does not have to exist when you invoke ajaxForm:

	$('#myForm').ajaxForm({
		delegation: true,
		target: '#output'
	});
	
	When using ajaxForm, the ajaxSubmit function will be invoked for you
	at the appropriate time.
*/

/**
 * ajaxSubmit() provides a mechanism for immediately submitting
 * an HTML form using AJAX.
 */
$.fn.ajaxSubmit = function(options) {
	// fast fail if nothing selected (http://dev.jquery.com/ticket/2752)
	if (!this.length) {
		log('ajaxSubmit: skipping submit process - no element selected');
		return this;
	}
	
	var method, action, url, $form = this;

	if (typeof options == 'function') {
		options = { success: options };
	}

	method = this.attr('method');
	action = this.attr('action');
	url = (typeof action === 'string') ? $.trim(action) : '';
	url = url || window.location.href || '';
	if (url) {
		// clean url (don't include hash vaue)
		url = (url.match(/^([^#]+)/)||[])[1];
	}

	options = $.extend(true, {
		url:  url,
		success: $.ajaxSettings.success,
		type: method || 'GET',
		iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank'
	}, options);

	// hook for manipulating the form data before it is extracted;
	// convenient for use with rich editors like tinyMCE or FCKEditor
	var veto = {};
	this.trigger('form-pre-serialize', [this, options, veto]);
	if (veto.veto) {
		log('ajaxSubmit: submit vetoed via form-pre-serialize trigger');
		return this;
	}

	// provide opportunity to alter form data before it is serialized
	if (options.beforeSerialize && options.beforeSerialize(this, options) === false) {
		log('ajaxSubmit: submit aborted via beforeSerialize callback');
		return this;
	}

	var traditional = options.traditional;
	if ( traditional === undefined ) {
		traditional = $.ajaxSettings.traditional;
	}
	
	var qx,n,v,a = this.formToArray(options.semantic);
	if (options.data) {
		options.extraData = options.data;
		qx = $.param(options.data, traditional);
	}

	// give pre-submit callback an opportunity to abort the submit
	if (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) {
		log('ajaxSubmit: submit aborted via beforeSubmit callback');
		return this;
	}

	// fire vetoable 'validate' event
	this.trigger('form-submit-validate', [a, this, options, veto]);
	if (veto.veto) {
		log('ajaxSubmit: submit vetoed via form-submit-validate trigger');
		return this;
	}

	var q = $.param(a, traditional);
	if (qx) {
		q = ( q ? (q + '&' + qx) : qx );
	}	
	if (options.type.toUpperCase() == 'GET') {
		options.url += (options.url.indexOf('?') >= 0 ? '&' : '?') + q;
		options.data = null;  // data is null for 'get'
	}
	else {
		options.data = q; // data is the query string for 'post'
	}

	var callbacks = [];
	if (options.resetForm) {
		callbacks.push(function() { $form.resetForm(); });
	}
	if (options.clearForm) {
		callbacks.push(function() { $form.clearForm(options.includeHidden); });
	}

	// perform a load on the target only if dataType is not provided
	if (!options.dataType && options.target) {
		var oldSuccess = options.success || function(){};
		callbacks.push(function(data) {
			var fn = options.replaceTarget ? 'replaceWith' : 'html';
			$(options.target)[fn](data).each(oldSuccess, arguments);
		});
	}
	else if (options.success) {
		callbacks.push(options.success);
	}

	options.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg
		var context = options.context || options;	// jQuery 1.4+ supports scope context 
		for (var i=0, max=callbacks.length; i < max; i++) {
			callbacks[i].apply(context, [data, status, xhr || $form, $form]);
		}
	};

	// are there files to upload?
	var fileInputs = $('input:file:enabled[value]', this); // [value] (issue #113)
	var hasFileInputs = fileInputs.length > 0;
	var mp = 'multipart/form-data';
	var multipart = ($form.attr('enctype') == mp || $form.attr('encoding') == mp);

	var fileAPI = !!(hasFileInputs && fileInputs.get(0).files && window.FormData);
	log("fileAPI :" + fileAPI);
	var shouldUseFrame = (hasFileInputs || multipart) && !fileAPI;

	// options.iframe allows user to force iframe mode
	// 06-NOV-09: now defaulting to iframe mode if file input is detected
	if (options.iframe !== false && (options.iframe || shouldUseFrame)) {
		// hack to fix Safari hang (thanks to Tim Molendijk for this)
		// see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
		if (options.closeKeepAlive) {
			$.get(options.closeKeepAlive, function() {
				fileUploadIframe(a);
			});
		}
  		else {
			fileUploadIframe(a);
  		}
	}
	else if ((hasFileInputs || multipart) && fileAPI) {
		options.progress = options.progress || $.noop;
		fileUploadXhr(a);
	}
	else {
		$.ajax(options);
	}

	 // fire 'notify' event
	 this.trigger('form-submit-notify', [this, options]);
	 return this;

	 // XMLHttpRequest Level 2 file uploads (big hat tip to francois2metz)
	function fileUploadXhr(a) {
		var formdata = new FormData();

		for (var i=0; i < a.length; i++) {
			if (a[i].type == 'file')
				continue;
			formdata.append(a[i].name, a[i].value);
		}

		$form.find('input:file:enabled').each(function(){
			var name = $(this).attr('name'), files = this.files;
			if (name) {
				for (var i=0; i < files.length; i++)
					formdata.append(name, files[i]);
			}
		});

		if (options.extraData) {
			for (var k in options.extraData)
				formdata.append(k, options.extraData[k])
		}

		options.data = null;

		var s = $.extend(true, {}, $.ajaxSettings, options, {
			contentType: false,
			processData: false,
			cache: false,
			type: 'POST'
		});

      //s.context = s.context || s;

      s.data = null;
      var beforeSend = s.beforeSend;
      s.beforeSend = function(xhr, o) {
          o.data = formdata;
          if(xhr.upload) { // unfortunately, jQuery doesn't expose this prop (http://bugs.jquery.com/ticket/10190)
              xhr.upload.onprogress = function(event) {
                  o.progress(event.position, event.total);
              };
          }
          if(beforeSend)
              beforeSend.call(o, xhr, options);
      };
      $.ajax(s);
   }

	// private function for handling file uploads (hat tip to YAHOO!)
	function fileUploadIframe(a) {
		var form = $form[0], el, i, s, g, id, $io, io, xhr, sub, n, timedOut, timeoutHandle;
		var useProp = !!$.fn.prop;

		if (a) {
			if ( useProp ) {
				// ensure that every serialized input is still enabled
				for (i=0; i < a.length; i++) {
					el = $(form[a[i].name]);
					el.prop('disabled', false);
				}
			} else {
				for (i=0; i < a.length; i++) {
					el = $(form[a[i].name]);
					el.removeAttr('disabled');
				}
			};
		}

		if ($(':input[name=submit],:input[id=submit]', form).length) {
			// if there is an input with a name or id of 'submit' then we won't be
			// able to invoke the submit fn on the form (at least not x-browser)
			alert('Error: Form elements must not have name or id of "submit".');
			return;
		}
		
		s = $.extend(true, {}, $.ajaxSettings, options);
		s.context = s.context || s;
		id = 'jqFormIO' + (new Date().getTime());
		if (s.iframeTarget) {
			$io = $(s.iframeTarget);
			n = $io.attr('name');
			if (n == null)
			 	$io.attr('name', id);
			else
				id = n;
		}
		else {
			$io = $('<iframe name="' + id + '" src="'+ s.iframeSrc +'" />');
			$io.css({ position: 'absolute', top: '-1000px', left: '-1000px' });
		}
		io = $io[0];


		xhr = { // mock object
			aborted: 0,
			responseText: null,
			responseXML: null,
			status: 0,
			statusText: 'n/a',
			getAllResponseHeaders: function() {},
			getResponseHeader: function() {},
			setRequestHeader: function() {},
			abort: function(status) {
				var e = (status === 'timeout' ? 'timeout' : 'aborted');
				log('aborting upload... ' + e);
				this.aborted = 1;
				$io.attr('src', s.iframeSrc); // abort op in progress
				xhr.error = e;
				s.error && s.error.call(s.context, xhr, e, status);
				g && $.event.trigger("ajaxError", [xhr, s, e]);
				s.complete && s.complete.call(s.context, xhr, e);
			}
		};

		g = s.global;
		// trigger ajax global events so that activity/block indicators work like normal
		if (g && ! $.active++) {
			$.event.trigger("ajaxStart");
		}
		if (g) {
			$.event.trigger("ajaxSend", [xhr, s]);
		}

		if (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {
			if (s.global) {
				$.active--;
			}
			return;
		}
		if (xhr.aborted) {
			return;
		}

		// add submitting element to data if we know it
		sub = form.clk;
		if (sub) {
			n = sub.name;
			if (n && !sub.disabled) {
				s.extraData = s.extraData || {};
				s.extraData[n] = sub.value;
				if (sub.type == "image") {
					s.extraData[n+'.x'] = form.clk_x;
					s.extraData[n+'.y'] = form.clk_y;
				}
			}
		}
		
		var CLIENT_TIMEOUT_ABORT = 1;
		var SERVER_ABORT = 2;

		function getDoc(frame) {
			var doc = frame.contentWindow ? frame.contentWindow.document : frame.contentDocument ? frame.contentDocument : frame.document;
			return doc;
		}
		
		// Rails CSRF hack (thanks to Yvan Barthelemy)
		var csrf_token = $('meta[name=csrf-token]').attr('content');
		var csrf_param = $('meta[name=csrf-param]').attr('content');
		if (csrf_param && csrf_token) {
			s.extraData = s.extraData || {};
			s.extraData[csrf_param] = csrf_token;
		}

		// take a breath so that pending repaints get some cpu time before the upload starts
		function doSubmit() {
			// make sure form attrs are set
			var t = $form.attr('target'), a = $form.attr('action');

			// update form attrs in IE friendly way
			form.setAttribute('target',id);
			if (!method) {
				form.setAttribute('method', 'POST');
			}
			if (a != s.url) {
				form.setAttribute('action', s.url);
			}

			// ie borks in some cases when setting encoding
			if (! s.skipEncodingOverride && (!method || /post/i.test(method))) {
				$form.attr({
					encoding: 'multipart/form-data',
					enctype:  'multipart/form-data'
				});
			}

			// support timout
			if (s.timeout) {
				timeoutHandle = setTimeout(function() { timedOut = true; cb(CLIENT_TIMEOUT_ABORT); }, s.timeout);
			}
			
			// look for server aborts
			function checkState() {
				try {
					var state = getDoc(io).readyState;
					log('state = ' + state);
					if (state.toLowerCase() == 'uninitialized')
						setTimeout(checkState,50);
				}
				catch(e) {
					log('Server abort: ' , e, ' (', e.name, ')');
					cb(SERVER_ABORT);
					timeoutHandle && clearTimeout(timeoutHandle);
					timeoutHandle = undefined;
				}
			}

			// add "extra" data to form if provided in options
			var extraInputs = [];
			try {
				if (s.extraData) {
					for (var n in s.extraData) {
						extraInputs.push(
							$('<input type="hidden" name="'+n+'">').attr('value',s.extraData[n])
								.appendTo(form)[0]);
					}
				}

				if (!s.iframeTarget) {
					// add iframe to doc and submit the form
					$io.appendTo('body');
					io.attachEvent ? io.attachEvent('onload', cb) : io.addEventListener('load', cb, false);
				}
				setTimeout(checkState,15);
				form.submit();
			}
			finally {
				// reset attrs and remove "extra" input elements
				form.setAttribute('action',a);
				if(t) {
					form.setAttribute('target', t);
				} else {
					$form.removeAttr('target');
				}
				$(extraInputs).remove();
			}
		}

		if (s.forceSync) {
			doSubmit();
		}
		else {
			setTimeout(doSubmit, 10); // this lets dom updates render
		}

		var data, doc, domCheckCount = 50, callbackProcessed;

		function cb(e) {
			if (xhr.aborted || callbackProcessed) {
				return;
			}
			try {
				doc = getDoc(io);
			}
			catch(ex) {
				log('cannot access response document: ', ex);
				e = SERVER_ABORT;
			}
			if (e === CLIENT_TIMEOUT_ABORT && xhr) {
				xhr.abort('timeout');
				return;
			}
			else if (e == SERVER_ABORT && xhr) {
				xhr.abort('server abort');
				return;
			}

			if (!doc || doc.location.href == s.iframeSrc) {
				// response not received yet
				if (!timedOut)
					return;
			}
			io.detachEvent ? io.detachEvent('onload', cb) : io.removeEventListener('load', cb, false);

			var status = 'success', errMsg;
			try {
				if (timedOut) {
					throw 'timeout';
				}

				var isXml = s.dataType == 'xml' || doc.XMLDocument || $.isXMLDoc(doc);
				log('isXml='+isXml);
				if (!isXml && window.opera && (doc.body == null || doc.body.innerHTML == '')) {
					if (--domCheckCount) {
						// in some browsers (Opera) the iframe DOM is not always traversable when
						// the onload callback fires, so we loop a bit to accommodate
						log('requeing onLoad callback, DOM not available');
						setTimeout(cb, 250);
						return;
					}
					// let this fall through because server response could be an empty document
					//log('Could not access iframe DOM after mutiple tries.');
					//throw 'DOMException: not available';
				}

				//log('response detected');
				var docRoot = doc.body ? doc.body : doc.documentElement;
				xhr.responseText = docRoot ? docRoot.innerHTML : null;
				xhr.responseXML = doc.XMLDocument ? doc.XMLDocument : doc;
				if (isXml)
					s.dataType = 'xml';
				xhr.getResponseHeader = function(header){
					var headers = {'content-type': s.dataType};
					return headers[header];
				};
				// support for XHR 'status' & 'statusText' emulation :
				if (docRoot) {
					xhr.status = Number( docRoot.getAttribute('status') ) || xhr.status;
					xhr.statusText = docRoot.getAttribute('statusText') || xhr.statusText;
				}

				var dt = (s.dataType || '').toLowerCase();
				var scr = /(json|script|text)/.test(dt);
				if (scr || s.textarea) {
					// see if user embedded response in textarea
					var ta = doc.getElementsByTagName('textarea')[0];
					if (ta) {
						xhr.responseText = ta.value;
						// support for XHR 'status' & 'statusText' emulation :
						xhr.status = Number( ta.getAttribute('status') ) || xhr.status;
						xhr.statusText = ta.getAttribute('statusText') || xhr.statusText;
					}
					else if (scr) {
						// account for browsers injecting pre around json response
						var pre = doc.getElementsByTagName('pre')[0];
						var b = doc.getElementsByTagName('body')[0];
						if (pre) {
							xhr.responseText = pre.textContent ? pre.textContent : pre.innerText;
						}
						else if (b) {
							xhr.responseText = b.textContent ? b.textContent : b.innerText;
						}
					}
				}
				else if (dt == 'xml' && !xhr.responseXML && xhr.responseText != null) {
					xhr.responseXML = toXml(xhr.responseText);
				}

				try {
					data = httpData(xhr, dt, s);
				}
				catch (e) {
					status = 'parsererror';
					xhr.error = errMsg = (e || status);
				}
			}
			catch (e) {
				log('error caught: ',e);
				status = 'error';
				xhr.error = errMsg = (e || status);
			}

			if (xhr.aborted) {
				log('upload aborted');
				status = null;
			}

			if (xhr.status) { // we've set xhr.status
				status = (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) ? 'success' : 'error';
			}

			// ordering of these callbacks/triggers is odd, but that's how $.ajax does it
			if (status === 'success') {
				s.success && s.success.call(s.context, data, 'success', xhr);
				g && $.event.trigger("ajaxSuccess", [xhr, s]);
			}
			else if (status) {
				if (errMsg == undefined)
					errMsg = xhr.statusText;
				s.error && s.error.call(s.context, xhr, status, errMsg);
				g && $.event.trigger("ajaxError", [xhr, s, errMsg]);
			}

			g && $.event.trigger("ajaxComplete", [xhr, s]);

			if (g && ! --$.active) {
				$.event.trigger("ajaxStop");
			}

			s.complete && s.complete.call(s.context, xhr, status);

			callbackProcessed = true;
			if (s.timeout)
				clearTimeout(timeoutHandle);

			// clean up
			setTimeout(function() {
				if (!s.iframeTarget)
					$io.remove();
				xhr.responseXML = null;
			}, 100);
		}

		var toXml = $.parseXML || function(s, doc) { // use parseXML if available (jQuery 1.5+)
			if (window.ActiveXObject) {
				doc = new ActiveXObject('Microsoft.XMLDOM');
				doc.async = 'false';
				doc.loadXML(s);
			}
			else {
				doc = (new DOMParser()).parseFromString(s, 'text/xml');
			}
			return (doc && doc.documentElement && doc.documentElement.nodeName != 'parsererror') ? doc : null;
		};
		var parseJSON = $.parseJSON || function(s) {
			return window['eval']('(' + s + ')');
		};

		var httpData = function( xhr, type, s ) { // mostly lifted from jq1.4.4

			var ct = xhr.getResponseHeader('content-type') || '',
				xml = type === 'xml' || !type && ct.indexOf('xml') >= 0,
				data = xml ? xhr.responseXML : xhr.responseText;

			if (xml && data.documentElement.nodeName === 'parsererror') {
				$.error && $.error('parsererror');
			}
			if (s && s.dataFilter) {
				data = s.dataFilter(data, type);
			}
			if (typeof data === 'string') {
				if (type === 'json' || !type && ct.indexOf('json') >= 0) {
					data = parseJSON(data);
				} else if (type === "script" || !type && ct.indexOf("javascript") >= 0) {
					$.globalEval(data);
				}
			}
			return data;
		};
	}
};

/**
 * ajaxForm() provides a mechanism for fully automating form submission.
 *
 * The advantages of using this method instead of ajaxSubmit() are:
 *
 * 1: This method will include coordinates for <input type="image" /> elements (if the element
 *	is used to submit the form).
 * 2. This method will include the submit element's name/value data (for the element that was
 *	used to submit the form).
 * 3. This method binds the submit() method to the form for you.
 *
 * The options argument for ajaxForm works exactly as it does for ajaxSubmit.  ajaxForm merely
 * passes the options argument along after properly binding events for submit elements and
 * the form itself.
 */
$.fn.ajaxForm = function(options) {
	options = options || {};
	options.delegation = options.delegation && $.isFunction($.fn.on);
	
	// in jQuery 1.3+ we can fix mistakes with the ready state
	if (!options.delegation && this.length === 0) {
		var o = { s: this.selector, c: this.context };
		if (!$.isReady && o.s) {
			log('DOM not ready, queuing ajaxForm');
			$(function() {
				$(o.s,o.c).ajaxForm(options);
			});
			return this;
		}
		// is your DOM ready?  http://docs.jquery.com/Tutorials:Introducing_$(document).ready()
		log('terminating; zero elements found by selector' + ($.isReady ? '' : ' (DOM not ready)'));
		return this;
	}

	if ( options.delegation ) {
		$(document)
			.off('submit.form-plugin', this.selector, doAjaxSubmit)
			.off('click.form-plugin', this.selector, captureSubmittingElement)
			.on('submit.form-plugin', this.selector, options, doAjaxSubmit)
			.on('click.form-plugin', this.selector, options, captureSubmittingElement);
		return this;
	}

	return this.ajaxFormUnbind()
		.bind('submit.form-plugin', options, doAjaxSubmit)
		.bind('click.form-plugin', options, captureSubmittingElement);
};

// private event handlers	
function doAjaxSubmit(e) {
	var options = e.data;
	if (!e.isDefaultPrevented()) { // if event has been canceled, don't proceed
		e.preventDefault();
		$(this).ajaxSubmit(options);
	}
}
	
function captureSubmittingElement(e) {
	var target = e.target;
	var $el = $(target);
	if (!($el.is(":submit,input:image"))) {
		// is this a child element of the submit el?  (ex: a span within a button)
		var t = $el.closest(':submit');
		if (t.length == 0) {
			return;
		}
		target = t[0];
	}
	var form = this;
	form.clk = target;
	if (target.type == 'image') {
		if (e.offsetX != undefined) {
			form.clk_x = e.offsetX;
			form.clk_y = e.offsetY;
		} else if (typeof $.fn.offset == 'function') {
			var offset = $el.offset();
			form.clk_x = e.pageX - offset.left;
			form.clk_y = e.pageY - offset.top;
		} else {
			form.clk_x = e.pageX - target.offsetLeft;
			form.clk_y = e.pageY - target.offsetTop;
		}
	}
	// clear form vars
	setTimeout(function() { form.clk = form.clk_x = form.clk_y = null; }, 100);
};


// ajaxFormUnbind unbinds the event handlers that were bound by ajaxForm
$.fn.ajaxFormUnbind = function() {
	return this.unbind('submit.form-plugin click.form-plugin');
};

/**
 * formToArray() gathers form element data into an array of objects that can
 * be passed to any of the following ajax functions: $.get, $.post, or load.
 * Each object in the array has both a 'name' and 'value' property.  An example of
 * an array for a simple login form might be:
 *
 * [ { name: 'username', value: 'jresig' }, { name: 'password', value: 'secret' } ]
 *
 * It is this array that is passed to pre-submit callback functions provided to the
 * ajaxSubmit() and ajaxForm() methods.
 */
$.fn.formToArray = function(semantic) {
	var a = [];
	if (this.length === 0) {
		return a;
	}

	var form = this[0];
	var els = semantic ? form.getElementsByTagName('*') : form.elements;
	if (!els) {
		return a;
	}

	var i,j,n,v,el,max,jmax;
	for(i=0, max=els.length; i < max; i++) {
		el = els[i];
		n = el.name;
		if (!n) {
			continue;
		}

		if (semantic && form.clk && el.type == "image") {
			// handle image inputs on the fly when semantic == true
			if(!el.disabled && form.clk == el) {
				a.push({name: n, value: $(el).val(), type: el.type });
				a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
			}
			continue;
		}

		v = $.fieldValue(el, true);
		if (v && v.constructor == Array) {
			for(j=0, jmax=v.length; j < jmax; j++) {
				a.push({name: n, value: v[j]});
			}
		}
		else if (v !== null && typeof v != 'undefined') {
			a.push({name: n, value: v, type: el.type});
		}
	}

	if (!semantic && form.clk) {
		// input type=='image' are not found in elements array! handle it here
		var $input = $(form.clk), input = $input[0];
		n = input.name;
		if (n && !input.disabled && input.type == 'image') {
			a.push({name: n, value: $input.val()});
			a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
		}
	}
	return a;
};

/**
 * Serializes form data into a 'submittable' string. This method will return a string
 * in the format: name1=value1&amp;name2=value2
 */
$.fn.formSerialize = function(semantic) {
	//hand off to jQuery.param for proper encoding
	return $.param(this.formToArray(semantic));
};

/**
 * Serializes all field elements in the jQuery object into a query string.
 * This method will return a string in the format: name1=value1&amp;name2=value2
 */
$.fn.fieldSerialize = function(successful) {
	var a = [];
	this.each(function() {
		var n = this.name;
		if (!n) {
			return;
		}
		var v = $.fieldValue(this, successful);
		if (v && v.constructor == Array) {
			for (var i=0,max=v.length; i < max; i++) {
				a.push({name: n, value: v[i]});
			}
		}
		else if (v !== null && typeof v != 'undefined') {
			a.push({name: this.name, value: v});
		}
	});
	//hand off to jQuery.param for proper encoding
	return $.param(a);
};

/**
 * Returns the value(s) of the element in the matched set.  For example, consider the following form:
 *
 *  <form><fieldset>
 *	  <input name="A" type="text" />
 *	  <input name="A" type="text" />
 *	  <input name="B" type="checkbox" value="B1" />
 *	  <input name="B" type="checkbox" value="B2"/>
 *	  <input name="C" type="radio" value="C1" />
 *	  <input name="C" type="radio" value="C2" />
 *  </fieldset></form>
 *
 *  var v = $(':text').fieldValue();
 *  // if no values are entered into the text inputs
 *  v == ['','']
 *  // if values entered into the text inputs are 'foo' and 'bar'
 *  v == ['foo','bar']
 *
 *  var v = $(':checkbox').fieldValue();
 *  // if neither checkbox is checked
 *  v === undefined
 *  // if both checkboxes are checked
 *  v == ['B1', 'B2']
 *
 *  var v = $(':radio').fieldValue();
 *  // if neither radio is checked
 *  v === undefined
 *  // if first radio is checked
 *  v == ['C1']
 *
 * The successful argument controls whether or not the field element must be 'successful'
 * (per http://www.w3.org/TR/html4/interact/forms.html#successful-controls).
 * The default value of the successful argument is true.  If this value is false the value(s)
 * for each element is returned.
 *
 * Note: This method *always* returns an array.  If no valid value can be determined the
 *	array will be empty, otherwise it will contain one or more values.
 */
$.fn.fieldValue = function(successful) {
	for (var val=[], i=0, max=this.length; i < max; i++) {
		var el = this[i];
		var v = $.fieldValue(el, successful);
		if (v === null || typeof v == 'undefined' || (v.constructor == Array && !v.length)) {
			continue;
		}
		v.constructor == Array ? $.merge(val, v) : val.push(v);
	}
	return val;
};

/**
 * Returns the value of the field element.
 */
$.fieldValue = function(el, successful) {
	var n = el.name, t = el.type, tag = el.tagName.toLowerCase();
	if (successful === undefined) {
		successful = true;
	}

	if (successful && (!n || el.disabled || t == 'reset' || t == 'button' ||
		(t == 'checkbox' || t == 'radio') && !el.checked ||
		(t == 'submit' || t == 'image') && el.form && el.form.clk != el ||
		tag == 'select' && el.selectedIndex == -1)) {
			return null;
	}

	if (tag == 'select') {
		var index = el.selectedIndex;
		if (index < 0) {
			return null;
		}
		var a = [], ops = el.options;
		var one = (t == 'select-one');
		var max = (one ? index+1 : ops.length);
		for(var i=(one ? index : 0); i < max; i++) {
			var op = ops[i];
			if (op.selected) {
				var v = op.value;
				if (!v) { // extra pain for IE...
					v = (op.attributes && op.attributes['value'] && !(op.attributes['value'].specified)) ? op.text : op.value;
				}
				if (one) {
					return v;
				}
				a.push(v);
			}
		}
		return a;
	}
	return $(el).val();
};

/**
 * Clears the form data.  Takes the following actions on the form's input fields:
 *  - input text fields will have their 'value' property set to the empty string
 *  - select elements will have their 'selectedIndex' property set to -1
 *  - checkbox and radio inputs will have their 'checked' property set to false
 *  - inputs of type submit, button, reset, and hidden will *not* be effected
 *  - button elements will *not* be effected
 */
$.fn.clearForm = function(includeHidden) {
	return this.each(function() {
		$('input,select,textarea', this).clearFields(includeHidden);
	});
};

/**
 * Clears the selected form elements.
 */
$.fn.clearFields = $.fn.clearInputs = function(includeHidden) {
	var re = /^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i; // 'hidden' is not in this list
	return this.each(function() {
		var t = this.type, tag = this.tagName.toLowerCase();
		if (re.test(t) || tag == 'textarea' || (includeHidden && /hidden/.test(t)) ) {
			this.value = '';
		}
		else if (t == 'checkbox' || t == 'radio') {
			this.checked = false;
		}
		else if (tag == 'select') {
			this.selectedIndex = -1;
		}
	});
};

/**
 * Resets the form data.  Causes all form elements to be reset to their original value.
 */
$.fn.resetForm = function() {
	return this.each(function() {
		// guard against an input with the name of 'reset'
		// note that IE reports the reset function as an 'object'
		if (typeof this.reset == 'function' || (typeof this.reset == 'object' && !this.reset.nodeType)) {
			this.reset();
		}
	});
};

/**
 * Enables or disables any matching elements.
 */
$.fn.enable = function(b) {
	if (b === undefined) {
		b = true;
	}
	return this.each(function() {
		this.disabled = !b;
	});
};

/**
 * Checks/unchecks any matching checkboxes or radio buttons and
 * selects/deselects and matching option elements.
 */
$.fn.selected = function(select) {
	if (select === undefined) {
		select = true;
	}
	return this.each(function() {
		var t = this.type;
		if (t == 'checkbox' || t == 'radio') {
			this.checked = select;
		}
		else if (this.tagName.toLowerCase() == 'option') {
			var $sel = $(this).parent('select');
			if (select && $sel[0] && $sel[0].type == 'select-one') {
				// deselect all other options
				$sel.find('option').selected(false);
			}
			this.selected = select;
		}
	});
};

// expose debug var
$.fn.ajaxSubmit.debug = false;

// helper fn for console logging
function log() {
	if (!$.fn.ajaxSubmit.debug) 
		return;
	var msg = '[jquery.form] ' + Array.prototype.join.call(arguments,'');
	if (window.console && window.console.log) {
		window.console.log(msg);
	}
	else if (window.opera && window.opera.postError) {
		window.opera.postError(msg);
	}
};

})(jQuery);
},{}],22:[function(require,module,exports){
/**
 * On-demand JavaScript handler
 *
 * Based on http://plugins.jquery.com/files/issues/jquery.ondemand.js_.txt
 * and heavily modified to integrate with SilverStripe and prototype.js.
 * Adds capabilities for custom X-Include-CSS and X-Include-JS HTTP headers
 * to request loading of externals alongside an ajax response.
 *
 * Requires jQuery 1.5 ($.Deferred support)
 *
 * CAUTION: Relies on customization of the 'beforeSend' callback in jQuery.ajaxSetup()
 *
 * @author Ingo Schommer (ingo at silverstripe dot com)
 * @author Sam Minnee (sam at silverstripe dot com)
 */
(function($){

	var decodePath = function(str) {
		return str.replace(/%2C/g,',').replace(/\&amp;/g, '&').replace(/^\s+|\s+$/g, '');
	};

	$.extend({

		// loaded files list - to protect against loading existed file again  (by PGA)
		_ondemand_loaded_list : null,

		/**
		 * Returns true if the given CSS or JS script has already been loaded
		 */
		isItemLoaded : function(scriptUrl) {
			var self = this, src;
			if(this._ondemand_loaded_list === null) {
				this._ondemand_loaded_list = {};
				$('script').each(function() {
					src = $(this).attr('src');
					if(src) self._ondemand_loaded_list[src] = 1;
				});
				$('link[rel="stylesheet"]').each(function() {
					src = $(this).attr('href');
					if(src) self._ondemand_loaded_list[src] = 1;
				});
			}
			return (this._ondemand_loaded_list[decodePath(scriptUrl)] !== undefined);
		},

		requireCss : function(styleUrl, media){
			if(!media) media = 'all';

			// Don't double up on loading scripts
			if($.isItemLoaded(styleUrl)) return;

			if(document.createStyleSheet){
				var ss = document.createStyleSheet(styleUrl);
				ss.media = media;

			} else {
				var styleTag = document.createElement('link');
				$(styleTag).attr({
					href	: styleUrl,
					type	: 'text/css',
					media 	: media,
					rel		: 'stylesheet'
				}).appendTo($('head').get(0));
			}

			this._ondemand_loaded_list[styleUrl] = 1;

		},

		/**
		 * Process the X-Include-CSS and X-Include-JS headers provided by the Requirements class
		 */
		processOnDemandHeaders: function(xml, status, xhr) {
			var self = this, processDfd = new $.Deferred();

			// CSS
			if(xhr.getResponseHeader && xhr.getResponseHeader('X-Include-CSS')) {
				var cssIncludes = xhr.getResponseHeader('X-Include-CSS').split(',');
				for(var i=0;i<cssIncludes.length;i++) {
					// Syntax: "URL:##:media"
					if(cssIncludes[i].match(/^(.*):##:(.*)$/)) {
						$.requireCss(decodePath(RegExp.$1), RegExp.$2);
					// Syntax: "URL"
					} else {
						$.requireCss(decodePath(cssIncludes[i]));
					}
				}
			}

			// JavaScript
			var newJsIncludes = [];
			if(xhr.getResponseHeader && xhr.getResponseHeader('X-Include-JS')) {
				var jsIncludes = xhr.getResponseHeader('X-Include-JS').split(',');
				for(var i=0;i<jsIncludes.length;i++) {
					var jsIncludePath = decodePath(jsIncludes[i]);
					if(!$.isItemLoaded(jsIncludePath)) {
						newJsIncludes.push(jsIncludePath);
					}
				}
			}

			// We make an array of the includes that are actually new, and attach the callback to the last one
			// They are placed in a queue and will be included in order.  This means that the callback will
			// be able to execute script in the new includes (such as a livequery update)
			var getScriptQueue = function() {
				if(newJsIncludes.length) {
					var newJsInclude = newJsIncludes.shift();
					// emulates getScript() with addtl. setting
					$.ajax({
						dataType: 'script',
						url: newJsInclude,
						success: function() {
							self._ondemand_loaded_list[newJsInclude] = 1;
							getScriptQueue();
						},
						cache: false,
						// jQuery seems to override the XHR objects if used in async mode
						async: false
					});
				} else {
					processDfd.resolve(xml, status, xhr);
				}
			}

			if(newJsIncludes.length) {
				getScriptQueue();
			} else {
				// If there aren't any new includes, then we can just call the callbacks ourselves
				processDfd.resolve(xml, status, xhr);
			}

			return processDfd.promise();
		}

	});

	$.ajaxSetup({
		// beforeSend is the only place to access the XHR object before success handlers are added
		beforeSend: function(jqXHR, s) {
			// Avoid recursion in ajax callbacks caused by getScript(), by not parsing
			// ondemand headers for 'script' datatypes
			if(s.dataType == 'script') return;

			var dfd = new $.Deferred();

			// Register our own success handler (assumes no handlers are already registered)
			// 'success' is an alias for 'done', which is executed by the built-in deferred instance in $.ajax()
			jqXHR.success(function(success, statusText, jXHR) {
				$.processOnDemandHeaders(success, statusText, jXHR).done(function() {
					dfd.resolveWith(s.context || this, [success, statusText, jXHR]);
				});
			});

			// Reroute all external success hanlders through our own deferred.
			// Not overloading fail() as no event can cause the original request to fail.
			jqXHR.success = function(callback) {
				dfd.done(callback);
			}
		}
	});


})(jQuery);

},{}],23:[function(require,module,exports){
/**
 * jQuery.query - Query String Modification and Creation for jQuery
 * Written by Blair Mitchelmore (blair DOT mitchelmore AT gmail DOT com)
 * Licensed under the WTFPL (http://sam.zoy.org/wtfpl/).
 * Date: 2009/8/13
 *
 * @author Blair Mitchelmore
 * @version 2.1.7
 *
 **/
new function(settings) { 
  // Various Settings
  var $separator = settings.separator || '&';
  var $spaces = settings.spaces === false ? false : true;
  var $suffix = settings.suffix === false ? '' : '[]';
  var $prefix = settings.prefix === false ? false : true;
  var $hash = $prefix ? settings.hash === true ? "#" : "?" : "";
  var $numbers = settings.numbers === false ? false : true;
  
  jQuery.query = new function() {
    var is = function(o, t) {
      return o != undefined && o !== null && (!!t ? o.constructor == t : true);
    };
    var parse = function(path) {
      var m, rx = /\[([^[]*)\]/g, match = /^([^[]+)(\[.*\])?$/.exec(path), base = match[1], tokens = [];
      while (m = rx.exec(match[2])) tokens.push(m[1]);
      return [base, tokens];
    };
    var set = function(target, tokens, value) {
      var o, token = tokens.shift();
      if (typeof target != 'object') target = null;
      if (token === "") {
        if (!target) target = [];
        if (is(target, Array)) {
          target.push(tokens.length == 0 ? value : set(null, tokens.slice(0), value));
        } else if (is(target, Object)) {
          var i = 0;
          while (target[i++] != null);
          target[--i] = tokens.length == 0 ? value : set(target[i], tokens.slice(0), value);
        } else {
          target = [];
          target.push(tokens.length == 0 ? value : set(null, tokens.slice(0), value));
        }
      } else if (token && token.match(/^\s*[0-9]+\s*$/)) {
        var index = parseInt(token, 10);
        if (!target) target = [];
        target[index] = tokens.length == 0 ? value : set(target[index], tokens.slice(0), value);
      } else if (token) {
        var index = token.replace(/^\s*|\s*$/g, "");
        if (!target) target = {};
        if (is(target, Array)) {
          var temp = {};
          for (var i = 0; i < target.length; ++i) {
            temp[i] = target[i];
          }
          target = temp;
        }
        target[index] = tokens.length == 0 ? value : set(target[index], tokens.slice(0), value);
      } else {
        return value;
      }
      return target;
    };
    
    var queryObject = function(a) {
      var self = this;
      self.keys = {};
      
      if (a.queryObject) {
        jQuery.each(a.get(), function(key, val) {
          self.SET(key, val);
        });
      } else {
        jQuery.each(arguments, function() {
          var q = "" + this;
          q = q.replace(/^[?#]/,''); // remove any leading ? || #
          q = q.replace(/[;&]$/,''); // remove any trailing & || ;
          if ($spaces) q = q.replace(/[+]/g,' '); // replace +'s with spaces
          
          jQuery.each(q.split(/[&;]/), function(){
            var key = decodeURIComponent(this.split('=')[0] || "");
            var val = decodeURIComponent(this.split('=')[1] || "");
            
            if (!key) return;
            
            if ($numbers) {
              if (/^[+-]?[0-9]+\.[0-9]*$/.test(val)) // simple float regex
                val = parseFloat(val);
              else if (/^[+-]?[0-9]+$/.test(val)) // simple int regex
                val = parseInt(val, 10);
            }
            
            val = (!val && val !== 0) ? true : val;
            
            if (val !== false && val !== true && typeof val != 'number')
              val = val;
            
            self.SET(key, val);
          });
        });
      }
      return self;
    };
    
    queryObject.prototype = {
      queryObject: true,
      has: function(key, type) {
        var value = this.get(key);
        return is(value, type);
      },
      GET: function(key) {
        if (!is(key)) return this.keys;
        var parsed = parse(key), base = parsed[0], tokens = parsed[1];
        var target = this.keys[base];
        while (target != null && tokens.length != 0) {
          target = target[tokens.shift()];
        }
        return typeof target == 'number' ? target : target || "";
      },
      get: function(key) {
        var target = this.GET(key);
        if (is(target, Object))
          return jQuery.extend(true, {}, target);
        else if (is(target, Array))
          return target.slice(0);
        return target;
      },
      SET: function(key, val) {
        var value = !is(val) ? null : val;
        var parsed = parse(key), base = parsed[0], tokens = parsed[1];
        var target = this.keys[base];
        this.keys[base] = set(target, tokens.slice(0), value);
        return this;
      },
      set: function(key, val) {
        return this.copy().SET(key, val);
      },
      REMOVE: function(key) {
        return this.SET(key, null).COMPACT();
      },
      remove: function(key) {
        return this.copy().REMOVE(key);
      },
      EMPTY: function() {
        var self = this;
        jQuery.each(self.keys, function(key, value) {
          delete self.keys[key];
        });
        return self;
      },
      load: function(url) {
        var hash = url.replace(/^.*?[#](.+?)(?:\?.+)?$/, "$1");
        var search = url.replace(/^.*?[?](.+?)(?:#.+)?$/, "$1");
        return new queryObject(url.length == search.length ? '' : search, url.length == hash.length ? '' : hash);
      },
      empty: function() {
        return this.copy().EMPTY();
      },
      copy: function() {
        return new queryObject(this);
      },
      COMPACT: function() {
        function build(orig) {
          var obj = typeof orig == "object" ? is(orig, Array) ? [] : {} : orig;
          if (typeof orig == 'object') {
            function add(o, key, value) {
              if (is(o, Array))
                o.push(value);
              else
                o[key] = value;
            }
            jQuery.each(orig, function(key, value) {
              if (!is(value)) return true;
              add(obj, key, build(value));
            });
          }
          return obj;
        }
        this.keys = build(this.keys);
        return this;
      },
      compact: function() {
        return this.copy().COMPACT();
      },
      toString: function() {
        var i = 0, queryString = [], chunks = [], self = this;
        var encode = function(str) {
          str = str + "";
          if ($spaces) str = str.replace(/ /g, "+");
          return encodeURIComponent(str);
        };
        var addFields = function(arr, key, value) {
          if (!is(value) || value === false) return;
          var o = [encode(key)];
          if (value !== true) {
            o.push("=");
            o.push(encode(value));
          }
          arr.push(o.join(""));
        };
        var build = function(obj, base) {
          var newKey = function(key) {
            return !base || base == "" ? [key].join("") : [base, "[", key, "]"].join("");
          };
          jQuery.each(obj, function(key, value) {
            if (typeof value == 'object') 
              build(value, newKey(key));
            else
              addFields(chunks, newKey(key), value);
          });
        };
        
        build(this.keys);
        
        if (chunks.length > 0) queryString.push($hash);
        queryString.push(chunks.join($separator));
        
        return queryString.join("");
      }
    };
    
    return new queryObject(location.search, location.hash);
  };
}(jQuery.query || {}); // Pass in jQuery.query as settings object
},{}],24:[function(require,module,exports){
/*! jQuery UI - v1.9.2 - 2012-11-23
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.position.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.effect.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js, jquery.ui.menu.js, jquery.ui.progressbar.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.slider.js, jquery.ui.sortable.js, jquery.ui.spinner.js, jquery.ui.tabs.js, jquery.ui.tooltip.js
* Copyright (c) 2012 jQuery Foundation and other contributors Licensed MIT */

(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// prevent duplicate loading
// this is only a problem because we proxy existing functions
// and we don't want to double proxy them
$.ui = $.ui || {};
if ( $.ui.version ) {
	return;
}

$.extend( $.ui, {
	version: "1.9.2",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	_focus: $.fn.focus,
	focus: function( delay, fn ) {
		return typeof delay === "number" ?
			this.each(function() {
				var elem = this;
				setTimeout(function() {
					$( elem ).focus();
					if ( fn ) {
						fn.call( elem );
					}
				}, delay );
			}) :
			this._focus.apply( this, arguments );
	},

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie && (/(static|relative)/).test(this.css('position'))) || (/absolute/).test(this.css('position'))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,'position')) && (/(auto|scroll)/).test($.css(this,'overflow')+$.css(this,'overflow-y')+$.css(this,'overflow-x'));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,'overflow')+$.css(this,'overflow-y')+$.css(this,'overflow-x'));
			}).eq(0);
		}

		return (/fixed/).test(this.css('position')) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = "ui-id-" + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().andSelf().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support
$(function() {
	var body = document.body,
		div = body.appendChild( div = document.createElement( "div" ) );

	// access offsetHeight before setting the style to prevent a layout bug
	// in IE 9 which causes the element to continue to take up space even
	// after it is removed from the DOM (#8026)
	div.offsetHeight;

	$.extend( div.style, {
		minHeight: "100px",
		height: "auto",
		padding: 0,
		borderWidth: 0
	});

	$.support.minHeight = div.offsetHeight === 100;
	$.support.selectstart = "onselectstart" in div;

	// set display to none to avoid a layout bug in IE
	// http://dev.jquery.com/ticket/4014
	body.removeChild( div ).style.display = "none";
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}





// deprecated

(function() {
	var uaMatch = /msie ([\w.]+)/.exec( navigator.userAgent.toLowerCase() ) || [];
	$.ui.ie = uaMatch.length ? true : false;
	$.ui.ie6 = parseFloat( uaMatch[ 1 ], 10 ) === 6;
})();

$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.extend( $.ui, {
	// $.ui.plugin is deprecated.  Use the proxy pattern instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	contains: $.contains,

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	},

	// these are odd functions, fix the API or move into individual plugins
	isOverAxis: function( x, reference, size ) {
		//Determines when x coordinate is over "b" element axis
		return ( x > reference ) && ( x < ( reference + size ) );
	},
	isOver: function( y, x, top, left, height, width ) {
		//Determines when x, y coordinates is over "b" element
		return $.ui.isOverAxis( y, top, height ) && $.ui.isOverAxis( x, left, width );
	}
});

})( jQuery );
(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( $.isFunction( value ) ) {
			prototype[ prop ] = (function() {
				var _super = function() {
						return base.prototype[ prop ].apply( this, arguments );
					},
					_superApply = function( args ) {
						return base.prototype[ prop ].apply( this, args );
					};
				return function() {
					var __super = this._super,
						__superApply = this._superApply,
						returnValue;

					this._super = _super;
					this._superApply = _superApply;

					returnValue = value.apply( this, arguments );

					this._super = __super;
					this._superApply = __superApply;

					return returnValue;
				};
			})();
		}
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
	}, prototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		// TODO remove widgetBaseClass, see #8155
		widgetBaseClass: fullName,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			// 1.9 BC for #7810
			// TODO remove dual storage
			$.data( element, this.widgetName, this );
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( value === undefined ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( value === undefined ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && ( $.effects.effect[ effectName ] || $.uiBackCompat !== false && $.effects[ effectName ] ) ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

// DEPRECATED
if ( $.uiBackCompat !== false ) {
	$.Widget.prototype._getCreateOptions = function() {
		return $.metadata && $.metadata.get( this.element[0] )[ this.widgetName ];
	};
}

})( jQuery );
(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function( e ) {
	mouseHandled = false;
});

$.widget("ui.mouse", {
	version: "1.9.2",
	options: {
		cancel: 'input,textarea,button,select,option',
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind('mousedown.'+this.widgetName, function(event) {
				return that._mouseDown(event);
			})
			.bind('click.'+this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + '.preventClickEvent')) {
					$.removeData(event.target, that.widgetName + '.preventClickEvent');
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind('.'+this.widgetName);
		if ( this._mouseMoveDelegate ) {
			$(document)
				.unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
				.unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if( mouseHandled ) { return; }

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + '.preventClickEvent')) {
			$.removeData(event.target, this.widgetName + '.preventClickEvent');
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};
		$(document)
			.bind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.bind('mouseup.'+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.ui.ie && !(document.documentMode >= 9) && !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + '.preventClickEvent', true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(event) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(event) {},
	_mouseDrag: function(event) {},
	_mouseStop: function(event) {},
	_mouseCapture: function(event) { return true; }
});

})(jQuery);
(function( $, undefined ) {

$.ui = $.ui || {};

var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseInt( offsets[ 0 ], 10 ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseInt( offsets[ 1 ], 10 ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}
function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[0];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[0].clientWidth;
		}

		div.remove();

		return (cachedScrollbarWidth = w1 - w2);
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow ? "" : within.element.css( "overflow-x" ),
			overflowY = within.isWindow ? "" : within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[0].scrollHeight );
		return {
			width: hasOverflowX ? $.position.scrollbarWidth() : 0,
			height: hasOverflowY ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[0] );
		return {
			element: withinElement,
			isWindow: isWindow,
			offset: withinElement.offset() || { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: isWindow ? withinElement.width() : withinElement.outerWidth(),
			height: isWindow ? withinElement.height() : withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		targetElem = target[0],
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	if ( targetElem.nodeType === 9 ) {
		targetWidth = target.width();
		targetHeight = target.height();
		targetOffset = { top: 0, left: 0 };
	} else if ( $.isWindow( targetElem ) ) {
		targetWidth = target.width();
		targetHeight = target.height();
		targetOffset = { top: target.scrollTop(), left: target.scrollLeft() };
	} else if ( targetElem.preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
		targetWidth = targetHeight = 0;
		targetOffset = { top: targetElem.pageY, left: targetElem.pageX };
	} else {
		targetWidth = target.outerWidth();
		targetHeight = target.outerHeight();
		targetOffset = target.offset();
	}
	// clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each(function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		// if the browser doesn't support fractions, then round for consistent results
		if ( !$.support.offsetFractions ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem : elem
				});
			}
		});

		if ( $.fn.bgiframe ) {
			elem.bgiframe();
		}

		if ( options.using ) {
			// adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// element is wider than within
			if ( data.collisionWidth > outerWidth ) {
				// element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
					position.left += overLeft - newOverRight;
				// element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;
				// element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}
			// too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;
			// too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;
			// adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// element is taller than within
			if ( data.collisionHeight > outerHeight ) {
				// element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
					position.top += overTop - newOverBottom;
				// element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;
				// element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}
			// too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;
			// too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;
			// adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			}
			else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
				if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
			else if ( overBottom > 0 ) {
				newOverTop = position.top -  data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
				if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

// fraction support test
(function () {
	var testElement, testElementParent, testElementStyle, offsetLeft, i,
		body = document.getElementsByTagName( "body" )[ 0 ],
		div = document.createElement( "div" );

	//Create a "fake body" for testing based on method used in jQuery.support
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = "position: absolute; left: 10.7432222px;";

	offsetLeft = $( div ).offset().left;
	$.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );
})();

// DEPRECATED
if ( $.uiBackCompat !== false ) {
	// offset option
	(function( $ ) {
		var _position = $.fn.position;
		$.fn.position = function( options ) {
			if ( !options || !options.offset ) {
				return _position.call( this, options );
			}
			var offset = options.offset.split( " " ),
				at = options.at.split( " " );
			if ( offset.length === 1 ) {
				offset[ 1 ] = offset[ 0 ];
			}
			if ( /^\d/.test( offset[ 0 ] ) ) {
				offset[ 0 ] = "+" + offset[ 0 ];
			}
			if ( /^\d/.test( offset[ 1 ] ) ) {
				offset[ 1 ] = "+" + offset[ 1 ];
			}
			if ( at.length === 1 ) {
				if ( /left|center|right/.test( at[ 0 ] ) ) {
					at[ 1 ] = "center";
				} else {
					at[ 1 ] = at[ 0 ];
					at[ 0 ] = "center";
				}
			}
			return _position.call( this, $.extend( options, {
				at: at[ 0 ] + offset[ 0 ] + " " + at[ 1 ] + offset[ 1 ],
				offset: undefined
			} ) );
		};
	}( jQuery ) );
}

}( jQuery ) );
(function( $, undefined ) {

var uid = 0,
	hideProps = {},
	showProps = {};

hideProps.height = hideProps.paddingTop = hideProps.paddingBottom =
	hideProps.borderTopWidth = hideProps.borderBottomWidth = "hide";
showProps.height = showProps.paddingTop = showProps.paddingBottom =
	showProps.borderTopWidth = showProps.borderBottomWidth = "show";

$.widget( "ui.accordion", {
	version: "1.9.2",
	options: {
		active: 0,
		animate: {},
		collapsible: false,
		event: "click",
		header: "> li > :first-child,> :not(li):even",
		heightStyle: "auto",
		icons: {
			activeHeader: "ui-icon-triangle-1-s",
			header: "ui-icon-triangle-1-e"
		},

		// callbacks
		activate: null,
		beforeActivate: null
	},

	_create: function() {
		var accordionId = this.accordionId = "ui-accordion-" +
				(this.element.attr( "id" ) || ++uid),
			options = this.options;

		this.prevShow = this.prevHide = $();
		this.element.addClass( "ui-accordion ui-widget ui-helper-reset" );

		this.headers = this.element.find( options.header )
			.addClass( "ui-accordion-header ui-helper-reset ui-state-default ui-corner-all" );
		this._hoverable( this.headers );
		this._focusable( this.headers );

		this.headers.next()
			.addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" )
			.hide();

		// don't allow collapsible: false and active: false / null
		if ( !options.collapsible && (options.active === false || options.active == null) ) {
			options.active = 0;
		}
		// handle negative values
		if ( options.active < 0 ) {
			options.active += this.headers.length;
		}
		this.active = this._findActive( options.active )
			.addClass( "ui-accordion-header-active ui-state-active" )
			.toggleClass( "ui-corner-all ui-corner-top" );
		this.active.next()
			.addClass( "ui-accordion-content-active" )
			.show();

		this._createIcons();
		this.refresh();

		// ARIA
		this.element.attr( "role", "tablist" );

		this.headers
			.attr( "role", "tab" )
			.each(function( i ) {
				var header = $( this ),
					headerId = header.attr( "id" ),
					panel = header.next(),
					panelId = panel.attr( "id" );
				if ( !headerId ) {
					headerId = accordionId + "-header-" + i;
					header.attr( "id", headerId );
				}
				if ( !panelId ) {
					panelId = accordionId + "-panel-" + i;
					panel.attr( "id", panelId );
				}
				header.attr( "aria-controls", panelId );
				panel.attr( "aria-labelledby", headerId );
			})
			.next()
				.attr( "role", "tabpanel" );

		this.headers
			.not( this.active )
			.attr({
				"aria-selected": "false",
				tabIndex: -1
			})
			.next()
				.attr({
					"aria-expanded": "false",
					"aria-hidden": "true"
				})
				.hide();

		// make sure at least one header is in the tab order
		if ( !this.active.length ) {
			this.headers.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active.attr({
				"aria-selected": "true",
				tabIndex: 0
			})
			.next()
				.attr({
					"aria-expanded": "true",
					"aria-hidden": "false"
				});
		}

		this._on( this.headers, { keydown: "_keydown" });
		this._on( this.headers.next(), { keydown: "_panelKeyDown" });
		this._setupEvents( options.event );
	},

	_getCreateEventData: function() {
		return {
			header: this.active,
			content: !this.active.length ? $() : this.active.next()
		};
	},

	_createIcons: function() {
		var icons = this.options.icons;
		if ( icons ) {
			$( "<span>" )
				.addClass( "ui-accordion-header-icon ui-icon " + icons.header )
				.prependTo( this.headers );
			this.active.children( ".ui-accordion-header-icon" )
				.removeClass( icons.header )
				.addClass( icons.activeHeader );
			this.headers.addClass( "ui-accordion-icons" );
		}
	},

	_destroyIcons: function() {
		this.headers
			.removeClass( "ui-accordion-icons" )
			.children( ".ui-accordion-header-icon" )
				.remove();
	},

	_destroy: function() {
		var contents;

		// clean up main element
		this.element
			.removeClass( "ui-accordion ui-widget ui-helper-reset" )
			.removeAttr( "role" );

		// clean up headers
		this.headers
			.removeClass( "ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )
			.removeAttr( "role" )
			.removeAttr( "aria-selected" )
			.removeAttr( "aria-controls" )
			.removeAttr( "tabIndex" )
			.each(function() {
				if ( /^ui-accordion/.test( this.id ) ) {
					this.removeAttribute( "id" );
				}
			});
		this._destroyIcons();

		// clean up content panels
		contents = this.headers.next()
			.css( "display", "" )
			.removeAttr( "role" )
			.removeAttr( "aria-expanded" )
			.removeAttr( "aria-hidden" )
			.removeAttr( "aria-labelledby" )
			.removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled" )
			.each(function() {
				if ( /^ui-accordion/.test( this.id ) ) {
					this.removeAttribute( "id" );
				}
			});
		if ( this.options.heightStyle !== "content" ) {
			contents.css( "height", "" );
		}
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "event" ) {
			if ( this.options.event ) {
				this._off( this.headers, this.options.event );
			}
			this._setupEvents( value );
		}

		this._super( key, value );

		// setting collapsible: false while collapsed; open first panel
		if ( key === "collapsible" && !value && this.options.active === false ) {
			this._activate( 0 );
		}

		if ( key === "icons" ) {
			this._destroyIcons();
			if ( value ) {
				this._createIcons();
			}
		}

		// #5332 - opacity doesn't cascade to positioned elements in IE
		// so we need to add the disabled class to the headers and panels
		if ( key === "disabled" ) {
			this.headers.add( this.headers.next() )
				.toggleClass( "ui-state-disabled", !!value );
		}
	},

	_keydown: function( event ) {
		if ( event.altKey || event.ctrlKey ) {
			return;
		}

		var keyCode = $.ui.keyCode,
			length = this.headers.length,
			currentIndex = this.headers.index( event.target ),
			toFocus = false;

		switch ( event.keyCode ) {
			case keyCode.RIGHT:
			case keyCode.DOWN:
				toFocus = this.headers[ ( currentIndex + 1 ) % length ];
				break;
			case keyCode.LEFT:
			case keyCode.UP:
				toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
				break;
			case keyCode.SPACE:
			case keyCode.ENTER:
				this._eventHandler( event );
				break;
			case keyCode.HOME:
				toFocus = this.headers[ 0 ];
				break;
			case keyCode.END:
				toFocus = this.headers[ length - 1 ];
				break;
		}

		if ( toFocus ) {
			$( event.target ).attr( "tabIndex", -1 );
			$( toFocus ).attr( "tabIndex", 0 );
			toFocus.focus();
			event.preventDefault();
		}
	},

	_panelKeyDown : function( event ) {
		if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {
			$( event.currentTarget ).prev().focus();
		}
	},

	refresh: function() {
		var maxHeight, overflow,
			heightStyle = this.options.heightStyle,
			parent = this.element.parent();


		if ( heightStyle === "fill" ) {
			// IE 6 treats height like minHeight, so we need to turn off overflow
			// in order to get a reliable height
			// we use the minHeight support test because we assume that only
			// browsers that don't support minHeight will treat height as minHeight
			if ( !$.support.minHeight ) {
				overflow = parent.css( "overflow" );
				parent.css( "overflow", "hidden");
			}
			maxHeight = parent.height();
			this.element.siblings( ":visible" ).each(function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});
			if ( overflow ) {
				parent.css( "overflow", overflow );
			}

			this.headers.each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.headers.next()
				.each(function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) );
				})
				.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.headers.next()
				.each(function() {
					maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );
				})
				.height( maxHeight );
		}
	},

	_activate: function( index ) {
		var active = this._findActive( index )[ 0 ];

		// trying to activate the already active panel
		if ( active === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the currently active header
		active = active || this.active[ 0 ];

		this._eventHandler({
			target: active,
			currentTarget: active,
			preventDefault: $.noop
		});
	},

	_findActive: function( selector ) {
		return typeof selector === "number" ? this.headers.eq( selector ) : $();
	},

	_setupEvents: function( event ) {
		var events = {};
		if ( !event ) {
			return;
		}
		$.each( event.split(" "), function( index, eventName ) {
			events[ eventName ] = "_eventHandler";
		});
		this._on( this.headers, events );
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			clicked = $( event.currentTarget ),
			clickedIsActive = clicked[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : clicked.next(),
			toHide = active.next(),
			eventData = {
				oldHeader: active,
				oldPanel: toHide,
				newHeader: collapsing ? $() : clicked,
				newPanel: toShow
			};

		event.preventDefault();

		if (
				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.headers.index( clicked );

		// when the call to ._toggle() comes after the class changes
		// it causes a very odd bug in IE 8 (see #6720)
		this.active = clickedIsActive ? $() : clicked;
		this._toggle( eventData );

		// switch classes
		// corner classes on the previously active header stay after the animation
		active.removeClass( "ui-accordion-header-active ui-state-active" );
		if ( options.icons ) {
			active.children( ".ui-accordion-header-icon" )
				.removeClass( options.icons.activeHeader )
				.addClass( options.icons.header );
		}

		if ( !clickedIsActive ) {
			clicked
				.removeClass( "ui-corner-all" )
				.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" );
			if ( options.icons ) {
				clicked.children( ".ui-accordion-header-icon" )
					.removeClass( options.icons.header )
					.addClass( options.icons.activeHeader );
			}

			clicked
				.next()
				.addClass( "ui-accordion-content-active" );
		}
	},

	_toggle: function( data ) {
		var toShow = data.newPanel,
			toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

		// handle activating a panel during the animation for another activation
		this.prevShow.add( this.prevHide ).stop( true, true );
		this.prevShow = toShow;
		this.prevHide = toHide;

		if ( this.options.animate ) {
			this._animate( toShow, toHide, data );
		} else {
			toHide.hide();
			toShow.show();
			this._toggleComplete( data );
		}

		toHide.attr({
			"aria-expanded": "false",
			"aria-hidden": "true"
		});
		toHide.prev().attr( "aria-selected", "false" );
		// if we're switching panels, remove the old header from the tab order
		// if we're opening from collapsed state, remove the previous header from the tab order
		// if we're collapsing, then keep the collapsing header in the tab order
		if ( toShow.length && toHide.length ) {
			toHide.prev().attr( "tabIndex", -1 );
		} else if ( toShow.length ) {
			this.headers.filter(function() {
				return $( this ).attr( "tabIndex" ) === 0;
			})
			.attr( "tabIndex", -1 );
		}

		toShow
			.attr({
				"aria-expanded": "true",
				"aria-hidden": "false"
			})
			.prev()
				.attr({
					"aria-selected": "true",
					tabIndex: 0
				});
	},

	_animate: function( toShow, toHide, data ) {
		var total, easing, duration,
			that = this,
			adjust = 0,
			down = toShow.length &&
				( !toHide.length || ( toShow.index() < toHide.index() ) ),
			animate = this.options.animate || {},
			options = down && animate.down || animate,
			complete = function() {
				that._toggleComplete( data );
			};

		if ( typeof options === "number" ) {
			duration = options;
		}
		if ( typeof options === "string" ) {
			easing = options;
		}
		// fall back from options to animation in case of partial down settings
		easing = easing || options.easing || animate.easing;
		duration = duration || options.duration || animate.duration;

		if ( !toHide.length ) {
			return toShow.animate( showProps, duration, easing, complete );
		}
		if ( !toShow.length ) {
			return toHide.animate( hideProps, duration, easing, complete );
		}

		total = toShow.show().outerHeight();
		toHide.animate( hideProps, {
			duration: duration,
			easing: easing,
			step: function( now, fx ) {
				fx.now = Math.round( now );
			}
		});
		toShow
			.hide()
			.animate( showProps, {
				duration: duration,
				easing: easing,
				complete: complete,
				step: function( now, fx ) {
					fx.now = Math.round( now );
					if ( fx.prop !== "height" ) {
						adjust += fx.now;
					} else if ( that.options.heightStyle !== "content" ) {
						fx.now = Math.round( total - toHide.outerHeight() - adjust );
						adjust = 0;
					}
				}
			});
	},

	_toggleComplete: function( data ) {
		var toHide = data.oldPanel;

		toHide
			.removeClass( "ui-accordion-content-active" )
			.prev()
				.removeClass( "ui-corner-top" )
				.addClass( "ui-corner-all" );

		// Work around for rendering bug in IE (#5421)
		if ( toHide.length ) {
			toHide.parent()[0].className = toHide.parent()[0].className;
		}

		this._trigger( "activate", null, data );
	}
});



// DEPRECATED
if ( $.uiBackCompat !== false ) {
	// navigation options
	(function( $, prototype ) {
		$.extend( prototype.options, {
			navigation: false,
			navigationFilter: function() {
				return this.href.toLowerCase() === location.href.toLowerCase();
			}
		});

		var _create = prototype._create;
		prototype._create = function() {
			if ( this.options.navigation ) {
				var that = this,
					headers = this.element.find( this.options.header ),
					content = headers.next(),
					current = headers.add( content )
						.find( "a" )
						.filter( this.options.navigationFilter )
						[ 0 ];
				if ( current ) {
					headers.add( content ).each( function( index ) {
						if ( $.contains( this, current ) ) {
							that.options.active = Math.floor( index / 2 );
							return false;
						}
					});
				}
			}
			_create.call( this );
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// height options
	(function( $, prototype ) {
		$.extend( prototype.options, {
			heightStyle: null, // remove default so we fall back to old values
			autoHeight: true, // use heightStyle: "auto"
			clearStyle: false, // use heightStyle: "content"
			fillSpace: false // use heightStyle: "fill"
		});

		var _create = prototype._create,
			_setOption = prototype._setOption;

		$.extend( prototype, {
			_create: function() {
				this.options.heightStyle = this.options.heightStyle ||
					this._mergeHeightStyle();

				_create.call( this );
			},

			_setOption: function( key ) {
				if ( key === "autoHeight" || key === "clearStyle" || key === "fillSpace" ) {
					this.options.heightStyle = this._mergeHeightStyle();
				}
				_setOption.apply( this, arguments );
			},

			_mergeHeightStyle: function() {
				var options = this.options;

				if ( options.fillSpace ) {
					return "fill";
				}

				if ( options.clearStyle ) {
					return "content";
				}

				if ( options.autoHeight ) {
					return "auto";
				}
			}
		});
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// icon options
	(function( $, prototype ) {
		$.extend( prototype.options.icons, {
			activeHeader: null, // remove default so we fall back to old values
			headerSelected: "ui-icon-triangle-1-s"
		});

		var _createIcons = prototype._createIcons;
		prototype._createIcons = function() {
			if ( this.options.icons ) {
				this.options.icons.activeHeader = this.options.icons.activeHeader ||
					this.options.icons.headerSelected;
			}
			_createIcons.call( this );
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// expanded active option, activate method
	(function( $, prototype ) {
		prototype.activate = prototype._activate;

		var _findActive = prototype._findActive;
		prototype._findActive = function( index ) {
			if ( index === -1 ) {
				index = false;
			}
			if ( index && typeof index !== "number" ) {
				index = this.headers.index( this.headers.filter( index ) );
				if ( index === -1 ) {
					index = false;
				}
			}
			return _findActive.call( this, index );
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// resize method
	jQuery.ui.accordion.prototype.resize = jQuery.ui.accordion.prototype.refresh;

	// change events
	(function( $, prototype ) {
		$.extend( prototype.options, {
			change: null,
			changestart: null
		});

		var _trigger = prototype._trigger;
		prototype._trigger = function( type, event, data ) {
			var ret = _trigger.apply( this, arguments );
			if ( !ret ) {
				return false;
			}

			if ( type === "beforeActivate" ) {
				ret = _trigger.call( this, "changestart", event, {
					oldHeader: data.oldHeader,
					oldContent: data.oldPanel,
					newHeader: data.newHeader,
					newContent: data.newPanel
				});
			} else if ( type === "activate" ) {
				ret = _trigger.call( this, "change", event, {
					oldHeader: data.oldHeader,
					oldContent: data.oldPanel,
					newHeader: data.newHeader,
					newContent: data.newPanel
				});
			}
			return ret;
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// animated option
	// NOTE: this only provides support for "slide", "bounceslide", and easings
	// not the full $.ui.accordion.animations API
	(function( $, prototype ) {
		$.extend( prototype.options, {
			animate: null,
			animated: "slide"
		});

		var _create = prototype._create;
		prototype._create = function() {
			var options = this.options;
			if ( options.animate === null ) {
				if ( !options.animated ) {
					options.animate = false;
				} else if ( options.animated === "slide" ) {
					options.animate = 300;
				} else if ( options.animated === "bounceslide" ) {
					options.animate = {
						duration: 200,
						down: {
							easing: "easeOutBounce",
							duration: 1000
						}
					};
				} else {
					options.animate = options.animated;
				}
			}

			_create.call( this );
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );
}

})( jQuery );
(function( $, undefined ) {

// used to prevent race conditions with remote data sources
var requestIndex = 0;

$.widget( "ui.autocomplete", {
	version: "1.9.2",
	defaultElement: "<input>",
	options: {
		appendTo: "body",
		autoFocus: false,
		delay: 300,
		minLength: 1,
		position: {
			my: "left top",
			at: "left bottom",
			collision: "none"
		},
		source: null,

		// callbacks
		change: null,
		close: null,
		focus: null,
		open: null,
		response: null,
		search: null,
		select: null
	},

	pending: 0,

	_create: function() {
		// Some browsers only repeat keydown events, not keypress events,
		// so we use the suppressKeyPress flag to determine if we've already
		// handled the keydown event. #7269
		// Unfortunately the code for & in keypress is the same as the up arrow,
		// so we use the suppressKeyPressRepeat flag to avoid handling keypress
		// events when we know the keydown event was used to modify the
		// search term. #7799
		var suppressKeyPress, suppressKeyPressRepeat, suppressInput;

		this.isMultiLine = this._isMultiLine();
		this.valueMethod = this.element[ this.element.is( "input,textarea" ) ? "val" : "text" ];
		this.isNewMenu = true;

		this.element
			.addClass( "ui-autocomplete-input" )
			.attr( "autocomplete", "off" );

		this._on( this.element, {
			keydown: function( event ) {
				if ( this.element.prop( "readOnly" ) ) {
					suppressKeyPress = true;
					suppressInput = true;
					suppressKeyPressRepeat = true;
					return;
				}

				suppressKeyPress = false;
				suppressInput = false;
				suppressKeyPressRepeat = false;
				var keyCode = $.ui.keyCode;
				switch( event.keyCode ) {
				case keyCode.PAGE_UP:
					suppressKeyPress = true;
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					suppressKeyPress = true;
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					suppressKeyPress = true;
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					suppressKeyPress = true;
					this._keyEvent( "next", event );
					break;
				case keyCode.ENTER:
				case keyCode.NUMPAD_ENTER:
					// when menu is open and has focus
					if ( this.menu.active ) {
						// #6055 - Opera still allows the keypress to occur
						// which causes forms to submit
						suppressKeyPress = true;
						event.preventDefault();
						this.menu.select( event );
					}
					break;
				case keyCode.TAB:
					if ( this.menu.active ) {
						this.menu.select( event );
					}
					break;
				case keyCode.ESCAPE:
					if ( this.menu.element.is( ":visible" ) ) {
						this._value( this.term );
						this.close( event );
						// Different browsers have different default behavior for escape
						// Single press can mean undo or clear
						// Double press in IE means clear the whole form
						event.preventDefault();
					}
					break;
				default:
					suppressKeyPressRepeat = true;
					// search timeout should be triggered before the input value is changed
					this._searchTimeout( event );
					break;
				}
			},
			keypress: function( event ) {
				if ( suppressKeyPress ) {
					suppressKeyPress = false;
					event.preventDefault();
					return;
				}
				if ( suppressKeyPressRepeat ) {
					return;
				}

				// replicate some key handlers to allow them to repeat in Firefox and Opera
				var keyCode = $.ui.keyCode;
				switch( event.keyCode ) {
				case keyCode.PAGE_UP:
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					this._keyEvent( "next", event );
					break;
				}
			},
			input: function( event ) {
				if ( suppressInput ) {
					suppressInput = false;
					event.preventDefault();
					return;
				}
				this._searchTimeout( event );
			},
			focus: function() {
				this.selectedItem = null;
				this.previous = this._value();
			},
			blur: function( event ) {
				if ( this.cancelBlur ) {
					delete this.cancelBlur;
					return;
				}

				clearTimeout( this.searching );
				this.close( event );
				this._change( event );
			}
		});

		this._initSource();
		this.menu = $( "<ul>" )
			.addClass( "ui-autocomplete" )
			.appendTo( this.document.find( this.options.appendTo || "body" )[ 0 ] )
			.menu({
				// custom key handling for now
				input: $(),
				// disable ARIA support, the live region takes care of that
				role: null
			})
			.zIndex( this.element.zIndex() + 1 )
			.hide()
			.data( "menu" );

		this._on( this.menu.element, {
			mousedown: function( event ) {
				// prevent moving focus out of the text field
				event.preventDefault();

				// IE doesn't prevent moving focus even with event.preventDefault()
				// so we set a flag to know when we should ignore the blur event
				this.cancelBlur = true;
				this._delay(function() {
					delete this.cancelBlur;
				});

				// clicking on the scrollbar causes focus to shift to the body
				// but we can't detect a mouseup or a click immediately afterward
				// so we have to track the next mousedown and close the menu if
				// the user clicks somewhere outside of the autocomplete
				var menuElement = this.menu.element[ 0 ];
				if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {
					this._delay(function() {
						var that = this;
						this.document.one( "mousedown", function( event ) {
							if ( event.target !== that.element[ 0 ] &&
									event.target !== menuElement &&
									!$.contains( menuElement, event.target ) ) {
								that.close();
							}
						});
					});
				}
			},
			menufocus: function( event, ui ) {
				// #7024 - Prevent accidental activation of menu items in Firefox
				if ( this.isNewMenu ) {
					this.isNewMenu = false;
					if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
						this.menu.blur();

						this.document.one( "mousemove", function() {
							$( event.target ).trigger( event.originalEvent );
						});

						return;
					}
				}

				// back compat for _renderItem using item.autocomplete, via #7810
				// TODO remove the fallback, see #8156
				var item = ui.item.data( "ui-autocomplete-item" ) || ui.item.data( "item.autocomplete" );
				if ( false !== this._trigger( "focus", event, { item: item } ) ) {
					// use value to match what will end up in the input, if it was a key event
					if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
						this._value( item.value );
					}
				} else {
					// Normally the input is populated with the item's value as the
					// menu is navigated, causing screen readers to notice a change and
					// announce the item. Since the focus event was canceled, this doesn't
					// happen, so we update the live region so that screen readers can
					// still notice the change and announce it.
					this.liveRegion.text( item.value );
				}
			},
			menuselect: function( event, ui ) {
				// back compat for _renderItem using item.autocomplete, via #7810
				// TODO remove the fallback, see #8156
				var item = ui.item.data( "ui-autocomplete-item" ) || ui.item.data( "item.autocomplete" ),
					previous = this.previous;

				// only trigger when focus was lost (click on menu)
				if ( this.element[0] !== this.document[0].activeElement ) {
					this.element.focus();
					this.previous = previous;
					// #6109 - IE triggers two focus events and the second
					// is asynchronous, so we need to reset the previous
					// term synchronously and asynchronously :-(
					this._delay(function() {
						this.previous = previous;
						this.selectedItem = item;
					});
				}

				if ( false !== this._trigger( "select", event, { item: item } ) ) {
					this._value( item.value );
				}
				// reset the term after the select event
				// this allows custom select handling to work properly
				this.term = this._value();

				this.close( event );
				this.selectedItem = item;
			}
		});

		this.liveRegion = $( "<span>", {
				role: "status",
				"aria-live": "polite"
			})
			.addClass( "ui-helper-hidden-accessible" )
			.insertAfter( this.element );

		if ( $.fn.bgiframe ) {
			this.menu.element.bgiframe();
		}

		// turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		});
	},

	_destroy: function() {
		clearTimeout( this.searching );
		this.element
			.removeClass( "ui-autocomplete-input" )
			.removeAttr( "autocomplete" );
		this.menu.element.remove();
		this.liveRegion.remove();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "source" ) {
			this._initSource();
		}
		if ( key === "appendTo" ) {
			this.menu.element.appendTo( this.document.find( value || "body" )[0] );
		}
		if ( key === "disabled" && value && this.xhr ) {
			this.xhr.abort();
		}
	},

	_isMultiLine: function() {
		// Textareas are always multi-line
		if ( this.element.is( "textarea" ) ) {
			return true;
		}
		// Inputs are always single-line, even if inside a contentEditable element
		// IE also treats inputs as contentEditable
		if ( this.element.is( "input" ) ) {
			return false;
		}
		// All other element types are determined by whether or not they're contentEditable
		return this.element.prop( "isContentEditable" );
	},

	_initSource: function() {
		var array, url,
			that = this;
		if ( $.isArray(this.options.source) ) {
			array = this.options.source;
			this.source = function( request, response ) {
				response( $.ui.autocomplete.filter( array, request.term ) );
			};
		} else if ( typeof this.options.source === "string" ) {
			url = this.options.source;
			this.source = function( request, response ) {
				if ( that.xhr ) {
					that.xhr.abort();
				}
				that.xhr = $.ajax({
					url: url,
					data: request,
					dataType: "json",
					success: function( data ) {
						response( data );
					},
					error: function() {
						response( [] );
					}
				});
			};
		} else {
			this.source = this.options.source;
		}
	},

	_searchTimeout: function( event ) {
		clearTimeout( this.searching );
		this.searching = this._delay(function() {
			// only search if the value has changed
			if ( this.term !== this._value() ) {
				this.selectedItem = null;
				this.search( null, event );
			}
		}, this.options.delay );
	},

	search: function( value, event ) {
		value = value != null ? value : this._value();

		// always save the actual value, not the one passed as an argument
		this.term = this._value();

		if ( value.length < this.options.minLength ) {
			return this.close( event );
		}

		if ( this._trigger( "search", event ) === false ) {
			return;
		}

		return this._search( value );
	},

	_search: function( value ) {
		this.pending++;
		this.element.addClass( "ui-autocomplete-loading" );
		this.cancelSearch = false;

		this.source( { term: value }, this._response() );
	},

	_response: function() {
		var that = this,
			index = ++requestIndex;

		return function( content ) {
			if ( index === requestIndex ) {
				that.__response( content );
			}

			that.pending--;
			if ( !that.pending ) {
				that.element.removeClass( "ui-autocomplete-loading" );
			}
		};
	},

	__response: function( content ) {
		if ( content ) {
			content = this._normalize( content );
		}
		this._trigger( "response", null, { content: content } );
		if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
			this._suggest( content );
			this._trigger( "open" );
		} else {
			// use ._close() instead of .close() so we don't cancel future searches
			this._close();
		}
	},

	close: function( event ) {
		this.cancelSearch = true;
		this._close( event );
	},

	_close: function( event ) {
		if ( this.menu.element.is( ":visible" ) ) {
			this.menu.element.hide();
			this.menu.blur();
			this.isNewMenu = true;
			this._trigger( "close", event );
		}
	},

	_change: function( event ) {
		if ( this.previous !== this._value() ) {
			this._trigger( "change", event, { item: this.selectedItem } );
		}
	},

	_normalize: function( items ) {
		// assume all items have the right format when the first item is complete
		if ( items.length && items[0].label && items[0].value ) {
			return items;
		}
		return $.map( items, function( item ) {
			if ( typeof item === "string" ) {
				return {
					label: item,
					value: item
				};
			}
			return $.extend({
				label: item.label || item.value,
				value: item.value || item.label
			}, item );
		});
	},

	_suggest: function( items ) {
		var ul = this.menu.element
			.empty()
			.zIndex( this.element.zIndex() + 1 );
		this._renderMenu( ul, items );
		this.menu.refresh();

		// size and position menu
		ul.show();
		this._resizeMenu();
		ul.position( $.extend({
			of: this.element
		}, this.options.position ));

		if ( this.options.autoFocus ) {
			this.menu.next();
		}
	},

	_resizeMenu: function() {
		var ul = this.menu.element;
		ul.outerWidth( Math.max(
			// Firefox wraps long text (possibly a rounding bug)
			// so we add 1px to avoid the wrapping (#7513)
			ul.width( "" ).outerWidth() + 1,
			this.element.outerWidth()
		) );
	},

	_renderMenu: function( ul, items ) {
		var that = this;
		$.each( items, function( index, item ) {
			that._renderItemData( ul, item );
		});
	},

	_renderItemData: function( ul, item ) {
		return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
	},

	_renderItem: function( ul, item ) {
		return $( "<li>" )
			.append( $( "<a>" ).text( item.label ) )
			.appendTo( ul );
	},

	_move: function( direction, event ) {
		if ( !this.menu.element.is( ":visible" ) ) {
			this.search( null, event );
			return;
		}
		if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
				this.menu.isLastItem() && /^next/.test( direction ) ) {
			this._value( this.term );
			this.menu.blur();
			return;
		}
		this.menu[ direction ]( event );
	},

	widget: function() {
		return this.menu.element;
	},

	_value: function() {
		return this.valueMethod.apply( this.element, arguments );
	},

	_keyEvent: function( keyEvent, event ) {
		if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
			this._move( keyEvent, event );

			// prevents moving cursor to beginning/end of the text field in some browsers
			event.preventDefault();
		}
	}
});

$.extend( $.ui.autocomplete, {
	escapeRegex: function( value ) {
		return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
	},
	filter: function(array, term) {
		var matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), "i" );
		return $.grep( array, function(value) {
			return matcher.test( value.label || value.value || value );
		});
	}
});


// live region extension, adding a `messages` option
// NOTE: This is an experimental API. We are still investigating
// a full solution for string manipulation and internationalization.
$.widget( "ui.autocomplete", $.ui.autocomplete, {
	options: {
		messages: {
			noResults: "No search results.",
			results: function( amount ) {
				return amount + ( amount > 1 ? " results are" : " result is" ) +
					" available, use up and down arrow keys to navigate.";
			}
		}
	},

	__response: function( content ) {
		var message;
		this._superApply( arguments );
		if ( this.options.disabled || this.cancelSearch ) {
			return;
		}
		if ( content && content.length ) {
			message = this.options.messages.results( content.length );
		} else {
			message = this.options.messages.noResults;
		}
		this.liveRegion.text( message );
	}
});


}( jQuery ));
(function( $, undefined ) {

var lastActive, startXPos, startYPos, clickDragged,
	baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
	stateClasses = "ui-state-hover ui-state-active ",
	typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
	formResetHandler = function() {
		var buttons = $( this ).find( ":ui-button" );
		setTimeout(function() {
			buttons.button( "refresh" );
		}, 1 );
	},
	radioGroup = function( radio ) {
		var name = radio.name,
			form = radio.form,
			radios = $( [] );
		if ( name ) {
			if ( form ) {
				radios = $( form ).find( "[name='" + name + "']" );
			} else {
				radios = $( "[name='" + name + "']", radio.ownerDocument )
					.filter(function() {
						return !this.form;
					});
			}
		}
		return radios;
	};

$.widget( "ui.button", {
	version: "1.9.2",
	defaultElement: "<button>",
	options: {
		disabled: null,
		text: true,
		label: null,
		icons: {
			primary: null,
			secondary: null
		}
	},
	_create: function() {
		this.element.closest( "form" )
			.unbind( "reset" + this.eventNamespace )
			.bind( "reset" + this.eventNamespace, formResetHandler );

		if ( typeof this.options.disabled !== "boolean" ) {
			this.options.disabled = !!this.element.prop( "disabled" );
		} else {
			this.element.prop( "disabled", this.options.disabled );
		}

		this._determineButtonType();
		this.hasTitle = !!this.buttonElement.attr( "title" );

		var that = this,
			options = this.options,
			toggleButton = this.type === "checkbox" || this.type === "radio",
			activeClass = !toggleButton ? "ui-state-active" : "",
			focusClass = "ui-state-focus";

		if ( options.label === null ) {
			options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
		}

		this._hoverable( this.buttonElement );

		this.buttonElement
			.addClass( baseClasses )
			.attr( "role", "button" )
			.bind( "mouseenter" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				if ( this === lastActive ) {
					$( this ).addClass( "ui-state-active" );
				}
			})
			.bind( "mouseleave" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( activeClass );
			})
			.bind( "click" + this.eventNamespace, function( event ) {
				if ( options.disabled ) {
					event.preventDefault();
					event.stopImmediatePropagation();
				}
			});

		this.element
			.bind( "focus" + this.eventNamespace, function() {
				// no need to check disabled, focus won't be triggered anyway
				that.buttonElement.addClass( focusClass );
			})
			.bind( "blur" + this.eventNamespace, function() {
				that.buttonElement.removeClass( focusClass );
			});

		if ( toggleButton ) {
			this.element.bind( "change" + this.eventNamespace, function() {
				if ( clickDragged ) {
					return;
				}
				that.refresh();
			});
			// if mouse moves between mousedown and mouseup (drag) set clickDragged flag
			// prevents issue where button state changes but checkbox/radio checked state
			// does not in Firefox (see ticket #6970)
			this.buttonElement
				.bind( "mousedown" + this.eventNamespace, function( event ) {
					if ( options.disabled ) {
						return;
					}
					clickDragged = false;
					startXPos = event.pageX;
					startYPos = event.pageY;
				})
				.bind( "mouseup" + this.eventNamespace, function( event ) {
					if ( options.disabled ) {
						return;
					}
					if ( startXPos !== event.pageX || startYPos !== event.pageY ) {
						clickDragged = true;
					}
			});
		}

		if ( this.type === "checkbox" ) {
			this.buttonElement.bind( "click" + this.eventNamespace, function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
				$( this ).toggleClass( "ui-state-active" );
				that.buttonElement.attr( "aria-pressed", that.element[0].checked );
			});
		} else if ( this.type === "radio" ) {
			this.buttonElement.bind( "click" + this.eventNamespace, function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
				$( this ).addClass( "ui-state-active" );
				that.buttonElement.attr( "aria-pressed", "true" );

				var radio = that.element[ 0 ];
				radioGroup( radio )
					.not( radio )
					.map(function() {
						return $( this ).button( "widget" )[ 0 ];
					})
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			});
		} else {
			this.buttonElement
				.bind( "mousedown" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).addClass( "ui-state-active" );
					lastActive = this;
					that.document.one( "mouseup", function() {
						lastActive = null;
					});
				})
				.bind( "mouseup" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).removeClass( "ui-state-active" );
				})
				.bind( "keydown" + this.eventNamespace, function(event) {
					if ( options.disabled ) {
						return false;
					}
					if ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {
						$( this ).addClass( "ui-state-active" );
					}
				})
				.bind( "keyup" + this.eventNamespace, function() {
					$( this ).removeClass( "ui-state-active" );
				});

			if ( this.buttonElement.is("a") ) {
				this.buttonElement.keyup(function(event) {
					if ( event.keyCode === $.ui.keyCode.SPACE ) {
						// TODO pass through original event correctly (just as 2nd argument doesn't work)
						$( this ).click();
					}
				});
			}
		}

		// TODO: pull out $.Widget's handling for the disabled option into
		// $.Widget.prototype._setOptionDisabled so it's easy to proxy and can
		// be overridden by individual plugins
		this._setOption( "disabled", options.disabled );
		this._resetButton();
	},

	_determineButtonType: function() {
		var ancestor, labelSelector, checked;

		if ( this.element.is("[type=checkbox]") ) {
			this.type = "checkbox";
		} else if ( this.element.is("[type=radio]") ) {
			this.type = "radio";
		} else if ( this.element.is("input") ) {
			this.type = "input";
		} else {
			this.type = "button";
		}

		if ( this.type === "checkbox" || this.type === "radio" ) {
			// we don't search against the document in case the element
			// is disconnected from the DOM
			ancestor = this.element.parents().last();
			labelSelector = "label[for='" + this.element.attr("id") + "']";
			this.buttonElement = ancestor.find( labelSelector );
			if ( !this.buttonElement.length ) {
				ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
				this.buttonElement = ancestor.filter( labelSelector );
				if ( !this.buttonElement.length ) {
					this.buttonElement = ancestor.find( labelSelector );
				}
			}
			this.element.addClass( "ui-helper-hidden-accessible" );

			checked = this.element.is( ":checked" );
			if ( checked ) {
				this.buttonElement.addClass( "ui-state-active" );
			}
			this.buttonElement.prop( "aria-pressed", checked );
		} else {
			this.buttonElement = this.element;
		}
	},

	widget: function() {
		return this.buttonElement;
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-helper-hidden-accessible" );
		this.buttonElement
			.removeClass( baseClasses + " " + stateClasses + " " + typeClasses )
			.removeAttr( "role" )
			.removeAttr( "aria-pressed" )
			.html( this.buttonElement.find(".ui-button-text").html() );

		if ( !this.hasTitle ) {
			this.buttonElement.removeAttr( "title" );
		}
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "disabled" ) {
			if ( value ) {
				this.element.prop( "disabled", true );
			} else {
				this.element.prop( "disabled", false );
			}
			return;
		}
		this._resetButton();
	},

	refresh: function() {
		//See #8237 & #8828
		var isDisabled = this.element.is( "input, button" ) ? this.element.is( ":disabled" ) : this.element.hasClass( "ui-button-disabled" );

		if ( isDisabled !== this.options.disabled ) {
			this._setOption( "disabled", isDisabled );
		}
		if ( this.type === "radio" ) {
			radioGroup( this.element[0] ).each(function() {
				if ( $( this ).is( ":checked" ) ) {
					$( this ).button( "widget" )
						.addClass( "ui-state-active" )
						.attr( "aria-pressed", "true" );
				} else {
					$( this ).button( "widget" )
						.removeClass( "ui-state-active" )
						.attr( "aria-pressed", "false" );
				}
			});
		} else if ( this.type === "checkbox" ) {
			if ( this.element.is( ":checked" ) ) {
				this.buttonElement
					.addClass( "ui-state-active" )
					.attr( "aria-pressed", "true" );
			} else {
				this.buttonElement
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			}
		}
	},

	_resetButton: function() {
		if ( this.type === "input" ) {
			if ( this.options.label ) {
				this.element.val( this.options.label );
			}
			return;
		}
		var buttonElement = this.buttonElement.removeClass( typeClasses ),
			buttonText = $( "<span></span>", this.document[0] )
				.addClass( "ui-button-text" )
				.html( this.options.label )
				.appendTo( buttonElement.empty() )
				.text(),
			icons = this.options.icons,
			multipleIcons = icons.primary && icons.secondary,
			buttonClasses = [];

		if ( icons.primary || icons.secondary ) {
			if ( this.options.text ) {
				buttonClasses.push( "ui-button-text-icon" + ( multipleIcons ? "s" : ( icons.primary ? "-primary" : "-secondary" ) ) );
			}

			if ( icons.primary ) {
				buttonElement.prepend( "<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>" );
			}

			if ( icons.secondary ) {
				buttonElement.append( "<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>" );
			}

			if ( !this.options.text ) {
				buttonClasses.push( multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only" );

				if ( !this.hasTitle ) {
					buttonElement.attr( "title", $.trim( buttonText ) );
				}
			}
		} else {
			buttonClasses.push( "ui-button-text-only" );
		}
		buttonElement.addClass( buttonClasses.join( " " ) );
	}
});

$.widget( "ui.buttonset", {
	version: "1.9.2",
	options: {
		items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(button)"
	},

	_create: function() {
		this.element.addClass( "ui-buttonset" );
	},

	_init: function() {
		this.refresh();
	},

	_setOption: function( key, value ) {
		if ( key === "disabled" ) {
			this.buttons.button( "option", key, value );
		}

		this._super( key, value );
	},

	refresh: function() {
		var rtl = this.element.css( "direction" ) === "rtl";

		this.buttons = this.element.find( this.options.items )
			.filter( ":ui-button" )
				.button( "refresh" )
			.end()
			.not( ":ui-button" )
				.button()
			.end()
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-all ui-corner-left ui-corner-right" )
				.filter( ":first" )
					.addClass( rtl ? "ui-corner-right" : "ui-corner-left" )
				.end()
				.filter( ":last" )
					.addClass( rtl ? "ui-corner-left" : "ui-corner-right" )
				.end()
			.end();
	},

	_destroy: function() {
		this.element.removeClass( "ui-buttonset" );
		this.buttons
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-left ui-corner-right" )
			.end()
			.button( "destroy" );
	}
});

}( jQuery ) );
(function( $, undefined ) {

$.extend($.ui, { datepicker: { version: "1.9.2" } });

var PROP_NAME = 'datepicker';
var dpuuid = new Date().getTime();
var instActive;

/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this.debug = false; // Change this to true to start debugging
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = 'ui-datepicker-div'; // The ID of the main datepicker division
	this._inlineClass = 'ui-datepicker-inline'; // The name of the inline marker class
	this._appendClass = 'ui-datepicker-append'; // The name of the append marker class
	this._triggerClass = 'ui-datepicker-trigger'; // The name of the trigger marker class
	this._dialogClass = 'ui-datepicker-dialog'; // The name of the dialog marker class
	this._disableClass = 'ui-datepicker-disabled'; // The name of the disabled covering marker class
	this._unselectableClass = 'ui-datepicker-unselectable'; // The name of the unselectable cell marker class
	this._currentClass = 'ui-datepicker-current-day'; // The name of the current day marker class
	this._dayOverClass = 'ui-datepicker-days-cell-over'; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[''] = { // Default regional settings
		closeText: 'Done', // Display text for close link
		prevText: 'Prev', // Display text for previous month link
		nextText: 'Next', // Display text for next month link
		currentText: 'Today', // Display text for current month link
		monthNames: ['January','February','March','April','May','June',
			'July','August','September','October','November','December'], // Names of months for drop-down and formatting
		monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], // For formatting
		dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], // For formatting
		dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], // For formatting
		dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'], // Column headings for days starting at Sunday
		weekHeader: 'Wk', // Column header for week of the year
		dateFormat: 'mm/dd/yy', // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: '' // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: 'focus', // 'focus' for popup on focus,
			// 'button' for trigger button, or 'both' for either
		showAnim: 'fadeIn', // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: '', // Display text following the input box, e.g. showing the format
		buttonText: '...', // Text for trigger button
		buttonImage: '', // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: 'c-10:c+10', // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: '+10', // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with '+' for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: 'fast', // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or '',
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: '', // Selector for an alternate field to store selected dates into
		altFormat: '', // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend(this._defaults, this.regional['']);
	this.dpDiv = bindHover($('<div id="' + this._mainDivId + '" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'));
}

$.extend(Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: 'hasDatepicker',

	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	/* Debug logging (if enabled). */
	log: function () {
		if (this.debug)
			console.log.apply('', arguments);
	},

	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	   @param  settings  object - the new settings to use as defaults (anonymous object)
	   @return the manager object */
	setDefaults: function(settings) {
		extendRemove(this._defaults, settings || {});
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span
	   @param  settings  object - the new settings to use for this date picker instance (anonymous) */
	_attachDatepicker: function(target, settings) {
		// check for settings on the control itself - in namespace 'date:'
		var inlineSettings = null;
		for (var attrName in this._defaults) {
			var attrValue = target.getAttribute('date:' + attrName);
			if (attrValue) {
				inlineSettings = inlineSettings || {};
				try {
					inlineSettings[attrName] = eval(attrValue);
				} catch (err) {
					inlineSettings[attrName] = attrValue;
				}
			}
		}
		var nodeName = target.nodeName.toLowerCase();
		var inline = (nodeName == 'div' || nodeName == 'span');
		if (!target.id) {
			this.uuid += 1;
			target.id = 'dp' + this.uuid;
		}
		var inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {}, inlineSettings || {});
		if (nodeName == 'input') {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	/* Create a new instance object. */
	_newInst: function(target, inline) {
		var id = target[0].id.replace(/([^A-Za-z0-9_-])/g, '\\\\$1'); // escape jQuery meta chars
		return {id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : // presentation div
			bindHover($('<div class="' + this._inlineClass + ' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>')))};
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName))
			return;
		this._attachments(input, inst);
		input.addClass(this.markerClassName).keydown(this._doKeyDown).
			keypress(this._doKeyPress).keyup(this._doKeyUp).
			bind("setData.datepicker", function(event, key, value) {
				inst.settings[key] = value;
			}).bind("getData.datepicker", function(event, key) {
				return this._get(inst, key);
			});
		this._autoSize(inst);
		$.data(target, PROP_NAME, inst);
		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function(input, inst) {
		var appendText = this._get(inst, 'appendText');
		var isRTL = this._get(inst, 'isRTL');
		if (inst.append)
			inst.append.remove();
		if (appendText) {
			inst.append = $('<span class="' + this._appendClass + '">' + appendText + '</span>');
			input[isRTL ? 'before' : 'after'](inst.append);
		}
		input.unbind('focus', this._showDatepicker);
		if (inst.trigger)
			inst.trigger.remove();
		var showOn = this._get(inst, 'showOn');
		if (showOn == 'focus' || showOn == 'both') // pop-up date picker when in the marked field
			input.focus(this._showDatepicker);
		if (showOn == 'button' || showOn == 'both') { // pop-up date picker when button clicked
			var buttonText = this._get(inst, 'buttonText');
			var buttonImage = this._get(inst, 'buttonImage');
			inst.trigger = $(this._get(inst, 'buttonImageOnly') ?
				$('<img/>').addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$('<button type="button"></button>').addClass(this._triggerClass).
					html(buttonImage == '' ? buttonText : $('<img/>').attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? 'before' : 'after'](inst.trigger);
			inst.trigger.click(function() {
				if ($.datepicker._datepickerShowing && $.datepicker._lastInput == input[0])
					$.datepicker._hideDatepicker();
				else if ($.datepicker._datepickerShowing && $.datepicker._lastInput != input[0]) {
					$.datepicker._hideDatepicker();
					$.datepicker._showDatepicker(input[0]);
				} else
					$.datepicker._showDatepicker(input[0]);
				return false;
			});
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function(inst) {
		if (this._get(inst, 'autoSize') && !inst.inline) {
			var date = new Date(2009, 12 - 1, 20); // Ensure double digits
			var dateFormat = this._get(inst, 'dateFormat');
			if (dateFormat.match(/[DM]/)) {
				var findMax = function(names) {
					var max = 0;
					var maxI = 0;
					for (var i = 0; i < names.length; i++) {
						if (names[i].length > max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
					'monthNames' : 'monthNamesShort'))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
					'dayNames' : 'dayNamesShort'))) + 20 - date.getDay());
			}
			inst.input.attr('size', this._formatDate(inst, date).length);
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName))
			return;
		divSpan.addClass(this.markerClassName).append(inst.dpDiv).
			bind("setData.datepicker", function(event, key, value){
				inst.settings[key] = value;
			}).bind("getData.datepicker", function(event, key){
				return this._get(inst, key);
			});
		$.data(target, PROP_NAME, inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	   @param  input     element - ignored
	   @param  date      string or Date - the initial date to display
	   @param  onSelect  function - the function to call when a date is selected
	   @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	   @param  pos       int[2] - coordinates for the dialog's position within the screen or
	                     event - with x/y coordinates or
	                     leave empty for default (screen centre)
	   @return the manager object */
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var inst = this._dialogInst; // internal instance
		if (!inst) {
			this.uuid += 1;
			var id = 'dp' + this.uuid;
			this._dialogInput = $('<input type="text" id="' + id +
				'" style="position: absolute; top: -100px; width: 0px;"/>');
			this._dialogInput.keydown(this._doKeyDown);
			$('body').append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], PROP_NAME, inst);
		}
		extendRemove(inst.settings, settings || {});
		date = (date && date.constructor == Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			var browserWidth = document.documentElement.clientWidth;
			var browserHeight = document.documentElement.clientHeight;
			var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
		}

		// move input on screen for focus, but hidden behind dialog
		this._dialogInput.css('left', (this._pos[0] + 20) + 'px').css('top', this._pos[1] + 'px');
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI)
			$.blockUI(this.dpDiv);
		$.data(this._dialogInput[0], PROP_NAME, inst);
		return this;
	},

	/* Detach a datepicker from its control.
	   @param  target    element - the target input field or division or span */
	_destroyDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		$.removeData(target, PROP_NAME);
		if (nodeName == 'input') {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass(this.markerClassName).
				unbind('focus', this._showDatepicker).
				unbind('keydown', this._doKeyDown).
				unbind('keypress', this._doKeyPress).
				unbind('keyup', this._doKeyUp);
		} else if (nodeName == 'div' || nodeName == 'span')
			$target.removeClass(this.markerClassName).empty();
	},

	/* Enable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span */
	_enableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == 'input') {
			target.disabled = false;
			inst.trigger.filter('button').
				each(function() { this.disabled = false; }).end().
				filter('img').css({opacity: '1.0', cursor: ''});
		}
		else if (nodeName == 'div' || nodeName == 'span') {
			var inline = $target.children('.' + this._inlineClass);
			inline.children().removeClass('ui-state-disabled');
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", false);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span */
	_disableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == 'input') {
			target.disabled = true;
			inst.trigger.filter('button').
				each(function() { this.disabled = true; }).end().
				filter('img').css({opacity: '0.5', cursor: 'default'});
		}
		else if (nodeName == 'div' || nodeName == 'span') {
			var inline = $target.children('.' + this._inlineClass);
			inline.children().addClass('ui-state-disabled');
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", true);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); // delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	   @param  target    element - the target input field or division or span
	   @return boolean - true if disabled, false if enabled */
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i < this._disabledInputs.length; i++) {
			if (this._disabledInputs[i] == target)
				return true;
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	   @param  target  element - the target input field or division or span
	   @return  object - the associated instance data
	   @throws  error if a jQuery problem getting data */
	_getInst: function(target) {
		try {
			return $.data(target, PROP_NAME);
		}
		catch (err) {
			throw 'Missing instance data for this datepicker';
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span
	   @param  name    object - the new settings to update or
	                   string - the name of the setting to change or retrieve,
	                   when retrieving also 'all' for all instance settings or
	                   'defaults' for all global defaults
	   @param  value   any - the new value for the setting
	                   (omit if above is an object or to retrieve a value) */
	_optionDatepicker: function(target, name, value) {
		var inst = this._getInst(target);
		if (arguments.length == 2 && typeof name == 'string') {
			return (name == 'defaults' ? $.extend({}, $.datepicker._defaults) :
				(inst ? (name == 'all' ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}
		var settings = name || {};
		if (typeof name == 'string') {
			settings = {};
			settings[name] = value;
		}
		if (inst) {
			if (this._curInst == inst) {
				this._hideDatepicker();
			}
			var date = this._getDateDatepicker(target, true);
			var minDate = this._getMinMaxDate(inst, 'min');
			var maxDate = this._getMinMaxDate(inst, 'max');
			extendRemove(inst.settings, settings);
			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if (minDate !== null && settings['dateFormat'] !== undefined && settings['minDate'] === undefined)
				inst.settings.minDate = this._formatDate(inst, minDate);
			if (maxDate !== null && settings['dateFormat'] !== undefined && settings['maxDate'] === undefined)
				inst.settings.maxDate = this._formatDate(inst, maxDate);
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDate(inst, date);
			this._updateAlternate(inst);
			this._updateDatepicker(inst);
		}
	},

	// change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	/* Redraw the date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span */
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	/* Set the dates for a jQuery selection.
	   @param  target   element - the target input field or division or span
	   @param  date     Date - the new date */
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	   @param  target     element - the target input field or division or span
	   @param  noDefault  boolean - true if no default date is to be used
	   @return Date - the current date */
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst && !inst.inline)
			this._setDateFromField(inst, noDefault);
		return (inst ? this._getDate(inst) : null);
	},

	/* Handle keystrokes. */
	_doKeyDown: function(event) {
		var inst = $.datepicker._getInst(event.target);
		var handled = true;
		var isRTL = inst.dpDiv.is('.ui-datepicker-rtl');
		inst._keyEvent = true;
		if ($.datepicker._datepickerShowing)
			switch (event.keyCode) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: var sel = $('td.' + $.datepicker._dayOverClass + ':not(.' +
									$.datepicker._currentClass + ')', inst.dpDiv);
						if (sel[0])
							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
							var onSelect = $.datepicker._get(inst, 'onSelect');
							if (onSelect) {
								var dateStr = $.datepicker._formatDate(inst);

								// trigger custom callback
								onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
							}
						else
							$.datepicker._hideDatepicker();
						return false; // don't submit the form
						break; // select the value on enter
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							-$.datepicker._get(inst, 'stepBigMonths') :
							-$.datepicker._get(inst, 'stepMonths')), 'M');
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							+$.datepicker._get(inst, 'stepBigMonths') :
							+$.datepicker._get(inst, 'stepMonths')), 'M');
						break; // next month/year on page down/+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) $.datepicker._clearDate(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) $.datepicker._gotoToday(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), 'D');
						handled = event.ctrlKey || event.metaKey;
						// -1 day on ctrl or command +left
						if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
									-$.datepicker._get(inst, 'stepBigMonths') :
									-$.datepicker._get(inst, 'stepMonths')), 'M');
						// next month/year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, -7, 'D');
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), 'D');
						handled = event.ctrlKey || event.metaKey;
						// +1 day on ctrl or command +right
						if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
									+$.datepicker._get(inst, 'stepBigMonths') :
									+$.datepicker._get(inst, 'stepMonths')), 'M');
						// next month/year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, +7, 'D');
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		else if (event.keyCode == 36 && event.ctrlKey) // display the date picker on ctrl+home
			$.datepicker._showDatepicker(this);
		else {
			handled = false;
		}
		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function(event) {
		var inst = $.datepicker._getInst(event.target);
		if ($.datepicker._get(inst, 'constrainInput')) {
			var chars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat'));
			var chr = String.fromCharCode(event.charCode == undefined ? event.keyCode : event.charCode);
			return event.ctrlKey || event.metaKey || (chr < ' ' || !chars || chars.indexOf(chr) > -1);
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function(event) {
		var inst = $.datepicker._getInst(event.target);
		if (inst.input.val() != inst.lastVal) {
			try {
				var date = $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'),
					(inst.input ? inst.input.val() : null),
					$.datepicker._getFormatConfig(inst));
				if (date) { // only if valid
					$.datepicker._setDateFromField(inst);
					$.datepicker._updateAlternate(inst);
					$.datepicker._updateDatepicker(inst);
				}
			}
			catch (err) {
				$.datepicker.log(err);
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	   If false returned from beforeShow event handler do not show.
	   @param  input  element - the input field attached to the date picker or
	                  event - if triggered by focus */
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() != 'input') // find from button/image trigger
			input = $('input', input.parentNode)[0];
		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput == input) // already here
			return;
		var inst = $.datepicker._getInst(input);
		if ($.datepicker._curInst && $.datepicker._curInst != inst) {
			$.datepicker._curInst.dpDiv.stop(true, true);
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
			}
		}
		var beforeShow = $.datepicker._get(inst, 'beforeShow');
		var beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
		if(beforeShowSettings === false){
			//false
			return;
		}
		extendRemove(inst.settings, beforeShowSettings);
		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField(inst);
		if ($.datepicker._inDialog) // hide cursor
			input.value = '';
		if (!$.datepicker._pos) { // position below input
			$.datepicker._pos = $.datepicker._findPos(input);
			$.datepicker._pos[1] += input.offsetHeight; // add the height
		}
		var isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css('position') == 'fixed';
			return !isFixed;
		});
		var offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
		$.datepicker._pos = null;
		//to avoid flashes on Firefox
		inst.dpDiv.empty();
		// determine sizing offscreen
		inst.dpDiv.css({position: 'absolute', display: 'block', top: '-1000px'});
		$.datepicker._updateDatepicker(inst);
		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
			'static' : (isFixed ? 'fixed' : 'absolute')), display: 'none',
			left: offset.left + 'px', top: offset.top + 'px'});
		if (!inst.inline) {
			var showAnim = $.datepicker._get(inst, 'showAnim');
			var duration = $.datepicker._get(inst, 'duration');
			var postProcess = function() {
				var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); // IE6- only
				if( !! cover.length ){
					var borders = $.datepicker._getBorders(inst.dpDiv);
					cover.css({left: -borders[0], top: -borders[1],
						width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()});
				}
			};
			inst.dpDiv.zIndex($(input).zIndex()+1);
			$.datepicker._datepickerShowing = true;

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) )
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
			else
				inst.dpDiv[showAnim || 'show']((showAnim ? duration : null), postProcess);
			if (!showAnim || !duration)
				postProcess();
			if (inst.input.is(':visible') && !inst.input.is(':disabled'))
				inst.input.focus();
			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function(inst) {
		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		var borders = $.datepicker._getBorders(inst.dpDiv);
		instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append(this._generateHTML(inst));
		this._attachHandlers(inst);
		var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); // IE6- only
		if( !!cover.length ){ //avoid call to outerXXXX() when not in IE6
			cover.css({left: -borders[0], top: -borders[1], width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()})
		}
		inst.dpDiv.find('.' + this._dayOverClass + ' a').mouseover();
		var numMonths = this._getNumberOfMonths(inst);
		var cols = numMonths[1];
		var width = 17;
		inst.dpDiv.removeClass('ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4').width('');
		if (cols > 1)
			inst.dpDiv.addClass('ui-datepicker-multi-' + cols).css('width', (width * cols) + 'em');
		inst.dpDiv[(numMonths[0] != 1 || numMonths[1] != 1 ? 'add' : 'remove') +
			'Class']('ui-datepicker-multi');
		inst.dpDiv[(this._get(inst, 'isRTL') ? 'add' : 'remove') +
			'Class']('ui-datepicker-rtl');
		if (inst == $.datepicker._curInst && $.datepicker._datepickerShowing && inst.input &&
				// #6694 - don't focus the input if it's already focused
				// this breaks the change event in IE
				inst.input.is(':visible') && !inst.input.is(':disabled') && inst.input[0] != document.activeElement)
			inst.input.focus();
		// deffered render of the years select (to avoid flashes on Firefox)
		if( inst.yearshtml ){
			var origyearshtml = inst.yearshtml;
			setTimeout(function(){
				//assure that inst.yearshtml didn't change.
				if( origyearshtml === inst.yearshtml && inst.yearshtml ){
					inst.dpDiv.find('select.ui-datepicker-year:first').replaceWith(inst.yearshtml);
				}
				origyearshtml = inst.yearshtml = null;
			}, 0);
		}
	},

	/* Retrieve the size of left and top borders for an element.
	   @param  elem  (jQuery object) the element of interest
	   @return  (number[2]) the left and top borders */
	_getBorders: function(elem) {
		var convert = function(value) {
			return {thin: 1, medium: 2, thick: 3}[value] || value;
		};
		return [parseFloat(convert(elem.css('border-left-width'))),
			parseFloat(convert(elem.css('border-top-width')))];
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth();
		var dpHeight = inst.dpDiv.outerHeight();
		var inputWidth = inst.input ? inst.input.outerWidth() : 0;
		var inputHeight = inst.input ? inst.input.outerHeight() : 0;
		var viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft());
		var viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

		offset.left -= (this._get(inst, 'isRTL') ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed && offset.left == inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed && offset.top == (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		// now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
		offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function(obj) {
		var inst = this._getInst(obj);
		var isRTL = this._get(inst, 'isRTL');
		while (obj && (obj.type == 'hidden' || obj.nodeType != 1 || $.expr.filters.hidden(obj))) {
			obj = obj[isRTL ? 'previousSibling' : 'nextSibling'];
		}
		var position = $(obj).offset();
		return [position.left, position.top];
	},

	/* Hide the date picker from view.
	   @param  input  element - the input field attached to the date picker */
	_hideDatepicker: function(input) {
		var inst = this._curInst;
		if (!inst || (input && inst != $.data(input, PROP_NAME)))
			return;
		if (this._datepickerShowing) {
			var showAnim = this._get(inst, 'showAnim');
			var duration = this._get(inst, 'duration');
			var postProcess = function() {
				$.datepicker._tidyDialog(inst);
			};

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) )
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
			else
				inst.dpDiv[(showAnim == 'slideDown' ? 'slideUp' :
					(showAnim == 'fadeIn' ? 'fadeOut' : 'hide'))]((showAnim ? duration : null), postProcess);
			if (!showAnim)
				postProcess();
			this._datepickerShowing = false;
			var onClose = this._get(inst, 'onClose');
			if (onClose)
				onClose.apply((inst.input ? inst.input[0] : null),
					[(inst.input ? inst.input.val() : ''), inst]);
			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: 'absolute', left: '0', top: '-100px' });
				if ($.blockUI) {
					$.unblockUI();
					$('body').append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).unbind('.ui-datepicker-calendar');
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function(event) {
		if (!$.datepicker._curInst)
			return;

		var $target = $(event.target),
			inst = $.datepicker._getInst($target[0]);

		if ( ( ( $target[0].id != $.datepicker._mainDivId &&
				$target.parents('#' + $.datepicker._mainDivId).length == 0 &&
				!$target.hasClass($.datepicker.markerClassName) &&
				!$target.closest("." + $.datepicker._triggerClass).length &&
				$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
			( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst != inst ) )
			$.datepicker._hideDatepicker();
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function(id, offset, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period == 'M' ? this._get(inst, 'showCurrentAtPos') : 0), // undo positioning
			period);
		this._updateDatepicker(inst);
	},

	/* Action for current link. */
	_gotoToday: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._get(inst, 'gotoCurrent') && inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		}
		else {
			var date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function(id, select, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		inst['selected' + (period == 'M' ? 'Month' : 'Year')] =
		inst['draw' + (period == 'M' ? 'Month' : 'Year')] =
			parseInt(select.options[select.selectedIndex].value,10);
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a day. */
	_selectDay: function(id, month, year, td) {
		var target = $(id);
		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}
		var inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $('a', td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		this._selectDate(target, '');
	},

	/* Update the input field with the selected date. */
	_selectDate: function(id, dateStr) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input)
			inst.input.val(dateStr);
		this._updateAlternate(inst);
		var onSelect = this._get(inst, 'onSelect');
		if (onSelect)
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		else if (inst.input)
			inst.input.trigger('change'); // fire the change event
		if (inst.inline)
			this._updateDatepicker(inst);
		else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) != 'object')
				inst.input.focus(); // restore focus
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function(inst) {
		var altField = this._get(inst, 'altField');
		if (altField) { // update alternate field too
			var altFormat = this._get(inst, 'altFormat') || this._get(inst, 'dateFormat');
			var date = this._getDate(inst);
			var dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	   @param  date  Date - the date to customise
	   @return [boolean, string] - is this date selectable?, what is its CSS class? */
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day > 0 && day < 6), ''];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	   @param  date  Date - the date to get the week for
	   @return  number - the number of the week within the year that contains this date */
	iso8601Week: function(date) {
		var checkDate = new Date(date.getTime());
		// Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
		var time = checkDate.getTime();
		checkDate.setMonth(0); // Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	},

	/* Parse a string value into a date object.
	   See formatDate below for the possible formats.

	   @param  format    string - the expected format of the date
	   @param  value     string - the date in the above format
	   @param  settings  Object - attributes include:
	                     shortYearCutoff  number - the cutoff year for determining the century (optional)
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  Date - the extracted date value or null if value is blank */
	parseDate: function (format, value, settings) {
		if (format == null || value == null)
			throw 'Invalid arguments';
		value = (typeof value == 'object' ? value.toString() : value + '');
		if (value == '')
			return null;
		var shortYearCutoff = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff;
		shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		var year = -1;
		var month = -1;
		var day = -1;
		var doy = -1;
		var literal = false;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		// Extract a number from the string value
		var getNumber = function(match) {
			var isDoubled = lookAhead(match);
			var size = (match == '@' ? 14 : (match == '!' ? 20 :
				(match == 'y' && isDoubled ? 4 : (match == 'o' ? 3 : 2))));
			var digits = new RegExp('^\\d{1,' + size + '}');
			var num = value.substring(iValue).match(digits);
			if (!num)
				throw 'Missing number at position ' + iValue;
			iValue += num[0].length;
			return parseInt(num[0], 10);
		};
		// Extract a name from the string value and convert to an index
		var getName = function(match, shortNames, longNames) {
			var names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
				return [ [k, v] ];
			}).sort(function (a, b) {
				return -(a[1].length - b[1].length);
			});
			var index = -1;
			$.each(names, function (i, pair) {
				var name = pair[1];
				if (value.substr(iValue, name.length).toLowerCase() == name.toLowerCase()) {
					index = pair[0];
					iValue += name.length;
					return false;
				}
			});
			if (index != -1)
				return index + 1;
			else
				throw 'Unknown name at position ' + iValue;
		};
		// Confirm that a literal character matches the string value
		var checkLiteral = function() {
			if (value.charAt(iValue) != format.charAt(iFormat))
				throw 'Unexpected literal at position ' + iValue;
			iValue++;
		};
		var iValue = 0;
		for (var iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal)
				if (format.charAt(iFormat) == "'" && !lookAhead("'"))
					literal = false;
				else
					checkLiteral();
			else
				switch (format.charAt(iFormat)) {
					case 'd':
						day = getNumber('d');
						break;
					case 'D':
						getName('D', dayNamesShort, dayNames);
						break;
					case 'o':
						doy = getNumber('o');
						break;
					case 'm':
						month = getNumber('m');
						break;
					case 'M':
						month = getName('M', monthNamesShort, monthNames);
						break;
					case 'y':
						year = getNumber('y');
						break;
					case '@':
						var date = new Date(getNumber('@'));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case '!':
						var date = new Date((getNumber('!') - this._ticksTo1970) / 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if (lookAhead("'"))
							checkLiteral();
						else
							literal = true;
						break;
					default:
						checkLiteral();
				}
		}
		if (iValue < value.length){
			var extra = value.substr(iValue);
			if (!/^\s+/.test(extra)) {
				throw "Extra/unparsed characters found in date: " + extra;
			}
		}
		if (year == -1)
			year = new Date().getFullYear();
		else if (year < 100)
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year <= shortYearCutoff ? 0 : -100);
		if (doy > -1) {
			month = 1;
			day = doy;
			do {
				var dim = this._getDaysInMonth(year, month - 1);
				if (day <= dim)
					break;
				month++;
				day -= dim;
			} while (true);
		}
		var date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() != year || date.getMonth() + 1 != month || date.getDate() != day)
			throw 'Invalid date'; // E.g. 31/02/00
		return date;
	},

	/* Standard date formats. */
	ATOM: 'yy-mm-dd', // RFC 3339 (ISO 8601)
	COOKIE: 'D, dd M yy',
	ISO_8601: 'yy-mm-dd',
	RFC_822: 'D, d M y',
	RFC_850: 'DD, dd-M-y',
	RFC_1036: 'D, d M y',
	RFC_1123: 'D, d M yy',
	RFC_2822: 'D, d M yy',
	RSS: 'D, d M y', // RFC 822
	TICKS: '!',
	TIMESTAMP: '@',
	W3C: 'yy-mm-dd', // ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

	/* Format a date object into a string value.
	   The format can be combinations of the following:
	   d  - day of month (no leading zero)
	   dd - day of month (two digit)
	   o  - day of year (no leading zeros)
	   oo - day of year (three digit)
	   D  - day name short
	   DD - day name long
	   m  - month of year (no leading zero)
	   mm - month of year (two digit)
	   M  - month name short
	   MM - month name long
	   y  - year (two digit)
	   yy - year (four digit)
	   @ - Unix timestamp (ms since 01/01/1970)
	   ! - Windows ticks (100ns since 01/01/0001)
	   '...' - literal text
	   '' - single quote

	   @param  format    string - the desired format of the date
	   @param  date      Date - the date value to format
	   @param  settings  Object - attributes include:
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  string - the date in the above format */
	formatDate: function (format, date, settings) {
		if (!date)
			return '';
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		// Format a number, with leading zero if necessary
		var formatNumber = function(match, value, len) {
			var num = '' + value;
			if (lookAhead(match))
				while (num.length < len)
					num = '0' + num;
			return num;
		};
		// Format a name, short or long as requested
		var formatName = function(match, value, shortNames, longNames) {
			return (lookAhead(match) ? longNames[value] : shortNames[value]);
		};
		var output = '';
		var literal = false;
		if (date)
			for (var iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal)
					if (format.charAt(iFormat) == "'" && !lookAhead("'"))
						literal = false;
					else
						output += format.charAt(iFormat);
				else
					switch (format.charAt(iFormat)) {
						case 'd':
							output += formatNumber('d', date.getDate(), 2);
							break;
						case 'D':
							output += formatName('D', date.getDay(), dayNamesShort, dayNames);
							break;
						case 'o':
							output += formatNumber('o',
								Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
							break;
						case 'm':
							output += formatNumber('m', date.getMonth() + 1, 2);
							break;
						case 'M':
							output += formatName('M', date.getMonth(), monthNamesShort, monthNames);
							break;
						case 'y':
							output += (lookAhead('y') ? date.getFullYear() :
								(date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100);
							break;
						case '@':
							output += date.getTime();
							break;
						case '!':
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if (lookAhead("'"))
								output += "'";
							else
								literal = true;
							break;
						default:
							output += format.charAt(iFormat);
					}
			}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function (format) {
		var chars = '';
		var literal = false;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		for (var iFormat = 0; iFormat < format.length; iFormat++)
			if (literal)
				if (format.charAt(iFormat) == "'" && !lookAhead("'"))
					literal = false;
				else
					chars += format.charAt(iFormat);
			else
				switch (format.charAt(iFormat)) {
					case 'd': case 'm': case 'y': case '@':
						chars += '0123456789';
						break;
					case 'D': case 'M':
						return null; // Accept anything
					case "'":
						if (lookAhead("'"))
							chars += "'";
						else
							literal = true;
						break;
					default:
						chars += format.charAt(iFormat);
				}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function(inst, name) {
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() == inst.lastVal) {
			return;
		}
		var dateFormat = this._get(inst, 'dateFormat');
		var dates = inst.lastVal = inst.input ? inst.input.val() : null;
		var date, defaultDate;
		date = defaultDate = this._getDefaultDate(inst);
		var settings = this._getFormatConfig(inst);
		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			this.log(event);
			dates = (noDefault ? '' : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, 'defaultDate'), new Date()));
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
			var date = new Date();
			date.setDate(date.getDate() + offset);
			return date;
		};
		var offsetString = function(offset) {
			try {
				return $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'),
					offset, $.datepicker._getFormatConfig(inst));
			}
			catch (e) {
				// Ignore
			}
			var date = (offset.toLowerCase().match(/^c/) ?
				$.datepicker._getDate(inst) : null) || new Date();
			var year = date.getFullYear();
			var month = date.getMonth();
			var day = date.getDate();
			var pattern = /([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g;
			var matches = pattern.exec(offset);
			while (matches) {
				switch (matches[2] || 'd') {
					case 'd' : case 'D' :
						day += parseInt(matches[1],10); break;
					case 'w' : case 'W' :
						day += parseInt(matches[1],10) * 7; break;
					case 'm' : case 'M' :
						month += parseInt(matches[1],10);
						day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
						break;
					case 'y': case 'Y' :
						year += parseInt(matches[1],10);
						day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
						break;
				}
				matches = pattern.exec(offset);
			}
			return new Date(year, month, day);
		};
		var newDate = (date == null || date === '' ? defaultDate : (typeof date == 'string' ? offsetString(date) :
			(typeof date == 'number' ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));
		newDate = (newDate && newDate.toString() == 'Invalid Date' ? defaultDate : newDate);
		if (newDate) {
			newDate.setHours(0);
			newDate.setMinutes(0);
			newDate.setSeconds(0);
			newDate.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(newDate);
	},

	/* Handle switch to/from daylight saving.
	   Hours may be non-zero on daylight saving cut-over:
	   > 12 when midnight changeover, but then cannot generate
	   midnight datetime, so jump to 1AM, otherwise reset.
	   @param  date  (Date) the date to check
	   @return  (Date) the corrected date */
	_daylightSavingAdjust: function(date) {
		if (!date) return null;
		date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function(inst, date, noChange) {
		var clear = !date;
		var origMonth = inst.selectedMonth;
		var origYear = inst.selectedYear;
		var newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ((origMonth != inst.selectedMonth || origYear != inst.selectedYear) && !noChange)
			this._notifyChange(inst);
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? '' : this._formatDate(inst));
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input && inst.input.val() == '') ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function(inst) {
		var stepMonths = this._get(inst, 'stepMonths');
		var id = '#' + inst.id.replace( /\\\\/g, "\\" );
		inst.dpDiv.find('[data-handler]').map(function () {
			var handler = {
				prev: function () {
					window['DP_jQuery_' + dpuuid].datepicker._adjustDate(id, -stepMonths, 'M');
				},
				next: function () {
					window['DP_jQuery_' + dpuuid].datepicker._adjustDate(id, +stepMonths, 'M');
				},
				hide: function () {
					window['DP_jQuery_' + dpuuid].datepicker._hideDatepicker();
				},
				today: function () {
					window['DP_jQuery_' + dpuuid].datepicker._gotoToday(id);
				},
				selectDay: function () {
					window['DP_jQuery_' + dpuuid].datepicker._selectDay(id, +this.getAttribute('data-month'), +this.getAttribute('data-year'), this);
					return false;
				},
				selectMonth: function () {
					window['DP_jQuery_' + dpuuid].datepicker._selectMonthYear(id, this, 'M');
					return false;
				},
				selectYear: function () {
					window['DP_jQuery_' + dpuuid].datepicker._selectMonthYear(id, this, 'Y');
					return false;
				}
			};
			$(this).bind(this.getAttribute('data-event'), handler[this.getAttribute('data-handler')]);
		});
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function(inst) {
		var today = new Date();
		today = this._daylightSavingAdjust(
			new Date(today.getFullYear(), today.getMonth(), today.getDate())); // clear time
		var isRTL = this._get(inst, 'isRTL');
		var showButtonPanel = this._get(inst, 'showButtonPanel');
		var hideIfNoPrevNext = this._get(inst, 'hideIfNoPrevNext');
		var navigationAsDateFormat = this._get(inst, 'navigationAsDateFormat');
		var numMonths = this._getNumberOfMonths(inst);
		var showCurrentAtPos = this._get(inst, 'showCurrentAtPos');
		var stepMonths = this._get(inst, 'stepMonths');
		var isMultiMonth = (numMonths[0] != 1 || numMonths[1] != 1);
		var currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
			new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		var drawMonth = inst.drawMonth - showCurrentAtPos;
		var drawYear = inst.drawYear;
		if (drawMonth < 0) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			var maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
				drawMonth--;
				if (drawMonth < 0) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;
		var prevText = this._get(inst, 'prevText');
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));
		var prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			'<a class="ui-datepicker-prev ui-corner-all" data-handler="prev" data-event="click"' +
			' title="' + prevText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>' :
			(hideIfNoPrevNext ? '' : '<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="'+ prevText +'"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>'));
		var nextText = this._get(inst, 'nextText');
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));
		var next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			'<a class="ui-datepicker-next ui-corner-all" data-handler="next" data-event="click"' +
			' title="' + nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>' :
			(hideIfNoPrevNext ? '' : '<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="'+ nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>'));
		var currentText = this._get(inst, 'currentText');
		var gotoDate = (this._get(inst, 'gotoCurrent') && inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));
		var controls = (!inst.inline ? '<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" data-handler="hide" data-event="click">' +
			this._get(inst, 'closeText') + '</button>' : '');
		var buttonPanel = (showButtonPanel) ? '<div class="ui-datepicker-buttonpane ui-widget-content">' + (isRTL ? controls : '') +
			(this._isInRange(inst, gotoDate) ? '<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" data-handler="today" data-event="click"' +
			'>' + currentText + '</button>' : '') + (isRTL ? '' : controls) + '</div>' : '';
		var firstDay = parseInt(this._get(inst, 'firstDay'),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);
		var showWeek = this._get(inst, 'showWeek');
		var dayNames = this._get(inst, 'dayNames');
		var dayNamesShort = this._get(inst, 'dayNamesShort');
		var dayNamesMin = this._get(inst, 'dayNamesMin');
		var monthNames = this._get(inst, 'monthNames');
		var monthNamesShort = this._get(inst, 'monthNamesShort');
		var beforeShowDay = this._get(inst, 'beforeShowDay');
		var showOtherMonths = this._get(inst, 'showOtherMonths');
		var selectOtherMonths = this._get(inst, 'selectOtherMonths');
		var calculateWeek = this._get(inst, 'calculateWeek') || this.iso8601Week;
		var defaultDate = this._getDefaultDate(inst);
		var html = '';
		for (var row = 0; row < numMonths[0]; row++) {
			var group = '';
			this.maxRows = 4;
			for (var col = 0; col < numMonths[1]; col++) {
				var selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				var cornerClass = ' ui-corner-all';
				var calender = '';
				if (isMultiMonth) {
					calender += '<div class="ui-datepicker-group';
					if (numMonths[1] > 1)
						switch (col) {
							case 0: calender += ' ui-datepicker-group-first';
								cornerClass = ' ui-corner-' + (isRTL ? 'right' : 'left'); break;
							case numMonths[1]-1: calender += ' ui-datepicker-group-last';
								cornerClass = ' ui-corner-' + (isRTL ? 'left' : 'right'); break;
							default: calender += ' ui-datepicker-group-middle'; cornerClass = ''; break;
						}
					calender += '">';
				}
				calender += '<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix' + cornerClass + '">' +
					(/all|left/.test(cornerClass) && row == 0 ? (isRTL ? next : prev) : '') +
					(/all|right/.test(cornerClass) && row == 0 ? (isRTL ? prev : next) : '') +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
					'</div><table class="ui-datepicker-calendar"><thead>' +
					'<tr>';
				var thead = (showWeek ? '<th class="ui-datepicker-week-col">' + this._get(inst, 'weekHeader') + '</th>' : '');
				for (var dow = 0; dow < 7; dow++) { // days of the week
					var day = (dow + firstDay) % 7;
					thead += '<th' + ((dow + firstDay + 6) % 7 >= 5 ? ' class="ui-datepicker-week-end"' : '') + '>' +
						'<span title="' + dayNames[day] + '">' + dayNamesMin[day] + '</span></th>';
				}
				calender += thead + '</tr></thead><tbody>';
				var daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear == inst.selectedYear && drawMonth == inst.selectedMonth)
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				var leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				var curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
				var numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				var printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (var dRow = 0; dRow < numRows; dRow++) { // create date picker rows
					calender += '<tr>';
					var tbody = (!showWeek ? '' : '<td class="ui-datepicker-week-col">' +
						this._get(inst, 'calculateWeek')(printDate) + '</td>');
					for (var dow = 0; dow < 7; dow++) { // create date picker days
						var daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, '']);
						var otherMonth = (printDate.getMonth() != drawMonth);
						var unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
							(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
						tbody += '<td class="' +
							((dow + firstDay + 6) % 7 >= 5 ? ' ui-datepicker-week-end' : '') + // highlight weekends
							(otherMonth ? ' ui-datepicker-other-month' : '') + // highlight days from other months
							((printDate.getTime() == selectedDate.getTime() && drawMonth == inst.selectedMonth && inst._keyEvent) || // user pressed key
							(defaultDate.getTime() == printDate.getTime() && defaultDate.getTime() == selectedDate.getTime()) ?
							// or defaultDate is current printedDate and defaultDate is selectedDate
							' ' + this._dayOverClass : '') + // highlight selected day
							(unselectable ? ' ' + this._unselectableClass + ' ui-state-disabled': '') +  // highlight unselectable days
							(otherMonth && !showOtherMonths ? '' : ' ' + daySettings[1] + // highlight custom dates
							(printDate.getTime() == currentDate.getTime() ? ' ' + this._currentClass : '') + // highlight selected day
							(printDate.getTime() == today.getTime() ? ' ui-datepicker-today' : '')) + '"' + // highlight today (if different)
							((!otherMonth || showOtherMonths) && daySettings[2] ? ' title="' + daySettings[2] + '"' : '') + // cell title
							(unselectable ? '' : ' data-handler="selectDay" data-event="click" data-month="' + printDate.getMonth() + '" data-year="' + printDate.getFullYear() + '"') + '>' + // actions
							(otherMonth && !showOtherMonths ? '&#xa0;' : // display for other months
							(unselectable ? '<span class="ui-state-default">' + printDate.getDate() + '</span>' : '<a class="ui-state-default' +
							(printDate.getTime() == today.getTime() ? ' ui-state-highlight' : '') +
							(printDate.getTime() == currentDate.getTime() ? ' ui-state-active' : '') + // highlight selected day
							(otherMonth ? ' ui-priority-secondary' : '') + // distinguish dates from other months
							'" href="#">' + printDate.getDate() + '</a>')) + '</td>'; // display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + '</tr>';
				}
				drawMonth++;
				if (drawMonth > 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += '</tbody></table>' + (isMultiMonth ? '</div>' +
							((numMonths[0] > 0 && col == numMonths[1]-1) ? '<div class="ui-datepicker-row-break"></div>' : '') : '');
				group += calender;
			}
			html += group;
		}
		html += buttonPanel + ($.ui.ie6 && !inst.inline ?
			'<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>' : '');
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {
		var changeMonth = this._get(inst, 'changeMonth');
		var changeYear = this._get(inst, 'changeYear');
		var showMonthAfterYear = this._get(inst, 'showMonthAfterYear');
		var html = '<div class="ui-datepicker-title">';
		var monthHtml = '';
		// month selection
		if (secondary || !changeMonth)
			monthHtml += '<span class="ui-datepicker-month">' + monthNames[drawMonth] + '</span>';
		else {
			var inMinYear = (minDate && minDate.getFullYear() == drawYear);
			var inMaxYear = (maxDate && maxDate.getFullYear() == drawYear);
			monthHtml += '<select class="ui-datepicker-month" data-handler="selectMonth" data-event="change">';
			for (var month = 0; month < 12; month++) {
				if ((!inMinYear || month >= minDate.getMonth()) &&
						(!inMaxYear || month <= maxDate.getMonth()))
					monthHtml += '<option value="' + month + '"' +
						(month == drawMonth ? ' selected="selected"' : '') +
						'>' + monthNamesShort[month] + '</option>';
			}
			monthHtml += '</select>';
		}
		if (!showMonthAfterYear)
			html += monthHtml + (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '');
		// year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = '';
			if (secondary || !changeYear)
				html += '<span class="ui-datepicker-year">' + drawYear + '</span>';
			else {
				// determine range of years to display
				var years = this._get(inst, 'yearRange').split(':');
				var thisYear = new Date().getFullYear();
				var determineYear = function(value) {
					var year = (value.match(/c[+-].*/) ? drawYear + parseInt(value.substring(1), 10) :
						(value.match(/[+-].*/) ? thisYear + parseInt(value, 10) :
						parseInt(value, 10)));
					return (isNaN(year) ? thisYear : year);
				};
				var year = determineYear(years[0]);
				var endYear = Math.max(year, determineYear(years[1] || ''));
				year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
				endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
				inst.yearshtml += '<select class="ui-datepicker-year" data-handler="selectYear" data-event="change">';
				for (; year <= endYear; year++) {
					inst.yearshtml += '<option value="' + year + '"' +
						(year == drawYear ? ' selected="selected"' : '') +
						'>' + year + '</option>';
				}
				inst.yearshtml += '</select>';

				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}
		html += this._get(inst, 'yearSuffix');
		if (showMonthAfterYear)
			html += (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '') + monthHtml;
		html += '</div>'; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period == 'Y' ? offset : 0);
		var month = inst.drawMonth + (period == 'M' ? offset : 0);
		var day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) +
			(period == 'D' ? offset : 0);
		var date = this._restrictMinMax(inst,
			this._daylightSavingAdjust(new Date(year, month, day)));
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period == 'M' || period == 'Y')
			this._notifyChange(inst);
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		var newDate = (minDate && date < minDate ? minDate : date);
		newDate = (maxDate && newDate > maxDate ? maxDate : newDate);
		return newDate;
	},

	/* Notify change of month/year. */
	_notifyChange: function(inst) {
		var onChange = this._get(inst, 'onChangeMonthYear');
		if (onChange)
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, 'numberOfMonths');
		return (numMonths == null ? [1, 1] : (typeof numMonths == 'number' ? [1, numMonths] : numMonths));
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + 'Date'), null);
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function(year, month) {
		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst);
		var date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
		if (offset < 0)
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		return this._isInRange(inst, date);
	},

	/* Is the given date in the accepted range? */
	_isInRange: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		return ((!minDate || date.getTime() >= minDate.getTime()) &&
			(!maxDate || date.getTime() <= maxDate.getTime()));
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, 'shortYearCutoff');
		shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, 'dayNamesShort'), dayNames: this._get(inst, 'dayNames'),
			monthNamesShort: this._get(inst, 'monthNamesShort'), monthNames: this._get(inst, 'monthNames')};
	},

	/* Format the given date for display. */
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day == 'object' ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, 'dateFormat'), date, this._getFormatConfig(inst));
	}
});

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function bindHover(dpDiv) {
	var selector = 'button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a';
	return dpDiv.delegate(selector, 'mouseout', function() {
			$(this).removeClass('ui-state-hover');
			if (this.className.indexOf('ui-datepicker-prev') != -1) $(this).removeClass('ui-datepicker-prev-hover');
			if (this.className.indexOf('ui-datepicker-next') != -1) $(this).removeClass('ui-datepicker-next-hover');
		})
		.delegate(selector, 'mouseover', function(){
			if (!$.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
				$(this).parents('.ui-datepicker-calendar').find('a').removeClass('ui-state-hover');
				$(this).addClass('ui-state-hover');
				if (this.className.indexOf('ui-datepicker-prev') != -1) $(this).addClass('ui-datepicker-prev-hover');
				if (this.className.indexOf('ui-datepicker-next') != -1) $(this).addClass('ui-datepicker-next-hover');
			}
		});
}

/* jQuery extend now ignores nulls! */
function extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props)
		if (props[name] == null || props[name] == undefined)
			target[name] = props[name];
	return target;
};

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
	                Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){

	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}

	/* Initialise the date picker. */
	if (!$.datepicker.initialized) {
		$(document).mousedown($.datepicker._checkExternalClick).
			find(document.body).append($.datepicker.dpDiv);
		$.datepicker.initialized = true;
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options == 'string' && (options == 'isDisabled' || options == 'getDate' || options == 'widget'))
		return $.datepicker['_' + options + 'Datepicker'].
			apply($.datepicker, [this[0]].concat(otherArgs));
	if (options == 'option' && arguments.length == 2 && typeof arguments[1] == 'string')
		return $.datepicker['_' + options + 'Datepicker'].
			apply($.datepicker, [this[0]].concat(otherArgs));
	return this.each(function() {
		typeof options == 'string' ?
			$.datepicker['_' + options + 'Datepicker'].
				apply($.datepicker, [this].concat(otherArgs)) :
			$.datepicker._attachDatepicker(this, options);
	});
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.9.2";

// Workaround for #4055
// Add another global to avoid noConflict issues with inline event handlers
window['DP_jQuery_' + dpuuid] = $;

})(jQuery);
(function( $, undefined ) {

var uiDialogClasses = "ui-dialog ui-widget ui-widget-content ui-corner-all ",
	sizeRelatedOptions = {
		buttons: true,
		height: true,
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true,
		width: true
	},
	resizableRelatedOptions = {
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true
	};

$.widget("ui.dialog", {
	version: "1.9.2",
	options: {
		autoOpen: true,
		buttons: {},
		closeOnEscape: true,
		closeText: "close",
		dialogClass: "",
		draggable: true,
		hide: null,
		height: "auto",
		maxHeight: false,
		maxWidth: false,
		minHeight: 150,
		minWidth: 150,
		modal: false,
		position: {
			my: "center",
			at: "center",
			of: window,
			collision: "fit",
			// ensure that the titlebar is never outside the document
			using: function( pos ) {
				var topOffset = $( this ).css( pos ).offset().top;
				if ( topOffset < 0 ) {
					$( this ).css( "top", pos.top - topOffset );
				}
			}
		},
		resizable: true,
		show: null,
		stack: true,
		title: "",
		width: 300,
		zIndex: 1000
	},

	_create: function() {
		this.originalTitle = this.element.attr( "title" );
		// #5742 - .attr() might return a DOMElement
		if ( typeof this.originalTitle !== "string" ) {
			this.originalTitle = "";
		}
		this.oldPosition = {
			parent: this.element.parent(),
			index: this.element.parent().children().index( this.element )
		};
		this.options.title = this.options.title || this.originalTitle;
		var that = this,
			options = this.options,

			title = options.title || "&#160;",
			uiDialog,
			uiDialogTitlebar,
			uiDialogTitlebarClose,
			uiDialogTitle,
			uiDialogButtonPane;

			uiDialog = ( this.uiDialog = $( "<div>" ) )
				.addClass( uiDialogClasses + options.dialogClass )
				.css({
					display: "none",
					outline: 0, // TODO: move to stylesheet
					zIndex: options.zIndex
				})
				// setting tabIndex makes the div focusable
				.attr( "tabIndex", -1)
				.keydown(function( event ) {
					if ( options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
							event.keyCode === $.ui.keyCode.ESCAPE ) {
						that.close( event );
						event.preventDefault();
					}
				})
				.mousedown(function( event ) {
					that.moveToTop( false, event );
				})
				.appendTo( "body" );

			this.element
				.show()
				.removeAttr( "title" )
				.addClass( "ui-dialog-content ui-widget-content" )
				.appendTo( uiDialog );

			uiDialogTitlebar = ( this.uiDialogTitlebar = $( "<div>" ) )
				.addClass( "ui-dialog-titlebar  ui-widget-header  " +
					"ui-corner-all  ui-helper-clearfix" )
				.bind( "mousedown", function() {
					// Dialog isn't getting focus when dragging (#8063)
					uiDialog.focus();
				})
				.prependTo( uiDialog );

			uiDialogTitlebarClose = $( "<a href='#'></a>" )
				.addClass( "ui-dialog-titlebar-close  ui-corner-all" )
				.attr( "role", "button" )
				.click(function( event ) {
					event.preventDefault();
					that.close( event );
				})
				.appendTo( uiDialogTitlebar );

			( this.uiDialogTitlebarCloseText = $( "<span>" ) )
				.addClass( "ui-icon ui-icon-closethick" )
				.text( options.closeText )
				.appendTo( uiDialogTitlebarClose );

			uiDialogTitle = $( "<span>" )
				.uniqueId()
				.addClass( "ui-dialog-title" )
				.html( title )
				.prependTo( uiDialogTitlebar );

			uiDialogButtonPane = ( this.uiDialogButtonPane = $( "<div>" ) )
				.addClass( "ui-dialog-buttonpane ui-widget-content ui-helper-clearfix" );

			( this.uiButtonSet = $( "<div>" ) )
				.addClass( "ui-dialog-buttonset" )
				.appendTo( uiDialogButtonPane );

		uiDialog.attr({
			role: "dialog",
			"aria-labelledby": uiDialogTitle.attr( "id" )
		});

		uiDialogTitlebar.find( "*" ).add( uiDialogTitlebar ).disableSelection();
		this._hoverable( uiDialogTitlebarClose );
		this._focusable( uiDialogTitlebarClose );

		if ( options.draggable && $.fn.draggable ) {
			this._makeDraggable();
		}
		if ( options.resizable && $.fn.resizable ) {
			this._makeResizable();
		}

		this._createButtons( options.buttons );
		this._isOpen = false;

		if ( $.fn.bgiframe ) {
			uiDialog.bgiframe();
		}

		// prevent tabbing out of modal dialogs
		this._on( uiDialog, { keydown: function( event ) {
			if ( !options.modal || event.keyCode !== $.ui.keyCode.TAB ) {
				return;
			}

			var tabbables = $( ":tabbable", uiDialog ),
				first = tabbables.filter( ":first" ),
				last  = tabbables.filter( ":last" );

			if ( event.target === last[0] && !event.shiftKey ) {
				first.focus( 1 );
				return false;
			} else if ( event.target === first[0] && event.shiftKey ) {
				last.focus( 1 );
				return false;
			}
		}});
	},

	_init: function() {
		if ( this.options.autoOpen ) {
			this.open();
		}
	},

	_destroy: function() {
		var next,
			oldPosition = this.oldPosition;

		if ( this.overlay ) {
			this.overlay.destroy();
		}
		this.uiDialog.hide();
		this.element
			.removeClass( "ui-dialog-content ui-widget-content" )
			.hide()
			.appendTo( "body" );
		this.uiDialog.remove();

		if ( this.originalTitle ) {
			this.element.attr( "title", this.originalTitle );
		}

		next = oldPosition.parent.children().eq( oldPosition.index );
		// Don't try to place the dialog next to itself (#8613)
		if ( next.length && next[ 0 ] !== this.element[ 0 ] ) {
			next.before( this.element );
		} else {
			oldPosition.parent.append( this.element );
		}
	},

	widget: function() {
		return this.uiDialog;
	},

	close: function( event ) {
		var that = this,
			maxZ, thisZ;

		if ( !this._isOpen ) {
			return;
		}

		if ( false === this._trigger( "beforeClose", event ) ) {
			return;
		}

		this._isOpen = false;

		if ( this.overlay ) {
			this.overlay.destroy();
		}

		if ( this.options.hide ) {
			this._hide( this.uiDialog, this.options.hide, function() {
				that._trigger( "close", event );
			});
		} else {
			this.uiDialog.hide();
			this._trigger( "close", event );
		}

		$.ui.dialog.overlay.resize();

		// adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
		if ( this.options.modal ) {
			maxZ = 0;
			$( ".ui-dialog" ).each(function() {
				if ( this !== that.uiDialog[0] ) {
					thisZ = $( this ).css( "z-index" );
					if ( !isNaN( thisZ ) ) {
						maxZ = Math.max( maxZ, thisZ );
					}
				}
			});
			$.ui.dialog.maxZ = maxZ;
		}

		return this;
	},

	isOpen: function() {
		return this._isOpen;
	},

	// the force parameter allows us to move modal dialogs to their correct
	// position on open
	moveToTop: function( force, event ) {
		var options = this.options,
			saveScroll;

		if ( ( options.modal && !force ) ||
				( !options.stack && !options.modal ) ) {
			return this._trigger( "focus", event );
		}

		if ( options.zIndex > $.ui.dialog.maxZ ) {
			$.ui.dialog.maxZ = options.zIndex;
		}
		if ( this.overlay ) {
			$.ui.dialog.maxZ += 1;
			$.ui.dialog.overlay.maxZ = $.ui.dialog.maxZ;
			this.overlay.$el.css( "z-index", $.ui.dialog.overlay.maxZ );
		}

		// Save and then restore scroll
		// Opera 9.5+ resets when parent z-index is changed.
		// http://bugs.jqueryui.com/ticket/3193
		saveScroll = {
			scrollTop: this.element.scrollTop(),
			scrollLeft: this.element.scrollLeft()
		};
		$.ui.dialog.maxZ += 1;
		this.uiDialog.css( "z-index", $.ui.dialog.maxZ );
		this.element.attr( saveScroll );
		this._trigger( "focus", event );

		return this;
	},

	open: function() {
		if ( this._isOpen ) {
			return;
		}

		var hasFocus,
			options = this.options,
			uiDialog = this.uiDialog;

		this._size();
		this._position( options.position );
		uiDialog.show( options.show );
		this.overlay = options.modal ? new $.ui.dialog.overlay( this ) : null;
		this.moveToTop( true );

		// set focus to the first tabbable element in the content area or the first button
		// if there are no tabbable elements, set focus on the dialog itself
		hasFocus = this.element.find( ":tabbable" );
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialogButtonPane.find( ":tabbable" );
			if ( !hasFocus.length ) {
				hasFocus = uiDialog;
			}
		}
		hasFocus.eq( 0 ).focus();

		this._isOpen = true;
		this._trigger( "open" );

		return this;
	},

	_createButtons: function( buttons ) {
		var that = this,
			hasButtons = false;

		// if we already have a button pane, remove it
		this.uiDialogButtonPane.remove();
		this.uiButtonSet.empty();

		if ( typeof buttons === "object" && buttons !== null ) {
			$.each( buttons, function() {
				return !(hasButtons = true);
			});
		}
		if ( hasButtons ) {
			$.each( buttons, function( name, props ) {
				var button, click;
				props = $.isFunction( props ) ?
					{ click: props, text: name } :
					props;
				// Default to a non-submitting button
				props = $.extend( { type: "button" }, props );
				// Change the context for the click callback to be the main element
				click = props.click;
				props.click = function() {
					click.apply( that.element[0], arguments );
				};
				button = $( "<button></button>", props )
					.appendTo( that.uiButtonSet );
				if ( $.fn.button ) {
					button.button();
				}
			});
			this.uiDialog.addClass( "ui-dialog-buttons" );
			this.uiDialogButtonPane.appendTo( this.uiDialog );
		} else {
			this.uiDialog.removeClass( "ui-dialog-buttons" );
		}
	},

	_makeDraggable: function() {
		var that = this,
			options = this.options;

		function filteredUi( ui ) {
			return {
				position: ui.position,
				offset: ui.offset
			};
		}

		this.uiDialog.draggable({
			cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
			handle: ".ui-dialog-titlebar",
			containment: "document",
			start: function( event, ui ) {
				$( this )
					.addClass( "ui-dialog-dragging" );
				that._trigger( "dragStart", event, filteredUi( ui ) );
			},
			drag: function( event, ui ) {
				that._trigger( "drag", event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				options.position = [
					ui.position.left - that.document.scrollLeft(),
					ui.position.top - that.document.scrollTop()
				];
				$( this )
					.removeClass( "ui-dialog-dragging" );
				that._trigger( "dragStop", event, filteredUi( ui ) );
				$.ui.dialog.overlay.resize();
			}
		});
	},

	_makeResizable: function( handles ) {
		handles = (handles === undefined ? this.options.resizable : handles);
		var that = this,
			options = this.options,
			// .ui-resizable has position: relative defined in the stylesheet
			// but dialogs have to use absolute or fixed positioning
			position = this.uiDialog.css( "position" ),
			resizeHandles = typeof handles === 'string' ?
				handles	:
				"n,e,s,w,se,sw,ne,nw";

		function filteredUi( ui ) {
			return {
				originalPosition: ui.originalPosition,
				originalSize: ui.originalSize,
				position: ui.position,
				size: ui.size
			};
		}

		this.uiDialog.resizable({
			cancel: ".ui-dialog-content",
			containment: "document",
			alsoResize: this.element,
			maxWidth: options.maxWidth,
			maxHeight: options.maxHeight,
			minWidth: options.minWidth,
			minHeight: this._minHeight(),
			handles: resizeHandles,
			start: function( event, ui ) {
				$( this ).addClass( "ui-dialog-resizing" );
				that._trigger( "resizeStart", event, filteredUi( ui ) );
			},
			resize: function( event, ui ) {
				that._trigger( "resize", event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				$( this ).removeClass( "ui-dialog-resizing" );
				options.height = $( this ).height();
				options.width = $( this ).width();
				that._trigger( "resizeStop", event, filteredUi( ui ) );
				$.ui.dialog.overlay.resize();
			}
		})
		.css( "position", position )
		.find( ".ui-resizable-se" )
			.addClass( "ui-icon ui-icon-grip-diagonal-se" );
	},

	_minHeight: function() {
		var options = this.options;

		if ( options.height === "auto" ) {
			return options.minHeight;
		} else {
			return Math.min( options.minHeight, options.height );
		}
	},

	_position: function( position ) {
		var myAt = [],
			offset = [ 0, 0 ],
			isVisible;

		if ( position ) {
			// deep extending converts arrays to objects in jQuery <= 1.3.2 :-(
	//		if (typeof position == 'string' || $.isArray(position)) {
	//			myAt = $.isArray(position) ? position : position.split(' ');

			if ( typeof position === "string" || (typeof position === "object" && "0" in position ) ) {
				myAt = position.split ? position.split( " " ) : [ position[ 0 ], position[ 1 ] ];
				if ( myAt.length === 1 ) {
					myAt[ 1 ] = myAt[ 0 ];
				}

				$.each( [ "left", "top" ], function( i, offsetPosition ) {
					if ( +myAt[ i ] === myAt[ i ] ) {
						offset[ i ] = myAt[ i ];
						myAt[ i ] = offsetPosition;
					}
				});

				position = {
					my: myAt[0] + (offset[0] < 0 ? offset[0] : "+" + offset[0]) + " " +
						myAt[1] + (offset[1] < 0 ? offset[1] : "+" + offset[1]),
					at: myAt.join( " " )
				};
			}

			position = $.extend( {}, $.ui.dialog.prototype.options.position, position );
		} else {
			position = $.ui.dialog.prototype.options.position;
		}

		// need to show the dialog to get the actual offset in the position plugin
		isVisible = this.uiDialog.is( ":visible" );
		if ( !isVisible ) {
			this.uiDialog.show();
		}
		this.uiDialog.position( position );
		if ( !isVisible ) {
			this.uiDialog.hide();
		}
	},

	_setOptions: function( options ) {
		var that = this,
			resizableOptions = {},
			resize = false;

		$.each( options, function( key, value ) {
			that._setOption( key, value );

			if ( key in sizeRelatedOptions ) {
				resize = true;
			}
			if ( key in resizableRelatedOptions ) {
				resizableOptions[ key ] = value;
			}
		});

		if ( resize ) {
			this._size();
		}
		if ( this.uiDialog.is( ":data(resizable)" ) ) {
			this.uiDialog.resizable( "option", resizableOptions );
		}
	},

	_setOption: function( key, value ) {
		var isDraggable, isResizable,
			uiDialog = this.uiDialog;

		switch ( key ) {
			case "buttons":
				this._createButtons( value );
				break;
			case "closeText":
				// ensure that we always pass a string
				this.uiDialogTitlebarCloseText.text( "" + value );
				break;
			case "dialogClass":
				uiDialog
					.removeClass( this.options.dialogClass )
					.addClass( uiDialogClasses + value );
				break;
			case "disabled":
				if ( value ) {
					uiDialog.addClass( "ui-dialog-disabled" );
				} else {
					uiDialog.removeClass( "ui-dialog-disabled" );
				}
				break;
			case "draggable":
				isDraggable = uiDialog.is( ":data(draggable)" );
				if ( isDraggable && !value ) {
					uiDialog.draggable( "destroy" );
				}

				if ( !isDraggable && value ) {
					this._makeDraggable();
				}
				break;
			case "position":
				this._position( value );
				break;
			case "resizable":
				// currently resizable, becoming non-resizable
				isResizable = uiDialog.is( ":data(resizable)" );
				if ( isResizable && !value ) {
					uiDialog.resizable( "destroy" );
				}

				// currently resizable, changing handles
				if ( isResizable && typeof value === "string" ) {
					uiDialog.resizable( "option", "handles", value );
				}

				// currently non-resizable, becoming resizable
				if ( !isResizable && value !== false ) {
					this._makeResizable( value );
				}
				break;
			case "title":
				// convert whatever was passed in o a string, for html() to not throw up
				$( ".ui-dialog-title", this.uiDialogTitlebar )
					.html( "" + ( value || "&#160;" ) );
				break;
		}

		this._super( key, value );
	},

	_size: function() {
		/* If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
		 * divs will both have width and height set, so we need to reset them
		 */
		var nonContentHeight, minContentHeight, autoHeight,
			options = this.options,
			isVisible = this.uiDialog.is( ":visible" );

		// reset content sizing
		this.element.show().css({
			width: "auto",
			minHeight: 0,
			height: 0
		});

		if ( options.minWidth > options.width ) {
			options.width = options.minWidth;
		}

		// reset wrapper sizing
		// determine the height of all the non-content elements
		nonContentHeight = this.uiDialog.css({
				height: "auto",
				width: options.width
			})
			.outerHeight();
		minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );

		if ( options.height === "auto" ) {
			// only needed for IE6 support
			if ( $.support.minHeight ) {
				this.element.css({
					minHeight: minContentHeight,
					height: "auto"
				});
			} else {
				this.uiDialog.show();
				autoHeight = this.element.css( "height", "auto" ).height();
				if ( !isVisible ) {
					this.uiDialog.hide();
				}
				this.element.height( Math.max( autoHeight, minContentHeight ) );
			}
		} else {
			this.element.height( Math.max( options.height - nonContentHeight, 0 ) );
		}

		if (this.uiDialog.is( ":data(resizable)" ) ) {
			this.uiDialog.resizable( "option", "minHeight", this._minHeight() );
		}
	}
});

$.extend($.ui.dialog, {
	uuid: 0,
	maxZ: 0,

	getTitleId: function($el) {
		var id = $el.attr( "id" );
		if ( !id ) {
			this.uuid += 1;
			id = this.uuid;
		}
		return "ui-dialog-title-" + id;
	},

	overlay: function( dialog ) {
		this.$el = $.ui.dialog.overlay.create( dialog );
	}
});

$.extend( $.ui.dialog.overlay, {
	instances: [],
	// reuse old instances due to IE memory leak with alpha transparency (see #5185)
	oldInstances: [],
	maxZ: 0,
	events: $.map(
		"focus,mousedown,mouseup,keydown,keypress,click".split( "," ),
		function( event ) {
			return event + ".dialog-overlay";
		}
	).join( " " ),
	create: function( dialog ) {
		if ( this.instances.length === 0 ) {
			// prevent use of anchors and inputs
			// we use a setTimeout in case the overlay is created from an
			// event that we're going to be cancelling (see #2804)
			setTimeout(function() {
				// handle $(el).dialog().dialog('close') (see #4065)
				if ( $.ui.dialog.overlay.instances.length ) {
					$( document ).bind( $.ui.dialog.overlay.events, function( event ) {
						// stop events if the z-index of the target is < the z-index of the overlay
						// we cannot return true when we don't want to cancel the event (#3523)
						if ( $( event.target ).zIndex() < $.ui.dialog.overlay.maxZ ) {
							return false;
						}
					});
				}
			}, 1 );

			// handle window resize
			$( window ).bind( "resize.dialog-overlay", $.ui.dialog.overlay.resize );
		}

		var $el = ( this.oldInstances.pop() || $( "<div>" ).addClass( "ui-widget-overlay" ) );

		// allow closing by pressing the escape key
		$( document ).bind( "keydown.dialog-overlay", function( event ) {
			var instances = $.ui.dialog.overlay.instances;
			// only react to the event if we're the top overlay
			if ( instances.length !== 0 && instances[ instances.length - 1 ] === $el &&
				dialog.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
				event.keyCode === $.ui.keyCode.ESCAPE ) {

				dialog.close( event );
				event.preventDefault();
			}
		});

		$el.appendTo( document.body ).css({
			width: this.width(),
			height: this.height()
		});

		if ( $.fn.bgiframe ) {
			$el.bgiframe();
		}

		this.instances.push( $el );
		return $el;
	},

	destroy: function( $el ) {
		var indexOf = $.inArray( $el, this.instances ),
			maxZ = 0;

		if ( indexOf !== -1 ) {
			this.oldInstances.push( this.instances.splice( indexOf, 1 )[ 0 ] );
		}

		if ( this.instances.length === 0 ) {
			$( [ document, window ] ).unbind( ".dialog-overlay" );
		}

		$el.height( 0 ).width( 0 ).remove();

		// adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
		$.each( this.instances, function() {
			maxZ = Math.max( maxZ, this.css( "z-index" ) );
		});
		this.maxZ = maxZ;
	},

	height: function() {
		var scrollHeight,
			offsetHeight;
		// handle IE
		if ( $.ui.ie ) {
			scrollHeight = Math.max(
				document.documentElement.scrollHeight,
				document.body.scrollHeight
			);
			offsetHeight = Math.max(
				document.documentElement.offsetHeight,
				document.body.offsetHeight
			);

			if ( scrollHeight < offsetHeight ) {
				return $( window ).height() + "px";
			} else {
				return scrollHeight + "px";
			}
		// handle "good" browsers
		} else {
			return $( document ).height() + "px";
		}
	},

	width: function() {
		var scrollWidth,
			offsetWidth;
		// handle IE
		if ( $.ui.ie ) {
			scrollWidth = Math.max(
				document.documentElement.scrollWidth,
				document.body.scrollWidth
			);
			offsetWidth = Math.max(
				document.documentElement.offsetWidth,
				document.body.offsetWidth
			);

			if ( scrollWidth < offsetWidth ) {
				return $( window ).width() + "px";
			} else {
				return scrollWidth + "px";
			}
		// handle "good" browsers
		} else {
			return $( document ).width() + "px";
		}
	},

	resize: function() {
		/* If the dialog is draggable and the user drags it past the
		 * right edge of the window, the document becomes wider so we
		 * need to stretch the overlay. If the user then drags the
		 * dialog back to the left, the document will become narrower,
		 * so we need to shrink the overlay to the appropriate size.
		 * This is handled by shrinking the overlay before setting it
		 * to the full document size.
		 */
		var $overlays = $( [] );
		$.each( $.ui.dialog.overlay.instances, function() {
			$overlays = $overlays.add( this );
		});

		$overlays.css({
			width: 0,
			height: 0
		}).css({
			width: $.ui.dialog.overlay.width(),
			height: $.ui.dialog.overlay.height()
		});
	}
});

$.extend( $.ui.dialog.overlay.prototype, {
	destroy: function() {
		$.ui.dialog.overlay.destroy( this.$el );
	}
});

}( jQuery ) );
(function( $, undefined ) {

$.widget("ui.draggable", $.ui.mouse, {
	version: "1.9.2",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false
	},
	_create: function() {

		if (this.options.helper == 'original' && !(/^(?:r|a|f)/).test(this.element.css("position")))
			this.element[0].style.position = 'relative';

		(this.options.addClasses && this.element.addClass("ui-draggable"));
		(this.options.disabled && this.element.addClass("ui-draggable-disabled"));

		this._mouseInit();

	},

	_destroy: function() {
		this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {

		var o = this.options;

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).is('.ui-resizable-handle'))
			return false;

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle)
			return false;

		$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
			$('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>')
			.css({
				width: this.offsetWidth+"px", height: this.offsetHeight+"px",
				position: "absolute", opacity: "0.001", zIndex: 1000
			})
			.css($(this).offset())
			.appendTo("body");
		});

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass("ui-draggable-dragging");

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css("position");
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if 'cursorAt' is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		//Trigger event + callbacks
		if(this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);


		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) $.ui.ddmanager.dragStart(this, event);

		return true;
	},

	_mouseDrag: function(event, noPropagation) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger('drag', event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left+'px';
		if(!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top+'px';
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour)
			dropped = $.ui.ddmanager.drop(this, event);

		//if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		//if the original element is no longer in the DOM don't bother to continue (see #8269)
		var element = this.element[0], elementInDom = false;
		while ( element && (element = element.parentNode) ) {
			if (element == document ) {
				elementInDom = true;
			}
		}
		if ( !elementInDom && this.options.helper === "original" )
			return false;

		if((this.options.revert == "invalid" && !dropped) || (this.options.revert == "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			var that = this;
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(that._trigger("stop", event) !== false) {
					that._clear();
				}
			});
		} else {
			if(this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function(event) {
		//Remove frame helpers
		$("div.ui-draggable-iframeFix").each(function() {
			this.parentNode.removeChild(this);
		});

		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if( $.ui.ddmanager ) $.ui.ddmanager.dragStop(this, event);

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},

	cancel: function() {

		if(this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {

		var handle = !this.options.handle || !$(this.options.handle, this.element).length ? true : false;
		$(this.options.handle, this.element)
			.find("*")
			.andSelf()
			.each(function() {
				if(this == event.target) handle = true;
			});

		return handle;

	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper == 'clone' ? this.element.clone().removeAttr('id') : this.element);

		if(!helper.parents('body').length)
			helper.appendTo((o.appendTo == 'parent' ? this.element[0].parentNode : o.appendTo));

		if(helper[0] != this.element[0] && !(/(fixed|absolute)/).test(helper.css("position")))
			helper.css("position", "absolute");

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == 'string') {
			obj = obj.split(' ');
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ('left' in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ('right' in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ('top' in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ('bottom' in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.ui.ie)) //Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == "relative") {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"),10) || 0),
			top: (parseInt(this.element.css("marginTop"),10) || 0),
			right: (parseInt(this.element.css("marginRight"),10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == 'parent') o.containment = this.helper[0].parentNode;
		if(o.containment == 'document' || o.containment == 'window') this.containment = [
			o.containment == 'document' ? 0 : $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
			o.containment == 'document' ? 0 : $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
			(o.containment == 'document' ? 0 : $(window).scrollLeft()) + $(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
			(o.containment == 'document' ? 0 : $(window).scrollTop()) + ($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment) && o.containment.constructor != Array) {
			var c = $(o.containment);
			var ce = c[0]; if(!ce) return;
			var co = c.offset();
			var over = ($(ce).css("overflow") != 'hidden');

			this.containment = [
				(parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0),
				(parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0),
				(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,
				(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top  - this.margins.bottom
			];
			this.relative_container = c;

		} else if(o.containment.constructor == Array) {
			this.containment = o.containment;
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == "absolute" ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent's offset without borders (offset + border)
				- ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent's offset without borders (offset + border)
				- ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options
			var containment;
			if(this.containment) {
			if (this.relative_container){
				var co = this.relative_container.offset();
				containment = [ this.containment[0] + co.left,
					this.containment[1] + co.top,
					this.containment[2] + co.left,
					this.containment[3] + co.top ];
			}
			else {
				containment = this.containment;
			}

				if(event.pageX - this.offset.click.left < containment[0]) pageX = containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top < containment[1]) pageY = containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left > containment[2]) pageX = containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top > containment[3]) pageY = containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				var top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? (!(top - this.offset.click.top < containment[1] || top - this.offset.click.top > containment[3]) ? top : (!(top - this.offset.click.top < containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? (!(left - this.offset.click.left < containment[0] || left - this.offset.click.left > containment[2]) ? left : (!(left - this.offset.click.left < containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent's offset without borders (offset + border)
				+ ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent's offset without borders (offset + border)
				+ ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if(this.helper[0] != this.element[0] && !this.cancelHelperRemoval) this.helper.remove();
		//if($.ui.ddmanager) $.ui.ddmanager.current = null;
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		if(type == "drag") this.positionAbs = this._convertPositionTo("absolute"); //The absolute position has to be recalculated after plugins
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function(event) {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add("draggable", "connectToSortable", {
	start: function(event, ui) {

		var inst = $(this).data("draggable"), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, 'sortable');
			if (sortable && !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger("activate", event, uiSortable);
			}
		});

	},
	stop: function(event, ui) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data("draggable"),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: 'valid/invalid'
				if(this.shouldRevert) this.instance.options.revert = true;

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper == 'original')
					this.instance.currentItem.css({ top: 'auto', left: 'auto' });

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger("deactivate", event, uiSortable);
			}

		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("draggable"), that = this;

		var checkPos = function(o) {
			var dyClick = this.offset.click.top, dxClick = this.offset.click.left;
			var helperTop = this.positionAbs.top, helperLeft = this.positionAbs.left;
			var itemHeight = o.height, itemWidth = o.width;
			var itemTop = o.top, itemLeft = o.left;

			return $.ui.isOver(helperTop + dyClick, helperLeft + dxClick, itemTop, itemLeft, itemHeight, itemWidth);
		};

		$.each(inst.sortables, function(i) {

			var innermostIntersecting = false;
			var thisSortable = this;
			//Copy over some variables to allow calling the sortable's native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;

			if(this.instance._intersectsWith(this.instance.containerCache)) {
				innermostIntersecting = true;
				$.each(inst.sortables, function () {
					this.instance.positionAbs = inst.positionAbs;
					this.instance.helperProportions = inst.helperProportions;
					this.instance.offset.click = inst.offset.click;
					if  (this != thisSortable
						&& this.instance._intersectsWith(this.instance.containerCache)
						&& $.ui.contains(thisSortable.instance.element[0], this.instance.element[0]))
						innermostIntersecting = false;
						return innermostIntersecting;
				});
			}


			if(innermostIntersecting) {
				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
					this.instance.currentItem = $(that).clone().removeAttr('id').appendTo(this.instance.element).data("sortable-item", true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger("toSortable", event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) this.instance._mouseDrag(event);

			} else {

				//If it doesn't intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;

					//Prevent reverting on this forced stop
					this.instance.options.revert = false;

					// The out event needs to be triggered independently
					this.instance._trigger('out', event, this.instance._uiHash(this.instance));

					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) this.instance.placeholder.remove();

					inst._trigger("fromSortable", event);
					inst.dropped = false; //draggable revert needs that
				}

			};

		});

	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function(event, ui) {
		var t = $('body'), o = $(this).data('draggable').options;
		if (t.css("cursor")) o._cursor = t.css("cursor");
		t.css("cursor", o.cursor);
	},
	stop: function(event, ui) {
		var o = $(this).data('draggable').options;
		if (o._cursor) $('body').css("cursor", o._cursor);
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data('draggable').options;
		if(t.css("opacity")) o._opacity = t.css("opacity");
		t.css('opacity', o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data('draggable').options;
		if(o._opacity) $(ui.helper).css('opacity', o._opacity);
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function(event, ui) {
		var i = $(this).data("draggable");
		if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') i.overflowOffset = i.scrollParent.offset();
	},
	drag: function(event, ui) {

		var i = $(this).data("draggable"), o = i.options, scrolled = false;

		if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') {

			if(!o.axis || o.axis != 'x') {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
			}

			if(!o.axis || o.axis != 'y') {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
			}

		} else {

			if(!o.axis || o.axis != 'x') {
				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
			}

			if(!o.axis || o.axis != 'y') {
				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
			}

		}

		if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(i, event);

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function(event, ui) {

		var i = $(this).data("draggable"), o = i.options;
		i.snapElements = [];

		$(o.snap.constructor != String ? ( o.snap.items || ':data(draggable)' ) : o.snap).each(function() {
			var $t = $(this); var $o = $t.offset();
			if(this != i.element[0]) i.snapElements.push({
				item: this,
				width: $t.outerWidth(), height: $t.outerHeight(),
				top: $o.top, left: $o.left
			});
		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("draggable"), o = inst.options;
		var d = o.snapTolerance;

		var x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (var i = inst.snapElements.length - 1; i >= 0; i--){

			var l = inst.snapElements[i].left, r = l + inst.snapElements[i].width,
				t = inst.snapElements[i].top, b = t + inst.snapElements[i].height;

			//Yes, I know, this is insane ;)
			if(!((l-d < x1 && x1 < r+d && t-d < y1 && y1 < b+d) || (l-d < x1 && x1 < r+d && t-d < y2 && y2 < b+d) || (l-d < x2 && x2 < r+d && t-d < y1 && y1 < b+d) || (l-d < x2 && x2 < r+d && t-d < y2 && y2 < b+d))) {
				if(inst.snapElements[i].snapping) (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode != 'inner') {
				var ts = Math.abs(t - y2) <= d;
				var bs = Math.abs(b - y1) <= d;
				var ls = Math.abs(l - x2) <= d;
				var rs = Math.abs(r - x1) <= d;
				if(ts) ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
			}

			var first = (ts || bs || ls || rs);

			if(o.snapMode != 'outer') {
				var ts = Math.abs(t - y1) <= d;
				var bs = Math.abs(b - y2) <= d;
				var ls = Math.abs(l - x1) <= d;
				var rs = Math.abs(r - x2) <= d;
				if(ts) ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
			}

			if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first))
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		};

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function(event, ui) {

		var o = $(this).data("draggable").options;

		var group = $.makeArray($(o.stack)).sort(function(a,b) {
			return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
		});
		if (!group.length) { return; }

		var min = parseInt(group[0].style.zIndex) || 0;
		$(group).each(function(i) {
			this.style.zIndex = min + i;
		});

		this[0].style.zIndex = min + group.length;

	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("draggable").options;
		if(t.css("zIndex")) o._zIndex = t.css("zIndex");
		t.css('zIndex', o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data("draggable").options;
		if(o._zIndex) $(ui.helper).css('zIndex', o._zIndex);
	}
});

})(jQuery);
(function( $, undefined ) {

$.widget("ui.droppable", {
	version: "1.9.2",
	widgetEventPrefix: "drop",
	options: {
		accept: '*',
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: 'default',
		tolerance: 'intersect'
	},
	_create: function() {

		var o = this.options, accept = o.accept;
		this.isover = 0; this.isout = 1;

		this.accept = $.isFunction(accept) ? accept : function(d) {
			return d.is(accept);
		};

		//Store the droppable's proportions
		this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };

		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
		$.ui.ddmanager.droppables[o.scope].push(this);

		(o.addClasses && this.element.addClass("ui-droppable"));

	},

	_destroy: function() {
		var drop = $.ui.ddmanager.droppables[this.options.scope];
		for ( var i = 0; i < drop.length; i++ )
			if ( drop[i] == this )
				drop.splice(i, 1);

		this.element.removeClass("ui-droppable ui-droppable-disabled");
	},

	_setOption: function(key, value) {

		if(key == 'accept') {
			this.accept = $.isFunction(value) ? value : function(d) {
				return d.is(value);
			};
		}
		$.Widget.prototype._setOption.apply(this, arguments);
	},

	_activate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.addClass(this.options.activeClass);
		(draggable && this._trigger('activate', event, this.ui(draggable)));
	},

	_deactivate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
		(draggable && this._trigger('deactivate', event, this.ui(draggable)));
	},

	_over: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.addClass(this.options.hoverClass);
			this._trigger('over', event, this.ui(draggable));
		}

	},

	_out: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger('out', event, this.ui(draggable));
		}

	},

	_drop: function(event,custom) {

		var draggable = custom || $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return false; // Bail if draggable and droppable are same element

		var childrenIntersection = false;
		this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function() {
			var inst = $.data(this, 'droppable');
			if(
				inst.options.greedy
				&& !inst.options.disabled
				&& inst.options.scope == draggable.options.scope
				&& inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element))
				&& $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
			) { childrenIntersection = true; return false; }
		});
		if(childrenIntersection) return false;

		if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger('drop', event, this.ui(draggable));
			return this.element;
		}

		return false;

	},

	ui: function(c) {
		return {
			draggable: (c.currentItem || c.element),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.ui.intersect = function(draggable, droppable, toleranceMode) {

	if (!droppable.offset) return false;

	var x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,
		y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height;
	var l = droppable.offset.left, r = l + droppable.proportions.width,
		t = droppable.offset.top, b = t + droppable.proportions.height;

	switch (toleranceMode) {
		case 'fit':
			return (l <= x1 && x2 <= r
				&& t <= y1 && y2 <= b);
			break;
		case 'intersect':
			return (l < x1 + (draggable.helperProportions.width / 2) // Right Half
				&& x2 - (draggable.helperProportions.width / 2) < r // Left Half
				&& t < y1 + (draggable.helperProportions.height / 2) // Bottom Half
				&& y2 - (draggable.helperProportions.height / 2) < b ); // Top Half
			break;
		case 'pointer':
			var draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left),
				draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top),
				isOver = $.ui.isOver(draggableTop, draggableLeft, t, l, droppable.proportions.height, droppable.proportions.width);
			return isOver;
			break;
		case 'touch':
			return (
					(y1 >= t && y1 <= b) ||	// Top edge touching
					(y2 >= t && y2 <= b) ||	// Bottom edge touching
					(y1 < t && y2 > b)		// Surrounded vertically
				) && (
					(x1 >= l && x1 <= r) ||	// Left edge touching
					(x2 >= l && x2 <= r) ||	// Right edge touching
					(x1 < l && x2 > r)		// Surrounded horizontally
				);
			break;
		default:
			return false;
			break;
		}

};

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { 'default': [] },
	prepareOffsets: function(t, event) {

		var m = $.ui.ddmanager.droppables[t.options.scope] || [];
		var type = event ? event.type : null; // workaround for #2317
		var list = (t.currentItem || t.element).find(":data(droppable)").andSelf();

		droppablesLoop: for (var i = 0; i < m.length; i++) {

			if(m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) continue;	//No disabled and non-accepted
			for (var j=0; j < list.length; j++) { if(list[j] == m[i].element[0]) { m[i].proportions.height = 0; continue droppablesLoop; } }; //Filter out elements in the current dragged item
			m[i].visible = m[i].element.css("display") != "none"; if(!m[i].visible) continue; 									//If the element is not visible, continue

			if(type == "mousedown") m[i]._activate.call(m[i], event); //Activate the droppable if used directly from draggables

			m[i].offset = m[i].element.offset();
			m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };

		}

	},
	drop: function(draggable, event) {

		var dropped = false;
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(!this.options) return;
			if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance))
				dropped = this._drop.call(this, event) || dropped;

			if (!this.options.disabled && this.visible && this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				this.isout = 1; this.isover = 0;
				this._deactivate.call(this, event);
			}

		});
		return dropped;

	},
	dragStart: function( draggable, event ) {
		//Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
		draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {
			if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
		});
	},
	drag: function(draggable, event) {

		//If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if(draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable, event);

		//Run through all droppables and check their positions based on specific tolerance options
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(this.options.disabled || this.greedyChild || !this.visible) return;
			var intersects = $.ui.intersect(draggable, this, this.options.tolerance);

			var c = !intersects && this.isover == 1 ? 'isout' : (intersects && this.isover == 0 ? 'isover' : null);
			if(!c) return;

			var parentInstance;
			if (this.options.greedy) {
				// find droppable parents with same scope
				var scope = this.options.scope;
				var parent = this.element.parents(':data(droppable)').filter(function () {
					return $.data(this, 'droppable').options.scope === scope;
				});

				if (parent.length) {
					parentInstance = $.data(parent[0], 'droppable');
					parentInstance.greedyChild = (c == 'isover' ? 1 : 0);
				}
			}

			// we just moved into a greedy child
			if (parentInstance && c == 'isover') {
				parentInstance['isover'] = 0;
				parentInstance['isout'] = 1;
				parentInstance._out.call(parentInstance, event);
			}

			this[c] = 1; this[c == 'isout' ? 'isover' : 'isout'] = 0;
			this[c == "isover" ? "_over" : "_out"].call(this, event);

			// we just moved out of a greedy child
			if (parentInstance && c == 'isout') {
				parentInstance['isout'] = 0;
				parentInstance['isover'] = 1;
				parentInstance._over.call(parentInstance, event);
			}
		});

	},
	dragStop: function( draggable, event ) {
		draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );
		//Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
		if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
	}
};

})(jQuery);
;(jQuery.effects || (function($, undefined) {

var backCompat = $.uiBackCompat !== false,
	// prefix used for storing data on .data()
	dataSpace = "ui-effects-";

$.effects = {
	effect: {}
};

/*!
 * jQuery Color Animations v2.0.0
 * http://jquery.com/
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Mon Aug 13 13:41:02 2012 -0500
 */
(function( jQuery, undefined ) {

	var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor".split(" "),

	// plusequals test for += 100 -= 100
	rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
	// a set of RE's that can match strings and generate color tuples.
	stringParsers = [{
			re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ],
					execResult[ 3 ],
					execResult[ 4 ]
				];
			}
		}, {
			re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ] * 2.55,
					execResult[ 2 ] * 2.55,
					execResult[ 3 ] * 2.55,
					execResult[ 4 ]
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ], 16 )
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
				];
			}
		}, {
			re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
			space: "hsla",
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ] / 100,
					execResult[ 3 ] / 100,
					execResult[ 4 ]
				];
			}
		}],

	// jQuery.Color( )
	color = jQuery.Color = function( color, green, blue, alpha ) {
		return new jQuery.Color.fn.parse( color, green, blue, alpha );
	},
	spaces = {
		rgba: {
			props: {
				red: {
					idx: 0,
					type: "byte"
				},
				green: {
					idx: 1,
					type: "byte"
				},
				blue: {
					idx: 2,
					type: "byte"
				}
			}
		},

		hsla: {
			props: {
				hue: {
					idx: 0,
					type: "degrees"
				},
				saturation: {
					idx: 1,
					type: "percent"
				},
				lightness: {
					idx: 2,
					type: "percent"
				}
			}
		}
	},
	propTypes = {
		"byte": {
			floor: true,
			max: 255
		},
		"percent": {
			max: 1
		},
		"degrees": {
			mod: 360,
			floor: true
		}
	},
	support = color.support = {},

	// element for support tests
	supportElem = jQuery( "<p>" )[ 0 ],

	// colors = jQuery.Color.names
	colors,

	// local aliases of functions called often
	each = jQuery.each;

// determine rgba support immediately
supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;

// define cache name and alpha properties
// for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
	space.cache = "_" + spaceName;
	space.props.alpha = {
		idx: 3,
		type: "percent",
		def: 1
	};
});

function clamp( value, prop, allowEmpty ) {
	var type = propTypes[ prop.type ] || {};

	if ( value == null ) {
		return (allowEmpty || !prop.def) ? null : prop.def;
	}

	// ~~ is an short way of doing floor for positive numbers
	value = type.floor ? ~~value : parseFloat( value );

	// IE will pass in empty strings as value for alpha,
	// which will hit this case
	if ( isNaN( value ) ) {
		return prop.def;
	}

	if ( type.mod ) {
		// we add mod before modding to make sure that negatives values
		// get converted properly: -10 -> 350
		return (value + type.mod) % type.mod;
	}

	// for now all property types without mod have min and max
	return 0 > value ? 0 : type.max < value ? type.max : value;
}

function stringParse( string ) {
	var inst = color(),
		rgba = inst._rgba = [];

	string = string.toLowerCase();

	each( stringParsers, function( i, parser ) {
		var parsed,
			match = parser.re.exec( string ),
			values = match && parser.parse( match ),
			spaceName = parser.space || "rgba";

		if ( values ) {
			parsed = inst[ spaceName ]( values );

			// if this was an rgba parse the assignment might happen twice
			// oh well....
			inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
			rgba = inst._rgba = parsed._rgba;

			// exit each( stringParsers ) here because we matched
			return false;
		}
	});

	// Found a stringParser that handled it
	if ( rgba.length ) {

		// if this came from a parsed string, force "transparent" when alpha is 0
		// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
		if ( rgba.join() === "0,0,0,0" ) {
			jQuery.extend( rgba, colors.transparent );
		}
		return inst;
	}

	// named colors
	return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
	parse: function( red, green, blue, alpha ) {
		if ( red === undefined ) {
			this._rgba = [ null, null, null, null ];
			return this;
		}
		if ( red.jquery || red.nodeType ) {
			red = jQuery( red ).css( green );
			green = undefined;
		}

		var inst = this,
			type = jQuery.type( red ),
			rgba = this._rgba = [];

		// more than 1 argument specified - assume ( red, green, blue, alpha )
		if ( green !== undefined ) {
			red = [ red, green, blue, alpha ];
			type = "array";
		}

		if ( type === "string" ) {
			return this.parse( stringParse( red ) || colors._default );
		}

		if ( type === "array" ) {
			each( spaces.rgba.props, function( key, prop ) {
				rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
			});
			return this;
		}

		if ( type === "object" ) {
			if ( red instanceof color ) {
				each( spaces, function( spaceName, space ) {
					if ( red[ space.cache ] ) {
						inst[ space.cache ] = red[ space.cache ].slice();
					}
				});
			} else {
				each( spaces, function( spaceName, space ) {
					var cache = space.cache;
					each( space.props, function( key, prop ) {

						// if the cache doesn't exist, and we know how to convert
						if ( !inst[ cache ] && space.to ) {

							// if the value was null, we don't need to copy it
							// if the key was alpha, we don't need to copy it either
							if ( key === "alpha" || red[ key ] == null ) {
								return;
							}
							inst[ cache ] = space.to( inst._rgba );
						}

						// this is the only case where we allow nulls for ALL properties.
						// call clamp with alwaysAllowEmpty
						inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
					});

					// everything defined but alpha?
					if ( inst[ cache ] && $.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
						// use the default of 1
						inst[ cache ][ 3 ] = 1;
						if ( space.from ) {
							inst._rgba = space.from( inst[ cache ] );
						}
					}
				});
			}
			return this;
		}
	},
	is: function( compare ) {
		var is = color( compare ),
			same = true,
			inst = this;

		each( spaces, function( _, space ) {
			var localCache,
				isCache = is[ space.cache ];
			if (isCache) {
				localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
				each( space.props, function( _, prop ) {
					if ( isCache[ prop.idx ] != null ) {
						same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
						return same;
					}
				});
			}
			return same;
		});
		return same;
	},
	_space: function() {
		var used = [],
			inst = this;
		each( spaces, function( spaceName, space ) {
			if ( inst[ space.cache ] ) {
				used.push( spaceName );
			}
		});
		return used.pop();
	},
	transition: function( other, distance ) {
		var end = color( other ),
			spaceName = end._space(),
			space = spaces[ spaceName ],
			startColor = this.alpha() === 0 ? color( "transparent" ) : this,
			start = startColor[ space.cache ] || space.to( startColor._rgba ),
			result = start.slice();

		end = end[ space.cache ];
		each( space.props, function( key, prop ) {
			var index = prop.idx,
				startValue = start[ index ],
				endValue = end[ index ],
				type = propTypes[ prop.type ] || {};

			// if null, don't override start value
			if ( endValue === null ) {
				return;
			}
			// if null - use end
			if ( startValue === null ) {
				result[ index ] = endValue;
			} else {
				if ( type.mod ) {
					if ( endValue - startValue > type.mod / 2 ) {
						startValue += type.mod;
					} else if ( startValue - endValue > type.mod / 2 ) {
						startValue -= type.mod;
					}
				}
				result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
			}
		});
		return this[ spaceName ]( result );
	},
	blend: function( opaque ) {
		// if we are already opaque - return ourself
		if ( this._rgba[ 3 ] === 1 ) {
			return this;
		}

		var rgb = this._rgba.slice(),
			a = rgb.pop(),
			blend = color( opaque )._rgba;

		return color( jQuery.map( rgb, function( v, i ) {
			return ( 1 - a ) * blend[ i ] + a * v;
		}));
	},
	toRgbaString: function() {
		var prefix = "rgba(",
			rgba = jQuery.map( this._rgba, function( v, i ) {
				return v == null ? ( i > 2 ? 1 : 0 ) : v;
			});

		if ( rgba[ 3 ] === 1 ) {
			rgba.pop();
			prefix = "rgb(";
		}

		return prefix + rgba.join() + ")";
	},
	toHslaString: function() {
		var prefix = "hsla(",
			hsla = jQuery.map( this.hsla(), function( v, i ) {
				if ( v == null ) {
					v = i > 2 ? 1 : 0;
				}

				// catch 1 and 2
				if ( i && i < 3 ) {
					v = Math.round( v * 100 ) + "%";
				}
				return v;
			});

		if ( hsla[ 3 ] === 1 ) {
			hsla.pop();
			prefix = "hsl(";
		}
		return prefix + hsla.join() + ")";
	},
	toHexString: function( includeAlpha ) {
		var rgba = this._rgba.slice(),
			alpha = rgba.pop();

		if ( includeAlpha ) {
			rgba.push( ~~( alpha * 255 ) );
		}

		return "#" + jQuery.map( rgba, function( v ) {

			// default to 0 when nulls exist
			v = ( v || 0 ).toString( 16 );
			return v.length === 1 ? "0" + v : v;
		}).join("");
	},
	toString: function() {
		return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
	}
});
color.fn.parse.prototype = color.fn;

// hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
	h = ( h + 1 ) % 1;
	if ( h * 6 < 1 ) {
		return p + (q - p) * h * 6;
	}
	if ( h * 2 < 1) {
		return q;
	}
	if ( h * 3 < 2 ) {
		return p + (q - p) * ((2/3) - h) * 6;
	}
	return p;
}

spaces.hsla.to = function ( rgba ) {
	if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
		return [ null, null, null, rgba[ 3 ] ];
	}
	var r = rgba[ 0 ] / 255,
		g = rgba[ 1 ] / 255,
		b = rgba[ 2 ] / 255,
		a = rgba[ 3 ],
		max = Math.max( r, g, b ),
		min = Math.min( r, g, b ),
		diff = max - min,
		add = max + min,
		l = add * 0.5,
		h, s;

	if ( min === max ) {
		h = 0;
	} else if ( r === max ) {
		h = ( 60 * ( g - b ) / diff ) + 360;
	} else if ( g === max ) {
		h = ( 60 * ( b - r ) / diff ) + 120;
	} else {
		h = ( 60 * ( r - g ) / diff ) + 240;
	}

	if ( l === 0 || l === 1 ) {
		s = l;
	} else if ( l <= 0.5 ) {
		s = diff / add;
	} else {
		s = diff / ( 2 - add );
	}
	return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function ( hsla ) {
	if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
		return [ null, null, null, hsla[ 3 ] ];
	}
	var h = hsla[ 0 ] / 360,
		s = hsla[ 1 ],
		l = hsla[ 2 ],
		a = hsla[ 3 ],
		q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
		p = 2 * l - q;

	return [
		Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
		Math.round( hue2rgb( p, q, h ) * 255 ),
		Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
		a
	];
};


each( spaces, function( spaceName, space ) {
	var props = space.props,
		cache = space.cache,
		to = space.to,
		from = space.from;

	// makes rgba() and hsla()
	color.fn[ spaceName ] = function( value ) {

		// generate a cache for this space if it doesn't exist
		if ( to && !this[ cache ] ) {
			this[ cache ] = to( this._rgba );
		}
		if ( value === undefined ) {
			return this[ cache ].slice();
		}

		var ret,
			type = jQuery.type( value ),
			arr = ( type === "array" || type === "object" ) ? value : arguments,
			local = this[ cache ].slice();

		each( props, function( key, prop ) {
			var val = arr[ type === "object" ? key : prop.idx ];
			if ( val == null ) {
				val = local[ prop.idx ];
			}
			local[ prop.idx ] = clamp( val, prop );
		});

		if ( from ) {
			ret = color( from( local ) );
			ret[ cache ] = local;
			return ret;
		} else {
			return color( local );
		}
	};

	// makes red() green() blue() alpha() hue() saturation() lightness()
	each( props, function( key, prop ) {
		// alpha is included in more than one space
		if ( color.fn[ key ] ) {
			return;
		}
		color.fn[ key ] = function( value ) {
			var vtype = jQuery.type( value ),
				fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
				local = this[ fn ](),
				cur = local[ prop.idx ],
				match;

			if ( vtype === "undefined" ) {
				return cur;
			}

			if ( vtype === "function" ) {
				value = value.call( this, cur );
				vtype = jQuery.type( value );
			}
			if ( value == null && prop.empty ) {
				return this;
			}
			if ( vtype === "string" ) {
				match = rplusequals.exec( value );
				if ( match ) {
					value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
				}
			}
			local[ prop.idx ] = value;
			return this[ fn ]( local );
		};
	});
});

// add .fx.step functions
each( stepHooks, function( i, hook ) {
	jQuery.cssHooks[ hook ] = {
		set: function( elem, value ) {
			var parsed, curElem,
				backgroundColor = "";

			if ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) {
				value = color( parsed || value );
				if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
					curElem = hook === "backgroundColor" ? elem.parentNode : elem;
					while (
						(backgroundColor === "" || backgroundColor === "transparent") &&
						curElem && curElem.style
					) {
						try {
							backgroundColor = jQuery.css( curElem, "backgroundColor" );
							curElem = curElem.parentNode;
						} catch ( e ) {
						}
					}

					value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
						backgroundColor :
						"_default" );
				}

				value = value.toRgbaString();
			}
			try {
				elem.style[ hook ] = value;
			} catch( error ) {
				// wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
			}
		}
	};
	jQuery.fx.step[ hook ] = function( fx ) {
		if ( !fx.colorInit ) {
			fx.start = color( fx.elem, hook );
			fx.end = color( fx.end );
			fx.colorInit = true;
		}
		jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
	};
});

jQuery.cssHooks.borderColor = {
	expand: function( value ) {
		var expanded = {};

		each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
			expanded[ "border" + part + "Color" ] = value;
		});
		return expanded;
	}
};

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
colors = jQuery.Color.names = {
	// 4.1. Basic color keywords
	aqua: "#00ffff",
	black: "#000000",
	blue: "#0000ff",
	fuchsia: "#ff00ff",
	gray: "#808080",
	green: "#008000",
	lime: "#00ff00",
	maroon: "#800000",
	navy: "#000080",
	olive: "#808000",
	purple: "#800080",
	red: "#ff0000",
	silver: "#c0c0c0",
	teal: "#008080",
	white: "#ffffff",
	yellow: "#ffff00",

	// 4.2.3. "transparent" color keyword
	transparent: [ null, null, null, 0 ],

	_default: "#ffffff"
};

})( jQuery );



/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/
(function() {

var classAnimationActions = [ "add", "remove", "toggle" ],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

$.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) {
	$.fx.step[ prop ] = function( fx ) {
		if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
			jQuery.style( fx.elem, prop, fx.end );
			fx.setAttr = true;
		}
	};
});

function getElementStyles() {
	var style = this.ownerDocument.defaultView ?
			this.ownerDocument.defaultView.getComputedStyle( this, null ) :
			this.currentStyle,
		newStyle = {},
		key,
		len;

	// webkit enumerates style porperties
	if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
		len = style.length;
		while ( len-- ) {
			key = style[ len ];
			if ( typeof style[ key ] === "string" ) {
				newStyle[ $.camelCase( key ) ] = style[ key ];
			}
		}
	} else {
		for ( key in style ) {
			if ( typeof style[ key ] === "string" ) {
				newStyle[ key ] = style[ key ];
			}
		}
	}

	return newStyle;
}


function styleDifference( oldStyle, newStyle ) {
	var diff = {},
		name, value;

	for ( name in newStyle ) {
		value = newStyle[ name ];
		if ( oldStyle[ name ] !== value ) {
			if ( !shorthandStyles[ name ] ) {
				if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
					diff[ name ] = value;
				}
			}
		}
	}

	return diff;
}

$.effects.animateClass = function( value, duration, easing, callback ) {
	var o = $.speed( duration, easing, callback );

	return this.queue( function() {
		var animated = $( this ),
			baseClass = animated.attr( "class" ) || "",
			applyClassChange,
			allAnimations = o.children ? animated.find( "*" ).andSelf() : animated;

		// map the animated objects to store the original styles.
		allAnimations = allAnimations.map(function() {
			var el = $( this );
			return {
				el: el,
				start: getElementStyles.call( this )
			};
		});

		// apply class change
		applyClassChange = function() {
			$.each( classAnimationActions, function(i, action) {
				if ( value[ action ] ) {
					animated[ action + "Class" ]( value[ action ] );
				}
			});
		};
		applyClassChange();

		// map all animated objects again - calculate new styles and diff
		allAnimations = allAnimations.map(function() {
			this.end = getElementStyles.call( this.el[ 0 ] );
			this.diff = styleDifference( this.start, this.end );
			return this;
		});

		// apply original class
		animated.attr( "class", baseClass );

		// map all animated objects again - this time collecting a promise
		allAnimations = allAnimations.map(function() {
			var styleInfo = this,
				dfd = $.Deferred(),
				opts = jQuery.extend({}, o, {
					queue: false,
					complete: function() {
						dfd.resolve( styleInfo );
					}
				});

			this.el.animate( this.diff, opts );
			return dfd.promise();
		});

		// once all animations have completed:
		$.when.apply( $, allAnimations.get() ).done(function() {

			// set the final class
			applyClassChange();

			// for each animated element,
			// clear all css properties that were animated
			$.each( arguments, function() {
				var el = this.el;
				$.each( this.diff, function(key) {
					el.css( key, '' );
				});
			});

			// this is guarnteed to be there if you use jQuery.speed()
			// it also handles dequeuing the next anim...
			o.complete.call( animated[ 0 ] );
		});
	});
};

$.fn.extend({
	_addClass: $.fn.addClass,
	addClass: function( classNames, speed, easing, callback ) {
		return speed ?
			$.effects.animateClass.call( this,
				{ add: classNames }, speed, easing, callback ) :
			this._addClass( classNames );
	},

	_removeClass: $.fn.removeClass,
	removeClass: function( classNames, speed, easing, callback ) {
		return speed ?
			$.effects.animateClass.call( this,
				{ remove: classNames }, speed, easing, callback ) :
			this._removeClass( classNames );
	},

	_toggleClass: $.fn.toggleClass,
	toggleClass: function( classNames, force, speed, easing, callback ) {
		if ( typeof force === "boolean" || force === undefined ) {
			if ( !speed ) {
				// without speed parameter
				return this._toggleClass( classNames, force );
			} else {
				return $.effects.animateClass.call( this,
					(force ? { add: classNames } : { remove: classNames }),
					speed, easing, callback );
			}
		} else {
			// without force parameter
			return $.effects.animateClass.call( this,
				{ toggle: classNames }, force, speed, easing );
		}
	},

	switchClass: function( remove, add, speed, easing, callback) {
		return $.effects.animateClass.call( this, {
			add: add,
			remove: remove
		}, speed, easing, callback );
	}
});

})();

/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

(function() {

$.extend( $.effects, {
	version: "1.9.2",

	// Saves a set of properties in a data storage
	save: function( element, set ) {
		for( var i=0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
			}
		}
	},

	// Restores a set of previously saved properties from a data storage
	restore: function( element, set ) {
		var val, i;
		for( i=0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				val = element.data( dataSpace + set[ i ] );
				// support: jQuery 1.6.2
				// http://bugs.jquery.com/ticket/9917
				// jQuery 1.6.2 incorrectly returns undefined for any falsy value.
				// We can't differentiate between "" and 0 here, so we just assume
				// empty string since it's likely to be a more common value...
				if ( val === undefined ) {
					val = "";
				}
				element.css( set[ i ], val );
			}
		}
	},

	setMode: function( el, mode ) {
		if (mode === "toggle") {
			mode = el.is( ":hidden" ) ? "show" : "hide";
		}
		return mode;
	},

	// Translates a [top,left] array into a baseline value
	// this should be a little more flexible in the future to handle a string & hash
	getBaseline: function( origin, original ) {
		var y, x;
		switch ( origin[ 0 ] ) {
			case "top": y = 0; break;
			case "middle": y = 0.5; break;
			case "bottom": y = 1; break;
			default: y = origin[ 0 ] / original.height;
		}
		switch ( origin[ 1 ] ) {
			case "left": x = 0; break;
			case "center": x = 0.5; break;
			case "right": x = 1; break;
			default: x = origin[ 1 ] / original.width;
		}
		return {
			x: x,
			y: y
		};
	},

	// Wraps the element around a wrapper that copies position properties
	createWrapper: function( element ) {

		// if the element is already wrapped, return it
		if ( element.parent().is( ".ui-effects-wrapper" )) {
			return element.parent();
		}

		// wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				"float": element.css( "float" )
			},
			wrapper = $( "<div></div>" )
				.addClass( "ui-effects-wrapper" )
				.css({
					fontSize: "100%",
					background: "transparent",
					border: "none",
					margin: 0,
					padding: 0
				}),
			// Store the size in case width/height are defined in % - Fixes #5245
			size = {
				width: element.width(),
				height: element.height()
			},
			active = document.activeElement;

		// support: Firefox
		// Firefox incorrectly exposes anonymous content
		// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
		try {
			active.id;
		} catch( e ) {
			active = document.body;
		}

		element.wrap( wrapper );

		// Fixes #7595 - Elements lose focus when wrapped.
		if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
			$( active ).focus();
		}

		wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

		// transfer positioning properties to the wrapper
		if ( element.css( "position" ) === "static" ) {
			wrapper.css({ position: "relative" });
			element.css({ position: "relative" });
		} else {
			$.extend( props, {
				position: element.css( "position" ),
				zIndex: element.css( "z-index" )
			});
			$.each([ "top", "left", "bottom", "right" ], function(i, pos) {
				props[ pos ] = element.css( pos );
				if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
					props[ pos ] = "auto";
				}
			});
			element.css({
				position: "relative",
				top: 0,
				left: 0,
				right: "auto",
				bottom: "auto"
			});
		}
		element.css(size);

		return wrapper.css( props ).show();
	},

	removeWrapper: function( element ) {
		var active = document.activeElement;

		if ( element.parent().is( ".ui-effects-wrapper" ) ) {
			element.parent().replaceWith( element );

			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
		}


		return element;
	},

	setTransition: function( element, list, factor, value ) {
		value = value || {};
		$.each( list, function( i, x ) {
			var unit = element.cssUnit( x );
			if ( unit[ 0 ] > 0 ) {
				value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
			}
		});
		return value;
	}
});

// return an effect options object for the given parameters:
function _normalizeArguments( effect, options, speed, callback ) {

	// allow passing all options as the first parameter
	if ( $.isPlainObject( effect ) ) {
		options = effect;
		effect = effect.effect;
	}

	// convert to an object
	effect = { effect: effect };

	// catch (effect, null, ...)
	if ( options == null ) {
		options = {};
	}

	// catch (effect, callback)
	if ( $.isFunction( options ) ) {
		callback = options;
		speed = null;
		options = {};
	}

	// catch (effect, speed, ?)
	if ( typeof options === "number" || $.fx.speeds[ options ] ) {
		callback = speed;
		speed = options;
		options = {};
	}

	// catch (effect, options, callback)
	if ( $.isFunction( speed ) ) {
		callback = speed;
		speed = null;
	}

	// add options to effect
	if ( options ) {
		$.extend( effect, options );
	}

	speed = speed || options.duration;
	effect.duration = $.fx.off ? 0 :
		typeof speed === "number" ? speed :
		speed in $.fx.speeds ? $.fx.speeds[ speed ] :
		$.fx.speeds._default;

	effect.complete = callback || options.complete;

	return effect;
}

function standardSpeed( speed ) {
	// valid standard speeds
	if ( !speed || typeof speed === "number" || $.fx.speeds[ speed ] ) {
		return true;
	}

	// invalid strings - treat as "normal" speed
	if ( typeof speed === "string" && !$.effects.effect[ speed ] ) {
		// TODO: remove in 2.0 (#7115)
		if ( backCompat && $.effects[ speed ] ) {
			return false;
		}
		return true;
	}

	return false;
}

$.fn.extend({
	effect: function( /* effect, options, speed, callback */ ) {
		var args = _normalizeArguments.apply( this, arguments ),
			mode = args.mode,
			queue = args.queue,
			effectMethod = $.effects.effect[ args.effect ],

			// DEPRECATED: remove in 2.0 (#7115)
			oldEffectMethod = !effectMethod && backCompat && $.effects[ args.effect ];

		if ( $.fx.off || !( effectMethod || oldEffectMethod ) ) {
			// delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args.duration, args.complete );
			} else {
				return this.each( function() {
					if ( args.complete ) {
						args.complete.call( this );
					}
				});
			}
		}

		function run( next ) {
			var elem = $( this ),
				complete = args.complete,
				mode = args.mode;

			function done() {
				if ( $.isFunction( complete ) ) {
					complete.call( elem[0] );
				}
				if ( $.isFunction( next ) ) {
					next();
				}
			}

			// if the element is hiddden and mode is hide,
			// or element is visible and mode is show
			if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
				done();
			} else {
				effectMethod.call( elem[0], args, done );
			}
		}

		// TODO: remove this check in 2.0, effectMethod will always be true
		if ( effectMethod ) {
			return queue === false ? this.each( run ) : this.queue( queue || "fx", run );
		} else {
			// DEPRECATED: remove in 2.0 (#7115)
			return oldEffectMethod.call(this, {
				options: args,
				duration: args.duration,
				callback: args.complete,
				mode: args.mode
			});
		}
	},

	_show: $.fn.show,
	show: function( speed ) {
		if ( standardSpeed( speed ) ) {
			return this._show.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = "show";
			return this.effect.call( this, args );
		}
	},

	_hide: $.fn.hide,
	hide: function( speed ) {
		if ( standardSpeed( speed ) ) {
			return this._hide.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = "hide";
			return this.effect.call( this, args );
		}
	},

	// jQuery core overloads toggle and creates _toggle
	__toggle: $.fn.toggle,
	toggle: function( speed ) {
		if ( standardSpeed( speed ) || typeof speed === "boolean" || $.isFunction( speed ) ) {
			return this.__toggle.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = "toggle";
			return this.effect.call( this, args );
		}
	},

	// helper functions
	cssUnit: function(key) {
		var style = this.css( key ),
			val = [];

		$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
			if ( style.indexOf( unit ) > 0 ) {
				val = [ parseFloat( style ), unit ];
			}
		});
		return val;
	}
});

})();

/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

(function() {

// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

var baseEasings = {};

$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
	baseEasings[ name ] = function( p ) {
		return Math.pow( p, i + 2 );
	};
});

$.extend( baseEasings, {
	Sine: function ( p ) {
		return 1 - Math.cos( p * Math.PI / 2 );
	},
	Circ: function ( p ) {
		return 1 - Math.sqrt( 1 - p * p );
	},
	Elastic: function( p ) {
		return p === 0 || p === 1 ? p :
			-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
	},
	Back: function( p ) {
		return p * p * ( 3 * p - 2 );
	},
	Bounce: function ( p ) {
		var pow2,
			bounce = 4;

		while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
		return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
	}
});

$.each( baseEasings, function( name, easeIn ) {
	$.easing[ "easeIn" + name ] = easeIn;
	$.easing[ "easeOut" + name ] = function( p ) {
		return 1 - easeIn( 1 - p );
	};
	$.easing[ "easeInOut" + name ] = function( p ) {
		return p < 0.5 ?
			easeIn( p * 2 ) / 2 :
			1 - easeIn( p * -2 + 2 ) / 2;
	};
});

})();

})(jQuery));
(function( $, undefined ) {

var rvertical = /up|down|vertical/,
	rpositivemotion = /up|left|vertical|horizontal/;

$.effects.effect.blind = function( o, done ) {
	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		direction = o.direction || "up",
		vertical = rvertical.test( direction ),
		ref = vertical ? "height" : "width",
		ref2 = vertical ? "top" : "left",
		motion = rpositivemotion.test( direction ),
		animation = {},
		show = mode === "show",
		wrapper, distance, margin;

	// if already wrapped, the wrapper's properties are my property. #6245
	if ( el.parent().is( ".ui-effects-wrapper" ) ) {
		$.effects.save( el.parent(), props );
	} else {
		$.effects.save( el, props );
	}
	el.show();
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	distance = wrapper[ ref ]();
	margin = parseFloat( wrapper.css( ref2 ) ) || 0;

	animation[ ref ] = show ? distance : 0;
	if ( !motion ) {
		el
			.css( vertical ? "bottom" : "right", 0 )
			.css( vertical ? "top" : "left", "auto" )
			.css({ position: "absolute" });

		animation[ ref2 ] = show ? margin : distance + margin;
	}

	// start at 0 if we are showing
	if ( show ) {
		wrapper.css( ref, 0 );
		if ( ! motion ) {
			wrapper.css( ref2, margin + distance );
		}
	}

	// Animate
	wrapper.animate( animation, {
		duration: o.duration,
		easing: o.easing,
		queue: false,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.bounce = function( o, done ) {
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],

		// defaults:
		mode = $.effects.setMode( el, o.mode || "effect" ),
		hide = mode === "hide",
		show = mode === "show",
		direction = o.direction || "up",
		distance = o.distance,
		times = o.times || 5,

		// number of internal animations
		anims = times * 2 + ( show || hide ? 1 : 0 ),
		speed = o.duration / anims,
		easing = o.easing,

		// utility:
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ),
		i,
		upAnim,
		downAnim,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	// Avoid touching opacity to prevent clearType and PNG issues in IE
	if ( show || hide ) {
		props.push( "opacity" );
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el ); // Create Wrapper

	// default distance for the BIGGEST bounce is the outer Distance / 3
	if ( !distance ) {
		distance = el[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
	}

	if ( show ) {
		downAnim = { opacity: 1 };
		downAnim[ ref ] = 0;

		// if we are showing, force opacity 0 and set the initial position
		// then do the "first" animation
		el.css( "opacity", 0 )
			.css( ref, motion ? -distance * 2 : distance * 2 )
			.animate( downAnim, speed, easing );
	}

	// start at the smallest distance if we are hiding
	if ( hide ) {
		distance = distance / Math.pow( 2, times - 1 );
	}

	downAnim = {};
	downAnim[ ref ] = 0;
	// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
	for ( i = 0; i < times; i++ ) {
		upAnim = {};
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		el.animate( upAnim, speed, easing )
			.animate( downAnim, speed, easing );

		distance = hide ? distance * 2 : distance / 2;
	}

	// Last Bounce when Hiding
	if ( hide ) {
		upAnim = { opacity: 0 };
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		el.animate( upAnim, speed, easing );
	}

	el.queue(function() {
		if ( hide ) {
			el.hide();
		}
		$.effects.restore( el, props );
		$.effects.removeWrapper( el );
		done();
	});

	// inject all the animations we just queued to be first in line (after "inprogress")
	if ( queuelen > 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.clip = function( o, done ) {
	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		direction = o.direction || "vertical",
		vert = direction === "vertical",
		size = vert ? "height" : "width",
		position = vert ? "top" : "left",
		animation = {},
		wrapper, animate, distance;

	// Save & Show
	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});
	animate = ( el[0].tagName === "IMG" ) ? wrapper : el;
	distance = animate[ size ]();

	// Shift
	if ( show ) {
		animate.css( size, 0 );
		animate.css( position, distance / 2 );
	}

	// Create Animation Object:
	animation[ size ] = show ? distance : 0;
	animation[ position ] = show ? 0 : distance / 2;

	// Animate
	animate.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( !show ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.drop = function( o, done ) {

	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ) ? "pos" : "neg",
		animation = {
			opacity: show ? 1 : 0
		},
		distance;

	// Adjust
	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	distance = o.distance || el[ ref === "top" ? "outerHeight": "outerWidth" ]( true ) / 2;

	if ( show ) {
		el
			.css( "opacity", 0 )
			.css( ref, motion === "pos" ? -distance : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( motion === "pos" ? "+=" : "-=" ) :
		( motion === "pos" ? "-=" : "+=" ) ) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.explode = function( o, done ) {

	var rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,
		cells = rows,
		el = $( this ),
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",

		// show and then visibility:hidden the element before calculating offset
		offset = el.show().css( "visibility", "hidden" ).offset(),

		// width and height of a piece
		width = Math.ceil( el.outerWidth() / cells ),
		height = Math.ceil( el.outerHeight() / rows ),
		pieces = [],

		// loop
		i, j, left, top, mx, my;

	// children animate complete:
	function childComplete() {
		pieces.push( this );
		if ( pieces.length === rows * cells ) {
			animComplete();
		}
	}

	// clone the element for each row and cell.
	for( i = 0; i < rows ; i++ ) { // ===>
		top = offset.top + i * height;
		my = i - ( rows - 1 ) / 2 ;

		for( j = 0; j < cells ; j++ ) { // |||
			left = offset.left + j * width;
			mx = j - ( cells - 1 ) / 2 ;

			// Create a clone of the now hidden main element that will be absolute positioned
			// within a wrapper div off the -left and -top equal to size of our pieces
			el
				.clone()
				.appendTo( "body" )
				.wrap( "<div></div>" )
				.css({
					position: "absolute",
					visibility: "visible",
					left: -j * width,
					top: -i * height
				})

			// select the wrapper - make it overflow: hidden and absolute positioned based on
			// where the original was located +left and +top equal to the size of pieces
				.parent()
				.addClass( "ui-effects-explode" )
				.css({
					position: "absolute",
					overflow: "hidden",
					width: width,
					height: height,
					left: left + ( show ? mx * width : 0 ),
					top: top + ( show ? my * height : 0 ),
					opacity: show ? 0 : 1
				}).animate({
					left: left + ( show ? 0 : mx * width ),
					top: top + ( show ? 0 : my * height ),
					opacity: show ? 1 : 0
				}, o.duration || 500, o.easing, childComplete );
		}
	}

	function animComplete() {
		el.css({
			visibility: "visible"
		});
		$( pieces ).remove();
		if ( !show ) {
			el.hide();
		}
		done();
	}
};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.fade = function( o, done ) {
	var el = $( this ),
		mode = $.effects.setMode( el, o.mode || "toggle" );

	el.animate({
		opacity: mode
	}, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: done
	});
};

})( jQuery );
(function( $, undefined ) {

$.effects.effect.fold = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		hide = mode === "hide",
		size = o.size || 15,
		percent = /([0-9]+)%/.exec( size ),
		horizFirst = !!o.horizFirst,
		widthFirst = show !== horizFirst,
		ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ],
		duration = o.duration / 2,
		wrapper, distance,
		animation1 = {},
		animation2 = {};

	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});
	distance = widthFirst ?
		[ wrapper.width(), wrapper.height() ] :
		[ wrapper.height(), wrapper.width() ];

	if ( percent ) {
		size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
	}
	if ( show ) {
		wrapper.css( horizFirst ? {
			height: 0,
			width: size
		} : {
			height: size,
			width: 0
		});
	}

	// Animation
	animation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;
	animation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;

	// Animate
	wrapper
		.animate( animation1, duration, o.easing )
		.animate( animation2, duration, o.easing, function() {
			if ( hide ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.highlight = function( o, done ) {
	var elem = $( this ),
		props = [ "backgroundImage", "backgroundColor", "opacity" ],
		mode = $.effects.setMode( elem, o.mode || "show" ),
		animation = {
			backgroundColor: elem.css( "backgroundColor" )
		};

	if (mode === "hide") {
		animation.opacity = 0;
	}

	$.effects.save( elem, props );

	elem
		.show()
		.css({
			backgroundImage: "none",
			backgroundColor: o.color || "#ffff99"
		})
		.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( mode === "hide" ) {
					elem.hide();
				}
				$.effects.restore( elem, props );
				done();
			}
		});
};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.pulsate = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || "show" ),
		show = mode === "show",
		hide = mode === "hide",
		showhide = ( show || mode === "hide" ),

		// showing or hiding leaves of the "last" animation
		anims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
		duration = o.duration / anims,
		animateTo = 0,
		queue = elem.queue(),
		queuelen = queue.length,
		i;

	if ( show || !elem.is(":visible")) {
		elem.css( "opacity", 0 ).show();
		animateTo = 1;
	}

	// anims - 1 opacity "toggles"
	for ( i = 1; i < anims; i++ ) {
		elem.animate({
			opacity: animateTo
		}, duration, o.easing );
		animateTo = 1 - animateTo;
	}

	elem.animate({
		opacity: animateTo
	}, duration, o.easing);

	elem.queue(function() {
		if ( hide ) {
			elem.hide();
		}
		done();
	});

	// We just queued up "anims" animations, we need to put them next in the queue
	if ( queuelen > 1 ) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	elem.dequeue();
};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.puff = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || "hide" ),
		hide = mode === "hide",
		percent = parseInt( o.percent, 10 ) || 150,
		factor = percent / 100,
		original = {
			height: elem.height(),
			width: elem.width(),
			outerHeight: elem.outerHeight(),
			outerWidth: elem.outerWidth()
		};

	$.extend( o, {
		effect: "scale",
		queue: false,
		fade: true,
		mode: mode,
		complete: done,
		percent: hide ? percent : 100,
		from: hide ?
			original :
			{
				height: original.height * factor,
				width: original.width * factor,
				outerHeight: original.outerHeight * factor,
				outerWidth: original.outerWidth * factor
			}
	});

	elem.effect( o );
};

$.effects.effect.scale = function( o, done ) {

	// Create element
	var el = $( this ),
		options = $.extend( true, {}, o ),
		mode = $.effects.setMode( el, o.mode || "effect" ),
		percent = parseInt( o.percent, 10 ) ||
			( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === "hide" ? 0 : 100 ) ),
		direction = o.direction || "both",
		origin = o.origin,
		original = {
			height: el.height(),
			width: el.width(),
			outerHeight: el.outerHeight(),
			outerWidth: el.outerWidth()
		},
		factor = {
			y: direction !== "horizontal" ? (percent / 100) : 1,
			x: direction !== "vertical" ? (percent / 100) : 1
		};

	// We are going to pass this effect to the size effect:
	options.effect = "size";
	options.queue = false;
	options.complete = done;

	// Set default origin and restore for show/hide
	if ( mode !== "effect" ) {
		options.origin = origin || ["middle","center"];
		options.restore = true;
	}

	options.from = o.from || ( mode === "show" ? {
		height: 0,
		width: 0,
		outerHeight: 0,
		outerWidth: 0
	} : original );
	options.to = {
		height: original.height * factor.y,
		width: original.width * factor.x,
		outerHeight: original.outerHeight * factor.y,
		outerWidth: original.outerWidth * factor.x
	};

	// Fade option to support puff
	if ( options.fade ) {
		if ( mode === "show" ) {
			options.from.opacity = 0;
			options.to.opacity = 1;
		}
		if ( mode === "hide" ) {
			options.from.opacity = 1;
			options.to.opacity = 0;
		}
	}

	// Animate
	el.effect( options );

};

$.effects.effect.size = function( o, done ) {

	// Create element
	var original, baseline, factor,
		el = $( this ),
		props0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ],

		// Always restore
		props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ],

		// Copy for children
		props2 = [ "width", "height", "overflow" ],
		cProps = [ "fontSize" ],
		vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
		hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],

		// Set options
		mode = $.effects.setMode( el, o.mode || "effect" ),
		restore = o.restore || mode !== "effect",
		scale = o.scale || "both",
		origin = o.origin || [ "middle", "center" ],
		position = el.css( "position" ),
		props = restore ? props0 : props1,
		zero = {
			height: 0,
			width: 0,
			outerHeight: 0,
			outerWidth: 0
		};

	if ( mode === "show" ) {
		el.show();
	}
	original = {
		height: el.height(),
		width: el.width(),
		outerHeight: el.outerHeight(),
		outerWidth: el.outerWidth()
	};

	if ( o.mode === "toggle" && mode === "show" ) {
		el.from = o.to || zero;
		el.to = o.from || original;
	} else {
		el.from = o.from || ( mode === "show" ? zero : original );
		el.to = o.to || ( mode === "hide" ? zero : original );
	}

	// Set scaling factor
	factor = {
		from: {
			y: el.from.height / original.height,
			x: el.from.width / original.width
		},
		to: {
			y: el.to.height / original.height,
			x: el.to.width / original.width
		}
	};

	// Scale the css box
	if ( scale === "box" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( vProps );
			el.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );
		}

		// Horizontal props scaling
		if ( factor.from.x !== factor.to.x ) {
			props = props.concat( hProps );
			el.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );
			el.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );
		}
	}

	// Scale the content
	if ( scale === "content" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( cProps ).concat( props2 );
			el.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );
		}
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );
	el.css( "overflow", "hidden" ).css( el.from );

	// Adjust
	if (origin) { // Calculate baseline shifts
		baseline = $.effects.getBaseline( origin, original );
		el.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;
		el.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;
		el.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;
		el.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;
	}
	el.css( el.from ); // set top & left

	// Animate
	if ( scale === "content" || scale === "both" ) { // Scale the children

		// Add margins/font-size
		vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
		hProps = hProps.concat([ "marginLeft", "marginRight" ]);
		props2 = props0.concat(vProps).concat(hProps);

		el.find( "*[width]" ).each( function(){
			var child = $( this ),
				c_original = {
					height: child.height(),
					width: child.width(),
					outerHeight: child.outerHeight(),
					outerWidth: child.outerWidth()
				};
			if (restore) {
				$.effects.save(child, props2);
			}

			child.from = {
				height: c_original.height * factor.from.y,
				width: c_original.width * factor.from.x,
				outerHeight: c_original.outerHeight * factor.from.y,
				outerWidth: c_original.outerWidth * factor.from.x
			};
			child.to = {
				height: c_original.height * factor.to.y,
				width: c_original.width * factor.to.x,
				outerHeight: c_original.height * factor.to.y,
				outerWidth: c_original.width * factor.to.x
			};

			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				child.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );
				child.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );
			}

			// Horizontal props scaling
			if ( factor.from.x !== factor.to.x ) {
				child.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );
				child.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );
			}

			// Animate children
			child.css( child.from );
			child.animate( child.to, o.duration, o.easing, function() {

				// Restore children
				if ( restore ) {
					$.effects.restore( child, props2 );
				}
			});
		});
	}

	// Animate
	el.animate( el.to, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( el.to.opacity === 0 ) {
				el.css( "opacity", el.from.opacity );
			}
			if( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			if ( !restore ) {

				// we need to calculate our new positioning based on the scaling
				if ( position === "static" ) {
					el.css({
						position: "relative",
						top: el.to.top,
						left: el.to.left
					});
				} else {
					$.each([ "top", "left" ], function( idx, pos ) {
						el.css( pos, function( _, str ) {
							var val = parseInt( str, 10 ),
								toRef = idx ? el.to.left : el.to.top;

							// if original was "auto", recalculate the new value from wrapper
							if ( str === "auto" ) {
								return toRef + "px";
							}

							return val + toRef + "px";
						});
					});
				}
			}

			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.shake = function( o, done ) {

	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "effect" ),
		direction = o.direction || "left",
		distance = o.distance || 20,
		times = o.times || 3,
		anims = times * 2 + 1,
		speed = Math.round(o.duration/anims),
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		animation = {},
		animation1 = {},
		animation2 = {},
		i,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	// Animation
	animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
	animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
	animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;

	// Animate
	el.animate( animation, speed, o.easing );

	// Shakes
	for ( i = 1; i < times; i++ ) {
		el.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );
	}
	el
		.animate( animation1, speed, o.easing )
		.animate( animation, speed / 2, o.easing )
		.queue(function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

	// inject all the animations we just queued to be first in line (after "inprogress")
	if ( queuelen > 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.slide = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "width", "height" ],
		mode = $.effects.setMode( el, o.mode || "show" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		distance,
		animation = {};

	// Adjust
	$.effects.save( el, props );
	el.show();
	distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true );

	$.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	if ( show ) {
		el.css( ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( positiveMotion ? "+=" : "-=") :
		( positiveMotion ? "-=" : "+=")) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.transfer = function( o, done ) {
	var elem = $( this ),
		target = $( o.to ),
		targetFixed = target.css( "position" ) === "fixed",
		body = $("body"),
		fixTop = targetFixed ? body.scrollTop() : 0,
		fixLeft = targetFixed ? body.scrollLeft() : 0,
		endPosition = target.offset(),
		animation = {
			top: endPosition.top - fixTop ,
			left: endPosition.left - fixLeft ,
			height: target.innerHeight(),
			width: target.innerWidth()
		},
		startPosition = elem.offset(),
		transfer = $( '<div class="ui-effects-transfer"></div>' )
			.appendTo( document.body )
			.addClass( o.className )
			.css({
				top: startPosition.top - fixTop ,
				left: startPosition.left - fixLeft ,
				height: elem.innerHeight(),
				width: elem.innerWidth(),
				position: targetFixed ? "fixed" : "absolute"
			})
			.animate( animation, o.duration, o.easing, function() {
				transfer.remove();
				done();
			});
};

})(jQuery);
(function( $, undefined ) {

var mouseHandled = false;

$.widget( "ui.menu", {
	version: "1.9.2",
	defaultElement: "<ul>",
	delay: 300,
	options: {
		icons: {
			submenu: "ui-icon-carat-1-e"
		},
		menus: "ul",
		position: {
			my: "left top",
			at: "right top"
		},
		role: "menu",

		// callbacks
		blur: null,
		focus: null,
		select: null
	},

	_create: function() {
		this.activeMenu = this.element;
		this.element
			.uniqueId()
			.addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
			.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length )
			.attr({
				role: this.options.role,
				tabIndex: 0
			})
			// need to catch all clicks on disabled menu
			// not possible through _on
			.bind( "click" + this.eventNamespace, $.proxy(function( event ) {
				if ( this.options.disabled ) {
					event.preventDefault();
				}
			}, this ));

		if ( this.options.disabled ) {
			this.element
				.addClass( "ui-state-disabled" )
				.attr( "aria-disabled", "true" );
		}

		this._on({
			// Prevent focus from sticking to links inside menu after clicking
			// them (focus should always stay on UL during navigation).
			"mousedown .ui-menu-item > a": function( event ) {
				event.preventDefault();
			},
			"click .ui-state-disabled > a": function( event ) {
				event.preventDefault();
			},
			"click .ui-menu-item:has(a)": function( event ) {
				var target = $( event.target ).closest( ".ui-menu-item" );
				if ( !mouseHandled && target.not( ".ui-state-disabled" ).length ) {
					mouseHandled = true;

					this.select( event );
					// Open submenu on click
					if ( target.has( ".ui-menu" ).length ) {
						this.expand( event );
					} else if ( !this.element.is( ":focus" ) ) {
						// Redirect focus to the menu
						this.element.trigger( "focus", [ true ] );

						// If the active item is on the top level, let it stay active.
						// Otherwise, blur the active item since it is no longer visible.
						if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
							clearTimeout( this.timer );
						}
					}
				}
			},
			"mouseenter .ui-menu-item": function( event ) {
				var target = $( event.currentTarget );
				// Remove ui-state-active class from siblings of the newly focused menu item
				// to avoid a jump caused by adjacent elements both having a class with a border
				target.siblings().children( ".ui-state-active" ).removeClass( "ui-state-active" );
				this.focus( event, target );
			},
			mouseleave: "collapseAll",
			"mouseleave .ui-menu": "collapseAll",
			focus: function( event, keepActiveItem ) {
				// If there's already an active item, keep it active
				// If not, activate the first item
				var item = this.active || this.element.children( ".ui-menu-item" ).eq( 0 );

				if ( !keepActiveItem ) {
					this.focus( event, item );
				}
			},
			blur: function( event ) {
				this._delay(function() {
					if ( !$.contains( this.element[0], this.document[0].activeElement ) ) {
						this.collapseAll( event );
					}
				});
			},
			keydown: "_keydown"
		});

		this.refresh();

		// Clicks outside of a menu collapse any open menus
		this._on( this.document, {
			click: function( event ) {
				if ( !$( event.target ).closest( ".ui-menu" ).length ) {
					this.collapseAll( event );
				}

				// Reset the mouseHandled flag
				mouseHandled = false;
			}
		});
	},

	_destroy: function() {
		// Destroy (sub)menus
		this.element
			.removeAttr( "aria-activedescendant" )
			.find( ".ui-menu" ).andSelf()
				.removeClass( "ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons" )
				.removeAttr( "role" )
				.removeAttr( "tabIndex" )
				.removeAttr( "aria-labelledby" )
				.removeAttr( "aria-expanded" )
				.removeAttr( "aria-hidden" )
				.removeAttr( "aria-disabled" )
				.removeUniqueId()
				.show();

		// Destroy menu items
		this.element.find( ".ui-menu-item" )
			.removeClass( "ui-menu-item" )
			.removeAttr( "role" )
			.removeAttr( "aria-disabled" )
			.children( "a" )
				.removeUniqueId()
				.removeClass( "ui-corner-all ui-state-hover" )
				.removeAttr( "tabIndex" )
				.removeAttr( "role" )
				.removeAttr( "aria-haspopup" )
				.children().each( function() {
					var elem = $( this );
					if ( elem.data( "ui-menu-submenu-carat" ) ) {
						elem.remove();
					}
				});

		// Destroy menu dividers
		this.element.find( ".ui-menu-divider" ).removeClass( "ui-menu-divider ui-widget-content" );
	},

	_keydown: function( event ) {
		var match, prev, character, skip, regex,
			preventDefault = true;

		function escape( value ) {
			return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
		}

		switch ( event.keyCode ) {
		case $.ui.keyCode.PAGE_UP:
			this.previousPage( event );
			break;
		case $.ui.keyCode.PAGE_DOWN:
			this.nextPage( event );
			break;
		case $.ui.keyCode.HOME:
			this._move( "first", "first", event );
			break;
		case $.ui.keyCode.END:
			this._move( "last", "last", event );
			break;
		case $.ui.keyCode.UP:
			this.previous( event );
			break;
		case $.ui.keyCode.DOWN:
			this.next( event );
			break;
		case $.ui.keyCode.LEFT:
			this.collapse( event );
			break;
		case $.ui.keyCode.RIGHT:
			if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
				this.expand( event );
			}
			break;
		case $.ui.keyCode.ENTER:
		case $.ui.keyCode.SPACE:
			this._activate( event );
			break;
		case $.ui.keyCode.ESCAPE:
			this.collapse( event );
			break;
		default:
			preventDefault = false;
			prev = this.previousFilter || "";
			character = String.fromCharCode( event.keyCode );
			skip = false;

			clearTimeout( this.filterTimer );

			if ( character === prev ) {
				skip = true;
			} else {
				character = prev + character;
			}

			regex = new RegExp( "^" + escape( character ), "i" );
			match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
				return regex.test( $( this ).children( "a" ).text() );
			});
			match = skip && match.index( this.active.next() ) !== -1 ?
				this.active.nextAll( ".ui-menu-item" ) :
				match;

			// If no matches on the current filter, reset to the last character pressed
			// to move down the menu to the first item that starts with that character
			if ( !match.length ) {
				character = String.fromCharCode( event.keyCode );
				regex = new RegExp( "^" + escape( character ), "i" );
				match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
					return regex.test( $( this ).children( "a" ).text() );
				});
			}

			if ( match.length ) {
				this.focus( event, match );
				if ( match.length > 1 ) {
					this.previousFilter = character;
					this.filterTimer = this._delay(function() {
						delete this.previousFilter;
					}, 1000 );
				} else {
					delete this.previousFilter;
				}
			} else {
				delete this.previousFilter;
			}
		}

		if ( preventDefault ) {
			event.preventDefault();
		}
	},

	_activate: function( event ) {
		if ( !this.active.is( ".ui-state-disabled" ) ) {
			if ( this.active.children( "a[aria-haspopup='true']" ).length ) {
				this.expand( event );
			} else {
				this.select( event );
			}
		}
	},

	refresh: function() {
		var menus,
			icon = this.options.icons.submenu,
			submenus = this.element.find( this.options.menus );

		// Initialize nested menus
		submenus.filter( ":not(.ui-menu)" )
			.addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
			.hide()
			.attr({
				role: this.options.role,
				"aria-hidden": "true",
				"aria-expanded": "false"
			})
			.each(function() {
				var menu = $( this ),
					item = menu.prev( "a" ),
					submenuCarat = $( "<span>" )
						.addClass( "ui-menu-icon ui-icon " + icon )
						.data( "ui-menu-submenu-carat", true );

				item
					.attr( "aria-haspopup", "true" )
					.prepend( submenuCarat );
				menu.attr( "aria-labelledby", item.attr( "id" ) );
			});

		menus = submenus.add( this.element );

		// Don't refresh list items that are already adapted
		menus.children( ":not(.ui-menu-item):has(a)" )
			.addClass( "ui-menu-item" )
			.attr( "role", "presentation" )
			.children( "a" )
				.uniqueId()
				.addClass( "ui-corner-all" )
				.attr({
					tabIndex: -1,
					role: this._itemRole()
				});

		// Initialize unlinked menu-items containing spaces and/or dashes only as dividers
		menus.children( ":not(.ui-menu-item)" ).each(function() {
			var item = $( this );
			// hyphen, em dash, en dash
			if ( !/[^\-—–\s]/.test( item.text() ) ) {
				item.addClass( "ui-widget-content ui-menu-divider" );
			}
		});

		// Add aria-disabled attribute to any disabled menu item
		menus.children( ".ui-state-disabled" ).attr( "aria-disabled", "true" );

		// If the active item has been removed, blur the menu
		if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
			this.blur();
		}
	},

	_itemRole: function() {
		return {
			menu: "menuitem",
			listbox: "option"
		}[ this.options.role ];
	},

	focus: function( event, item ) {
		var nested, focused;
		this.blur( event, event && event.type === "focus" );

		this._scrollIntoView( item );

		this.active = item.first();
		focused = this.active.children( "a" ).addClass( "ui-state-focus" );
		// Only update aria-activedescendant if there's a role
		// otherwise we assume focus is managed elsewhere
		if ( this.options.role ) {
			this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
		}

		// Highlight active parent menu item, if any
		this.active
			.parent()
			.closest( ".ui-menu-item" )
			.children( "a:first" )
			.addClass( "ui-state-active" );

		if ( event && event.type === "keydown" ) {
			this._close();
		} else {
			this.timer = this._delay(function() {
				this._close();
			}, this.delay );
		}

		nested = item.children( ".ui-menu" );
		if ( nested.length && ( /^mouse/.test( event.type ) ) ) {
			this._startOpening(nested);
		}
		this.activeMenu = item.parent();

		this._trigger( "focus", event, { item: item } );
	},

	_scrollIntoView: function( item ) {
		var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
		if ( this._hasScroll() ) {
			borderTop = parseFloat( $.css( this.activeMenu[0], "borderTopWidth" ) ) || 0;
			paddingTop = parseFloat( $.css( this.activeMenu[0], "paddingTop" ) ) || 0;
			offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
			scroll = this.activeMenu.scrollTop();
			elementHeight = this.activeMenu.height();
			itemHeight = item.height();

			if ( offset < 0 ) {
				this.activeMenu.scrollTop( scroll + offset );
			} else if ( offset + itemHeight > elementHeight ) {
				this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
			}
		}
	},

	blur: function( event, fromFocus ) {
		if ( !fromFocus ) {
			clearTimeout( this.timer );
		}

		if ( !this.active ) {
			return;
		}

		this.active.children( "a" ).removeClass( "ui-state-focus" );
		this.active = null;

		this._trigger( "blur", event, { item: this.active } );
	},

	_startOpening: function( submenu ) {
		clearTimeout( this.timer );

		// Don't open if already open fixes a Firefox bug that caused a .5 pixel
		// shift in the submenu position when mousing over the carat icon
		if ( submenu.attr( "aria-hidden" ) !== "true" ) {
			return;
		}

		this.timer = this._delay(function() {
			this._close();
			this._open( submenu );
		}, this.delay );
	},

	_open: function( submenu ) {
		var position = $.extend({
			of: this.active
		}, this.options.position );

		clearTimeout( this.timer );
		this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
			.hide()
			.attr( "aria-hidden", "true" );

		submenu
			.show()
			.removeAttr( "aria-hidden" )
			.attr( "aria-expanded", "true" )
			.position( position );
	},

	collapseAll: function( event, all ) {
		clearTimeout( this.timer );
		this.timer = this._delay(function() {
			// If we were passed an event, look for the submenu that contains the event
			var currentMenu = all ? this.element :
				$( event && event.target ).closest( this.element.find( ".ui-menu" ) );

			// If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
			if ( !currentMenu.length ) {
				currentMenu = this.element;
			}

			this._close( currentMenu );

			this.blur( event );
			this.activeMenu = currentMenu;
		}, this.delay );
	},

	// With no arguments, closes the currently active menu - if nothing is active
	// it closes all menus.  If passed an argument, it will search for menus BELOW
	_close: function( startMenu ) {
		if ( !startMenu ) {
			startMenu = this.active ? this.active.parent() : this.element;
		}

		startMenu
			.find( ".ui-menu" )
				.hide()
				.attr( "aria-hidden", "true" )
				.attr( "aria-expanded", "false" )
			.end()
			.find( "a.ui-state-active" )
				.removeClass( "ui-state-active" );
	},

	collapse: function( event ) {
		var newItem = this.active &&
			this.active.parent().closest( ".ui-menu-item", this.element );
		if ( newItem && newItem.length ) {
			this._close();
			this.focus( event, newItem );
		}
	},

	expand: function( event ) {
		var newItem = this.active &&
			this.active
				.children( ".ui-menu " )
				.children( ".ui-menu-item" )
				.first();

		if ( newItem && newItem.length ) {
			this._open( newItem.parent() );

			// Delay so Firefox will not hide activedescendant change in expanding submenu from AT
			this._delay(function() {
				this.focus( event, newItem );
			});
		}
	},

	next: function( event ) {
		this._move( "next", "first", event );
	},

	previous: function( event ) {
		this._move( "prev", "last", event );
	},

	isFirstItem: function() {
		return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
	},

	isLastItem: function() {
		return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
	},

	_move: function( direction, filter, event ) {
		var next;
		if ( this.active ) {
			if ( direction === "first" || direction === "last" ) {
				next = this.active
					[ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
					.eq( -1 );
			} else {
				next = this.active
					[ direction + "All" ]( ".ui-menu-item" )
					.eq( 0 );
			}
		}
		if ( !next || !next.length || !this.active ) {
			next = this.activeMenu.children( ".ui-menu-item" )[ filter ]();
		}

		this.focus( event, next );
	},

	nextPage: function( event ) {
		var item, base, height;

		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isLastItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.nextAll( ".ui-menu-item" ).each(function() {
				item = $( this );
				return item.offset().top - base - height < 0;
			});

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.children( ".ui-menu-item" )
				[ !this.active ? "first" : "last" ]() );
		}
	},

	previousPage: function( event ) {
		var item, base, height;
		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isFirstItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.prevAll( ".ui-menu-item" ).each(function() {
				item = $( this );
				return item.offset().top - base + height > 0;
			});

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.children( ".ui-menu-item" ).first() );
		}
	},

	_hasScroll: function() {
		return this.element.outerHeight() < this.element.prop( "scrollHeight" );
	},

	select: function( event ) {
		// TODO: It should never be possible to not have an active item at this
		// point, but the tests don't trigger mouseenter before click.
		this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
		var ui = { item: this.active };
		if ( !this.active.has( ".ui-menu" ).length ) {
			this.collapseAll( event, true );
		}
		this._trigger( "select", event, ui );
	}
});

}( jQuery ));
(function( $, undefined ) {

$.widget( "ui.progressbar", {
	version: "1.9.2",
	options: {
		value: 0,
		max: 100
	},

	min: 0,

	_create: function() {
		this.element
			.addClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.attr({
				role: "progressbar",
				"aria-valuemin": this.min,
				"aria-valuemax": this.options.max,
				"aria-valuenow": this._value()
			});

		this.valueDiv = $( "<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>" )
			.appendTo( this.element );

		this.oldValue = this._value();
		this._refreshValue();
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.removeAttr( "role" )
			.removeAttr( "aria-valuemin" )
			.removeAttr( "aria-valuemax" )
			.removeAttr( "aria-valuenow" );

		this.valueDiv.remove();
	},

	value: function( newValue ) {
		if ( newValue === undefined ) {
			return this._value();
		}

		this._setOption( "value", newValue );
		return this;
	},

	_setOption: function( key, value ) {
		if ( key === "value" ) {
			this.options.value = value;
			this._refreshValue();
			if ( this._value() === this.options.max ) {
				this._trigger( "complete" );
			}
		}

		this._super( key, value );
	},

	_value: function() {
		var val = this.options.value;
		// normalize invalid value
		if ( typeof val !== "number" ) {
			val = 0;
		}
		return Math.min( this.options.max, Math.max( this.min, val ) );
	},

	_percentage: function() {
		return 100 * this._value() / this.options.max;
	},

	_refreshValue: function() {
		var value = this.value(),
			percentage = this._percentage();

		if ( this.oldValue !== value ) {
			this.oldValue = value;
			this._trigger( "change" );
		}

		this.valueDiv
			.toggle( value > this.min )
			.toggleClass( "ui-corner-right", value === this.options.max )
			.width( percentage.toFixed(0) + "%" );
		this.element.attr( "aria-valuenow", value );
	}
});

})( jQuery );
(function( $, undefined ) {

$.widget("ui.resizable", $.ui.mouse, {
	version: "1.9.2",
	widgetEventPrefix: "resize",
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: "slow",
		animateEasing: "swing",
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: "e,s,se",
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		zIndex: 1000
	},
	_create: function() {

		var that = this, o = this.options;
		this.element.addClass("ui-resizable");

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || 'ui-resizable-helper' : null
		});

		//Wrap the element if it cannot hold child nodes
		if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

			//Create a wrapper element and set the wrapper to the new current internal element
			this.element.wrap(
				$('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({
					position: this.element.css('position'),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css('top'),
					left: this.element.css('left')
				})
			);

			//Overwrite the original this.element
			this.element = this.element.parent().data(
				"resizable", this.element.data('resizable')
			);

			this.elementIsWrapper = true;

			//Move margins to the wrapper
			this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
			this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

			//Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css('resize');
			this.originalElement.css('resize', 'none');

			//Push the actual element to our proportionallyResize internal array
			this._proportionallyResizeElements.push(this.originalElement.css({ position: 'static', zoom: 1, display: 'block' }));

			// avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css('margin') });

			// fix handlers offset
			this._proportionallyResize();

		}

		this.handles = o.handles || (!$('.ui-resizable-handle', this.element).length ? "e,s,se" : { n: '.ui-resizable-n', e: '.ui-resizable-e', s: '.ui-resizable-s', w: '.ui-resizable-w', se: '.ui-resizable-se', sw: '.ui-resizable-sw', ne: '.ui-resizable-ne', nw: '.ui-resizable-nw' });
		if(this.handles.constructor == String) {

			if(this.handles == 'all') this.handles = 'n,e,s,w,se,sw,ne,nw';
			var n = this.handles.split(","); this.handles = {};

			for(var i = 0; i < n.length; i++) {

				var handle = $.trim(n[i]), hname = 'ui-resizable-'+handle;
				var axis = $('<div class="ui-resizable-handle ' + hname + '"></div>');

				// Apply zIndex to all handles - see #7960
				axis.css({ zIndex: o.zIndex });

				//TODO : What's going on here?
				if ('se' == handle) {
					axis.addClass('ui-icon ui-icon-gripsmall-diagonal-se');
				};

				//Insert into internal handles object and append to element
				this.handles[handle] = '.ui-resizable-'+handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			target = target || this.element;

			for(var i in this.handles) {

				if(this.handles[i].constructor == String)
					this.handles[i] = $(this.handles[i], this.element).show();

				//Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
				if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

					var axis = $(this.handles[i], this.element), padWrapper = 0;

					//Checking the correct pad and border
					padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

					//The padding type i have to apply...
					var padPos = [ 'padding',
						/ne|nw|n/.test(i) ? 'Top' :
						/se|sw|s/.test(i) ? 'Bottom' :
						/^e$/.test(i) ? 'Right' : 'Left' ].join("");

					target.css(padPos, padWrapper);

					this._proportionallyResize();

				}

				//TODO: What's that good for? There's not anything to be executed left
				if(!$(this.handles[i]).length)
					continue;

			}
		};

		//TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = $('.ui-resizable-handle', this.element)
			.disableSelection();

		//Matching axis name
		this._handles.mouseover(function() {
			if (!that.resizing) {
				if (this.className)
					var axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
				//Axis, default = se
				that.axis = axis && axis[1] ? axis[1] : 'se';
			}
		});

		//If we want to auto hide the elements
		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass("ui-resizable-autohide")
				.mouseenter(function() {
					if (o.disabled) return;
					$(this).removeClass("ui-resizable-autohide");
					that._handles.show();
				})
				.mouseleave(function(){
					if (o.disabled) return;
					if (!that.resizing) {
						$(this).addClass("ui-resizable-autohide");
						that._handles.hide();
					}
				});
		}

		//Initialize the mouse interaction
		this._mouseInit();

	},

	_destroy: function() {

		this._mouseDestroy();

		var _destroy = function(exp) {
			$(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
				.removeData("resizable").removeData("ui-resizable").unbind(".resizable").find('.ui-resizable-handle').remove();
		};

		//TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			var wrapper = this.element;
			this.originalElement.css({
				position: wrapper.css('position'),
				width: wrapper.outerWidth(),
				height: wrapper.outerHeight(),
				top: wrapper.css('top'),
				left: wrapper.css('left')
			}).insertAfter( wrapper );
			wrapper.remove();
		}

		this.originalElement.css('resize', this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var handle = false;
		for (var i in this.handles) {
			if ($(this.handles[i])[0] == event.target) {
				handle = true;
			}
		}

		return !this.options.disabled && handle;
	},

	_mouseStart: function(event) {

		var o = this.options, iniPos = this.element.position(), el = this.element;

		this.resizing = true;
		this.documentScroll = { top: $(document).scrollTop(), left: $(document).scrollLeft() };

		// bugfix for http://dev.jquery.com/ticket/1749
		if (el.is('.ui-draggable') || (/absolute/).test(el.css('position'))) {
			el.css({ position: 'absolute', top: iniPos.top, left: iniPos.left });
		}

		this._renderProxy();

		var curleft = num(this.helper.css('left')), curtop = num(this.helper.css('top'));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		//Store needed variables
		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };
		this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalPosition = { left: curleft, top: curtop };
		this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		//Aspect Ratio
		this.aspectRatio = (typeof o.aspectRatio == 'number') ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

		var cursor = $('.ui-resizable-' + this.axis).css('cursor');
		$('body').css('cursor', cursor == 'auto' ? this.axis + '-resize' : cursor);

		el.addClass("ui-resizable-resizing");
		this._propagate("start", event);
		return true;
	},

	_mouseDrag: function(event) {

		//Increase performance, avoid regex
		var el = this.helper, o = this.options, props = {},
			that = this, smp = this.originalMousePosition, a = this.axis;

		var dx = (event.pageX-smp.left)||0, dy = (event.pageY-smp.top)||0;
		var trigger = this._change[a];
		if (!trigger) return false;

		// Calculate the attrs that will be change
		var data = trigger.apply(this, [event, dx, dy]);

		// Put this in the mouseDrag handler since the user can start pressing shift while resizing
		this._updateVirtualBoundaries(event.shiftKey);
		if (this._aspectRatio || event.shiftKey)
			data = this._updateRatio(data, event);

		data = this._respectSize(data, event);

		// plugins callbacks need to be called first
		this._propagate("resize", event);

		el.css({
			top: this.position.top + "px", left: this.position.left + "px",
			width: this.size.width + "px", height: this.size.height + "px"
		});

		if (!this._helper && this._proportionallyResizeElements.length)
			this._proportionallyResize();

		this._updateCache(data);

		// calling the user callback at the end
		this._trigger('resize', event, this.ui());

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var o = this.options, that = this;

		if(this._helper) {
			var pr = this._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),
				soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : that.sizeDiff.height,
				soffsetw = ista ? 0 : that.sizeDiff.width;

			var s = { width: (that.helper.width()  - soffsetw), height: (that.helper.height() - soffseth) },
				left = (parseInt(that.element.css('left'), 10) + (that.position.left - that.originalPosition.left)) || null,
				top = (parseInt(that.element.css('top'), 10) + (that.position.top - that.originalPosition.top)) || null;

			if (!o.animate)
				this.element.css($.extend(s, { top: top, left: left }));

			that.helper.height(that.size.height);
			that.helper.width(that.size.width);

			if (this._helper && !o.animate) this._proportionallyResize();
		}

		$('body').css('cursor', 'auto');

		this.element.removeClass("ui-resizable-resizing");

		this._propagate("stop", event);

		if (this._helper) this.helper.remove();
		return false;

	},

	_updateVirtualBoundaries: function(forceAspectRatio) {
		var o = this.options, pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b;

		b = {
			minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
			maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
			minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
			maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
		};

		if(this._aspectRatio || forceAspectRatio) {
			// We want to create an enclosing box whose aspect ration is the requested one
			// First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
			pMinWidth = b.minHeight * this.aspectRatio;
			pMinHeight = b.minWidth / this.aspectRatio;
			pMaxWidth = b.maxHeight * this.aspectRatio;
			pMaxHeight = b.maxWidth / this.aspectRatio;

			if(pMinWidth > b.minWidth) b.minWidth = pMinWidth;
			if(pMinHeight > b.minHeight) b.minHeight = pMinHeight;
			if(pMaxWidth < b.maxWidth) b.maxWidth = pMaxWidth;
			if(pMaxHeight < b.maxHeight) b.maxHeight = pMaxHeight;
		}
		this._vBoundaries = b;
	},

	_updateCache: function(data) {
		var o = this.options;
		this.offset = this.helper.offset();
		if (isNumber(data.left)) this.position.left = data.left;
		if (isNumber(data.top)) this.position.top = data.top;
		if (isNumber(data.height)) this.size.height = data.height;
		if (isNumber(data.width)) this.size.width = data.width;
	},

	_updateRatio: function(data, event) {

		var o = this.options, cpos = this.position, csize = this.size, a = this.axis;

		if (isNumber(data.height)) data.width = (data.height * this.aspectRatio);
		else if (isNumber(data.width)) data.height = (data.width / this.aspectRatio);

		if (a == 'sw') {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a == 'nw') {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function(data, event) {

		var el = this.helper, o = this._vBoundaries, pRatio = this._aspectRatio || event.shiftKey, a = this.axis,
				ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
					isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height);

		if (isminw) data.width = o.minWidth;
		if (isminh) data.height = o.minHeight;
		if (ismaxw) data.width = o.maxWidth;
		if (ismaxh) data.height = o.maxHeight;

		var dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height;
		var cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);

		if (isminw && cw) data.left = dw - o.minWidth;
		if (ismaxw && cw) data.left = dw - o.maxWidth;
		if (isminh && ch)	data.top = dh - o.minHeight;
		if (ismaxh && ch)	data.top = dh - o.maxHeight;

		// fixing jump error on top/left - bug #2330
		var isNotwh = !data.width && !data.height;
		if (isNotwh && !data.left && data.top) data.top = null;
		else if (isNotwh && !data.top && data.left) data.left = null;

		return data;
	},

	_proportionallyResize: function() {

		var o = this.options;
		if (!this._proportionallyResizeElements.length) return;
		var element = this.helper || this.element;

		for (var i=0; i < this._proportionallyResizeElements.length; i++) {

			var prel = this._proportionallyResizeElements[i];

			if (!this.borderDif) {
				var b = [prel.css('borderTopWidth'), prel.css('borderRightWidth'), prel.css('borderBottomWidth'), prel.css('borderLeftWidth')],
					p = [prel.css('paddingTop'), prel.css('paddingRight'), prel.css('paddingBottom'), prel.css('paddingLeft')];

				this.borderDif = $.map(b, function(v, i) {
					var border = parseInt(v,10)||0, padding = parseInt(p[i],10)||0;
					return border + padding;
				});
			}

			prel.css({
				height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
				width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
			});

		};

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if(this._helper) {

			this.helper = this.helper || $('<div style="overflow:hidden;"></div>');

			// fix ie6 offset TODO: This seems broken
			var ie6offset = ($.ui.ie6 ? 1 : 0),
			pxyoffset = ( $.ui.ie6 ? 2 : -1 );

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() + pxyoffset,
				height: this.element.outerHeight() + pxyoffset,
				position: 'absolute',
				left: this.elementOffset.left - ie6offset +'px',
				top: this.elementOffset.top - ie6offset +'px',
				zIndex: ++o.zIndex //TODO: Don't modify option
			});

			this.helper
				.appendTo("body")
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx, dy) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [event, this.ui()]);
		(n != "resize" && this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

/*
 * Resizable Extensions
 */

$.ui.plugin.add("resizable", "alsoResize", {

	start: function (event, ui) {
		var that = $(this).data("resizable"), o = that.options;

		var _store = function (exp) {
			$(exp).each(function() {
				var el = $(this);
				el.data("resizable-alsoresize", {
					width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
					left: parseInt(el.css('left'), 10), top: parseInt(el.css('top'), 10)
				});
			});
		};

		if (typeof(o.alsoResize) == 'object' && !o.alsoResize.parentNode) {
			if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
			else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
		}else{
			_store(o.alsoResize);
		}
	},

	resize: function (event, ui) {
		var that = $(this).data("resizable"), o = that.options, os = that.originalSize, op = that.originalPosition;

		var delta = {
			height: (that.size.height - os.height) || 0, width: (that.size.width - os.width) || 0,
			top: (that.position.top - op.top) || 0, left: (that.position.left - op.left) || 0
		},

		_alsoResize = function (exp, c) {
			$(exp).each(function() {
				var el = $(this), start = $(this).data("resizable-alsoresize"), style = {},
					css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ['width', 'height'] : ['width', 'height', 'top', 'left'];

				$.each(css, function (i, prop) {
					var sum = (start[prop]||0) + (delta[prop]||0);
					if (sum && sum >= 0)
						style[prop] = sum || null;
				});

				el.css(style);
			});
		};

		if (typeof(o.alsoResize) == 'object' && !o.alsoResize.nodeType) {
			$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
		}else{
			_alsoResize(o.alsoResize);
		}
	},

	stop: function (event, ui) {
		$(this).removeData("resizable-alsoresize");
	}
});

$.ui.plugin.add("resizable", "animate", {

	stop: function(event, ui) {
		var that = $(this).data("resizable"), o = that.options;

		var pr = that._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),
					soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : that.sizeDiff.height,
						soffsetw = ista ? 0 : that.sizeDiff.width;

		var style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
					left = (parseInt(that.element.css('left'), 10) + (that.position.left - that.originalPosition.left)) || null,
						top = (parseInt(that.element.css('top'), 10) + (that.position.top - that.originalPosition.top)) || null;

		that.element.animate(
			$.extend(style, top && left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(that.element.css('width'), 10),
						height: parseInt(that.element.css('height'), 10),
						top: parseInt(that.element.css('top'), 10),
						left: parseInt(that.element.css('left'), 10)
					};

					if (pr && pr.length) $(pr[0]).css({ width: data.width, height: data.height });

					// propagating resize, and updating values for each animation step
					that._updateCache(data);
					that._propagate("resize", event);

				}
			}
		);
	}

});

$.ui.plugin.add("resizable", "containment", {

	start: function(event, ui) {
		var that = $(this).data("resizable"), o = that.options, el = that.element;
		var oc = o.containment,	ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;
		if (!ce) return;

		that.containerElement = $(ce);

		if (/document/.test(oc) || oc == document) {
			that.containerOffset = { left: 0, top: 0 };
			that.containerPosition = { left: 0, top: 0 };

			that.parentData = {
				element: $(document), left: 0, top: 0,
				width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
			};
		}

		// i'm a node, so compute top, left, right, bottom
		else {
			var element = $(ce), p = [];
			$([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) { p[i] = num(element.css("padding" + name)); });

			that.containerOffset = element.offset();
			that.containerPosition = element.position();
			that.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

			var co = that.containerOffset, ch = that.containerSize.height,	cw = that.containerSize.width,
						width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw ), height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

			that.parentData = {
				element: ce, left: co.left, top: co.top, width: width, height: height
			};
		}
	},

	resize: function(event, ui) {
		var that = $(this).data("resizable"), o = that.options,
				ps = that.containerSize, co = that.containerOffset, cs = that.size, cp = that.position,
				pRatio = that._aspectRatio || event.shiftKey, cop = { top:0, left:0 }, ce = that.containerElement;

		if (ce[0] != document && (/static/).test(ce.css('position'))) cop = co;

		if (cp.left < (that._helper ? co.left : 0)) {
			that.size.width = that.size.width + (that._helper ? (that.position.left - co.left) : (that.position.left - cop.left));
			if (pRatio) that.size.height = that.size.width / that.aspectRatio;
			that.position.left = o.helper ? co.left : 0;
		}

		if (cp.top < (that._helper ? co.top : 0)) {
			that.size.height = that.size.height + (that._helper ? (that.position.top - co.top) : that.position.top);
			if (pRatio) that.size.width = that.size.height * that.aspectRatio;
			that.position.top = that._helper ? co.top : 0;
		}

		that.offset.left = that.parentData.left+that.position.left;
		that.offset.top = that.parentData.top+that.position.top;

		var woset = Math.abs( (that._helper ? that.offset.left - cop.left : (that.offset.left - cop.left)) + that.sizeDiff.width ),
					hoset = Math.abs( (that._helper ? that.offset.top - cop.top : (that.offset.top - co.top)) + that.sizeDiff.height );

		var isParent = that.containerElement.get(0) == that.element.parent().get(0),
			isOffsetRelative = /relative|absolute/.test(that.containerElement.css('position'));

		if(isParent && isOffsetRelative) woset -= that.parentData.left;

		if (woset + that.size.width >= that.parentData.width) {
			that.size.width = that.parentData.width - woset;
			if (pRatio) that.size.height = that.size.width / that.aspectRatio;
		}

		if (hoset + that.size.height >= that.parentData.height) {
			that.size.height = that.parentData.height - hoset;
			if (pRatio) that.size.width = that.size.height * that.aspectRatio;
		}
	},

	stop: function(event, ui){
		var that = $(this).data("resizable"), o = that.options, cp = that.position,
				co = that.containerOffset, cop = that.containerPosition, ce = that.containerElement;

		var helper = $(that.helper), ho = helper.offset(), w = helper.outerWidth() - that.sizeDiff.width, h = helper.outerHeight() - that.sizeDiff.height;

		if (that._helper && !o.animate && (/relative/).test(ce.css('position')))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

		if (that._helper && !o.animate && (/static/).test(ce.css('position')))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

	}
});

$.ui.plugin.add("resizable", "ghost", {

	start: function(event, ui) {

		var that = $(this).data("resizable"), o = that.options, cs = that.size;

		that.ghost = that.originalElement.clone();
		that.ghost
			.css({ opacity: .25, display: 'block', position: 'relative', height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
			.addClass('ui-resizable-ghost')
			.addClass(typeof o.ghost == 'string' ? o.ghost : '');

		that.ghost.appendTo(that.helper);

	},

	resize: function(event, ui){
		var that = $(this).data("resizable"), o = that.options;
		if (that.ghost) that.ghost.css({ position: 'relative', height: that.size.height, width: that.size.width });
	},

	stop: function(event, ui){
		var that = $(this).data("resizable"), o = that.options;
		if (that.ghost && that.helper) that.helper.get(0).removeChild(that.ghost.get(0));
	}

});

$.ui.plugin.add("resizable", "grid", {

	resize: function(event, ui) {
		var that = $(this).data("resizable"), o = that.options, cs = that.size, os = that.originalSize, op = that.originalPosition, a = that.axis, ratio = o._aspectRatio || event.shiftKey;
		o.grid = typeof o.grid == "number" ? [o.grid, o.grid] : o.grid;
		var ox = Math.round((cs.width - os.width) / (o.grid[0]||1)) * (o.grid[0]||1), oy = Math.round((cs.height - os.height) / (o.grid[1]||1)) * (o.grid[1]||1);

		if (/^(se|s|e)$/.test(a)) {
			that.size.width = os.width + ox;
			that.size.height = os.height + oy;
		}
		else if (/^(ne)$/.test(a)) {
			that.size.width = os.width + ox;
			that.size.height = os.height + oy;
			that.position.top = op.top - oy;
		}
		else if (/^(sw)$/.test(a)) {
			that.size.width = os.width + ox;
			that.size.height = os.height + oy;
			that.position.left = op.left - ox;
		}
		else {
			that.size.width = os.width + ox;
			that.size.height = os.height + oy;
			that.position.top = op.top - oy;
			that.position.left = op.left - ox;
		}
	}

});

var num = function(v) {
	return parseInt(v, 10) || 0;
};

var isNumber = function(value) {
	return !isNaN(parseInt(value, 10));
};

})(jQuery);
(function( $, undefined ) {

$.widget("ui.selectable", $.ui.mouse, {
	version: "1.9.2",
	options: {
		appendTo: 'body',
		autoRefresh: true,
		distance: 0,
		filter: '*',
		tolerance: 'touch'
	},
	_create: function() {
		var that = this;

		this.element.addClass("ui-selectable");

		this.dragged = false;

		// cache selectee children based on filter
		var selectees;
		this.refresh = function() {
			selectees = $(that.options.filter, that.element[0]);
			selectees.addClass("ui-selectee");
			selectees.each(function() {
				var $this = $(this);
				var pos = $this.offset();
				$.data(this, "selectable-item", {
					element: this,
					$element: $this,
					left: pos.left,
					top: pos.top,
					right: pos.left + $this.outerWidth(),
					bottom: pos.top + $this.outerHeight(),
					startselected: false,
					selected: $this.hasClass('ui-selected'),
					selecting: $this.hasClass('ui-selecting'),
					unselecting: $this.hasClass('ui-unselecting')
				});
			});
		};
		this.refresh();

		this.selectees = selectees.addClass("ui-selectee");

		this._mouseInit();

		this.helper = $("<div class='ui-selectable-helper'></div>");
	},

	_destroy: function() {
		this.selectees
			.removeClass("ui-selectee")
			.removeData("selectable-item");
		this.element
			.removeClass("ui-selectable ui-selectable-disabled");
		this._mouseDestroy();
	},

	_mouseStart: function(event) {
		var that = this;

		this.opos = [event.pageX, event.pageY];

		if (this.options.disabled)
			return;

		var options = this.options;

		this.selectees = $(options.filter, this.element[0]);

		this._trigger("start", event);

		$(options.appendTo).append(this.helper);
		// position helper (lasso)
		this.helper.css({
			"left": event.clientX,
			"top": event.clientY,
			"width": 0,
			"height": 0
		});

		if (options.autoRefresh) {
			this.refresh();
		}

		this.selectees.filter('.ui-selected').each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.startselected = true;
			if (!event.metaKey && !event.ctrlKey) {
				selectee.$element.removeClass('ui-selected');
				selectee.selected = false;
				selectee.$element.addClass('ui-unselecting');
				selectee.unselecting = true;
				// selectable UNSELECTING callback
				that._trigger("unselecting", event, {
					unselecting: selectee.element
				});
			}
		});

		$(event.target).parents().andSelf().each(function() {
			var selectee = $.data(this, "selectable-item");
			if (selectee) {
				var doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass('ui-selected');
				selectee.$element
					.removeClass(doSelect ? "ui-unselecting" : "ui-selected")
					.addClass(doSelect ? "ui-selecting" : "ui-unselecting");
				selectee.unselecting = !doSelect;
				selectee.selecting = doSelect;
				selectee.selected = doSelect;
				// selectable (UN)SELECTING callback
				if (doSelect) {
					that._trigger("selecting", event, {
						selecting: selectee.element
					});
				} else {
					that._trigger("unselecting", event, {
						unselecting: selectee.element
					});
				}
				return false;
			}
		});

	},

	_mouseDrag: function(event) {
		var that = this;
		this.dragged = true;

		if (this.options.disabled)
			return;

		var options = this.options;

		var x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;
		if (x1 > x2) { var tmp = x2; x2 = x1; x1 = tmp; }
		if (y1 > y2) { var tmp = y2; y2 = y1; y1 = tmp; }
		this.helper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});

		this.selectees.each(function() {
			var selectee = $.data(this, "selectable-item");
			//prevent helper from being selected if appendTo: selectable
			if (!selectee || selectee.element == that.element[0])
				return;
			var hit = false;
			if (options.tolerance == 'touch') {
				hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );
			} else if (options.tolerance == 'fit') {
				hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
			}

			if (hit) {
				// SELECT
				if (selectee.selected) {
					selectee.$element.removeClass('ui-selected');
					selectee.selected = false;
				}
				if (selectee.unselecting) {
					selectee.$element.removeClass('ui-unselecting');
					selectee.unselecting = false;
				}
				if (!selectee.selecting) {
					selectee.$element.addClass('ui-selecting');
					selectee.selecting = true;
					// selectable SELECTING callback
					that._trigger("selecting", event, {
						selecting: selectee.element
					});
				}
			} else {
				// UNSELECT
				if (selectee.selecting) {
					if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
						selectee.$element.removeClass('ui-selecting');
						selectee.selecting = false;
						selectee.$element.addClass('ui-selected');
						selectee.selected = true;
					} else {
						selectee.$element.removeClass('ui-selecting');
						selectee.selecting = false;
						if (selectee.startselected) {
							selectee.$element.addClass('ui-unselecting');
							selectee.unselecting = true;
						}
						// selectable UNSELECTING callback
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
				if (selectee.selected) {
					if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
						selectee.$element.removeClass('ui-selected');
						selectee.selected = false;

						selectee.$element.addClass('ui-unselecting');
						selectee.unselecting = true;
						// selectable UNSELECTING callback
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
			}
		});

		return false;
	},

	_mouseStop: function(event) {
		var that = this;

		this.dragged = false;

		var options = this.options;

		$('.ui-unselecting', this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass('ui-unselecting');
			selectee.unselecting = false;
			selectee.startselected = false;
			that._trigger("unselected", event, {
				unselected: selectee.element
			});
		});
		$('.ui-selecting', this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass('ui-selecting').addClass('ui-selected');
			selectee.selecting = false;
			selectee.selected = true;
			selectee.startselected = true;
			that._trigger("selected", event, {
				selected: selectee.element
			});
		});
		this._trigger("stop", event);

		this.helper.remove();

		return false;
	}

});

})(jQuery);
(function( $, undefined ) {

// number of pages in a slider
// (how many times can you page up/down to go through the whole range)
var numPages = 5;

$.widget( "ui.slider", $.ui.mouse, {
	version: "1.9.2",
	widgetEventPrefix: "slide",

	options: {
		animate: false,
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null
	},

	_create: function() {
		var i, handleCount,
			o = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
			handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
			handles = [];

		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();

		this.element
			.addClass( "ui-slider" +
				" ui-slider-" + this.orientation +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" +
				( o.disabled ? " ui-slider-disabled ui-disabled" : "" ) );

		this.range = $([]);

		if ( o.range ) {
			if ( o.range === true ) {
				if ( !o.values ) {
					o.values = [ this._valueMin(), this._valueMin() ];
				}
				if ( o.values.length && o.values.length !== 2 ) {
					o.values = [ o.values[0], o.values[0] ];
				}
			}

			this.range = $( "<div></div>" )
				.appendTo( this.element )
				.addClass( "ui-slider-range" +
				// note: this isn't the most fittingly semantic framework class for this element,
				// but worked best visually with a variety of themes
				" ui-widget-header" +
				( ( o.range === "min" || o.range === "max" ) ? " ui-slider-range-" + o.range : "" ) );
		}

		handleCount = ( o.values && o.values.length ) || 1;

		for ( i = existingHandles.length; i < handleCount; i++ ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );

		this.handle = this.handles.eq( 0 );

		this.handles.add( this.range ).filter( "a" )
			.click(function( event ) {
				event.preventDefault();
			})
			.mouseenter(function() {
				if ( !o.disabled ) {
					$( this ).addClass( "ui-state-hover" );
				}
			})
			.mouseleave(function() {
				$( this ).removeClass( "ui-state-hover" );
			})
			.focus(function() {
				if ( !o.disabled ) {
					$( ".ui-slider .ui-state-focus" ).removeClass( "ui-state-focus" );
					$( this ).addClass( "ui-state-focus" );
				} else {
					$( this ).blur();
				}
			})
			.blur(function() {
				$( this ).removeClass( "ui-state-focus" );
			});

		this.handles.each(function( i ) {
			$( this ).data( "ui-slider-handle-index", i );
		});

		this._on( this.handles, {
			keydown: function( event ) {
				var allowed, curVal, newVal, step,
					index = $( event.target ).data( "ui-slider-handle-index" );

				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
					case $.ui.keyCode.END:
					case $.ui.keyCode.PAGE_UP:
					case $.ui.keyCode.PAGE_DOWN:
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						event.preventDefault();
						if ( !this._keySliding ) {
							this._keySliding = true;
							$( event.target ).addClass( "ui-state-active" );
							allowed = this._start( event, index );
							if ( allowed === false ) {
								return;
							}
						}
						break;
				}

				step = this.options.step;
				if ( this.options.values && this.options.values.length ) {
					curVal = newVal = this.values( index );
				} else {
					curVal = newVal = this.value();
				}

				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
						newVal = this._valueMin();
						break;
					case $.ui.keyCode.END:
						newVal = this._valueMax();
						break;
					case $.ui.keyCode.PAGE_UP:
						newVal = this._trimAlignValue( curVal + ( (this._valueMax() - this._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.PAGE_DOWN:
						newVal = this._trimAlignValue( curVal - ( (this._valueMax() - this._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
						if ( curVal === this._valueMax() ) {
							return;
						}
						newVal = this._trimAlignValue( curVal + step );
						break;
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						if ( curVal === this._valueMin() ) {
							return;
						}
						newVal = this._trimAlignValue( curVal - step );
						break;
				}

				this._slide( event, index, newVal );
			},
			keyup: function( event ) {
				var index = $( event.target ).data( "ui-slider-handle-index" );

				if ( this._keySliding ) {
					this._keySliding = false;
					this._stop( event, index );
					this._change( event, index );
					$( event.target ).removeClass( "ui-state-active" );
				}
			}
		});

		this._refreshValue();

		this._animateOff = false;
	},

	_destroy: function() {
		this.handles.remove();
		this.range.remove();

		this.element
			.removeClass( "ui-slider" +
				" ui-slider-horizontal" +
				" ui-slider-vertical" +
				" ui-slider-disabled" +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" );

		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
			that = this,
			o = this.options;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		this.handles.each(function( i ) {
			var thisDistance = Math.abs( normValue - that.values(i) );
			if ( distance > thisDistance ) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		});

		// workaround for bug #3736 (if both handles of a range are at 0,
		// the first is always used as the one with least distance,
		// and moving it is obviously prevented by preventing negative ranges)
		if( o.range === true && this.values(1) === o.min ) {
			index += 1;
			closestHandle = $( this.handles[index] );
		}

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		this._handleIndex = index;

		closestHandle
			.addClass( "ui-state-active" )
			.focus();

		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().andSelf().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
				( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
				( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function() {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );

		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this.handles.removeClass( "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},

	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_start: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}
		return this._trigger( "start", event, uiHash );
	},

	_slide: function( event, index, newVal ) {
		var otherVal,
			newValues,
			allowed;

		if ( this.options.values && this.options.values.length ) {
			otherVal = this.values( index ? 0 : 1 );

			if ( ( this.options.values.length === 2 && this.options.range === true ) &&
					( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
				) {
				newVal = otherVal;
			}

			if ( newVal !== this.values( index ) ) {
				newValues = this.values();
				newValues[ index ] = newVal;
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal,
					values: newValues
				} );
				otherVal = this.values( index ? 0 : 1 );
				if ( allowed !== false ) {
					this.values( index, newVal, true );
				}
			}
		} else {
			if ( newVal !== this.value() ) {
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal
				} );
				if ( allowed !== false ) {
					this.value( newVal );
				}
			}
		}
	},

	_stop: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}

		this._trigger( "stop", event, uiHash );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			this._trigger( "change", event, uiHash );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this.options.values && this.options.values.length ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		$.Widget.prototype._setOption.apply( this, arguments );

		switch ( key ) {
			case "disabled":
				if ( value ) {
					this.handles.filter( ".ui-state-focus" ).blur();
					this.handles.removeClass( "ui-state-hover" );
					this.handles.prop( "disabled", true );
					this.element.addClass( "ui-disabled" );
				} else {
					this.handles.prop( "disabled", false );
					this.element.removeClass( "ui-disabled" );
				}
				break;
			case "orientation":
				this._detectOrientation();
				this.element
					.removeClass( "ui-slider-horizontal ui-slider-vertical" )
					.addClass( "ui-slider-" + this.orientation );
				this._refreshValue();
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();
				for ( i = 0; i < valsLength; i += 1 ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
			case "min":
			case "max":
				this._animateOff = true;
				this._refreshValue();
				this._animateOff = false;
				break;
		}
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else {
			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i+= 1) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		}
	},

	// returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = (val - this._valueMin()) % step,
			alignValue = val - valModStep;

		if ( Math.abs(valModStep) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed(5) );
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.options.max;
	},

	_refreshValue: function() {
		var lastValPercent, valPercent, value, valueMin, valueMax,
			oRange = this.options.range,
			o = this.options,
			that = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			_set = {};

		if ( this.options.values && this.options.values.length ) {
			this.handles.each(function( i ) {
				valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;
				_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( that.options.range === true ) {
					if ( that.orientation === "horizontal" ) {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					} else {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					}
				}
				lastValPercent = valPercent;
			});
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
		}
	}

});

}(jQuery));
(function( $, undefined ) {

$.widget("ui.sortable", $.ui.mouse, {
	version: "1.9.2",
	widgetEventPrefix: "sort",
	ready: false,
	options: {
		appendTo: "parent",
		axis: false,
		connectWith: false,
		containment: false,
		cursor: 'auto',
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: "original",
		items: '> *',
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: "default",
		tolerance: "intersect",
		zIndex: 1000
	},
	_create: function() {

		var o = this.options;
		this.containerCache = {};
		this.element.addClass("ui-sortable");

		//Get the items
		this.refresh();

		//Let's determine if the items are being displayed horizontally
		this.floating = this.items.length ? o.axis === 'x' || (/left|right/).test(this.items[0].item.css('float')) || (/inline|table-cell/).test(this.items[0].item.css('display')) : false;

		//Let's determine the parent's offset
		this.offset = this.element.offset();

		//Initialize mouse events for interaction
		this._mouseInit();

		//We're ready to go
		this.ready = true

	},

	_destroy: function() {
		this.element
			.removeClass("ui-sortable ui-sortable-disabled");
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i >= 0; i-- )
			this.items[i].item.removeData(this.widgetName + "-item");

		return this;
	},

	_setOption: function(key, value){
		if ( key === "disabled" ) {
			this.options[ key ] = value;

			this.widget().toggleClass( "ui-sortable-disabled", !!value );
		} else {
			// Don't call widget base _setOption for disable as it adds ui-state-disabled class
			$.Widget.prototype._setOption.apply(this, arguments);
		}
	},

	_mouseCapture: function(event, overrideHandle) {
		var that = this;

		if (this.reverting) {
			return false;
		}

		if(this.options.disabled || this.options.type == 'static') return false;

		//We have to refresh the items data once first
		this._refreshItems(event);

		//Find out if the clicked node (or one of its parents) is a actual item in this.items
		var currentItem = null, nodes = $(event.target).parents().each(function() {
			if($.data(this, that.widgetName + '-item') == that) {
				currentItem = $(this);
				return false;
			}
		});
		if($.data(event.target, that.widgetName + '-item') == that) currentItem = $(event.target);

		if(!currentItem) return false;
		if(this.options.handle && !overrideHandle) {
			var validHandle = false;

			$(this.options.handle, currentItem).find("*").andSelf().each(function() { if(this == event.target) validHandle = true; });
			if(!validHandle) return false;
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function(event, overrideHandle, noActivation) {

		var o = this.options;
		this.currentContainer = this;

		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
		this.refreshPositions();

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		//Cache the helper size
		this._cacheHelperProportions();

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		// Only after we got the offset, we can change the helper's position to absolute
		// TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css("position", "absolute");
		this.cssPosition = this.helper.css("position");

		//Generate the original position
		this.originalPosition = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if 'cursorAt' is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Cache the former DOM position
		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

		//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
		if(this.helper[0] != this.currentItem[0]) {
			this.currentItem.hide();
		}

		//Create the placeholder
		this._createPlaceholder();

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		if(o.cursor) { // cursor option
			if ($('body').css("cursor")) this._storedCursor = $('body').css("cursor");
			$('body').css("cursor", o.cursor);
		}

		if(o.opacity) { // opacity option
			if (this.helper.css("opacity")) this._storedOpacity = this.helper.css("opacity");
			this.helper.css("opacity", o.opacity);
		}

		if(o.zIndex) { // zIndex option
			if (this.helper.css("zIndex")) this._storedZIndex = this.helper.css("zIndex");
			this.helper.css("zIndex", o.zIndex);
		}

		//Prepare scrolling
		if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML')
			this.overflowOffset = this.scrollParent.offset();

		//Call callbacks
		this._trigger("start", event, this._uiHash());

		//Recache the helper size
		if(!this._preserveHelperProportions)
			this._cacheHelperProportions();


		//Post 'activate' events to possible containers
		if(!noActivation) {
			 for (var i = this.containers.length - 1; i >= 0; i--) { this.containers[i]._trigger("activate", event, this._uiHash(this)); }
		}

		//Prepare possible droppables
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		if ($.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);

		this.dragging = true;

		this.helper.addClass("ui-sortable-helper");
		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		return true;

	},

	_mouseDrag: function(event) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		if (!this.lastPositionAbs) {
			this.lastPositionAbs = this.positionAbs;
		}

		//Do scrolling
		if(this.options.scroll) {
			var o = this.options, scrolled = false;
			if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML') {

				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;

				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;

			} else {

				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);

				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);

			}

			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)
				$.ui.ddmanager.prepareOffsets(this, event);
		}

		//Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo("absolute");

		//Set the helper position
		if(!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left+'px';
		if(!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top+'px';

		//Rearrange
		for (var i = this.items.length - 1; i >= 0; i--) {

			//Cache variables and intersection, continue if no intersection
			var item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item);
			if (!intersection) continue;

			// Only put the placeholder inside the current Container, skip all
			// items form other containers. This works because when moving
			// an item from one container to another the
			// currentContainer is switched before the placeholder is moved.
			//
			// Without this moving items in "sub-sortables" can cause the placeholder to jitter
			// beetween the outer and inner container.
			if (item.instance !== this.currentContainer) continue;

			if (itemElement != this.currentItem[0] //cannot intersect with itself
				&&	this.placeholder[intersection == 1 ? "next" : "prev"]()[0] != itemElement //no useless actions that have been done before
				&&	!$.contains(this.placeholder[0], itemElement) //no action if the item moved is the parent of the item checked
				&& (this.options.type == 'semi-dynamic' ? !$.contains(this.element[0], itemElement) : true)
				//&& itemElement.parentNode == this.placeholder[0].parentNode // only rearrange items within the same container
			) {

				this.direction = intersection == 1 ? "down" : "up";

				if (this.options.tolerance == "pointer" || this._intersectsWithSides(item)) {
					this._rearrange(event, item);
				} else {
					break;
				}

				this._trigger("change", event, this._uiHash());
				break;
			}
		}

		//Post events to containers
		this._contactContainers(event);

		//Interconnect with droppables
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		//Call callbacks
		this._trigger('sort', event, this._uiHash());

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function(event, noPropagation) {

		if(!event) return;

		//If we are using droppables, inform the manager about the drop
		if ($.ui.ddmanager && !this.options.dropBehaviour)
			$.ui.ddmanager.drop(this, event);

		if(this.options.revert) {
			var that = this;
			var cur = this.placeholder.offset();

			this.reverting = true;

			$(this.helper).animate({
				left: cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft),
				top: cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop)
			}, parseInt(this.options.revert, 10) || 500, function() {
				that._clear(event);
			});
		} else {
			this._clear(event, noPropagation);
		}

		return false;

	},

	cancel: function() {

		if(this.dragging) {

			this._mouseUp({ target: null });

			if(this.options.helper == "original")
				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
			else
				this.currentItem.show();

			//Post deactivating events to containers
			for (var i = this.containers.length - 1; i >= 0; i--){
				this.containers[i]._trigger("deactivate", null, this._uiHash(this));
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", null, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		if (this.placeholder) {
			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			if(this.placeholder[0].parentNode) this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
			if(this.options.helper != "original" && this.helper && this.helper[0].parentNode) this.helper.remove();

			$.extend(this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			});

			if(this.domPosition.prev) {
				$(this.domPosition.prev).after(this.currentItem);
			} else {
				$(this.domPosition.parent).prepend(this.currentItem);
			}
		}

		return this;

	},

	serialize: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected);
		var str = []; o = o || {};

		$(items).each(function() {
			var res = ($(o.item || this).attr(o.attribute || 'id') || '').match(o.expression || (/(.+)[-=_](.+)/));
			if(res) str.push((o.key || res[1]+'[]')+'='+(o.key && o.expression ? res[1] : res[2]));
		});

		if(!str.length && o.key) {
			str.push(o.key + '=');
		}

		return str.join('&');

	},

	toArray: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected);
		var ret = []; o = o || {};

		items.each(function() { ret.push($(o.item || this).attr(o.attribute || 'id') || ''); });
		return ret;

	},

	/* Be careful with the following core functions */
	_intersectsWith: function(item) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height;

		var l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height;

		var dyClick = this.offset.click.top,
			dxClick = this.offset.click.left;

		var isOverElement = (y1 + dyClick) > t && (y1 + dyClick) < b && (x1 + dxClick) > l && (x1 + dxClick) < r;

		if(	   this.options.tolerance == "pointer"
			|| this.options.forcePointerForContainers
			|| (this.options.tolerance != "pointer" && this.helperProportions[this.floating ? 'width' : 'height'] > item[this.floating ? 'width' : 'height'])
		) {
			return isOverElement;
		} else {

			return (l < x1 + (this.helperProportions.width / 2) // Right Half
				&& x2 - (this.helperProportions.width / 2) < r // Left Half
				&& t < y1 + (this.helperProportions.height / 2) // Bottom Half
				&& y2 - (this.helperProportions.height / 2) < b ); // Top Half

		}
	},

	_intersectsWithPointer: function(item) {

		var isOverElementHeight = (this.options.axis === 'x') || $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
			isOverElementWidth = (this.options.axis === 'y') || $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
			isOverElement = isOverElementHeight && isOverElementWidth,
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (!isOverElement)
			return false;

		return this.floating ?
			( ((horizontalDirection && horizontalDirection == "right") || verticalDirection == "down") ? 2 : 1 )
			: ( verticalDirection && (verticalDirection == "down" ? 2 : 1) );

	},

	_intersectsWithSides: function(item) {

		var isOverBottomHalf = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
			isOverRightHalf = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (this.floating && horizontalDirection) {
			return ((horizontalDirection == "right" && isOverRightHalf) || (horizontalDirection == "left" && !isOverRightHalf));
		} else {
			return verticalDirection && ((verticalDirection == "down" && isOverBottomHalf) || (verticalDirection == "up" && !isOverBottomHalf));
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta != 0 && (delta > 0 ? "down" : "up");
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta != 0 && (delta > 0 ? "right" : "left");
	},

	refresh: function(event) {
		this._refreshItems(event);
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor == String
			? [options.connectWith]
			: options.connectWith;
	},

	_getItemsAsjQuery: function(connected) {

		var items = [];
		var queries = [];
		var connectWith = this._connectWith();

		if(connectWith && connected) {
			for (var i = connectWith.length - 1; i >= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j >= 0; j--){
					var inst = $.data(cur[j], this.widgetName);
					if(inst && inst != this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), inst]);
					}
				};
			};
		}

		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), this]);

		for (var i = queries.length - 1; i >= 0; i--){
			queries[i][0].each(function() {
				items.push(this);
			});
		};

		return $(items);

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

		this.items = $.grep(this.items, function (item) {
			for (var j=0; j < list.length; j++) {
				if(list[j] == item.item[0])
					return false;
			};
			return true;
		});

	},

	_refreshItems: function(event) {

		this.items = [];
		this.containers = [this];
		var items = this.items;
		var queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]];
		var connectWith = this._connectWith();

		if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
			for (var i = connectWith.length - 1; i >= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j >= 0; j--){
					var inst = $.data(cur[j], this.widgetName);
					if(inst && inst != this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
						this.containers.push(inst);
					}
				};
			};
		}

		for (var i = queries.length - 1; i >= 0; i--) {
			var targetData = queries[i][1];
			var _queries = queries[i][0];

			for (var j=0, queriesLength = _queries.length; j < queriesLength; j++) {
				var item = $(_queries[j]);

				item.data(this.widgetName + '-item', targetData); // Data for target checking (mouse manager)

				items.push({
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				});
			};
		};

	},

	refreshPositions: function(fast) {

		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
		if(this.offsetParent && this.helper) {
			this.offset.parent = this._getParentOffset();
		}

		for (var i = this.items.length - 1; i >= 0; i--){
			var item = this.items[i];

			//We ignore calculating positions of all connected containers when we're not over them
			if(item.instance != this.currentContainer && this.currentContainer && item.item[0] != this.currentItem[0])
				continue;

			var t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

			if (!fast) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			var p = t.offset();
			item.left = p.left;
			item.top = p.top;
		};

		if(this.options.custom && this.options.custom.refreshContainers) {
			this.options.custom.refreshContainers.call(this);
		} else {
			for (var i = this.containers.length - 1; i >= 0; i--){
				var p = this.containers[i].element.offset();
				this.containers[i].containerCache.left = p.left;
				this.containers[i].containerCache.top = p.top;
				this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();
				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
			};
		}

		return this;
	},

	_createPlaceholder: function(that) {
		that = that || this;
		var o = that.options;

		if(!o.placeholder || o.placeholder.constructor == String) {
			var className = o.placeholder;
			o.placeholder = {
				element: function() {

					var el = $(document.createElement(that.currentItem[0].nodeName))
						.addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")
						.removeClass("ui-sortable-helper")[0];

					if(!className)
						el.style.visibility = "hidden";

					return el;
				},
				update: function(container, p) {

					// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
					if(className && !o.forcePlaceholderSize) return;

					//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
					if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css('paddingTop')||0, 10) - parseInt(that.currentItem.css('paddingBottom')||0, 10)); };
					if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css('paddingLeft')||0, 10) - parseInt(that.currentItem.css('paddingRight')||0, 10)); };
				}
			};
		}

		//Create the placeholder
		that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

		//Append it after the actual current item
		that.currentItem.after(that.placeholder);

		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
		o.placeholder.update(that, that.placeholder);

	},

	_contactContainers: function(event) {

		// get innermost container that intersects with item
		var innermostContainer = null, innermostIndex = null;


		for (var i = this.containers.length - 1; i >= 0; i--){

			// never consider a container that's located within the item itself
			if($.contains(this.currentItem[0], this.containers[i].element[0]))
				continue;

			if(this._intersectsWith(this.containers[i].containerCache)) {

				// if we've already found a container and it's more "inner" than this, then continue
				if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0]))
					continue;

				innermostContainer = this.containers[i];
				innermostIndex = i;

			} else {
				// container doesn't intersect. trigger "out" event if necessary
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", event, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		// if no intersecting containers found, return
		if(!innermostContainer) return;

		// move the item into the container if it's not there already
		if(this.containers.length === 1) {
			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		} else {

			//When entering a new container, we will find the item with the least distance and append our item near it
			var dist = 10000; var itemWithLeastDistance = null;
			var posProperty = this.containers[innermostIndex].floating ? 'left' : 'top';
			var sizeProperty = this.containers[innermostIndex].floating ? 'width' : 'height';
			var base = this.positionAbs[posProperty] + this.offset.click[posProperty];
			for (var j = this.items.length - 1; j >= 0; j--) {
				if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) continue;
				if(this.items[j].item[0] == this.currentItem[0]) continue;
				var cur = this.items[j].item.offset()[posProperty];
				var nearBottom = false;
				if(Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)){
					nearBottom = true;
					cur += this.items[j][sizeProperty];
				}

				if(Math.abs(cur - base) < dist) {
					dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];
					this.direction = nearBottom ? "up": "down";
				}
			}

			if(!itemWithLeastDistance && !this.options.dropOnEmpty) //Check if dropOnEmpty is enabled
				return;

			this.currentContainer = this.containers[innermostIndex];
			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
			this._trigger("change", event, this._uiHash());
			this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));

			//Update the placeholder
			this.options.placeholder.update(this.currentContainer, this.placeholder);

			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		}


	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper == 'clone' ? this.currentItem.clone() : this.currentItem);

		if(!helper.parents('body').length) //Add the helper to the DOM if that didn't happen already
			$(o.appendTo != 'parent' ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);

		if(helper[0] == this.currentItem[0])
			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };

		if(helper[0].style.width == '' || o.forceHelperSize) helper.width(this.currentItem.width());
		if(helper[0].style.height == '' || o.forceHelperSize) helper.height(this.currentItem.height());

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == 'string') {
			obj = obj.split(' ');
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ('left' in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ('right' in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ('top' in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ('bottom' in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {


		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.ui.ie)) //Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == "relative") {
			var p = this.currentItem.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
			top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == 'parent') o.containment = this.helper[0].parentNode;
		if(o.containment == 'document' || o.containment == 'window') this.containment = [
			0 - this.offset.relative.left - this.offset.parent.left,
			0 - this.offset.relative.top - this.offset.parent.top,
			$(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
			($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment)) {
			var ce = $(o.containment)[0];
			var co = $(o.containment).offset();
			var over = ($(ce).css("overflow") != 'hidden');

			this.containment = [
				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == "absolute" ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent's offset without borders (offset + border)
				- ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent's offset without borders (offset + border)
				- ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		// This is another very weird special case that only happens for relative elements:
		// 1. If the css position is relative
		// 2. and the scroll parent is the document or similar to the offset parent
		// we have to refresh the relative offset during the scroll so there are no jumps
		if(this.cssPosition == 'relative' && !(this.scrollParent[0] != document && this.scrollParent[0] != this.offsetParent[0])) {
			this.offset.relative = this._getRelativeOffset();
		}

		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options

			if(this.containment) {
				if(event.pageX - this.offset.click.left < this.containment[0]) pageX = this.containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top < this.containment[1]) pageY = this.containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left > this.containment[2]) pageX = this.containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top > this.containment[3]) pageY = this.containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				var top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
				pageY = this.containment ? (!(top - this.offset.click.top < this.containment[1] || top - this.offset.click.top > this.containment[3]) ? top : (!(top - this.offset.click.top < this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
				pageX = this.containment ? (!(left - this.offset.click.left < this.containment[0] || left - this.offset.click.left > this.containment[2]) ? left : (!(left - this.offset.click.left < this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent's offset without borders (offset + border)
				+ ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent's offset without borders (offset + border)
				+ ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_rearrange: function(event, i, a, hardRefresh) {

		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction == 'down' ? i.item[0] : i.item[0].nextSibling));

		//Various things done here to improve the performance:
		// 1. we create a setTimeout, that calls refreshPositions
		// 2. on the instance, we have a counter variable, that get's higher after every append
		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
		// 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var counter = this.counter;

		this._delay(function() {
			if(counter == this.counter) this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
		});

	},

	_clear: function(event, noPropagation) {

		this.reverting = false;
		// We delay all events that have to be triggered to after the point where the placeholder has been removed and
		// everything else normalized again
		var delayedTriggers = [];

		// We first have to update the dom position of the actual currentItem
		// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
		if(!this._noFinalSort && this.currentItem.parent().length) this.placeholder.before(this.currentItem);
		this._noFinalSort = null;

		if(this.helper[0] == this.currentItem[0]) {
			for(var i in this._storedCSS) {
				if(this._storedCSS[i] == 'auto' || this._storedCSS[i] == 'static') this._storedCSS[i] = '';
			}
			this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
		} else {
			this.currentItem.show();
		}

		if(this.fromOutside && !noPropagation) delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
		if((this.fromOutside || this.domPosition.prev != this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent != this.currentItem.parent()[0]) && !noPropagation) delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed

		// Check if the items Container has Changed and trigger appropriate
		// events.
		if (this !== this.currentContainer) {
			if(!noPropagation) {
				delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
				delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));
				delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));
			}
		}


		//Post events to containers
		for (var i = this.containers.length - 1; i >= 0; i--){
			if(!noPropagation) delayedTriggers.push((function(c) { return function(event) { c._trigger("deactivate", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
			if(this.containers[i].containerCache.over) {
				delayedTriggers.push((function(c) { return function(event) { c._trigger("out", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
				this.containers[i].containerCache.over = 0;
			}
		}

		//Do what was originally in plugins
		if(this._storedCursor) $('body').css("cursor", this._storedCursor); //Reset cursor
		if(this._storedOpacity) this.helper.css("opacity", this._storedOpacity); //Reset opacity
		if(this._storedZIndex) this.helper.css("zIndex", this._storedZIndex == 'auto' ? '' : this._storedZIndex); //Reset z-index

		this.dragging = false;
		if(this.cancelHelperRemoval) {
			if(!noPropagation) {
				this._trigger("beforeStop", event, this._uiHash());
				for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
				this._trigger("stop", event, this._uiHash());
			}

			this.fromOutside = false;
			return false;
		}

		if(!noPropagation) this._trigger("beforeStop", event, this._uiHash());

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

		if(this.helper[0] != this.currentItem[0]) this.helper.remove(); this.helper = null;

		if(!noPropagation) {
			for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
			this._trigger("stop", event, this._uiHash());
		}

		this.fromOutside = false;
		return true;

	},

	_trigger: function() {
		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
			this.cancel();
		}
	},

	_uiHash: function(_inst) {
		var inst = _inst || this;
		return {
			helper: inst.helper,
			placeholder: inst.placeholder || $([]),
			position: inst.position,
			originalPosition: inst.originalPosition,
			offset: inst.positionAbs,
			item: inst.currentItem,
			sender: _inst ? _inst.element : null
		};
	}

});

})(jQuery);
(function( $ ) {

function modifier( fn ) {
	return function() {
		var previous = this.element.val();
		fn.apply( this, arguments );
		this._refresh();
		if ( previous !== this.element.val() ) {
			this._trigger( "change" );
		}
	};
}

$.widget( "ui.spinner", {
	version: "1.9.2",
	defaultElement: "<input>",
	widgetEventPrefix: "spin",
	options: {
		culture: null,
		icons: {
			down: "ui-icon-triangle-1-s",
			up: "ui-icon-triangle-1-n"
		},
		incremental: true,
		max: null,
		min: null,
		numberFormat: null,
		page: 10,
		step: 1,

		change: null,
		spin: null,
		start: null,
		stop: null
	},

	_create: function() {
		// handle string values that need to be parsed
		this._setOption( "max", this.options.max );
		this._setOption( "min", this.options.min );
		this._setOption( "step", this.options.step );

		// format the value, but don't constrain
		this._value( this.element.val(), true );

		this._draw();
		this._on( this._events );
		this._refresh();

		// turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		});
	},

	_getCreateOptions: function() {
		var options = {},
			element = this.element;

		$.each( [ "min", "max", "step" ], function( i, option ) {
			var value = element.attr( option );
			if ( value !== undefined && value.length ) {
				options[ option ] = value;
			}
		});

		return options;
	},

	_events: {
		keydown: function( event ) {
			if ( this._start( event ) && this._keydown( event ) ) {
				event.preventDefault();
			}
		},
		keyup: "_stop",
		focus: function() {
			this.previous = this.element.val();
		},
		blur: function( event ) {
			if ( this.cancelBlur ) {
				delete this.cancelBlur;
				return;
			}

			this._refresh();
			if ( this.previous !== this.element.val() ) {
				this._trigger( "change", event );
			}
		},
		mousewheel: function( event, delta ) {
			if ( !delta ) {
				return;
			}
			if ( !this.spinning && !this._start( event ) ) {
				return false;
			}

			this._spin( (delta > 0 ? 1 : -1) * this.options.step, event );
			clearTimeout( this.mousewheelTimer );
			this.mousewheelTimer = this._delay(function() {
				if ( this.spinning ) {
					this._stop( event );
				}
			}, 100 );
			event.preventDefault();
		},
		"mousedown .ui-spinner-button": function( event ) {
			var previous;

			// We never want the buttons to have focus; whenever the user is
			// interacting with the spinner, the focus should be on the input.
			// If the input is focused then this.previous is properly set from
			// when the input first received focus. If the input is not focused
			// then we need to set this.previous based on the value before spinning.
			previous = this.element[0] === this.document[0].activeElement ?
				this.previous : this.element.val();
			function checkFocus() {
				var isActive = this.element[0] === this.document[0].activeElement;
				if ( !isActive ) {
					this.element.focus();
					this.previous = previous;
					// support: IE
					// IE sets focus asynchronously, so we need to check if focus
					// moved off of the input because the user clicked on the button.
					this._delay(function() {
						this.previous = previous;
					});
				}
			}

			// ensure focus is on (or stays on) the text field
			event.preventDefault();
			checkFocus.call( this );

			// support: IE
			// IE doesn't prevent moving focus even with event.preventDefault()
			// so we set a flag to know when we should ignore the blur event
			// and check (again) if focus moved off of the input.
			this.cancelBlur = true;
			this._delay(function() {
				delete this.cancelBlur;
				checkFocus.call( this );
			});

			if ( this._start( event ) === false ) {
				return;
			}

			this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
		},
		"mouseup .ui-spinner-button": "_stop",
		"mouseenter .ui-spinner-button": function( event ) {
			// button will add ui-state-active if mouse was down while mouseleave and kept down
			if ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {
				return;
			}

			if ( this._start( event ) === false ) {
				return false;
			}
			this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
		},
		// TODO: do we really want to consider this a stop?
		// shouldn't we just stop the repeater and wait until mouseup before
		// we trigger the stop event?
		"mouseleave .ui-spinner-button": "_stop"
	},

	_draw: function() {
		var uiSpinner = this.uiSpinner = this.element
			.addClass( "ui-spinner-input" )
			.attr( "autocomplete", "off" )
			.wrap( this._uiSpinnerHtml() )
			.parent()
				// add buttons
				.append( this._buttonHtml() );

		this.element.attr( "role", "spinbutton" );

		// button bindings
		this.buttons = uiSpinner.find( ".ui-spinner-button" )
			.attr( "tabIndex", -1 )
			.button()
			.removeClass( "ui-corner-all" );

		// IE 6 doesn't understand height: 50% for the buttons
		// unless the wrapper has an explicit height
		if ( this.buttons.height() > Math.ceil( uiSpinner.height() * 0.5 ) &&
				uiSpinner.height() > 0 ) {
			uiSpinner.height( uiSpinner.height() );
		}

		// disable spinner if element was already disabled
		if ( this.options.disabled ) {
			this.disable();
		}
	},

	_keydown: function( event ) {
		var options = this.options,
			keyCode = $.ui.keyCode;

		switch ( event.keyCode ) {
		case keyCode.UP:
			this._repeat( null, 1, event );
			return true;
		case keyCode.DOWN:
			this._repeat( null, -1, event );
			return true;
		case keyCode.PAGE_UP:
			this._repeat( null, options.page, event );
			return true;
		case keyCode.PAGE_DOWN:
			this._repeat( null, -options.page, event );
			return true;
		}

		return false;
	},

	_uiSpinnerHtml: function() {
		return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
	},

	_buttonHtml: function() {
		return "" +
			"<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" +
				"<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" +
			"</a>" +
			"<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" +
				"<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" +
			"</a>";
	},

	_start: function( event ) {
		if ( !this.spinning && this._trigger( "start", event ) === false ) {
			return false;
		}

		if ( !this.counter ) {
			this.counter = 1;
		}
		this.spinning = true;
		return true;
	},

	_repeat: function( i, steps, event ) {
		i = i || 500;

		clearTimeout( this.timer );
		this.timer = this._delay(function() {
			this._repeat( 40, steps, event );
		}, i );

		this._spin( steps * this.options.step, event );
	},

	_spin: function( step, event ) {
		var value = this.value() || 0;

		if ( !this.counter ) {
			this.counter = 1;
		}

		value = this._adjustValue( value + step * this._increment( this.counter ) );

		if ( !this.spinning || this._trigger( "spin", event, { value: value } ) !== false) {
			this._value( value );
			this.counter++;
		}
	},

	_increment: function( i ) {
		var incremental = this.options.incremental;

		if ( incremental ) {
			return $.isFunction( incremental ) ?
				incremental( i ) :
				Math.floor( i*i*i/50000 - i*i/500 + 17*i/200 + 1 );
		}

		return 1;
	},

	_precision: function() {
		var precision = this._precisionOf( this.options.step );
		if ( this.options.min !== null ) {
			precision = Math.max( precision, this._precisionOf( this.options.min ) );
		}
		return precision;
	},

	_precisionOf: function( num ) {
		var str = num.toString(),
			decimal = str.indexOf( "." );
		return decimal === -1 ? 0 : str.length - decimal - 1;
	},

	_adjustValue: function( value ) {
		var base, aboveMin,
			options = this.options;

		// make sure we're at a valid step
		// - find out where we are relative to the base (min or 0)
		base = options.min !== null ? options.min : 0;
		aboveMin = value - base;
		// - round to the nearest step
		aboveMin = Math.round(aboveMin / options.step) * options.step;
		// - rounding is based on 0, so adjust back to our base
		value = base + aboveMin;

		// fix precision from bad JS floating point math
		value = parseFloat( value.toFixed( this._precision() ) );

		// clamp the value
		if ( options.max !== null && value > options.max) {
			return options.max;
		}
		if ( options.min !== null && value < options.min ) {
			return options.min;
		}

		return value;
	},

	_stop: function( event ) {
		if ( !this.spinning ) {
			return;
		}

		clearTimeout( this.timer );
		clearTimeout( this.mousewheelTimer );
		this.counter = 0;
		this.spinning = false;
		this._trigger( "stop", event );
	},

	_setOption: function( key, value ) {
		if ( key === "culture" || key === "numberFormat" ) {
			var prevValue = this._parse( this.element.val() );
			this.options[ key ] = value;
			this.element.val( this._format( prevValue ) );
			return;
		}

		if ( key === "max" || key === "min" || key === "step" ) {
			if ( typeof value === "string" ) {
				value = this._parse( value );
			}
		}

		this._super( key, value );

		if ( key === "disabled" ) {
			if ( value ) {
				this.element.prop( "disabled", true );
				this.buttons.button( "disable" );
			} else {
				this.element.prop( "disabled", false );
				this.buttons.button( "enable" );
			}
		}
	},

	_setOptions: modifier(function( options ) {
		this._super( options );
		this._value( this.element.val() );
	}),

	_parse: function( val ) {
		if ( typeof val === "string" && val !== "" ) {
			val = window.Globalize && this.options.numberFormat ?
				Globalize.parseFloat( val, 10, this.options.culture ) : +val;
		}
		return val === "" || isNaN( val ) ? null : val;
	},

	_format: function( value ) {
		if ( value === "" ) {
			return "";
		}
		return window.Globalize && this.options.numberFormat ?
			Globalize.format( value, this.options.numberFormat, this.options.culture ) :
			value;
	},

	_refresh: function() {
		this.element.attr({
			"aria-valuemin": this.options.min,
			"aria-valuemax": this.options.max,
			// TODO: what should we do with values that can't be parsed?
			"aria-valuenow": this._parse( this.element.val() )
		});
	},

	// update the value without triggering change
	_value: function( value, allowAny ) {
		var parsed;
		if ( value !== "" ) {
			parsed = this._parse( value );
			if ( parsed !== null ) {
				if ( !allowAny ) {
					parsed = this._adjustValue( parsed );
				}
				value = this._format( parsed );
			}
		}
		this.element.val( value );
		this._refresh();
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-spinner-input" )
			.prop( "disabled", false )
			.removeAttr( "autocomplete" )
			.removeAttr( "role" )
			.removeAttr( "aria-valuemin" )
			.removeAttr( "aria-valuemax" )
			.removeAttr( "aria-valuenow" );
		this.uiSpinner.replaceWith( this.element );
	},

	stepUp: modifier(function( steps ) {
		this._stepUp( steps );
	}),
	_stepUp: function( steps ) {
		this._spin( (steps || 1) * this.options.step );
	},

	stepDown: modifier(function( steps ) {
		this._stepDown( steps );
	}),
	_stepDown: function( steps ) {
		this._spin( (steps || 1) * -this.options.step );
	},

	pageUp: modifier(function( pages ) {
		this._stepUp( (pages || 1) * this.options.page );
	}),

	pageDown: modifier(function( pages ) {
		this._stepDown( (pages || 1) * this.options.page );
	}),

	value: function( newVal ) {
		if ( !arguments.length ) {
			return this._parse( this.element.val() );
		}
		modifier( this._value ).call( this, newVal );
	},

	widget: function() {
		return this.uiSpinner;
	}
});

}( jQuery ) );
(function( $, undefined ) {

var tabId = 0,
	rhash = /#.*$/;

function getNextTabId() {
	return ++tabId;
}

function isLocal( anchor ) {
	return anchor.hash.length > 1 &&
		anchor.href.replace( rhash, "" ) ===
			location.href.replace( rhash, "" )
				// support: Safari 5.1
				// Safari 5.1 doesn't encode spaces in window.location
				// but it does encode spaces from anchors (#8777)
				.replace( /\s/g, "%20" );
}

$.widget( "ui.tabs", {
	version: "1.9.2",
	delay: 300,
	options: {
		active: null,
		collapsible: false,
		event: "click",
		heightStyle: "content",
		hide: null,
		show: null,

		// callbacks
		activate: null,
		beforeActivate: null,
		beforeLoad: null,
		load: null
	},

	_create: function() {
		var that = this,
			options = this.options,
			active = options.active,
			locationHash = location.hash.substring( 1 );

		this.running = false;

		this.element
			.addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" )
			.toggleClass( "ui-tabs-collapsible", options.collapsible )
			// Prevent users from focusing disabled tabs via click
			.delegate( ".ui-tabs-nav > li", "mousedown" + this.eventNamespace, function( event ) {
				if ( $( this ).is( ".ui-state-disabled" ) ) {
					event.preventDefault();
				}
			})
			// support: IE <9
			// Preventing the default action in mousedown doesn't prevent IE
			// from focusing the element, so if the anchor gets focused, blur.
			// We don't have to worry about focusing the previously focused
			// element since clicking on a non-focusable element should focus
			// the body anyway.
			.delegate( ".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
				if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
					this.blur();
				}
			});

		this._processTabs();

		if ( active === null ) {
			// check the fragment identifier in the URL
			if ( locationHash ) {
				this.tabs.each(function( i, tab ) {
					if ( $( tab ).attr( "aria-controls" ) === locationHash ) {
						active = i;
						return false;
					}
				});
			}

			// check for a tab marked active via a class
			if ( active === null ) {
				active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );
			}

			// no active tab, set to false
			if ( active === null || active === -1 ) {
				active = this.tabs.length ? 0 : false;
			}
		}

		// handle numbers: negative, out of range
		if ( active !== false ) {
			active = this.tabs.index( this.tabs.eq( active ) );
			if ( active === -1 ) {
				active = options.collapsible ? false : 0;
			}
		}
		options.active = active;

		// don't allow collapsible: false and active: false
		if ( !options.collapsible && options.active === false && this.anchors.length ) {
			options.active = 0;
		}

		// Take disabling tabs via class attribute from HTML
		// into account and update option properly.
		if ( $.isArray( options.disabled ) ) {
			options.disabled = $.unique( options.disabled.concat(
				$.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
					return that.tabs.index( li );
				})
			) ).sort();
		}

		// check for length avoids error when initializing empty list
		if ( this.options.active !== false && this.anchors.length ) {
			this.active = this._findActive( this.options.active );
		} else {
			this.active = $();
		}

		this._refresh();

		if ( this.active.length ) {
			this.load( options.active );
		}
	},

	_getCreateEventData: function() {
		return {
			tab: this.active,
			panel: !this.active.length ? $() : this._getPanelForTab( this.active )
		};
	},

	_tabKeydown: function( event ) {
		var focusedTab = $( this.document[0].activeElement ).closest( "li" ),
			selectedIndex = this.tabs.index( focusedTab ),
			goingForward = true;

		if ( this._handlePageNav( event ) ) {
			return;
		}

		switch ( event.keyCode ) {
			case $.ui.keyCode.RIGHT:
			case $.ui.keyCode.DOWN:
				selectedIndex++;
				break;
			case $.ui.keyCode.UP:
			case $.ui.keyCode.LEFT:
				goingForward = false;
				selectedIndex--;
				break;
			case $.ui.keyCode.END:
				selectedIndex = this.anchors.length - 1;
				break;
			case $.ui.keyCode.HOME:
				selectedIndex = 0;
				break;
			case $.ui.keyCode.SPACE:
				// Activate only, no collapsing
				event.preventDefault();
				clearTimeout( this.activating );
				this._activate( selectedIndex );
				return;
			case $.ui.keyCode.ENTER:
				// Toggle (cancel delayed activation, allow collapsing)
				event.preventDefault();
				clearTimeout( this.activating );
				// Determine if we should collapse or activate
				this._activate( selectedIndex === this.options.active ? false : selectedIndex );
				return;
			default:
				return;
		}

		// Focus the appropriate tab, based on which key was pressed
		event.preventDefault();
		clearTimeout( this.activating );
		selectedIndex = this._focusNextTab( selectedIndex, goingForward );

		// Navigating with control key will prevent automatic activation
		if ( !event.ctrlKey ) {
			// Update aria-selected immediately so that AT think the tab is already selected.
			// Otherwise AT may confuse the user by stating that they need to activate the tab,
			// but the tab will already be activated by the time the announcement finishes.
			focusedTab.attr( "aria-selected", "false" );
			this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );

			this.activating = this._delay(function() {
				this.option( "active", selectedIndex );
			}, this.delay );
		}
	},

	_panelKeydown: function( event ) {
		if ( this._handlePageNav( event ) ) {
			return;
		}

		// Ctrl+up moves focus to the current tab
		if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
			event.preventDefault();
			this.active.focus();
		}
	},

	// Alt+page up/down moves focus to the previous/next tab (and activates)
	_handlePageNav: function( event ) {
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
			this._activate( this._focusNextTab( this.options.active - 1, false ) );
			return true;
		}
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
			this._activate( this._focusNextTab( this.options.active + 1, true ) );
			return true;
		}
	},

	_findNextTab: function( index, goingForward ) {
		var lastTabIndex = this.tabs.length - 1;

		function constrain() {
			if ( index > lastTabIndex ) {
				index = 0;
			}
			if ( index < 0 ) {
				index = lastTabIndex;
			}
			return index;
		}

		while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
			index = goingForward ? index + 1 : index - 1;
		}

		return index;
	},

	_focusNextTab: function( index, goingForward ) {
		index = this._findNextTab( index, goingForward );
		this.tabs.eq( index ).focus();
		return index;
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "disabled" ) {
			// don't use the widget factory's disabled handling
			this._setupDisabled( value );
			return;
		}

		this._super( key, value);

		if ( key === "collapsible" ) {
			this.element.toggleClass( "ui-tabs-collapsible", value );
			// Setting collapsible: false while collapsed; open first panel
			if ( !value && this.options.active === false ) {
				this._activate( 0 );
			}
		}

		if ( key === "event" ) {
			this._setupEvents( value );
		}

		if ( key === "heightStyle" ) {
			this._setupHeightStyle( value );
		}
	},

	_tabId: function( tab ) {
		return tab.attr( "aria-controls" ) || "ui-tabs-" + getNextTabId();
	},

	_sanitizeSelector: function( hash ) {
		return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
	},

	refresh: function() {
		var options = this.options,
			lis = this.tablist.children( ":has(a[href])" );

		// get disabled tabs from class attribute from HTML
		// this will get converted to a boolean if needed in _refresh()
		options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
			return lis.index( tab );
		});

		this._processTabs();

		// was collapsed or no tabs
		if ( options.active === false || !this.anchors.length ) {
			options.active = false;
			this.active = $();
		// was active, but active tab is gone
		} else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {
			// all remaining tabs are disabled
			if ( this.tabs.length === options.disabled.length ) {
				options.active = false;
				this.active = $();
			// activate previous tab
			} else {
				this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
			}
		// was active, active tab still exists
		} else {
			// make sure active index is correct
			options.active = this.tabs.index( this.active );
		}

		this._refresh();
	},

	_refresh: function() {
		this._setupDisabled( this.options.disabled );
		this._setupEvents( this.options.event );
		this._setupHeightStyle( this.options.heightStyle );

		this.tabs.not( this.active ).attr({
			"aria-selected": "false",
			tabIndex: -1
		});
		this.panels.not( this._getPanelForTab( this.active ) )
			.hide()
			.attr({
				"aria-expanded": "false",
				"aria-hidden": "true"
			});

		// Make sure one tab is in the tab order
		if ( !this.active.length ) {
			this.tabs.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active
				.addClass( "ui-tabs-active ui-state-active" )
				.attr({
					"aria-selected": "true",
					tabIndex: 0
				});
			this._getPanelForTab( this.active )
				.show()
				.attr({
					"aria-expanded": "true",
					"aria-hidden": "false"
				});
		}
	},

	_processTabs: function() {
		var that = this;

		this.tablist = this._getList()
			.addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
			.attr( "role", "tablist" );

		this.tabs = this.tablist.find( "> li:has(a[href])" )
			.addClass( "ui-state-default ui-corner-top" )
			.attr({
				role: "tab",
				tabIndex: -1
			});

		this.anchors = this.tabs.map(function() {
				return $( "a", this )[ 0 ];
			})
			.addClass( "ui-tabs-anchor" )
			.attr({
				role: "presentation",
				tabIndex: -1
			});

		this.panels = $();

		this.anchors.each(function( i, anchor ) {
			var selector, panel, panelId,
				anchorId = $( anchor ).uniqueId().attr( "id" ),
				tab = $( anchor ).closest( "li" ),
				originalAriaControls = tab.attr( "aria-controls" );

			// inline tab
			if ( isLocal( anchor ) ) {
				selector = anchor.hash;
				panel = that.element.find( that._sanitizeSelector( selector ) );
			// remote tab
			} else {
				panelId = that._tabId( tab );
				selector = "#" + panelId;
				panel = that.element.find( selector );
				if ( !panel.length ) {
					panel = that._createPanel( panelId );
					panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
				}
				panel.attr( "aria-live", "polite" );
			}

			if ( panel.length) {
				that.panels = that.panels.add( panel );
			}
			if ( originalAriaControls ) {
				tab.data( "ui-tabs-aria-controls", originalAriaControls );
			}
			tab.attr({
				"aria-controls": selector.substring( 1 ),
				"aria-labelledby": anchorId
			});
			panel.attr( "aria-labelledby", anchorId );
		});

		this.panels
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
			.attr( "role", "tabpanel" );
	},

	// allow overriding how to find the list for rare usage scenarios (#7715)
	_getList: function() {
		return this.element.find( "ol,ul" ).eq( 0 );
	},

	_createPanel: function( id ) {
		return $( "<div>" )
			.attr( "id", id )
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
			.data( "ui-tabs-destroy", true );
	},

	_setupDisabled: function( disabled ) {
		if ( $.isArray( disabled ) ) {
			if ( !disabled.length ) {
				disabled = false;
			} else if ( disabled.length === this.anchors.length ) {
				disabled = true;
			}
		}

		// disable tabs
		for ( var i = 0, li; ( li = this.tabs[ i ] ); i++ ) {
			if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
				$( li )
					.addClass( "ui-state-disabled" )
					.attr( "aria-disabled", "true" );
			} else {
				$( li )
					.removeClass( "ui-state-disabled" )
					.removeAttr( "aria-disabled" );
			}
		}

		this.options.disabled = disabled;
	},

	_setupEvents: function( event ) {
		var events = {
			click: function( event ) {
				event.preventDefault();
			}
		};
		if ( event ) {
			$.each( event.split(" "), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			});
		}

		this._off( this.anchors.add( this.tabs ).add( this.panels ) );
		this._on( this.anchors, events );
		this._on( this.tabs, { keydown: "_tabKeydown" } );
		this._on( this.panels, { keydown: "_panelKeydown" } );

		this._focusable( this.tabs );
		this._hoverable( this.tabs );
	},

	_setupHeightStyle: function( heightStyle ) {
		var maxHeight, overflow,
			parent = this.element.parent();

		if ( heightStyle === "fill" ) {
			// IE 6 treats height like minHeight, so we need to turn off overflow
			// in order to get a reliable height
			// we use the minHeight support test because we assume that only
			// browsers that don't support minHeight will treat height as minHeight
			if ( !$.support.minHeight ) {
				overflow = parent.css( "overflow" );
				parent.css( "overflow", "hidden");
			}
			maxHeight = parent.height();
			this.element.siblings( ":visible" ).each(function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});
			if ( overflow ) {
				parent.css( "overflow", overflow );
			}

			this.element.children().not( this.panels ).each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.panels.each(function() {
				$( this ).height( Math.max( 0, maxHeight -
					$( this ).innerHeight() + $( this ).height() ) );
			})
			.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.panels.each(function() {
				maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
			}).height( maxHeight );
		}
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			anchor = $( event.currentTarget ),
			tab = anchor.closest( "li" ),
			clickedIsActive = tab[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : this._getPanelForTab( tab ),
			toHide = !active.length ? $() : this._getPanelForTab( active ),
			eventData = {
				oldTab: active,
				oldPanel: toHide,
				newTab: collapsing ? $() : tab,
				newPanel: toShow
			};

		event.preventDefault();

		if ( tab.hasClass( "ui-state-disabled" ) ||
				// tab is already loading
				tab.hasClass( "ui-tabs-loading" ) ||
				// can't switch durning an animation
				this.running ||
				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.tabs.index( tab );

		this.active = clickedIsActive ? $() : tab;
		if ( this.xhr ) {
			this.xhr.abort();
		}

		if ( !toHide.length && !toShow.length ) {
			$.error( "jQuery UI Tabs: Mismatching fragment identifier." );
		}

		if ( toShow.length ) {
			this.load( this.tabs.index( tab ), event );
		}
		this._toggle( event, eventData );
	},

	// handles show/hide for selecting tabs
	_toggle: function( event, eventData ) {
		var that = this,
			toShow = eventData.newPanel,
			toHide = eventData.oldPanel;

		this.running = true;

		function complete() {
			that.running = false;
			that._trigger( "activate", event, eventData );
		}

		function show() {
			eventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );

			if ( toShow.length && that.options.show ) {
				that._show( toShow, that.options.show, complete );
			} else {
				toShow.show();
				complete();
			}
		}

		// start out by hiding, then showing, then completing
		if ( toHide.length && this.options.hide ) {
			this._hide( toHide, this.options.hide, function() {
				eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
				show();
			});
		} else {
			eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
			toHide.hide();
			show();
		}

		toHide.attr({
			"aria-expanded": "false",
			"aria-hidden": "true"
		});
		eventData.oldTab.attr( "aria-selected", "false" );
		// If we're switching tabs, remove the old tab from the tab order.
		// If we're opening from collapsed state, remove the previous tab from the tab order.
		// If we're collapsing, then keep the collapsing tab in the tab order.
		if ( toShow.length && toHide.length ) {
			eventData.oldTab.attr( "tabIndex", -1 );
		} else if ( toShow.length ) {
			this.tabs.filter(function() {
				return $( this ).attr( "tabIndex" ) === 0;
			})
			.attr( "tabIndex", -1 );
		}

		toShow.attr({
			"aria-expanded": "true",
			"aria-hidden": "false"
		});
		eventData.newTab.attr({
			"aria-selected": "true",
			tabIndex: 0
		});
	},

	_activate: function( index ) {
		var anchor,
			active = this._findActive( index );

		// trying to activate the already active panel
		if ( active[ 0 ] === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the current active header
		if ( !active.length ) {
			active = this.active;
		}

		anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
		this._eventHandler({
			target: anchor,
			currentTarget: anchor,
			preventDefault: $.noop
		});
	},

	_findActive: function( index ) {
		return index === false ? $() : this.tabs.eq( index );
	},

	_getIndex: function( index ) {
		// meta-function to give users option to provide a href string instead of a numerical index.
		if ( typeof index === "string" ) {
			index = this.anchors.index( this.anchors.filter( "[href$='" + index + "']" ) );
		}

		return index;
	},

	_destroy: function() {
		if ( this.xhr ) {
			this.xhr.abort();
		}

		this.element.removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" );

		this.tablist
			.removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
			.removeAttr( "role" );

		this.anchors
			.removeClass( "ui-tabs-anchor" )
			.removeAttr( "role" )
			.removeAttr( "tabIndex" )
			.removeData( "href.tabs" )
			.removeData( "load.tabs" )
			.removeUniqueId();

		this.tabs.add( this.panels ).each(function() {
			if ( $.data( this, "ui-tabs-destroy" ) ) {
				$( this ).remove();
			} else {
				$( this )
					.removeClass( "ui-state-default ui-state-active ui-state-disabled " +
						"ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel" )
					.removeAttr( "tabIndex" )
					.removeAttr( "aria-live" )
					.removeAttr( "aria-busy" )
					.removeAttr( "aria-selected" )
					.removeAttr( "aria-labelledby" )
					.removeAttr( "aria-hidden" )
					.removeAttr( "aria-expanded" )
					.removeAttr( "role" );
			}
		});

		this.tabs.each(function() {
			var li = $( this ),
				prev = li.data( "ui-tabs-aria-controls" );
			if ( prev ) {
				li.attr( "aria-controls", prev );
			} else {
				li.removeAttr( "aria-controls" );
			}
		});

		this.panels.show();

		if ( this.options.heightStyle !== "content" ) {
			this.panels.css( "height", "" );
		}
	},

	enable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === false ) {
			return;
		}

		if ( index === undefined ) {
			disabled = false;
		} else {
			index = this._getIndex( index );
			if ( $.isArray( disabled ) ) {
				disabled = $.map( disabled, function( num ) {
					return num !== index ? num : null;
				});
			} else {
				disabled = $.map( this.tabs, function( li, num ) {
					return num !== index ? num : null;
				});
			}
		}
		this._setupDisabled( disabled );
	},

	disable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === true ) {
			return;
		}

		if ( index === undefined ) {
			disabled = true;
		} else {
			index = this._getIndex( index );
			if ( $.inArray( index, disabled ) !== -1 ) {
				return;
			}
			if ( $.isArray( disabled ) ) {
				disabled = $.merge( [ index ], disabled ).sort();
			} else {
				disabled = [ index ];
			}
		}
		this._setupDisabled( disabled );
	},

	load: function( index, event ) {
		index = this._getIndex( index );
		var that = this,
			tab = this.tabs.eq( index ),
			anchor = tab.find( ".ui-tabs-anchor" ),
			panel = this._getPanelForTab( tab ),
			eventData = {
				tab: tab,
				panel: panel
			};

		// not remote
		if ( isLocal( anchor[ 0 ] ) ) {
			return;
		}

		this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );

		// support: jQuery <1.8
		// jQuery <1.8 returns false if the request is canceled in beforeSend,
		// but as of 1.8, $.ajax() always returns a jqXHR object.
		if ( this.xhr && this.xhr.statusText !== "canceled" ) {
			tab.addClass( "ui-tabs-loading" );
			panel.attr( "aria-busy", "true" );

			this.xhr
				.success(function( response ) {
					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						panel.html( response );
						that._trigger( "load", event, eventData );
					}, 1 );
				})
				.complete(function( jqXHR, status ) {
					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						if ( status === "abort" ) {
							that.panels.stop( false, true );
						}

						tab.removeClass( "ui-tabs-loading" );
						panel.removeAttr( "aria-busy" );

						if ( jqXHR === that.xhr ) {
							delete that.xhr;
						}
					}, 1 );
				});
		}
	},

	// TODO: Remove this function in 1.10 when ajaxOptions is removed
	_ajaxSettings: function( anchor, event, eventData ) {
		var that = this;
		return {
			url: anchor.attr( "href" ),
			beforeSend: function( jqXHR, settings ) {
				return that._trigger( "beforeLoad", event,
					$.extend( { jqXHR : jqXHR, ajaxSettings: settings }, eventData ) );
			}
		};
	},

	_getPanelForTab: function( tab ) {
		var id = $( tab ).attr( "aria-controls" );
		return this.element.find( this._sanitizeSelector( "#" + id ) );
	}
});

// DEPRECATED
if ( $.uiBackCompat !== false ) {

	// helper method for a lot of the back compat extensions
	$.ui.tabs.prototype._ui = function( tab, panel ) {
		return {
			tab: tab,
			panel: panel,
			index: this.anchors.index( tab )
		};
	};

	// url method
	$.widget( "ui.tabs", $.ui.tabs, {
		url: function( index, url ) {
			this.anchors.eq( index ).attr( "href", url );
		}
	});

	// TODO: Remove _ajaxSettings() method when removing this extension
	// ajaxOptions and cache options
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			ajaxOptions: null,
			cache: false
		},

		_create: function() {
			this._super();

			var that = this;

			this._on({ tabsbeforeload: function( event, ui ) {
				// tab is already cached
				if ( $.data( ui.tab[ 0 ], "cache.tabs" ) ) {
					event.preventDefault();
					return;
				}

				ui.jqXHR.success(function() {
					if ( that.options.cache ) {
						$.data( ui.tab[ 0 ], "cache.tabs", true );
					}
				});
			}});
		},

		_ajaxSettings: function( anchor, event, ui ) {
			var ajaxOptions = this.options.ajaxOptions;
			return $.extend( {}, ajaxOptions, {
				error: function( xhr, status ) {
					try {
						// Passing index avoid a race condition when this method is
						// called after the user has selected another tab.
						// Pass the anchor that initiated this request allows
						// loadError to manipulate the tab content panel via $(a.hash)
						ajaxOptions.error(
							xhr, status, ui.tab.closest( "li" ).index(), ui.tab[ 0 ] );
					}
					catch ( error ) {}
				}
			}, this._superApply( arguments ) );
		},

		_setOption: function( key, value ) {
			// reset cache if switching from cached to not cached
			if ( key === "cache" && value === false ) {
				this.anchors.removeData( "cache.tabs" );
			}
			this._super( key, value );
		},

		_destroy: function() {
			this.anchors.removeData( "cache.tabs" );
			this._super();
		},

		url: function( index ){
			this.anchors.eq( index ).removeData( "cache.tabs" );
			this._superApply( arguments );
		}
	});

	// abort method
	$.widget( "ui.tabs", $.ui.tabs, {
		abort: function() {
			if ( this.xhr ) {
				this.xhr.abort();
			}
		}
	});

	// spinner
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			spinner: "<em>Loading&#8230;</em>"
		},
		_create: function() {
			this._super();
			this._on({
				tabsbeforeload: function( event, ui ) {
					// Don't react to nested tabs or tabs that don't use a spinner
					if ( event.target !== this.element[ 0 ] ||
							!this.options.spinner ) {
						return;
					}

					var span = ui.tab.find( "span" ),
						html = span.html();
					span.html( this.options.spinner );
					ui.jqXHR.complete(function() {
						span.html( html );
					});
				}
			});
		}
	});

	// enable/disable events
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			enable: null,
			disable: null
		},

		enable: function( index ) {
			var options = this.options,
				trigger;

			if ( index && options.disabled === true ||
					( $.isArray( options.disabled ) && $.inArray( index, options.disabled ) !== -1 ) ) {
				trigger = true;
			}

			this._superApply( arguments );

			if ( trigger ) {
				this._trigger( "enable", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
			}
		},

		disable: function( index ) {
			var options = this.options,
				trigger;

			if ( index && options.disabled === false ||
					( $.isArray( options.disabled ) && $.inArray( index, options.disabled ) === -1 ) ) {
				trigger = true;
			}

			this._superApply( arguments );

			if ( trigger ) {
				this._trigger( "disable", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
			}
		}
	});

	// add/remove methods and events
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			add: null,
			remove: null,
			tabTemplate: "<li><a href='#{href}'><span>#{label}</span></a></li>"
		},

		add: function( url, label, index ) {
			if ( index === undefined ) {
				index = this.anchors.length;
			}

			var doInsertAfter, panel,
				options = this.options,
				li = $( options.tabTemplate
					.replace( /#\{href\}/g, url )
					.replace( /#\{label\}/g, label ) ),
				id = !url.indexOf( "#" ) ?
					url.replace( "#", "" ) :
					this._tabId( li );

			li.addClass( "ui-state-default ui-corner-top" ).data( "ui-tabs-destroy", true );
			li.attr( "aria-controls", id );

			doInsertAfter = index >= this.tabs.length;

			// try to find an existing element before creating a new one
			panel = this.element.find( "#" + id );
			if ( !panel.length ) {
				panel = this._createPanel( id );
				if ( doInsertAfter ) {
					if ( index > 0 ) {
						panel.insertAfter( this.panels.eq( -1 ) );
					} else {
						panel.appendTo( this.element );
					}
				} else {
					panel.insertBefore( this.panels[ index ] );
				}
			}
			panel.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" ).hide();

			if ( doInsertAfter ) {
				li.appendTo( this.tablist );
			} else {
				li.insertBefore( this.tabs[ index ] );
			}

			options.disabled = $.map( options.disabled, function( n ) {
				return n >= index ? ++n : n;
			});

			this.refresh();
			if ( this.tabs.length === 1 && options.active === false ) {
				this.option( "active", 0 );
			}

			this._trigger( "add", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
			return this;
		},

		remove: function( index ) {
			index = this._getIndex( index );
			var options = this.options,
				tab = this.tabs.eq( index ).remove(),
				panel = this._getPanelForTab( tab ).remove();

			// If selected tab was removed focus tab to the right or
			// in case the last tab was removed the tab to the left.
			// We check for more than 2 tabs, because if there are only 2,
			// then when we remove this tab, there will only be one tab left
			// so we don't need to detect which tab to activate.
			if ( tab.hasClass( "ui-tabs-active" ) && this.anchors.length > 2 ) {
				this._activate( index + ( index + 1 < this.anchors.length ? 1 : -1 ) );
			}

			options.disabled = $.map(
				$.grep( options.disabled, function( n ) {
					return n !== index;
				}),
				function( n ) {
					return n >= index ? --n : n;
				});

			this.refresh();

			this._trigger( "remove", null, this._ui( tab.find( "a" )[ 0 ], panel[ 0 ] ) );
			return this;
		}
	});

	// length method
	$.widget( "ui.tabs", $.ui.tabs, {
		length: function() {
			return this.anchors.length;
		}
	});

	// panel ids (idPrefix option + title attribute)
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			idPrefix: "ui-tabs-"
		},

		_tabId: function( tab ) {
			var a = tab.is( "li" ) ? tab.find( "a[href]" ) : tab;
			a = a[0];
			return $( a ).closest( "li" ).attr( "aria-controls" ) ||
				a.title && a.title.replace( /\s/g, "_" ).replace( /[^\w\u00c0-\uFFFF\-]/g, "" ) ||
				this.options.idPrefix + getNextTabId();
		}
	});

	// _createPanel method
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			panelTemplate: "<div></div>"
		},

		_createPanel: function( id ) {
			return $( this.options.panelTemplate )
				.attr( "id", id )
				.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
				.data( "ui-tabs-destroy", true );
		}
	});

	// selected option
	$.widget( "ui.tabs", $.ui.tabs, {
		_create: function() {
			var options = this.options;
			if ( options.active === null && options.selected !== undefined ) {
				options.active = options.selected === -1 ? false : options.selected;
			}
			this._super();
			options.selected = options.active;
			if ( options.selected === false ) {
				options.selected = -1;
			}
		},

		_setOption: function( key, value ) {
			if ( key !== "selected" ) {
				return this._super( key, value );
			}

			var options = this.options;
			this._super( "active", value === -1 ? false : value );
			options.selected = options.active;
			if ( options.selected === false ) {
				options.selected = -1;
			}
		},

		_eventHandler: function() {
			this._superApply( arguments );
			this.options.selected = this.options.active;
			if ( this.options.selected === false ) {
				this.options.selected = -1;
			}
		}
	});

	// show and select event
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			show: null,
			select: null
		},
		_create: function() {
			this._super();
			if ( this.options.active !== false ) {
				this._trigger( "show", null, this._ui(
					this.active.find( ".ui-tabs-anchor" )[ 0 ],
					this._getPanelForTab( this.active )[ 0 ] ) );
			}
		},
		_trigger: function( type, event, data ) {
			var tab, panel,
				ret = this._superApply( arguments );

			if ( !ret ) {
				return false;
			}

			if ( type === "beforeActivate" ) {
				tab = data.newTab.length ? data.newTab : data.oldTab;
				panel = data.newPanel.length ? data.newPanel : data.oldPanel;
				ret = this._super( "select", event, {
					tab: tab.find( ".ui-tabs-anchor" )[ 0],
					panel: panel[ 0 ],
					index: tab.closest( "li" ).index()
				});
			} else if ( type === "activate" && data.newTab.length ) {
				ret = this._super( "show", event, {
					tab: data.newTab.find( ".ui-tabs-anchor" )[ 0 ],
					panel: data.newPanel[ 0 ],
					index: data.newTab.closest( "li" ).index()
				});
			}
			return ret;
		}
	});

	// select method
	$.widget( "ui.tabs", $.ui.tabs, {
		select: function( index ) {
			index = this._getIndex( index );
			if ( index === -1 ) {
				if ( this.options.collapsible && this.options.selected !== -1 ) {
					index = this.options.selected;
				} else {
					return;
				}
			}
			this.anchors.eq( index ).trigger( this.options.event + this.eventNamespace );
		}
	});

	// cookie option
	(function() {

	var listId = 0;

	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			cookie: null // e.g. { expires: 7, path: '/', domain: 'jquery.com', secure: true }
		},
		_create: function() {
			var options = this.options,
				active;
			if ( options.active == null && options.cookie ) {
				active = parseInt( this._cookie(), 10 );
				if ( active === -1 ) {
					active = false;
				}
				options.active = active;
			}
			this._super();
		},
		_cookie: function( active ) {
			var cookie = [ this.cookie ||
				( this.cookie = this.options.cookie.name || "ui-tabs-" + (++listId) ) ];
			if ( arguments.length ) {
				cookie.push( active === false ? -1 : active );
				cookie.push( this.options.cookie );
			}
			return $.cookie.apply( null, cookie );
		},
		_refresh: function() {
			this._super();
			if ( this.options.cookie ) {
				this._cookie( this.options.active, this.options.cookie );
			}
		},
		_eventHandler: function() {
			this._superApply( arguments );
			if ( this.options.cookie ) {
				this._cookie( this.options.active, this.options.cookie );
			}
		},
		_destroy: function() {
			this._super();
			if ( this.options.cookie ) {
				this._cookie( null, this.options.cookie );
			}
		}
	});

	})();

	// load event
	$.widget( "ui.tabs", $.ui.tabs, {
		_trigger: function( type, event, data ) {
			var _data = $.extend( {}, data );
			if ( type === "load" ) {
				_data.panel = _data.panel[ 0 ];
				_data.tab = _data.tab.find( ".ui-tabs-anchor" )[ 0 ];
			}
			return this._super( type, event, _data );
		}
	});

	// fx option
	// The new animation options (show, hide) conflict with the old show callback.
	// The old fx option wins over show/hide anyway (always favor back-compat).
	// If a user wants to use the new animation API, they must give up the old API.
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			fx: null // e.g. { height: "toggle", opacity: "toggle", duration: 200 }
		},

		_getFx: function() {
			var hide, show,
				fx = this.options.fx;

			if ( fx ) {
				if ( $.isArray( fx ) ) {
					hide = fx[ 0 ];
					show = fx[ 1 ];
				} else {
					hide = show = fx;
				}
			}

			return fx ? { show: show, hide: hide } : null;
		},

		_toggle: function( event, eventData ) {
			var that = this,
				toShow = eventData.newPanel,
				toHide = eventData.oldPanel,
				fx = this._getFx();

			if ( !fx ) {
				return this._super( event, eventData );
			}

			that.running = true;

			function complete() {
				that.running = false;
				that._trigger( "activate", event, eventData );
			}

			function show() {
				eventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );

				if ( toShow.length && fx.show ) {
					toShow
						.animate( fx.show, fx.show.duration, function() {
							complete();
						});
				} else {
					toShow.show();
					complete();
				}
			}

			// start out by hiding, then showing, then completing
			if ( toHide.length && fx.hide ) {
				toHide.animate( fx.hide, fx.hide.duration, function() {
					eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
					show();
				});
			} else {
				eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
				toHide.hide();
				show();
			}
		}
	});
}

})( jQuery );
(function( $ ) {

var increments = 0;

function addDescribedBy( elem, id ) {
	var describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ );
	describedby.push( id );
	elem
		.data( "ui-tooltip-id", id )
		.attr( "aria-describedby", $.trim( describedby.join( " " ) ) );
}

function removeDescribedBy( elem ) {
	var id = elem.data( "ui-tooltip-id" ),
		describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ ),
		index = $.inArray( id, describedby );
	if ( index !== -1 ) {
		describedby.splice( index, 1 );
	}

	elem.removeData( "ui-tooltip-id" );
	describedby = $.trim( describedby.join( " " ) );
	if ( describedby ) {
		elem.attr( "aria-describedby", describedby );
	} else {
		elem.removeAttr( "aria-describedby" );
	}
}

$.widget( "ui.tooltip", {
	version: "1.9.2",
	options: {
		content: function() {
			return $( this ).attr( "title" );
		},
		hide: true,
		// Disabled elements have inconsistent behavior across browsers (#8661)
		items: "[title]:not([disabled])",
		position: {
			my: "left top+15",
			at: "left bottom",
			collision: "flipfit flip"
		},
		show: true,
		tooltipClass: null,
		track: false,

		// callbacks
		close: null,
		open: null
	},

	_create: function() {
		this._on({
			mouseover: "open",
			focusin: "open"
		});

		// IDs of generated tooltips, needed for destroy
		this.tooltips = {};
		// IDs of parent tooltips where we removed the title attribute
		this.parents = {};

		if ( this.options.disabled ) {
			this._disable();
		}
	},

	_setOption: function( key, value ) {
		var that = this;

		if ( key === "disabled" ) {
			this[ value ? "_disable" : "_enable" ]();
			this.options[ key ] = value;
			// disable element style changes
			return;
		}

		this._super( key, value );

		if ( key === "content" ) {
			$.each( this.tooltips, function( id, element ) {
				that._updateContent( element );
			});
		}
	},

	_disable: function() {
		var that = this;

		// close open tooltips
		$.each( this.tooltips, function( id, element ) {
			var event = $.Event( "blur" );
			event.target = event.currentTarget = element[0];
			that.close( event, true );
		});

		// remove title attributes to prevent native tooltips
		this.element.find( this.options.items ).andSelf().each(function() {
			var element = $( this );
			if ( element.is( "[title]" ) ) {
				element
					.data( "ui-tooltip-title", element.attr( "title" ) )
					.attr( "title", "" );
			}
		});
	},

	_enable: function() {
		// restore title attributes
		this.element.find( this.options.items ).andSelf().each(function() {
			var element = $( this );
			if ( element.data( "ui-tooltip-title" ) ) {
				element.attr( "title", element.data( "ui-tooltip-title" ) );
			}
		});
	},

	open: function( event ) {
		var that = this,
			target = $( event ? event.target : this.element )
				// we need closest here due to mouseover bubbling,
				// but always pointing at the same event target
				.closest( this.options.items );

		// No element to show a tooltip for or the tooltip is already open
		if ( !target.length || target.data( "ui-tooltip-id" ) ) {
			return;
		}

		if ( target.attr( "title" ) ) {
			target.data( "ui-tooltip-title", target.attr( "title" ) );
		}

		target.data( "ui-tooltip-open", true );

		// kill parent tooltips, custom or native, for hover
		if ( event && event.type === "mouseover" ) {
			target.parents().each(function() {
				var parent = $( this ),
					blurEvent;
				if ( parent.data( "ui-tooltip-open" ) ) {
					blurEvent = $.Event( "blur" );
					blurEvent.target = blurEvent.currentTarget = this;
					that.close( blurEvent, true );
				}
				if ( parent.attr( "title" ) ) {
					parent.uniqueId();
					that.parents[ this.id ] = {
						element: this,
						title: parent.attr( "title" )
					};
					parent.attr( "title", "" );
				}
			});
		}

		this._updateContent( target, event );
	},

	_updateContent: function( target, event ) {
		var content,
			contentOption = this.options.content,
			that = this,
			eventType = event ? event.type : null;

		if ( typeof contentOption === "string" ) {
			return this._open( event, target, contentOption );
		}

		content = contentOption.call( target[0], function( response ) {
			// ignore async response if tooltip was closed already
			if ( !target.data( "ui-tooltip-open" ) ) {
				return;
			}
			// IE may instantly serve a cached response for ajax requests
			// delay this call to _open so the other call to _open runs first
			that._delay(function() {
				// jQuery creates a special event for focusin when it doesn't
				// exist natively. To improve performance, the native event
				// object is reused and the type is changed. Therefore, we can't
				// rely on the type being correct after the event finished
				// bubbling, so we set it back to the previous value. (#8740)
				if ( event ) {
					event.type = eventType;
				}
				this._open( event, target, response );
			});
		});
		if ( content ) {
			this._open( event, target, content );
		}
	},

	_open: function( event, target, content ) {
		var tooltip, events, delayedShow,
			positionOption = $.extend( {}, this.options.position );

		if ( !content ) {
			return;
		}

		// Content can be updated multiple times. If the tooltip already
		// exists, then just update the content and bail.
		tooltip = this._find( target );
		if ( tooltip.length ) {
			tooltip.find( ".ui-tooltip-content" ).html( content );
			return;
		}

		// if we have a title, clear it to prevent the native tooltip
		// we have to check first to avoid defining a title if none exists
		// (we don't want to cause an element to start matching [title])
		//
		// We use removeAttr only for key events, to allow IE to export the correct
		// accessible attributes. For mouse events, set to empty string to avoid
		// native tooltip showing up (happens only when removing inside mouseover).
		if ( target.is( "[title]" ) ) {
			if ( event && event.type === "mouseover" ) {
				target.attr( "title", "" );
			} else {
				target.removeAttr( "title" );
			}
		}

		tooltip = this._tooltip( target );
		addDescribedBy( target, tooltip.attr( "id" ) );
		tooltip.find( ".ui-tooltip-content" ).html( content );

		function position( event ) {
			positionOption.of = event;
			if ( tooltip.is( ":hidden" ) ) {
				return;
			}
			tooltip.position( positionOption );
		}
		if ( this.options.track && event && /^mouse/.test( event.type ) ) {
			this._on( this.document, {
				mousemove: position
			});
			// trigger once to override element-relative positioning
			position( event );
		} else {
			tooltip.position( $.extend({
				of: target
			}, this.options.position ) );
		}

		tooltip.hide();

		this._show( tooltip, this.options.show );
		// Handle tracking tooltips that are shown with a delay (#8644). As soon
		// as the tooltip is visible, position the tooltip using the most recent
		// event.
		if ( this.options.show && this.options.show.delay ) {
			delayedShow = setInterval(function() {
				if ( tooltip.is( ":visible" ) ) {
					position( positionOption.of );
					clearInterval( delayedShow );
				}
			}, $.fx.interval );
		}

		this._trigger( "open", event, { tooltip: tooltip } );

		events = {
			keyup: function( event ) {
				if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
					var fakeEvent = $.Event(event);
					fakeEvent.currentTarget = target[0];
					this.close( fakeEvent, true );
				}
			},
			remove: function() {
				this._removeTooltip( tooltip );
			}
		};
		if ( !event || event.type === "mouseover" ) {
			events.mouseleave = "close";
		}
		if ( !event || event.type === "focusin" ) {
			events.focusout = "close";
		}
		this._on( true, target, events );
	},

	close: function( event ) {
		var that = this,
			target = $( event ? event.currentTarget : this.element ),
			tooltip = this._find( target );

		// disabling closes the tooltip, so we need to track when we're closing
		// to avoid an infinite loop in case the tooltip becomes disabled on close
		if ( this.closing ) {
			return;
		}

		// only set title if we had one before (see comment in _open())
		if ( target.data( "ui-tooltip-title" ) ) {
			target.attr( "title", target.data( "ui-tooltip-title" ) );
		}

		removeDescribedBy( target );

		tooltip.stop( true );
		this._hide( tooltip, this.options.hide, function() {
			that._removeTooltip( $( this ) );
		});

		target.removeData( "ui-tooltip-open" );
		this._off( target, "mouseleave focusout keyup" );
		// Remove 'remove' binding only on delegated targets
		if ( target[0] !== this.element[0] ) {
			this._off( target, "remove" );
		}
		this._off( this.document, "mousemove" );

		if ( event && event.type === "mouseleave" ) {
			$.each( this.parents, function( id, parent ) {
				$( parent.element ).attr( "title", parent.title );
				delete that.parents[ id ];
			});
		}

		this.closing = true;
		this._trigger( "close", event, { tooltip: tooltip } );
		this.closing = false;
	},

	_tooltip: function( element ) {
		var id = "ui-tooltip-" + increments++,
			tooltip = $( "<div>" )
				.attr({
					id: id,
					role: "tooltip"
				})
				.addClass( "ui-tooltip ui-widget ui-corner-all ui-widget-content " +
					( this.options.tooltipClass || "" ) );
		$( "<div>" )
			.addClass( "ui-tooltip-content" )
			.appendTo( tooltip );
		tooltip.appendTo( this.document[0].body );
		if ( $.fn.bgiframe ) {
			tooltip.bgiframe();
		}
		this.tooltips[ id ] = element;
		return tooltip;
	},

	_find: function( target ) {
		var id = target.data( "ui-tooltip-id" );
		return id ? $( "#" + id ) : $();
	},

	_removeTooltip: function( tooltip ) {
		tooltip.remove();
		delete this.tooltips[ tooltip.attr( "id" ) ];
	},

	_destroy: function() {
		var that = this;

		// close open tooltips
		$.each( this.tooltips, function( id, element ) {
			// Delegate to close method to handle common cleanup
			var event = $.Event( "blur" );
			event.target = event.currentTarget = element[0];
			that.close( event, true );

			// Remove immediately; destroying an open tooltip doesn't use the
			// hide animation
			$( "#" + id ).remove();

			// Restore the title
			if ( element.data( "ui-tooltip-title" ) ) {
				element.attr( "title", element.data( "ui-tooltip-title" ) );
				element.removeData( "ui-tooltip-title" );
			}
		});
	}
});

}( jQuery ) );

},{}],25:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v1.7.2
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Wed Mar 21 12:46:34 2012 -0700
 */
(function( window, undefined ) {

// Use the correct document accordingly with window argument (sandbox)
var document = window.document,
	navigator = window.navigator,
	location = window.location;
var jQuery = (function() {

// Define a local copy of jQuery
var jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// A simple way to check for HTML strings or ID strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

	// Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,

	// Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

	// Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

	// Matches dashed string for camelizing
	rdashAlpha = /-([a-z]|[0-9])/ig,
	rmsPrefix = /^-ms-/,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
	},

	// Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

	// For matching the engine and version of the browser
	browserMatch,

	// The deferred used on DOM ready
	readyList,

	// The ready event handler
	DOMContentLoaded,

	// Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,

	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), or $(undefined)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// The body element only exists once, optimize finding it
		if ( selector === "body" && !context && document.body ) {
			this.context = document;
			this[0] = document.body;
			this.selector = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			// Are we dealing with HTML string or an ID?
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = quickExpr.exec( selector );
			}

			// Verify a match, and that no context was specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = ( context ? context.ownerDocument || context : document );

					// If a single string is passed in and it's a single tag
					// just do a createElement and skip the rest
					ret = rsingleTag.exec( selector );

					if ( ret ) {
						if ( jQuery.isPlainObject( context ) ) {
							selector = [ document.createElement( ret[1] ) ];
							jQuery.fn.attr.call( selector, context, true );

						} else {
							selector = [ doc.createElement( ret[1] ) ];
						}

					} else {
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
						selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
					}

					return jQuery.merge( this, selector );

				// HANDLE: $("#id")
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.7.2",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return slice.call( this, 0 );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {
		// Build a new jQuery matched element set
		var ret = this.constructor();

		if ( jQuery.isArray( elems ) ) {
			push.apply( ret, elems );

		} else {
			jQuery.merge( ret, elems );
		}

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Attach the listeners
		jQuery.bindReady();

		// Add the callback
		readyList.add( fn );

		return this;
	},

	eq: function( i ) {
		i = +i;
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ),
			"slice", slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {
		// Either a released hold or an DOMready/load event and not yet ready
		if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( !document.body ) {
				return setTimeout( jQuery.ready, 1 );
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.fireWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.trigger ) {
				jQuery( document ).trigger( "ready" ).off( "ready" );
			}
		}
	},

	bindReady: function() {
		if ( readyList ) {
			return;
		}

		readyList = jQuery.Callbacks( "once memory" );

		// Catch cases where $(document).ready() is called after the
		// browser event has already occurred.
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			return setTimeout( jQuery.ready, 1 );
		}

		// Mozilla, Opera and webkit nightlies currently support this event
		if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else if ( document.attachEvent ) {
			// ensure firing before onload,
			// maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", DOMContentLoaded );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var toplevel = false;

			try {
				toplevel = window.frameElement == null;
			} catch(e) {}

			if ( document.documentElement.doScroll && toplevel ) {
				doScrollCheck();
			}
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		for ( var name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	parseJSON: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return ( new Function( "return " + data ) )();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}
		var xml, tmp;
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && rnotwhite.test( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
	},

	// args is for internal usage only
	each: function( object, callback, args ) {
		var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction( object );

		if ( args ) {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.apply( object[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( object[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return object;
	},

	// Use native String.trim function wherever possible
	trim: trim ?
		function( text ) {
			return text == null ?
				"" :
				trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
		},

	// results is for internal usage only
	makeArray: function( array, results ) {
		var ret = results || [];

		if ( array != null ) {
			// The window, strings (and functions) also have 'length'
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			var type = jQuery.type( array );

			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
				push.call( ret, array );
			} else {
				jQuery.merge( ret, array );
			}
		}

		return ret;
	},

	inArray: function( elem, array, i ) {
		var len;

		if ( array ) {
			if ( indexOf ) {
				return indexOf.call( array, elem, i );
			}

			len = array.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in array && array[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var i = first.length,
			j = 0;

		if ( typeof second.length === "number" ) {
			for ( var l = second.length; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var ret = [], retVal;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value, key, ret = [],
			i = 0,
			length = elems.length,
			// jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		if ( typeof context === "string" ) {
			var tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		var args = slice.call( arguments, 2 ),
			proxy = function() {
				return fn.apply( context, args.concat( slice.call( arguments ) ) );
			};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

		return proxy;
	},

	// Mutifunctional method to get and set values to a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
		var exec,
			bulk = key == null,
			i = 0,
			length = elems.length;

		// Sets many values
		if ( key && typeof key === "object" ) {
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
			}
			chainable = 1;

		// Sets one value
		} else if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = pass === undefined && jQuery.isFunction( value );

			if ( bulk ) {
				// Bulk operations only iterate when executing function values
				if ( exec ) {
					exec = fn;
					fn = function( elem, key, value ) {
						return exec.call( jQuery( elem ), value );
					};

				// Otherwise they run against the entire set
				} else {
					fn.call( elems, value );
					fn = null;
				}
			}

			if ( fn ) {
				for (; i < length; i++ ) {
					fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
				}
			}

			chainable = 1;
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				length ? fn( elems[0], key ) : emptyGet;
	},

	now: function() {
		return ( new Date() ).getTime();
	},

	// Use of jQuery.browser is frowned upon.
	// More details: http://docs.jquery.com/Utilities/jQuery.browser
	uaMatch: function( ua ) {
		ua = ua.toLowerCase();

		var match = rwebkit.exec( ua ) ||
			ropera.exec( ua ) ||
			rmsie.exec( ua ) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
			[];

		return { browser: match[1] || "", version: match[2] || "0" };
	},

	sub: function() {
		function jQuerySub( selector, context ) {
			return new jQuerySub.fn.init( selector, context );
		}
		jQuery.extend( true, jQuerySub, this );
		jQuerySub.superclass = this;
		jQuerySub.fn = jQuerySub.prototype = this();
		jQuerySub.fn.constructor = jQuerySub;
		jQuerySub.sub = this.sub;
		jQuerySub.fn.init = function init( selector, context ) {
			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
				context = jQuerySub( context );
			}

			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
		};
		jQuerySub.fn.init.prototype = jQuerySub.fn;
		var rootjQuerySub = jQuerySub(document);
		return jQuerySub;
	},

	browser: {}
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
	jQuery.browser[ browserMatch.browser ] = true;
	jQuery.browser.version = browserMatch.version;
}

// Deprecated, use jQuery.browser.webkit instead
if ( jQuery.browser.webkit ) {
	jQuery.browser.safari = true;
}

// IE doesn't match non-breaking spaces with \s
if ( rnotwhite.test( "\xA0" ) ) {
	trimLeft = /^[\s\xA0]+/;
	trimRight = /[\s\xA0]+$/;
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
if ( document.addEventListener ) {
	DOMContentLoaded = function() {
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		jQuery.ready();
	};

} else if ( document.attachEvent ) {
	DOMContentLoaded = function() {
		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( document.readyState === "complete" ) {
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	};
}

// The DOM ready check for Internet Explorer
function doScrollCheck() {
	if ( jQuery.isReady ) {
		return;
	}

	try {
		// If IE is used, use the trick by Diego Perini
		// http://javascript.nwbox.com/IEContentLoaded/
		document.documentElement.doScroll("left");
	} catch(e) {
		setTimeout( doScrollCheck, 1 );
		return;
	}

	// and execute any waiting functions
	jQuery.ready();
}

return jQuery;

})();


// String to Object flags format cache
var flagsCache = {};

// Convert String-formatted flags into Object-formatted ones and store in cache
function createFlags( flags ) {
	var object = flagsCache[ flags ] = {},
		i, length;
	flags = flags.split( /\s+/ );
	for ( i = 0, length = flags.length; i < length; i++ ) {
		object[ flags[i] ] = true;
	}
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	flags:	an optional list of space-separated flags that will change how
 *			the callback list behaves
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible flags:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( flags ) {

	// Convert flags from String-formatted to Object-formatted
	// (we check in cache first)
	flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};

	var // Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = [],
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Add one or several callbacks to the list
		add = function( args ) {
			var i,
				length,
				elem,
				type,
				actual;
			for ( i = 0, length = args.length; i < length; i++ ) {
				elem = args[ i ];
				type = jQuery.type( elem );
				if ( type === "array" ) {
					// Inspect recursively
					add( elem );
				} else if ( type === "function" ) {
					// Add if not in unique mode and callback is not in
					if ( !flags.unique || !self.has( elem ) ) {
						list.push( elem );
					}
				}
			}
		},
		// Fire callbacks
		fire = function( context, args ) {
			args = args || [];
			memory = !flags.memory || [ context, args ];
			fired = true;
			firing = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
					memory = true; // Mark as halted
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( !flags.once ) {
					if ( stack && stack.length ) {
						memory = stack.shift();
						self.fireWith( memory[ 0 ], memory[ 1 ] );
					}
				} else if ( memory === true ) {
					self.disable();
				} else {
					list = [];
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					var length = list.length;
					add( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away, unless previous
					// firing was halted (stopOnFalse)
					} else if ( memory && memory !== true ) {
						firingStart = length;
						fire( memory[ 0 ], memory[ 1 ] );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					var args = arguments,
						argIndex = 0,
						argLength = args.length;
					for ( ; argIndex < argLength ; argIndex++ ) {
						for ( var i = 0; i < list.length; i++ ) {
							if ( args[ argIndex ] === list[ i ] ) {
								// Handle firingIndex and firingLength
								if ( firing ) {
									if ( i <= firingLength ) {
										firingLength--;
										if ( i <= firingIndex ) {
											firingIndex--;
										}
									}
								}
								// Remove the element
								list.splice( i--, 1 );
								// If we have some unicity property then
								// we only need to do this once
								if ( flags.unique ) {
									break;
								}
							}
						}
					}
				}
				return this;
			},
			// Control if a given callback is in the list
			has: function( fn ) {
				if ( list ) {
					var i = 0,
						length = list.length;
					for ( ; i < length; i++ ) {
						if ( fn === list[ i ] ) {
							return true;
						}
					}
				}
				return false;
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory || memory === true ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( stack ) {
					if ( firing ) {
						if ( !flags.once ) {
							stack.push( [ context, args ] );
						}
					} else if ( !( flags.once && memory ) ) {
						fire( context, args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};




var // Static reference to slice
	sliceDeferred = [].slice;

jQuery.extend({

	Deferred: function( func ) {
		var doneList = jQuery.Callbacks( "once memory" ),
			failList = jQuery.Callbacks( "once memory" ),
			progressList = jQuery.Callbacks( "memory" ),
			state = "pending",
			lists = {
				resolve: doneList,
				reject: failList,
				notify: progressList
			},
			promise = {
				done: doneList.add,
				fail: failList.add,
				progress: progressList.add,

				state: function() {
					return state;
				},

				// Deprecated
				isResolved: doneList.fired,
				isRejected: failList.fired,

				then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
					deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
					return this;
				},
				always: function() {
					deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
					return this;
				},
				pipe: function( fnDone, fnFail, fnProgress ) {
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( {
							done: [ fnDone, "resolve" ],
							fail: [ fnFail, "reject" ],
							progress: [ fnProgress, "notify" ]
						}, function( handler, data ) {
							var fn = data[ 0 ],
								action = data[ 1 ],
								returned;
							if ( jQuery.isFunction( fn ) ) {
								deferred[ handler ](function() {
									returned = fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
									}
								});
							} else {
								deferred[ handler ]( newDefer[ action ] );
							}
						});
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					if ( obj == null ) {
						obj = promise;
					} else {
						for ( var key in promise ) {
							obj[ key ] = promise[ key ];
						}
					}
					return obj;
				}
			},
			deferred = promise.promise({}),
			key;

		for ( key in lists ) {
			deferred[ key ] = lists[ key ].fire;
			deferred[ key + "With" ] = lists[ key ].fireWith;
		}

		// Handle state
		deferred.done( function() {
			state = "resolved";
		}, failList.disable, progressList.lock ).fail( function() {
			state = "rejected";
		}, doneList.disable, progressList.lock );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( firstParam ) {
		var args = sliceDeferred.call( arguments, 0 ),
			i = 0,
			length = args.length,
			pValues = new Array( length ),
			count = length,
			pCount = length,
			deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
				firstParam :
				jQuery.Deferred(),
			promise = deferred.promise();
		function resolveFunc( i ) {
			return function( value ) {
				args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				if ( !( --count ) ) {
					deferred.resolveWith( deferred, args );
				}
			};
		}
		function progressFunc( i ) {
			return function( value ) {
				pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				deferred.notifyWith( promise, pValues );
			};
		}
		if ( length > 1 ) {
			for ( ; i < length; i++ ) {
				if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
					args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
				} else {
					--count;
				}
			}
			if ( !count ) {
				deferred.resolveWith( deferred, args );
			}
		} else if ( deferred !== firstParam ) {
			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
		}
		return promise;
	}
});




jQuery.support = (function() {

	var support,
		all,
		a,
		select,
		opt,
		input,
		fragment,
		tds,
		events,
		eventName,
		i,
		isSupported,
		div = document.createElement( "div" ),
		documentElement = document.documentElement;

	// Preliminary tests
	div.setAttribute("className", "t");
	div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

	all = div.getElementsByTagName( "*" );
	a = div.getElementsByTagName( "a" )[ 0 ];

	// Can't get basic test support
	if ( !all || !all.length || !a ) {
		return {};
	}

	// First batch of supports tests
	select = document.createElement( "select" );
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName( "input" )[ 0 ];

	support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute("href") === "/a" ),

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.55/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: ( input.value === "on" ),

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// Tests for enctype support on a form(#6743)
		enctype: !!document.createElement("form").enctype,

		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true,
		pixelMargin: true
	};

	// jQuery.boxModel DEPRECATED in 1.3, use jQuery.support.boxModel instead
	jQuery.boxModel = support.boxModel = (document.compatMode === "CSS1Compat");

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", function() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent( "onclick" );
	}

	// Check if a radio maintains its value
	// after being appended to the DOM
	input = document.createElement("input");
	input.value = "t";
	input.setAttribute("type", "radio");
	support.radioValue = input.value === "t";

	input.setAttribute("checked", "checked");

	// #11217 - WebKit loses check when the name is after the checked attribute
	input.setAttribute( "name", "t" );

	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.lastChild );

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	fragment.removeChild( input );
	fragment.appendChild( div );

	// Technique from Juriy Zaytsev
	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
	// We only care about the case where non-standard event systems
	// are used, namely in IE. Short-circuiting here helps us to
	// avoid an eval call (in setAttribute) which can cause CSP
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
	if ( div.attachEvent ) {
		for ( i in {
			submit: 1,
			change: 1,
			focusin: 1
		}) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}

	fragment.removeChild( div );

	// Null elements to avoid leaks in IE
	fragment = select = opt = div = input = null;

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, outer, inner, table, td, offsetSupport,
			marginDiv, conMarginTop, style, html, positionTopLeftWidthHeight,
			paddingMarginBorderVisibility, paddingMarginBorder,
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		conMarginTop = 1;
		paddingMarginBorder = "padding:0;margin:0;border:";
		positionTopLeftWidthHeight = "position:absolute;top:0;left:0;width:1px;height:1px;";
		paddingMarginBorderVisibility = paddingMarginBorder + "0;visibility:hidden;";
		style = "style='" + positionTopLeftWidthHeight + paddingMarginBorder + "5px solid #000;";
		html = "<div " + style + "display:block;'><div style='" + paddingMarginBorder + "0;display:block;overflow:hidden;'></div></div>" +
			"<table " + style + "' cellpadding='0' cellspacing='0'>" +
			"<tr><td></td></tr></table>";

		container = document.createElement("div");
		container.style.cssText = paddingMarginBorderVisibility + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
		body.insertBefore( container, body.firstChild );

		// Construct the test element
		div = document.createElement("div");
		container.appendChild( div );

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		div.innerHTML = "<table><tr><td style='" + paddingMarginBorder + "0;display:none'></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName( "td" );
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Check if empty table cells still have offsetWidth/Height
		// (IE <= 8 fail this test)
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Check if div with explicit width and no margin-right incorrectly
		// gets computed margin-right based on width of container. For more
		// info see bug #3333
		// Fails in WebKit before Feb 2011 nightlies
		// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
		if ( window.getComputedStyle ) {
			div.innerHTML = "";
			marginDiv = document.createElement( "div" );
			marginDiv.style.width = "0";
			marginDiv.style.marginRight = "0";
			div.style.width = "2px";
			div.appendChild( marginDiv );
			support.reliableMarginRight =
				( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
		}

		if ( typeof div.style.zoom !== "undefined" ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			// (IE < 8 does this)
			div.innerHTML = "";
			div.style.width = div.style.padding = "1px";
			div.style.border = 0;
			div.style.overflow = "hidden";
			div.style.display = "inline";
			div.style.zoom = 1;
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = "block";
			div.style.overflow = "visible";
			div.innerHTML = "<div style='width:5px;'></div>";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );
		}

		div.style.cssText = positionTopLeftWidthHeight + paddingMarginBorderVisibility;
		div.innerHTML = html;

		outer = div.firstChild;
		inner = outer.firstChild;
		td = outer.nextSibling.firstChild.firstChild;

		offsetSupport = {
			doesNotAddBorder: ( inner.offsetTop !== 5 ),
			doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
		};

		inner.style.position = "fixed";
		inner.style.top = "20px";

		// safari subtracts parent border width here which is 5px
		offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
		inner.style.position = inner.style.top = "";

		outer.style.overflow = "hidden";
		outer.style.position = "relative";

		offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
		offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );

		if ( window.getComputedStyle ) {
			div.style.marginTop = "1%";
			support.pixelMargin = ( window.getComputedStyle( div, null ) || { marginTop: 0 } ).marginTop !== "1%";
		}

		if ( typeof container.style.zoom !== "undefined" ) {
			container.style.zoom = 1;
		}

		body.removeChild( container );
		marginDiv = div = container = null;

		jQuery.extend( support, offsetSupport );
	});

	return support;
})();




var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([A-Z])/g;

jQuery.extend({
	cache: {},

	// Please use with caution
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var privateCache, thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
			isEvents = name === "events";

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ internalKey ] = id = ++jQuery.uuid;
			} else {
				id = internalKey;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// Avoids exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}

		privateCache = thisCache = cache[ id ];

		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}

			thisCache = thisCache.data;
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// Users should not attempt to inspect the internal events object using jQuery.data,
		// it is undocumented and subject to change. But does anyone listen? No.
		if ( isEvents && !thisCache[ name ] ) {
			return privateCache.events;
		}

		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {

			// First Try to find as-is property data
			ret = thisCache[ name ];

			// Test for null|undefined property data
			if ( ret == null ) {

				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i, l,

			// Reference to internal data cache key
			internalKey = jQuery.expando,

			isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,

			// See jQuery.data for more information
			id = isNode ? elem[ internalKey ] : internalKey;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt ? cache[ id ] : cache[ id ].data;

			if ( thisCache ) {

				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {

					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {

						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split( " " );
						}
					}
				}

				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject(cache[ id ]) ) {
				return;
			}
		}

		// Browsers that fail expando deletion also refuse to delete expandos on
		// the window, but it will allow it on all other JS objects; other browsers
		// don't care
		// Ensure that `cache` is not a window object #10080
		if ( jQuery.support.deleteExpando || !cache.setInterval ) {
			delete cache[ id ];
		} else {
			cache[ id ] = null;
		}

		// We destroyed the cache and need to eliminate the expando on the node to avoid
		// false lookups in the cache for entries that no longer exist
		if ( isNode ) {
			// IE does not allow us to delete expando properties from nodes,
			// nor does it have a removeAttribute function on Document nodes;
			// we must handle all of these cases
			if ( jQuery.support.deleteExpando ) {
				delete elem[ internalKey ];
			} else if ( elem.removeAttribute ) {
				elem.removeAttribute( internalKey );
			} else {
				elem[ internalKey ] = null;
			}
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		if ( elem.nodeName ) {
			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

			if ( match ) {
				return !(match === true || elem.getAttribute("classid") !== match);
			}
		}

		return true;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var parts, part, attr, name, l,
			elem = this[0],
			i = 0,
			data = null;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					attr = elem.attributes;
					for ( l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( elem, name, data[ name ] );
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		parts = key.split( ".", 2 );
		parts[1] = parts[1] ? "." + parts[1] : "";
		part = parts[1] + "!";

		return jQuery.access( this, function( value ) {

			if ( value === undefined ) {
				data = this.triggerHandler( "getData" + part, [ parts[0] ] );

				// Try to fetch any internally stored data first
				if ( data === undefined && elem ) {
					data = jQuery.data( elem, key );
					data = dataAttr( elem, key, data );
				}

				return data === undefined && parts[1] ?
					this.data( parts[0] ) :
					data;
			}

			parts[1] = value;
			this.each(function() {
				var self = jQuery( this );

				self.triggerHandler( "setData" + part, parts );
				jQuery.data( this, key, value );
				self.triggerHandler( "changeData" + part, parts );
			});
		}, null, value, arguments.length > 1, null, false );
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				jQuery.isNumeric( data ) ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	for ( var name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}




function handleQueueMarkDefer( elem, type, src ) {
	var deferDataKey = type + "defer",
		queueDataKey = type + "queue",
		markDataKey = type + "mark",
		defer = jQuery._data( elem, deferDataKey );
	if ( defer &&
		( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
		( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
		// Give room for hard-coded callbacks to fire first
		// and eventually mark/queue something else on the element
		setTimeout( function() {
			if ( !jQuery._data( elem, queueDataKey ) &&
				!jQuery._data( elem, markDataKey ) ) {
				jQuery.removeData( elem, deferDataKey, true );
				defer.fire();
			}
		}, 0 );
	}
}

jQuery.extend({

	_mark: function( elem, type ) {
		if ( elem ) {
			type = ( type || "fx" ) + "mark";
			jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
		}
	},

	_unmark: function( force, elem, type ) {
		if ( force !== true ) {
			type = elem;
			elem = force;
			force = false;
		}
		if ( elem ) {
			type = type || "fx";
			var key = type + "mark",
				count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
			if ( count ) {
				jQuery._data( elem, key, count );
			} else {
				jQuery.removeData( elem, key, true );
				handleQueueMarkDefer( elem, type, "mark" );
			}
		}
	},

	queue: function( elem, type, data ) {
		var q;
		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			q = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !q || jQuery.isArray(data) ) {
					q = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					q.push( data );
				}
			}
			return q || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			fn = queue.shift(),
			hooks = {};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
		}

		if ( fn ) {
			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			jQuery._data( elem, type + ".run", hooks );
			fn.call( elem, function() {
				jQuery.dequeue( elem, type );
			}, hooks );
		}

		if ( !queue.length ) {
			jQuery.removeData( elem, type + "queue " + type + ".run", true );
			handleQueueMarkDefer( elem, type, "queue" );
		}
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, object ) {
		if ( typeof type !== "string" ) {
			object = type;
			type = undefined;
		}
		type = type || "fx";
		var defer = jQuery.Deferred(),
			elements = this,
			i = elements.length,
			count = 1,
			deferDataKey = type + "defer",
			queueDataKey = type + "queue",
			markDataKey = type + "mark",
			tmp;
		function resolve() {
			if ( !( --count ) ) {
				defer.resolveWith( elements, [ elements ] );
			}
		}
		while( i-- ) {
			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
					jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
				count++;
				tmp.add( resolve );
			}
		}
		resolve();
		return defer.promise( object );
	}
});




var rclass = /[\n\t\r]/g,
	rspace = /\s+/,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	nodeHook, boolHook, fixSpecified;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value && typeof value === "string" ) {
			classNames = value.split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className && classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = " " + elem.className + " ";

						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, i, l, elem, className, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}

		if ( (value && typeof value === "string") || value === undefined ) {
			classNames = ( value || "" ).split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 && elem.className ) {
					if ( value ) {
						className = (" " + elem.className + " ").replace( rclass, " " );
						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							className = className.replace(" " + classNames[ c ] + " ", " ");
						}
						elem.className = jQuery.trim( className );

					} else {
						elem.className = "";
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( rspace );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space seperated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var self = jQuery(this), val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, i, max, option,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

				// Nothing was selected
				if ( index < 0 ) {
					return null;
				}

				// Loop through all the selected options
				i = one ? index : 0;
				max = one ? index + 1 : options.length;
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Don't return options that are disabled or in a disabled optgroup
					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
				if ( one && !values.length && options.length ) {
					return jQuery( options[ index ] ).val();
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attrFn: {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true
	},

	attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( pass && name in jQuery.attrFn ) {
			return jQuery( elem )[ name ]( value );
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;

			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, "" + value );
				return value;
			}

		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret === null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var propName, attrNames, name, l, isBool,
			i = 0;

		if ( value && elem.nodeType === 1 ) {
			attrNames = value.toLowerCase().split( rspace );
			l = attrNames.length;

			for ( ; i < l; i++ ) {
				name = attrNames[ i ];

				if ( name ) {
					propName = jQuery.propFix[ name ] || name;
					isBool = rboolean.test( name );

					// See #9699 for explanation of this approach (setting first, then removal)
					// Do not do this for boolean attributes (see #10870)
					if ( !isBool ) {
						jQuery.attr( elem, name, "" );
					}
					elem.removeAttribute( getSetAttribute ? name : propName );

					// Set corresponding property to false for boolean attributes
					if ( isBool && propName in elem ) {
						elem[ propName ] = false;
					}
				}
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to it's default in case type is set after value
					// This is for element creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		// Use the value property for back compat
		// Use the nodeHook for button elements in IE6/7 (#1954)
		value: {
			get: function( elem, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
				// Does not return so that setAttribute is also used
				elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		// Fall back to attribute presence where some booleans are not supported
		var attrNode,
			property = jQuery.prop( elem, name );
		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			// value is true since we know at this point it's type boolean and not false
			// Set boolean attributes to the same name and set the DOM property
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				// Only set the IDL specifically if it already exists on the element
				elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	fixSpecified = {
		name: true,
		id: true,
		coords: true
	};

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
				ret.nodeValue :
				undefined;
		},
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				ret = document.createAttribute( name );
				elem.setAttributeNode( ret );
			}
			return ( ret.nodeValue = value + "" );
		}
	};

	// Apply the nodeHook to tabindex
	jQuery.attrHooks.tabindex.set = nodeHook.set;

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			if ( value === "" ) {
				value = "false";
			}
			nodeHook.set( elem, value, name );
		}
	};
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Normalize to lowercase since IE uppercases css property names
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = "" + value );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});




var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
	rhoverHack = /(?:^|\s)hover(\.\S+)?\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
	quickParse = function( selector ) {
		var quick = rquickIs.exec( selector );
		if ( quick ) {
			//   0  1    2   3
			// [ _, tag, id, class ]
			quick[1] = ( quick[1] || "" ).toLowerCase();
			quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
		}
		return quick;
	},
	quickIs = function( elem, m ) {
		var attrs = elem.attributes || {};
		return (
			(!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
			(!m[2] || (attrs.id || {}).value === m[2]) &&
			(!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
		);
	},
	hoverHack = function( events ) {
		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	add: function( elem, types, handler, data, selector ) {

		var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, quick, handlers, special;

		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		events = elemData.events;
		if ( !events ) {
			elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = jQuery.trim( hoverHack(types) ).split( " " );
		for ( t = 0; t < types.length; t++ ) {

			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || "" ).split( "." ).sort();

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				quick: selector && quickParse( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			handlers = events[ type ];
			if ( !handlers ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
			t, tns, type, origType, namespaces, origCount,
			j, events, special, handle, eventType, handleObj;

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
		for ( t = 0; t < types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = origType = tns[1];
			namespaces = tns[2];

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector? special.delegateType : special.bindType ) || type;
			eventType = events[ type ] || [];
			origCount = eventType.length;
			namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;

			// Remove matching events
			for ( j = 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					 ( !handler || handler.guid === handleObj.guid ) &&
					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
					 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					eventType.splice( j--, 1 );

					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( eventType.length === 0 && origCount !== eventType.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			handle = elemData.handle;
			if ( handle ) {
				handle.elem = null;
			}

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery.removeData( elem, [ "events", "handle" ], true );
		}
	},

	// Events that are safe to short-circuit if no handlers are attached.
	// Native DOM events should not be added, they may have inline handlers.
	customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		// Don't do events on text and comment nodes
		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
			return;
		}

		// Event object or event type
		var type = event.type || event,
			namespaces = [],
			cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "!" ) >= 0 ) {
			// Exclusive events trigger only for the exact event (no namespaces)
			type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf( "." ) >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
			// No jQuery handlers for this event type, and it can't have inline handlers
			return;
		}

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object" ?
			// jQuery.Event object
			event[ jQuery.expando ] ? event :
			// Object literal
			new jQuery.Event( type, event ) :
			// Just the event type (string)
			new jQuery.Event( type );

		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( "." );
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

		// Handle a global trigger
		if ( !elem ) {

			// TODO: Stop taunting the data cache; remove global events and always attach to document
			cache = jQuery.cache;
			for ( i in cache ) {
				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
				}
			}
			return;
		}

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		eventPath = [[ elem, special.bindType || type ]];
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
			old = null;
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push([ cur, bubbleType ]);
				old = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( old && old === elem.ownerDocument ) {
				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
			}
		}

		// Fire handlers on the event path
		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

			cur = eventPath[i][0];
			event.type = eventPath[i][1];

			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}
			// Note that this is a bare JS function and not a jQuery handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				// IE<9 dies on focus/blur to hidden element (#1486)
				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					old = elem[ ontype ];

					if ( old ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event || window.event );

		var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
			delegateCount = handlers.delegateCount,
			args = [].slice.call( arguments, 0 ),
			run_all = !event.exclusive && !event.namespace,
			special = jQuery.event.special[ event.type ] || {},
			handlerQueue = [],
			i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers that should run if there are delegated events
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && !(event.button && event.type === "click") ) {

			// Pregenerate a single jQuery object for reuse with .is()
			jqcur = jQuery(this);
			jqcur.context = this.ownerDocument || this;

			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {

				// Don't process events on disabled elements (#6911, #8165)
				if ( cur.disabled !== true ) {
					selMatch = {};
					matches = [];
					jqcur[0] = cur;
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];
						sel = handleObj.selector;

						if ( selMatch[ sel ] === undefined ) {
							selMatch[ sel ] = (
								handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
							);
						}
						if ( selMatch[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, matches: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( handlers.length > delegateCount ) {
			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}

		// Run delegates first; they may want to stop propagation beneath us
		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
			matched = handlerQueue[ i ];
			event.currentTarget = matched.elem;

			for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
				handleObj = matched.matches[ j ];

				// Triggered event must either 1) be non-exclusive and have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

					event.data = handleObj.data;
					event.handleObj = handleObj;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
	props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[ event.type ] || {},
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = jQuery.Event( originalEvent );

		for ( i = copy.length; i; ) {
			prop = copy[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Target should not be a text node (#504, Safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
		if ( event.metaKey === undefined ) {
			event.metaKey = event.ctrlKey;
		}

		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		ready: {
			// Make sure the ready event is setup
			setup: jQuery.bindReady
		},

		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},

		focus: {
			delegateType: "focusin"
		},
		blur: {
			delegateType: "focusout"
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		if ( elem.detachEvent ) {
			elem.detachEvent( "on" + type, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector,
				ret;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !form._submit_attached ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					form._submit_attached = true;
				}
			});
			// return undefined since we don't need an event listener
		},
		
		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
							jQuery.event.simulate( "change", this, event, true );
						}
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					elem._change_attached = true;
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) { // && selector != null
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			var handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( var type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || "**", fn );
		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				// Figure out which function to execute
				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

				// Make sure that clicks stop
				event.preventDefault();

				// and execute the function
				return args[ lastToggle ].apply( this, arguments ) || false;
			};

		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};

	if ( jQuery.attrFn ) {
		jQuery.attrFn[ name ] = true;
	}

	if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
	}

	if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
	}
});



/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	expando = "sizcache" + (Math.random() + '').replace('.', ''),
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rReturn = /\r\n/g,
	rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;

	// Reset the position of the chunker regexp (start from head)
	do {
		chunker.exec( "" );
		m = chunker.exec( soFar );

		if ( m ) {
			soFar = m[3];

			parts.push( m[1] );

			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {

		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context, seed );

		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}

				set = posProcess( selector, set, seed );
			}
		}

	} else {
		// Take a shortcut and set the context if the root selector is an ID
		// (but not if it'll be faster if the inner selector is an ID)
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ?
				Sizzle.filter( ret.expr, ret.set )[0] :
				ret.set[0];
		}

		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

			set = ret.expr ?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray( set );

			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );

		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}

		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}

	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
	var set, i, len, match, type, left;

	if ( !expr ) {
		return [];
	}

	for ( i = 0, len = Expr.order.length; i < len; i++ ) {
		type = Expr.order[i];

		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			left = match[1];
			match.splice( 1, 1 );

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace( rBackslash, "" );
				set = Expr.find[ type ]( match, context, isXML );

				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( "*" ) :
			[];
	}

	return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		type, found, item, filter, left,
		i, pass,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

	while ( expr && set.length ) {
		for ( type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				filter = Expr.filter[ type ];
				left = match[1];

				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

				if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;

					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							pass = not ^ found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;

								} else {
									curLoop[i] = false;
								}

							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );

			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Utility function for retreiving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
var getText = Sizzle.getText = function( elem ) {
    var i, node,
		nodeType = elem.nodeType,
		ret = "";

	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent || innerText for elements
			if ( typeof elem.textContent === 'string' ) {
				return elem.textContent;
			} else if ( typeof elem.innerText === 'string' ) {
				// Replace IE's carriage returns
				return elem.innerText.replace( rReturn, '' );
			} else {
				// Traverse it's children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
	} else {

		// If no nodeType, this is expected to be an array
		for ( i = 0; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			if ( node.nodeType !== 8 ) {
				ret += getText( node );
			}
		}
	}
	return ret;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],

	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},

	leftMatch: {},

	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},

	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		},
		type: function( elem ) {
			return elem.getAttribute( "type" );
		}
	},

	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test( part ),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},

		">": function( checkSet, part ) {
			var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

			if ( isPartStr && !rNonWord.test( part ) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}

			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},

		"": function(checkSet, part, isXML){
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
		},

		"~": function( checkSet, part, isXML ) {
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
		}
	},

	find: {
		ID: function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		},

		NAME: function( match, context ) {
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [],
					results = context.getElementsByName( match[1] );

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},

		TAG: function( match, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( match[1] );
			}
		}
	},
	preFilter: {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace( rBackslash, "" ) + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}

					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},

		ID: function( match ) {
			return match[1].replace( rBackslash, "" );
		},

		TAG: function( match, curLoop ) {
			return match[1].replace( rBackslash, "" ).toLowerCase();
		},

		CHILD: function( match ) {
			if ( match[1] === "nth" ) {
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				match[2] = match[2].replace(/^\+|\s*/g, '');

				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}
			else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},

		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1] = match[1].replace( rBackslash, "" );

			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			// Handle if an un-quoted value was used
			match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},

		PSEUDO: function( match, curLoop, inplace, result, not ) {
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);

				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

					if ( !inplace ) {
						result.push.apply( result, ret );
					}

					return false;
				}

			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}

			return match;
		},

		POS: function( match ) {
			match.unshift( true );

			return match;
		}
	},

	filters: {
		enabled: function( elem ) {
			return elem.disabled === false && elem.type !== "hidden";
		},

		disabled: function( elem ) {
			return elem.disabled === true;
		},

		checked: function( elem ) {
			return elem.checked === true;
		},

		selected: function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		parent: function( elem ) {
			return !!elem.firstChild;
		},

		empty: function( elem ) {
			return !elem.firstChild;
		},

		has: function( elem, i, match ) {
			return !!Sizzle( match[3], elem ).length;
		},

		header: function( elem ) {
			return (/h\d/i).test( elem.nodeName );
		},

		text: function( elem ) {
			var attr = elem.getAttribute( "type" ), type = elem.type;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
		},

		radio: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
		},

		checkbox: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
		},

		file: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
		},

		password: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
		},

		submit: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "submit" === elem.type;
		},

		image: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
		},

		reset: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "reset" === elem.type;
		},

		button: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && "button" === elem.type || name === "button";
		},

		input: function( elem ) {
			return (/input|select|textarea|button/i).test( elem.nodeName );
		},

		focus: function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		}
	},
	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},

		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},

		even: function( elem, i ) {
			return i % 2 === 0;
		},

		odd: function( elem, i ) {
			return i % 2 === 1;
		},

		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},

		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},

		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},

		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );

			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;

			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;

			} else {
				Sizzle.error( name );
			}
		},

		CHILD: function( elem, match ) {
			var first, last,
				doneName, parent, cache,
				count, diff,
				type = match[1],
				node = elem;

			switch ( type ) {
				case "only":
				case "first":
					while ( (node = node.previousSibling) ) {
						if ( node.nodeType === 1 ) {
							return false;
						}
					}

					if ( type === "first" ) {
						return true;
					}

					node = elem;

					/* falls through */
				case "last":
					while ( (node = node.nextSibling) ) {
						if ( node.nodeType === 1 ) {
							return false;
						}
					}

					return true;

				case "nth":
					first = match[2];
					last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}

					doneName = match[0];
					parent = elem.parentNode;

					if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
						count = 0;

						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						}

						parent[ expando ] = doneName;
					}

					diff = elem.nodeIndex - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},

		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},

		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
		},

		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},

		ATTR: function( elem, match ) {
			var name = match[1],
				result = Sizzle.attr ?
					Sizzle.attr( elem, name ) :
					Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				!type && Sizzle.attr ?
				result != null :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},

		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}
// Expose origPOS
// "global" as in regardless of relation to brackets/parens
Expr.match.globalPOS = origPOS;

var makeArray = function( array, results ) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}

	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch( e ) {
	makeArray = function( array, results ) {
		var i = 0,
			ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );

		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}

			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			return a.compareDocumentPosition ? -1 : 1;
		}

		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
	};

} else {
	sortOrder = function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it's available on both nodes
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;
		}

		var cur = a.nextSibling;

		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}

			cur = cur.nextSibling;
		}

		return 1;
	};
}

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
	// We're going to inject a fake input element with a specified name
	var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

	form.innerHTML = "<a name='" + id + "'/>";

	// Inject it into the root element, check its status, and remove it quickly
	root.insertBefore( form, root.firstChild );

	// The workaround has to do additional checks after a getElementById
	// Which slows things down for other browsers (hence the branching)
	if ( document.getElementById( id ) ) {
		Expr.find.ID = function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);

				return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
			}
		};

		Expr.filter.ID = function( elem, match ) {
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );

	// release memory in IE
	root = form = null;
})();

(function(){
	// Check to see if the browser returns only elements
	// when doing getElementsByTagName("*")

	// Create a fake element
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	// Make sure no comments are found
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function( match, context ) {
			var results = context.getElementsByTagName( match[1] );

			// Filter out possible comments
			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	// Check to see if an attribute returns normalized href attributes
	div.innerHTML = "<a href='#'></a>";

	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {

		Expr.attrHandle.href = function( elem ) {
			return elem.getAttribute( "href", 2 );
		};
	}

	// release memory in IE
	div = null;
})();

if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

		div.innerHTML = "<p class='TEST'></p>";

		// Safari can't handle uppercase or unicode characters when
		// in quirks mode.
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}

		Sizzle = function( query, context, extra, seed ) {
			context = context || document;

			// Only use querySelectorAll on non-XML documents
			// (ID selectors don't work in non-HTML documents)
			if ( !seed && !Sizzle.isXML(context) ) {
				// See if we find a selector to speed up
				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );

				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
					// Speed-up: Sizzle("TAG")
					if ( match[1] ) {
						return makeArray( context.getElementsByTagName( query ), extra );

					// Speed-up: Sizzle(".CLASS")
					} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
						return makeArray( context.getElementsByClassName( match[2] ), extra );
					}
				}

				if ( context.nodeType === 9 ) {
					// Speed-up: Sizzle("body")
					// The body element only exists once, optimize finding it
					if ( query === "body" && context.body ) {
						return makeArray( [ context.body ], extra );

					// Speed-up: Sizzle("#ID")
					} else if ( match && match[3] ) {
						var elem = context.getElementById( match[3] );

						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE and Opera return items
							// by name instead of ID
							if ( elem.id === match[3] ) {
								return makeArray( [ elem ], extra );
							}

						} else {
							return makeArray( [], extra );
						}
					}

					try {
						return makeArray( context.querySelectorAll(query), extra );
					} catch(qsaError) {}

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var oldContext = context,
						old = context.getAttribute( "id" ),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test( query );

					if ( !old ) {
						context.setAttribute( "id", nid );
					} else {
						nid = nid.replace( /'/g, "\\$&" );
					}
					if ( relativeHierarchySelector && hasParent ) {
						context = context.parentNode;
					}

					try {
						if ( !relativeHierarchySelector || hasParent ) {
							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
						}

					} catch(pseudoError) {
					} finally {
						if ( !old ) {
							oldContext.removeAttribute( "id" );
						}
					}
				}
			}

			return oldSizzle(query, context, extra, seed);
		};

		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

		// release memory in IE
		div = null;
	})();
}

(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

	if ( matches ) {
		// Check to see if it's possible to do matchesSelector
		// on a disconnected node (IE 9 fails this)
		var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
			pseudoWorks = false;

		try {
			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( document.documentElement, "[test!='']:sizzle" );

		} catch( pseudoError ) {
			pseudoWorks = true;
		}

		Sizzle.matchesSelector = function( node, expr ) {
			// Make sure that attribute selectors are quoted
			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

			if ( !Sizzle.isXML( node ) ) {
				try {
					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
						var ret = matches.call( node, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || !disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9, so check for that
								node.document && node.document.nodeType !== 11 ) {
							return ret;
						}
					}
				} catch(e) {}
			}

			return Sizzle(expr, null, null, [node]).length > 0;
		};
	}
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	// Opera can't find a second classname (in 9.6)
	// Also, make sure that getElementsByClassName actually exists
	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}

	// Safari caches class attributes, doesn't catch changes (in 3.2)
	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}

	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function( match, context, isXML ) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	// release memory in IE
	div = null;
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem[ expando ] = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem[ expando ] = doneName;
						elem.sizset = i;
					}

					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

if ( document.documentElement.contains ) {
	Sizzle.contains = function( a, b ) {
		return a !== b && (a.contains ? a.contains(b) : true);
	};

} else if ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = function( a, b ) {
		return !!(a.compareDocumentPosition(b) & 16);
	};

} else {
	Sizzle.contains = function() {
		return false;
	};
}

Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function( selector, context, seed ) {
	var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet, seed );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE
// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
Sizzle.selectors.attrMap = {};
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})();


var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
	// Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.globalPOS,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var self = this,
			i, l;

		if ( typeof selector !== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		var ret = this.pushStack( "", "find", selector ),
			length, n, r;

		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var targets = jQuery( target );
		return this.filter(function() {
			for ( var i = 0, l = targets.length; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return !!selector && (
			typeof selector === "string" ?
				// If this is a positional selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				POS.test( selector ) ?
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
				this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var ret = [], i, l, cur = this[0];

		// Array (deprecated as of jQuery 1.7)
		if ( jQuery.isArray( selectors ) ) {
			var level = 1;

			while ( cur && cur.ownerDocument && cur !== context ) {
				for ( i = 0; i < selectors.length; i++ ) {

					if ( jQuery( cur ).is( selectors[ i ] ) ) {
						ret.push({ selector: selectors[ i ], elem: cur, level: level });
					}
				}

				cur = cur.parentNode;
				level++;
			}

			return ret;
		}

		// String
		var pos = POS.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( i = 0, l = this.length; i < l; i++ ) {
			cur = this[i];

			while ( cur ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;

				} else {
					cur = cur.parentNode;
					if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
						break;
					}
				}
			}
		}

		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	andSelf: function() {
		return this.add( this.prevObject );
	}
});

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return jQuery.nth( elem, 2, "nextSibling" );
	},
	prev: function( elem ) {
		return jQuery.nth( elem, 2, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray( elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, slice.call( arguments ).join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	nth: function( cur, result, dir, elem ) {
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] ) {
			if ( cur.nodeType === 1 && ++num === result ) {
				break;
			}
		}

		return cur;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}




function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
	safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	},
	safeFragment = createSafeFragment( document );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "div<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( value ) {
		return jQuery.access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		} else if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			set.push.apply( set, this.toArray() );
			return this.pushStack( set, "before", arguments );
		}
	},

	after: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		} else if ( arguments.length ) {
			var set = this.pushStack( this, "after", arguments );
			set.push.apply( set, jQuery.clean(arguments) );
			return set;
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return jQuery.access( this, function( value ) {
			var elem = this[0] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					null;
			}


			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( elem.getElementsByTagName( "*" ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function( value ) {
		if ( this[0] && this[0].parentNode ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		} else {
			return this.length ?
				this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
				this;
		}
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {
		var results, first, fragment, parent,
			value = args[0],
			scripts = [];

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback, true );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call(this, i, table ? self.html() : undefined);
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			parent = value && value.parentNode;

			// If we're in a fragment, just use that instead of building a new one
			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
				results = { fragment: parent };

			} else {
				results = jQuery.buildFragment( args, this, scripts );
			}

			fragment = results.fragment;

			if ( fragment.childNodes.length === 1 ) {
				first = fragment = fragment.firstChild;
			} else {
				first = fragment.firstChild;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
					callback.call(
						table ?
							root(this[i], first) :
							this[i],
						// Make sure that we do not leak memory by inadvertently discarding
						// the original fragment (which might have attached data) instead of
						// using it; in addition, use the original fragment object for the last
						// item instead of first because it can end up being emptied incorrectly
						// in certain situations (Bug #8070).
						// Fragments from the fragment cache must always be cloned and never used
						// in place.
						results.cacheable || ( l > 1 && i < lastIndex ) ?
							jQuery.clone( fragment, true, true ) :
							fragment
					);
				}
			}

			if ( scripts.length ) {
				jQuery.each( scripts, function( i, elem ) {
					if ( elem.src ) {
						jQuery.ajax({
							type: "GET",
							global: false,
							url: elem.src,
							async: false,
							dataType: "script"
						});
					} else {
						jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
					}

					if ( elem.parentNode ) {
						elem.parentNode.removeChild( elem );
					}
				});
			}
		}

		return this;
	}
});

function root( elem, cur ) {
	return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	// clearAttributes removes the attributes, which we don't want,
	// but also removes the attachEvent events, which we *do* want
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 fail to clone children inside object elements that use
	// the proprietary classid attribute value (rather than the type
	// attribute) to identify the type of content to display
	if ( nodeName === "object" ) {
		dest.outerHTML = src.outerHTML;

	} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set
		if ( src.checked ) {
			dest.defaultChecked = dest.checked = src.checked;
		}

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;

	// IE blanks contents when cloning scripts
	} else if ( nodeName === "script" && dest.text !== src.text ) {
		dest.text = src.text;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );

	// Clear flags for bubbling special change/submit events, they must
	// be reattached when the newly cloned events are first activated
	dest.removeAttribute( "_submit_attached" );
	dest.removeAttribute( "_change_attached" );
}

jQuery.buildFragment = function( args, nodes, scripts ) {
	var fragment, cacheable, cacheresults, doc,
	first = args[ 0 ];

	// nodes may contain either an explicit document object,
	// a jQuery collection or context object.
	// If nodes[0] contains a valid object to assign to doc
	if ( nodes && nodes[0] ) {
		doc = nodes[0].ownerDocument || nodes[0];
	}

	// Ensure that an attr object doesn't incorrectly stand in as a document object
	// Chrome and Firefox seem to allow this to occur and will throw exception
	// Fixes #8950
	if ( !doc.createDocumentFragment ) {
		doc = document;
	}

	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
	if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
		first.charAt(0) === "<" && !rnocache.test( first ) &&
		(jQuery.support.checkClone || !rchecked.test( first )) &&
		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

		cacheable = true;

		cacheresults = jQuery.fragments[ first ];
		if ( cacheresults && cacheresults !== 1 ) {
			fragment = cacheresults;
		}
	}

	if ( !fragment ) {
		fragment = doc.createDocumentFragment();
		jQuery.clean( args, doc, fragment, scripts );
	}

	if ( cacheable ) {
		jQuery.fragments[ first ] = cacheresults ? fragment : 1;
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var ret = [],
			insert = jQuery( selector ),
			parent = this.length === 1 && this[0].parentNode;

		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
			insert[ original ]( this[0] );
			return this;

		} else {
			for ( var i = 0, l = insert.length; i < l; i++ ) {
				var elems = ( i > 0 ? this.clone(true) : this ).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( typeof elem.getElementsByTagName !== "undefined" ) {
		return elem.getElementsByTagName( "*" );

	} else if ( typeof elem.querySelectorAll !== "undefined" ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( elem.type === "checkbox" || elem.type === "radio" ) {
		elem.defaultChecked = elem.checked;
	}
}
// Finds all inputs and passes them to fixDefaultChecked
function findInputs( elem ) {
	var nodeName = ( elem.nodeName || "" ).toLowerCase();
	if ( nodeName === "input" ) {
		fixDefaultChecked( elem );
	// Skip scripts, get other children
	} else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
		jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
	}
}

// Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
function shimCloneNode( elem ) {
	var div = document.createElement( "div" );
	safeFragment.appendChild( div );

	div.innerHTML = elem.outerHTML;
	return div.firstChild;
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var srcElements,
			destElements,
			i,
			// IE<=8 does not properly clone detached, unknown element nodes
			clone = jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ?
				elem.cloneNode( true ) :
				shimCloneNode( elem );

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of "length"
			for ( i = 0; srcElements[i]; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

		// Return the cloned set
		return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var checkScriptType, script, j,
				ret = [];

		context = context || document;

		// !context.createElement fails in IE with an error but returns typeof 'object'
		if ( typeof context.createElement === "undefined" ) {
			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
		}

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					// Fix "XHTML"-style tags in all browsers
					elem = elem.replace(rxhtmlTag, "<$1></$2>");

					// Trim whitespace, otherwise indexOf won't work as expected
					var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
						wrap = wrapMap[ tag ] || wrapMap._default,
						depth = wrap[0],
						div = context.createElement("div"),
						safeChildNodes = safeFragment.childNodes,
						remove;

					// Append wrapper element to unknown element safe doc fragment
					if ( context === document ) {
						// Use the fragment we've already created for this document
						safeFragment.appendChild( div );
					} else {
						// Use a fragment created with the owner document
						createSafeFragment( context ).appendChild( div );
					}

					// Go to html and back, then peel off extra wrappers
					div.innerHTML = wrap[1] + elem + wrap[2];

					// Move to the right depth
					while ( depth-- ) {
						div = div.lastChild;
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						var hasBody = rtbody.test(elem),
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

					// IE completely kills leading whitespace when innerHTML is used
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;

					// Clear elements from DocumentFragment (safeFragment or otherwise)
					// to avoid hoarding elements. Fixes #11356
					if ( div ) {
						div.parentNode.removeChild( div );

						// Guard against -1 index exceptions in FF3.6
						if ( safeChildNodes.length > 0 ) {
							remove = safeChildNodes[ safeChildNodes.length - 1 ];

							if ( remove && remove.parentNode ) {
								remove.parentNode.removeChild( remove );
							}
						}
					}
				}
			}

			// Resets defaultChecked for any radios and checkboxes
			// about to be appended to the DOM in IE 6/7 (#8060)
			var len;
			if ( !jQuery.support.appendChecked ) {
				if ( elem[0] && typeof (len = elem.length) === "number" ) {
					for ( j = 0; j < len; j++ ) {
						findInputs( elem[j] );
					}
				} else {
					findInputs( elem );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				ret = jQuery.merge( ret, elem );
			}
		}

		if ( fragment ) {
			checkScriptType = function( elem ) {
				return !elem.type || rscriptType.test( elem.type );
			};
			for ( i = 0; ret[i]; i++ ) {
				script = ret[i];
				if ( scripts && jQuery.nodeName( script, "script" ) && (!script.type || rscriptType.test( script.type )) ) {
					scripts.push( script.parentNode ? script.parentNode.removeChild( script ) : script );

				} else {
					if ( script.nodeType === 1 ) {
						var jsTags = jQuery.grep( script.getElementsByTagName( "script" ), checkScriptType );

						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
					}
					fragment.appendChild( script );
				}
			}
		}

		return ret;
	},

	cleanData: function( elems ) {
		var data, id,
			cache = jQuery.cache,
			special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
				continue;
			}

			id = elem[ jQuery.expando ];

			if ( id ) {
				data = cache[ id ];

				if ( data && data.events ) {
					for ( var type in data.events ) {
						if ( special[ type ] ) {
							jQuery.event.remove( elem, type );

						// This is a shortcut to avoid jQuery.event.remove's overhead
						} else {
							jQuery.removeEvent( elem, type, data.handle );
						}
					}

					// Null the DOM reference to avoid IE6/7/8 leak (#7054)
					if ( data.handle ) {
						data.handle.elem = null;
					}
				}

				if ( deleteExpando ) {
					delete elem[ jQuery.expando ];

				} else if ( elem.removeAttribute ) {
					elem.removeAttribute( jQuery.expando );
				}

				delete cache[ id ];
			}
		}
	}
});




var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	// fixed for IE9, see #8346
	rupper = /([A-Z]|^ms)/g,
	rnum = /^[\-+]?(?:\d*\.)?\d+$/i,
	rnumnonpx = /^-?(?:\d*\.)?\d+(?!px)[^\d\s]+$/i,
	rrelNum = /^([\-+])=([\-+.\de]+)/,
	rmargin = /^margin/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },

	// order is important!
	cssExpand = [ "Top", "Right", "Bottom", "Left" ],

	curCSS,

	getComputedStyle,
	currentStyle;

jQuery.fn.css = function( name, value ) {
	return jQuery.access( this, function( elem, name, value ) {
		return value !== undefined ?
			jQuery.style( elem, name, value ) :
			jQuery.css( elem, name );
	}, name, value, arguments.length > 1 );
};

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;

				} else {
					return elem.style.opacity;
				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, origName = jQuery.camelCase( name ),
			style = elem.style, hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra ) {
		var ret, hooks;

		// Make sure that we're working with the right name
		name = jQuery.camelCase( name );
		hooks = jQuery.cssHooks[ name ];
		name = jQuery.cssProps[ name ] || name;

		// cssFloat needs a special treatment
		if ( name === "cssFloat" ) {
			name = "float";
		}

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
			return ret;

		// Otherwise, if a way to get the computed value exists, use that
		} else if ( curCSS ) {
			return curCSS( elem, name );
		}
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var old = {},
			ret, name;

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	}
});

// DEPRECATED in 1.3, Use jQuery.css() instead
jQuery.curCSS = jQuery.css;

if ( document.defaultView && document.defaultView.getComputedStyle ) {
	getComputedStyle = function( elem, name ) {
		var ret, defaultView, computedStyle, width,
			style = elem.style;

		name = name.replace( rupper, "-$1" ).toLowerCase();

		if ( (defaultView = elem.ownerDocument.defaultView) &&
				(computedStyle = defaultView.getComputedStyle( elem, null )) ) {

			ret = computedStyle.getPropertyValue( name );
			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
				ret = jQuery.style( elem, name );
			}
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// WebKit uses "computed value (percentage if specified)" instead of "used value" for margins
		// which is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( !jQuery.support.pixelMargin && computedStyle && rmargin.test( name ) && rnumnonpx.test( ret ) ) {
			width = style.width;
			style.width = ret;
			ret = computedStyle.width;
			style.width = width;
		}

		return ret;
	};
}

if ( document.documentElement.currentStyle ) {
	currentStyle = function( elem, name ) {
		var left, rsLeft, uncomputed,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && (uncomputed = style[ name ]) ) {
			ret = uncomputed;
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		if ( rnumnonpx.test( ret ) ) {

			// Remember the original values
			left = style.left;
			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

curCSS = getComputedStyle || currentStyle;

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property
	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		i = name === "width" ? 1 : 0,
		len = 4;

	if ( val > 0 ) {
		if ( extra !== "border" ) {
			for ( ; i < len; i += 2 ) {
				if ( !extra ) {
					val -= parseFloat( jQuery.css( elem, "padding" + cssExpand[ i ] ) ) || 0;
				}
				if ( extra === "margin" ) {
					val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ] ) ) || 0;
				} else {
					val -= parseFloat( jQuery.css( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
				}
			}
		}

		return val + "px";
	}

	// Fall back to computed then uncomputed css if necessary
	val = curCSS( elem, name );
	if ( val < 0 || val == null ) {
		val = elem.style[ name ];
	}

	// Computed unit is not pixels. Stop here and return.
	if ( rnumnonpx.test(val) ) {
		return val;
	}

	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Add padding, border, margin
	if ( extra ) {
		for ( ; i < len; i += 2 ) {
			val += parseFloat( jQuery.css( elem, "padding" + cssExpand[ i ] ) ) || 0;
			if ( extra !== "padding" ) {
				val += parseFloat( jQuery.css( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
			}
			if ( extra === "margin" ) {
				val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ]) ) || 0;
			}
		}
	}

	return val + "px";
}

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				if ( elem.offsetWidth !== 0 ) {
					return getWidthOrHeight( elem, name, extra );
				} else {
					return jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					});
				}
			}
		},

		set: function( elem, value ) {
			return rnum.test( value ) ?
				value + "px" :
				value;
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( parseFloat( RegExp.$1 ) / 100 ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there there is no filter style applied in a css rule, we are done
				if ( currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery(function() {
	// This hook cannot be added until DOM ready because the support test
	// for it is not run until after DOM ready
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				return jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						return curCSS( elem, "margin-right" );
					} else {
						return elem.style.marginRight;
					}
				});
			}
		};
	}
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		var width = elem.offsetWidth,
			height = elem.offsetHeight;

		return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {

	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i,

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ],
				expanded = {};

			for ( i = 0; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};
});




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rspacesAjax = /\s+/,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Document location
	ajaxLocation,

	// Document location segments
	ajaxLocParts,

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		if ( jQuery.isFunction( func ) ) {
			var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
				i = 0,
				length = dataTypes.length,
				dataType,
				list,
				placeBefore;

			// For each dataType in the dataTypeExpression
			for ( ; i < length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we're asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters ),
		selection;

	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we're only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it'll be ignored by the caller in that case
	return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
}

jQuery.fn.extend({
	load: function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );

		// Don't do a request if no elements are being requested
		} else if ( !this.length ) {
			return this;
		}

		var off = url.indexOf( " " );
		if ( off >= 0 ) {
			var selector = url.slice( off, url.length );
			url = url.slice( 0, off );
		}

		// Default to a GET request
		var type = "GET";

		// If the second parameter was provided
		if ( params ) {
			// If it's a function
			if ( jQuery.isFunction( params ) ) {
				// We assume that it's the callback
				callback = params;
				params = undefined;

			// Otherwise, build a param string
			} else if ( typeof params === "object" ) {
				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
				type = "POST";
			}
		}

		var self = this;

		// Request the remote document
		jQuery.ajax({
			url: url,
			type: type,
			dataType: "html",
			data: params,
			// Complete callback (responseText is used internally)
			complete: function( jqXHR, status, responseText ) {
				// Store the response as specified by the jqXHR object
				responseText = jqXHR.responseText;
				// If successful, inject the HTML into all the matched elements
				if ( jqXHR.isResolved() ) {
					// #4825: Get the actual response in case
					// a dataFilter is present in ajaxSettings
					jqXHR.done(function( r ) {
						responseText = r;
					});
					// See if a selector was specified
					self.html( selector ?
						// Create a dummy div to hold the results
						jQuery("<div>")
							// inject the contents of the document in, removing the scripts
							// to avoid any 'Permission Denied' errors in IE
							.append(responseText.replace(rscript, ""))

							// Locate the specified elements
							.find(selector) :

						// If not, just inject the full result
						responseText );
				}

				if ( callback ) {
					self.each( callback, [ responseText, status, jqXHR ] );
				}
			}
		});

		return this;
	},

	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},

	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.on( o, f );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		if ( settings ) {
			// Building a settings object
			ajaxExtend( target, jQuery.ajaxSettings );
		} else {
			// Extending ajaxSettings
			settings = target;
			target = jQuery.ajaxSettings;
		}
		ajaxExtend( target, settings );
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		traditional: false,
		headers: {},
		*/

		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": allTypes
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// List of data converters
		// 1) key format is "source_type destination_type" (a single space in-between)
		// 2) the catchall symbol "*" can be used for source_type
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			context: true,
			url: true
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events
			// It's the callbackContext if one was provided in the options
			// and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// ifModified key
			ifModifiedKey,
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// Response headers
			responseHeadersString,
			responseHeaders,
			// transport
			transport,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// The jqXHR state
			state = 0,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Fake xhr
			jqXHR = {

				readyState: 0,

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					statusText = statusText || "abort";
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		// It is defined here because jslint complains if it is declared
		// at the end of the function (which would be more logical and readable)
		function done( status, nativeStatusText, responses, headers ) {

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			var isSuccess,
				success,
				error,
				statusText = nativeStatusText,
				response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
				lastModified,
				etag;

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {

					if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
						jQuery.lastModified[ ifModifiedKey ] = lastModified;
					}
					if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
						jQuery.etag[ ifModifiedKey ] = etag;
					}
				}

				// If not modified
				if ( status === 304 ) {

					statusText = "notmodified";
					isSuccess = true;

				// If we have data
				} else {

					try {
						success = ajaxConvert( s, response );
						statusText = "success";
						isSuccess = true;
					} catch(e) {
						// We have a parsererror
						statusText = "parsererror";
						error = e;
					}
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( !statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = "" + ( nativeStatusText || statusText );

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		// Attach deferreds
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.add;

		// Status-dependent callbacks
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for ( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.then( tmp, tmp );
				}
			}
			return this;
		};

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// We also use the url parameter if available
		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

		// Determine if a cross-domain request is in order
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return false;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Get ifModifiedKey before adding the anti-cache parameter
			ifModifiedKey = s.url;

			// Add anti-cache in url if needed
			if ( s.cache === false ) {

				var ts = jQuery.now(),
					// try replacing _= if it is there
					ret = s.url.replace( rts, "$1_=" + ts );

				// if nothing was replaced, add timestamp to the end
				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
			}
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already
				jqXHR.abort();
				return false;

		}

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		return jqXHR;
	},

	// Serialize an array of form elements or a set of
	// key/values into a query string
	param: function( a, traditional ) {
		var s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : value;
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});

		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( var prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	}
});

function buildParams( prefix, obj, traditional, add ) {
	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( var name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields,
		ct,
		type,
		finalDataType,
		firstDataType;

	// Fill responseXXX fields
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	var dataTypes = s.dataTypes,
		converters = {},
		i,
		key,
		length = dataTypes.length,
		tmp,
		// Current and previous dataTypes
		current = dataTypes[ 0 ],
		prev,
		// Conversion expression
		conversion,
		// Conversion function
		conv,
		// Conversion functions (transitive conversion)
		conv1,
		conv2;

	// For each dataType in the chain
	for ( i = 1; i < length; i++ ) {

		// Create converters map
		// with lowercased keys
		if ( i === 1 ) {
			for ( key in s.converters ) {
				if ( typeof key === "string" ) {
					converters[ key.toLowerCase() ] = s.converters[ key ];
				}
			}
		}

		// Get the dataTypes
		prev = current;
		current = dataTypes[ i ];

		// If current is auto dataType, update it to prev
		if ( current === "*" ) {
			current = prev;
		// If no auto and dataTypes are actually different
		} else if ( prev !== "*" && prev !== current ) {

			// Get the converter
			conversion = prev + " " + current;
			conv = converters[ conversion ] || converters[ "* " + current ];

			// If there is no direct converter, search transitively
			if ( !conv ) {
				conv2 = undefined;
				for ( conv1 in converters ) {
					tmp = conv1.split( " " );
					if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
						conv2 = converters[ tmp[1] + " " + current ];
						if ( conv2 ) {
							conv1 = converters[ conv1 ];
							if ( conv1 === true ) {
								conv = conv2;
							} else if ( conv2 === true ) {
								conv = conv1;
							}
							break;
						}
					}
				}
			}
			// If we found no converter, dispatch an error
			if ( !( conv || conv2 ) ) {
				jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
			}
			// If found converter is not an equivalence
			if ( conv !== true ) {
				// Convert with 1 or 2 converters accordingly
				response = conv ? conv( response ) : conv2( conv1(response) );
			}
		}
	}
	return response;
}




var jsc = jQuery.now(),
	jsre = /(\=)\?(&|$)|\?\?/i;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		return jQuery.expando + "_" + ( jsc++ );
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var inspectData = ( typeof s.data === "string" ) && /^application\/x\-www\-form\-urlencoded/.test( s.contentType );

	if ( s.dataTypes[ 0 ] === "jsonp" ||
		s.jsonp !== false && ( jsre.test( s.url ) ||
				inspectData && jsre.test( s.data ) ) ) {

		var responseContainer,
			jsonpCallback = s.jsonpCallback =
				jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
			previous = window[ jsonpCallback ],
			url = s.url,
			data = s.data,
			replace = "$1" + jsonpCallback + "$2";

		if ( s.jsonp !== false ) {
			url = url.replace( jsre, replace );
			if ( s.url === url ) {
				if ( inspectData ) {
					data = data.replace( jsre, replace );
				}
				if ( s.data === data ) {
					// Add callback manually
					url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
				}
			}
		}

		s.url = url;
		s.data = data;

		// Install callback
		window[ jsonpCallback ] = function( response ) {
			responseContainer = [ response ];
		};

		// Clean-up function
		jqXHR.always(function() {
			// Set callback back to previous value
			window[ jsonpCallback ] = previous;
			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( previous ) ) {
				window[ jsonpCallback ]( responseContainer[ 0 ] );
			}
		});

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( jsonpCallback + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Delegate to script
		return "script";
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = "async";

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
				// This arises when a base node is used (#2709 and #4378).
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});




var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function() {
		// Abort all pending requests
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0,
	xhrCallbacks;

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax: !!xhr,
		cors: !!xhr && ( "withCredentials" in xhr )
	});
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var xhr = s.xhr(),
						handle,
						i;

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occured
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;

									// Construct response list
									if ( xml && xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}

									// When requesting binary data, IE6-9 will throw an exception
									// on any attempt to access responseText (#11426)
									try {
										responses.text = xhr.responseText;
									} catch( _ ) {
									}

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					// if we're in sync mode or it's in cache
					// and has been retrieved directly (IE6 & IE7)
					// we need to manually fire the callback
					if ( !s.async || xhr.readyState === 4 ) {
						callback();
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}




var elemdisplay = {},
	iframe, iframeDoc,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
	timerId,
	fxAttrs = [
		// height animations
		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
		// width animations
		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
		// opacity animations
		[ "opacity" ]
	],
	fxNow;

jQuery.fn.extend({
	show: function( speed, easing, callback ) {
		var elem, display;

		if ( speed || speed === 0 ) {
			return this.animate( genFx("show", 3), speed, easing, callback );

		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					// Reset the inline display of this element to learn if it is
					// being hidden by cascaded rules or not
					if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
						display = elem.style.display = "";
					}

					// Set elements which have been overridden with display: none
					// in a stylesheet to whatever the default browser style is
					// for such an element
					if ( (display === "" && jQuery.css(elem, "display") === "none") ||
						!jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
						jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
					}
				}
			}

			// Set the display of most of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					if ( display === "" || display === "none" ) {
						elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
					}
				}
			}

			return this;
		}
	},

	hide: function( speed, easing, callback ) {
		if ( speed || speed === 0 ) {
			return this.animate( genFx("hide", 3), speed, easing, callback);

		} else {
			var elem, display,
				i = 0,
				j = this.length;

			for ( ; i < j; i++ ) {
				elem = this[i];
				if ( elem.style ) {
					display = jQuery.css( elem, "display" );

					if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
						jQuery._data( elem, "olddisplay", display );
					}
				}
			}

			// Set the display of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				if ( this[i].style ) {
					this[i].style.display = "none";
				}
			}

			return this;
		}
	},

	// Save the old toggle function
	_toggle: jQuery.fn.toggle,

	toggle: function( fn, fn2, callback ) {
		var bool = typeof fn === "boolean";

		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
			this._toggle.apply( this, arguments );

		} else if ( fn == null || bool ) {
			this.each(function() {
				var state = bool ? fn : jQuery(this).is(":hidden");
				jQuery(this)[ state ? "show" : "hide" ]();
			});

		} else {
			this.animate(genFx("toggle", 3), fn, fn2, callback);
		}

		return this;
	},

	fadeTo: function( speed, to, easing, callback ) {
		return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({opacity: to}, speed, easing, callback);
	},

	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed( speed, easing, callback );

		if ( jQuery.isEmptyObject( prop ) ) {
			return this.each( optall.complete, [ false ] );
		}

		// Do not change referenced properties as per-property easing will be lost
		prop = jQuery.extend( {}, prop );

		function doAnimation() {
			// XXX 'this' does not always have a nodeName when running the
			// test suite

			if ( optall.queue === false ) {
				jQuery._mark( this );
			}

			var opt = jQuery.extend( {}, optall ),
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				name, val, p, e, hooks, replace,
				parts, start, end, unit,
				method;

			// will store per property easing and be used to determine when an animation is complete
			opt.animatedProperties = {};

			// first pass over propertys to expand / normalize
			for ( p in prop ) {
				name = jQuery.camelCase( p );
				if ( p !== name ) {
					prop[ name ] = prop[ p ];
					delete prop[ p ];
				}

				if ( ( hooks = jQuery.cssHooks[ name ] ) && "expand" in hooks ) {
					replace = hooks.expand( prop[ name ] );
					delete prop[ name ];

					// not quite $.extend, this wont overwrite keys already present.
					// also - reusing 'p' from above because we have the correct "name"
					for ( p in replace ) {
						if ( ! ( p in prop ) ) {
							prop[ p ] = replace[ p ];
						}
					}
				}
			}

			for ( name in prop ) {
				val = prop[ name ];
				// easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
				if ( jQuery.isArray( val ) ) {
					opt.animatedProperties[ name ] = val[ 1 ];
					val = prop[ name ] = val[ 0 ];
				} else {
					opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
				}

				if ( val === "hide" && hidden || val === "show" && !hidden ) {
					return opt.complete.call( this );
				}

				if ( isElement && ( name === "height" || name === "width" ) ) {
					// Make sure that nothing sneaks out
					// Record all 3 overflow attributes because IE does not
					// change the overflow attribute when overflowX and
					// overflowY are set to the same value
					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

					// Set display property to inline-block for height/width
					// animations on inline elements that are having width/height animated
					if ( jQuery.css( this, "display" ) === "inline" &&
							jQuery.css( this, "float" ) === "none" ) {

						// inline-level elements accept inline-block;
						// block-level elements need to be inline with layout
						if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
							this.style.display = "inline-block";

						} else {
							this.style.zoom = 1;
						}
					}
				}
			}

			if ( opt.overflow != null ) {
				this.style.overflow = "hidden";
			}

			for ( p in prop ) {
				e = new jQuery.fx( this, opt, p );
				val = prop[ p ];

				if ( rfxtypes.test( val ) ) {

					// Tracks whether to show or hide based on private
					// data attached to the element
					method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
					if ( method ) {
						jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
						e[ method ]();
					} else {
						e[ val ]();
					}

				} else {
					parts = rfxnum.exec( val );
					start = e.cur();

					if ( parts ) {
						end = parseFloat( parts[2] );
						unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );

						// We need to compute starting value
						if ( unit !== "px" ) {
							jQuery.style( this, p, (end || 1) + unit);
							start = ( (end || 1) / e.cur() ) * start;
							jQuery.style( this, p, start + unit);
						}

						// If a +=/-= token was provided, we're doing a relative animation
						if ( parts[1] ) {
							end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
						}

						e.custom( start, end, unit );

					} else {
						e.custom( start, val, "" );
					}
				}
			}

			// For JS strict compliance
			return true;
		}

		return optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},

	stop: function( type, clearQueue, gotoEnd ) {
		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var index,
				hadTimers = false,
				timers = jQuery.timers,
				data = jQuery._data( this );

			// clear marker counters if we know they won't be
			if ( !gotoEnd ) {
				jQuery._unmark( true, this );
			}

			function stopQueue( elem, data, index ) {
				var hooks = data[ index ];
				jQuery.removeData( elem, index, true );
				hooks.stop( gotoEnd );
			}

			if ( type == null ) {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
						stopQueue( this, data, index );
					}
				}
			} else if ( data[ index = type + ".run" ] && data[ index ].stop ){
				stopQueue( this, data, index );
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					if ( gotoEnd ) {

						// force the next step to be the last
						timers[ index ]( true );
					} else {
						timers[ index ].saveState();
					}
					hadTimers = true;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( !( gotoEnd && hadTimers ) ) {
				jQuery.dequeue( this, type );
			}
		});
	}

});

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout( clearFxNow, 0 );
	return ( fxNow = jQuery.now() );
}

function clearFxNow() {
	fxNow = undefined;
}

// Generate parameters to create a standard animation
function genFx( type, num ) {
	var obj = {};

	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
		obj[ this ] = type;
	});

	return obj;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx( "show", 1 ),
	slideUp: genFx( "hide", 1 ),
	slideToggle: genFx( "toggle", 1 ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.extend({
	speed: function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function( noUnmark ) {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			} else if ( noUnmark !== false ) {
				jQuery._unmark( this );
			}
		};

		return opt;
	},

	easing: {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return ( -Math.cos( p*Math.PI ) / 2 ) + 0.5;
		}
	},

	timers: [],

	fx: function( elem, options, prop ) {
		this.options = options;
		this.elem = elem;
		this.prop = prop;

		options.orig = options.orig || {};
	}

});

jQuery.fx.prototype = {
	// Simple function for setting a style value
	update: function() {
		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
	},

	// Get the current size
	cur: function() {
		if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
			return this.elem[ this.prop ];
		}

		var parsed,
			r = jQuery.css( this.elem, this.prop );
		// Empty strings, null, undefined and "auto" are converted to 0,
		// complex values such as "rotate(1rad)" are returned as is,
		// simple values such as "10px" are parsed to Float.
		return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
	},

	// Start an animation from one number to another
	custom: function( from, to, unit ) {
		var self = this,
			fx = jQuery.fx;

		this.startTime = fxNow || createFxNow();
		this.end = to;
		this.now = this.start = from;
		this.pos = this.state = 0;
		this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );

		function t( gotoEnd ) {
			return self.step( gotoEnd );
		}

		t.queue = this.options.queue;
		t.elem = this.elem;
		t.saveState = function() {
			if ( jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
				if ( self.options.hide ) {
					jQuery._data( self.elem, "fxshow" + self.prop, self.start );
				} else if ( self.options.show ) {
					jQuery._data( self.elem, "fxshow" + self.prop, self.end );
				}
			}
		};

		if ( t() && jQuery.timers.push(t) && !timerId ) {
			timerId = setInterval( fx.tick, fx.interval );
		}
	},

	// Simple 'show' function
	show: function() {
		var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );

		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
		this.options.show = true;

		// Begin the animation
		// Make sure that we start at a small width/height to avoid any flash of content
		if ( dataShow !== undefined ) {
			// This show is picking up where a previous hide or show left off
			this.custom( this.cur(), dataShow );
		} else {
			this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
		}

		// Start by showing the element
		jQuery( this.elem ).show();
	},

	// Simple 'hide' function
	hide: function() {
		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
		this.options.hide = true;

		// Begin the animation
		this.custom( this.cur(), 0 );
	},

	// Each step of an animation
	step: function( gotoEnd ) {
		var p, n, complete,
			t = fxNow || createFxNow(),
			done = true,
			elem = this.elem,
			options = this.options;

		if ( gotoEnd || t >= options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();

			options.animatedProperties[ this.prop ] = true;

			for ( p in options.animatedProperties ) {
				if ( options.animatedProperties[ p ] !== true ) {
					done = false;
				}
			}

			if ( done ) {
				// Reset the overflow
				if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {

					jQuery.each( [ "", "X", "Y" ], function( index, value ) {
						elem.style[ "overflow" + value ] = options.overflow[ index ];
					});
				}

				// Hide the element if the "hide" operation was done
				if ( options.hide ) {
					jQuery( elem ).hide();
				}

				// Reset the properties, if the item has been hidden or shown
				if ( options.hide || options.show ) {
					for ( p in options.animatedProperties ) {
						jQuery.style( elem, p, options.orig[ p ] );
						jQuery.removeData( elem, "fxshow" + p, true );
						// Toggle data is no longer needed
						jQuery.removeData( elem, "toggle" + p, true );
					}
				}

				// Execute the complete function
				// in the event that the complete function throws an exception
				// we must ensure it won't be called twice. #5684

				complete = options.complete;
				if ( complete ) {

					options.complete = false;
					complete.call( elem );
				}
			}

			return false;

		} else {
			// classical easing cannot be used with an Infinity duration
			if ( options.duration == Infinity ) {
				this.now = t;
			} else {
				n = t - this.startTime;
				this.state = n / options.duration;

				// Perform the easing function, defaults to swing
				this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
				this.now = this.start + ( (this.end - this.start) * this.pos );
			}
			// Perform the next step of the animation
			this.update();
		}

		return true;
	}
};

jQuery.extend( jQuery.fx, {
	tick: function() {
		var timer,
			timers = jQuery.timers,
			i = 0;

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
	},

	interval: 13,

	stop: function() {
		clearInterval( timerId );
		timerId = null;
	},

	speeds: {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	},

	step: {
		opacity: function( fx ) {
			jQuery.style( fx.elem, "opacity", fx.now );
		},

		_default: function( fx ) {
			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
				fx.elem.style[ fx.prop ] = fx.now + fx.unit;
			} else {
				fx.elem[ fx.prop ] = fx.now;
			}
		}
	}
});

// Ensure props that can't be negative don't go there on undershoot easing
jQuery.each( fxAttrs.concat.apply( [], fxAttrs ), function( i, prop ) {
	// exclude marginTop, marginLeft, marginBottom and marginRight from this list
	if ( prop.indexOf( "margin" ) ) {
		jQuery.fx.step[ prop ] = function( fx ) {
			jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
		};
	}
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}

// Try to restore the default display value of an element
function defaultDisplay( nodeName ) {

	if ( !elemdisplay[ nodeName ] ) {

		var body = document.body,
			elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
			display = elem.css( "display" );
		elem.remove();

		// If the simple way fails,
		// get element's real default display by attaching it to a temp iframe
		if ( display === "none" || display === "" ) {
			// No iframe to use yet, so create it
			if ( !iframe ) {
				iframe = document.createElement( "iframe" );
				iframe.frameBorder = iframe.width = iframe.height = 0;
			}

			body.appendChild( iframe );

			// Create a cacheable copy of the iframe document on first call.
			// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
			// document to it; WebKit & Firefox won't allow reusing the iframe document.
			if ( !iframeDoc || !iframe.createElement ) {
				iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
				iframeDoc.write( ( jQuery.support.boxModel ? "<!doctype html>" : "" ) + "<html><body>" );
				iframeDoc.close();
			}

			elem = iframeDoc.createElement( nodeName );

			iframeDoc.body.appendChild( elem );

			display = jQuery.css( elem, "display" );
			body.removeChild( iframe );
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return elemdisplay[ nodeName ];
}




var getOffset,
	rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

if ( "getBoundingClientRect" in document.documentElement ) {
	getOffset = function( elem, doc, docElem, box ) {
		try {
			box = elem.getBoundingClientRect();
		} catch(e) {}

		// Make sure we're not dealing with a disconnected DOM node
		if ( !box || !jQuery.contains( docElem, elem ) ) {
			return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
		}

		var body = doc.body,
			win = getWindow( doc ),
			clientTop  = docElem.clientTop  || body.clientTop  || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
			top  = box.top  + scrollTop  - clientTop,
			left = box.left + scrollLeft - clientLeft;

		return { top: top, left: left };
	};

} else {
	getOffset = function( elem, doc, docElem ) {
		var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;

		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
			if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
				break;
			}

			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
			top  -= elem.scrollTop;
			left -= elem.scrollLeft;

			if ( elem === offsetParent ) {
				top  += elem.offsetTop;
				left += elem.offsetLeft;

				if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
				}

				prevOffsetParent = offsetParent;
				offsetParent = elem.offsetParent;
			}

			if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
			}

			prevComputedStyle = computedStyle;
		}

		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
			top  += body.offsetTop;
			left += body.offsetLeft;
		}

		if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
			top  += Math.max( docElem.scrollTop, body.scrollTop );
			left += Math.max( docElem.scrollLeft, body.scrollLeft );
		}

		return { top: top, left: left };
	};
}

jQuery.fn.offset = function( options ) {
	if ( arguments.length ) {
		return options === undefined ?
			this :
			this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
	}

	var elem = this[0],
		doc = elem && elem.ownerDocument;

	if ( !doc ) {
		return null;
	}

	if ( elem === doc.body ) {
		return jQuery.offset.bodyOffset( elem );
	}

	return getOffset( elem, doc, doc.documentElement );
};

jQuery.offset = {

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[0] ) {
			return null;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return jQuery.access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					jQuery.support.boxModel && win.document.documentElement[ method ] ||
						win.document.body[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					 top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}




// Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	var clientProp = "client" + name,
		scrollProp = "scroll" + name,
		offsetProp = "offset" + name;

	// innerHeight and innerWidth
	jQuery.fn[ "inner" + name ] = function() {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, "padding" ) ) :
			this[ type ]() :
			null;
	};

	// outerHeight and outerWidth
	jQuery.fn[ "outer" + name ] = function( margin ) {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
			this[ type ]() :
			null;
	};

	jQuery.fn[ type ] = function( value ) {
		return jQuery.access( this, function( elem, type, value ) {
			var doc, docElemProp, orig, ret;

			if ( jQuery.isWindow( elem ) ) {
				// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
				doc = elem.document;
				docElemProp = doc.documentElement[ clientProp ];
				return jQuery.support.boxModel && docElemProp ||
					doc.body && doc.body[ clientProp ] || docElemProp;
			}

			// Get document width or height
			if ( elem.nodeType === 9 ) {
				// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
				doc = elem.documentElement;

				// when a window > document, IE6 reports a offset[Width/Height] > client[Width/Height]
				// so we can't use max, as it'll choose the incorrect offset[Width/Height]
				// instead we use the correct client[Width/Height]
				// support:IE6
				if ( doc[ clientProp ] >= doc[ scrollProp ] ) {
					return doc[ clientProp ];
				}

				return Math.max(
					elem.body[ scrollProp ], doc[ scrollProp ],
					elem.body[ offsetProp ], doc[ offsetProp ]
				);
			}

			// Get width or height on the element
			if ( value === undefined ) {
				orig = jQuery.css( elem, type );
				ret = parseFloat( orig );
				return jQuery.isNumeric( ret ) ? ret : orig;
			}

			// Set the width or height on the element
			jQuery( elem ).css( type, value );
		}, type, value, arguments.length, null );
	};
});




// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
	define( "jquery", [], function () { return jQuery; } );
}



})( window );
},{}],26:[function(require,module,exports){
/*
    http://www.JSON.org/json2.js
    2009-06-29

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html

    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the object holding the key.

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.

    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.
*/

/*jslint evil: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/

// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON = JSON || {};

(function () {

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                   this.getUTCFullYear()   + '-' +
                 f(this.getUTCMonth() + 1) + '-' +
                 f(this.getUTCDate())      + 'T' +
                 f(this.getUTCHours())     + ':' +
                 f(this.getUTCMinutes())   + ':' +
                 f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON =
        Number.prototype.toJSON =
        Boolean.prototype.toJSON = function (key) {
            return this.valueOf();
        };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ?
            '"' + string.replace(escapable, function (a) {
                var c = meta[a];
                return typeof c === 'string' ? c :
                    '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' :
            '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' :
                    gap ? '[\n' + gap +
                            partial.join(',\n' + gap) + '\n' +
                                mind + ']' :
                          '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' :
                gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' +
                        mind + '}' : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                     typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/.
test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').
replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());

},{}],27:[function(require,module,exports){
/*
 * jsTree (custom version for SilverStripe: 1.0-rc3 + minor bugfixes)
 * http://jstree.com/
 *
 * Copyright (c) 2010 Ivan Bozhanov (vakata.com)
 *
 * Licensed same as jquery - under the terms of either the MIT License or the GPL Version 2 License
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 *
 * $Date: 2011-02-09 01:17:14 +0200 (ср, 09 февр 2011) $
 * $Revision: 236 $
 */

/*jslint browser: true, onevar: true, undef: true, bitwise: true, strict: true */
/*global window : false, clearInterval: false, clearTimeout: false, document: false, setInterval: false, setTimeout: false, jQuery: false, navigator: false, XSLTProcessor: false, DOMParser: false, XMLSerializer: false*/

"use strict";

// top wrapper to prevent multiple inclusion (is this OK?)
(function () { if(jQuery && jQuery.jstree) { return; }
	var is_ie6 = false, is_ie7 = false, is_ff2 = false;

/* 
 * jsTree core
 */
(function ($) {
	// Common functions not related to jsTree 
	// decided to move them to a `vakata` "namespace"
	$.vakata = {};
	// CSS related functions
	$.vakata.css = {
		get_css : function(rule_name, delete_flag, sheet) {
			rule_name = rule_name.toLowerCase();
			var css_rules = sheet.cssRules || sheet.rules,
				j = 0;
			do {
				if(css_rules.length && j > css_rules.length + 5) { return false; }
				if(css_rules[j].selectorText && css_rules[j].selectorText.toLowerCase() == rule_name) {
					if(delete_flag === true) {
						if(sheet.removeRule) { sheet.removeRule(j); }
						if(sheet.deleteRule) { sheet.deleteRule(j); }
						return true;
					}
					else { return css_rules[j]; }
				}
			}
			while (css_rules[++j]);
			return false;
		},
		add_css : function(rule_name, sheet) {
			if($.jstree.css.get_css(rule_name, false, sheet)) { return false; }
			if(sheet.insertRule) { sheet.insertRule(rule_name + ' { }', 0); } else { sheet.addRule(rule_name, null, 0); }
			return $.vakata.css.get_css(rule_name);
		},
		remove_css : function(rule_name, sheet) { 
			return $.vakata.css.get_css(rule_name, true, sheet); 
		},
		add_sheet : function(opts) {
		  // MODIFIED ischommer/SilverStripe: add_sheet significantly slows down rendering,
		  // we're loading all required CSS directly rather than adding it inline
		  
      // var tmp = false, is_new = true;
      // if(opts.str) {
      //  if(opts.title) { tmp = $("style[id='" + opts.title + "-stylesheet']")[0]; }
      //  if(tmp) { is_new = false; }
      //  else {
      //    tmp = document.createElement("style");
      //    tmp.setAttribute('type',"text/css");
      //    if(opts.title) { tmp.setAttribute("id", opts.title + "-stylesheet"); }
      //  }
      //  if(tmp.styleSheet) {
      //    if(is_new) { 
      //      document.getElementsByTagName("head")[0].appendChild(tmp); 
      //      tmp.styleSheet.cssText = opts.str; 
      //    }
      //    else {
      //      tmp.styleSheet.cssText = tmp.styleSheet.cssText + " " + opts.str; 
      //    }
      //  }
      //  else {
      //    tmp.appendChild(document.createTextNode(opts.str));
      //    document.getElementsByTagName("head")[0].appendChild(tmp);
      //  }
      //  return tmp.sheet || tmp.styleSheet;
      // }
      // if(opts.url) {
      //  if(document.createStyleSheet) {
      //    try { tmp = document.createStyleSheet(opts.url); } catch (e) { }
      //  }
      //  else {
      //    tmp     = document.createElement('link');
      //    tmp.rel   = 'stylesheet';
      //    tmp.type  = 'text/css';
      //    tmp.media = "all";
      //    tmp.href  = opts.url;
      //    document.getElementsByTagName("head")[0].appendChild(tmp);
      //    return tmp.styleSheet;
      //  }
      // }
		}
	};

	// private variables 
	var instances = [],			// instance array (used by $.jstree.reference/create/focused)
		focused_instance = -1,	// the index in the instance array of the currently focused instance
		plugins = {},			// list of included plugins
		prepared_move = {};		// for the move_node function

	// jQuery plugin wrapper (thanks to jquery UI widget function)
	$.fn.jstree = function (settings) {
		var isMethodCall = (typeof settings == 'string'), // is this a method call like $().jstree("open_node")
			args = Array.prototype.slice.call(arguments, 1), 
			returnValue = this;

		// if a method call execute the method on all selected instances
		if(isMethodCall) {
			if(settings.substring(0, 1) == '_') { return returnValue; }
			this.each(function() {
				var instance = instances[$.data(this, "jstree_instance_id")],
					methodValue = (instance && $.isFunction(instance[settings])) ? instance[settings].apply(instance, args) : instance;
					if(typeof methodValue !== "undefined" && (settings.indexOf("is_") === 0 || (methodValue !== true && methodValue !== false))) { returnValue = methodValue; return false; }
			});
		}
		else {
			this.each(function() {
				// extend settings and allow for multiple hashes and $.data
				var instance_id = $.data(this, "jstree_instance_id"),
					a = [],
					b = settings ? $.extend({}, true, settings) : {},
					c = $(this), 
					s = false, 
					t = [];
				a = a.concat(args);
				if(c.data("jstree")) { a.push(c.data("jstree")); }
				b = a.length ? $.extend.apply(null, [true, b].concat(a)) : b;

				// if an instance already exists, destroy it first
				if(typeof instance_id !== "undefined" && instances[instance_id]) { instances[instance_id].destroy(); }
				// push a new empty object to the instances array
				instance_id = parseInt(instances.push({}),10) - 1;
				// store the jstree instance id to the container element
				$.data(this, "jstree_instance_id", instance_id);
				// clean up all plugins
				b.plugins = $.isArray(b.plugins) ? b.plugins : $.jstree.defaults.plugins.slice();
				b.plugins.unshift("core");
				// only unique plugins
				b.plugins = b.plugins.sort().join(",,").replace(/(,|^)([^,]+)(,,\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",");

				// extend defaults with passed data
				s = $.extend(true, {}, $.jstree.defaults, b);
				s.plugins = b.plugins;
				$.each(plugins, function (i, val) { 
					if($.inArray(i, s.plugins) === -1) { s[i] = null; delete s[i]; } 
					else { t.push(i); }
				});
				s.plugins = t;

				// push the new object to the instances array (at the same time set the default classes to the container) and init
				instances[instance_id] = new $.jstree._instance(instance_id, $(this).addClass("jstree jstree-" + instance_id), s); 
				// init all activated plugins for this instance
				$.each(instances[instance_id]._get_settings().plugins, function (i, val) { instances[instance_id].data[val] = {}; });
				$.each(instances[instance_id]._get_settings().plugins, function (i, val) { if(plugins[val]) { plugins[val].__init.apply(instances[instance_id]); } });
				// initialize the instance
				setTimeout(function() { if(instances[instance_id]) { instances[instance_id].init(); } }, 0);
			});
		}
		// return the jquery selection (or if it was a method call that returned a value - the returned value)
		return returnValue;
	};
	// object to store exposed functions and objects
	$.jstree = {
		defaults : {
			plugins : []
		},
		_focused : function () { return instances[focused_instance] || null; },
		_reference : function (needle) { 
			// get by instance id
			if(instances[needle]) { return instances[needle]; }
			// get by DOM (if still no luck - return null
			var o = $(needle); 
			if(!o.length && typeof needle === "string") { o = $("#" + needle); }
			if(!o.length) { return null; }
			return instances[o.closest(".jstree").data("jstree_instance_id")] || null; 
		},
		_instance : function (index, container, settings) { 
			// for plugins to store data in
			this.data = { core : {} };
			this.get_settings	= function () { return $.extend(true, {}, settings); };
			this._get_settings	= function () { return settings; };
			this.get_index		= function () { return index; };
			this.get_container	= function () { return container; };
			this.get_container_ul = function () { return container.children("ul:eq(0)"); };
			this._set_settings	= function (s) { 
				settings = $.extend(true, {}, settings, s);
			};
		},
		_fn : { },
		plugin : function (pname, pdata) {
			pdata = $.extend({}, {
				__init		: $.noop, 
				__destroy	: $.noop,
				_fn			: {},
				defaults	: false
			}, pdata);
			plugins[pname] = pdata;

			$.jstree.defaults[pname] = pdata.defaults;
			$.each(pdata._fn, function (i, val) {
				val.plugin		= pname;
				val.old			= $.jstree._fn[i];
				$.jstree._fn[i] = function () {
					var rslt,
						func = val,
						args = Array.prototype.slice.call(arguments),
						evnt = new $.Event("before.jstree"),
						rlbk = false;

					if(this.data.core.locked === true && i !== "unlock" && i !== "is_locked") { return; }

					// Check if function belongs to the included plugins of this instance
					do {
						if(func && func.plugin && $.inArray(func.plugin, this._get_settings().plugins) !== -1) { break; }
						func = func.old;
					} while(func);
					if(!func) { return; }

					// context and function to trigger events, then finally call the function
					if(i.indexOf("_") === 0) {
						rslt = func.apply(this, args);
					}
					else {
						rslt = this.get_container().triggerHandler(evnt, { "func" : i, "inst" : this, "args" : args, "plugin" : func.plugin });
						if(rslt === false) { return; }
						if(typeof rslt !== "undefined") { args = rslt; }

						rslt = func.apply(
							$.extend({}, this, { 
								__callback : function (data) { 
									this.get_container().triggerHandler( i + '.jstree', { "inst" : this, "args" : args, "rslt" : data, "rlbk" : rlbk });
								},
								__rollback : function () { 
									rlbk = this.get_rollback();
									return rlbk;
								},
								__call_old : function (replace_arguments) {
									return func.old.apply(this, (replace_arguments ? Array.prototype.slice.call(arguments, 1) : args ) );
								}
							}), args);
					}

					// return the result
					return rslt;
				};
				$.jstree._fn[i].old = val.old;
				$.jstree._fn[i].plugin = pname;
			});
		},
		rollback : function (rb) {
			if(rb) {
				if(!$.isArray(rb)) { rb = [ rb ]; }
				$.each(rb, function (i, val) {
					instances[val.i].set_rollback(val.h, val.d);
				});
			}
		}
	};
	// set the prototype for all instances
	$.jstree._fn = $.jstree._instance.prototype = {};

	// load the css when DOM is ready
	$(function() {
		// code is copied from jQuery ($.browser is deprecated + there is a bug in IE)
		var u = navigator.userAgent.toLowerCase(),
			v = (u.match( /.+?(?:rv|it|ra|ie)[\/: ]([\d.]+)/ ) || [0,'0'])[1],
			css_string = '' + 
				'.jstree ul, .jstree li { display:block; margin:0 0 0 0; padding:0 0 0 0; list-style-type:none; } ' + 
				'.jstree li { display:block; min-height:18px; line-height:18px; white-space:nowrap; margin-left:18px; min-width:18px; } ' + 
				'.jstree-rtl li { margin-left:0; margin-right:18px; } ' + 
				'.jstree > ul > li { margin-left:0px; } ' + 
				'.jstree-rtl > ul > li { margin-right:0px; } ' + 
				'.jstree ins { display:inline-block; text-decoration:none; width:18px; height:18px; margin:0 0 0 0; padding:0; } ' + 
				'.jstree a { display:inline-block; line-height:16px; height:16px; color:black; white-space:nowrap; text-decoration:none; padding:1px 2px; margin:0; } ' + 
				'.jstree a:focus { outline: none; } ' + 
				'.jstree a > ins { height:16px; width:16px; } ' + 
				'.jstree a > .jstree-icon { margin-right:3px; } ' + 
				'.jstree-rtl a > .jstree-icon { margin-left:3px; margin-right:0; } ' + 
				'li.jstree-open > ul { display:block; } ' + 
				'li.jstree-closed > ul { display:none; } ';
		// Correct IE 6 (does not support the > CSS selector)
		if(/msie/.test(u) && parseInt(v, 10) == 6) { 
			is_ie6 = true;

			// fix image flicker and lack of caching
			try {
				document.execCommand("BackgroundImageCache", false, true);
			} catch (err) { }

			css_string += '' + 
				'.jstree li { height:18px; margin-left:0; margin-right:0; } ' + 
				'.jstree li li { margin-left:18px; } ' + 
				'.jstree-rtl li li { margin-left:0px; margin-right:18px; } ' + 
				'li.jstree-open ul { display:block; } ' + 
				'li.jstree-closed ul { display:none !important; } ' + 
				'.jstree li a { display:inline; border-width:0 !important; padding:0px 2px !important; } ' + 
				'.jstree li a ins { height:16px; width:16px; margin-right:3px; } ' + 
				'.jstree-rtl li a ins { margin-right:0px; margin-left:3px; } ';
		}
		// Correct IE 7 (shifts anchor nodes onhover)
		if(/msie/.test(u) && parseInt(v, 10) == 7) { 
			is_ie7 = true;
			css_string += '.jstree li a { border-width:0 !important; padding:0px 2px !important; } ';
		}
		// correct ff2 lack of display:inline-block
		if(!/compatible/.test(u) && /mozilla/.test(u) && parseFloat(v, 10) < 1.9) {
			is_ff2 = true;
			css_string += '' + 
				'.jstree ins { display:-moz-inline-box; } ' + 
				'.jstree li { line-height:12px; } ' + // WHY??
				'.jstree a { display:-moz-inline-box; } ' + 
				'.jstree .jstree-no-icons .jstree-checkbox { display:-moz-inline-stack !important; } ';
				/* this shouldn't be here as it is theme specific */
		}
		// the default stylesheet
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
	});

	// core functions (open, close, create, update, delete)
	$.jstree.plugin("core", {
		__init : function () {
			this.data.core.locked = false;
			this.data.core.to_open = this.get_settings().core.initially_open;
			this.data.core.to_load = this.get_settings().core.initially_load;
		},
		defaults : { 
			html_titles	: false,
			animation	: 500,
			initially_open : [],
			initially_load : [],
			open_parents : true,
			notify_plugins : true,
			rtl			: false,
			load_open	: false,
			strings		: {
				loading		: "Loading ...",
				new_node	: "New node",
				multiple_selection : "Multiple selection"
			}
		},
		_fn : { 
			init	: function () { 
				this.set_focus(); 
				if(this._get_settings().core.rtl) {
					this.get_container().addClass("jstree-rtl").css("direction", "rtl");
				}
				this.get_container().html("<ul><li class='jstree-last jstree-leaf'><ins>&#160;</ins><a class='jstree-loading' href='#'><ins class='jstree-icon'>&#160;</ins>" + this._get_string("loading") + "</a></li></ul>");
				this.data.core.li_height = this.get_container_ul().find("li.jstree-closed, li.jstree-leaf").eq(0).height() || 18;

				this.get_container()
					.delegate("li > ins", "click.jstree", $.proxy(function (event) {
							var trgt = $(event.target);
							// if(trgt.is("ins") && event.pageY - trgt.offset().top < this.data.core.li_height) { this.toggle_node(trgt); }
							this.toggle_node(trgt);
						}, this))
					.bind("mousedown.jstree", $.proxy(function () { 
							this.set_focus(); // This used to be setTimeout(set_focus,0) - why?
						}, this))
					.bind("dblclick.jstree", function (event) { 
						var sel;
						if(document.selection && document.selection.empty) { document.selection.empty(); }
						else {
							if(window.getSelection) {
								sel = window.getSelection();
								try { 
									sel.removeAllRanges();
									sel.collapse();
								} catch (err) { }
							}
						}
					});
				if(this._get_settings().core.notify_plugins) {
					this.get_container()
						.bind("load_node.jstree", $.proxy(function (e, data) { 
								var o = this._get_node(data.rslt.obj),
									t = this;
								if(o === -1) { o = this.get_container_ul(); }
								if(!o.length) { return; }
								o.find("li").each(function () {
									var th = $(this);
									if(th.data("jstree")) {
										$.each(th.data("jstree"), function (plugin, values) {
											if(t.data[plugin] && $.isFunction(t["_" + plugin + "_notify"])) {
												t["_" + plugin + "_notify"].call(t, th, values);
											}
										});
									}
								});
							}, this));
				}
				if(this._get_settings().core.load_open) {
					this.get_container()
						.bind("load_node.jstree", $.proxy(function (e, data) { 
								var o = this._get_node(data.rslt.obj),
									t = this;
								if(o === -1) { o = this.get_container_ul(); }
								if(!o.length) { return; }
								o.find("li.jstree-open:not(:has(ul))").each(function () {
									t.load_node(this, $.noop, $.noop);
								});
							}, this));
				}
				this.__callback();
				this.load_node(-1, function () { this.loaded(); this.reload_nodes(); });
			},
			destroy	: function () { 
				var i,
					n = this.get_index(),
					s = this._get_settings(),
					_this = this;

				$.each(s.plugins, function (i, val) {
					try { plugins[val].__destroy.apply(_this); } catch(err) { }
				});
				this.__callback();
				// set focus to another instance if this one is focused
				if(this.is_focused()) { 
					for(i in instances) { 
						if(instances.hasOwnProperty(i) && i != n) { 
							instances[i].set_focus(); 
							break; 
						} 
					}
				}
				// if no other instance found
				if(n === focused_instance) { focused_instance = -1; }
				// remove all traces of jstree in the DOM (only the ones set using jstree*) and cleans all events
				this.get_container()
					.unbind(".jstree")
					.undelegate(".jstree")
					.removeData("jstree_instance_id")
					.find("[class^='jstree']")
						.andSelf()
						.attr("class", function () { return this.className.replace(/jstree[^ ]*|$/ig,''); });
				$(document)
					.unbind(".jstree-" + n)
					.undelegate(".jstree-" + n);
				// remove the actual data
				instances[n] = null;
				delete instances[n];
			},

			_core_notify : function (n, data) {
				if(data.opened) {
					this.open_node(n, false, true);
				}
			},

			lock : function () {
				this.data.core.locked = true;
				this.get_container().children("ul").addClass("jstree-locked").css("opacity","0.7");
				this.__callback({});
			},
			unlock : function () {
				this.data.core.locked = false;
				this.get_container().children("ul").removeClass("jstree-locked").css("opacity","1");
				this.__callback({});
			},
			is_locked : function () { return this.data.core.locked; },
			save_opened : function () {
				var _this = this;
				this.data.core.to_open = [];
				this.get_container_ul().find("li.jstree-open").each(function () { 
					if(this.id) { _this.data.core.to_open.push("#" + this.id.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:")); }
				});
				this.__callback(_this.data.core.to_open);
			},
			save_loaded : function () { },
			reload_nodes : function (is_callback) {
				var _this = this,
					done = true,
					current = [],
					remaining = [];
				if(!is_callback) { 
					this.data.core.reopen = false; 
					this.data.core.refreshing = true; 
					this.data.core.to_open = $.map($.makeArray(this.data.core.to_open), function (n) { return "#" + n.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:"); });
					this.data.core.to_load = $.map($.makeArray(this.data.core.to_load), function (n) { return "#" + n.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:"); });
					if(this.data.core.to_open.length) {
						this.data.core.to_load = this.data.core.to_load.concat(this.data.core.to_open);
					}
				}
				if(this.data.core.to_load.length) {
					$.each(this.data.core.to_load, function (i, val) {
						if(val == "#") { return true; }
						if($(val).length) { current.push(val); }
						else { remaining.push(val); }
					});
					if(current.length) {
						this.data.core.to_load = remaining;
						$.each(current, function (i, val) { 
							if(!_this._is_loaded(val)) {
								_this.load_node(val, function () { _this.reload_nodes(true); }, function () { _this.reload_nodes(true); });
								done = false;
							}
						});
					}
				}
				if(this.data.core.to_open.length) {
					$.each(this.data.core.to_open, function (i, val) {
						_this.open_node(val, false, true); 
					});
				}
				if(done) { 
					// TODO: find a more elegant approach to syncronizing returning requests
					if(this.data.core.reopen) { clearTimeout(this.data.core.reopen); }
					this.data.core.reopen = setTimeout(function () { _this.__callback({}, _this); }, 50);
					this.data.core.refreshing = false;
					this.reopen();
				}
			},
			reopen : function () {
				var _this = this;
				if(this.data.core.to_open.length) {
					$.each(this.data.core.to_open, function (i, val) {
						_this.open_node(val, false, true); 
					});
				}
				this.__callback({});
			},
			refresh : function (obj, s_call, e_call) {
				var _this = this;
				this.save_opened();
				if(!obj) { obj = -1; }
				obj = this._get_node(obj);
				if(!obj) { obj = -1; }
				if(obj !== -1) { obj.children("UL").remove(); }
				else { this.get_container_ul().empty(); }
				this.load_node(
					obj, 
					function () { 
						_this.__callback({ "obj" : obj}); 
						_this.reload_nodes(); 
						if(s_call) s_call.call(this); 
					},
					e_call
				);
			},
			// Dummy function to fire after the first load (so that there is a jstree.loaded event)
			loaded	: function () { 
				this.__callback(); 
			},
			// deal with focus
			set_focus	: function () { 
				if(this.is_focused()) { return; }
				var f = $.jstree._focused();
				if(f) { f.unset_focus(); }

				this.get_container().addClass("jstree-focused"); 
				focused_instance = this.get_index(); 
				this.__callback();
			},
			is_focused	: function () { 
				return focused_instance == this.get_index(); 
			},
			unset_focus	: function () {
				if(this.is_focused()) {
					this.get_container().removeClass("jstree-focused"); 
					focused_instance = -1; 
				}
				this.__callback();
			},

			// traverse
			_get_node		: function (obj) { 
				var $obj = $(obj, this.get_container()); 
				if($obj.is(".jstree") || obj == -1) { return -1; } 
				$obj = $obj.closest("li", this.get_container()); 
				return $obj.length ? $obj : false; 
			},
			_get_next		: function (obj, strict) {
				obj = this._get_node(obj);
				if(obj === -1) { return this.get_container().find("> ul > li:first-child"); }
				if(!obj.length) { return false; }
				if(strict) { return (obj.nextAll("li").size() > 0) ? obj.nextAll("li:eq(0)") : false; }

				if(obj.hasClass("jstree-open")) { return obj.find("li:eq(0)"); }
				else if(obj.nextAll("li").size() > 0) { return obj.nextAll("li:eq(0)"); }
				else { return obj.parentsUntil(".jstree","li").next("li").eq(0); }
			},
			_get_prev		: function (obj, strict) {
				obj = this._get_node(obj);
				if(obj === -1) { return this.get_container().find("> ul > li:last-child"); }
				if(!obj.length) { return false; }
				if(strict) { return (obj.prevAll("li").length > 0) ? obj.prevAll("li:eq(0)") : false; }

				if(obj.prev("li").length) {
					obj = obj.prev("li").eq(0);
					while(obj.hasClass("jstree-open")) { obj = obj.children("ul:eq(0)").children("li:last"); }
					return obj;
				}
				else { var o = obj.parentsUntil(".jstree","li:eq(0)"); return o.length ? o : false; }
			},
			_get_parent		: function (obj) {
				obj = this._get_node(obj);
				if(obj == -1 || !obj.length) { return false; }
				var o = obj.parentsUntil(".jstree", "li:eq(0)");
				return o.length ? o : -1;
			},
			_get_children	: function (obj) {
				obj = this._get_node(obj);
				if(obj === -1) { return this.get_container().children("ul:eq(0)").children("li"); }
				if(!obj.length) { return false; }
				return obj.children("ul:eq(0)").children("li");
			},
			get_path		: function (obj, id_mode) {
				var p = [],
					_this = this;
				obj = this._get_node(obj);
				if(obj === -1 || !obj || !obj.length) { return false; }
				obj.parentsUntil(".jstree", "li").each(function () {
					p.push( id_mode ? this.id : _this.get_text(this) );
				});
				p.reverse();
				p.push( id_mode ? obj.attr("id") : this.get_text(obj) );
				return p;
			},

			// string functions
			_get_string : function (key) {
				return this._get_settings().core.strings[key] || key;
			},

			is_open		: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-open"); },
			is_closed	: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-closed"); },
			is_leaf		: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-leaf"); },
			correct_state	: function (obj) {
				obj = this._get_node(obj);
				if(!obj || obj === -1) { return false; }
				obj.removeClass("jstree-closed jstree-open").addClass("jstree-leaf").children("ul").remove();
				this.__callback({ "obj" : obj });
			},
			// open/close
			open_node	: function (obj, callback, skip_animation) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				if(!obj.hasClass("jstree-closed")) { if(callback) { callback.call(); } return false; }
				var s = skip_animation || is_ie6 ? 0 : this._get_settings().core.animation,
					t = this;
				if(!this._is_loaded(obj)) {
					obj.children("a").addClass("jstree-loading");
					this.load_node(obj, function () { t.open_node(obj, callback, skip_animation); }, callback);
				}
				else {
					if(this._get_settings().core.open_parents) {
						obj.parentsUntil(".jstree",".jstree-closed").each(function () {
							t.open_node(this, false, true);
						});
					}
					if(s) { obj.children("ul").css("display","none"); }
					obj.removeClass("jstree-closed").addClass("jstree-open").children("a").removeClass("jstree-loading");
					if(s) { obj.children("ul").stop(true, true).slideDown(s, function () { this.style.display = ""; t.after_open(obj); }); }
					else { t.after_open(obj); }
					this.__callback({ "obj" : obj });
					if(callback) { callback.call(); }
				}
			},
			after_open	: function (obj) { this.__callback({ "obj" : obj }); },
			close_node	: function (obj, skip_animation) {
				obj = this._get_node(obj);
				var s = skip_animation || is_ie6 ? 0 : this._get_settings().core.animation,
					t = this;
				if(!obj.length || !obj.hasClass("jstree-open")) { return false; }
				if(s) { obj.children("ul").attr("style","display:block !important"); }
				obj.removeClass("jstree-open").addClass("jstree-closed");
				if(s) { obj.children("ul").stop(true, true).slideUp(s, function () { this.style.display = ""; t.after_close(obj); }); }
				else { t.after_close(obj); }
				this.__callback({ "obj" : obj });
			},
			after_close	: function (obj) { this.__callback({ "obj" : obj }); },
			toggle_node	: function (obj) {
				obj = this._get_node(obj);
				if(obj.hasClass("jstree-closed")) { return this.open_node(obj); }
				if(obj.hasClass("jstree-open")) { return this.close_node(obj); }
			},
			open_all	: function (obj, do_animation, original_obj) {
				obj = obj ? this._get_node(obj) : -1;
				if(!obj || obj === -1) { obj = this.get_container_ul(); }
				if(original_obj) { 
					obj = obj.find("li.jstree-closed");
				}
				else {
					original_obj = obj;
					if(obj.is(".jstree-closed")) { obj = obj.find("li.jstree-closed").andSelf(); }
					else { obj = obj.find("li.jstree-closed"); }
				}
				var _this = this;
				obj.each(function () { 
					var __this = this; 
					if(!_this._is_loaded(this)) { _this.open_node(this, function() { _this.open_all(__this, do_animation, original_obj); }, !do_animation); }
					else { _this.open_node(this, false, !do_animation); }
				});
				// so that callback is fired AFTER all nodes are open
				if(original_obj.find('li.jstree-closed').length === 0) { this.__callback({ "obj" : original_obj }); }
			},
			close_all	: function (obj, do_animation) {
				var _this = this;
				obj = obj ? this._get_node(obj) : this.get_container();
				if(!obj || obj === -1) { obj = this.get_container_ul(); }
				obj.find("li.jstree-open").andSelf().each(function () { _this.close_node(this, !do_animation); });
				this.__callback({ "obj" : obj });
			},
			clean_node	: function (obj) {
				obj = obj && obj != -1 ? $(obj) : this.get_container_ul();
				obj = obj.is("li") ? obj.find("li").andSelf() : obj.find("li");
				obj.removeClass("jstree-last")
					.filter("li:last-child").addClass("jstree-last").end()
					.filter(":has(li)")
						.not(".jstree-open").removeClass("jstree-leaf").addClass("jstree-closed");
				obj.not(".jstree-open, .jstree-closed").addClass("jstree-leaf").children("ul").remove();
				this.__callback({ "obj" : obj });
			},
			// rollback
			get_rollback : function () { 
				this.__callback();
				return { i : this.get_index(), h : this.get_container().children("ul").clone(true), d : this.data }; 
			},
			set_rollback : function (html, data) {
				this.get_container().empty().append(html);
				this.data = data;
				this.__callback();
			},
			// Dummy functions to be overwritten by any datastore plugin included
			load_node	: function (obj, s_call, e_call) { this.__callback({ "obj" : obj }); },
			_is_loaded	: function (obj) { return true; },

			// Basic operations: create
			create_node	: function (obj, position, js, callback, is_loaded) {
				obj = this._get_node(obj);
				position = typeof position === "undefined" ? "last" : position;
				var d = $("<li />"),
					s = this._get_settings().core,
					tmp;

				if(obj !== -1 && !obj.length) { return false; }
				if(!is_loaded && !this._is_loaded(obj)) { this.load_node(obj, function () { this.create_node(obj, position, js, callback, true); }); return false; }

				this.__rollback();

				if(typeof js === "string") { js = { "data" : js }; }
				if(!js) { js = {}; }
				if(js.attr) { d.attr(js.attr); }
				if(js.metadata) { d.data(js.metadata); }
				if(js.state) { d.addClass("jstree-" + js.state); }
				if(!js.data) { js.data = this._get_string("new_node"); }
				if(!$.isArray(js.data)) { tmp = js.data; js.data = []; js.data.push(tmp); }
				$.each(js.data, function (i, m) {
					tmp = $("<a />");
					if($.isFunction(m)) { m = m.call(this, js); }
					if(typeof m == "string") { tmp.attr('href','#')[ s.html_titles ? "html" : "text" ](m); }
					else {
						if(!m.attr) { m.attr = {}; }
						if(!m.attr.href) { m.attr.href = '#'; }
						tmp.attr(m.attr)[ s.html_titles ? "html" : "text" ](m.title);
						if(m.language) { tmp.addClass(m.language); }
					}
					tmp.prepend("<ins class='jstree-icon'>&#160;</ins>");
					if(!m.icon && js.icon) { m.icon = js.icon; }
					if(m.icon) { 
						if(m.icon.indexOf("/") === -1) { tmp.children("ins").addClass(m.icon); }
						else { tmp.children("ins").css("background","url('" + m.icon + "') center center no-repeat"); }
					}
					d.append(tmp);
				});
				d.prepend("<ins class='jstree-icon'>&#160;</ins>");
				if(obj === -1) {
					obj = this.get_container();
					if(position === "before") { position = "first"; }
					if(position === "after") { position = "last"; }
				}
				switch(position) {
					case "before": obj.before(d); tmp = this._get_parent(obj); break;
					case "after" : obj.after(d);  tmp = this._get_parent(obj); break;
					case "inside":
					case "first" :
						if(!obj.children("ul").length) { obj.append("<ul />"); }
						obj.children("ul").prepend(d);
						tmp = obj;
						break;
					case "last":
						if(!obj.children("ul").length) { obj.append("<ul />"); }
						obj.children("ul").append(d);
						tmp = obj;
						break;
					default:
						if(!obj.children("ul").length) { obj.append("<ul />"); }
						if(!position) { position = 0; }
						tmp = obj.children("ul").children("li").eq(position);
						if(tmp.length) { tmp.before(d); }
						else { obj.children("ul").append(d); }
						tmp = obj;
						break;
				}
				if(tmp === -1 || tmp.get(0) === this.get_container().get(0)) { tmp = -1; }
				this.clean_node(tmp);
				this.__callback({ "obj" : d, "parent" : tmp });
				if(callback) { callback.call(this, d); }
				return d;
			},
			// Basic operations: rename (deal with text)
			get_text	: function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				var s = this._get_settings().core.html_titles;
				obj = obj.children("a:eq(0)");
				if(s) {
					obj = obj.clone();
					obj.children("INS").remove();
					return obj.html();
				}
				else {
					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
					return obj ? obj.nodeValue : '';
				}
			},
			set_text	: function (obj, val) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				obj = obj.children("a:eq(0)");
				if(this._get_settings().core.html_titles) {
					var tmp = obj.children("INS").clone();
					obj.html(val).prepend(tmp);
					this.__callback({ "obj" : obj, "name" : val });
					return true;
				}
				else {
					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
					this.__callback({ "obj" : obj, "name" : val });
					return (obj.nodeValue = val);
				}
			},
			rename_node : function (obj, val) {
				obj = this._get_node(obj);
				this.__rollback();
				if(obj && obj.length && this.set_text.apply(this, Array.prototype.slice.call(arguments))) { this.__callback({ "obj" : obj, "name" : val }); }
			},
			// Basic operations: deleting nodes
			delete_node : function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				this.__rollback();
				var p = this._get_parent(obj), prev = $([]), t = this;
				obj.each(function () {
					prev = prev.add(t._get_prev(this));
				});
				obj = obj.detach();
				if(p !== -1 && p.find("> ul > li").length === 0) {
					p.removeClass("jstree-open jstree-closed").addClass("jstree-leaf");
				}
				this.clean_node(p);
				this.__callback({ "obj" : obj, "prev" : prev, "parent" : p });
				return obj;
			},
			prepare_move : function (o, r, pos, cb, is_cb) {
				var p = {};

				p.ot = $.jstree._reference(o) || this;
				p.o = p.ot._get_node(o);
				p.r = r === - 1 ? -1 : this._get_node(r);
				p.p = (typeof pos === "undefined" || pos === false) ? "last" : pos; // TODO: move to a setting
				if(!is_cb && prepared_move.o && prepared_move.o[0] === p.o[0] && prepared_move.r[0] === p.r[0] && prepared_move.p === p.p) {
					this.__callback(prepared_move);
					if(cb) { cb.call(this, prepared_move); }
					return;
				}
				p.ot = $.jstree._reference(p.o) || this;
				p.rt = $.jstree._reference(p.r) || this; // r === -1 ? p.ot : $.jstree._reference(p.r) || this
				if(p.r === -1 || !p.r) {
					p.cr = -1;
					switch(p.p) {
						case "first":
						case "before":
						case "inside":
							p.cp = 0; 
							break;
						case "after":
						case "last":
							p.cp = p.rt.get_container().find(" > ul > li").length; 
							break;
						default:
							p.cp = p.p;
							break;
					}
				}
				else {
					if(!/^(before|after)$/.test(p.p) && !this._is_loaded(p.r)) {
						return this.load_node(p.r, function () { this.prepare_move(o, r, pos, cb, true); });
					}
					switch(p.p) {
						case "before":
							p.cp = p.r.index();
							p.cr = p.rt._get_parent(p.r);
							break;
						case "after":
							p.cp = p.r.index() + 1;
							p.cr = p.rt._get_parent(p.r);
							break;
						case "inside":
						case "first":
							p.cp = 0;
							p.cr = p.r;
							break;
						case "last":
							p.cp = p.r.find(" > ul > li").length; 
							p.cr = p.r;
							break;
						default: 
							p.cp = p.p;
							p.cr = p.r;
							break;
					}
				}
				p.np = p.cr == -1 ? p.rt.get_container() : p.cr;
				p.op = p.ot._get_parent(p.o);
				p.cop = p.o.index();
				if(p.op === -1) { p.op = p.ot ? p.ot.get_container() : this.get_container(); }
				if(!/^(before|after)$/.test(p.p) && p.op && p.np && p.op[0] === p.np[0] && p.o.index() < p.cp) { p.cp++; }
				//if(p.p === "before" && p.op && p.np && p.op[0] === p.np[0] && p.o.index() < p.cp) { p.cp--; }
				p.or = p.np.find(" > ul > li:nth-child(" + (p.cp + 1) + ")");
				prepared_move = p;
				this.__callback(prepared_move);
				if(cb) { cb.call(this, prepared_move); }
			},
			check_move : function () {
				var obj = prepared_move, ret = true, r = obj.r === -1 ? this.get_container() : obj.r;
				if(!obj || !obj.o || obj.or[0] === obj.o[0]) { return false; }
				if(!obj.cy) {
					if(obj.op && obj.np && obj.op[0] === obj.np[0] && obj.cp - 1 === obj.o.index()) { return false; }
					obj.o.each(function () { 
						if(r.parentsUntil(".jstree", "li").andSelf().index(this) !== -1) { ret = false; return false; }
					});
				}
				return ret;
			},
			move_node : function (obj, ref, position, is_copy, is_prepared, skip_check) {
				if(!is_prepared) { 
					return this.prepare_move(obj, ref, position, function (p) {
						this.move_node(p, false, false, is_copy, true, skip_check);
					});
				}
				if(is_copy) { 
					prepared_move.cy = true;
				}
				if(!skip_check && !this.check_move()) { return false; }

				this.__rollback();
				var o = false;
				if(is_copy) {
					o = obj.o.clone(true);
					o.find("*[id]").andSelf().each(function () {
						if(this.id) { this.id = "copy_" + this.id; }
					});
				}
				else { o = obj.o; }

				if(obj.or.length) { obj.or.before(o); }
				else { 
					if(!obj.np.children("ul").length) { $("<ul />").appendTo(obj.np); }
					obj.np.children("ul:eq(0)").append(o); 
				}

				try { 
					obj.ot.clean_node(obj.op);
					obj.rt.clean_node(obj.np);
					if(!obj.op.find("> ul > li").length) {
						obj.op.removeClass("jstree-open jstree-closed").addClass("jstree-leaf").children("ul").remove();
					}
				} catch (e) { }

				if(is_copy) { 
					prepared_move.cy = true;
					prepared_move.oc = o; 
				}
				this.__callback(prepared_move);
				return prepared_move;
			},
			_get_move : function () { return prepared_move; }
		}
	});
})(jQuery);
//*/

/* 
 * jsTree ui plugin
 * This plugins handles selecting/deselecting/hovering/dehovering nodes
 */
(function ($) {
	var scrollbar_width, e1, e2;
	$(function() {
		if (/msie/.test(navigator.userAgent.toLowerCase())) {
			e1 = $('<textarea cols="10" rows="2"></textarea>').css({ position: 'absolute', top: -1000, left: 0 }).appendTo('body');
			e2 = $('<textarea cols="10" rows="2" style="overflow: hidden;"></textarea>').css({ position: 'absolute', top: -1000, left: 0 }).appendTo('body');
			scrollbar_width = e1.width() - e2.width();
			e1.add(e2).remove();
		} 
		else {
			e1 = $('<div />').css({ width: 100, height: 100, overflow: 'auto', position: 'absolute', top: -1000, left: 0 })
					.prependTo('body').append('<div />').find('div').css({ width: '100%', height: 200 });
			scrollbar_width = 100 - e1.width();
			e1.parent().remove();
		}
	});
	$.jstree.plugin("ui", {
		__init : function () { 
			this.data.ui.selected = $(); 
			this.data.ui.last_selected = false; 
			this.data.ui.hovered = null;
			this.data.ui.to_select = this.get_settings().ui.initially_select;

			this.get_container()
				.delegate("a", "click.jstree", $.proxy(function (event) {
						event.preventDefault();
						event.currentTarget.blur();
						if(!$(event.currentTarget).hasClass("jstree-loading")) {
							this.select_node(event.currentTarget, true, event);
						}
					}, this))
				.delegate("a", "mouseenter.jstree", $.proxy(function (event) {
						if(!$(event.currentTarget).hasClass("jstree-loading")) {
							this.hover_node(event.target);
						}
					}, this))
				.delegate("a", "mouseleave.jstree", $.proxy(function (event) {
						if(!$(event.currentTarget).hasClass("jstree-loading")) {
							this.dehover_node(event.target);
						}
					}, this))
				.bind("reopen.jstree", $.proxy(function () { 
						this.reselect();
					}, this))
				.bind("get_rollback.jstree", $.proxy(function () { 
						this.dehover_node();
						this.save_selected();
					}, this))
				.bind("set_rollback.jstree", $.proxy(function () { 
						this.reselect();
					}, this))
				.bind("close_node.jstree", $.proxy(function (event, data) { 
						var s = this._get_settings().ui,
							obj = this._get_node(data.rslt.obj),
							clk = (obj && obj.length) ? obj.children("ul").find("a.jstree-clicked") : $(),
							_this = this;
						if(s.selected_parent_close === false || !clk.length) { return; }
						clk.each(function () { 
							_this.deselect_node(this);
							if(s.selected_parent_close === "select_parent") { _this.select_node(obj); }
						});
					}, this))
				.bind("delete_node.jstree", $.proxy(function (event, data) { 
						var s = this._get_settings().ui.select_prev_on_delete,
							obj = this._get_node(data.rslt.obj),
							clk = (obj && obj.length) ? obj.find("a.jstree-clicked") : [],
							_this = this;
						clk.each(function () { _this.deselect_node(this); });
						if(s && clk.length) { 
							data.rslt.prev.each(function () { 
								if(this.parentNode) { _this.select_node(this); return false; /* if return false is removed all prev nodes will be selected */}
							});
						}
					}, this))
				.bind("move_node.jstree", $.proxy(function (event, data) { 
						if(data.rslt.cy) { 
							data.rslt.oc.find("a.jstree-clicked").removeClass("jstree-clicked");
						}
					}, this));
		},
		defaults : {
			select_limit : -1, // 0, 1, 2 ... or -1 for unlimited
			select_multiple_modifier : "ctrl", // on, or ctrl, shift, alt
			select_range_modifier : "shift",
			selected_parent_close : "select_parent", // false, "deselect", "select_parent"
			selected_parent_open : true,
			select_prev_on_delete : true,
			disable_selecting_children : false,
			initially_select : []
		},
		_fn : { 
			_get_node : function (obj, allow_multiple) {
				if(typeof obj === "undefined" || obj === null) { return allow_multiple ? this.data.ui.selected : this.data.ui.last_selected; }
				var $obj = $(obj, this.get_container()); 
				if($obj.is(".jstree") || obj == -1) { return -1; } 
				$obj = $obj.closest("li", this.get_container()); 
				return $obj.length ? $obj : false; 
			},
			_ui_notify : function (n, data) {
				if(data.selected) {
					this.select_node(n, false);
				}
			},
			save_selected : function () {
				var _this = this;
				this.data.ui.to_select = [];
				this.data.ui.selected.each(function () { if(this.id) { _this.data.ui.to_select.push("#" + this.id.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:")); } });
				this.__callback(this.data.ui.to_select);
			},
			reselect : function () {
				var _this = this,
					s = this.data.ui.to_select;
				s = $.map($.makeArray(s), function (n) { return "#" + n.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:"); });
				// this.deselect_all(); WHY deselect, breaks plugin state notifier?
				$.each(s, function (i, val) { if(val && val !== "#") { _this.select_node(val); } });
				this.data.ui.selected = this.data.ui.selected.filter(function () { return this.parentNode; });
				this.__callback();
			},
			refresh : function (obj) {
				this.save_selected();
				return this.__call_old();
			},
			hover_node : function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				//if(this.data.ui.hovered && obj.get(0) === this.data.ui.hovered.get(0)) { return; }
				if(!obj.hasClass("jstree-hovered")) { this.dehover_node(); }
				this.data.ui.hovered = obj.children("a").addClass("jstree-hovered").parent();
				this._fix_scroll(obj);
				this.__callback({ "obj" : obj });
			},
			dehover_node : function () {
				var obj = this.data.ui.hovered, p;
				if(!obj || !obj.length) { return false; }
				p = obj.children("a").removeClass("jstree-hovered").parent();
				if(this.data.ui.hovered[0] === p[0]) { this.data.ui.hovered = null; }
				this.__callback({ "obj" : obj });
			},
			select_node : function (obj, check, e) {
				obj = this._get_node(obj);
				if(obj == -1 || !obj || !obj.length) { return false; }
				var s = this._get_settings().ui,
					is_multiple = (s.select_multiple_modifier == "on" || (s.select_multiple_modifier !== false && e && e[s.select_multiple_modifier + "Key"])),
					is_range = (s.select_range_modifier !== false && e && e[s.select_range_modifier + "Key"] && this.data.ui.last_selected && this.data.ui.last_selected[0] !== obj[0] && this.data.ui.last_selected.parent()[0] === obj.parent()[0]),
					is_selected = this.is_selected(obj),
					proceed = true,
					t = this;
				if(check) {
					if(s.disable_selecting_children && is_multiple && 
						(
							(obj.parentsUntil(".jstree","li").children("a.jstree-clicked").length) ||
							(obj.children("ul").find("a.jstree-clicked:eq(0)").length)
						)
					) {
						return false;
					}
					proceed = false;
					switch(!0) {
						case (is_range):
							this.data.ui.last_selected.addClass("jstree-last-selected");
							obj = obj[ obj.index() < this.data.ui.last_selected.index() ? "nextUntil" : "prevUntil" ](".jstree-last-selected").andSelf();
							if(s.select_limit == -1 || obj.length < s.select_limit) {
								this.data.ui.last_selected.removeClass("jstree-last-selected");
								this.data.ui.selected.each(function () {
									if(this !== t.data.ui.last_selected[0]) { t.deselect_node(this); }
								});
								is_selected = false;
								proceed = true;
							}
							else {
								proceed = false;
							}
							break;
						case (is_selected && !is_multiple): 
							this.deselect_all();
							is_selected = false;
							proceed = true;
							break;
						case (!is_selected && !is_multiple): 
							if(s.select_limit == -1 || s.select_limit > 0) {
								this.deselect_all();
								proceed = true;
							}
							break;
						case (is_selected && is_multiple): 
							this.deselect_node(obj);
							break;
						case (!is_selected && is_multiple): 
							if(s.select_limit == -1 || this.data.ui.selected.length + 1 <= s.select_limit) { 
								proceed = true;
							}
							break;
					}
				}
				if(proceed && !is_selected) {
					if(!is_range) { this.data.ui.last_selected = obj; }
					obj.children("a").addClass("jstree-clicked");
					if(s.selected_parent_open) {
						obj.parents(".jstree-closed").each(function () { t.open_node(this, false, true); });
					}
					this.data.ui.selected = this.data.ui.selected.add(obj);
					this._fix_scroll(obj.eq(0));
					this.__callback({ "obj" : obj, "e" : e });
				}
			},
			_fix_scroll : function (obj) {
				var c = this.get_container()[0], t;
				if(c.scrollHeight > c.offsetHeight) {
					obj = this._get_node(obj);
					if(!obj || obj === -1 || !obj.length || !obj.is(":visible")) { return; }
					t = obj.offset().top - this.get_container().offset().top;
					if(t < 0) { 
						c.scrollTop = c.scrollTop + t - 1; 
					}
					if(t + this.data.core.li_height + (c.scrollWidth > c.offsetWidth ? scrollbar_width : 0) > c.offsetHeight) { 
						c.scrollTop = c.scrollTop + (t - c.offsetHeight + this.data.core.li_height + 1 + (c.scrollWidth > c.offsetWidth ? scrollbar_width : 0)); 
					}
				}
			},
			deselect_node : function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				if(this.is_selected(obj)) {
					obj.children("a").removeClass("jstree-clicked");
					this.data.ui.selected = this.data.ui.selected.not(obj);
					if(this.data.ui.last_selected.get(0) === obj.get(0)) { this.data.ui.last_selected = this.data.ui.selected.eq(0); }
					this.__callback({ "obj" : obj });
				}
			},
			toggle_select : function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return false; }
				if(this.is_selected(obj)) { this.deselect_node(obj); }
				else { this.select_node(obj); }
			},
			is_selected : function (obj) { return this.data.ui.selected.index(this._get_node(obj)) >= 0; },
			get_selected : function (context) { 
				return context ? $(context).find("a.jstree-clicked").parent() : this.data.ui.selected; 
			},
			deselect_all : function (context) {
				var ret = context ? $(context).find("a.jstree-clicked").parent() : this.get_container().find("a.jstree-clicked").parent();
				ret.children("a.jstree-clicked").removeClass("jstree-clicked");
				this.data.ui.selected = $([]);
				this.data.ui.last_selected = false;
				this.__callback({ "obj" : ret });
			}
		}
	});
	// include the selection plugin by default
	$.jstree.defaults.plugins.push("ui");
})(jQuery);
//*/

/* 
 * jsTree CRRM plugin
 * Handles creating/renaming/removing/moving nodes by user interaction.
 */
(function ($) {
	$.jstree.plugin("crrm", { 
		__init : function () {
			this.get_container()
				.bind("move_node.jstree", $.proxy(function (e, data) {
					if(this._get_settings().crrm.move.open_onmove) {
						var t = this;
						data.rslt.np.parentsUntil(".jstree").andSelf().filter(".jstree-closed").each(function () {
							t.open_node(this, false, true);
						});
					}
				}, this));
		},
		defaults : {
			input_width_limit : 200,
			move : {
				always_copy			: false, // false, true or "multitree"
				open_onmove			: true,
				default_position	: "last",
				check_move			: function (m) { return true; }
			}
		},
		_fn : {
			_show_input : function (obj, callback) {
				obj = this._get_node(obj);
				var rtl = this._get_settings().core.rtl,
					w = this._get_settings().crrm.input_width_limit,
					w1 = obj.children("ins").width(),
					w2 = obj.find("> a:visible > ins").width() * obj.find("> a:visible > ins").length,
					t = this.get_text(obj),
					h1 = $("<div />", { css : { "position" : "absolute", "top" : "-200px", "left" : (rtl ? "0px" : "-1000px"), "visibility" : "hidden" } }).appendTo("body"),
					h2 = obj.css("position","relative").append(
					$("<input />", { 
						"value" : t,
						"class" : "jstree-rename-input",
						// "size" : t.length,
						"css" : {
							"padding" : "0",
							"border" : "1px solid silver",
							"position" : "absolute",
							"left"  : (rtl ? "auto" : (w1 + w2 + 4) + "px"),
							"right" : (rtl ? (w1 + w2 + 4) + "px" : "auto"),
							"top" : "0px",
							"height" : (this.data.core.li_height - 2) + "px",
							"lineHeight" : (this.data.core.li_height - 2) + "px",
							"width" : "150px" // will be set a bit further down
						},
						"blur" : $.proxy(function () {
							var i = obj.children(".jstree-rename-input"),
								v = i.val();
							if(v === "") { v = t; }
							h1.remove();
							i.remove(); // rollback purposes
							this.set_text(obj,t); // rollback purposes
							this.rename_node(obj, v);
							callback.call(this, obj, v, t);
							obj.css("position","");
						}, this),
						"keyup" : function (event) {
							var key = event.keyCode || event.which;
							if(key == 27) { this.value = t; this.blur(); return; }
							else if(key == 13) { this.blur(); return; }
							else {
								h2.width(Math.min(h1.text("pW" + this.value).width(),w));
							}
						},
						"keypress" : function(event) {
							var key = event.keyCode || event.which;
							if(key == 13) { return false; }
						}
					})
				).children(".jstree-rename-input"); 
				this.set_text(obj, "");
				h1.css({
						fontFamily		: h2.css('fontFamily')		|| '',
						fontSize		: h2.css('fontSize')		|| '',
						fontWeight		: h2.css('fontWeight')		|| '',
						fontStyle		: h2.css('fontStyle')		|| '',
						fontStretch		: h2.css('fontStretch')		|| '',
						fontVariant		: h2.css('fontVariant')		|| '',
						letterSpacing	: h2.css('letterSpacing')	|| '',
						wordSpacing		: h2.css('wordSpacing')		|| ''
				});
				h2.width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0].select();
			},
			rename : function (obj) {
				obj = this._get_node(obj);
				this.__rollback();
				var f = this.__callback;
				this._show_input(obj, function (obj, new_name, old_name) { 
					f.call(this, { "obj" : obj, "new_name" : new_name, "old_name" : old_name });
				});
			},
			create : function (obj, position, js, callback, skip_rename) {
				var t, _this = this;
				obj = this._get_node(obj);
				if(!obj) { obj = -1; }
				this.__rollback();
				t = this.create_node(obj, position, js, function (t) {
					var p = this._get_parent(t),
						pos = $(t).index();
					if(callback) { callback.call(this, t); }
					if(p.length && p.hasClass("jstree-closed")) { this.open_node(p, false, true); }
					if(!skip_rename) { 
						this._show_input(t, function (obj, new_name, old_name) { 
							_this.__callback({ "obj" : obj, "name" : new_name, "parent" : p, "position" : pos });
						});
					}
					else { _this.__callback({ "obj" : t, "name" : this.get_text(t), "parent" : p, "position" : pos }); }
				});
				return t;
			},
			remove : function (obj) {
				obj = this._get_node(obj, true);
				var p = this._get_parent(obj), prev = this._get_prev(obj);
				this.__rollback();
				obj = this.delete_node(obj);
				if(obj !== false) { this.__callback({ "obj" : obj, "prev" : prev, "parent" : p }); }
			},
			check_move : function () {
				if(!this.__call_old()) { return false; }
				var s = this._get_settings().crrm.move;
				if(!s.check_move.call(this, this._get_move())) { return false; }
				return true;
			},
			move_node : function (obj, ref, position, is_copy, is_prepared, skip_check) {
				var s = this._get_settings().crrm.move;
				if(!is_prepared) { 
					if(typeof position === "undefined") { position = s.default_position; }
					if(position === "inside" && !s.default_position.match(/^(before|after)$/)) { position = s.default_position; }
					return this.__call_old(true, obj, ref, position, is_copy, false, skip_check);
				}
				// if the move is already prepared
				if(s.always_copy === true || (s.always_copy === "multitree" && obj.rt.get_index() !== obj.ot.get_index() )) {
					is_copy = true;
				}
				this.__call_old(true, obj, ref, position, is_copy, true, skip_check);
			},

			cut : function (obj) {
				obj = this._get_node(obj, true);
				if(!obj || !obj.length) { return false; }
				this.data.crrm.cp_nodes = false;
				this.data.crrm.ct_nodes = obj;
				this.__callback({ "obj" : obj });
			},
			copy : function (obj) {
				obj = this._get_node(obj, true);
				if(!obj || !obj.length) { return false; }
				this.data.crrm.ct_nodes = false;
				this.data.crrm.cp_nodes = obj;
				this.__callback({ "obj" : obj });
			},
			paste : function (obj) { 
				obj = this._get_node(obj);
				if(!obj || !obj.length) { return false; }
				var nodes = this.data.crrm.ct_nodes ? this.data.crrm.ct_nodes : this.data.crrm.cp_nodes;
				if(!this.data.crrm.ct_nodes && !this.data.crrm.cp_nodes) { return false; }
				if(this.data.crrm.ct_nodes) { this.move_node(this.data.crrm.ct_nodes, obj); this.data.crrm.ct_nodes = false; }
				if(this.data.crrm.cp_nodes) { this.move_node(this.data.crrm.cp_nodes, obj, false, true); }
				this.__callback({ "obj" : obj, "nodes" : nodes });
			}
		}
	});
	// include the crr plugin by default
	// $.jstree.defaults.plugins.push("crrm");
})(jQuery);
//*/

/* 
 * jsTree themes plugin
 * Handles loading and setting themes, as well as detecting path to themes, etc.
 */
(function ($) {
	var themes_loaded = [];
	// this variable stores the path to the themes folder - if left as false - it will be autodetected
	$.jstree._themes = false;
	$.jstree.plugin("themes", {
		__init : function () { 
			this.get_container()
				.bind("init.jstree", $.proxy(function () {
						var s = this._get_settings().themes;
						this.data.themes.dots = s.dots; 
						this.data.themes.icons = s.icons; 
						this.set_theme(s.theme, s.url);
					}, this))
				.bind("loaded.jstree", $.proxy(function () {
						// bound here too, as simple HTML tree's won't honor dots & icons otherwise
						if(!this.data.themes.dots) { this.hide_dots(); }
						else { this.show_dots(); }
						if(!this.data.themes.icons) { this.hide_icons(); }
						else { this.show_icons(); }
					}, this));
		},
		defaults : { 
			theme : "default", 
			url : false,
			dots : true,
			icons : true
		},
		_fn : {
			set_theme : function (theme_name, theme_url) {
				if(!theme_name) { return false; }
				if(!theme_url) { theme_url = $.jstree._themes + theme_name + '/style.css'; }
				if($.inArray(theme_url, themes_loaded) == -1) {
					$.vakata.css.add_sheet({ "url" : theme_url });
					themes_loaded.push(theme_url);
				}
				if(this.data.themes.theme != theme_name) {
					this.get_container().removeClass('jstree-' + this.data.themes.theme);
					this.data.themes.theme = theme_name;
				}
				this.get_container().addClass('jstree-' + theme_name);
				if(!this.data.themes.dots) { this.hide_dots(); }
				else { this.show_dots(); }
				if(!this.data.themes.icons) { this.hide_icons(); }
				else { this.show_icons(); }
				this.__callback();
			},
			get_theme	: function () { return this.data.themes.theme; },

			show_dots	: function () { this.data.themes.dots = true; this.get_container().children("ul").removeClass("jstree-no-dots"); },
			hide_dots	: function () { this.data.themes.dots = false; this.get_container().children("ul").addClass("jstree-no-dots"); },
			toggle_dots	: function () { if(this.data.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },

			show_icons	: function () { this.data.themes.icons = true; this.get_container().children("ul").removeClass("jstree-no-icons"); },
			hide_icons	: function () { this.data.themes.icons = false; this.get_container().children("ul").addClass("jstree-no-icons"); },
			toggle_icons: function () { if(this.data.themes.icons) { this.hide_icons(); } else { this.show_icons(); } }
		}
	});
	// autodetect themes path
	$(function () {
		if($.jstree._themes === false) {
			$("script").each(function () { 
				if(this.src.toString().match(/jquery\.jstree[^\/]*?\.js(\?.*)?$/)) { 
					$.jstree._themes = this.src.toString().replace(/jquery\.jstree[^\/]*?\.js(\?.*)?$/, "") + 'themes/'; 
					return false; 
				}
			});
		}
		if($.jstree._themes === false) { $.jstree._themes = "themes/"; }
	});
	// include the themes plugin by default
	$.jstree.defaults.plugins.push("themes");
})(jQuery);
//*/

/*
 * jsTree hotkeys plugin
 * Enables keyboard navigation for all tree instances
 * Depends on the jstree ui & jquery hotkeys plugins
 */
(function ($) {
	var bound = [];
	function exec(i, event) {
		var f = $.jstree._focused(), tmp;
		if(f && f.data && f.data.hotkeys && f.data.hotkeys.enabled) { 
			tmp = f._get_settings().hotkeys[i];
			if(tmp) { return tmp.call(f, event); }
		}
	}
	$.jstree.plugin("hotkeys", {
		__init : function () {
			if(typeof $.hotkeys === "undefined") { throw "jsTree hotkeys: jQuery hotkeys plugin not included."; }
			if(!this.data.ui) { throw "jsTree hotkeys: jsTree UI plugin not included."; }
			$.each(this._get_settings().hotkeys, function (i, v) {
				if(v !== false && $.inArray(i, bound) == -1) {
					$(document).bind("keydown", i, function (event) { return exec(i, event); });
					bound.push(i);
				}
			});
			this.get_container()
				.bind("lock.jstree", $.proxy(function () {
						if(this.data.hotkeys.enabled) { this.data.hotkeys.enabled = false; this.data.hotkeys.revert = true; }
					}, this))
				.bind("unlock.jstree", $.proxy(function () {
						if(this.data.hotkeys.revert) { this.data.hotkeys.enabled = true; }
					}, this));
			this.enable_hotkeys();
		},
		defaults : {
			"up" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_prev(o));
				return false; 
			},
			"ctrl+up" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_prev(o));
				return false; 
			},
			"shift+up" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_prev(o));
				return false; 
			},
			"down" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_next(o));
				return false;
			},
			"ctrl+down" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_next(o));
				return false;
			},
			"shift+down" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;
				this.hover_node(this._get_next(o));
				return false;
			},
			"left" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o) {
					if(o.hasClass("jstree-open")) { this.close_node(o); }
					else { this.hover_node(this._get_prev(o)); }
				}
				return false;
			},
			"ctrl+left" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o) {
					if(o.hasClass("jstree-open")) { this.close_node(o); }
					else { this.hover_node(this._get_prev(o)); }
				}
				return false;
			},
			"shift+left" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o) {
					if(o.hasClass("jstree-open")) { this.close_node(o); }
					else { this.hover_node(this._get_prev(o)); }
				}
				return false;
			},
			"right" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o && o.length) {
					if(o.hasClass("jstree-closed")) { this.open_node(o); }
					else { this.hover_node(this._get_next(o)); }
				}
				return false;
			},
			"ctrl+right" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o && o.length) {
					if(o.hasClass("jstree-closed")) { this.open_node(o); }
					else { this.hover_node(this._get_next(o)); }
				}
				return false;
			},
			"shift+right" : function () { 
				var o = this.data.ui.hovered || this.data.ui.last_selected;
				if(o && o.length) {
					if(o.hasClass("jstree-closed")) { this.open_node(o); }
					else { this.hover_node(this._get_next(o)); }
				}
				return false;
			},
			"space" : function () { 
				if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").click(); } 
				return false; 
			},
			"ctrl+space" : function (event) { 
				event.type = "click";
				if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").trigger(event); } 
				return false; 
			},
			"shift+space" : function (event) { 
				event.type = "click";
				if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").trigger(event); } 
				return false; 
			},
			"f2" : function () { this.rename(this.data.ui.hovered || this.data.ui.last_selected); },
			"del" : function () { this.remove(this.data.ui.hovered || this._get_node(null)); }
		},
		_fn : {
			enable_hotkeys : function () {
				this.data.hotkeys.enabled = true;
			},
			disable_hotkeys : function () {
				this.data.hotkeys.enabled = false;
			}
		}
	});
})(jQuery);
//*/

/* 
 * jsTree JSON plugin
 * The JSON data store. Datastores are build by overriding the `load_node` and `_is_loaded` functions.
 */
(function ($) {
	$.jstree.plugin("json_data", {
		__init : function() {
			var s = this._get_settings().json_data;
			if(s.progressive_unload) {
				this.get_container().bind("after_close.jstree", function (e, data) {
					data.rslt.obj.children("ul").remove();
				});
			}
		},
		defaults : { 
			// `data` can be a function:
			//  * accepts two arguments - node being loaded and a callback to pass the result to
			//  * will be executed in the current tree's scope & ajax won't be supported
			data : false, 
			ajax : false,
			correct_state : true,
			progressive_render : false,
			progressive_unload : false
		},
		_fn : {
			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_json(obj, function () { _this.__callback({ "obj" : _this._get_node(obj) }); s_call.call(this); }, e_call); },
			_is_loaded : function (obj) { 
				var s = this._get_settings().json_data;
				obj = this._get_node(obj); 
				return obj == -1 || !obj || (!s.ajax && !s.progressive_render && !$.isFunction(s.data)) || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").length > 0;
			},
			refresh : function (obj) {
				obj = this._get_node(obj);
				var s = this._get_settings().json_data;
				if(obj && obj !== -1 && s.progressive_unload && ($.isFunction(s.data) || !!s.ajax)) {
					obj.removeData("jstree_children");
				}
				return this.__call_old();
			},
			load_node_json : function (obj, s_call, e_call) {
				var s = this.get_settings().json_data, d,
					error_func = function () {},
					success_func = function () {};
				obj = this._get_node(obj);

				if(obj && obj !== -1 && (s.progressive_render || s.progressive_unload) && !obj.is(".jstree-open, .jstree-leaf") && obj.children("ul").children("li").length === 0 && obj.data("jstree_children")) {
					d = this._parse_json(obj.data("jstree_children"), obj);
					if(d) {
						obj.append(d);
						if(!s.progressive_unload) { obj.removeData("jstree_children"); }
					}
					this.clean_node(obj);
					if(s_call) { s_call.call(this); }
					return;
				}

				if(obj && obj !== -1) {
					if(obj.data("jstree_is_loading")) { return; }
					else { obj.data("jstree_is_loading",true); }
				}
				switch(!0) {
					case (!s.data && !s.ajax): throw "Neither data nor ajax settings supplied.";
					// function option added here for easier model integration (also supporting async - see callback)
					case ($.isFunction(s.data)):
						s.data.call(this, obj, $.proxy(function (d) {
							d = this._parse_json(d, obj);
							if(!d) { 
								if(obj === -1 || !obj) {
									if(s.correct_state) { this.get_container().children("ul").empty(); }
								}
								else {
									obj.children("a.jstree-loading").removeClass("jstree-loading");
									obj.removeData("jstree_is_loading");
									if(s.correct_state) { this.correct_state(obj); }
								}
								if(e_call) { e_call.call(this); }
							}
							else {
								if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
								else { obj.append(d).children("a.jstree-loading").removeClass("jstree-loading"); obj.removeData("jstree_is_loading"); }
								this.clean_node(obj);
								if(s_call) { s_call.call(this); }
							}
						}, this));
						break;
					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
						if(!obj || obj == -1) {
							d = this._parse_json(s.data, obj);
							if(d) {
								this.get_container().children("ul").empty().append(d.children());
								this.clean_node();
							}
							else { 
								if(s.correct_state) { this.get_container().children("ul").empty(); }
							}
						}
						if(s_call) { s_call.call(this); }
						break;
					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
						error_func = function (x, t, e) {
							var ef = this.get_settings().json_data.ajax.error; 
							if(ef) { ef.call(this, x, t, e); }
							if(obj != -1 && obj.length) {
								obj.children("a.jstree-loading").removeClass("jstree-loading");
								obj.removeData("jstree_is_loading");
								if(t === "success" && s.correct_state) { this.correct_state(obj); }
							}
							else {
								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
							}
							if(e_call) { e_call.call(this); }
						};
						success_func = function (d, t, x) {
							var sf = this.get_settings().json_data.ajax.success; 
							if(sf) { d = sf.call(this,d,t,x) || d; }
							if(d === "" || (d && d.toString && d.toString().replace(/^[\s\n]+$/,"") === "") || (!$.isArray(d) && !$.isPlainObject(d))) {
								return error_func.call(this, x, t, "");
							}
							d = this._parse_json(d, obj);
							if(d) {
								if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
								else { obj.append(d).children("a.jstree-loading").removeClass("jstree-loading"); obj.removeData("jstree_is_loading"); }
								this.clean_node(obj);
								if(s_call) { s_call.call(this); }
							}
							else {
								if(obj === -1 || !obj) {
									if(s.correct_state) { 
										this.get_container().children("ul").empty(); 
										if(s_call) { s_call.call(this); }
									}
								}
								else {
									obj.children("a.jstree-loading").removeClass("jstree-loading");
									obj.removeData("jstree_is_loading");
									if(s.correct_state) { 
										this.correct_state(obj);
										if(s_call) { s_call.call(this); } 
									}
								}
							}
						};
						s.ajax.context = this;
						s.ajax.error = error_func;
						s.ajax.success = success_func;
						if(!s.ajax.dataType) { s.ajax.dataType = "json"; }
						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
						$.ajax(s.ajax);
						break;
				}
			},
			_parse_json : function (js, obj, is_callback) {
				var d = false, 
					p = this._get_settings(),
					s = p.json_data,
					t = p.core.html_titles,
					tmp, i, j, ul1, ul2;

				if(!js) { return d; }
				if(s.progressive_unload && obj && obj !== -1) { 
					obj.data("jstree_children", d);
				}
				if($.isArray(js)) {
					d = $();
					if(!js.length) { return false; }
					for(i = 0, j = js.length; i < j; i++) {
						tmp = this._parse_json(js[i], obj, true);
						if(tmp.length) { d = d.add(tmp); }
					}
				}
				else {
					if(typeof js == "string") { js = { data : js }; }
					if(!js.data && js.data !== "") { return d; }
					d = $("<li />");
					if(js.attr) { d.attr(js.attr); }
					if(js.metadata) { d.data(js.metadata); }
					if(js.state) { d.addClass("jstree-" + js.state); }
					if(!$.isArray(js.data)) { tmp = js.data; js.data = []; js.data.push(tmp); }
					$.each(js.data, function (i, m) {
						tmp = $("<a />");
						if($.isFunction(m)) { m = m.call(this, js); }
						if(typeof m == "string") { tmp.attr('href','#')[ t ? "html" : "text" ](m); }
						else {
							if(!m.attr) { m.attr = {}; }
							if(!m.attr.href) { m.attr.href = '#'; }
							tmp.attr(m.attr)[ t ? "html" : "text" ](m.title);
							if(m.language) { tmp.addClass(m.language); }
						}
						tmp.prepend("<ins class='jstree-icon'>&#160;</ins>");
						if(!m.icon && js.icon) { m.icon = js.icon; }
						if(m.icon) { 
							if(m.icon.indexOf("/") === -1) { tmp.children("ins").addClass(m.icon); }
							else { tmp.children("ins").css("background","url('" + m.icon + "') center center no-repeat"); }
						}
						d.append(tmp);
					});
					d.prepend("<ins class='jstree-icon'>&#160;</ins>");
					if(js.children) { 
						if(s.progressive_render && js.state !== "open") {
							d.addClass("jstree-closed").data("jstree_children", js.children);
						}
						else {
							if(s.progressive_unload) { d.data("jstree_children", js.children); }
							if($.isArray(js.children) && js.children.length) {
								tmp = this._parse_json(js.children, obj, true);
								if(tmp.length) {
									ul2 = $("<ul />");
									ul2.append(tmp);
									d.append(ul2);
								}
							}
						}
					}
				}
				if(!is_callback) {
					ul1 = $("<ul />");
					ul1.append(d);
					d = ul1;
				}
				return d;
			},
			get_json : function (obj, li_attr, a_attr, is_callback) {
				var result = [], 
					s = this._get_settings(), 
					_this = this,
					tmp1, tmp2, li, a, t, lang;
				obj = this._get_node(obj);
				if(!obj || obj === -1) { obj = this.get_container().find("> ul > li"); }
				li_attr = $.isArray(li_attr) ? li_attr : [ "id", "class" ];
				if(!is_callback && this.data.types) { li_attr.push(s.types.type_attr); }
				a_attr = $.isArray(a_attr) ? a_attr : [ ];

				obj.each(function () {
					li = $(this);
					tmp1 = { data : [] };
					if(li_attr.length) { tmp1.attr = { }; }
					$.each(li_attr, function (i, v) { 
						tmp2 = li.attr(v); 
						if(tmp2 && tmp2.length && tmp2.replace(/jstree[^ ]*/ig,'').length) {
							tmp1.attr[v] = (" " + tmp2).replace(/ jstree[^ ]*/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,""); 
						}
					});
					if(li.hasClass("jstree-open")) { tmp1.state = "open"; }
					if(li.hasClass("jstree-closed")) { tmp1.state = "closed"; }
					if(li.data()) { tmp1.metadata = li.data(); }
					a = li.children("a");
					a.each(function () {
						t = $(this);
						if(
							a_attr.length || 
							$.inArray("languages", s.plugins) !== -1 || 
							t.children("ins").get(0).style.backgroundImage.length || 
							(t.children("ins").get(0).className && t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').length)
						) { 
							lang = false;
							if($.inArray("languages", s.plugins) !== -1 && $.isArray(s.languages) && s.languages.length) {
								$.each(s.languages, function (l, lv) {
									if(t.hasClass(lv)) {
										lang = lv;
										return false;
									}
								});
							}
							tmp2 = { attr : { }, title : _this.get_text(t, lang) }; 
							$.each(a_attr, function (k, z) {
								tmp2.attr[z] = (" " + (t.attr(z) || "")).replace(/ jstree[^ ]*/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"");
							});
							if($.inArray("languages", s.plugins) !== -1 && $.isArray(s.languages) && s.languages.length) {
								$.each(s.languages, function (k, z) {
									if(t.hasClass(z)) { tmp2.language = z; return true; }
								});
							}
							if(t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"").length) {
								tmp2.icon = t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"");
							}
							if(t.children("ins").get(0).style.backgroundImage.length) {
								tmp2.icon = t.children("ins").get(0).style.backgroundImage.replace("url(","").replace(")","");
							}
						}
						else {
							tmp2 = _this.get_text(t);
						}
						if(a.length > 1) { tmp1.data.push(tmp2); }
						else { tmp1.data = tmp2; }
					});
					li = li.find("> ul > li");
					if(li.length) { tmp1.children = _this.get_json(li, li_attr, a_attr, true); }
					result.push(tmp1);
				});
				return result;
			}
		}
	});
})(jQuery);
//*/

/* 
 * jsTree languages plugin
 * Adds support for multiple language versions in one tree
 * This basically allows for many titles coexisting in one node, but only one of them being visible at any given time
 * This is useful for maintaining the same structure in many languages (hence the name of the plugin)
 */
(function ($) {
	var sh = false;
	$.jstree.plugin("languages", {
		__init : function () { this._load_css();  },
		defaults : [],
		_fn : {
			set_lang : function (i) { 
				var langs = this._get_settings().languages,
					st = false,
					selector = ".jstree-" + this.get_index() + ' a';
				if(!$.isArray(langs) || langs.length === 0) { return false; }
				if($.inArray(i,langs) == -1) {
					if(!!langs[i]) { i = langs[i]; }
					else { return false; }
				}
				if(i == this.data.languages.current_language) { return true; }
				st = $.vakata.css.get_css(selector + "." + this.data.languages.current_language, false, sh);
				if(st !== false) { st.style.display = "none"; }
				st = $.vakata.css.get_css(selector + "." + i, false, sh);
				if(st !== false) { st.style.display = ""; }
				this.data.languages.current_language = i;
				this.__callback(i);
				return true;
			},
			get_lang : function () {
				return this.data.languages.current_language;
			},
			_get_string : function (key, lang) {
				var langs = this._get_settings().languages,
					s = this._get_settings().core.strings;
				if($.isArray(langs) && langs.length) {
					lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;
				}
				if(s[lang] && s[lang][key]) { return s[lang][key]; }
				if(s[key]) { return s[key]; }
				return key;
			},
			get_text : function (obj, lang) {
				obj = this._get_node(obj) || this.data.ui.last_selected;
				if(!obj.size()) { return false; }
				var langs = this._get_settings().languages,
					s = this._get_settings().core.html_titles;
				if($.isArray(langs) && langs.length) {
					lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;
					obj = obj.children("a." + lang);
				}
				else { obj = obj.children("a:eq(0)"); }
				if(s) {
					obj = obj.clone();
					obj.children("INS").remove();
					return obj.html();
				}
				else {
					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
					return obj.nodeValue;
				}
			},
			set_text : function (obj, val, lang) {
				obj = this._get_node(obj) || this.data.ui.last_selected;
				if(!obj.size()) { return false; }
				var langs = this._get_settings().languages,
					s = this._get_settings().core.html_titles,
					tmp;
				if($.isArray(langs) && langs.length) {
					lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;
					obj = obj.children("a." + lang);
				}
				else { obj = obj.children("a:eq(0)"); }
				if(s) {
					tmp = obj.children("INS").clone();
					obj.html(val).prepend(tmp);
					this.__callback({ "obj" : obj, "name" : val, "lang" : lang });
					return true;
				}
				else {
					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];
					this.__callback({ "obj" : obj, "name" : val, "lang" : lang });
					return (obj.nodeValue = val);
				}
			},
			_load_css : function () {
				var langs = this._get_settings().languages,
					str = "/* languages css */",
					selector = ".jstree-" + this.get_index() + ' a',
					ln;
				if($.isArray(langs) && langs.length) {
					this.data.languages.current_language = langs[0];
					for(ln = 0; ln < langs.length; ln++) {
						str += selector + "." + langs[ln] + " {";
						if(langs[ln] != this.data.languages.current_language) { str += " display:none; "; }
						str += " } ";
					}
					sh = $.vakata.css.add_sheet({ 'str' : str, 'title' : "jstree-languages" });
				}
			},
			create_node : function (obj, position, js, callback) {
				var t = this.__call_old(true, obj, position, js, function (t) {
					var langs = this._get_settings().languages,
						a = t.children("a"),
						ln;
					if($.isArray(langs) && langs.length) {
						for(ln = 0; ln < langs.length; ln++) {
							if(!a.is("." + langs[ln])) {
								t.append(a.eq(0).clone().removeClass(langs.join(" ")).addClass(langs[ln]));
							}
						}
						a.not("." + langs.join(", .")).remove();
					}
					if(callback) { callback.call(this, t); }
				});
				return t;
			}
		}
	});
})(jQuery);
//*/

/*
 * jsTree cookies plugin
 * Stores the currently opened/selected nodes in a cookie and then restores them
 * Depends on the jquery.cookie plugin
 */
(function ($) {
	$.jstree.plugin("cookies", {
		__init : function () {
			if(typeof $.cookie === "undefined") { throw "jsTree cookie: jQuery cookie plugin not included."; }

			var s = this._get_settings().cookies,
				tmp;
			if(!!s.save_loaded) {
				tmp = $.cookie(s.save_loaded);
				if(tmp && tmp.length) { this.data.core.to_load = tmp.split(","); }
			}
			if(!!s.save_opened) {
				tmp = $.cookie(s.save_opened);
				if(tmp && tmp.length) { this.data.core.to_open = tmp.split(","); }
			}
			if(!!s.save_selected) {
				tmp = $.cookie(s.save_selected);
				if(tmp && tmp.length && this.data.ui) { this.data.ui.to_select = tmp.split(","); }
			}
			this.get_container()
				.one( ( this.data.ui ? "reselect" : "reopen" ) + ".jstree", $.proxy(function () {
					this.get_container()
						.bind("open_node.jstree close_node.jstree select_node.jstree deselect_node.jstree", $.proxy(function (e) { 
								if(this._get_settings().cookies.auto_save) { this.save_cookie((e.handleObj.namespace + e.handleObj.type).replace("jstree","")); }
							}, this));
				}, this));
		},
		defaults : {
			save_loaded		: "jstree_load",
			save_opened		: "jstree_open",
			save_selected	: "jstree_select",
			auto_save		: true,
			cookie_options	: {}
		},
		_fn : {
			save_cookie : function (c) {
				if(this.data.core.refreshing) { return; }
				var s = this._get_settings().cookies;
				if(!c) { // if called manually and not by event
					if(s.save_loaded) {
						this.save_loaded();
						$.cookie(s.save_loaded, this.data.core.to_load.join(","), s.cookie_options);
					}
					if(s.save_opened) {
						this.save_opened();
						$.cookie(s.save_opened, this.data.core.to_open.join(","), s.cookie_options);
					}
					if(s.save_selected && this.data.ui) {
						this.save_selected();
						$.cookie(s.save_selected, this.data.ui.to_select.join(","), s.cookie_options);
					}
					return;
				}
				switch(c) {
					case "open_node":
					case "close_node":
						if(!!s.save_opened) { 
							this.save_opened(); 
							$.cookie(s.save_opened, this.data.core.to_open.join(","), s.cookie_options); 
						}
						if(!!s.save_loaded) { 
							this.save_loaded(); 
							$.cookie(s.save_loaded, this.data.core.to_load.join(","), s.cookie_options); 
						}
						break;
					case "select_node":
					case "deselect_node":
						if(!!s.save_selected && this.data.ui) { 
							this.save_selected(); 
							$.cookie(s.save_selected, this.data.ui.to_select.join(","), s.cookie_options); 
						}
						break;
				}
			}
		}
	});
	// include cookies by default
	// $.jstree.defaults.plugins.push("cookies");
})(jQuery);
//*/

/*
 * jsTree sort plugin
 * Sorts items alphabetically (or using any other function)
 */
(function ($) {
	$.jstree.plugin("sort", {
		__init : function () {
			this.get_container()
				.bind("load_node.jstree", $.proxy(function (e, data) {
						var obj = this._get_node(data.rslt.obj);
						obj = obj === -1 ? this.get_container().children("ul") : obj.children("ul");
						this.sort(obj);
					}, this))
				.bind("rename_node.jstree create_node.jstree create.jstree", $.proxy(function (e, data) {
						this.sort(data.rslt.obj.parent());
					}, this))
				.bind("move_node.jstree", $.proxy(function (e, data) {
						var m = data.rslt.np == -1 ? this.get_container() : data.rslt.np;
						this.sort(m.children("ul"));
					}, this));
		},
		defaults : function (a, b) { return this.get_text(a) > this.get_text(b) ? 1 : -1; },
		_fn : {
			sort : function (obj) {
				var s = this._get_settings().sort,
					t = this;
				obj.append($.makeArray(obj.children("li")).sort($.proxy(s, t)));
				obj.find("> li > ul").each(function() { t.sort($(this)); });
				this.clean_node(obj);
			}
		}
	});
})(jQuery);
//*/

/*
 * jsTree DND plugin
 * Drag and drop plugin for moving/copying nodes
 */
(function ($) {
	var o = false,
		r = false,
		m = false,
		ml = false,
		sli = false,
		sti = false,
		dir1 = false,
		dir2 = false,
		last_pos = false;
	$.vakata.dnd = {
		is_down : false,
		is_drag : false,
		helper : false,
		scroll_spd : 10,
		init_x : 0,
		init_y : 0,
		threshold : 5,
		helper_left : 5,
		helper_top : 10,
		user_data : {},

		drag_start : function (e, data, html) { 
			if($.vakata.dnd.is_drag) { $.vakata.drag_stop({}); }
			try {
				e.currentTarget.unselectable = "on";
				e.currentTarget.onselectstart = function() { return false; };
				if(e.currentTarget.style) { e.currentTarget.style.MozUserSelect = "none"; }
			} catch(err) { }
			$.vakata.dnd.init_x = e.pageX;
			$.vakata.dnd.init_y = e.pageY;
			$.vakata.dnd.user_data = data;
			$.vakata.dnd.is_down = true;
			$.vakata.dnd.helper = $("<div id='vakata-dragged' />").html(html); //.fadeTo(10,0.25);
			$(document).bind("mousemove", $.vakata.dnd.drag);
			$(document).bind("mouseup", $.vakata.dnd.drag_stop);
			return false;
		},
		drag : function (e) { 
			if(!$.vakata.dnd.is_down) { return; }
			if(!$.vakata.dnd.is_drag) {
				if(Math.abs(e.pageX - $.vakata.dnd.init_x) > 5 || Math.abs(e.pageY - $.vakata.dnd.init_y) > 5) { 
					$.vakata.dnd.helper.appendTo("body");
					$.vakata.dnd.is_drag = true;
					$(document).triggerHandler("drag_start.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
				}
				else { return; }
			}

			// maybe use a scrolling parent element instead of document?
			if(e.type === "mousemove") { // thought of adding scroll in order to move the helper, but mouse poisition is n/a
				var d = $(document), t = d.scrollTop(), l = d.scrollLeft();
				if(e.pageY - t < 20) { 
					if(sti && dir1 === "down") { clearInterval(sti); sti = false; }
					if(!sti) { dir1 = "up"; sti = setInterval(function () { $(document).scrollTop($(document).scrollTop() - $.vakata.dnd.scroll_spd); }, 150); }
				}
				else { 
					if(sti && dir1 === "up") { clearInterval(sti); sti = false; }
				}
				if($(window).height() - (e.pageY - t) < 20) {
					if(sti && dir1 === "up") { clearInterval(sti); sti = false; }
					if(!sti) { dir1 = "down"; sti = setInterval(function () { $(document).scrollTop($(document).scrollTop() + $.vakata.dnd.scroll_spd); }, 150); }
				}
				else { 
					if(sti && dir1 === "down") { clearInterval(sti); sti = false; }
				}

				if(e.pageX - l < 20) {
					if(sli && dir2 === "right") { clearInterval(sli); sli = false; }
					if(!sli) { dir2 = "left"; sli = setInterval(function () { $(document).scrollLeft($(document).scrollLeft() - $.vakata.dnd.scroll_spd); }, 150); }
				}
				else { 
					if(sli && dir2 === "left") { clearInterval(sli); sli = false; }
				}
				if($(window).width() - (e.pageX - l) < 20) {
					if(sli && dir2 === "left") { clearInterval(sli); sli = false; }
					if(!sli) { dir2 = "right"; sli = setInterval(function () { $(document).scrollLeft($(document).scrollLeft() + $.vakata.dnd.scroll_spd); }, 150); }
				}
				else { 
					if(sli && dir2 === "right") { clearInterval(sli); sli = false; }
				}
			}

			$.vakata.dnd.helper.css({ left : (e.pageX + $.vakata.dnd.helper_left) + "px", top : (e.pageY + $.vakata.dnd.helper_top) + "px" });
			$(document).triggerHandler("drag.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
		},
		drag_stop : function (e) {
			if(sli) { clearInterval(sli); }
			if(sti) { clearInterval(sti); }
			$(document).unbind("mousemove", $.vakata.dnd.drag);
			$(document).unbind("mouseup", $.vakata.dnd.drag_stop);
			$(document).triggerHandler("drag_stop.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });
			$.vakata.dnd.helper.remove();
			$.vakata.dnd.init_x = 0;
			$.vakata.dnd.init_y = 0;
			$.vakata.dnd.user_data = {};
			$.vakata.dnd.is_down = false;
			$.vakata.dnd.is_drag = false;
		}
	};
	$(function() {
		var css_string = '#vakata-dragged { display:block; margin:0 0 0 0; padding:4px 4px 4px 24px; position:absolute; top:-2000px; line-height:16px; z-index:10000; } ';
		$.vakata.css.add_sheet({ str : css_string, title : "vakata" });
	});

	$.jstree.plugin("dnd", {
		__init : function () {
			this.data.dnd = {
				active : false,
				after : false,
				inside : false,
				before : false,
				off : false,
				prepared : false,
				w : 0,
				to1 : false,
				to2 : false,
				cof : false,
				cw : false,
				ch : false,
				i1 : false,
				i2 : false,
				mto : false
			};
			this.get_container()
				.bind("mouseenter.jstree", $.proxy(function (e) {
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							if(this.data.themes) {
								m.attr("class", "jstree-" + this.data.themes.theme); 
								if(ml) { ml.attr("class", "jstree-" + this.data.themes.theme); }
								$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme);
							}
							//if($(e.currentTarget).find("> ul > li").length === 0) {
							if(e.currentTarget === e.target && $.vakata.dnd.user_data.obj && $($.vakata.dnd.user_data.obj).length && $($.vakata.dnd.user_data.obj).parents(".jstree:eq(0)")[0] !== e.target) { // node should not be from the same tree
								var tr = $.jstree._reference(e.target), dc;
								if(tr.data.dnd.foreign) {
									dc = tr._get_settings().dnd.drag_check.call(this, { "o" : o, "r" : tr.get_container(), is_root : true });
									if(dc === true || dc.inside === true || dc.before === true || dc.after === true) {
										$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
									}
								}
								else {
									tr.prepare_move(o, tr.get_container(), "last");
									if(tr.check_move()) {
										$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
									}
								}
							}
						}
					}, this))
				.bind("mouseup.jstree", $.proxy(function (e) {
						//if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && $(e.currentTarget).find("> ul > li").length === 0) {
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && e.currentTarget === e.target && $.vakata.dnd.user_data.obj && $($.vakata.dnd.user_data.obj).length && $($.vakata.dnd.user_data.obj).parents(".jstree:eq(0)")[0] !== e.target) { // node should not be from the same tree
							var tr = $.jstree._reference(e.currentTarget), dc;
							if(tr.data.dnd.foreign) {
								dc = tr._get_settings().dnd.drag_check.call(this, { "o" : o, "r" : tr.get_container(), is_root : true });
								if(dc === true || dc.inside === true || dc.before === true || dc.after === true) {
									tr._get_settings().dnd.drag_finish.call(this, { "o" : o, "r" : tr.get_container(), is_root : true });
								}
							}
							else {
								tr.move_node(o, tr.get_container(), "last", e[tr._get_settings().dnd.copy_modifier + "Key"]);
							}
						}
					}, this))
				.bind("mouseleave.jstree", $.proxy(function (e) {
						if(e.relatedTarget && e.relatedTarget.id && e.relatedTarget.id === "jstree-marker-line") {
							return false; 
						}
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
							if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
							if(this.data.dnd.to1) { clearTimeout(this.data.dnd.to1); }
							if(this.data.dnd.to2) { clearTimeout(this.data.dnd.to2); }
							if($.vakata.dnd.helper.children("ins").hasClass("jstree-ok")) {
								$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
							}
						}
					}, this))
				.bind("mousemove.jstree", $.proxy(function (e) {
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							var cnt = this.get_container()[0];

							// Horizontal scroll
							if(e.pageX + 24 > this.data.dnd.cof.left + this.data.dnd.cw) {
								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
								this.data.dnd.i1 = setInterval($.proxy(function () { this.scrollLeft += $.vakata.dnd.scroll_spd; }, cnt), 100);
							}
							else if(e.pageX - 24 < this.data.dnd.cof.left) {
								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
								this.data.dnd.i1 = setInterval($.proxy(function () { this.scrollLeft -= $.vakata.dnd.scroll_spd; }, cnt), 100);
							}
							else {
								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
							}

							// Vertical scroll
							if(e.pageY + 24 > this.data.dnd.cof.top + this.data.dnd.ch) {
								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
								this.data.dnd.i2 = setInterval($.proxy(function () { this.scrollTop += $.vakata.dnd.scroll_spd; }, cnt), 100);
							}
							else if(e.pageY - 24 < this.data.dnd.cof.top) {
								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
								this.data.dnd.i2 = setInterval($.proxy(function () { this.scrollTop -= $.vakata.dnd.scroll_spd; }, cnt), 100);
							}
							else {
								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
							}

						}
					}, this))
				.bind("scroll.jstree", $.proxy(function (e) { 
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && m && ml) {
							m.hide();
							ml.hide();
						}
					}, this))
				.delegate("a", "mousedown.jstree", $.proxy(function (e) { 
						if(e.which === 1) {
							this.start_drag(e.currentTarget, e);
							return false;
						}
					}, this))
				.delegate("a", "mouseenter.jstree", $.proxy(function (e) { 
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							this.dnd_enter(e.currentTarget);
						}
					}, this))
				.delegate("a", "mousemove.jstree", $.proxy(function (e) { 
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							if(!r || !r.length || r.children("a")[0] !== e.currentTarget) {
								this.dnd_enter(e.currentTarget);
							}
							if(typeof this.data.dnd.off.top === "undefined") { this.data.dnd.off = $(e.target).offset(); }
							this.data.dnd.w = (e.pageY - (this.data.dnd.off.top || 0)) % this.data.core.li_height;
							if(this.data.dnd.w < 0) { this.data.dnd.w += this.data.core.li_height; }
							this.dnd_show();
						}
					}, this))
				.delegate("a", "mouseleave.jstree", $.proxy(function (e) { 
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							if(e.relatedTarget && e.relatedTarget.id && e.relatedTarget.id === "jstree-marker-line") {
								return false; 
							}
								if(m) { m.hide(); }
								if(ml) { ml.hide(); }
							/*
							var ec = $(e.currentTarget).closest("li"), 
								er = $(e.relatedTarget).closest("li");
							if(er[0] !== ec.prev()[0] && er[0] !== ec.next()[0]) {
								if(m) { m.hide(); }
								if(ml) { ml.hide(); }
							}
							*/
							this.data.dnd.mto = setTimeout( 
								(function (t) { return function () { t.dnd_leave(e); }; })(this),
							0);
						}
					}, this))
				.delegate("a, #jstree-marker-line", "mouseup.jstree", $.proxy(function (e) {
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {
							this.dnd_finish(e);
						}
					}, this));

			$(document)
				.bind("drag_stop.vakata", $.proxy(function () {
						if(this.data.dnd.to1) { clearTimeout(this.data.dnd.to1); }
						if(this.data.dnd.to2) { clearTimeout(this.data.dnd.to2); }
						if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }
						if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }
						this.data.dnd.after		= false;
						this.data.dnd.before	= false;
						this.data.dnd.inside	= false;
						this.data.dnd.off		= false;
						this.data.dnd.prepared	= false;
						this.data.dnd.w			= false;
						this.data.dnd.to1		= false;
						this.data.dnd.to2		= false;
						this.data.dnd.i1		= false;
						this.data.dnd.i2		= false;
						this.data.dnd.active	= false;
						this.data.dnd.foreign	= false;
						if(m) { m.css({ "top" : "-2000px" }); }
						if(ml) { ml.css({ "top" : "-2000px" }); }
					}, this))
				.bind("drag_start.vakata", $.proxy(function (e, data) {
						if(data.data.jstree) { 
							var et = $(data.event.target);
							if(et.closest(".jstree").hasClass("jstree-" + this.get_index())) {
								this.dnd_enter(et);
							}
						}
					}, this));
				/*
				.bind("keydown.jstree-" + this.get_index() + " keyup.jstree-" + this.get_index(), $.proxy(function(e) {
						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && !this.data.dnd.foreign) {
							var h = $.vakata.dnd.helper.children("ins");
							if(e[this._get_settings().dnd.copy_modifier + "Key"] && h.hasClass("jstree-ok")) {
								h.parent().html(h.parent().html().replace(/ \(Copy\)$/, "") + " (Copy)");
							} 
							else {
								h.parent().html(h.parent().html().replace(/ \(Copy\)$/, ""));
							}
						}
					}, this)); */



			var s = this._get_settings().dnd;
			if(s.drag_target) {
				$(document)
					.delegate(s.drag_target, "mousedown.jstree-" + this.get_index(), $.proxy(function (e) {
						o = e.target;
						$.vakata.dnd.drag_start(e, { jstree : true, obj : e.target }, "<ins class='jstree-icon'></ins>" + $(e.target).text() );
						if(this.data.themes) { 
							if(m) { m.attr("class", "jstree-" + this.data.themes.theme); }
							if(ml) { ml.attr("class", "jstree-" + this.data.themes.theme); }
							$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme); 
						}
						$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
						var cnt = this.get_container();
						this.data.dnd.cof = cnt.offset();
						this.data.dnd.cw = parseInt(cnt.width(),10);
						this.data.dnd.ch = parseInt(cnt.height(),10);
						this.data.dnd.foreign = true;
						e.preventDefault();
					}, this));
			}
			if(s.drop_target) {
				$(document)
					.delegate(s.drop_target, "mouseenter.jstree-" + this.get_index(), $.proxy(function (e) {
							if(this.data.dnd.active && this._get_settings().dnd.drop_check.call(this, { "o" : o, "r" : $(e.target), "e" : e })) {
								$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
							}
						}, this))
					.delegate(s.drop_target, "mouseleave.jstree-" + this.get_index(), $.proxy(function (e) {
							if(this.data.dnd.active) {
								$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
							}
						}, this))
					.delegate(s.drop_target + ", #jstree-marker-line", "mouseup.jstree-" + this.get_index(), $.proxy(function (e) {
							if(this.data.dnd.active && $.vakata.dnd.helper.children("ins").hasClass("jstree-ok")) {
								this._get_settings().dnd.drop_finish.call(this, { "o" : o, "r" : $(e.target), "e" : e });
							}
						}, this));
			}
		},
		defaults : {
			copy_modifier	: "ctrl",
			check_timeout	: 100,
			open_timeout	: 500,
			drop_target		: ".jstree-drop",
			drop_check		: function (data) { return true; },
			drop_finish		: $.noop,
			drag_target		: ".jstree-draggable",
			drag_finish		: $.noop,
			drag_check		: function (data) { return { after : false, before : false, inside : true }; }
		},
		__destroy : function () {
			// unbind global event handlers when last instance is removed
			// (no access to private 'instances' variable from here)
			if($('.jstree').length <= 1) {
				$(document)
					.unbind("drag_start.vakata")
					.unbind("drag_stop.vakata");	
			}
			o = false;
		},
		_fn : {
			dnd_prepare : function () {
				if(!r || !r.length) { return; }
				this.data.dnd.off = r.offset();
				if(this._get_settings().core.rtl) {
					this.data.dnd.off.right = this.data.dnd.off.left + r.width();
				}
				if(this.data.dnd.foreign) {
					var a = this._get_settings().dnd.drag_check.call(this, { "o" : o, "r" : r });
					this.data.dnd.after = a.after;
					this.data.dnd.before = a.before;
					this.data.dnd.inside = a.inside;
					this.data.dnd.prepared = true;
					return this.dnd_show();
				}
				this.prepare_move(o, r, "before");
				this.data.dnd.before = this.check_move();
				this.prepare_move(o, r, "after");
				this.data.dnd.after = this.check_move();
				if(this._is_loaded(r)) {
					this.prepare_move(o, r, "inside");
					this.data.dnd.inside = this.check_move();
				}
				else {
					this.data.dnd.inside = false;
				}
				this.data.dnd.prepared = true;
				return this.dnd_show();
			},
			dnd_show : function () {
				if(!this.data.dnd.prepared) { return; }
				var o = ["before","inside","after"],
					r = false,
					rtl = this._get_settings().core.rtl,
					pos;
				if(this.data.dnd.w < this.data.core.li_height/3) { o = ["before","inside","after"]; }
				else if(this.data.dnd.w <= this.data.core.li_height*2/3) {
					o = this.data.dnd.w < this.data.core.li_height/2 ? ["inside","before","after"] : ["inside","after","before"];
				}
				else { o = ["after","inside","before"]; }
				$.each(o, $.proxy(function (i, val) { 
					if(this.data.dnd[val]) {
						$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");
						r = val;
						return false;
					}
				}, this));
				if(r === false) { $.vakata.dnd.helper.children("ins").attr("class","jstree-invalid"); }
				
				pos = rtl ? (this.data.dnd.off.right - 18) : (this.data.dnd.off.left + 10);
				switch(r) {
					case "before":
						m.css({ "left" : pos + "px", "top" : (this.data.dnd.off.top - 6) + "px" }).show();
						if(ml) { ml.css({ "left" : (pos + 8) + "px", "top" : (this.data.dnd.off.top - 1) + "px" }).show(); }
						break;
					case "after":
						m.css({ "left" : pos + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height - 6) + "px" }).show();
						if(ml) { ml.css({ "left" : (pos + 8) + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height - 1) + "px" }).show(); }
						break;
					case "inside":
						m.css({ "left" : pos + ( rtl ? -4 : 4) + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height/2 - 5) + "px" }).show();
						if(ml) { ml.hide(); }
						break;
					default:
						m.hide();
						if(ml) { ml.hide(); }
						break;
				}
				last_pos = r;
				return r;
			},
			dnd_open : function () {
				this.data.dnd.to2 = false;
				this.open_node(r, $.proxy(this.dnd_prepare,this), true);
			},
			dnd_finish : function (e) {
				if(this.data.dnd.foreign) {
					if(this.data.dnd.after || this.data.dnd.before || this.data.dnd.inside) {
						this._get_settings().dnd.drag_finish.call(this, { "o" : o, "r" : r, "p" : last_pos });
					}
				}
				else {
					this.dnd_prepare();
					this.move_node(o, r, last_pos, e[this._get_settings().dnd.copy_modifier + "Key"]);
				}
				o = false;
				r = false;
				m.hide();
				if(ml) { ml.hide(); }
			},
			dnd_enter : function (obj) {
				if(this.data.dnd.mto) { 
					clearTimeout(this.data.dnd.mto);
					this.data.dnd.mto = false;
				}
				var s = this._get_settings().dnd;
				this.data.dnd.prepared = false;
				r = this._get_node(obj);
				if(s.check_timeout) { 
					// do the calculations after a minimal timeout (users tend to drag quickly to the desired location)
					if(this.data.dnd.to1) { clearTimeout(this.data.dnd.to1); }
					this.data.dnd.to1 = setTimeout($.proxy(this.dnd_prepare, this), s.check_timeout); 
				}
				else { 
					this.dnd_prepare(); 
				}
				if(s.open_timeout) { 
					if(this.data.dnd.to2) { clearTimeout(this.data.dnd.to2); }
					if(r && r.length && r.hasClass("jstree-closed")) { 
						// if the node is closed - open it, then recalculate
						this.data.dnd.to2 = setTimeout($.proxy(this.dnd_open, this), s.open_timeout);
					}
				}
				else {
					if(r && r.length && r.hasClass("jstree-closed")) { 
						this.dnd_open();
					}
				}
			},
			dnd_leave : function (e) {
				this.data.dnd.after		= false;
				this.data.dnd.before	= false;
				this.data.dnd.inside	= false;
				$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");
				m.hide();
				if(ml) { ml.hide(); }
				if(r && r[0] === e.target.parentNode) {
					if(this.data.dnd.to1) {
						clearTimeout(this.data.dnd.to1);
						this.data.dnd.to1 = false;
					}
					if(this.data.dnd.to2) {
						clearTimeout(this.data.dnd.to2);
						this.data.dnd.to2 = false;
					}
				}
			},
			start_drag : function (obj, e) {
				o = this._get_node(obj);
				if(this.data.ui && this.is_selected(o)) { o = this._get_node(null, true); }
				var dt = o.length > 1 ? this._get_string("multiple_selection") : this.get_text(o),
					cnt = this.get_container();
				if(!this._get_settings().core.html_titles) { dt = dt.replace(/</ig,"&lt;").replace(/>/ig,"&gt;"); }
				$.vakata.dnd.drag_start(e, { jstree : true, obj : o }, "<ins class='jstree-icon'></ins>" + dt );
				if(this.data.themes) { 
					if(m) { m.attr("class", "jstree-" + this.data.themes.theme); }
					if(ml) { ml.attr("class", "jstree-" + this.data.themes.theme); }
					$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme); 
				}
				this.data.dnd.cof = cnt.offset();
				this.data.dnd.cw = parseInt(cnt.width(),10);
				this.data.dnd.ch = parseInt(cnt.height(),10);
				this.data.dnd.active = true;
			}
		}
	});
	$(function() {
		var css_string = '' + 
			'#vakata-dragged ins { display:block; text-decoration:none; width:16px; height:16px; margin:0 0 0 0; padding:0; position:absolute; top:4px; left:4px; ' + 
			' -moz-border-radius:4px; border-radius:4px; -webkit-border-radius:4px; ' +
			'} ' + 
			'#vakata-dragged .jstree-ok { background:green; } ' + 
			'#vakata-dragged .jstree-invalid { background:red; } ' + 
			'#jstree-marker { padding:0; margin:0; font-size:12px; overflow:hidden; height:12px; width:8px; position:absolute; top:-30px; z-index:10001; background-repeat:no-repeat; display:none; background-color:transparent; text-shadow:1px 1px 1px white; color:black; line-height:10px; } ' + 
			'#jstree-marker-line { padding:0; margin:0; line-height:0%; font-size:1px; overflow:hidden; height:1px; width:100px; position:absolute; top:-30px; z-index:10000; background-repeat:no-repeat; display:none; background-color:#456c43; ' + 
			' cursor:pointer; border:1px solid #eeeeee; border-left:0; -moz-box-shadow: 0px 0px 2px #666; -webkit-box-shadow: 0px 0px 2px #666; box-shadow: 0px 0px 2px #666; ' + 
			' -moz-border-radius:1px; border-radius:1px; -webkit-border-radius:1px; ' +
			'}' + 
			'';
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
		m = $("<div />").attr({ id : "jstree-marker" }).hide().html("&raquo;")
			.bind("mouseleave mouseenter", function (e) { 
				m.hide();
				ml.hide();
				e.preventDefault(); 
				e.stopImmediatePropagation(); 
				return false; 
			})
			.appendTo("body");
		ml = $("<div />").attr({ id : "jstree-marker-line" }).hide()
			.bind("mouseup", function (e) { 
				if(r && r.length) { 
					r.children("a").trigger(e); 
					e.preventDefault(); 
					e.stopImmediatePropagation(); 
					return false; 
				} 
			})
			.bind("mouseleave", function (e) { 
				var rt = $(e.relatedTarget);
				if(rt.is(".jstree") || rt.closest(".jstree").length === 0) {
					if(r && r.length) { 
						r.children("a").trigger(e); 
						m.hide();
						ml.hide();
						e.preventDefault(); 
						e.stopImmediatePropagation(); 
						return false; 
					}
				}
			})
			.appendTo("body");
		$(document).bind("drag_start.vakata", function (e, data) {
			if(data.data.jstree) { m.show(); if(ml) { ml.show(); } }
		});
		$(document).bind("drag_stop.vakata", function (e, data) {
			if(data.data.jstree) { m.hide(); if(ml) { ml.hide(); } }
		});
	});
})(jQuery);
//*/

/*
 * jsTree checkbox plugin
 * Inserts checkboxes in front of every node
 * Depends on the ui plugin
 * DOES NOT WORK NICELY WITH MULTITREE DRAG'N'DROP
 */
(function ($) {
	$.jstree.plugin("checkbox", {
		__init : function () {
			this.data.checkbox.noui = this._get_settings().checkbox.override_ui;
			if(this.data.ui && this.data.checkbox.noui) {
				this.select_node = this.deselect_node = this.deselect_all = $.noop;
				this.get_selected = this.get_checked;
			}

			this.get_container()
				.bind("open_node.jstree create_node.jstree clean_node.jstree refresh.jstree", $.proxy(function (e, data) { 
						this._prepare_checkboxes(data.rslt.obj);
					}, this))
				.bind("loaded.jstree", $.proxy(function (e) {
						this._prepare_checkboxes();
					}, this))
				.delegate( (this.data.ui && this.data.checkbox.noui ? "a" : "ins.jstree-checkbox") , "click.jstree", $.proxy(function (e) {
						e.preventDefault();
						if(this._get_node(e.target).hasClass("jstree-checked")) { this.uncheck_node(e.target); }
						else { this.check_node(e.target); }
						if(this.data.ui && this.data.checkbox.noui) {
							this.save_selected();
							if(this.data.cookies) { this.save_cookie("select_node"); }
						}
						else {
							e.stopImmediatePropagation();
							return false;
						}
					}, this));
		},
		defaults : {
			override_ui : false,
			two_state : false,
			real_checkboxes : false,
			checked_parent_open : true,
			real_checkboxes_names : function (n) { return [ ("check_" + (n[0].id || Math.ceil(Math.random() * 10000))) , 1]; }
		},
		__destroy : function () {
			this.get_container()
				.find("input.jstree-real-checkbox").removeClass("jstree-real-checkbox").end()
				.find("ins.jstree-checkbox").remove();
		},
		_fn : {
			_checkbox_notify : function (n, data) {
				if(data.checked) {
					this.check_node(n, false);
				}
			},
			_prepare_checkboxes : function (obj) {
				obj = !obj || obj == -1 ? this.get_container().find("> ul > li") : this._get_node(obj);
				if(obj === false) { return; } // added for removing root nodes
				var c, _this = this, t, ts = this._get_settings().checkbox.two_state, rc = this._get_settings().checkbox.real_checkboxes, rcn = this._get_settings().checkbox.real_checkboxes_names;
				obj.each(function () {
					t = $(this);
					c = t.is("li") && (t.hasClass("jstree-checked") || (rc && t.children(":checked").length)) ? "jstree-checked" : "jstree-unchecked";
					t.find("li").andSelf().each(function () {
						var $t = $(this), nm;
						$t.children("a" + (_this.data.languages ? "" : ":eq(0)") ).not(":has(.jstree-checkbox)").prepend("<ins class='jstree-checkbox'>&#160;</ins>").parent().not(".jstree-checked, .jstree-unchecked").addClass( ts ? "jstree-unchecked" : c );
						if(rc) {
							if(!$t.children(":checkbox").length) {
								nm = rcn.call(_this, $t);
								$t.prepend("<input type='checkbox' class='jstree-real-checkbox' id='" + nm[0] + "' name='" + nm[0] + "' value='" + nm[1] + "' />");
							}
							else {
								$t.children(":checkbox").addClass("jstree-real-checkbox");
							}
						}
						if(!ts) {
							if(c === "jstree-checked" || $t.hasClass("jstree-checked") || $t.children(':checked').length) {
								$t.find("li").andSelf().addClass("jstree-checked").children(":checkbox").prop("checked", true);
							}
						}
						else {
							if($t.hasClass("jstree-checked") || $t.children(':checked').length) {
								$t.addClass("jstree-checked").children(":checkbox").prop("checked", true);
							}
						}
					});
				});
				if(!ts) {
					obj.find(".jstree-checked").parent().parent().each(function () { _this._repair_state(this); }); 
				}
			},
			change_state : function (obj, state) {
				obj = this._get_node(obj);
				var coll = false, rc = this._get_settings().checkbox.real_checkboxes;
				if(!obj || obj === -1) { return false; }
				state = (state === false || state === true) ? state : obj.hasClass("jstree-checked");
				if(this._get_settings().checkbox.two_state) {
					if(state) { 
						obj.removeClass("jstree-checked").addClass("jstree-unchecked"); 
						if(rc) { obj.children(":checkbox").prop("checked", false); }
					}
					else { 
						obj.removeClass("jstree-unchecked").addClass("jstree-checked"); 
						if(rc) { obj.children(":checkbox").prop("checked", true); }
					}
				}
				else {
					if(state) { 
						coll = obj.find("li").andSelf();
						if(!coll.filter(".jstree-checked, .jstree-undetermined").length) { return false; }
						coll.removeClass("jstree-checked jstree-undetermined").addClass("jstree-unchecked"); 
						if(rc) { coll.children(":checkbox").prop("checked", false); }
					}
					else { 
						coll = obj.find("li").andSelf();
						if(!coll.filter(".jstree-unchecked, .jstree-undetermined").length) { return false; }
						coll.removeClass("jstree-unchecked jstree-undetermined").addClass("jstree-checked"); 
						if(rc) { coll.children(":checkbox").prop("checked", true); }
						if(this.data.ui) { this.data.ui.last_selected = obj; }
						this.data.checkbox.last_selected = obj;
					}
					obj.parentsUntil(".jstree", "li").each(function () {
						var $this = $(this);
						if(state) {
							if($this.children("ul").children("li.jstree-checked, li.jstree-undetermined").length) {
								$this.parentsUntil(".jstree", "li").andSelf().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
								if(rc) { $this.parentsUntil(".jstree", "li").andSelf().children(":checkbox").prop("checked", false); }
								return false;
							}
							else {
								$this.removeClass("jstree-checked jstree-undetermined").addClass("jstree-unchecked");
								if(rc) { $this.children(":checkbox").prop("checked", false); }
							}
						}
						else {
							if($this.children("ul").children("li.jstree-unchecked, li.jstree-undetermined").length) {
								$this.parentsUntil(".jstree", "li").andSelf().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
								if(rc) { $this.parentsUntil(".jstree", "li").andSelf().children(":checkbox").prop("checked", false); }
								return false;
							}
							else {
								$this.removeClass("jstree-unchecked jstree-undetermined").addClass("jstree-checked");
								if(rc) { $this.children(":checkbox").prop("checked", true); }
							}
						}
					});
				}
				if(this.data.ui && this.data.checkbox.noui) { this.data.ui.selected = this.get_checked(); }
				this.__callback(obj);
				return true;
			},
			check_node : function (obj) {
				if(this.change_state(obj, false)) { 
					obj = this._get_node(obj);
					if(this._get_settings().checkbox.checked_parent_open) {
						var t = this;
						obj.parents(".jstree-closed").each(function () { t.open_node(this, false, true); });
					}
					this.__callback({ "obj" : obj }); 
				}
			},
			uncheck_node : function (obj) {
				if(this.change_state(obj, true)) { this.__callback({ "obj" : this._get_node(obj) }); }
			},
			check_all : function () {
				var _this = this, 
					coll = this._get_settings().checkbox.two_state ? this.get_container_ul().find("li") : this.get_container_ul().children("li");
				coll.each(function () {
					_this.change_state(this, false);
				});
				this.__callback();
			},
			uncheck_all : function () {
				var _this = this,
					coll = this._get_settings().checkbox.two_state ? this.get_container_ul().find("li") : this.get_container_ul().children("li");
				coll.each(function () {
					_this.change_state(this, true);
				});
				this.__callback();
			},

			is_checked : function(obj) {
				obj = this._get_node(obj);
				return obj.length ? obj.is(".jstree-checked") : false;
			},
			get_checked : function (obj, get_all) {
				obj = !obj || obj === -1 ? this.get_container() : this._get_node(obj);
				return get_all || this._get_settings().checkbox.two_state ? obj.find(".jstree-checked") : obj.find("> ul > .jstree-checked, .jstree-undetermined > ul > .jstree-checked");
			},
			get_unchecked : function (obj, get_all) { 
				obj = !obj || obj === -1 ? this.get_container() : this._get_node(obj);
				return get_all || this._get_settings().checkbox.two_state ? obj.find(".jstree-unchecked") : obj.find("> ul > .jstree-unchecked, .jstree-undetermined > ul > .jstree-unchecked");
			},

			show_checkboxes : function () { this.get_container().children("ul").removeClass("jstree-no-checkboxes"); },
			hide_checkboxes : function () { this.get_container().children("ul").addClass("jstree-no-checkboxes"); },

			_repair_state : function (obj) {
				obj = this._get_node(obj);
				if(!obj.length) { return; }
				if(this._get_settings().checkbox.two_state) {
					obj.find('li').andSelf().not('.jstree-checked').removeClass('jstree-undetermined').addClass('jstree-unchecked').children(':checkbox').prop('checked', true);
					return;
				}
				var rc = this._get_settings().checkbox.real_checkboxes,
					a = obj.find("> ul > .jstree-checked").length,
					b = obj.find("> ul > .jstree-undetermined").length,
					c = obj.find("> ul > li").length;
				if(c === 0) { if(obj.hasClass("jstree-undetermined")) { this.change_state(obj, false); } }
				else if(a === 0 && b === 0) { this.change_state(obj, true); }
				else if(a === c) { this.change_state(obj, false); }
				else { 
					obj.parentsUntil(".jstree","li").andSelf().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");
					if(rc) { obj.parentsUntil(".jstree", "li").andSelf().children(":checkbox").prop("checked", false); }
				}
			},
			reselect : function () {
				if(this.data.ui && this.data.checkbox.noui) { 
					var _this = this,
						s = this.data.ui.to_select;
					s = $.map($.makeArray(s), function (n) { return "#" + n.toString().replace(/^#/,"").replace(/\\\//g,"/").replace(/\//g,"\\\/").replace(/\\\./g,".").replace(/\./g,"\\.").replace(/\:/g,"\\:"); });
					this.deselect_all();
					$.each(s, function (i, val) { _this.check_node(val); });
					this.__callback();
				}
				else { 
					this.__call_old(); 
				}
			},
			save_loaded : function () {
				var _this = this;
				this.data.core.to_load = [];
				this.get_container_ul().find("li.jstree-closed.jstree-undetermined").each(function () {
					if(this.id) { _this.data.core.to_load.push("#" + this.id); }
				});
			}
		}
	});
	$(function() {
		var css_string = '.jstree .jstree-real-checkbox { display:none; } ';
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
	});
})(jQuery);
//*/

/* 
 * jsTree XML plugin
 * The XML data store. Datastores are build by overriding the `load_node` and `_is_loaded` functions.
 */
(function ($) {
	$.vakata.xslt = function (xml, xsl, callback) {
		var rs = "", xm, xs, processor, support;
		// TODO: IE9 no XSLTProcessor, no document.recalc
		if(document.recalc) {
			xm = document.createElement('xml');
			xs = document.createElement('xml');
			xm.innerHTML = xml;
			xs.innerHTML = xsl;
			$("body").append(xm).append(xs);
			setTimeout( (function (xm, xs, callback) {
				return function () {
					callback.call(null, xm.transformNode(xs.XMLDocument));
					setTimeout( (function (xm, xs) { return function () { $(xm).remove(); $(xs).remove(); }; })(xm, xs), 200);
				};
			})(xm, xs, callback), 100);
			return true;
		}
		if(typeof window.DOMParser !== "undefined" && typeof window.XMLHttpRequest !== "undefined" && typeof window.XSLTProcessor === "undefined") {
			xml = new DOMParser().parseFromString(xml, "text/xml");
			xsl = new DOMParser().parseFromString(xsl, "text/xml");
			// alert(xml.transformNode());
			// callback.call(null, new XMLSerializer().serializeToString(rs));
			
		}
		if(typeof window.DOMParser !== "undefined" && typeof window.XMLHttpRequest !== "undefined" && typeof window.XSLTProcessor !== "undefined") {
			processor = new XSLTProcessor();
			support = $.isFunction(processor.transformDocument) ? (typeof window.XMLSerializer !== "undefined") : true;
			if(!support) { return false; }
			xml = new DOMParser().parseFromString(xml, "text/xml");
			xsl = new DOMParser().parseFromString(xsl, "text/xml");
			if($.isFunction(processor.transformDocument)) {
				rs = document.implementation.createDocument("", "", null);
				processor.transformDocument(xml, xsl, rs, null);
				callback.call(null, new XMLSerializer().serializeToString(rs));
				return true;
			}
			else {
				processor.importStylesheet(xsl);
				rs = processor.transformToFragment(xml, document);
				callback.call(null, $("<div />").append(rs).html());
				return true;
			}
		}
		return false;
	};
	var xsl = {
		'nest' : '<' + '?xml version="1.0" encoding="utf-8" ?>' + 
			'<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" >' + 
			'<xsl:output method="html" encoding="utf-8" omit-xml-declaration="yes" standalone="no" indent="no" media-type="text/html" />' + 
			'<xsl:template match="/">' + 
			'	<xsl:call-template name="nodes">' + 
			'		<xsl:with-param name="node" select="/root" />' + 
			'	</xsl:call-template>' + 
			'</xsl:template>' + 
			'<xsl:template name="nodes">' + 
			'	<xsl:param name="node" />' + 
			'	<ul>' + 
			'	<xsl:for-each select="$node/item">' + 
			'		<xsl:variable name="children" select="count(./item) &gt; 0" />' + 
			'		<li>' + 
			'			<xsl:attribute name="class">' + 
			'				<xsl:if test="position() = last()">jstree-last </xsl:if>' + 
			'				<xsl:choose>' + 
			'					<xsl:when test="@state = \'open\'">jstree-open </xsl:when>' + 
			'					<xsl:when test="$children or @hasChildren or @state = \'closed\'">jstree-closed </xsl:when>' + 
			'					<xsl:otherwise>jstree-leaf </xsl:otherwise>' + 
			'				</xsl:choose>' + 
			'				<xsl:value-of select="@class" />' + 
			'			</xsl:attribute>' + 
			'			<xsl:for-each select="@*">' + 
			'				<xsl:if test="name() != \'class\' and name() != \'state\' and name() != \'hasChildren\'">' + 
			'					<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
			'				</xsl:if>' + 
			'			</xsl:for-each>' + 
			'	<ins class="jstree-icon"><xsl:text>&#xa0;</xsl:text></ins>' + 
			'			<xsl:for-each select="content/name">' + 
			'				<a>' + 
			'				<xsl:attribute name="href">' + 
			'					<xsl:choose>' + 
			'					<xsl:when test="@href"><xsl:value-of select="@href" /></xsl:when>' + 
			'					<xsl:otherwise>#</xsl:otherwise>' + 
			'					</xsl:choose>' + 
			'				</xsl:attribute>' + 
			'				<xsl:attribute name="class"><xsl:value-of select="@lang" /> <xsl:value-of select="@class" /></xsl:attribute>' + 
			'				<xsl:attribute name="style"><xsl:value-of select="@style" /></xsl:attribute>' + 
			'				<xsl:for-each select="@*">' + 
			'					<xsl:if test="name() != \'style\' and name() != \'class\' and name() != \'href\'">' + 
			'						<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
			'					</xsl:if>' + 
			'				</xsl:for-each>' + 
			'					<ins>' + 
			'						<xsl:attribute name="class">jstree-icon ' + 
			'							<xsl:if test="string-length(attribute::icon) > 0 and not(contains(@icon,\'/\'))"><xsl:value-of select="@icon" /></xsl:if>' + 
			'						</xsl:attribute>' + 
			'						<xsl:if test="string-length(attribute::icon) > 0 and contains(@icon,\'/\')"><xsl:attribute name="style">background:url(<xsl:value-of select="@icon" />) center center no-repeat;</xsl:attribute></xsl:if>' + 
			'						<xsl:text>&#xa0;</xsl:text>' + 
			'					</ins>' + 
			'					<xsl:copy-of select="./child::node()" />' + 
			'				</a>' + 
			'			</xsl:for-each>' + 
			'			<xsl:if test="$children or @hasChildren"><xsl:call-template name="nodes"><xsl:with-param name="node" select="current()" /></xsl:call-template></xsl:if>' + 
			'		</li>' + 
			'	</xsl:for-each>' + 
			'	</ul>' + 
			'</xsl:template>' + 
			'</xsl:stylesheet>',

		'flat' : '<' + '?xml version="1.0" encoding="utf-8" ?>' + 
			'<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" >' + 
			'<xsl:output method="html" encoding="utf-8" omit-xml-declaration="yes" standalone="no" indent="no" media-type="text/xml" />' + 
			'<xsl:template match="/">' + 
			'	<ul>' + 
			'	<xsl:for-each select="//item[not(@parent_id) or @parent_id=0 or not(@parent_id = //item/@id)]">' + /* the last `or` may be removed */
			'		<xsl:call-template name="nodes">' + 
			'			<xsl:with-param name="node" select="." />' + 
			'			<xsl:with-param name="is_last" select="number(position() = last())" />' + 
			'		</xsl:call-template>' + 
			'	</xsl:for-each>' + 
			'	</ul>' + 
			'</xsl:template>' + 
			'<xsl:template name="nodes">' + 
			'	<xsl:param name="node" />' + 
			'	<xsl:param name="is_last" />' + 
			'	<xsl:variable name="children" select="count(//item[@parent_id=$node/attribute::id]) &gt; 0" />' + 
			'	<li>' + 
			'	<xsl:attribute name="class">' + 
			'		<xsl:if test="$is_last = true()">jstree-last </xsl:if>' + 
			'		<xsl:choose>' + 
			'			<xsl:when test="@state = \'open\'">jstree-open </xsl:when>' + 
			'			<xsl:when test="$children or @hasChildren or @state = \'closed\'">jstree-closed </xsl:when>' + 
			'			<xsl:otherwise>jstree-leaf </xsl:otherwise>' + 
			'		</xsl:choose>' + 
			'		<xsl:value-of select="@class" />' + 
			'	</xsl:attribute>' + 
			'	<xsl:for-each select="@*">' + 
			'		<xsl:if test="name() != \'parent_id\' and name() != \'hasChildren\' and name() != \'class\' and name() != \'state\'">' + 
			'		<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
			'		</xsl:if>' + 
			'	</xsl:for-each>' + 
			'	<ins class="jstree-icon"><xsl:text>&#xa0;</xsl:text></ins>' + 
			'	<xsl:for-each select="content/name">' + 
			'		<a>' + 
			'		<xsl:attribute name="href">' + 
			'			<xsl:choose>' + 
			'			<xsl:when test="@href"><xsl:value-of select="@href" /></xsl:when>' + 
			'			<xsl:otherwise>#</xsl:otherwise>' + 
			'			</xsl:choose>' + 
			'		</xsl:attribute>' + 
			'		<xsl:attribute name="class"><xsl:value-of select="@lang" /> <xsl:value-of select="@class" /></xsl:attribute>' + 
			'		<xsl:attribute name="style"><xsl:value-of select="@style" /></xsl:attribute>' + 
			'		<xsl:for-each select="@*">' + 
			'			<xsl:if test="name() != \'style\' and name() != \'class\' and name() != \'href\'">' + 
			'				<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>' + 
			'			</xsl:if>' + 
			'		</xsl:for-each>' + 
			'			<ins>' + 
			'				<xsl:attribute name="class">jstree-icon ' + 
			'					<xsl:if test="string-length(attribute::icon) > 0 and not(contains(@icon,\'/\'))"><xsl:value-of select="@icon" /></xsl:if>' + 
			'				</xsl:attribute>' + 
			'				<xsl:if test="string-length(attribute::icon) > 0 and contains(@icon,\'/\')"><xsl:attribute name="style">background:url(<xsl:value-of select="@icon" />) center center no-repeat;</xsl:attribute></xsl:if>' + 
			'				<xsl:text>&#xa0;</xsl:text>' + 
			'			</ins>' + 
			'			<xsl:copy-of select="./child::node()" />' + 
			'		</a>' + 
			'	</xsl:for-each>' + 
			'	<xsl:if test="$children">' + 
			'		<ul>' + 
			'		<xsl:for-each select="//item[@parent_id=$node/attribute::id]">' + 
			'			<xsl:call-template name="nodes">' + 
			'				<xsl:with-param name="node" select="." />' + 
			'				<xsl:with-param name="is_last" select="number(position() = last())" />' + 
			'			</xsl:call-template>' + 
			'		</xsl:for-each>' + 
			'		</ul>' + 
			'	</xsl:if>' + 
			'	</li>' + 
			'</xsl:template>' + 
			'</xsl:stylesheet>'
	},
	escape_xml = function(string) {
		return string
			.toString()
			.replace(/&/g, '&amp;')
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(/"/g, '&quot;')
			.replace(/'/g, '&apos;');
	};
	$.jstree.plugin("xml_data", {
		defaults : { 
			data : false,
			ajax : false,
			xsl : "flat",
			clean_node : false,
			correct_state : true,
			get_skip_empty : false,
			get_include_preamble : true
		},
		_fn : {
			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_xml(obj, function () { _this.__callback({ "obj" : _this._get_node(obj) }); s_call.call(this); }, e_call); },
			_is_loaded : function (obj) { 
				var s = this._get_settings().xml_data;
				obj = this._get_node(obj);
				return obj == -1 || !obj || (!s.ajax && !$.isFunction(s.data)) || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").size() > 0;
			},
			load_node_xml : function (obj, s_call, e_call) {
				var s = this.get_settings().xml_data,
					error_func = function () {},
					success_func = function () {};

				obj = this._get_node(obj);
				if(obj && obj !== -1) {
					if(obj.data("jstree_is_loading")) { return; }
					else { obj.data("jstree_is_loading",true); }
				}
				switch(!0) {
					case (!s.data && !s.ajax): throw "Neither data nor ajax settings supplied.";
					case ($.isFunction(s.data)):
						s.data.call(this, obj, $.proxy(function (d) {
							this.parse_xml(d, $.proxy(function (d) {
								if(d) {
									d = d.replace(/ ?xmlns="[^"]*"/ig, "");
									if(d.length > 10) {
										d = $(d);
										if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
										else { obj.children("a.jstree-loading").removeClass("jstree-loading"); obj.append(d); obj.removeData("jstree_is_loading"); }
										if(s.clean_node) { this.clean_node(obj); }
										if(s_call) { s_call.call(this); }
									}
									else {
										if(obj && obj !== -1) { 
											obj.children("a.jstree-loading").removeClass("jstree-loading");
											obj.removeData("jstree_is_loading");
											if(s.correct_state) { 
												this.correct_state(obj);
												if(s_call) { s_call.call(this); } 
											}
										}
										else {
											if(s.correct_state) { 
												this.get_container().children("ul").empty();
												if(s_call) { s_call.call(this); } 
											}
										}
									}
								}
							}, this));
						}, this));
						break;
					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
						if(!obj || obj == -1) {
							this.parse_xml(s.data, $.proxy(function (d) {
								if(d) {
									d = d.replace(/ ?xmlns="[^"]*"/ig, "");
									if(d.length > 10) {
										d = $(d);
										this.get_container().children("ul").empty().append(d.children());
										if(s.clean_node) { this.clean_node(obj); }
										if(s_call) { s_call.call(this); }
									}
								}
								else { 
									if(s.correct_state) { 
										this.get_container().children("ul").empty(); 
										if(s_call) { s_call.call(this); }
									}
								}
							}, this));
						}
						break;
					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
						error_func = function (x, t, e) {
							var ef = this.get_settings().xml_data.ajax.error; 
							if(ef) { ef.call(this, x, t, e); }
							if(obj !== -1 && obj.length) {
								obj.children("a.jstree-loading").removeClass("jstree-loading");
								obj.removeData("jstree_is_loading");
								if(t === "success" && s.correct_state) { this.correct_state(obj); }
							}
							else {
								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
							}
							if(e_call) { e_call.call(this); }
						};
						success_func = function (d, t, x) {
							d = x.responseText;
							var sf = this.get_settings().xml_data.ajax.success; 
							if(sf) { d = sf.call(this,d,t,x) || d; }
							if(d === "" || (d && d.toString && d.toString().replace(/^[\s\n]+$/,"") === "")) {
								return error_func.call(this, x, t, "");
							}
							this.parse_xml(d, $.proxy(function (d) {
								if(d) {
									d = d.replace(/ ?xmlns="[^"]*"/ig, "");
									if(d.length > 10) {
										d = $(d);
										if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }
										else { obj.children("a.jstree-loading").removeClass("jstree-loading"); obj.append(d); obj.removeData("jstree_is_loading"); }
										if(s.clean_node) { this.clean_node(obj); }
										if(s_call) { s_call.call(this); }
									}
									else {
										if(obj && obj !== -1) { 
											obj.children("a.jstree-loading").removeClass("jstree-loading");
											obj.removeData("jstree_is_loading");
											if(s.correct_state) { 
												this.correct_state(obj);
												if(s_call) { s_call.call(this); } 
											}
										}
										else {
											if(s.correct_state) { 
												this.get_container().children("ul").empty();
												if(s_call) { s_call.call(this); } 
											}
										}
									}
								}
							}, this));
						};
						s.ajax.context = this;
						s.ajax.error = error_func;
						s.ajax.success = success_func;
						if(!s.ajax.dataType) { s.ajax.dataType = "xml"; }
						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
						$.ajax(s.ajax);
						break;
				}
			},
			parse_xml : function (xml, callback) {
				var s = this._get_settings().xml_data;
				$.vakata.xslt(xml, xsl[s.xsl], callback);
			},
			get_xml : function (tp, obj, li_attr, a_attr, is_callback) {
				var result = "", 
					s = this._get_settings(), 
					_this = this,
					tmp1, tmp2, li, a, lang;
				if(!tp) { tp = "flat"; }
				if(!is_callback) { is_callback = 0; }
				obj = this._get_node(obj);
				if(!obj || obj === -1) { obj = this.get_container().find("> ul > li"); }
				li_attr = $.isArray(li_attr) ? li_attr : [ "id", "class" ];
				if(!is_callback && this.data.types && $.inArray(s.types.type_attr, li_attr) === -1) { li_attr.push(s.types.type_attr); }

				a_attr = $.isArray(a_attr) ? a_attr : [ ];

				if(!is_callback) { 
					if(s.xml_data.get_include_preamble) { 
						result += '<' + '?xml version="1.0" encoding="UTF-8"?' + '>'; 
					}
					result += "<root>"; 
				}
				obj.each(function () {
					result += "<item";
					li = $(this);
					$.each(li_attr, function (i, v) { 
						var t = li.attr(v);
						if(!s.xml_data.get_skip_empty || typeof t !== "undefined") {
							result += " " + v + "=\"" + escape_xml((" " + (t || "")).replace(/ jstree[^ ]*/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"")) + "\""; 
						}
					});
					if(li.hasClass("jstree-open")) { result += " state=\"open\""; }
					if(li.hasClass("jstree-closed")) { result += " state=\"closed\""; }
					if(tp === "flat") { result += " parent_id=\"" + escape_xml(is_callback) + "\""; }
					result += ">";
					result += "<content>";
					a = li.children("a");
					a.each(function () {
						tmp1 = $(this);
						lang = false;
						result += "<name";
						if($.inArray("languages", s.plugins) !== -1) {
							$.each(s.languages, function (k, z) {
								if(tmp1.hasClass(z)) { result += " lang=\"" + escape_xml(z) + "\""; lang = z; return false; }
							});
						}
						if(a_attr.length) { 
							$.each(a_attr, function (k, z) {
								var t = tmp1.attr(z);
								if(!s.xml_data.get_skip_empty || typeof t !== "undefined") {
									result += " " + z + "=\"" + escape_xml((" " + t || "").replace(/ jstree[^ ]*/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"")) + "\"";
								}
							});
						}
						if(tmp1.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/^\s+$/ig,"").length) {
							result += ' icon="' + escape_xml(tmp1.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,'').replace(/\s+$/ig," ").replace(/^ /,"").replace(/ $/,"")) + '"';
						}
						if(tmp1.children("ins").get(0).style.backgroundImage.length) {
							result += ' icon="' + escape_xml(tmp1.children("ins").get(0).style.backgroundImage.replace("url(","").replace(")","").replace(/'/ig,"").replace(/"/ig,"")) + '"';
						}
						result += ">";
						result += "<![CDATA[" + _this.get_text(tmp1, lang) + "]]>";
						result += "</name>";
					});
					result += "</content>";
					tmp2 = li[0].id || true;
					li = li.find("> ul > li");
					if(li.length) { tmp2 = _this.get_xml(tp, li, li_attr, a_attr, tmp2); }
					else { tmp2 = ""; }
					if(tp == "nest") { result += tmp2; }
					result += "</item>";
					if(tp == "flat") { result += tmp2; }
				});
				if(!is_callback) { result += "</root>"; }
				return result;
			}
		}
	});
})(jQuery);
//*/

/*
 * jsTree search plugin
 * Enables both sync and async search on the tree
 * DOES NOT WORK WITH JSON PROGRESSIVE RENDER
 */
(function ($) {
	$.expr[':'].jstree_contains = function(a,i,m){
		return (a.textContent || a.innerText || "").toLowerCase().indexOf(m[3].toLowerCase())>=0;
	};
	$.expr[':'].jstree_title_contains = function(a,i,m) {
		return (a.getAttribute("title") || "").toLowerCase().indexOf(m[3].toLowerCase())>=0;
	};
	$.jstree.plugin("search", {
		__init : function () {
			this.data.search.str = "";
			this.data.search.result = $();
			if(this._get_settings().search.show_only_matches) {
				this.get_container()
					.bind("search.jstree", function (e, data) {
						$(this).children("ul").find("li").hide().removeClass("jstree-last");
						data.rslt.nodes.parentsUntil(".jstree").andSelf().show()
							.filter("ul").each(function () { $(this).children("li:visible").eq(-1).addClass("jstree-last"); });
					})
					.bind("clear_search.jstree", function () {
						$(this).children("ul").find("li").css("display","").end().end().jstree("clean_node", -1);
					});
			}
		},
		defaults : {
			ajax : false,
			search_method : "jstree_contains", // for case insensitive - jstree_contains
			show_only_matches : false
		},
		_fn : {
			search : function (str, skip_async) {
				if($.trim(str) === "") { this.clear_search(); return; }
				var s = this.get_settings().search, 
					t = this,
					error_func = function () { },
					success_func = function () { };
				this.data.search.str = str;

				if(!skip_async && s.ajax !== false && this.get_container_ul().find("li.jstree-closed:not(:has(ul)):eq(0)").length > 0) {
					this.search.supress_callback = true;
					error_func = function () { };
					success_func = function (d, t, x) {
						var sf = this.get_settings().search.ajax.success; 
						if(sf) { d = sf.call(this,d,t,x) || d; }
						this.data.search.to_open = d;
						this._search_open();
					};
					s.ajax.context = this;
					s.ajax.error = error_func;
					s.ajax.success = success_func;
					if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, str); }
					if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, str); }
					if(!s.ajax.data) { s.ajax.data = { "search_string" : str }; }
					if(!s.ajax.dataType || /^json/.exec(s.ajax.dataType)) { s.ajax.dataType = "json"; }
					$.ajax(s.ajax);
					return;
				}
				if(this.data.search.result.length) { this.clear_search(); }
				this.data.search.result = this.get_container().find("a" + (this.data.languages ? "." + this.get_lang() : "" ) + ":" + (s.search_method) + "(" + this.data.search.str + ")");
				this.data.search.result.addClass("jstree-search").parent().parents(".jstree-closed").each(function () {
					t.open_node(this, false, true);
				});
				this.__callback({ nodes : this.data.search.result, str : str });
			},
			clear_search : function (str) {
				this.data.search.result.removeClass("jstree-search");
				this.__callback(this.data.search.result);
				this.data.search.result = $();
			},
			_search_open : function (is_callback) {
				var _this = this,
					done = true,
					current = [],
					remaining = [];
				if(this.data.search.to_open.length) {
					$.each(this.data.search.to_open, function (i, val) {
						if(val == "#") { return true; }
						if($(val).length && $(val).is(".jstree-closed")) { current.push(val); }
						else { remaining.push(val); }
					});
					if(current.length) {
						this.data.search.to_open = remaining;
						$.each(current, function (i, val) { 
							_this.open_node(val, function () { _this._search_open(true); }); 
						});
						done = false;
					}
				}
				if(done) { this.search(this.data.search.str, true); }
			}
		}
	});
})(jQuery);
//*/

/* 
 * jsTree contextmenu plugin
 */
(function ($) {
	$.vakata.context = {
		hide_on_mouseleave : false,

		cnt		: $("<div id='vakata-contextmenu' />"),
		vis		: false,
		tgt		: false,
		par		: false,
		func	: false,
		data	: false,
		rtl		: false,
		show	: function (s, t, x, y, d, p, rtl) {
			$.vakata.context.rtl = !!rtl;
			var html = $.vakata.context.parse(s), h, w;
			if(!html) { return; }
			$.vakata.context.vis = true;
			$.vakata.context.tgt = t;
			$.vakata.context.par = p || t || null;
			$.vakata.context.data = d || null;
			$.vakata.context.cnt
				.html(html)
				.css({ "visibility" : "hidden", "display" : "block", "left" : 0, "top" : 0 });

			if($.vakata.context.hide_on_mouseleave) {
				$.vakata.context.cnt
					.one("mouseleave", function(e) { $.vakata.context.hide(); });
			}

			h = $.vakata.context.cnt.height();
			w = $.vakata.context.cnt.width();
			if(x + w > $(document).width()) { 
				x = $(document).width() - (w + 5); 
				$.vakata.context.cnt.find("li > ul").addClass("right"); 
			}
			if(y + h > $(document).height()) { 
				y = y - (h + t[0].offsetHeight); 
				$.vakata.context.cnt.find("li > ul").addClass("bottom"); 
			}

			$.vakata.context.cnt
				.css({ "left" : x, "top" : y })
				.find("li:has(ul)")
					.bind("mouseenter", function (e) { 
						var w = $(document).width(),
							h = $(document).height(),
							ul = $(this).children("ul").show(); 
						if(w !== $(document).width()) { ul.toggleClass("right"); }
						if(h !== $(document).height()) { ul.toggleClass("bottom"); }
					})
					.bind("mouseleave", function (e) { 
						$(this).children("ul").hide(); 
					})
					.end()
				.css({ "visibility" : "visible" })
				.show();
			$(document).triggerHandler("context_show.vakata");
		},
		hide	: function () {
			$.vakata.context.vis = false;
			$.vakata.context.cnt.attr("class","").css({ "visibility" : "hidden" });
			$(document).triggerHandler("context_hide.vakata");
		},
		parse	: function (s, is_callback) {
			if(!s) { return false; }
			var str = "",
				tmp = false,
				was_sep = true;
			if(!is_callback) { $.vakata.context.func = {}; }
			str += "<ul>";
			$.each(s, function (i, val) {
				if(!val) { return true; }
				$.vakata.context.func[i] = val.action;
				if(!was_sep && val.separator_before) {
					str += "<li class='vakata-separator vakata-separator-before'></li>";
				}
				was_sep = false;
				str += "<li class='" + (val._class || "") + (val._disabled ? " jstree-contextmenu-disabled " : "") + "'><ins ";
				if(val.icon && val.icon.indexOf("/") === -1) { str += " class='" + val.icon + "' "; }
				if(val.icon && val.icon.indexOf("/") !== -1) { str += " style='background:url(" + val.icon + ") center center no-repeat;' "; }
				str += ">&#160;</ins><a href='#' rel='" + i + "'>";
				if(val.submenu) {
					str += "<span style='float:" + ($.vakata.context.rtl ? "left" : "right") + ";'>&raquo;</span>";
				}
				str += val.label + "</a>";
				if(val.submenu) {
					tmp = $.vakata.context.parse(val.submenu, true);
					if(tmp) { str += tmp; }
				}
				str += "</li>";
				if(val.separator_after) {
					str += "<li class='vakata-separator vakata-separator-after'></li>";
					was_sep = true;
				}
			});
			str = str.replace(/<li class\='vakata-separator vakata-separator-after'\><\/li\>$/,"");
			str += "</ul>";
			$(document).triggerHandler("context_parse.vakata");
			return str.length > 10 ? str : false;
		},
		exec	: function (i) {
			if($.isFunction($.vakata.context.func[i])) {
				// if is string - eval and call it!
				$.vakata.context.func[i].call($.vakata.context.data, $.vakata.context.par);
				return true;
			}
			else { return false; }
		}
	};
	$(function () {
		var css_string = '' + 
			'#vakata-contextmenu { display:block; visibility:hidden; left:0; top:-200px; position:absolute; margin:0; padding:0; min-width:180px; background:#ebebeb; border:1px solid silver; z-index:10000; *width:180px; } ' + 
			'#vakata-contextmenu ul { min-width:180px; *width:180px; } ' + 
			'#vakata-contextmenu ul, #vakata-contextmenu li { margin:0; padding:0; list-style-type:none; display:block; } ' + 
			'#vakata-contextmenu li { line-height:20px; min-height:20px; position:relative; padding:0px; } ' + 
			'#vakata-contextmenu li a { padding:1px 6px; line-height:17px; display:block; text-decoration:none; margin:1px 1px 0 1px; } ' + 
			'#vakata-contextmenu li ins { float:left; width:16px; height:16px; text-decoration:none; margin-right:2px; } ' + 
			'#vakata-contextmenu li a:hover, #vakata-contextmenu li.vakata-hover > a { background:gray; color:white; } ' + 
			'#vakata-contextmenu li ul { display:none; position:absolute; top:-2px; left:100%; background:#ebebeb; border:1px solid gray; } ' + 
			'#vakata-contextmenu .right { right:100%; left:auto; } ' + 
			'#vakata-contextmenu .bottom { bottom:-1px; top:auto; } ' + 
			'#vakata-contextmenu li.vakata-separator { min-height:0; height:1px; line-height:1px; font-size:1px; overflow:hidden; margin:0 2px; background:silver; /* border-top:1px solid #fefefe; */ padding:0; } ';
		$.vakata.css.add_sheet({ str : css_string, title : "vakata" });
		$.vakata.context.cnt
			.delegate("a","click", function (e) { e.preventDefault(); })
			.delegate("a","mouseup", function (e) {
				if(!$(this).parent().hasClass("jstree-contextmenu-disabled") && $.vakata.context.exec($(this).attr("rel"))) {
					$.vakata.context.hide();
				}
				else { $(this).blur(); }
			})
			.delegate("a","mouseover", function () {
				$.vakata.context.cnt.find(".vakata-hover").removeClass("vakata-hover");
			})
			.appendTo("body");
		$(document).bind("mousedown", function (e) { if($.vakata.context.vis && !$.contains($.vakata.context.cnt[0], e.target)) { $.vakata.context.hide(); } });
		if(typeof $.hotkeys !== "undefined") {
			$(document)
				.bind("keydown", "up", function (e) { 
					if($.vakata.context.vis) { 
						var o = $.vakata.context.cnt.find("ul:visible").last().children(".vakata-hover").removeClass("vakata-hover").prevAll("li:not(.vakata-separator)").first();
						if(!o.length) { o = $.vakata.context.cnt.find("ul:visible").last().children("li:not(.vakata-separator)").last(); }
						o.addClass("vakata-hover");
						e.stopImmediatePropagation(); 
						e.preventDefault();
					} 
				})
				.bind("keydown", "down", function (e) { 
					if($.vakata.context.vis) { 
						var o = $.vakata.context.cnt.find("ul:visible").last().children(".vakata-hover").removeClass("vakata-hover").nextAll("li:not(.vakata-separator)").first();
						if(!o.length) { o = $.vakata.context.cnt.find("ul:visible").last().children("li:not(.vakata-separator)").first(); }
						o.addClass("vakata-hover");
						e.stopImmediatePropagation(); 
						e.preventDefault();
					} 
				})
				.bind("keydown", "right", function (e) { 
					if($.vakata.context.vis) { 
						$.vakata.context.cnt.find(".vakata-hover").children("ul").show().children("li:not(.vakata-separator)").removeClass("vakata-hover").first().addClass("vakata-hover");
						e.stopImmediatePropagation(); 
						e.preventDefault();
					} 
				})
				.bind("keydown", "left", function (e) { 
					if($.vakata.context.vis) { 
						$.vakata.context.cnt.find(".vakata-hover").children("ul").hide().children(".vakata-separator").removeClass("vakata-hover");
						e.stopImmediatePropagation(); 
						e.preventDefault();
					} 
				})
				.bind("keydown", "esc", function (e) { 
					$.vakata.context.hide(); 
					e.preventDefault();
				})
				.bind("keydown", "space", function (e) { 
					$.vakata.context.cnt.find(".vakata-hover").last().children("a").click();
					e.preventDefault();
				});
		}
	});

	$.jstree.plugin("contextmenu", {
		__init : function () {
			this.get_container()
				.delegate("a", "contextmenu.jstree", $.proxy(function (e) {
						e.preventDefault();
						if(!$(e.currentTarget).hasClass("jstree-loading")) {
							this.show_contextmenu(e.currentTarget, e.pageX, e.pageY);
						}
					}, this))
				.delegate("a", "click.jstree", $.proxy(function (e) {
						if(this.data.contextmenu) {
							$.vakata.context.hide();
						}
					}, this))
				.bind("destroy.jstree", $.proxy(function () {
						// TODO: move this to descruct method
						if(this.data.contextmenu) {
							$.vakata.context.hide();
						}
					}, this));
			$(document).bind("context_hide.vakata", $.proxy(function () { this.data.contextmenu = false; }, this));
		},
		__destroy: function() {
			// unbind global event handlers when last instance is removed
			// (no access to private 'instances' variable from here)
			if($('.jstree').length <= 1) {
				$(document).unbind("context_hide.vakata");	
			}
		},
		defaults : { 
			select_node : false, // requires UI plugin
			show_at_node : true,
			items : { // Could be a function that should return an object like this one
				"create" : {
					"separator_before"	: false,
					"separator_after"	: true,
					"label"				: "Create",
					"action"			: function (obj) { this.create(obj); }
				},
				"rename" : {
					"separator_before"	: false,
					"separator_after"	: false,
					"label"				: "Rename",
					"action"			: function (obj) { this.rename(obj); }
				},
				"remove" : {
					"separator_before"	: false,
					"icon"				: false,
					"separator_after"	: false,
					"label"				: "Delete",
					"action"			: function (obj) { if(this.is_selected(obj)) { this.remove(); } else { this.remove(obj); } }
				},
				"ccp" : {
					"separator_before"	: true,
					"icon"				: false,
					"separator_after"	: false,
					"label"				: "Edit",
					"action"			: false,
					"submenu" : { 
						"cut" : {
							"separator_before"	: false,
							"separator_after"	: false,
							"label"				: "Cut",
							"action"			: function (obj) { this.cut(obj); }
						},
						"copy" : {
							"separator_before"	: false,
							"icon"				: false,
							"separator_after"	: false,
							"label"				: "Copy",
							"action"			: function (obj) { this.copy(obj); }
						},
						"paste" : {
							"separator_before"	: false,
							"icon"				: false,
							"separator_after"	: false,
							"label"				: "Paste",
							"action"			: function (obj) { this.paste(obj); }
						}
					}
				}
			}
		},
		_fn : {
			show_contextmenu : function (obj, x, y) {
				obj = this._get_node(obj);
				var s = this.get_settings().contextmenu,
					a = obj.children("a:visible:eq(0)"),
					o = false,
					i = false;
				if(s.select_node && this.data.ui && !this.is_selected(obj)) {
					this.deselect_all();
					this.select_node(obj, true);
				}
				if(s.show_at_node || typeof x === "undefined" || typeof y === "undefined") {
					o = a.offset();
					x = o.left;
					y = o.top + this.data.core.li_height;
				}
				i = obj.data("jstree") && obj.data("jstree").contextmenu ? obj.data("jstree").contextmenu : s.items;
				if($.isFunction(i)) { i = i.call(this, obj); }
				this.data.contextmenu = true;
				$.vakata.context.show(i, a, x, y, this, obj, this._get_settings().core.rtl);
				if(this.data.themes) { $.vakata.context.cnt.attr("class", "jstree-" + this.data.themes.theme + "-context"); }
			}
		}
	});
})(jQuery);
//*/

/* 
 * jsTree types plugin
 * Adds support types of nodes
 * You can set an attribute on each li node, that represents its type.
 * According to the type setting the node may get custom icon/validation rules
 */
(function ($) {
	$.jstree.plugin("types", {
		__init : function () {
			var s = this._get_settings().types;
			this.data.types.attach_to = [];
			this.get_container()
				.bind("init.jstree", $.proxy(function () { 
						var types = s.types, 
							attr  = s.type_attr, 
							icons_css = "", 
							_this = this;

						$.each(types, function (i, tp) {
							$.each(tp, function (k, v) { 
								if(!/^(max_depth|max_children|icon|valid_children)$/.test(k)) { _this.data.types.attach_to.push(k); }
							});
							if(!tp.icon) { return true; }
							if( tp.icon.image || tp.icon.position) {
								if(i == "default")	{ icons_css += '.jstree-' + _this.get_index() + ' a > .jstree-icon { '; }
								else				{ icons_css += '.jstree-' + _this.get_index() + ' li[' + attr + '="' + i + '"] > a > .jstree-icon { '; }
								if(tp.icon.image)	{ icons_css += ' background-image:url(' + tp.icon.image + '); '; }
								if(tp.icon.position){ icons_css += ' background-position:' + tp.icon.position + '; '; }
								else				{ icons_css += ' background-position:0 0; '; }
								icons_css += '} ';
							}
						});
						if(icons_css !== "") { $.vakata.css.add_sheet({ 'str' : icons_css, title : "jstree-types" }); }
					}, this))
				.bind("before.jstree", $.proxy(function (e, data) { 
						var s, t, 
							o = this._get_settings().types.use_data ? this._get_node(data.args[0]) : false, 
							d = o && o !== -1 && o.length ? o.data("jstree") : false;
						if(d && d.types && d.types[data.func] === false) { e.stopImmediatePropagation(); return false; }
						if($.inArray(data.func, this.data.types.attach_to) !== -1) {
							if(!data.args[0] || (!data.args[0].tagName && !data.args[0].jquery)) { return; }
							s = this._get_settings().types.types;
							t = this._get_type(data.args[0]);
							if(
								( 
									(s[t] && typeof s[t][data.func] !== "undefined") || 
									(s["default"] && typeof s["default"][data.func] !== "undefined") 
								) && this._check(data.func, data.args[0]) === false
							) {
								e.stopImmediatePropagation();
								return false;
							}
						}
					}, this));
			if(is_ie6) {
				this.get_container()
					.bind("load_node.jstree set_type.jstree", $.proxy(function (e, data) {
							var r = data && data.rslt && data.rslt.obj && data.rslt.obj !== -1 ? this._get_node(data.rslt.obj).parent() : this.get_container_ul(),
								c = false,
								s = this._get_settings().types;
							$.each(s.types, function (i, tp) {
								if(tp.icon && (tp.icon.image || tp.icon.position)) {
									c = i === "default" ? r.find("li > a > .jstree-icon") : r.find("li[" + s.type_attr + "='" + i + "'] > a > .jstree-icon");
									if(tp.icon.image) { c.css("backgroundImage","url(" + tp.icon.image + ")"); }
									c.css("backgroundPosition", tp.icon.position || "0 0");
								}
							});
						}, this));
			}
		},
		defaults : {
			// defines maximum number of root nodes (-1 means unlimited, -2 means disable max_children checking)
			max_children		: -1,
			// defines the maximum depth of the tree (-1 means unlimited, -2 means disable max_depth checking)
			max_depth			: -1,
			// defines valid node types for the root nodes
			valid_children		: "all",

			// whether to use $.data
			use_data : false, 
			// where is the type stores (the rel attribute of the LI element)
			type_attr : "rel",
			// a list of types
			types : {
				// the default type
				"default" : {
					"max_children"	: -1,
					"max_depth"		: -1,
					"valid_children": "all"

					// Bound functions - you can bind any other function here (using boolean or function)
					//"select_node"	: true
				}
			}
		},
		_fn : {
			_types_notify : function (n, data) {
				if(data.type && this._get_settings().types.use_data) {
					this.set_type(data.type, n);
				}
			},
			_get_type : function (obj) {
				obj = this._get_node(obj);
				return (!obj || !obj.length) ? false : obj.attr(this._get_settings().types.type_attr) || "default";
			},
			set_type : function (str, obj) {
				obj = this._get_node(obj);
				var ret = (!obj.length || !str) ? false : obj.attr(this._get_settings().types.type_attr, str);
				if(ret) { this.__callback({ obj : obj, type : str}); }
				return ret;
			},
			_check : function (rule, obj, opts) {
				obj = this._get_node(obj);
				var v = false, t = this._get_type(obj), d = 0, _this = this, s = this._get_settings().types, data = false;
				if(obj === -1) { 
					if(!!s[rule]) { v = s[rule]; }
					else { return; }
				}
				else {
					if(t === false) { return; }
					data = s.use_data ? obj.data("jstree") : false;
					if(data && data.types && typeof data.types[rule] !== "undefined") { v = data.types[rule]; }
					else if(!!s.types[t] && typeof s.types[t][rule] !== "undefined") { v = s.types[t][rule]; }
					else if(!!s.types["default"] && typeof s.types["default"][rule] !== "undefined") { v = s.types["default"][rule]; }
				}
				if($.isFunction(v)) { v = v.call(this, obj); }
				if(rule === "max_depth" && obj !== -1 && opts !== false && s.max_depth !== -2 && v !== 0) {
					// also include the node itself - otherwise if root node it is not checked
					obj.children("a:eq(0)").parentsUntil(".jstree","li").each(function (i) {
						// check if current depth already exceeds global tree depth
						if(s.max_depth !== -1 && s.max_depth - (i + 1) <= 0) { v = 0; return false; }
						d = (i === 0) ? v : _this._check(rule, this, false);
						// check if current node max depth is already matched or exceeded
						if(d !== -1 && d - (i + 1) <= 0) { v = 0; return false; }
						// otherwise - set the max depth to the current value minus current depth
						if(d >= 0 && (d - (i + 1) < v || v < 0) ) { v = d - (i + 1); }
						// if the global tree depth exists and it minus the nodes calculated so far is less than `v` or `v` is unlimited
						if(s.max_depth >= 0 && (s.max_depth - (i + 1) < v || v < 0) ) { v = s.max_depth - (i + 1); }
					});
				}
				return v;
			},
			check_move : function () {
				if(!this.__call_old()) { return false; }
				var m  = this._get_move(),
					s  = m.rt._get_settings().types,
					mc = m.rt._check("max_children", m.cr),
					md = m.rt._check("max_depth", m.cr),
					vc = m.rt._check("valid_children", m.cr),
					ch = 0, d = 1, t;

				if(vc === "none") { return false; } 
				if($.isArray(vc) && m.ot && m.ot._get_type) {
					m.o.each(function () {
						if($.inArray(m.ot._get_type(this), vc) === -1) { d = false; return false; }
					});
					if(d === false) { return false; }
				}
				if(s.max_children !== -2 && mc !== -1) {
					ch = m.cr === -1 ? this.get_container().find("> ul > li").not(m.o).length : m.cr.find("> ul > li").not(m.o).length;
					if(ch + m.o.length > mc) { return false; }
				}
				if(s.max_depth !== -2 && md !== -1) {
					d = 0;
					if(md === 0) { return false; }
					if(typeof m.o.d === "undefined") {
						// TODO: deal with progressive rendering and async when checking max_depth (how to know the depth of the moved node)
						t = m.o;
						while(t.length > 0) {
							t = t.find("> ul > li");
							d ++;
						}
						m.o.d = d;
					}
					if(md - m.o.d < 0) { return false; }
				}
				return true;
			},
			create_node : function (obj, position, js, callback, is_loaded, skip_check) {
				if(!skip_check && (is_loaded || this._is_loaded(obj))) {
					var p  = (typeof position == "string" && position.match(/^before|after$/i) && obj !== -1) ? this._get_parent(obj) : this._get_node(obj),
						s  = this._get_settings().types,
						mc = this._check("max_children", p),
						md = this._check("max_depth", p),
						vc = this._check("valid_children", p),
						ch;
					if(typeof js === "string") { js = { data : js }; }
					if(!js) { js = {}; }
					if(vc === "none") { return false; } 
					if($.isArray(vc)) {
						if(!js.attr || !js.attr[s.type_attr]) { 
							if(!js.attr) { js.attr = {}; }
							js.attr[s.type_attr] = vc[0]; 
						}
						else {
							if($.inArray(js.attr[s.type_attr], vc) === -1) { return false; }
						}
					}
					if(s.max_children !== -2 && mc !== -1) {
						ch = p === -1 ? this.get_container().find("> ul > li").length : p.find("> ul > li").length;
						if(ch + 1 > mc) { return false; }
					}
					if(s.max_depth !== -2 && md !== -1 && (md - 1) < 0) { return false; }
				}
				return this.__call_old(true, obj, position, js, callback, is_loaded, skip_check);
			}
		}
	});
})(jQuery);
//*/

/* 
 * jsTree HTML plugin
 * The HTML data store. Datastores are build by replacing the `load_node` and `_is_loaded` functions.
 */
(function ($) {
	$.jstree.plugin("html_data", {
		__init : function () { 
			// this used to use html() and clean the whitespace, but this way any attached data was lost
			this.data.html_data.original_container_html = this.get_container().find(" > ul > li").clone(true);
			// remove white space from LI node - otherwise nodes appear a bit to the right
			this.data.html_data.original_container_html.find("li").andSelf().contents().filter(function() { return this.nodeType == 3; }).remove();
		},
		defaults : { 
			data : false,
			ajax : false,
			correct_state : true
		},
		_fn : {
			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_html(obj, function () { _this.__callback({ "obj" : _this._get_node(obj) }); s_call.call(this); }, e_call); },
			_is_loaded : function (obj) { 
				obj = this._get_node(obj); 
				return obj == -1 || !obj || (!this._get_settings().html_data.ajax && !$.isFunction(this._get_settings().html_data.data)) || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").size() > 0;
			},
			load_node_html : function (obj, s_call, e_call) {
				var d,
					s = this.get_settings().html_data,
					error_func = function () {},
					success_func = function () {};
				obj = this._get_node(obj);
				if(obj && obj !== -1) {
					if(obj.data("jstree_is_loading")) { return; }
					else { obj.data("jstree_is_loading",true); }
				}
				switch(!0) {
					case ($.isFunction(s.data)):
						s.data.call(this, obj, $.proxy(function (d) {
							if(d && d !== "" && d.toString && d.toString().replace(/^[\s\n]+$/,"") !== "") {
								d = $(d);
								if(!d.is("ul")) { d = $("<ul />").append(d); }
								if(obj == -1 || !obj) { this.get_container().children("ul").empty().append(d.children()).find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); }
								else { obj.children("a.jstree-loading").removeClass("jstree-loading"); obj.append(d).children("ul").find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); obj.removeData("jstree_is_loading"); }
								this.clean_node(obj);
								if(s_call) { s_call.call(this); }
							}
							else {
								if(obj && obj !== -1) {
									obj.children("a.jstree-loading").removeClass("jstree-loading");
									obj.removeData("jstree_is_loading");
									if(s.correct_state) { 
										this.correct_state(obj);
										if(s_call) { s_call.call(this); } 
									}
								}
								else {
									if(s.correct_state) { 
										this.get_container().children("ul").empty();
										if(s_call) { s_call.call(this); } 
									}
								}
							}
						}, this));
						break;
					case (!s.data && !s.ajax):
						if(!obj || obj == -1) {
							this.get_container()
								.children("ul").empty()
								.append(this.data.html_data.original_container_html)
								.find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end()
								.filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon");
							this.clean_node();
						}
						if(s_call) { s_call.call(this); }
						break;
					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):
						if(!obj || obj == -1) {
							d = $(s.data);
							if(!d.is("ul")) { d = $("<ul />").append(d); }
							this.get_container()
								.children("ul").empty().append(d.children())
								.find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end()
								.filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon");
							this.clean_node();
						}
						if(s_call) { s_call.call(this); }
						break;
					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):
						obj = this._get_node(obj);
						error_func = function (x, t, e) {
							var ef = this.get_settings().html_data.ajax.error; 
							if(ef) { ef.call(this, x, t, e); }
							if(obj != -1 && obj.length) {
								obj.children("a.jstree-loading").removeClass("jstree-loading");
								obj.removeData("jstree_is_loading");
								if(t === "success" && s.correct_state) { this.correct_state(obj); }
							}
							else {
								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }
							}
							if(e_call) { e_call.call(this); }
						};
						success_func = function (d, t, x) {
							var sf = this.get_settings().html_data.ajax.success; 
							if(sf) { d = sf.call(this,d,t,x) || d; }
							if(d === "" || (d && d.toString && d.toString().replace(/^[\s\n]+$/,"") === "")) {
								return error_func.call(this, x, t, "");
							}
							if(d) {
								d = $(d);
								if(!d.is("ul")) { d = $("<ul />").append(d); }
								if(obj == -1 || !obj) { this.get_container().children("ul").empty().append(d.children()).find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); }
								else { obj.children("a.jstree-loading").removeClass("jstree-loading"); obj.append(d).children("ul").find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class='jstree-icon'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); obj.removeData("jstree_is_loading"); }
								this.clean_node(obj);
								if(s_call) { s_call.call(this); }
							}
							else {
								if(obj && obj !== -1) {
									obj.children("a.jstree-loading").removeClass("jstree-loading");
									obj.removeData("jstree_is_loading");
									if(s.correct_state) { 
										this.correct_state(obj);
										if(s_call) { s_call.call(this); } 
									}
								}
								else {
									if(s.correct_state) { 
										this.get_container().children("ul").empty();
										if(s_call) { s_call.call(this); } 
									}
								}
							}
						};
						s.ajax.context = this;
						s.ajax.error = error_func;
						s.ajax.success = success_func;
						if(!s.ajax.dataType) { s.ajax.dataType = "html"; }
						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }
						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }
						$.ajax(s.ajax);
						break;
				}
			}
		}
	});
	// include the HTML data plugin by default
	$.jstree.defaults.plugins.push("html_data");
})(jQuery);
//*/

/* 
 * jsTree themeroller plugin
 * Adds support for jQuery UI themes. Include this at the end of your plugins list, also make sure "themes" is not included.
 */
(function ($) {
	$.jstree.plugin("themeroller", {
		__init : function () {
			var s = this._get_settings().themeroller;
			this.get_container()
				.addClass("ui-widget-content")
				.addClass("jstree-themeroller")
				.delegate("a","mouseenter.jstree", function (e) {
					if(!$(e.currentTarget).hasClass("jstree-loading")) {
						$(this).addClass(s.item_h);
					}
				})
				.delegate("a","mouseleave.jstree", function () {
					$(this).removeClass(s.item_h);
				})
				.bind("init.jstree", $.proxy(function (e, data) { 
						data.inst.get_container().find("> ul > li > .jstree-loading > ins").addClass("ui-icon-refresh");
						this._themeroller(data.inst.get_container().find("> ul > li"));
					}, this))
				.bind("open_node.jstree create_node.jstree", $.proxy(function (e, data) { 
						this._themeroller(data.rslt.obj);
					}, this))
				.bind("loaded.jstree refresh.jstree", $.proxy(function (e) {
						this._themeroller();
					}, this))
				.bind("close_node.jstree", $.proxy(function (e, data) {
						this._themeroller(data.rslt.obj);
					}, this))
				.bind("delete_node.jstree", $.proxy(function (e, data) {
						this._themeroller(data.rslt.parent);
					}, this))
				.bind("correct_state.jstree", $.proxy(function (e, data) {
						data.rslt.obj
							.children("ins.jstree-icon").removeClass(s.opened + " " + s.closed + " ui-icon").end()
							.find("> a > ins.ui-icon")
								.filter(function() { 
									return this.className.toString()
										.replace(s.item_clsd,"").replace(s.item_open,"").replace(s.item_leaf,"")
										.indexOf("ui-icon-") === -1; 
								}).removeClass(s.item_open + " " + s.item_clsd).addClass(s.item_leaf || "jstree-no-icon");
					}, this))
				.bind("select_node.jstree", $.proxy(function (e, data) {
						data.rslt.obj.children("a").addClass(s.item_a);
					}, this))
				.bind("deselect_node.jstree deselect_all.jstree", $.proxy(function (e, data) {
						this.get_container()
							.find("a." + s.item_a).removeClass(s.item_a).end()
							.find("a.jstree-clicked").addClass(s.item_a);
					}, this))
				.bind("dehover_node.jstree", $.proxy(function (e, data) {
						data.rslt.obj.children("a").removeClass(s.item_h);
					}, this))
				.bind("hover_node.jstree", $.proxy(function (e, data) {
						this.get_container()
							.find("a." + s.item_h).not(data.rslt.obj).removeClass(s.item_h);
						data.rslt.obj.children("a").addClass(s.item_h);
					}, this))
				.bind("move_node.jstree", $.proxy(function (e, data) {
						this._themeroller(data.rslt.o);
						this._themeroller(data.rslt.op);
					}, this));
		},
		__destroy : function () {
			var s = this._get_settings().themeroller,
				c = [ "ui-icon" ];
			$.each(s, function (i, v) {
				v = v.split(" ");
				if(v.length) { c = c.concat(v); }
			});
			this.get_container()
				.removeClass("ui-widget-content")
				.find("." + c.join(", .")).removeClass(c.join(" "));
		},
		_fn : {
			_themeroller : function (obj) {
				var s = this._get_settings().themeroller;
				obj = (!obj || obj == -1) ? this.get_container_ul() : this._get_node(obj);
				obj = (!obj || obj == -1) ? this.get_container_ul() : obj.parent();
				obj
					.find("li.jstree-closed")
						.children("ins.jstree-icon").removeClass(s.opened).addClass("ui-icon " + s.closed).end()
						.children("a").addClass(s.item)
							.children("ins.jstree-icon").addClass("ui-icon")
								.filter(function() { 
									return this.className.toString()
										.replace(s.item_clsd,"").replace(s.item_open,"").replace(s.item_leaf,"")
										.indexOf("ui-icon-") === -1; 
								}).removeClass(s.item_leaf + " " + s.item_open).addClass(s.item_clsd || "jstree-no-icon")
								.end()
							.end()
						.end()
					.end()
					.find("li.jstree-open")
						.children("ins.jstree-icon").removeClass(s.closed).addClass("ui-icon " + s.opened).end()
						.children("a").addClass(s.item)
							.children("ins.jstree-icon").addClass("ui-icon")
								.filter(function() { 
									return this.className.toString()
										.replace(s.item_clsd,"").replace(s.item_open,"").replace(s.item_leaf,"")
										.indexOf("ui-icon-") === -1; 
								}).removeClass(s.item_leaf + " " + s.item_clsd).addClass(s.item_open || "jstree-no-icon")
								.end()
							.end()
						.end()
					.end()
					.find("li.jstree-leaf")
						.children("ins.jstree-icon").removeClass(s.closed + " ui-icon " + s.opened).end()
						.children("a").addClass(s.item)
							.children("ins.jstree-icon").addClass("ui-icon")
								.filter(function() { 
									return this.className.toString()
										.replace(s.item_clsd,"").replace(s.item_open,"").replace(s.item_leaf,"")
										.indexOf("ui-icon-") === -1; 
								}).removeClass(s.item_clsd + " " + s.item_open).addClass(s.item_leaf || "jstree-no-icon");
			}
		},
		defaults : {
			"opened"	: "ui-icon-triangle-1-se",
			"closed"	: "ui-icon-triangle-1-e",
			"item"		: "ui-state-default",
			"item_h"	: "ui-state-hover",
			"item_a"	: "ui-state-active",
			"item_open"	: "ui-icon-folder-open",
			"item_clsd"	: "ui-icon-folder-collapsed",
			"item_leaf"	: "ui-icon-document"
		}
	});
	$(function() {
		var css_string = '' + 
			'.jstree-themeroller .ui-icon { overflow:visible; } ' + 
			'.jstree-themeroller a { padding:0 2px; } ' + 
			'.jstree-themeroller .jstree-no-icon { display:none; }';
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
	});
})(jQuery);
//*/

/* 
 * jsTree unique plugin
 * Forces different names amongst siblings (still a bit experimental)
 * NOTE: does not check language versions (it will not be possible to have nodes with the same title, even in different languages)
 */
(function ($) {
	$.jstree.plugin("unique", {
		__init : function () {
			this.get_container()
				.bind("before.jstree", $.proxy(function (e, data) { 
						var nms = [], res = true, p, t;
						if(data.func == "move_node") {
							// obj, ref, position, is_copy, is_prepared, skip_check
							if(data.args[4] === true) {
								if(data.args[0].o && data.args[0].o.length) {
									data.args[0].o.children("a").each(function () { nms.push($(this).text().replace(/^\s+/g,"")); });
									res = this._check_unique(nms, data.args[0].np.find("> ul > li").not(data.args[0].o), "move_node");
								}
							}
						}
						if(data.func == "create_node") {
							// obj, position, js, callback, is_loaded
							if(data.args[4] || this._is_loaded(data.args[0])) {
								p = this._get_node(data.args[0]);
								if(data.args[1] && (data.args[1] === "before" || data.args[1] === "after")) {
									p = this._get_parent(data.args[0]);
									if(!p || p === -1) { p = this.get_container(); }
								}
								if(typeof data.args[2] === "string") { nms.push(data.args[2]); }
								else if(!data.args[2] || !data.args[2].data) { nms.push(this._get_string("new_node")); }
								else { nms.push(data.args[2].data); }
								res = this._check_unique(nms, p.find("> ul > li"), "create_node");
							}
						}
						if(data.func == "rename_node") {
							// obj, val
							nms.push(data.args[1]);
							t = this._get_node(data.args[0]);
							p = this._get_parent(t);
							if(!p || p === -1) { p = this.get_container(); }
							res = this._check_unique(nms, p.find("> ul > li").not(t), "rename_node");
						}
						if(!res) {
							e.stopPropagation();
							return false;
						}
					}, this));
		},
		defaults : { 
			error_callback : $.noop
		},
		_fn : { 
			_check_unique : function (nms, p, func) {
				var cnms = [], ok = true;
				p.children("a").each(function () { cnms.push($(this).text().replace(/^\s+/g,"")); });
				if(!cnms.length || !nms.length) { return true; }
				$.each(nms, function (i, v) {
					if($.inArray(v, cnms) !== -1) {
						ok = false;
						return false;
					}
				});
				if(!ok) {
					this._get_settings().unique.error_callback.call(null, nms, p, func);
				}
				return ok;
			},
			check_move : function () {
				if(!this.__call_old()) { return false; }
				var p = this._get_move(), nms = [];
				if(p.o && p.o.length) {
					p.o.children("a").each(function () { nms.push($(this).text().replace(/^\s+/g,"")); });
					return this._check_unique(nms, p.np.find("> ul > li").not(p.o), "check_move");
				}
				return true;
			}
		}
	});
})(jQuery);
//*/

/*
 * jsTree wholerow plugin
 * Makes select and hover work on the entire width of the node
 * MAY BE HEAVY IN LARGE DOM
 */
(function ($) {
	$.jstree.plugin("wholerow", {
		__init : function () {
			if(!this.data.ui) { throw "jsTree wholerow: jsTree UI plugin not included."; }
			this.data.wholerow.html = false;
			this.data.wholerow.to = false;
			this.get_container()
				.bind("init.jstree", $.proxy(function (e, data) { 
						this._get_settings().core.animation = 0;
					}, this))
				.bind("open_node.jstree create_node.jstree clean_node.jstree loaded.jstree", $.proxy(function (e, data) { 
						this._prepare_wholerow_span( data && data.rslt && data.rslt.obj ? data.rslt.obj : -1 );
					}, this))
				.bind("search.jstree clear_search.jstree reopen.jstree after_open.jstree after_close.jstree create_node.jstree delete_node.jstree clean_node.jstree", $.proxy(function (e, data) { 
						if(this.data.to) { clearTimeout(this.data.to); }
						this.data.to = setTimeout( (function (t, o) { return function() { t._prepare_wholerow_ul(o); }; })(this,  data && data.rslt && data.rslt.obj ? data.rslt.obj : -1), 0);
					}, this))
				.bind("deselect_all.jstree", $.proxy(function (e, data) { 
						this.get_container().find(" > .jstree-wholerow .jstree-clicked").removeClass("jstree-clicked " + (this.data.themeroller ? this._get_settings().themeroller.item_a : "" ));
					}, this))
				.bind("select_node.jstree deselect_node.jstree ", $.proxy(function (e, data) { 
						data.rslt.obj.each(function () { 
							var ref = data.inst.get_container().find(" > .jstree-wholerow li:visible:eq(" + ( parseInt((($(this).offset().top - data.inst.get_container().offset().top + data.inst.get_container()[0].scrollTop) / data.inst.data.core.li_height),10)) + ")");
							// ref.children("a")[e.type === "select_node" ? "addClass" : "removeClass"]("jstree-clicked");
							ref.children("a").attr("class",data.rslt.obj.children("a").attr("class"));
						});
					}, this))
				.bind("hover_node.jstree dehover_node.jstree", $.proxy(function (e, data) { 
						this.get_container().find(" > .jstree-wholerow .jstree-hovered").removeClass("jstree-hovered " + (this.data.themeroller ? this._get_settings().themeroller.item_h : "" ));
						if(e.type === "hover_node") {
							var ref = this.get_container().find(" > .jstree-wholerow li:visible:eq(" + ( parseInt(((data.rslt.obj.offset().top - this.get_container().offset().top + this.get_container()[0].scrollTop) / this.data.core.li_height),10)) + ")");
							// ref.children("a").addClass("jstree-hovered");
							ref.children("a").attr("class",data.rslt.obj.children(".jstree-hovered").attr("class"));
						}
					}, this))
				.delegate(".jstree-wholerow-span, ins.jstree-icon, li", "click.jstree", function (e) {
						var n = $(e.currentTarget);
						if(e.target.tagName === "A" || (e.target.tagName === "INS" && n.closest("li").is(".jstree-open, .jstree-closed"))) { return; }
						n.closest("li").children("a:visible:eq(0)").click();
						e.stopImmediatePropagation();
					})
				.delegate("li", "mouseover.jstree", $.proxy(function (e) {
						e.stopImmediatePropagation();
						if($(e.currentTarget).children(".jstree-hovered, .jstree-clicked").length) { return false; }
						this.hover_node(e.currentTarget);
						return false;
					}, this))
				.delegate("li", "mouseleave.jstree", $.proxy(function (e) {
						if($(e.currentTarget).children("a").hasClass("jstree-hovered").length) { return; }
						this.dehover_node(e.currentTarget);
					}, this));
			if(is_ie7 || is_ie6) {
				$.vakata.css.add_sheet({ str : ".jstree-" + this.get_index() + " { position:relative; } ", title : "jstree" });
			}
		},
		defaults : {
		},
		__destroy : function () {
			this.get_container().children(".jstree-wholerow").remove();
			this.get_container().find(".jstree-wholerow-span").remove();
		},
		_fn : {
			_prepare_wholerow_span : function (obj) {
				obj = !obj || obj == -1 ? this.get_container().find("> ul > li") : this._get_node(obj);
				if(obj === false) { return; } // added for removing root nodes
				obj.each(function () {
					$(this).find("li").andSelf().each(function () {
						var $t = $(this);
						if($t.children(".jstree-wholerow-span").length) { return true; }
						$t.prepend("<span class='jstree-wholerow-span' style='width:" + ($t.parentsUntil(".jstree","li").length * 18) + "px;'>&#160;</span>");
					});
				});
			},
			_prepare_wholerow_ul : function () {
				var o = this.get_container().children("ul").eq(0), h = o.html();
				o.addClass("jstree-wholerow-real");
				if(this.data.wholerow.last_html !== h) {
					this.data.wholerow.last_html = h;
					this.get_container().children(".jstree-wholerow").remove();
					this.get_container().append(
						o.clone().removeClass("jstree-wholerow-real")
							.wrapAll("<div class='jstree-wholerow' />").parent()
							.width(o.parent()[0].scrollWidth)
							.css("top", (o.height() + ( is_ie7 ? 5 : 0)) * -1 )
							.find("li[id]").each(function () { this.removeAttribute("id"); }).end()
					);
				}
			}
		}
	});
	$(function() {
		var css_string = '' + 
			'.jstree .jstree-wholerow-real { position:relative; z-index:1; } ' + 
			'.jstree .jstree-wholerow-real li { cursor:pointer; } ' + 
			'.jstree .jstree-wholerow-real a { border-left-color:transparent !important; border-right-color:transparent !important; } ' + 
			'.jstree .jstree-wholerow { position:relative; z-index:0; height:0; } ' + 
			'.jstree .jstree-wholerow ul, .jstree .jstree-wholerow li { width:100%; } ' + 
			'.jstree .jstree-wholerow, .jstree .jstree-wholerow ul, .jstree .jstree-wholerow li, .jstree .jstree-wholerow a { margin:0 !important; padding:0 !important; } ' + 
			'.jstree .jstree-wholerow, .jstree .jstree-wholerow ul, .jstree .jstree-wholerow li { background:transparent !important; }' + 
			'.jstree .jstree-wholerow ins, .jstree .jstree-wholerow span, .jstree .jstree-wholerow input { display:none !important; }' + 
			'.jstree .jstree-wholerow a, .jstree .jstree-wholerow a:hover { text-indent:-9999px; !important; width:100%; padding:0 !important; border-right-width:0px !important; border-left-width:0px !important; } ' + 
			'.jstree .jstree-wholerow-span { position:absolute; left:0; margin:0px; padding:0; height:18px; border-width:0; padding:0; z-index:0; }';
		if(is_ff2) {
			css_string += '' + 
				'.jstree .jstree-wholerow a { display:block; height:18px; margin:0; padding:0; border:0; } ' + 
				'.jstree .jstree-wholerow-real a { border-color:transparent !important; } ';
		}
		if(is_ie7 || is_ie6) {
			css_string += '' + 
				'.jstree .jstree-wholerow, .jstree .jstree-wholerow li, .jstree .jstree-wholerow ul, .jstree .jstree-wholerow a { margin:0; padding:0; line-height:18px; } ' + 
				'.jstree .jstree-wholerow a { display:block; height:18px; line-height:18px; overflow:hidden; } ';
		}
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
	});
})(jQuery);
//*/

/*
* jsTree model plugin
* This plugin gets jstree to use a class model to retrieve data, creating great dynamism
*/
(function ($) {
	var nodeInterface = ["getChildren","getChildrenCount","getAttr","getName","getProps"],
		validateInterface = function(obj, inter) {
			var valid = true;
			obj = obj || {};
			inter = [].concat(inter);
			$.each(inter, function (i, v) {
				if(!$.isFunction(obj[v])) { valid = false; return false; }
			});
			return valid;
		};
	$.jstree.plugin("model", {
		__init : function () {
			if(!this.data.json_data) { throw "jsTree model: jsTree json_data plugin not included."; }
			this._get_settings().json_data.data = function (n, b) {
				var obj = (n == -1) ? this._get_settings().model.object : n.data("jstree_model");
				if(!validateInterface(obj, nodeInterface)) { return b.call(null, false); }
				if(this._get_settings().model.async) {
					obj.getChildren($.proxy(function (data) {
						this.model_done(data, b);
					}, this));
				}
				else {
					this.model_done(obj.getChildren(), b);
				}
			};
		},
		defaults : {
			object : false,
			id_prefix : false,
			async : false
		},
		_fn : {
			model_done : function (data, callback) {
				var ret = [], 
					s = this._get_settings(),
					_this = this;

				if(!$.isArray(data)) { data = [data]; }
				$.each(data, function (i, nd) {
					var r = nd.getProps() || {};
					r.attr = nd.getAttr() || {};
					if(nd.getChildrenCount()) { r.state = "closed"; }
					r.data = nd.getName();
					if(!$.isArray(r.data)) { r.data = [r.data]; }
					if(_this.data.types && $.isFunction(nd.getType)) {
						r.attr[s.types.type_attr] = nd.getType();
					}
					if(r.attr.id && s.model.id_prefix) { r.attr.id = s.model.id_prefix + r.attr.id; }
					if(!r.metadata) { r.metadata = { }; }
					r.metadata.jstree_model = nd;
					ret.push(r);
				});
				callback.call(null, ret);
			}
		}
	});
})(jQuery);
//*/

})();
},{}],"config":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Config = function () {
    function Config() {
        _classCallCheck(this, Config);
    }

    _createClass(Config, null, [{
        key: 'getSection',
        value: function getSection(key) {
            return window.ss.config.sections[key];
        }
    }, {
        key: 'getTopLevelRoutes',
        value: function getTopLevelRoutes() {
            var topLevelRoutes = [];

            Object.keys(window.ss.config.sections).forEach(function (key) {
                var route = window.ss.config.sections[key].route;
                var isTopLevelRoute = route.indexOf('/') === -1;
                var isUnique = topLevelRoutes.indexOf(route) === -1;

                if (isTopLevelRoute && isUnique) {
                    topLevelRoutes.push(route);
                }
            });

            return topLevelRoutes;
        }
    }]);

    return Config;
}();

exports.default = Config;

},{}],"i18n":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var i18n = function () {
	function i18n() {
		_classCallCheck(this, i18n);

		this.currentLocale = null;
		this.defaultLocale = 'en_US';
		this.lang = {};
	}

	_createClass(i18n, [{
		key: 'setLocale',
		value: function setLocale(locale) {
			this.currentLocale = locale;
		}
	}, {
		key: 'getLocale',
		value: function getLocale() {
			return this.currentLocale !== null ? this.currentLocale : this.defaultLocale;
		}
	}, {
		key: '_t',
		value: function _t(entity, fallbackString, priority, context) {
			var langName = this.getLocale().replace(/_[\w]+/i, '');
			var defaultlangName = this.defaultLocale.replace(/_[\w]+/i, '');

			if (this.lang && this.lang[this.getLocale()] && this.lang[this.getLocale()][entity]) {
				return this.lang[this.getLocale()][entity];
			} else if (this.lang && this.lang[langName] && this.lang[langName][entity]) {
				return this.lang[langName][entity];
			} else if (this.lang && this.lang[this.defaultLocale] && this.lang[this.defaultLocale][entity]) {
				return this.lang[this.defaultLocale][entity];
			} else if (this.lang && this.lang[defaultlangName] && this.lang[defaultlangName][entity]) {
				return this.lang[defaultlangName][entity];
			} else if (fallbackString) {
				return fallbackString;
			} else {
				return '';
			}
		}
	}, {
		key: 'addDictionary',
		value: function addDictionary(locale, dict) {
			if (typeof this.lang[locale] === 'undefined') {
				this.lang[locale] = {};
			}

			for (var entity in dict) {
				this.lang[locale][entity] = dict[entity];
			}
		}
	}, {
		key: 'getDictionary',
		value: function getDictionary(locale) {
			return this.lang[locale];
		}
	}, {
		key: 'stripStr',
		value: function stripStr(str) {
			return str.replace(/^\s*/, '').replace(/\s*$/, '');
		}
	}, {
		key: 'stripStrML',
		value: function stripStrML(str) {
			var parts = str.split('\n');

			for (var i = 0; i < parts.length; i += 1) {
				parts[i] = stripStr(parts[i]);
			}

			return stripStr(parts.join(' '));
		}
	}, {
		key: 'sprintf',
		value: function sprintf(s) {
			for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				params[_key - 1] = arguments[_key];
			}

			if (params.length === 0) {
				return s;
			}

			var regx = new RegExp('(.?)(%s)', 'g');

			var i = 0;

			return s.replace(regx, function (match, subMatch1, subMatch2, offset, string) {
				if (subMatch1 === '%') {
					return match;
				}

				return subMatch1 + params[i++];
			});
		}
	}, {
		key: 'inject',
		value: function inject(s, map) {
			var regx = new RegExp('\{([A-Za-z0-9_]*)\}', 'g');

			return s.replace(regx, function (match, key, offset, string) {
				return map[key] ? map[key] : match;
			});
		}
	}, {
		key: 'detectLocale',
		value: function detectLocale() {
			var rawLocale;
			var detectedLocale;

			rawLocale = jQuery('body').attr('lang');

			if (!rawLocale) {
				var metas = document.getElementsByTagName('meta');

				for (var i = 0; i < metas.length; i++) {
					if (metas[i].attributes['http-equiv'] && metas[i].attributes['http-equiv'].nodeValue.toLowerCase() == 'content-language') {
						rawLocale = metas[i].attributes['content'].nodeValue;
					}
				}
			}

			if (!rawLocale) {
				rawLocale = this.defaultLocale;
			}

			var rawLocaleParts = rawLocale.match(/([^-|_]*)[-|_](.*)/);

			if (rawLocale.length == 2) {
				for (var compareLocale in i18n.lang) {
					if (compareLocale.substr(0, 2).toLowerCase() == rawLocale.toLowerCase()) {
						detectedLocale = compareLocale;
						break;
					}
				}
			} else if (rawLocaleParts) {
				detectedLocale = rawLocaleParts[1].toLowerCase() + '_' + rawLocaleParts[2].toUpperCase();
			}

			return detectedLocale;
		}
	}, {
		key: 'addEvent',
		value: function addEvent(obj, evType, fn, useCapture) {
			if (obj.addEventListener) {
				obj.addEventListener(evType, fn, useCapture);
				return true;
			} else if (obj.attachEvent) {
				return obj.attachEvent('on' + evType, fn);
			} else {
				console.log('Handler could not be attached');
			}
		}
	}]);

	return i18n;
}();

var _i18n = new i18n();

window.ss = typeof window.ss !== 'undefined' ? window.ss : {};
window.ss.i18n = window.i18n = _i18n;

exports.default = _i18n;

},{}],"jQuery":[function(require,module,exports){
'use strict';

var jQuery = typeof window.jQuery !== 'undefined' ? window.jQuery : null;

module.exports = jQuery;

},{}],"router":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _page = require('page.js');

var _page2 = _interopRequireDefault(_page);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function show(pageShow) {
    return function (path, state, dispatch, push) {
        var el = document.createElement('a');
        el.href = path;

        return pageShow(el.pathname, state, dispatch, push);
    };
}

_page2.default.show = show(_page2.default.show);

exports.default = _page2.default;

},{"page.js":16}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhZG1pbi9qYXZhc2NyaXB0L3NyYy9idW5kbGVzL2xpYi5qcyIsImFkbWluL2phdmFzY3JpcHQvc3JjL3NzcGF0aC5qcyIsImFkbWluL2phdmFzY3JpcHQvc3JjL3NzdWkuY29yZS5qcyIsImFkbWluL3RoaXJkcGFydHkvY2hvc2VuL2Nob3Nlbi9jaG9zZW4uanF1ZXJ5LmpzIiwiYWRtaW4vdGhpcmRwYXJ0eS9qbGF5b3V0L2xpYi9qbGF5b3V0LmJvcmRlci5qcyIsImFkbWluL3RoaXJkcGFydHkvamxheW91dC9saWIvanF1ZXJ5LmpsYXlvdXQuanMiLCJhZG1pbi90aGlyZHBhcnR5L2pxdWVyeS1ob3ZlckludGVudC9qcXVlcnkuaG92ZXJJbnRlbnQuanMiLCJhZG1pbi90aGlyZHBhcnR5L2pxdWVyeS1ub3RpY2UvanF1ZXJ5Lm5vdGljZS5qcyIsImFkbWluL3RoaXJkcGFydHkvanNpemVzL2xpYi9qcXVlcnkuc2l6ZXMuanMiLCJqYXZhc2NyaXB0L3NyYy9EYXRlRmllbGQuanMiLCJqYXZhc2NyaXB0L3NyYy9HcmlkRmllbGQuanMiLCJqYXZhc2NyaXB0L3NyYy9IdG1sRWRpdG9yRmllbGQuanMiLCJqYXZhc2NyaXB0L3NyYy9UYWJTZXQuanMiLCJqYXZhc2NyaXB0L3NyYy9UcmVlRHJvcGRvd25GaWVsZC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcGFnZS5qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYWdlLmpzL25vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9pbmRleC5qcyIsInRoaXJkcGFydHkvanF1ZXJ5LWNoYW5nZXRyYWNrZXIvbGliL2pxdWVyeS5jaGFuZ2V0cmFja2VyLmpzIiwidGhpcmRwYXJ0eS9qcXVlcnktY29va2llL2pxdWVyeS5jb29raWUuanMiLCJ0aGlyZHBhcnR5L2pxdWVyeS1lbnR3aW5lL2Rpc3QvanF1ZXJ5LmVudHdpbmUtZGlzdC5qcyIsInRoaXJkcGFydHkvanF1ZXJ5LWZvcm0vanF1ZXJ5LmZvcm0uanMiLCJ0aGlyZHBhcnR5L2pxdWVyeS1vbmRlbWFuZC9qcXVlcnkub25kZW1hbmQuanMiLCJ0aGlyZHBhcnR5L2pxdWVyeS1xdWVyeS9qcXVlcnkucXVlcnkuanMiLCJ0aGlyZHBhcnR5L2pxdWVyeS11aS9qcXVlcnktdWkuanMiLCJ0aGlyZHBhcnR5L2pxdWVyeS9qcXVlcnkuanMiLCJ0aGlyZHBhcnR5L2pzb24tanMvanNvbjIuanMiLCJ0aGlyZHBhcnR5L2pzdHJlZS9qcXVlcnkuanN0cmVlLmpzIiwiYWRtaW4vamF2YXNjcmlwdC9zcmMvY29uZmlnLmpzIiwiamF2YXNjcmlwdC9zcmMvaTE4bi5qcyIsImphdmFzY3JpcHQvc3JjL2pRdWVyeS5qcyIsImphdmFzY3JpcHQvc3JjL3JvdXRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FDQUEsUUFBUSx5Q0FBUjtBQUNBLFFBQVEsMkRBQVI7QUFDQSxRQUFRLHFCQUFSO0FBQ0EsUUFBUSwrQ0FBUjtBQUNBLFFBQVEseUNBQVI7QUFDQSxRQUFRLG1FQUFSO0FBQ0EsUUFBUSx1REFBUjtBQUNBLFFBQVEscURBQVI7QUFDQSxRQUFRLG1EQUFSO0FBQ0EsUUFBUSxvREFBUjtBQUNBLFFBQVEsZ0RBQVI7QUFDQSxRQUFRLG1EQUFSO0FBQ0EsUUFBUSxtREFBUjtBQUNBLFFBQVEsZ0RBQVI7QUFDQSxRQUFRLG9EQUFSO0FBQ0EsUUFBUSw4REFBUjtBQUNBLFFBQVEseUVBQVI7QUFDQSxRQUFRLGlEQUFSO0FBQ0EsUUFBUSx5Q0FBUjtBQUNBLFFBQVEsK0NBQVI7QUFDQSxRQUFRLHNDQUFSO0FBQ0EsUUFBUSx3QkFBUjtBQUNBLFFBQVEseUNBQVI7Ozs7Ozs7Ozs7O0FDRUEsSUFBSSxVQUFVLHNCQUFHLE1BQUgsQ0FBVjtJQUNILFFBQVEsc0JBQUcsTUFBSCxDQUFSO0lBQ0EsUUFBUSxzQkFBRyxNQUFILENBQVI7SUFHQSxPQUFPO0FBMkJOLGFBQVksa0xBQVo7O0FBSUEsV0FBVSxrQkFBVSxHQUFWLEVBQWdCO0FBR3pCLE1BQUssaUJBQUUsSUFBRixDQUFRLEdBQVIsTUFBa0IsUUFBbEIsRUFBNkI7QUFDakMsVUFBTyxHQUFQLENBRGlDO0dBQWxDOztBQUlBLE1BQUksVUFBVSxLQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBc0IsT0FBTyxFQUFQLENBQXRCLElBQXFDLEVBQXJDLENBUFc7O0FBYXhCLFNBQU87QUFDTixTQUFjLFFBQVUsQ0FBVixLQUFpQixFQUFqQjtBQUNkLGVBQWMsUUFBVSxDQUFWLEtBQWlCLEVBQWpCO0FBQ2QsaUJBQWMsUUFBVSxDQUFWLEtBQWlCLEVBQWpCO0FBQ2QsV0FBYyxRQUFVLENBQVYsS0FBaUIsRUFBakI7QUFDZCxhQUFjLFFBQVUsQ0FBVixLQUFpQixFQUFqQjtBQUNkLGdCQUFjLFFBQVUsQ0FBVixLQUFpQixFQUFqQjtBQUNkLGNBQWMsUUFBVSxDQUFWLEtBQWlCLEVBQWpCO0FBQ2QsYUFBYyxRQUFVLENBQVYsS0FBaUIsRUFBakI7QUFDZCxhQUFjLFFBQVUsQ0FBVixLQUFpQixFQUFqQjtBQUNkLFNBQWMsUUFBUyxFQUFULEtBQWlCLEVBQWpCO0FBQ2QsYUFBYyxRQUFTLEVBQVQsS0FBaUIsRUFBakI7QUFDZCxTQUFjLFFBQVMsRUFBVCxLQUFpQixFQUFqQjtBQUNkLGFBQWMsUUFBUyxFQUFULEtBQWlCLEVBQWpCO0FBQ2QsY0FBYyxRQUFTLEVBQVQsS0FBaUIsRUFBakI7QUFDZCxhQUFjLFFBQVMsRUFBVCxLQUFpQixFQUFqQjtBQUNkLFdBQWMsUUFBUyxFQUFULEtBQWlCLEVBQWpCO0FBQ2QsU0FBYyxRQUFTLEVBQVQsS0FBaUIsRUFBakI7R0FqQmYsQ0Fid0I7RUFBaEI7O0FBcUNWLG1CQUFrQiwwQkFBVSxPQUFWLEVBQW1CLE9BQW5CLEVBQTZCO0FBQzlDLE1BQUssV0FBVyxRQUFRLE1BQVIsQ0FBZ0IsQ0FBaEIsTUFBd0IsR0FBeEIsRUFBOEI7QUFDN0MsVUFBTyxPQUFQLENBRDZDO0dBQTlDOztBQUlBLFlBQVUsV0FBVyxFQUFYLENBTG9DO0FBTTlDLFlBQVUsVUFBVSxRQUFRLE9BQVIsQ0FBaUIseUJBQWpCLEVBQTRDLEVBQTVDLENBQVYsR0FBNkQsRUFBN0QsQ0FOb0M7O0FBUTlDLE1BQUksV0FBVyxVQUFVLFFBQVEsS0FBUixDQUFlLEdBQWYsQ0FBVixHQUFpQyxFQUFqQztNQUNkLFdBQVcsUUFBUSxLQUFSLENBQWUsR0FBZixDQUFYLENBVDZDO0FBVTlDLE9BQU0sSUFBSSxJQUFJLENBQUosRUFBTyxJQUFJLFNBQVMsTUFBVCxFQUFpQixHQUF0QyxFQUE0QztBQUMzQyxPQUFJLElBQUksU0FBVSxDQUFWLENBQUosQ0FEdUM7QUFFM0MsV0FBUyxDQUFUO0FBQ0MsU0FBSyxHQUFMO0FBQ0MsV0FERDtBQURELFNBR00sSUFBTDtBQUNDLFNBQUssU0FBUyxNQUFULEVBQWtCO0FBQ3RCLGVBQVMsR0FBVCxHQURzQjtNQUF2QjtBQUdBLFdBSkQ7QUFIRDtBQVNFLGNBQVMsSUFBVCxDQUFlLENBQWYsRUFERDtBQUVDLFdBRkQ7QUFSRCxJQUYyQztHQUE1QztBQWVBLFNBQU8sTUFBTSxTQUFTLElBQVQsQ0FBZSxHQUFmLENBQU4sQ0F6QnVDO0VBQTdCOztBQTZCbEIsZUFBYyxzQkFBVSxPQUFWLEVBQW1CLE9BQW5CLEVBQTZCO0FBQzFDLFNBQU8sS0FBSyxRQUFMLENBQWUsT0FBZixFQUF5QixNQUF6QixLQUFvQyxLQUFLLFFBQUwsQ0FBZSxPQUFmLEVBQXlCLE1BQXpCLENBREQ7RUFBN0I7O0FBS2QsZ0JBQWUsdUJBQVUsR0FBVixFQUFnQjtBQUU5QixTQUFPLEtBQUssUUFBTCxDQUFlLEdBQWYsRUFBcUIsUUFBckIsS0FBa0MsRUFBbEMsQ0FGdUI7RUFBaEI7O0FBTWYsZ0JBQWUsdUJBQVUsR0FBVixFQUFnQjtBQUM5QixTQUFPLEtBQUssUUFBTCxDQUFlLEdBQWYsRUFBcUIsUUFBckIsS0FBa0MsRUFBbEMsQ0FEdUI7RUFBaEI7O0FBTWYsa0JBQWlCLHlCQUFVLE1BQVYsRUFBa0IsTUFBbEIsRUFBMkI7QUFDM0MsTUFBSyxDQUFDLEtBQUssYUFBTCxDQUFvQixNQUFwQixDQUFELEVBQWdDO0FBQ3BDLFVBQU8sTUFBUCxDQURvQztHQUFyQzs7QUFJQSxNQUFJLFNBQVMsS0FBSyxRQUFMLENBQWUsTUFBZixDQUFUO01BQ0gsU0FBUyxLQUFLLFFBQUwsQ0FBZSxNQUFmLENBQVQ7TUFDQSxXQUFXLE9BQU8sUUFBUCxJQUFtQixPQUFPLFFBQVA7TUFDOUIsY0FBYyxPQUFPLFFBQVAsR0FBa0IsT0FBTyxXQUFQLEdBQXVCLE9BQU8sV0FBUCxJQUFzQixPQUFPLFdBQVA7TUFDN0UsWUFBWSxPQUFPLFNBQVAsSUFBb0IsT0FBTyxTQUFQO01BQ2hDLFVBQVUsT0FBTyxRQUFQLEtBQW9CLEVBQXBCO01BQ1YsV0FBVyxLQUFLLGdCQUFMLENBQXVCLE9BQU8sUUFBUCxJQUFtQixPQUFPLFFBQVAsRUFBaUIsT0FBTyxRQUFQLENBQXRFO01BQ0EsU0FBUyxPQUFPLE1BQVAsSUFBbUIsQ0FBQyxPQUFELElBQVksT0FBTyxNQUFQLElBQW1CLEVBQWxEO01BQ1QsT0FBTyxPQUFPLElBQVAsQ0FibUM7O0FBZTNDLFNBQU8sV0FBVyxXQUFYLEdBQXlCLFNBQXpCLEdBQXFDLFFBQXJDLEdBQWdELE1BQWhELEdBQXlELElBQXpELENBZm9DO0VBQTNCOztBQW9CakIsa0JBQWlCLHlCQUFVLEdBQVYsRUFBZSxNQUFmLEVBQXdCO0FBQ3hDLE1BQUksSUFBSSxLQUFLLFFBQUwsQ0FBZSxHQUFmLENBQUo7TUFDSCxTQUFTLE9BQVMsTUFBUCxLQUFrQixRQUFsQixHQUErQixLQUFLLG9CQUFMLENBQTJCLE1BQTNCLENBQWpDLEdBQXVFLE1BQXZFO01BQ1QsWUFBWSxpQkFBRSxNQUFGLENBQVUsS0FBSyxvQkFBTCxDQUEyQixFQUFFLE1BQUYsQ0FBckMsRUFBaUQsTUFBakQsQ0FBWixDQUh1QztBQUl4QyxTQUFPLEVBQUUsWUFBRixHQUFpQixHQUFqQixHQUF1QixpQkFBRSxLQUFGLENBQVMsU0FBVCxDQUF2QixJQUFnRCxFQUFFLElBQUYsSUFBVSxFQUFWLENBQWhELENBSmlDO0VBQXhCOztBQVFqQixrQkFBaUIseUJBQVMsR0FBVCxFQUFjO0FBQzlCLE1BQUksSUFBSSxLQUFLLFFBQUwsQ0FBZSxHQUFmLENBQUosQ0FEMEI7QUFFOUIsU0FBTyxLQUFLLG9CQUFMLENBQTJCLEVBQUUsTUFBRixDQUFsQyxDQUY4QjtFQUFkOztBQVFqQix1QkFBc0IsOEJBQVMsTUFBVCxFQUFpQjtBQUN0QyxNQUFJLFNBQVMsRUFBVDtNQUNILFNBQVMsT0FBTyxPQUFQLENBQWdCLEtBQWhCLEVBQXVCLEVBQXZCLENBQVQ7TUFDQSxRQUFRLFNBQVMsT0FBTyxLQUFQLENBQWMsR0FBZCxDQUFULEdBQStCLEVBQS9CO01BQW1DLENBRjVDO01BRStDLEdBRi9DLENBRHNDO0FBSXRDLE9BQUksSUFBRSxDQUFGLEVBQUssSUFBSSxNQUFNLE1BQU4sRUFBYyxHQUEzQixFQUFnQztBQUMvQixTQUFNLE1BQU0sQ0FBTixFQUFTLEtBQVQsQ0FBZ0IsR0FBaEIsQ0FBTixDQUQrQjtBQUUvQixVQUFPLElBQUksQ0FBSixDQUFQLElBQWlCLElBQUksQ0FBSixDQUFqQixDQUYrQjtHQUFoQztBQUlBLFNBQU8sTUFBUCxDQVJzQztFQUFqQjs7QUFXdEIsc0JBQXFCLDZCQUFVLE1BQVYsRUFBbUI7QUFDdkMsTUFBSSxJQUFJLEtBQUssUUFBTCxDQUFlLE1BQWYsQ0FBSixDQURtQztBQUV2QyxNQUFLLEtBQUssY0FBTCxDQUFxQixDQUFyQixDQUFMLEVBQWdDO0FBRy9CLFVBQU8sRUFBRSxJQUFGLENBQU8sS0FBUCxDQUFjLGFBQWQsRUFBOEIsQ0FBOUIsRUFBaUMsT0FBakMsQ0FBMEMsSUFBMUMsRUFBZ0QsRUFBaEQsQ0FBUCxDQUgrQjtHQUFoQyxNQUlPLElBQUssS0FBSyxZQUFMLENBQW1CLENBQW5CLEVBQXNCLFFBQXRCLENBQUwsRUFBd0M7QUFDOUMsVUFBTyxFQUFFLFVBQUYsQ0FBYSxPQUFiLENBQXNCLFNBQVMsTUFBVCxFQUFpQixFQUF2QyxDQUFQLENBRDhDO0dBQXhDO0FBR1AsU0FBTyxNQUFQLENBVHVDO0VBQW5COztBQWFyQixNQUFLLGFBQVUsT0FBVixFQUFvQjtBQUN4QixNQUFJLFlBQVksU0FBWixFQUF3QjtBQUMzQixhQUFVLFNBQVMsSUFBVCxDQURpQjtHQUE1QjtBQUdBLFNBQU8sS0FBSyxTQUFMLENBQWdCLE9BQWhCLEVBQTBCLE9BQTFCLENBQW1DLGtCQUFuQyxFQUF1RCxFQUF2RCxDQUFQLENBSndCO0VBQXBCOztBQVFMLGNBQWEscUJBQVUsSUFBVixFQUFpQjtBQUM3QixNQUFJLFdBQVcsTUFBTSxpQkFBRSxNQUFGLENBQVMsYUFBVCxDQURRO0FBRTdCLFNBQU8sUUFBUSxLQUFLLEtBQUwsQ0FBWSxRQUFaLEVBQXVCLENBQXZCLEVBQTBCLEtBQTFCLENBQWlDLGFBQWpDLEVBQWlELENBQWpELENBQVIsQ0FGc0I7RUFBakI7O0FBTWIsTUFBSyxhQUFVLElBQVYsRUFBaUI7QUFDckIsV0FBUyxJQUFULEdBQWdCLElBQWhCLENBRHFCO0VBQWpCOztBQU1MLFNBQVEsZ0JBQVUsR0FBVixFQUFnQjtBQUN2QixTQUFPLE1BQVMsSUFBVCxDQUFlLEdBQWYsQ0FBUDtJQUR1QjtFQUFoQjs7QUFLUixRQUFPLGVBQVUsR0FBVixFQUFnQjtBQUN0QixTQUFPLElBQUksT0FBSixDQUFhLFNBQVMsTUFBVCxFQUFpQixFQUE5QixDQUFQLENBRHNCO0VBQWhCOztBQUtQLFlBQVcsbUJBQVUsR0FBVixFQUFnQjtBQUMxQixTQUFPLElBQUksT0FBSixDQUFhLElBQWIsRUFBbUIsRUFBbkIsQ0FBUCxDQUQwQjtFQUFoQjs7QUFLWCxZQUFXLG1CQUFVLElBQVYsRUFBaUI7QUFDM0IsU0FBTyxLQUFLLFNBQUwsQ0FBZ0IsS0FBSyxPQUFMLENBQWMsT0FBZCxFQUF1QixFQUF2QixFQUE0QixPQUE1QixDQUFxQyxhQUFyQyxFQUFvRCxFQUFwRCxDQUFoQixDQUFQLENBRDJCO0VBQWpCOztBQU1YLGFBQVksb0JBQVUsR0FBVixFQUFnQjtBQUMzQixNQUFJLElBQUksS0FBSyxRQUFMLENBQWUsR0FBZixDQUFKLENBRHVCO0FBRTNCLFNBQU8sRUFBRSxRQUFGLElBQWMsRUFBRSxNQUFGLEtBQWEsU0FBUyxNQUFULEdBQWtCLElBQTdDLEdBQW9ELEtBQXBELENBRm9CO0VBQWhCOztBQUtaLGNBQWEscUJBQVUsR0FBVixFQUFnQjtBQUM1QixTQUFPLGFBQWdCLElBQWhCLENBQXNCLEdBQXRCLENBQVA7SUFENEI7RUFBaEI7Q0E1TmQ7O0FBaU9ELGlCQUFFLElBQUYsR0FBUyxJQUFUOzs7Ozs7Ozs7OztBQ3BQQSxpQkFBRSxNQUFGLENBQVMsYUFBVCxFQUF3QixpQkFBRSxFQUFGLENBQUssTUFBTCxFQUFhO0FBQ3BDLFVBQVM7QUFDUixhQUFXO0FBQ1YsU0FBTSxJQUFOO0FBQ0EsU0FBTSxJQUFOO0dBRkQ7QUFJQSxvQkFBa0IsS0FBbEI7RUFMRDs7QUFXQSxrQkFBaUIsMkJBQVc7QUFDM0IsTUFBSSxLQUFLLFFBQUwsQ0FBYyxtQkFBZCxNQUFxQyxLQUFyQyxFQUE0QyxPQUFoRDs7QUFHQSxNQUFJLENBQUMsS0FBSyxPQUFMLENBQWEsU0FBYixDQUF1QixJQUF2QixJQUErQixDQUFDLEtBQUssT0FBTCxDQUFhLFNBQWIsQ0FBdUIsSUFBdkIsRUFBNkIsT0FBbEU7O0FBRUEsT0FBSyxPQUFMLENBQWEsZ0JBQWIsR0FBZ0MsQ0FBQyxLQUFLLE9BQUwsQ0FBYSxnQkFBYixDQU5OO0FBTzNCLE9BQUssT0FBTCxHQVAyQjtFQUFYOztBQWFqQixvQkFBbUIsNkJBQVc7QUFDN0IsT0FBSyxRQUFMLENBQWMsd0JBQWQsRUFENkI7O0FBSTdCLE1BQUksQ0FBQyxLQUFLLE9BQUwsQ0FBYSxTQUFiLENBQXVCLElBQXZCLElBQStCLENBQUMsS0FBSyxPQUFMLENBQWEsU0FBYixDQUF1QixJQUF2QixFQUE2QixPQUFsRTs7QUFFQSxNQUFJLEtBQUssT0FBTCxDQUFhLGdCQUFiLEVBQStCO0FBQ2xDLFFBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IseUJBQWxCLEVBQTZDLElBQTdDLEdBRGtDO0FBRWxDLFFBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsaUJBQWxCLEVBQXFDLElBQXJDLEdBRmtDO0FBR2xDLFFBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsMkJBQWxCLEVBQStDLElBQS9DLEdBSGtDO0FBSWxDLFFBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsMkJBQWxCLEVBQStDLElBQS9DLEdBSmtDO0dBQW5DLE1BTUs7QUFDSixRQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLHlCQUFsQixFQUE2QyxJQUE3QyxHQURJO0FBRUosUUFBSyxPQUFMLENBQWEsSUFBYixDQUFrQixpQkFBbEIsRUFBcUMsSUFBckMsR0FGSTtBQUdKLFFBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsMkJBQWxCLEVBQStDLElBQS9DLEdBSEk7QUFJSixRQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLDJCQUFsQixFQUErQyxJQUEvQyxHQUpJO0dBTkw7O0FBYUEsT0FBSyxRQUFMLENBQWMsdUJBQWQsRUFuQjZCO0VBQVg7O0FBMEJuQixlQUFjLHdCQUFXO0FBQ3hCLE1BQUksY0FBYyxLQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLGNBQWxCLENBQWQ7TUFDSCxnQkFBZ0IsS0FBSyxPQUFMLENBQWEsSUFBYixDQUFrQixnQkFBbEIsQ0FBaEIsQ0FGdUI7O0FBSXhCLE1BQUksQ0FBQyxXQUFELEVBQWMsY0FBYyxLQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLE1BQWxCLENBQWQsQ0FBbEI7O0FBR0EsTUFBRyxXQUFILEVBQWdCLEtBQUssT0FBTCxDQUFhLEtBQWIsQ0FBbUIsT0FBbkIsR0FBNkIsY0FBYyxXQUFkLENBQTdDO0FBQ0EsTUFBRyxhQUFILEVBQWtCLEtBQUssT0FBTCxDQUFhLEtBQWIsQ0FBbUIsU0FBbkIsR0FBK0IsY0FBYyxhQUFkLENBQWpEOztBQUVBLG1CQUFFLEVBQUYsQ0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixZQUF0QixDQUFtQyxJQUFuQyxDQUF3QyxJQUF4QyxFQVZ3Qjs7QUFheEIsTUFBSSxDQUFDLEtBQUssT0FBTCxDQUFhLFNBQWIsQ0FBdUIsSUFBdkIsRUFBNkI7QUFDakMsUUFBSyxPQUFMLENBQWEsU0FBYixDQUF1QixJQUF2QixHQUE4QixLQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLGdCQUFsQixDQUE5QixDQURpQztHQUFsQztBQUdBLE1BQUksQ0FBQyxLQUFLLE9BQUwsQ0FBYSxTQUFiLENBQXVCLElBQXZCLEVBQTZCO0FBQ2pDLFFBQUssT0FBTCxDQUFhLFNBQWIsQ0FBdUIsSUFBdkIsR0FBOEIsS0FBSyxPQUFMLENBQWEsSUFBYixDQUFrQixnQkFBbEIsQ0FBOUIsQ0FEaUM7R0FBbEM7QUFHQSxNQUFJLENBQUMsS0FBSyxPQUFMLENBQWEsZ0JBQWIsRUFBK0I7QUFDbkMsUUFBSyxPQUFMLENBQWEsZ0JBQWIsR0FBZ0MsS0FBSyxPQUFMLENBQWEsUUFBYixDQUFzQixpQkFBdEIsQ0FBaEMsQ0FEbUM7R0FBcEM7O0FBS0EsTUFBSSxLQUFLLE9BQUwsQ0FBYSxTQUFiLENBQXVCLElBQXZCLEVBQTZCO0FBQ2hDLFFBQUssYUFBTCxDQUFtQixNQUFuQixDQUNDLG1GQUNFLEtBQUssT0FBTCxDQUFhLFNBQWIsQ0FBdUIsSUFBdkIsR0FBOEIsV0FEaEMsQ0FERCxDQURnQztHQUFqQztBQU1BLE1BQUksS0FBSyxPQUFMLENBQWEsU0FBYixDQUF1QixJQUF2QixFQUE2QjtBQUNoQyxRQUFLLGFBQUwsQ0FBbUIsTUFBbkIsQ0FDQywyREFBMkQsS0FBSyxPQUFMLENBQWEsU0FBYixDQUF1QixJQUF2QixHQUE4QixTQUF6RixDQURELENBRGdDO0dBQWpDOztBQU1BLE9BQUssaUJBQUwsR0FwQ3dCO0VBQVg7O0FBdUNkLFVBQVMsbUJBQVc7QUFDbkIsbUJBQUUsRUFBRixDQUFLLE1BQUwsQ0FBWSxTQUFaLENBQXNCLE9BQXRCLENBQThCLElBQTlCLENBQW1DLElBQW5DLEVBRG1COztBQUduQixPQUFLLGlCQUFMLEdBSG1CO0VBQVg7O0FBTVQsVUFBUyxtQkFBVztBQUNuQixPQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLDJCQUFsQixFQUErQyxNQUEvQyxHQURtQjtBQUVuQixPQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLDJCQUFsQixFQUErQyxNQUEvQyxHQUZtQjs7QUFJbkIsbUJBQUUsRUFBRixDQUFLLE1BQUwsQ0FBWSxTQUFaLENBQXNCLE9BQXRCLENBQThCLElBQTlCLENBQW9DLElBQXBDLEVBSm1CO0VBQVg7Q0FoR1Y7O0FBbUhBLGlCQUFFLE1BQUYsQ0FBUyxlQUFULEVBQTBCLGlCQUFFLEVBQUYsQ0FBSyxNQUFMLEVBQWE7QUFDdEMsVUFBUztBQUVSLGFBQVcsRUFBWDtBQUNBLGdCQUFjLElBQWQ7QUFDQSxvQkFBa0IsRUFBbEI7O0FBR0EsU0FBTyxJQUFQO0FBQ0EsWUFBVSxJQUFWO0FBQ0EsWUFBVSxLQUFWO0FBQ0EsZ0JBQWMsSUFBZDtBQUNBLFlBQVUsR0FBVjtBQUNBLFlBQVUsR0FBVjtBQUNBLGFBQVcsR0FBWDtBQUNBLGFBQVcsR0FBWDtBQUNBLGNBQVksR0FBWjtBQUNBLGVBQWEsR0FBYjtBQUNBLGFBQVcsS0FBWDtFQWpCRDtBQW1CQSxVQUFTLG1CQUFXO0FBQ25CLG1CQUFFLEVBQUYsQ0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixPQUF0QixDQUE4QixJQUE5QixDQUFtQyxJQUFuQyxFQURtQjs7QUFHbkIsTUFBSSxPQUFPLElBQVAsQ0FIZTs7QUFNbkIsTUFBSSxTQUFTLHNCQUFFLHFGQUFGLENBQVQsQ0FOZTtBQU9uQixTQUFPLElBQVAsQ0FBWSxNQUFaLEVBQW9CLFVBQVMsQ0FBVCxFQUFZO0FBQy9CLE9BQUcsc0JBQUUsSUFBRixFQUFRLElBQVIsQ0FBYSxLQUFiLEtBQXVCLGFBQXZCLEVBQXNDLE9BQXpDOztBQUVBLFVBQU8sUUFBUCxDQUFnQixRQUFoQixFQUEwQixJQUExQixHQUgrQjtBQUkvQixRQUFLLGFBQUwsR0FKK0I7QUFLL0IsUUFBSyxRQUFMLENBQWMsV0FBZCxDQUEwQixTQUExQixFQUwrQjtHQUFaLENBQXBCLENBTUcsSUFOSCxHQVBtQjs7QUFlbkIsTUFBRyxLQUFLLE9BQUwsQ0FBYSxnQkFBYixFQUErQixLQUFLLFFBQUwsQ0FBYyxRQUFkLENBQXVCLEtBQUssT0FBTCxDQUFhLGdCQUFiLENBQXZCLENBQWxDO0FBQ0EsT0FBSyxPQUFMLENBQWEsTUFBYixDQUFvQixNQUFwQixFQWhCbUI7O0FBbUJuQixNQUFHLEtBQUssT0FBTCxDQUFhLFNBQWIsRUFBd0IsS0FBSyxPQUFMLENBQWEsR0FBYixDQUFpQixVQUFqQixFQUE2QixRQUE3QixFQUEzQjtFQW5CUTtBQXFCVCxPQUFNLGdCQUFXO0FBQ2hCLG1CQUFFLEVBQUYsQ0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixJQUF0QixDQUEyQixJQUEzQixDQUFnQyxJQUFoQyxFQURnQjs7QUFHaEIsTUFBSSxPQUFPLElBQVA7TUFBYSxTQUFTLEtBQUssT0FBTCxDQUFhLFFBQWIsQ0FBc0IsUUFBdEIsQ0FBVCxDQUhEOztBQU1oQixNQUFHLEtBQUssT0FBTCxDQUFhLFNBQWIsS0FBMkIsQ0FBQyxPQUFPLFFBQVAsQ0FBZ0IsUUFBaEIsQ0FBRCxJQUE4QixLQUFLLE9BQUwsQ0FBYSxZQUFiLENBQXpELEVBQXFGO0FBQ3ZGLFVBQU8sSUFBUCxHQUR1RjtBQUV2RixVQUFPLElBQVAsQ0FBWSxLQUFaLEVBQW1CLEtBQUssT0FBTCxDQUFhLFNBQWIsQ0FBbkIsQ0FGdUY7QUFHdkYsUUFBSyxRQUFMLENBQWMsUUFBZCxDQUF1QixTQUF2QixFQUh1RjtHQUF4Rjs7QUFPQSx3QkFBRSxNQUFGLEVBQVUsSUFBVixDQUFlLGlCQUFmLEVBQWtDLFlBQVc7QUFBQyxRQUFLLGFBQUwsR0FBRDtHQUFYLENBQWxDLENBYmdCO0VBQVg7QUFlTixRQUFPLGlCQUFXO0FBQ2pCLG1CQUFFLEVBQUYsQ0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixLQUF0QixDQUE0QixJQUE1QixDQUFpQyxJQUFqQyxFQURpQjs7QUFHakIsT0FBSyxRQUFMLENBQWMsTUFBZCxDQUFxQixpQkFBckIsRUFIaUI7QUFJakIsd0JBQUUsTUFBRixFQUFVLE1BQVYsQ0FBaUIsaUJBQWpCLEVBSmlCO0VBQVg7QUFNUCxnQkFBZSx5QkFBVztBQUN6QixNQUFJLE9BQU8sRUFBUDtNQUFXLFFBQWY7TUFBeUIsU0FBekI7TUFBb0MsU0FBUyxLQUFLLE9BQUwsQ0FBYSxRQUFiLENBQXNCLFFBQXRCLENBQVQsQ0FEWDtBQUV6QixNQUFHLEtBQUssT0FBTCxDQUFhLFVBQWIsRUFBeUI7QUFDM0IsY0FBVyxzQkFBRSxNQUFGLEVBQVUsS0FBVixLQUFvQixLQUFLLE9BQUwsQ0FBYSxVQUFiLENBREo7QUFFM0IsT0FBRyxLQUFLLE9BQUwsQ0FBYSxRQUFiLElBQXlCLFdBQVcsS0FBSyxPQUFMLENBQWEsUUFBYixFQUF1QjtBQUM3RCxTQUFLLEtBQUwsR0FBYSxLQUFLLE9BQUwsQ0FBYSxRQUFiLENBRGdEO0lBQTlELE1BRU8sSUFBRyxLQUFLLE9BQUwsQ0FBYSxRQUFiLElBQXlCLFdBQVcsS0FBSyxPQUFMLENBQWEsUUFBYixFQUF1QjtBQUNwRSxTQUFLLEtBQUwsR0FBYSxLQUFLLE9BQUwsQ0FBYSxRQUFiLENBRHVEO0lBQTlELE1BRUE7QUFDTixTQUFLLEtBQUwsR0FBYSxRQUFiLENBRE07SUFGQTtHQUpSO0FBVUEsTUFBRyxLQUFLLE9BQUwsQ0FBYSxXQUFiLEVBQTBCO0FBQzVCLGVBQVksc0JBQUUsTUFBRixFQUFVLE1BQVYsS0FBcUIsS0FBSyxPQUFMLENBQWEsV0FBYixDQURMO0FBRTVCLE9BQUcsS0FBSyxPQUFMLENBQWEsU0FBYixJQUEwQixZQUFZLEtBQUssT0FBTCxDQUFhLFNBQWIsRUFBd0I7QUFDaEUsU0FBSyxNQUFMLEdBQWMsS0FBSyxPQUFMLENBQWEsU0FBYixDQURrRDtJQUFqRSxNQUVPLElBQUcsS0FBSyxPQUFMLENBQWEsU0FBYixJQUEwQixZQUFZLEtBQUssT0FBTCxDQUFhLFNBQWIsRUFBd0I7QUFDdkUsU0FBSyxNQUFMLEdBQWMsS0FBSyxPQUFMLENBQWEsU0FBYixDQUR5RDtJQUFqRSxNQUVBO0FBQ04sU0FBSyxNQUFMLEdBQWMsU0FBZCxDQURNO0lBRkE7R0FKUjs7QUFXQSxNQUFHLENBQUMsT0FBTyxhQUFQLENBQXFCLElBQXJCLENBQUQsRUFBNkI7QUFDL0IsUUFBSyxXQUFMLENBQWlCLElBQWpCLEVBRCtCOztBQUkvQixVQUFPLElBQVAsQ0FBWSxPQUFaLEVBQ0MsS0FBSyxLQUFMLEdBQ0UsV0FBVyxLQUFLLE9BQUwsQ0FBYSxHQUFiLENBQWlCLGFBQWpCLENBQVgsQ0FERixHQUVFLFdBQVcsS0FBSyxPQUFMLENBQWEsR0FBYixDQUFpQixjQUFqQixDQUFYLENBRkYsQ0FERCxDQUorQjtBQVMvQixVQUFPLElBQVAsQ0FBWSxRQUFaLEVBQ0MsS0FBSyxNQUFMLEdBQ0UsV0FBVyxLQUFLLE9BQUwsQ0FBYSxHQUFiLENBQWlCLFlBQWpCLENBQVgsQ0FERixHQUVFLFdBQVcsS0FBSyxPQUFMLENBQWEsR0FBYixDQUFpQixlQUFqQixDQUFYLENBRkYsQ0FERCxDQVQrQjs7QUFnQi9CLE9BQUcsS0FBSyxPQUFMLENBQWEsWUFBYixFQUEyQjtBQUM3QixTQUFLLFVBQUwsQ0FBZ0IsVUFBaEIsRUFBNEIsS0FBSyxPQUFMLENBQWEsUUFBYixDQUE1QixDQUQ2QjtJQUE5QjtHQWhCRDtFQXZCYztDQTlEaEI7O0FBNEdBLGlCQUFFLE1BQUYsQ0FBUyxlQUFULEVBQTBCO0FBQ3pCLFVBQVMsbUJBQVc7QUFDbkIsT0FBSyxhQUFMLEdBQXFCLEtBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsT0FBbEIsQ0FBckIsQ0FEbUI7O0FBR25CLE1BQUksT0FBTyxJQUFQLENBSGU7QUFJbkIsTUFBSSxVQUFVLEtBQUssT0FBTCxDQUpLOztBQU1uQixNQUFJLFFBQVEsUUFBUSxLQUFSLElBQWlCLEtBQUssYUFBTCxJQUFzQixRQUF2QyxDQU5PO0FBT25CLE1BQUksVUFBVSxpQkFBRSxFQUFGLENBQUssTUFBTCxDQUFZLFVBQVosQ0FBdUIsS0FBSyxPQUFMLENBQWpDLENBUGU7O0FBU25CLE9BQUssT0FBTCxDQUFhLE1BQWIsR0FBc0IsUUFBdEIsQ0FBK0IsV0FBL0IsRUFUbUI7O0FBV25CLE1BQUksbUJBQW1CLEtBQUssT0FBTCxDQUN0QixRQURzQixDQUVyQix3QkFDQSxtQkFEQSxHQUVBLGdCQUZBLEdBR0Esb0JBSEEsQ0FGRSxDQVhlOztBQXFCbEIsTUFBRyxRQUFRLFdBQVIsRUFBcUI7QUFDdkIsT0FBSSx3QkFBd0Isc0JBQUUsZUFBRixFQUMxQixRQUQwQixDQUUxQiw4QkFDQSxlQURBLENBRjBCLENBSzFCLElBTDBCLENBS3JCLE1BTHFCLEVBS2IsUUFMYSxFQU0xQixLQU4wQixDQU8xQixZQUFXO0FBQ1YsMEJBQXNCLFFBQXRCLENBQStCLGdCQUEvQixFQURVO0lBQVgsRUFHQSxZQUFXO0FBQ1YsMEJBQXNCLFdBQXRCLENBQWtDLGdCQUFsQyxFQURVO0lBQVgsQ0FWMEIsQ0FjMUIsS0FkMEIsQ0FjcEIsWUFBVztBQUNqQiwwQkFBc0IsUUFBdEIsQ0FBK0IsZ0JBQS9CLEVBRGlCO0lBQVgsQ0Fkb0IsQ0FpQjFCLElBakIwQixDQWlCckIsWUFBVztBQUNoQiwwQkFBc0IsV0FBdEIsQ0FBa0MsZ0JBQWxDLEVBRGdCO0lBQVgsQ0FqQnFCLENBb0IxQixTQXBCMEIsQ0FvQmhCLFVBQVMsRUFBVCxFQUFhO0FBQ3ZCLE9BQUcsZUFBSCxHQUR1QjtJQUFiLENBcEJnQixDQXVCMUIsUUF2QjBCLENBdUJqQixnQkF2QmlCLENBQXhCLENBRG1COztBQTBCdkIsT0FBSSw0QkFBNEIsQ0FBQyxLQUFLLHlCQUFMLEdBQWlDLHNCQUFFLFNBQUYsQ0FBakMsQ0FBRCxDQUM5QixRQUQ4QixDQUU5QixhQUNBLG9CQURBLENBRjhCLENBSzlCLElBTDhCLENBS3pCLFFBQVEsU0FBUixDQUx5QixDQU05QixRQU44QixDQU1yQixxQkFOcUIsQ0FBNUIsQ0ExQm1CO0dBQXhCOztBQW1DQSxNQUFJLGdCQUFnQixzQkFBRSxTQUFGLEVBQ2xCLFFBRGtCLENBQ1QsaUJBRFMsRUFFbEIsSUFGa0IsQ0FFYixJQUZhLEVBRVAsT0FGTyxFQUdsQixJQUhrQixDQUdiLEtBSGEsRUFJbEIsU0FKa0IsQ0FJUixnQkFKUSxDQUFoQixDQXhEYzs7QUE4RGxCLG1CQUFpQixJQUFqQixDQUFzQixHQUF0QixFQUEyQixHQUEzQixDQUErQixnQkFBL0IsRUFBaUQsZ0JBQWpELEdBOURrQjtFQUFYOztBQWlFVCxVQUFTLG1CQUFXO0FBQ25CLE9BQUssT0FBTCxDQUNFLE1BREYsQ0FDUyxTQURULEVBRUUsVUFGRixDQUVhLFFBRmIsRUFHRSxXQUhGLENBR2MscUNBSGQsRUFJRSxJQUpGLEdBSVMsUUFKVCxDQUlrQixNQUpsQixFQURtQjs7QUFPbkIsTUFBQyxDQUFLLGFBQUwsSUFBc0IsS0FBSyxPQUFMLENBQWEsSUFBYixDQUFrQixPQUFsQixFQUEyQixLQUFLLGFBQUwsQ0FBakQsQ0FQa0I7RUFBWDtDQWxFVjs7QUE2RUEsaUJBQUUsTUFBRixDQUFTLGlCQUFFLElBQUYsQ0FBTyxRQUFQLEVBQWlCO0FBQ3pCLFVBQVMsT0FBVDtBQUNBLFVBQVM7QUFDUixTQUFPLEVBQVA7QUFDQSxlQUFhLEtBQWI7QUFDQSxhQUFXLE9BQVg7RUFIRDs7QUFNQSxPQUFNLENBQU47O0FBRUEsYUFBWSxvQkFBUyxHQUFULEVBQWM7QUFDekIsU0FBTyxzQkFBc0IsSUFBSSxJQUFKLENBQVMsSUFBVCxLQUFrQixFQUFFLEtBQUssSUFBTCxDQUExQyxDQURrQjtFQUFkO0NBVmI7OztBQ3RUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNW5DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQzFFQSxpQkFBRSxFQUFGLENBQUssTUFBTCxDQUFZO0FBQ1gsZUFBYyxzQkFBUyxJQUFULEVBQWU7QUFDNUIsU0FBTyxzQkFBRSxJQUFGLEVBQVEsSUFBUixDQUFhLFlBQVc7QUFDOUIsT0FBRyxzQkFBRSxJQUFGLEVBQVEsSUFBUixDQUFhLFlBQWIsQ0FBSCxFQUErQixPQUEvQjs7QUFFQSx5QkFBRSxJQUFGLEVBQVEsUUFBUixDQUFpQixRQUFqQixFQUEyQixRQUEzQixDQUFvQywwQkFBcEMsRUFIOEI7O0FBSzlCLE9BQUksU0FBUyxzQkFBRSxJQUFGLEVBQVEsT0FBUixDQUFnQixtQkFBaEIsQ0FBVDtPQUNILFNBQVMsaUJBQUUsTUFBRixDQUFTLFFBQVEsRUFBUixFQUFZLHNCQUFFLElBQUYsRUFBUSxJQUFSLEVBQXJCLEVBQXFDLHNCQUFFLElBQUYsRUFBUSxJQUFSLENBQWEsZ0JBQWIsQ0FBckMsRUFBcUUsRUFBckUsQ0FBVCxDQU42QjtBQU85QixPQUFHLENBQUMsT0FBTyxZQUFQLEVBQXFCLE9BQXpCOztBQUVBLE9BQUcsT0FBTyxNQUFQLElBQWlCLGlCQUFFLFVBQUYsQ0FBYSxRQUFiLENBQXNCLE9BQU8sTUFBUCxDQUF2QyxFQUF1RDtBQUN6RCxhQUFTLGlCQUFFLE1BQUYsQ0FBUyxNQUFULEVBQWlCLGlCQUFFLFVBQUYsQ0FBYSxRQUFiLENBQXNCLE9BQU8sTUFBUCxDQUF2QyxFQUF1RCxFQUF2RCxDQUFULENBRHlEO0lBQTFEOztBQUlBLE9BQUcsT0FBTyxHQUFQLEVBQVksT0FBTyxPQUFQLEdBQWlCLGlCQUFFLFVBQUYsQ0FBYSxTQUFiLENBQXVCLFVBQXZCLEVBQW1DLE9BQU8sR0FBUCxDQUFwRCxDQUFmO0FBQ0EsT0FBRyxPQUFPLEdBQVAsRUFBWSxPQUFPLE9BQVAsR0FBaUIsaUJBQUUsVUFBRixDQUFhLFNBQWIsQ0FBdUIsVUFBdkIsRUFBbUMsT0FBTyxHQUFQLENBQXBELENBQWY7O0FBSUEsVUFBTyxVQUFQLEdBQW9CLE9BQU8sZ0JBQVAsQ0FsQlU7QUFtQjlCLHlCQUFFLElBQUYsRUFBUSxVQUFSLENBQW1CLE1BQW5CLEVBbkI4QjtHQUFYLENBQXBCLENBRDRCO0VBQWY7Q0FEZjs7QUEwQkEsc0JBQUUsUUFBRixFQUFZLEVBQVosQ0FBZSxPQUFmLEVBQXdCLHdDQUF4QixFQUFrRSxZQUFXO0FBQzVFLHVCQUFFLElBQUYsRUFBUSxZQUFSLEdBRDRFOztBQUc1RSxLQUFHLHNCQUFFLElBQUYsRUFBUSxJQUFSLENBQWEsWUFBYixDQUFILEVBQStCO0FBQzlCLHdCQUFFLElBQUYsRUFBUSxVQUFSLENBQW1CLE1BQW5CLEVBRDhCO0VBQS9CO0NBSGlFLENBQWxFOzs7Ozs7Ozs7Ozs7Ozs7QUN6QkEsaUJBQUUsT0FBRixDQUFVLElBQVYsRUFBZ0IsVUFBUyxDQUFULEVBQVk7QUFDM0IsR0FBRSxlQUFGLEVBQW1CLE9BQW5CLENBQTJCOztBQU0xQixVQUFRLGdCQUFTLFFBQVQsRUFBbUIsZUFBbkIsRUFBb0M7QUFDM0MsT0FBSSxPQUFPLElBQVA7T0FBYSxPQUFPLEtBQUssT0FBTCxDQUFhLE1BQWIsQ0FBUDtPQUNoQixnQkFBZ0IsS0FBSyxJQUFMLENBQVUsY0FBVixFQUEwQixJQUExQixDQUErQixNQUEvQixDQUFoQjtPQUNBLE9BQU8sS0FBSyxJQUFMLENBQVUsUUFBVixFQUFvQixjQUFwQixFQUFQLENBSDBDOztBQUszQyxPQUFHLENBQUMsUUFBRCxFQUFXLFdBQVcsRUFBWCxDQUFkO0FBQ0EsT0FBRyxDQUFDLFNBQVMsSUFBVCxFQUFlLFNBQVMsSUFBVCxHQUFnQixFQUFoQixDQUFuQjtBQUNBLFlBQVMsSUFBVCxHQUFnQixTQUFTLElBQVQsQ0FBYyxNQUFkLENBQXFCLElBQXJCLENBQWhCLENBUDJDOztBQVkzQyxPQUFHLE9BQU8sUUFBUCxDQUFnQixNQUFoQixFQUF3QjtBQUMxQixhQUFTLElBQVQsR0FBZ0IsT0FBTyxRQUFQLENBQWdCLE1BQWhCLENBQXVCLE9BQXZCLENBQStCLEtBQS9CLEVBQXNDLEVBQXRDLElBQTRDLEdBQTVDLEdBQWtELEVBQUUsS0FBRixDQUFRLFNBQVMsSUFBVCxDQUExRCxDQURVO0lBQTNCOztBQUlBLFFBQUssUUFBTCxDQUFjLFNBQWQsRUFoQjJDOztBQWtCM0MsS0FBRSxJQUFGLENBQU8sRUFBRSxNQUFGLENBQVMsRUFBVCxFQUFhO0FBQ25CLGFBQVMsRUFBQyxVQUFXLGNBQVgsRUFBVjtBQUNBLFVBQU0sTUFBTjtBQUNBLFNBQUssS0FBSyxJQUFMLENBQVUsS0FBVixDQUFMO0FBQ0EsY0FBVSxNQUFWO0FBQ0EsYUFBUyxpQkFBUyxJQUFULEVBQWU7QUFJdkIsVUFBSyxLQUFMLEdBQWEsTUFBYixDQUFvQixFQUFFLElBQUYsRUFBUSxRQUFSLEVBQXBCLEVBSnVCOztBQVF2QixTQUFHLGFBQUgsRUFBa0IsS0FBSyxJQUFMLENBQVUsa0JBQWtCLGFBQWxCLEdBQWtDLElBQWxDLENBQVYsQ0FBa0QsS0FBbEQsR0FBbEI7O0FBR0EsU0FBRyxLQUFLLElBQUwsQ0FBVSxnQkFBVixFQUE0QixNQUE1QixFQUFvQztBQUN0QyxVQUFJLE9BQUosQ0FEc0M7QUFFdEMsVUFBRyxTQUFTLElBQVQsQ0FBYyxDQUFkLEVBQWlCLE1BQWpCLElBQXlCLE1BQXpCLEVBQWlDO0FBQ25DLGlCQUFVLG9DQUFWLENBRG1DO0FBRW5DLFlBQUssUUFBTCxDQUFjLGFBQWQsRUFBNkIsSUFBN0IsQ0FBa0MsZ0JBQWxDLEVBQW9ELElBQXBELEdBRm1DO09BQXBDLE1BR087QUFDTixpQkFBVSw4RkFBVixDQURNO0FBRU4sWUFBSyxXQUFMLENBQWlCLGFBQWpCLEVBQWdDLElBQWhDLENBQXFDLGdCQUFyQyxFQUF1RCxJQUF2RCxHQUZNO09BSFA7O0FBUUEsV0FBSyxJQUFMLENBQVUsMEJBQVYsRUFBc0MsSUFBdEMsQ0FBMkMsT0FBM0MsRUFWc0M7TUFBdkM7O0FBYUEsVUFBSyxXQUFMLENBQWlCLFNBQWpCLEVBeEJ1QjtBQXlCdkIsU0FBRyxlQUFILEVBQW9CLGdCQUFnQixLQUFoQixDQUFzQixJQUF0QixFQUE0QixTQUE1QixFQUFwQjtBQUNBLFVBQUssT0FBTCxDQUFhLFFBQWIsRUFBdUIsSUFBdkIsRUExQnVCO0tBQWY7QUE0QlQsV0FBTyxlQUFTLENBQVQsRUFBWTtBQUNsQixXQUFNLGVBQUssRUFBTCxDQUFRLDhCQUFSLENBQU4sRUFEa0I7QUFFbEIsVUFBSyxXQUFMLENBQWlCLFNBQWpCLEVBRmtCO0tBQVo7SUFqQ0QsRUFxQ0osUUFyQ0ksQ0FBUCxFQWxCMkM7R0FBcEM7QUF5RFIsa0JBQWdCLHdCQUFTLEdBQVQsRUFBYztBQUM3QixVQUFPLFFBQVAsQ0FBZ0IsSUFBaEIsR0FBdUIsR0FBdkIsQ0FENkI7R0FBZDtBQUdoQixZQUFVLG9CQUFXO0FBQ3BCLFVBQU8sS0FBSyxJQUFMLENBQVUsb0JBQVYsQ0FBUCxDQURvQjtHQUFYOztBQU9WLFlBQVUsa0JBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUN4QixPQUFJLFFBQVEsS0FBSyxRQUFMLEVBQVIsQ0FEb0I7QUFFeEIsU0FBTSxDQUFOLElBQVcsQ0FBWCxDQUZ3QjtBQUd4QixRQUFLLElBQUwsQ0FBVSxrQkFBa0IsS0FBSyxJQUFMLENBQVUsTUFBVixDQUFsQixHQUFzQyxlQUF0QyxDQUFWLENBQWlFLEdBQWpFLENBQXFFLEtBQUssU0FBTCxDQUFlLEtBQWYsQ0FBckUsRUFId0I7R0FBZjs7QUFRVixZQUFVLG9CQUFXO0FBQ3BCLFVBQU8sS0FBSyxLQUFMLENBQVcsS0FBSyxJQUFMLENBQVUsa0JBQWtCLEtBQUssSUFBTCxDQUFVLE1BQVYsQ0FBbEIsR0FBc0MsZUFBdEMsQ0FBVixDQUFpRSxHQUFqRSxFQUFYLENBQVAsQ0FEb0I7R0FBWDtFQWpGWCxFQUQyQjs7QUF1RjNCLEdBQUUsaUJBQUYsRUFBcUIsT0FBckIsQ0FBNkI7QUFDNUIsZ0JBQWMsd0JBQVc7QUFDeEIsVUFBTyxLQUFLLE9BQUwsQ0FBYSxlQUFiLENBQVAsQ0FEd0I7R0FBWDtFQURmLEVBdkYyQjs7QUErRjNCLEdBQUUsd0NBQUYsRUFBNEMsT0FBNUMsQ0FBb0Q7QUFDbkQsV0FBUyxpQkFBUyxDQUFULEVBQVk7QUFDcEIsS0FBRSxnQkFBRixFQUNFLElBREYsQ0FDTyxNQURQLEVBRUUsSUFGRixDQUVPLGNBRlAsRUFFdUIsS0FGdkIsR0FEb0I7QUFJcEIsUUFBSyxPQUFMLENBQWEsZUFBYixFQUE4QixRQUE5QixDQUF1QyxhQUF2QyxFQUpvQjtBQUtwQixRQUFLLE1BQUwsR0FBYyxJQUFkLENBQW1CLG9DQUFuQixFQUxvQjtBQU1wQixLQUFFLGNBQUYsR0FOb0I7R0FBWjtFQURWLEVBL0YyQjs7QUEyRzNCLEdBQUUsa0NBQUYsRUFBc0MsT0FBdEMsQ0FBOEM7QUFDN0MsV0FBUyxpQkFBUyxDQUFULEVBQVk7QUFDcEIsT0FBRyxFQUFFLEVBQUUsTUFBRixDQUFGLENBQVksT0FBWixDQUFvQixTQUFwQixFQUErQixNQUEvQixFQUF1QztBQUN6QyxTQUFLLE1BQUwsQ0FBWSxDQUFaLEVBRHlDO0FBRXpDLFdBQU8sS0FBUCxDQUZ5QztJQUExQzs7QUFLQSxPQUFJLFdBQVcsS0FBSyxJQUFMLENBQVUsWUFBVixDQUFYLENBTmdCO0FBT3BCLE9BQUcsU0FBUyxNQUFULEVBQWlCLEtBQUssWUFBTCxHQUFvQixjQUFwQixDQUFtQyxTQUFTLElBQVQsQ0FBYyxNQUFkLENBQW5DLEVBQXBCO0dBUFE7QUFTVCxlQUFhLHVCQUFXO0FBQ3ZCLE9BQUcsS0FBSyxJQUFMLENBQVUsWUFBVixFQUF3QixNQUF4QixFQUFnQyxLQUFLLEdBQUwsQ0FBUyxRQUFULEVBQW1CLFNBQW5CLEVBQW5DO0dBRFk7QUFHYixjQUFZLHNCQUFXO0FBQ3RCLFFBQUssR0FBTCxDQUFTLFFBQVQsRUFBbUIsU0FBbkIsRUFEc0I7R0FBWDtFQWJiLEVBM0cyQjs7QUE2SDNCLEdBQUUsdUJBQUYsRUFBMkIsT0FBM0IsQ0FBbUM7QUFDbEMsV0FBUyxpQkFBUyxDQUFULEVBQVc7QUFDbkIsT0FBSSxjQUFZLE1BQVosQ0FEZTtBQUluQixPQUFJLEtBQUssTUFBTCxDQUFZLFFBQVosRUFBc0IsVUFBdEIsQ0FBSixFQUF1QztBQUN0QyxNQUFFLGNBQUYsR0FEc0M7QUFFdEMsV0FGc0M7SUFBdkM7O0FBS0EsT0FBRyxLQUFLLFFBQUwsQ0FBYywyQkFBZCxLQUE4QyxDQUFFLEtBQUssT0FBTCxDQUFhLGVBQWIsRUFBOEIsUUFBOUIsQ0FBdUMsYUFBdkMsQ0FBRixFQUF5RDtBQUN6RyxrQkFBWSxRQUFaLENBRHlHO0lBQTFHOztBQUlBLFFBQUssWUFBTCxHQUFvQixNQUFwQixDQUEyQixFQUFDLE1BQU0sQ0FBQyxFQUFDLE1BQU0sS0FBSyxJQUFMLENBQVUsTUFBVixDQUFOLEVBQXlCLE9BQU8sS0FBSyxHQUFMLEVBQVAsRUFBbUIsUUFBUSxXQUFSLEVBQTlDLENBQU4sRUFBNUIsRUFibUI7QUFjbkIsS0FBRSxjQUFGLEdBZG1CO0dBQVg7O0FBbUJULGFBQVcscUJBQVc7QUFDckIsT0FBSSxNQUFNLEtBQUssT0FBTCxDQUFhLFNBQWIsQ0FBTjtPQUErQixPQUFPLEtBQUssWUFBTCxFQUFQO09BQ2xDLE9BQU8sS0FBSyxPQUFMLENBQWEsTUFBYixDQUFQO09BQTZCLE9BQU8sS0FBSyxJQUFMLENBQVUsa0JBQVYsRUFBOEIsU0FBOUIsRUFBUDtPQUM3QixPQUFPLEtBQUssSUFBTCxDQUFVLDBCQUFWLEVBQXNDLEdBQXRDLEVBQVAsQ0FIb0I7O0FBTXJCLFdBQVEsTUFBTSxtQkFBbUIsSUFBSSxJQUFKLENBQVMsTUFBVCxDQUFuQixDQUFOLEdBQTZDLEdBQTdDLEdBQW1ELG1CQUFtQixJQUFJLEdBQUosRUFBbkIsQ0FBbkQsQ0FOYTs7QUFTckIsT0FBRyxJQUFILEVBQVM7QUFDUixZQUFRLGlCQUFpQixtQkFBbUIsSUFBbkIsQ0FBakIsQ0FEQTtJQUFUOztBQU9BLE9BQUcsT0FBTyxRQUFQLENBQWdCLE1BQWhCLEVBQXdCO0FBQzFCLFdBQU8sT0FBTyxRQUFQLENBQWdCLE1BQWhCLENBQXVCLE9BQXZCLENBQStCLEtBQS9CLEVBQXNDLEVBQXRDLElBQTRDLEdBQTVDLEdBQWtELElBQWxELENBRG1CO0lBQTNCOztBQUtBLE9BQUksWUFBWSxLQUFLLElBQUwsQ0FBVSxLQUFWLEVBQWlCLE9BQWpCLENBQXlCLEdBQXpCLEtBQWlDLENBQUMsQ0FBRCxHQUFLLEdBQXRDLEdBQTRDLEdBQTVDLENBckJLOztBQXVCckIsVUFBTyxFQUFFLElBQUYsQ0FBTyxlQUFQLENBQ04sS0FBSyxJQUFMLENBQVUsS0FBVixJQUFtQixTQUFuQixHQUErQixJQUEvQixFQUNBLEVBQUUsTUFBRixFQUFVLElBQVYsQ0FBZSxNQUFmLENBRk0sQ0FBUCxDQXZCcUI7R0FBWDs7RUFwQlosRUE3SDJCOztBQW1MM0IsR0FBRSwyQ0FBRixFQUErQyxPQUEvQyxDQUF1RDtBQUN0RCxrQkFBZ0IsMEJBQVk7QUFDM0IsT0FBSSxPQUFPLElBQVAsQ0FEdUI7O0FBRzNCLFFBQUssY0FBTCxHQUgyQjs7QUFLM0IsUUFBSyxJQUFMLENBQVUsb0JBQVYsRUFBZ0MsRUFBaEMsQ0FBbUMsT0FBbkMsRUFBNEMsWUFBWTtBQUN2RCxTQUFLLGNBQUwsR0FEdUQ7SUFBWixDQUE1QyxDQUwyQjtHQUFaO0FBU2hCLGFBQVcscUJBQVk7QUFDdEIsUUFBSyxJQUFMLENBQVUsb0JBQVYsRUFBZ0MsR0FBaEMsQ0FBb0MsT0FBcEMsRUFEc0I7R0FBWjtBQUdYLGtCQUFnQiwwQkFBWTtBQUMzQixPQUFJLFVBQVUsS0FBSyxJQUFMLENBQVUsZUFBVixDQUFWO09BQ0gsU0FBUyxLQUFLLElBQUwsQ0FBVSxvQkFBVixDQUFUO09BQ0EsZ0JBQWdCLE9BQU8sR0FBUCxPQUFpQixFQUFqQjtPQUNoQixpQkFBaUIsUUFBUSxFQUFSLENBQVcsV0FBWCxDQUFqQixDQUowQjs7QUFNM0IsT0FBSSxhQUFDLElBQWlCLGNBQWpCLElBQXFDLENBQUMsYUFBRCxJQUFrQixDQUFDLGNBQUQsRUFBa0I7QUFDN0UsWUFBUSxNQUFSLENBQWUsUUFBZixFQUF5QixVQUF6QixFQUFxQyxDQUFDLGNBQUQsQ0FBckMsQ0FENkU7SUFBOUU7R0FOZTtFQWJqQixFQW5MMkI7O0FBNk0zQixHQUFFLGlIQUFGLEVBQXFILE9BQXJILENBQTZIO0FBQzVILFdBQVMsaUJBQVMsQ0FBVCxFQUFXO0FBQ25CLE9BQUcsQ0FBQyxRQUFRLGVBQUssRUFBTCxDQUFRLGlDQUFSLENBQVIsQ0FBRCxFQUFzRDtBQUN4RCxNQUFFLGNBQUYsR0FEd0Q7QUFFeEQsV0FBTyxLQUFQLENBRndEO0lBQXpELE1BR087QUFDTixTQUFLLE1BQUwsQ0FBWSxDQUFaLEVBRE07SUFIUDtHQURRO0VBRFYsRUE3TTJCOztBQXdOM0IsR0FBRSw4Q0FBRixFQUFrRCxPQUFsRCxDQUEwRDtBQUN6RCxRQUFNLElBQU47QUFDQSxXQUFTLG1CQUFXO0FBQ25CLFFBQUssTUFBTCxHQURtQjtBQUVuQixRQUFLLE9BQUwsQ0FBYSxJQUFJLElBQUosR0FBVyxPQUFYLEVBQWIsRUFGbUI7R0FBWDtBQUlULGFBQVcscUJBQVc7QUFDckIsUUFBSyxNQUFMLEdBRHFCO0dBQVg7QUFHWCxXQUFTLGlCQUFTLENBQVQsRUFBVztBQUNuQixPQUFJLE1BQU0sS0FBSyxTQUFMLEVBQU4sQ0FEZTtBQUVuQixVQUFPLElBQVAsQ0FBWSxHQUFaLEVBRm1CO0FBR25CLEtBQUUsY0FBRixHQUhtQjtBQUluQixVQUFPLEtBQVAsQ0FKbUI7R0FBWDtFQVRWLEVBeE4yQjs7QUF5TzNCLEdBQUUsNEJBQUYsRUFBZ0MsT0FBaEMsQ0FBd0M7QUFDdkMsV0FBUyxtQkFBVTtBQUNsQixRQUFLLE1BQUwsR0FEa0I7O0FBR2xCLFFBQUssSUFBTCxHQUFZLElBQVosQ0FBaUIsTUFBakIsRUFBeUIsWUFBVztBQUNuQyxTQUFLLEtBQUwsR0FEbUM7QUFFbkMsUUFBSSxRQUFRLEtBQUssYUFBTCxJQUFzQixJQUF0QixDQUZ1QjtBQUduQyxVQUFNLEtBQU4sR0FIbUM7SUFBWCxDQUF6QixDQUhrQjtHQUFWO0FBU1QsYUFBVyxxQkFBVztBQUNyQixRQUFLLE1BQUwsR0FEcUI7R0FBWDtFQVZaLEVBek8yQjs7QUE4UDNCLEdBQUUsK0JBQUYsRUFBbUMsT0FBbkMsQ0FBMkM7QUFDMUMsV0FBUyxpQkFBUyxDQUFULEVBQVc7QUFDbkIsVUFBTyxRQUFQLENBQWdCLElBQWhCLEdBQXVCLEtBQUssU0FBTCxFQUF2QixDQURtQjtBQUVuQixLQUFFLGNBQUYsR0FGbUI7QUFHbkIsVUFBTyxLQUFQLENBSG1CO0dBQVg7RUFEVixFQTlQMkI7O0FBc1EzQixHQUFFLDhCQUFGLEVBQWtDLE9BQWxDLENBQTBDO0FBQ3pDLFdBQVMsbUJBQVc7QUFDbkIsUUFBSyxZQUFMLEdBQW9CLGNBQXBCLENBQW1DLEVBQUUsSUFBRixFQUFRLElBQVIsQ0FBYSxNQUFiLENBQW5DLEVBRG1CO0FBRW5CLFVBQU8sS0FBUCxDQUZtQjtHQUFYO0VBRFYsRUF0UTJCOztBQWlSM0IsR0FBRSxnQ0FBRixFQUFvQyxPQUFwQyxDQUE0QztBQUkzQyxvQkFBa0IsNEJBQVc7QUFDNUIsVUFBTyxLQUFLLElBQUwsQ0FBVSxnQ0FBVixDQUFQLENBRDRCO0dBQVg7O0FBTWxCLGtCQUFnQiwwQkFBVztBQUMxQixVQUFPLEVBQUUsR0FBRixDQUFNLEtBQUssZ0JBQUwsRUFBTixFQUErQixVQUFTLEVBQVQsRUFBYTtBQUFDLFdBQU8sRUFBRSxFQUFGLEVBQU0sSUFBTixDQUFXLElBQVgsQ0FBUCxDQUFEO0lBQWIsQ0FBdEMsQ0FEMEI7R0FBWDtFQVZqQixFQWpSMkI7QUErUjNCLEdBQUUsb0RBQUYsRUFBd0QsT0FBeEQsQ0FBZ0U7QUFDL0QsU0FBTyxpQkFBVztBQUNqQixRQUFLLE1BQUwsR0FEaUI7O0FBSWpCLFFBQUssVUFBTCxHQUppQjtHQUFYO0FBTVAsWUFBVSxvQkFBVztBQUNwQixRQUFLLE1BQUwsR0FEb0I7QUFFcEIsT0FBSSxLQUFLLElBQUwsQ0FBVSxZQUFWLENBQUosRUFBNkIsS0FBSyxVQUFMLENBQWdCLFNBQWhCLEVBQTdCO0dBRlM7RUFQWCxFQS9SMkI7O0FBZ1QzQixHQUFFLHFDQUFGLEVBQXlDLE9BQXpDLENBQWlEO0FBQ2hELFdBQVMsbUJBQVc7QUFDbkIsT0FBSSxZQUFZLEtBQUssT0FBTCxDQUFhLGFBQWIsRUFBNEIsSUFBNUIsQ0FBaUMsNkJBQWpDLENBQVo7T0FDSCxXQUFXLEtBQUssT0FBTCxDQUFhLGFBQWIsRUFBNEIsSUFBNUIsQ0FBaUMsNEJBQWpDLENBQVgsQ0FGa0I7O0FBSW5CLE9BQUcsS0FBSyxHQUFMLEVBQUgsRUFBZTtBQUNkLGNBQVUsUUFBVixDQUFtQixVQUFuQixFQURjO0FBRWQsYUFBUyxRQUFULENBQWtCLFVBQWxCLEVBRmM7SUFBZjtBQUlBLFFBQUssTUFBTCxHQVJtQjtHQUFYO0FBVVQsYUFBVyxxQkFBVztBQUNyQixRQUFLLE1BQUwsR0FEcUI7R0FBWDtBQUdYLGFBQVcsbUJBQVMsQ0FBVCxFQUFZO0FBRXRCLE9BQUcsS0FBSyxPQUFMLENBQWEsNEJBQWIsRUFBMkMsTUFBM0MsRUFBbUQsT0FBdEQ7O0FBRUEsT0FBSSxZQUFZLEtBQUssT0FBTCxDQUFhLGFBQWIsRUFBNEIsSUFBNUIsQ0FBaUMsNkJBQWpDLENBQVo7T0FDSCxXQUFXLEtBQUssT0FBTCxDQUFhLGFBQWIsRUFBNEIsSUFBNUIsQ0FBaUMsNEJBQWpDLENBQVgsQ0FMcUI7O0FBT3RCLE9BQUcsRUFBRSxPQUFGLElBQWEsSUFBYixFQUFtQjtBQUNyQixRQUFJLE9BQU8sS0FBSyxPQUFMLENBQWEsZ0JBQWIsRUFBK0IsSUFBL0IsQ0FBb0MsNkJBQXBDLENBQVAsQ0FEaUI7QUFFckIsUUFBSSxjQUFZLE1BQVosQ0FGaUI7QUFHckIsUUFBRyxLQUFLLFFBQUwsQ0FBYywyQkFBZCxLQUE0QyxDQUFFLEtBQUssT0FBTCxDQUFhLGVBQWIsRUFBOEIsUUFBOUIsQ0FBdUMsYUFBdkMsQ0FBRixFQUF5RDtBQUN2RyxtQkFBWSxRQUFaLENBRHVHO0tBQXhHOztBQUlBLFNBQUssWUFBTCxHQUFvQixNQUFwQixDQUEyQixFQUFDLE1BQU0sQ0FBQyxFQUFDLE1BQU0sS0FBSyxJQUFMLENBQVUsTUFBVixDQUFOLEVBQXlCLE9BQU8sS0FBSyxHQUFMLEVBQVAsRUFBbUIsUUFBUSxXQUFSLEVBQTlDLENBQU4sRUFBNUIsRUFQcUI7QUFRckIsV0FBTyxLQUFQLENBUnFCO0lBQXRCLE1BU0s7QUFDSixjQUFVLFFBQVYsQ0FBbUIsYUFBbkIsRUFESTtBQUVKLGFBQVMsUUFBVCxDQUFrQixhQUFsQixFQUZJO0lBVEw7R0FQVTtFQWRaLEVBaFQyQjs7QUFxVjNCLEdBQUUsZ0NBQUYsRUFBb0MsT0FBcEMsQ0FBNEM7QUFDM0MsYUFBVyxtQkFBVSxLQUFWLEVBQWlCO0FBQzNCLFFBQUssWUFBTCxDQUFrQjtBQUNqQixZQUFRLGdCQUFTLE9BQVQsRUFBa0IsUUFBbEIsRUFBMkI7QUFDbEMsU0FBSSxjQUFjLEVBQUUsS0FBSyxPQUFMLENBQWhCLENBRDhCO0FBRWxDLFNBQUksT0FBTyxFQUFFLEtBQUssT0FBTCxDQUFGLENBQWdCLE9BQWhCLENBQXdCLE1BQXhCLENBQVAsQ0FGOEI7QUFHbEMsT0FBRSxJQUFGLENBQU87QUFDTixlQUFTO0FBQ1IsaUJBQVcsU0FBWDtPQUREO0FBR0EsWUFBTSxLQUFOO0FBQ0EsV0FBSyxFQUFFLFdBQUYsRUFBZSxJQUFmLENBQW9CLFdBQXBCLENBQUw7QUFDQSxZQUFNLG1CQUFtQixZQUFZLElBQVosQ0FBaUIsTUFBakIsQ0FBbkIsSUFBNkMsR0FBN0MsR0FBaUQsbUJBQW1CLFlBQVksR0FBWixFQUFuQixDQUFqRDtBQUNOLGVBQVMsaUJBQVMsSUFBVCxFQUFlO0FBQ3ZCLGdCQUFVLEVBQUUsR0FBRixDQUFNLEtBQUssS0FBTCxDQUFXLElBQVgsQ0FBTixFQUF3QixVQUFVLElBQVYsRUFBZ0IsRUFBaEIsRUFBcUI7QUFDdEQsZUFBTyxFQUFFLE9BQU8sSUFBUCxFQUFhLE9BQU8sSUFBUCxFQUFhLElBQUksRUFBSixFQUFuQyxDQURzRDtRQUFyQixDQUFsQyxFQUR1QjtPQUFmO0FBS1QsYUFBTyxlQUFTLENBQVQsRUFBWTtBQUNsQixhQUFNLGVBQUssRUFBTCxDQUFRLDhCQUFSLEVBQXdDLGdGQUF4QyxDQUFOLEVBRGtCO09BQVo7TUFaUixFQUhrQztLQUEzQjtBQW9CUixZQUFRLGdCQUFTLEtBQVQsRUFBZ0IsRUFBaEIsRUFBb0I7QUFDM0IsT0FBRSxJQUFGLEVBQVEsT0FBUixDQUFnQixlQUFoQixFQUFpQyxJQUFqQyxDQUFzQyxnQ0FBdEMsRUFBd0UsV0FBeEUsQ0FDQyxtREFBaUQsR0FBRyxJQUFILENBQVEsRUFBUixHQUFXLHFCQUE1RCxDQURELENBRDJCO0FBSTNCLFNBQUksWUFBWSxFQUFFLElBQUYsRUFBUSxPQUFSLENBQWdCLGVBQWhCLEVBQWlDLElBQWpDLENBQXNDLCtCQUF0QyxDQUFaLENBSnVCO0FBSzNCLFNBQUcsVUFBVSxJQUFWLENBQWUsUUFBZixDQUFILEVBQTRCO0FBQzNCLGdCQUFVLE1BQVYsQ0FBaUIsUUFBakIsRUFEMkI7TUFBNUIsTUFFSztBQUNKLGdCQUFVLFVBQVYsQ0FBcUIsVUFBckIsRUFESTtNQUZMO0tBTE87SUFyQlQsRUFEMkI7R0FBakI7RUFEWixFQXJWMkI7O0FBMlgzQixHQUFFLDZDQUFGLEVBQWlELE9BQWpELENBQXlEO0FBQ3hELGFBQVcsbUJBQVMsS0FBVCxFQUFnQjtBQUMxQixPQUFHLE1BQU0sT0FBTixJQUFpQixFQUFqQixFQUFxQjtBQUN2QixRQUFJLFVBQVUsU0FBUyxFQUFFLElBQUYsRUFBUSxHQUFSLEVBQVQsRUFBd0IsRUFBeEIsQ0FBVixDQURtQjs7QUFHdkIsUUFBSSxZQUFZLEVBQUUsSUFBRixFQUFRLFlBQVIsRUFBWixDQUhtQjtBQUl2QixjQUFVLFFBQVYsQ0FBbUIsb0JBQW5CLEVBQXlDLEVBQUMsYUFBYSxPQUFiLEVBQTFDLEVBSnVCO0FBS3ZCLGNBQVUsTUFBVixHQUx1Qjs7QUFPdkIsV0FBTyxLQUFQLENBUHVCO0lBQXhCO0dBRFU7RUFEWixFQTNYMkI7Q0FBWixDQUFoQjs7Ozs7Ozs7Ozs7Ozs7O0FDUUEsSUFBSSxLQUFLLE9BQU8sT0FBTyxFQUFQLEtBQWMsV0FBckIsR0FBbUMsT0FBTyxFQUFQLEdBQVksRUFBL0M7O0FBT1QsR0FBRyxjQUFILEdBQW9CLEVBQXBCO0FBQ0EsR0FBRyxjQUFILENBQWtCLE9BQWxCLEdBQTZCLFlBQVc7QUFHdkMsS0FBSSxRQUFKLENBSHVDOztBQUt2QyxRQUFPO0FBTU4sUUFBTSxjQUFTLEVBQVQsRUFBYTtBQUNsQixjQUFXLEVBQVgsQ0FEa0I7O0FBR2xCLFFBQUssTUFBTCxHQUhrQjtHQUFiOztBQVNOLFdBQVMsbUJBQVc7QUFDbkIsV0FBUSxhQUFSLENBQXNCLFdBQXRCLENBQWtDLGlCQUFsQyxFQUFxRCxLQUFyRCxFQUE0RCxRQUE1RCxFQURtQjtHQUFYOztBQVNULGVBQWEsdUJBQVc7QUFDdkIsVUFBTyxRQUFRLGFBQVIsQ0FBc0IsR0FBdEIsQ0FBMEIsUUFBMUIsQ0FBUCxDQUR1QjtHQUFYOztBQU9iLFVBQVEsa0JBQVcsRUFBWDs7QUFPUixXQUFTLG1CQUFXLEVBQVg7O0FBU1QsYUFBVyxxQkFBVztBQUNyQixPQUFJLFdBQVcsTUFBTSxRQUFOO09BQ2QsU0FBUyxzQkFBRSxRQUFGLEVBQVksSUFBWixDQUFpQixRQUFqQixDQUFUO09BQ0EsT0FBTyxJQUFQLENBSG9COztBQU1yQixVQUFPLFFBQVAsR0FBa0IsUUFBbEIsQ0FOcUI7O0FBU3JCLFVBQU8sS0FBUCxHQUFlLFVBQVMsRUFBVCxFQUFhO0FBQzNCLE9BQUcsRUFBSCxDQUFNLFFBQU4sRUFBZ0IsWUFBVztBQUMxQixVQUFLLElBQUwsR0FEMEI7S0FBWCxDQUFoQixDQUQyQjtJQUFiLENBVE07QUFjckIsVUFBTyxNQUFQLENBZHFCO0dBQVg7O0FBb0JYLFFBQU0sZ0JBQVc7QUFDaEIsT0FBSSxXQUFXLEtBQUssV0FBTCxFQUFYLENBRFk7QUFFaEIsWUFBUyxJQUFULEdBRmdCOztBQUtoQix5QkFBRSxTQUFTLFVBQVQsRUFBRixFQUF5QixPQUF6QixDQUFpQyxRQUFqQyxFQUxnQjtHQUFYOztBQVdOLFVBQVEsa0JBQVc7QUFDbEIsT0FBSSxTQUFTLEtBQUssU0FBTCxFQUFULENBRGM7O0FBR2xCLE9BQUcsT0FBTyxPQUFPLE9BQVAsS0FBbUIsV0FBMUIsRUFBdUM7QUFDekMsWUFBUSxhQUFSLENBQXNCLE9BQXRCLEdBQWdDLE9BQU8sT0FBUCxDQURTO0lBQTFDO0FBR0EsV0FBUSxJQUFSLENBQWEsTUFBYixFQU5rQjtHQUFYOztBQVlSLFdBQVMsbUJBQVcsRUFBWDs7QUFPVCxXQUFTLG1CQUFXO0FBQ25CLFVBQU8sS0FBSyxXQUFMLEdBQW1CLE9BQW5CLEVBQVAsQ0FEbUI7R0FBWDs7QUFTVCxjQUFZLHNCQUFXO0FBQ3RCLFVBQU8sS0FBSyxXQUFMLEdBQW1CLFVBQW5CLEVBQVAsQ0FEc0I7R0FBWDs7QUFTWixVQUFRLGtCQUFXO0FBQ2xCLFVBQU8sS0FBSyxXQUFMLEdBQW1CLFVBQW5CLEVBQVAsQ0FEa0I7R0FBWDs7QUFPUixnQkFBYyx3QkFBVztBQUN4QixVQUFPLEtBQUssV0FBTCxHQUFtQixZQUFuQixFQUFQLENBRHdCO0dBQVg7O0FBU2QsbUJBQWlCLDJCQUFXO0FBQzNCLFVBQU8sS0FBSyxXQUFMLEdBQW1CLFNBQW5CLENBQTZCLE9BQTdCLEVBQVAsQ0FEMkI7R0FBWDs7QUFTakIsY0FBWSxvQkFBUyxJQUFULEVBQWU7QUFDMUIsUUFBSyxXQUFMLEdBQW1CLFNBQW5CLENBQTZCLE1BQTdCLENBQW9DLElBQXBDLEVBRDBCO0dBQWY7O0FBVVosY0FBWSxvQkFBUyxJQUFULEVBQWUsSUFBZixFQUFxQjtBQUNoQyxRQUFLLFdBQUwsR0FBbUIsVUFBbkIsQ0FBOEIsSUFBOUIsRUFBb0MsSUFBcEMsRUFEZ0M7R0FBckI7O0FBVVosaUJBQWUsdUJBQVMsSUFBVCxFQUFlLElBQWYsRUFBcUI7QUFDbkMsUUFBSyxXQUFMLEdBQW1CLGFBQW5CLENBQWlDLElBQWpDLEVBQXVDLElBQXZDLEVBRG1DO0dBQXJCOztBQVFmLGtCQUFnQix3QkFBUyxJQUFULEVBQWUsSUFBZixFQUFxQjtBQUNwQyxRQUFLLFdBQUwsR0FBbUIsV0FBbkIsQ0FBK0IsbUJBQS9CLEVBQW9ELEtBQXBELEVBQTJELElBQTNELEVBQWlFLElBQWpFLEVBRG9DO0dBQXJCOztBQVFoQixjQUFZLG9CQUFTLEtBQVQsRUFBZ0IsSUFBaEIsRUFBc0I7QUFDakMsUUFBSyxXQUFMLEdBQW1CLFdBQW5CLENBQStCLGVBQS9CLEVBQWdELEtBQWhELEVBQXVELEtBQXZELEVBQThELElBQTlELEVBRGlDO0dBQXRCOztBQU1aLGNBQVksc0JBQVc7QUFDdEIsUUFBSyxXQUFMLEdBQW1CLFdBQW5CLENBQStCLFFBQS9CLEVBQXlDLEtBQXpDLEVBRHNCO0dBQVg7O0FBVVosYUFBVyxtQkFBUyxJQUFULEVBQWUsSUFBZixFQUFxQjtBQUMvQixPQUFJLFdBQVcsS0FBSyxTQUFMO09BQ2QsS0FBSyxTQUFTLHVCQUFULENBQUwsQ0FGOEI7QUFHL0IsT0FBRyxFQUFILEVBQU8sT0FBTyxLQUFLLEtBQUsscUJBQUwsQ0FBWixDQUFQOztBQUdBLE9BQUcsS0FBSyxLQUFMLENBQVcsSUFBSSxNQUFKLENBQVcsTUFBTSxRQUFRLFFBQVIsQ0FBaUIsbUJBQWpCLENBQU4sR0FBOEMsT0FBOUMsQ0FBdEIsQ0FBSCxFQUFrRjtBQUNqRixXQUFPLE9BQU8sRUFBUCxDQUQwRTtJQUFsRjs7QUFLQSxPQUFHLEtBQUssS0FBTCxDQUFXLHNCQUFYLENBQUgsRUFBdUMsT0FBTyxFQUFQLENBQXZDOztBQUVBLFVBQU8sSUFBUCxDQWIrQjtHQUFyQjs7QUFvQlgsa0JBQWdCLDBCQUFXO0FBQzFCLFVBQU8sS0FBSyxXQUFMLEdBQW1CLFNBQW5CLENBQTZCLFdBQTdCLEVBQVAsQ0FEMEI7R0FBWDs7QUFPaEIsa0JBQWdCLHdCQUFTLFFBQVQsRUFBbUI7QUFDbEMsUUFBSyxXQUFMLEdBQW1CLFNBQW5CLENBQTZCLGNBQTdCLENBQTRDLFFBQTVDLEVBRGtDO0FBRWxDLFFBQUssV0FBTCxHQUFtQixLQUFuQixHQUZrQztHQUFuQjs7QUFPaEIsUUFBTSxnQkFBVztBQUNoQixRQUFLLFdBQUwsR0FBbUIsU0FBbkIsQ0FBNkIsUUFBN0IsR0FEZ0I7R0FBWDs7QUFNTixXQUFTLG1CQUFXO0FBQ25CLFFBQUssV0FBTCxHQUFtQixXQUFuQixDQUErQixHQUEvQixHQURtQjtHQUFYO0VBeE9WLENBTHVDO0NBQVg7O0FBbVA3QixHQUFHLGNBQUgsQ0FBa0IsU0FBbEIsSUFBK0IsR0FBRyxjQUFILENBQWtCLE9BQWxCOztBQUUvQixpQkFBRSxPQUFGLENBQVUsSUFBVixFQUFnQixVQUFTLENBQVQsRUFBWTtBQVMzQixHQUFFLHFCQUFGLEVBQXlCLE9BQXpCLENBQWlDOztBQUVoQyxVQUFRLElBQVI7O0FBS0EsU0FBTyxpQkFBVztBQUNqQixPQUFJLFVBQVUsS0FBSyxJQUFMLENBQVUsUUFBVixLQUF1QixTQUF2QjtPQUNiLEtBQUssR0FBRyxjQUFILENBQWtCLE9BQWxCLEdBQUwsQ0FGZ0I7QUFHakIsUUFBSyxTQUFMLENBQWUsRUFBZixFQUhpQjs7QUFLakIsTUFBRyxJQUFILENBQVEsS0FBSyxJQUFMLENBQVUsSUFBVixDQUFSLEVBTGlCOztBQU9qQixRQUFLLE1BQUwsR0FQaUI7R0FBWDs7QUFhUCxZQUFVLG9CQUFXO0FBQ3BCLFFBQUssU0FBTCxHQUFpQixPQUFqQixHQURvQjtBQUVwQixRQUFLLE1BQUwsR0FGb0I7R0FBWDs7QUFRVix5QkFBdUI7QUFDdEIsdUJBQW9CLDhCQUFXO0FBQzlCLFNBQUssU0FBTCxHQUFpQixJQUFqQixHQUQ4QjtBQUU5QixTQUFLLE1BQUwsR0FGOEI7SUFBWDtHQURyQjs7QUFXQSxrQkFBZ0IsMEJBQVc7QUFDMUIsUUFBSyxVQUFMLENBQWdCLE1BQWhCLEVBRDBCO0dBQVg7O0FBUWhCLG1CQUFpQiwyQkFBVztBQUMzQixRQUFLLFVBQUwsQ0FBZ0IsT0FBaEIsRUFEMkI7R0FBWDs7QUFJakIsY0FBWSxvQkFBUyxJQUFULEVBQWU7QUFDMUIsT0FBSSxhQUFhLFNBQWIsVUFBYSxDQUFTLElBQVQsRUFBZTtBQUMvQixXQUFPLEtBQUssTUFBTCxDQUFZLENBQVosRUFBZSxXQUFmLEtBQStCLEtBQUssS0FBTCxDQUFXLENBQVgsRUFBYyxXQUFkLEVBQS9CLENBRHdCO0lBQWYsQ0FEUzs7QUFLMUIsT0FBSSxPQUFPLElBQVA7T0FDSCxNQUFNLEVBQUUscUJBQUYsRUFBeUIsSUFBekIsQ0FBOEIsUUFBUSxXQUFXLElBQVgsQ0FBUixHQUEyQixNQUEzQixDQUFwQztPQUNBLFNBQVMsRUFBRSxzQkFBc0IsSUFBdEIsR0FBNkIsUUFBN0IsQ0FBWCxDQVB5Qjs7QUFTMUIsT0FBRyxPQUFPLE1BQVAsRUFBZTtBQUVqQixXQUFPLE9BQVAsR0FBaUIsVUFBakIsQ0FBNEIsSUFBNUIsRUFGaUI7QUFHakIsV0FBTyxJQUFQLENBQVksRUFBWixFQUhpQjtBQUlqQixXQUFPLFFBQVAsQ0FBZ0IsU0FBaEIsRUFKaUI7QUFLakIsV0FBTyxJQUFQLEdBTGlCO0lBQWxCLE1BTU87QUFHTixhQUFTLEVBQUUsd0RBQXdELElBQXhELEdBQStELGtCQUEvRCxDQUFYLENBSE07QUFJTixNQUFFLE1BQUYsRUFBVSxNQUFWLENBQWlCLE1BQWpCLEVBSk07SUFOUDs7QUFhQSxLQUFFLElBQUYsQ0FBTztBQUNOLFNBQUssR0FBTDtBQUNBLGNBQVUsb0JBQVc7QUFDcEIsWUFBTyxXQUFQLENBQW1CLFNBQW5CLEVBRG9CO0tBQVg7QUFHVixhQUFTLGlCQUFTLElBQVQsRUFBZTtBQUN2QixZQUFPLElBQVAsQ0FBWSxJQUFaLEVBRHVCO0FBRXZCLFlBQU8sT0FBUCxHQUFpQixVQUFqQixDQUE0QixJQUE1QixFQUZ1QjtBQUd2QixZQUFPLE9BQVAsQ0FBZSxjQUFmLEVBSHVCO0tBQWY7SUFMVixFQXRCMEI7R0FBZjtFQW5EYixFQVQyQjs7QUFnRzNCLEdBQUUseUJBQUYsRUFBNkIsT0FBN0IsQ0FBcUM7QUFDcEMsU0FBTyxpQkFBVztBQUdqQixPQUFJLENBQUMsS0FBSyxFQUFMLENBQVEsb0JBQVIsQ0FBRCxFQUFnQztBQUNuQyxTQUFLLFFBQUwsQ0FBYztBQUNiLGVBQVUsSUFBVjtBQUNBLGNBQVM7QUFDUixnQkFBVTtBQUNULGFBQU0sZUFBSyxFQUFMLENBQ0wsd0JBREssRUFFTCxRQUZLLENBQU47QUFJQSxvQkFBYSxRQUFiO0FBQ0EsY0FBTyx3Q0FBUDtBQUNBLGNBQU8saUJBQVc7QUFDakIsVUFBRSxJQUFGLEVBQVEsSUFBUixDQUFhLE1BQWIsRUFBcUIsTUFBckIsR0FEaUI7UUFBWDtPQVBSO01BREQ7S0FGRCxFQURtQztJQUFwQzs7QUFtQkEsUUFBSyxNQUFMLEdBdEJpQjtHQUFYOztBQXlCUCxXQUFTLG1CQUFXO0FBQ25CLFVBQU8sS0FBSyxJQUFMLENBQVUsTUFBVixDQUFQLENBRG1CO0dBQVg7QUFHVCxRQUFNLGdCQUFXO0FBQ2hCLFFBQUssUUFBTCxDQUFjLE1BQWQsRUFEZ0I7R0FBWDtBQUdOLFNBQU8saUJBQVc7QUFDakIsUUFBSyxRQUFMLENBQWMsT0FBZCxFQURpQjtHQUFYO0FBR1AsVUFBUSxnQkFBUyxJQUFULEVBQWU7QUFDdEIsT0FBRyxLQUFLLEVBQUwsQ0FBUSxVQUFSLENBQUgsRUFBd0IsS0FBSyxLQUFMLEdBQXhCLEtBQ0ssS0FBSyxJQUFMLEdBREw7R0FETztBQUlSLFlBQVUsb0JBQVk7QUFDckIsUUFBSyxPQUFMLENBQWE7QUFDWixlQUFXLEtBQUssSUFBTCxDQUFVLE1BQVYsRUFBa0IsTUFBbEIsRUFBWDtJQURELEVBRUcsR0FGSCxFQURxQjtHQUFaO0VBdkNYLEVBaEcyQjs7QUFrSjNCLEdBQUUsMkJBQUYsRUFBK0IsT0FBL0IsQ0FBdUM7QUFDdEMsYUFBVyxJQUFYOztBQUdBLFlBQVUsSUFBVjs7QUFHQSxXQUFTLElBQVQ7O0FBRUEsZ0JBQWMsc0JBQVMsSUFBVCxFQUFlO0FBQzVCLFVBQU8sS0FBSyxNQUFMLENBQVksRUFBRSxJQUFGLENBQVosQ0FBUCxDQUQ0QjtHQUFmOztBQUlkLFNBQU8saUJBQVc7QUFFakIsT0FBSSxVQUFVLEtBQUssSUFBTCxDQUFVLGVBQVYsQ0FBVixDQUZhO0FBR2pCLFFBQUssU0FBTCxHQUFpQixJQUFqQixDQUFzQixPQUF0QixFQUErQixRQUFRLElBQVIsRUFBL0IsRUFIaUI7O0FBS2pCLFFBQUssTUFBTCxHQUxpQjtHQUFYO0FBT1AsWUFBVSxvQkFBVztBQUNwQixRQUFLLFlBQUwsQ0FBa0IsSUFBbEIsRUFEb0I7QUFFcEIsUUFBSyxXQUFMLENBQWlCLElBQWpCLEVBRm9CO0FBR3BCLFFBQUssVUFBTCxDQUFnQixJQUFoQixFQUhvQjs7QUFLcEIsUUFBSyxNQUFMLEdBTG9CO0dBQVg7O0FBUVYsYUFBVyxxQkFBVztBQUVyQixVQUFPLEtBQUssT0FBTCxDQUFhLHlCQUFiLENBQVAsQ0FGcUI7R0FBWDs7QUFLWCxjQUFZO0FBQ1gsbUJBQWdCLDBCQUFVO0FBQ3pCLFFBQUksS0FBSyxLQUFLLFNBQUwsRUFBTCxDQURxQjs7QUFHekIsU0FBSyxZQUFMLENBQWtCLEdBQUcsZUFBSCxFQUFsQixFQUh5QjtBQUl6QixTQUFLLFdBQUwsQ0FBaUIsR0FBRyxjQUFILEVBQWpCLEVBSnlCOztBQU16QixPQUFHLElBQUgsR0FOeUI7O0FBUXpCLFNBQUssSUFBTCxDQUFVLGtEQUFWLEVBQ0UsTUFERixDQUNTLGtCQURULEVBRUUsRUFGRixDQUVLLENBRkwsRUFHRSxLQUhGLEdBUnlCOztBQWF6QixTQUFLLE1BQUwsR0FieUI7QUFjekIsU0FBSyxnQkFBTCxHQWR5QjtJQUFWOztBQWlCaEIsb0JBQWlCLDJCQUFVO0FBQzFCLFFBQUksS0FBSyxLQUFLLFNBQUwsRUFBTCxDQURzQjs7QUFHMUIsT0FBRyxjQUFILENBQWtCLEtBQUssV0FBTCxFQUFsQixFQUgwQjs7QUFLMUIsU0FBSyxZQUFMLENBQWtCLElBQWxCLEVBTDBCO0FBTTFCLFNBQUssV0FBTCxDQUFpQixJQUFqQixFQU4wQjs7QUFRMUIsU0FBSyxXQUFMLEdBUjBCO0lBQVY7R0FsQmxCOztBQWlDQSxhQUFXLHFCQUFVO0FBQ3BCLFVBQU8sS0FBSyxVQUFMLEdBQWtCLFNBQWxCLEVBQVAsQ0FEb0I7R0FBVjs7QUFJWCxtQkFBaUIseUJBQVMsUUFBVCxFQUFtQjtBQUNuQyxPQUFJLEtBQUssS0FBSyxTQUFMLEVBQUwsQ0FEK0I7O0FBR25DLE1BQUcsY0FBSCxDQUFrQixLQUFLLFdBQUwsRUFBbEIsRUFIbUM7QUFJbkMsWUFBUyxJQUFULENBQWMsSUFBZCxFQUFvQixFQUFwQixFQUptQzs7QUFNbkMsUUFBSyxZQUFMLENBQWtCLEdBQUcsZUFBSCxFQUFsQixFQU5tQztBQU9uQyxRQUFLLFdBQUwsQ0FBaUIsR0FBRyxjQUFILEVBQWpCLEVBUG1DOztBQVNuQyxNQUFHLElBQUgsR0FUbUM7R0FBbkI7O0FBWWpCLG9CQUFrQiw0QkFBVyxFQUFYO0FBR2xCLFVBQVEsa0JBQVcsRUFBWDtBQUdSLGVBQWEsdUJBQVc7QUFFdkIsUUFBSyxJQUFMLENBQVUsY0FBVixFQUEwQixLQUExQixHQUZ1QjtHQUFYO0VBeEZkLEVBbEoyQjs7QUFzUDNCLEdBQUUsK0JBQUYsRUFBbUMsT0FBbkMsQ0FBMkM7QUFHMUMsWUFBVSxrQkFBUyxDQUFULEVBQVk7QUFDckIsUUFBSyxVQUFMLEdBRHFCO0FBRXJCLFFBQUssU0FBTCxHQUFpQixLQUFqQixHQUZxQjtBQUdyQixVQUFPLEtBQVAsQ0FIcUI7R0FBWjtBQUtWLGVBQWEsdUJBQVc7QUFDdkIsUUFBSyxNQUFMLEdBRHVCOztBQUl2QixRQUFLLENBQUwsRUFBUSxLQUFSLEdBSnVCO0dBQVg7QUFNYixVQUFRLGtCQUFXO0FBQ2xCLFFBQUssTUFBTCxHQURrQjs7QUFHbEIsT0FBSSxXQUFXLEtBQUssSUFBTCxDQUFVLCtCQUFWLEVBQTJDLEdBQTNDLEVBQVgsQ0FIYzs7QUFLbEIsUUFBSyxpQkFBTCxHQUxrQjs7QUFPbEIsUUFBSyxjQUFMLEdBUGtCOztBQVVsQixRQUFLLElBQUwsQ0FBVSxvQkFBVixFQUFnQyxJQUFoQyxHQVZrQjtBQVdsQixRQUFLLElBQUwsQ0FBVSx3QkFBVixFQUFvQyxJQUFwQyxHQVhrQjtBQVlsQixRQUFLLElBQUwsQ0FBVSxpQkFBaUIsUUFBakIsR0FBMkIsV0FBM0IsQ0FBVixDQUFrRCxJQUFsRCxHQVprQjs7QUFjbEIsT0FBRyxZQUFZLFVBQVosSUFBMEIsWUFBWSxRQUFaLEVBQXNCO0FBQ2xELFNBQUssSUFBTCxDQUFVLDZCQUFWLEVBQXlDLElBQXpDLEdBRGtEO0lBQW5EOztBQUlBLE9BQUcsWUFBWSxPQUFaLEVBQXFCO0FBQ3ZCLFNBQUssSUFBTCxDQUFVLDhCQUFWLEVBQTBDLElBQTFDLEdBRHVCO0lBQXhCLE1BRU87QUFDTixTQUFLLElBQUwsQ0FBVSxrQ0FBVixFQUE4QyxJQUE5QyxHQURNO0lBRlA7O0FBTUEsT0FBRyxZQUFZLFFBQVosRUFBc0I7QUFDeEIsU0FBSyxJQUFMLENBQVUscUNBQVYsRUFBaUQsSUFBakQsR0FEd0I7SUFBekI7QUFHQSxRQUFLLElBQUwsQ0FBVSxrQ0FBVixFQUE4QyxJQUE5QyxHQTNCa0I7R0FBWDs7QUFnQ1IscUJBQW1CLDZCQUFXO0FBQzdCLE9BQUksSUFBSjtPQUNDLFNBQVMsSUFBVDtPQUNBLFVBQVUsS0FBSyxJQUFMLENBQVUsc0JBQVYsRUFBa0MsR0FBbEMsRUFBVjtPQUNBLFNBQVMsS0FBSyxJQUFMLENBQVUscUJBQVYsRUFBaUMsR0FBakMsRUFBVCxDQUo0Qjs7QUFPN0IsT0FBRyxLQUFLLElBQUwsQ0FBVSwwQkFBVixFQUFzQyxFQUF0QyxDQUF5QyxVQUF6QyxDQUFILEVBQXlEO0FBQ3hELGFBQVMsUUFBVCxDQUR3RDtJQUF6RDs7QUFLQSxXQUFPLEtBQUssSUFBTCxDQUFVLCtCQUFWLEVBQTJDLEdBQTNDLEVBQVA7QUFDQyxTQUFLLFVBQUw7QUFDQyxZQUFPLHVCQUF1QixLQUFLLElBQUwsQ0FBVSx1QkFBVixFQUFtQyxHQUFuQyxFQUF2QixHQUFrRSxHQUFsRSxDQURSOztBQUdDLFNBQUcsTUFBSCxFQUFXO0FBQ1YsY0FBUSxNQUFNLE1BQU4sQ0FERTtNQUFYOztBQUlBLFdBUEQ7O0FBREQsU0FVTSxRQUFMO0FBQ0MsWUFBTyxNQUFNLE1BQU4sQ0FEUjtBQUVDLFdBRkQ7O0FBVkQsU0FjTSxNQUFMO0FBQ2dCLFNBQUksU0FBUyxLQUFLLElBQUwsQ0FBVSxzQ0FBVixFQUFrRCxJQUFsRCxDQUF1RCxhQUF2RCxDQUFULENBRHBCO0FBRWdCLFlBQU8sU0FBUyxtQkFBbUIsTUFBbkIsR0FBNEIsR0FBNUIsR0FBa0MsRUFBM0MsQ0FGdkI7QUFHQyxXQUhEOztBQWRELFNBbUJNLE9BQUw7QUFDQyxZQUFPLFlBQVksS0FBSyxJQUFMLENBQVUsb0JBQVYsRUFBZ0MsR0FBaEMsRUFBWixDQURSO0FBRUMsU0FBRyxPQUFILEVBQVk7QUFDWCxjQUFRLGNBQWMsbUJBQW1CLE9BQW5CLENBQWQsQ0FERztNQUFaO0FBR0EsY0FBUyxJQUFULENBTEQ7QUFNQyxXQU5EOztBQW5CRDtBQTZCRSxZQUFPLEtBQUssSUFBTCxDQUFVLHVCQUFWLEVBQW1DLEdBQW5DLEVBQVAsQ0FERDs7QUFHQyxTQUFHLEtBQUssT0FBTCxDQUFhLEtBQWIsS0FBdUIsQ0FBQyxDQUFELEVBQUksT0FBTyxZQUFZLElBQVosQ0FBckM7QUFDQSxXQUpEO0FBNUJELElBWjZCOztBQStDN0IsVUFBTztBQUNOLFVBQU8sSUFBUDtBQUNBLFlBQVMsTUFBVDtBQUNBLFdBQVEsS0FBSyxJQUFMLENBQVUsMEJBQVYsRUFBc0MsR0FBdEMsRUFBUjtJQUhELENBL0M2QjtHQUFYO0FBcURuQixjQUFZLHNCQUFXO0FBQ3RCLFFBQUssZUFBTCxDQUFxQixVQUFTLEVBQVQsRUFBWTtBQUNoQyxPQUFHLFVBQUgsQ0FBYyxLQUFLLGlCQUFMLEVBQWQsRUFEZ0M7SUFBWixDQUFyQixDQURzQjtHQUFYO0FBS1osY0FBWSxzQkFBVztBQUN0QixRQUFLLGVBQUwsQ0FBcUIsVUFBUyxFQUFULEVBQVk7QUFDaEMsT0FBRyxVQUFILEdBRGdDO0lBQVosQ0FBckIsQ0FEc0I7O0FBS3RCLFFBQUssY0FBTCxHQUxzQjtBQU10QixRQUFLLEtBQUwsR0FOc0I7R0FBWDs7QUFTWixrQkFBZ0IsMEJBQVc7QUFFMUIsT0FBSSxZQUFZLEtBQUssSUFBTCxDQUFVLG9DQUFWLENBQVo7T0FDSCxhQUFhLFVBQVUsSUFBVixDQUFlLFlBQWYsQ0FBYjtPQUNBLGNBQWMsVUFBVSxJQUFWLENBQWUsbUNBQWYsQ0FBZCxDQUp5Qjs7QUFNMUIsT0FBRyxZQUFZLE1BQVosRUFBb0I7QUFDdEIsZUFBVyxRQUFYLENBQW9CLFNBQXBCLEVBQStCLElBQS9CLEVBQXFDLEVBQUMsU0FBUyxXQUFULEVBQXRDLEVBRHNCO0FBRXRCLGNBQVUsSUFBVixDQUFlLHlCQUFmLEVBQTBDLFdBQTFDLENBQXNELFdBQXRELEVBRnNCO0lBQXZCO0dBTmU7O0FBZWhCLHFCQUFtQiw2QkFBVztBQUU3QixPQUFHLEtBQUssSUFBTCxDQUFVLDZCQUFWLEVBQXlDLE1BQXpDLEVBQWlELE9BQXBEOztBQUVBLE9BQUksT0FBTyxJQUFQLENBSnlCO0FBSzdCLE9BQUksaUJBQWlCLEVBQ3BCLHdGQURvQixDQUFqQixDQUx5QjtBQVE3QixRQUFLLElBQUwsQ0FBVSxxQkFBVixFQUFpQyxNQUFqQyxHQUEwQyxNQUExQyxDQUFpRCxjQUFqRCxFQVI2Qjs7QUFXN0IsUUFBSyxvQkFBTCxHQVg2Qjs7QUFjN0Isa0JBQWUsTUFBZixDQUFzQixVQUFTLENBQVQsRUFBWTtBQUNqQyxTQUFLLElBQUwsQ0FBVSx1QkFBVixFQUFtQyxHQUFuQyxDQUF1QyxFQUFFLElBQUYsRUFBUSxHQUFSLEVBQXZDLEVBRGlDO0lBQVosQ0FBdEIsQ0FkNkI7R0FBWDs7QUF3Qm5CLGNBQVksc0JBQVc7QUFDdEIsT0FBSSxXQUFXLEtBQUssSUFBTCxDQUFVLCtCQUFWLEVBQTJDLEdBQTNDLEVBQVgsQ0FEa0I7QUFFdEIsT0FBSSxhQUFhLEVBQUUsUUFBRixFQUFiLENBRmtCOztBQUl0QixXQUFRLFFBQVI7QUFDQyxTQUFLLFFBQUw7QUFFQyxTQUFJLG1CQUFtQixFQUFuQixDQUZMO0FBR0MsU0FBSSxLQUFLLEtBQUssU0FBTCxFQUFMLENBSEw7OztBQU9DLFNBQUcsRUFBSCxFQUFPO0FBQ04sVUFBSSxNQUFNLEdBQUcsVUFBSCxHQUNSLEtBRFEsQ0FDRiwrRUFERSxDQUFOLENBREU7QUFHTixVQUFJLE9BQU8sSUFBSSxNQUFKLEVBQVk7QUFDdEIsWUFBSSxJQUFJLElBQUksQ0FBSixFQUFPLElBQUksSUFBSSxNQUFKLEVBQVksR0FBL0IsRUFBb0M7QUFDbkMsWUFBSSxhQUFhLEdBQUMsQ0FBSSxDQUFKLEVBQU8sT0FBUCxDQUFlLEtBQWYsS0FBeUIsQ0FBQyxDQUFELEdBQU0sQ0FBaEMsR0FBb0MsQ0FBcEMsQ0FEa0I7QUFFbkMseUJBQWlCLElBQWpCLENBQXNCLElBQUksQ0FBSixFQUFPLE1BQVAsQ0FBYyxVQUFkLEVBQTBCLE9BQTFCLENBQWtDLElBQWxDLEVBQXdDLEVBQXhDLENBQXRCLEVBRm1DO1FBQXBDO09BREQ7TUFIRDs7QUFXQSxnQkFBVyxPQUFYLENBQW1CLGdCQUFuQixFQWxCRDtBQW1CQyxXQW5CRDs7QUFERCxTQXNCTSxVQUFMO0FBRUMsU0FBSSxTQUFTLEtBQUssSUFBTCxDQUFVLHVCQUFWLEVBQW1DLEdBQW5DLEVBQVQsQ0FGTDs7QUFJQyxTQUFJLE1BQUosRUFBWTtBQUNYLFFBQUUsSUFBRixDQUFPO0FBQ04sWUFBSyxFQUFFLElBQUYsQ0FBTyxlQUFQLENBQ0osS0FBSyxJQUFMLENBQVUsUUFBVixFQUFvQixPQUFwQixDQUE0QixVQUE1QixFQUF3QyxZQUF4QyxDQURJLEVBRUosRUFBQyxVQUFVLFNBQVMsTUFBVCxDQUFWLEVBRkcsQ0FBTDtBQUlBLGdCQUFTLGlCQUFTLElBQVQsRUFBZSxNQUFmLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3BDLG1CQUFXLE9BQVgsQ0FBbUIsRUFBRSxTQUFGLENBQVksSUFBWixDQUFuQixFQURvQztRQUE1QjtBQUdULGNBQU8sZUFBUyxHQUFULEVBQWMsTUFBZCxFQUFzQjtBQUM1QixtQkFBVyxNQUFYLENBQWtCLElBQUksWUFBSixDQUFsQixDQUQ0QjtRQUF0QjtPQVJSLEVBRFc7TUFBWixNQWFPO0FBQ04saUJBQVcsT0FBWCxDQUFtQixFQUFuQixFQURNO01BYlA7QUFnQkEsV0FwQkQ7O0FBdEJEO0FBOENFLGdCQUFXLE1BQVgsQ0FBa0IsZUFBSyxFQUFMLENBQ2pCLHFDQURpQixFQUVqQiwrQ0FGaUIsQ0FBbEIsRUFGRDtBQU1DLFdBTkQ7QUE1Q0QsSUFKc0I7O0FBeUR0QixVQUFPLFdBQVcsT0FBWCxFQUFQLENBekRzQjtHQUFYOztBQStEWix3QkFBc0IsZ0NBQVc7QUFDaEMsT0FBSSxPQUFPLElBQVAsQ0FENEI7QUFFaEMsT0FBSSxXQUFXLEtBQUssSUFBTCxDQUFVLDZCQUFWLENBQVgsQ0FGNEI7QUFHaEMsT0FBSSxhQUFhLEtBQUssVUFBTCxFQUFiLENBSDRCOztBQU1oQyxZQUFTLEtBQVQsR0FOZ0M7QUFPaEMsWUFBUyxNQUFULENBQWdCLEVBQ2YsbUNBQ0EsZUFBSyxFQUFMLENBQVEsbUNBQVIsRUFBNkMsd0JBQTdDLENBREEsR0FFQSxXQUZBLENBREQsRUFQZ0M7O0FBYWhDLGNBQVcsSUFBWCxDQUFnQixVQUFTLE9BQVQsRUFBa0I7QUFDakMsYUFBUyxLQUFULEdBRGlDO0FBRWpDLGFBQVMsTUFBVCxDQUFnQixFQUNmLG1DQUNBLGVBQUssRUFBTCxDQUFRLDhCQUFSLENBREEsR0FFQSxXQUZBLENBREQsRUFGaUM7O0FBUWpDLFFBQUksT0FBSixFQUFhO0FBQ1osVUFBSyxJQUFJLElBQUksQ0FBSixFQUFPLElBQUksUUFBUSxNQUFSLEVBQWdCLEdBQXBDLEVBQXlDO0FBQ3hDLGVBQVMsTUFBVCxDQUFnQixFQUFFLG9CQUFrQixRQUFRLENBQVIsQ0FBbEIsR0FBNkIsSUFBN0IsR0FBa0MsUUFBUSxDQUFSLENBQWxDLEdBQTZDLFdBQTdDLENBQWxCLEVBRHdDO01BQXpDO0tBREQ7SUFSZSxDQUFoQixDQWNHLElBZEgsQ0FjUSxVQUFTLE9BQVQsRUFBa0I7QUFDekIsYUFBUyxLQUFULEdBRHlCO0FBRXpCLGFBQVMsTUFBVCxDQUFnQixFQUNmLG1DQUNBLE9BREEsR0FFQSxXQUZBLENBREQsRUFGeUI7SUFBbEIsQ0FkUixDQWJnQzs7QUFxQ2hDLE9BQUksRUFBRSxPQUFGLENBQVUsSUFBVixFQUFnQixTQUFTLElBQVQsR0FBZ0IsSUFBaEIsR0FBcEI7R0FyQ3FCOztBQTRDdEIsb0JBQWtCLDRCQUFXO0FBQzVCLE9BQUksaUJBQWlCLGFBQWpCO09BQWdDLFNBQXBDO09BQStDLE9BQU8sS0FBSyxjQUFMLEVBQVAsQ0FEbkI7O0FBRzVCLE9BQUcsSUFBSCxFQUFTO0FBQ1IsU0FBSSxTQUFKLElBQWlCLElBQWpCLEVBQXVCO0FBQ3RCLFNBQUksS0FBSyxLQUFLLElBQUwsQ0FBVSxpQkFBaUIsU0FBakIsR0FBNkIsR0FBN0IsQ0FBZjtTQUFrRCxXQUFXLEtBQUssU0FBTCxDQUFYLENBRGhDOztBQUd0QixTQUFHLE9BQU8sUUFBUCxJQUFvQixRQUFwQixFQUE4QixXQUFXLFNBQVMsT0FBVCxDQUFpQixjQUFqQixFQUFpQyxFQUFqQyxDQUFYLENBQWpDOztBQUdBLFNBQUcsR0FBRyxFQUFILENBQU0sV0FBTixDQUFILEVBQXVCO0FBQ3RCLFNBQUcsSUFBSCxDQUFRLFNBQVIsRUFBbUIsUUFBbkIsRUFBNkIsTUFBN0IsR0FEc0I7TUFBdkIsTUFFTyxJQUFHLEdBQUcsRUFBSCxDQUFNLFFBQU4sQ0FBSCxFQUFvQjtBQUMxQixTQUFHLEdBQUgsQ0FBTyxDQUFDLFFBQUQsQ0FBUCxFQUFtQixNQUFuQixHQUQwQjtNQUFwQixNQUVBLElBQUcsYUFBYSxNQUFiLEVBQXFCO0FBRTlCLFdBQUssS0FBSyxJQUFMLENBQVUsa0JBQWtCLFNBQWxCLEdBQThCLGVBQTlCLENBQWYsQ0FGOEI7O0FBSTlCLFdBQUssR0FBRyxPQUFILENBQVcsaUJBQVgsQ0FBTCxDQUo4Qjs7QUFPOUIsT0FBQyxTQUFTLE1BQVQsQ0FBZ0IsRUFBaEIsRUFBb0IsUUFBcEIsRUFBOEI7QUFDOUIsV0FBSSxDQUFFLEdBQUcsU0FBSCxFQUFGLEVBQWtCO0FBQ3JCLG1CQUFXLFlBQVU7QUFBRSxnQkFBTyxFQUFQLEVBQVcsUUFBWCxFQUFGO1NBQVYsRUFBcUMsRUFBaEQsRUFEcUI7UUFBdEIsTUFFTztBQUNOLFdBQUcsV0FBSCxDQUFlLENBQUMsUUFBRCxDQUFmLEVBRE07UUFGUDtPQURBLENBQUQsQ0FNRyxFQU5ILEVBTU8sUUFOUCxFQVA4QjtNQUF4QixNQWNBO0FBQ04sU0FBRyxHQUFILENBQU8sUUFBUCxFQUFpQixNQUFqQixHQURNO01BZEE7S0FWUjtJQUREO0dBSGlCOztBQXdDbEIsa0JBQWdCLDBCQUFXO0FBQzFCLE9BQUksYUFBYSxLQUFLLFlBQUwsRUFBYjtPQUNILE9BQU8sRUFBUDtPQUFXLFNBQVMsRUFBVDtPQUFhLFFBQVEsRUFBUjtPQUFZLFNBQVMsUUFBVDtPQUFtQixjQUFjLEVBQWQsQ0FGOUI7O0FBTzFCLE9BQUksaUJBQWlCLElBQWpCLENBUHNCO0FBUTFCLE9BQUcsV0FBVyxNQUFYLEVBQW1CO0FBQ3JCLFFBQUcsV0FBVyxFQUFYLENBQWMsR0FBZCxDQUFILEVBQXVCO0FBRXRCLHNCQUFpQixVQUFqQixDQUZzQjtLQUF2QixNQVFPO0FBRU4sdUJBQWlCLGFBQWEsV0FBVyxPQUFYLENBQW1CLFNBQW5CLENBQWIsQ0FGWDtNQVJQO0lBREQ7QUFjQSxPQUFHLGtCQUFrQixlQUFlLE1BQWYsRUFBdUIsS0FBSyxlQUFMLENBQXFCLFVBQVMsRUFBVCxFQUFZO0FBQzVFLE9BQUcsVUFBSCxDQUFjLGVBQWUsQ0FBZixDQUFkLEVBRDRFO0lBQVosQ0FBckIsQ0FBNUM7O0FBS0EsT0FBSSxDQUFDLGVBQWUsSUFBZixDQUFvQixNQUFwQixDQUFELEVBQThCLGlCQUFpQixJQUFqQixDQUFsQzs7QUFFQSxPQUFJLGNBQUosRUFBb0I7QUFDbkIsV0FBTyxlQUFlLElBQWYsQ0FBb0IsTUFBcEIsQ0FBUCxDQURtQjtBQUVuQixhQUFTLGVBQWUsSUFBZixDQUFvQixRQUFwQixDQUFULENBRm1CO0FBR25CLFlBQVEsZUFBZSxJQUFmLENBQW9CLE9BQXBCLENBQVIsQ0FIbUI7QUFJbkIsa0JBQWMsZUFBZSxJQUFmLENBQW9CLE9BQXBCLENBQWQsQ0FKbUI7QUFLbkIsV0FBTyxLQUFLLFNBQUwsR0FBaUIsU0FBakIsQ0FBMkIsSUFBM0IsRUFBaUMsY0FBakMsQ0FBUCxDQUxtQjtBQU1uQixhQUFTLFFBQVQsQ0FObUI7SUFBcEI7O0FBU0EsT0FBRyxLQUFLLEtBQUwsQ0FBVyxlQUFYLENBQUgsRUFBZ0M7QUFDL0IsV0FBTztBQUNOLGVBQVUsT0FBVjtBQUNBLFlBQU8sT0FBTyxFQUFQO0FBQ1Asa0JBQWEsS0FBYjtLQUhELENBRCtCO0lBQWhDLE1BTU8sSUFBRyxLQUFLLEtBQUwsQ0FBVyxnQkFBWCxLQUFnQyxLQUFLLEtBQUwsQ0FBVyxvREFBWCxDQUFoQyxFQUFrRztBQUMzRyxXQUFPO0FBQ04sZUFBVSxNQUFWO0FBQ0EsV0FBTSxPQUFPLEVBQVA7QUFDTixrQkFBYSxLQUFiO0FBQ0Esa0JBQWEsU0FBUyxJQUFULEdBQWdCLEtBQWhCO0tBSmQsQ0FEMkc7SUFBckcsTUFPQSxJQUFHLEtBQUssS0FBTCxDQUFXLFNBQVgsQ0FBSCxFQUEwQjtBQUNoQyxXQUFPO0FBQ04sZUFBVSxRQUFWO0FBQ0EsYUFBUSxPQUFPLEVBQVA7QUFDUixrQkFBYSxLQUFiO0FBQ0Esa0JBQWEsU0FBUyxJQUFULEdBQWdCLEtBQWhCO0tBSmQsQ0FEZ0M7SUFBMUIsTUFPQSxJQUFHLEtBQUssS0FBTCxDQUFXLHNEQUFYLENBQUgsRUFBdUU7QUFDN0UsV0FBTztBQUNOLGVBQVUsVUFBVjtBQUNBLGVBQVUsT0FBTyxFQUFQO0FBQ1YsYUFBUSxPQUFPLEVBQVAsR0FBWSxPQUFPLEVBQVAsQ0FBVSxNQUFWLENBQWlCLENBQWpCLENBQVosR0FBa0MsRUFBbEM7QUFDUixrQkFBYSxLQUFiO0FBQ0Esa0JBQWEsU0FBUyxJQUFULEdBQWdCLEtBQWhCO0tBTGQsQ0FENkU7SUFBdkUsTUFRQSxJQUFHLElBQUgsRUFBUztBQUNmLFdBQU87QUFDTixlQUFVLFVBQVY7QUFDQSxlQUFVLElBQVY7QUFDQSxrQkFBYSxLQUFiO0FBQ0Esa0JBQWEsU0FBUyxJQUFULEdBQWdCLEtBQWhCO0tBSmQsQ0FEZTtJQUFULE1BT0E7QUFFTixXQUFPLElBQVAsQ0FGTTtJQVBBO0dBbEVRO0VBM1NqQixFQXRQMkI7O0FBaW5CM0IsR0FBRSxvREFBRixFQUF3RCxPQUF4RCxDQUFnRTtBQUMvRCxXQUFTLGlCQUFTLENBQVQsRUFBWTtBQUNwQixRQUFLLE9BQUwsQ0FBYSxZQUFiLEVBQTJCLE1BQTNCLEdBRG9CO0FBRXBCLFFBQUssTUFBTCxHQUZvQjtHQUFaO0FBSVQsWUFBVSxvQkFBVztBQUNwQixRQUFLLE9BQUwsQ0FBYSxZQUFiLEVBQTJCLE1BQTNCLEdBRG9COztBQUlwQixPQUFJLFdBQVcsS0FBSyxNQUFMLEdBQWMsSUFBZCxDQUFtQixVQUFuQixFQUErQixHQUEvQixFQUFYLENBSmdCO0FBS3BCLE9BQUksYUFBVyxRQUFYLElBQXVCLGFBQVcsVUFBWCxFQUF1QjtBQUNqRCxTQUFLLE9BQUwsQ0FBYSwrQkFBYixFQUE4QyxvQkFBOUMsR0FEaUQ7SUFBbEQ7QUFHQSxRQUFLLE1BQUwsR0FSb0I7R0FBWDtFQUxYLEVBam5CMkI7O0FBa29CM0IsR0FBRSxvREFBRixFQUF3RCxPQUF4RCxDQUFnRTtBQUkvRCxrQkFBZ0IsMEJBQVc7QUFDMUIsUUFBSyxPQUFMLENBQWEsK0JBQWIsRUFBOEMsb0JBQTlDLEdBRDBCO0FBRTFCLFFBQUssTUFBTCxHQUYwQjtHQUFYO0VBSmpCLEVBbG9CMkI7O0FBNG9CM0IsR0FBRSwyREFBRixFQUErRCxPQUEvRCxDQUF1RTtBQUN0RSxXQUFTLGlCQUFTLENBQVQsRUFBWTtBQUNwQixRQUFLLE9BQUwsQ0FBYSxZQUFiLEVBQTJCLFVBQTNCLEdBRG9CO0FBRXBCLFFBQUssTUFBTCxHQUZvQjtBQUdwQixVQUFPLEtBQVAsQ0FIb0I7R0FBWjtFQURWLEVBNW9CMkI7O0FBOHBCM0IsR0FBRSxnQ0FBRixFQUFvQyxPQUFwQyxDQUE0QztBQUMzQyxxQkFBbUIsNkJBQVU7QUFDNUIsT0FBSSxpQkFBaUIsUUFBUSxLQUFLLElBQUwsQ0FBVSwwQkFBVixFQUFzQyxNQUF0QyxDQUF6QixDQUR3QjtBQUU1QixRQUFLLElBQUwsQ0FBVSwwQkFBVixFQUFzQyxpQkFBaUIsTUFBakIsR0FBMEIsTUFBMUIsQ0FBdEMsR0FGNEI7R0FBVjtBQUluQixZQUFVLG9CQUFXO0FBQ3BCLFFBQUssZUFBTCxDQUFxQixVQUFTLEVBQVQsRUFBWTtBQUNoQyxTQUFLLElBQUwsQ0FBVSwwQkFBVixFQUFzQyxJQUF0QyxDQUEyQyxZQUFXO0FBQ3JELE9BQUUsSUFBRixFQUFRLFVBQVIsQ0FBbUIsRUFBbkIsRUFEcUQ7S0FBWCxDQUEzQyxDQURnQztJQUFaLENBQXJCLENBRG9COztBQU9wQixRQUFLLFNBQUwsR0FBaUIsS0FBakIsR0FQb0I7QUFRcEIsVUFBTyxLQUFQLENBUm9CO0dBQVg7QUFVVixvQkFBa0IsNEJBQVc7QUFDNUIsT0FBSSxPQUFPLElBQVA7T0FBYSxPQUFPLEtBQUssWUFBTCxFQUFQLENBRFc7O0FBSTVCLE9BQUcsS0FBSyxFQUFMLENBQVEsS0FBUixDQUFILEVBQW1CO0FBQ2xCLFFBQUksVUFBVSxLQUFLLElBQUwsQ0FBVSxJQUFWLEtBQW1CLEtBQUssSUFBTCxDQUFVLEtBQVYsQ0FBbkIsSUFBdUMsS0FBSyxJQUFMLENBQVUsS0FBVixDQUF2QyxDQURJO0FBRWxCLFNBQUssWUFBTCxDQUFrQixPQUFsQixFQUEyQixJQUEzQixDQUFnQyxVQUFTLFNBQVQsRUFBb0I7QUFDbkQsZUFBVSxjQUFWLENBQXlCLElBQXpCLEVBRG1EO0FBRW5ELFVBQUssaUJBQUwsR0FGbUQ7QUFHbkQsVUFBSyxNQUFMLEdBSG1EO0tBQXBCLENBQWhDLENBRmtCO0lBQW5CO0FBUUEsUUFBSyxNQUFMLEdBWjRCO0dBQVg7QUFjbEIsVUFBUSxnQkFBUyxjQUFULEVBQXlCO0FBQ2hDLFFBQUssTUFBTCxHQURnQzs7QUFHaEMsT0FBSSxPQUFPLEtBQUssWUFBTCxFQUFQO09BQ0gsV0FBVyxRQUFRLEtBQUssSUFBTCxDQUFVLDBCQUFWLEVBQXNDLE1BQXRDLENBQW5CO09BQ0Esa0JBQWtCLEtBQUssRUFBTCxDQUFRLEtBQVIsQ0FBbEI7T0FDQSxlQUFlLEtBQUssUUFBTCxDQUFjLGNBQWQsQ0FBZjtPQUNBLFNBQVMsS0FBSyxJQUFMLENBQVUsY0FBVixDQUFULENBUCtCOztBQVVoQyxVQUFPLFdBQWEsTUFBYixHQUFzQixNQUF0QixDQUFQLEdBVmdDOztBQWFoQyxRQUFLLE9BQUwsQ0FBYSxXQUFiLEVBQ0UsSUFERixDQUNPLG9DQURQLEVBRUUsTUFGRixDQUVTLFdBQVcsUUFBWCxHQUFzQixTQUF0QixDQUZULENBR0UsV0FIRixDQUdjLG1CQUhkLEVBR21DLENBQUMsUUFBRCxDQUhuQyxDQWJnQzs7QUFtQmhDLFFBQUssSUFBTCxDQUFVLGdDQUFWLEVBQTRDLG1CQUFtQixZQUFuQixHQUFrQyxNQUFsQyxHQUEyQyxNQUEzQyxDQUE1QyxHQW5CZ0M7QUFvQmhDLFFBQUssSUFBTCxDQUFVLDRCQUFWLEVBQXdDLG1CQUFtQixDQUFDLFlBQUQsR0FBZ0IsTUFBbkMsR0FBNEMsTUFBNUMsQ0FBeEMsR0FwQmdDOztBQXNCaEMsT0FBSSxtQkFBbUIsS0FBSyxJQUFMLENBQVUsMkNBQVYsQ0FBbkIsQ0F0QjRCOztBQXdCaEMsT0FBSSxlQUFKLEVBQXFCO0FBRXBCLHFCQUFpQixJQUFqQixHQUZvQjtJQUFyQixNQUdPLElBQUksWUFBSixFQUFrQjtBQUV4QixxQkFDRSxJQURGLEdBRUUsSUFGRixDQUVPLGVBQUssRUFBTCxDQUFRLDJCQUFSLENBRlAsRUFHRSxPQUhGLENBR1Usb0VBQW9FLGVBQUssRUFBTCxDQUFRLHNCQUFSLENBQXBFLEdBQXNHLGFBQXRHLENBSFYsQ0FGd0I7O0FBT3hCLFNBQUssSUFBTCxDQUFVLDRDQUFWLEVBQXdELEtBQXhELEdBUHdCO0lBQWxCLE1BUUE7QUFFTixxQkFDRSxJQURGLEdBRUUsSUFGRixDQUVPLGVBQUssRUFBTCxDQUFRLDRCQUFSLENBRlAsRUFHRSxJQUhGLENBR08sY0FIUCxFQUd1QixNQUh2QixHQUZNO0lBUkE7O0FBaUJQLFFBQUssSUFBTCxDQUFVLDJDQUFWLEVBQXVELGtCQUFrQixNQUFsQixHQUEyQixNQUEzQixDQUF2RCxHQTVDZ0M7QUE2Q2hDLFFBQUssSUFBTCxDQUFVLDhCQUFWLEVBQTBDLGtCQUFrQixNQUFsQixHQUEyQixNQUEzQixDQUExQyxHQTdDZ0M7QUE4Q2hDLFFBQUssSUFBTCxDQUFVLDJCQUFWLEVBQXVDLGtCQUFrQixNQUFsQixHQUEyQixNQUEzQixDQUF2QyxHQTlDZ0M7QUErQ2hDLFFBQUssSUFBTCxDQUFVLDhCQUFWLEVBQTBDLGtCQUFrQixNQUFsQixHQUEyQixNQUEzQixDQUExQyxHQS9DZ0M7QUFnRGhDLFFBQUssSUFBTCxDQUFVLHdCQUFWLEVBQW9DLGtCQUFrQixNQUFsQixHQUEyQixNQUEzQixDQUFwQyxHQWhEZ0M7QUFpRGhDLFFBQUssSUFBTCxDQUFVLCtCQUFWLEVBQTJDLGNBQTNDLENBQTBELGVBQTFELEVBakRnQztBQWtEaEMsUUFBSyxJQUFMLENBQVUsK0NBQVYsRUFBMkQsR0FBM0QsQ0FBK0QsTUFBL0QsRUFBdUUsRUFBRSw0Q0FBRixFQUFnRCxVQUFoRCxFQUF2RSxFQWxEZ0M7QUFtRGhDLFFBQUssT0FBTCxDQUFhLFlBQWIsRUFBMkIsUUFBM0IsQ0FBb0MseUJBQXBDLEVBbkRnQztBQW9EaEMsUUFBSyxPQUFMLENBQWEsWUFBYixFQUNFLElBREYsQ0FDTyxxREFEUCxFQUVFLElBRkYsQ0FFTyxDQUFDLGtCQUFrQixlQUFLLEVBQUwsQ0FDekIsd0JBRHlCLEVBRXpCLFFBRnlCLENBQWxCLEdBR0osZUFBSyxFQUFMLENBQ0gsd0JBREcsRUFFSCxRQUZHLENBSEksQ0FGUixFQXBEZ0M7R0FBekI7QUE4RFIsZUFBYSx1QkFBVztBQUN2QixRQUFLLElBQUwsQ0FBVSwwQkFBVixFQUFzQyxNQUF0QyxHQUR1QjtBQUV2QixRQUFLLElBQUwsQ0FBVSxrQ0FBVixFQUE4QyxXQUE5QyxDQUEwRCxhQUExRCxFQUZ1QjtBQUd2QixRQUFLLElBQUwsQ0FBVSx3QkFBVixFQUFvQyxNQUFwQyxHQUh1QjtBQUl2QixRQUFLLE1BQUwsR0FKdUI7O0FBTXZCLFFBQUssTUFBTCxHQU51QjtHQUFYO0FBUWIsZUFBYSxxQkFBUyxPQUFULEVBQWtCO0FBQzlCLFVBQU8sS0FBSyxJQUFMLENBQVUsc0NBQXNDLE9BQXRDLEdBQWdELEdBQWhELENBQWpCLENBRDhCO0dBQWxCO0FBR2IsZ0JBQWMsc0JBQVMsT0FBVCxFQUFrQjtBQUMvQixPQUFJLE9BQU8sSUFBUDtPQUFhLFNBQVMsTUFBQyxDQUFPLE9BQVAsS0FBbUIsT0FBbkIsR0FBOEIsRUFBQyxJQUFJLE9BQUosRUFBaEMsR0FBK0MsRUFBQyxTQUFTLE9BQVQsRUFBaEQsQ0FESzs7QUFHL0IsT0FBSSxPQUFPLEVBQUUsaURBQUYsQ0FBUCxDQUgyQjtBQUkvQixRQUFLLElBQUwsQ0FBVSxlQUFWLEVBQTJCLE9BQTNCLENBQW1DLElBQW5DLEVBSitCOztBQU0vQixPQUFJLE1BQU0sRUFBRSxRQUFGLEVBQU4sQ0FOMkI7O0FBUS9CLEtBQUUsSUFBRixDQUFPO0FBQ04sU0FBSyxFQUFFLElBQUYsQ0FBTyxlQUFQLENBQXVCLEtBQUssSUFBTCxDQUFVLFFBQVYsRUFBb0IsT0FBcEIsQ0FBNEIsV0FBNUIsRUFBeUMsVUFBekMsQ0FBdkIsRUFBNkUsTUFBN0UsQ0FBTDtBQUNBLGFBQVMsaUJBQVMsSUFBVCxFQUFlLE1BQWYsRUFBdUIsR0FBdkIsRUFBNEI7QUFDcEMsU0FBSSxVQUFVLEVBQUUsSUFBRixFQUFRLE1BQVIsQ0FBZSwwQkFBZixDQUFWLENBRGdDO0FBRXBDLFVBQUssV0FBTCxDQUFpQixPQUFqQixFQUZvQztBQUdwQyxVQUFLLE1BQUwsR0FIb0M7QUFJcEMsU0FBSSxPQUFKLENBQVksT0FBWixFQUpvQztLQUE1QjtBQU1ULFdBQU8saUJBQVc7QUFDakIsVUFBSyxNQUFMLEdBRGlCO0FBRWpCLFNBQUksTUFBSixHQUZpQjtLQUFYO0lBUlIsRUFSK0I7O0FBc0IvQixVQUFPLElBQUksT0FBSixFQUFQLENBdEIrQjtHQUFsQjtFQXRHZixFQTlwQjJCOztBQSt4QjNCLEdBQUUsMERBQUYsRUFBOEQsT0FBOUQsQ0FBc0U7QUFDckUsV0FBUyxtQkFBWTtBQUNwQixPQUFJLE9BQU8sS0FBSyxPQUFMLENBQWEsTUFBYixDQUFQLENBRGdCOztBQUdwQixRQUFLLFFBQUwsQ0FBYyxjQUFkLEVBSG9CO0FBSXBCLFFBQUssTUFBTCxHQUpvQjtHQUFaO0VBRFYsRUEveEIyQjs7QUF5eUIzQixHQUFFLGdGQUFGLEVBQW9GLE9BQXBGLENBQTRGO0FBQzNGLFdBQVMsbUJBQVc7QUFDbkIsT0FBSSxPQUFPLEtBQUssT0FBTCxDQUFhLE1BQWIsQ0FBUCxDQURlOztBQUduQixRQUFLLFdBQUwsQ0FBaUIsY0FBakIsRUFIbUI7QUFJbkIsUUFBSyxNQUFMLEdBSm1CO0dBQVg7RUFEVixFQXp5QjJCOztBQWt6QjNCLEdBQUUsb0RBQUYsRUFBd0QsT0FBeEQsQ0FBZ0U7QUFDL0Qsd0JBQXNCLDhCQUFTLENBQVQsRUFBWSxFQUFaLEVBQWdCO0FBQ3JDLE9BQUksT0FBTyxLQUFLLE9BQUwsQ0FBYSxNQUFiLENBQVA7T0FBNkIsT0FBTyxFQUFFLEdBQUcsUUFBSCxDQUFULENBREk7QUFFckMsT0FBRyxDQUFDLEtBQUssRUFBTCxDQUFRLG9CQUFSLENBQUQsRUFBZ0MsT0FBbkM7QUFDQSxRQUFLLE9BQUwsQ0FBYSxNQUFiLEVBQXFCLFlBQXJCLENBQWtDLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBbEMsRUFIcUM7QUFJckMsUUFBSyxNQUFMLEdBSnFDOztBQU1yQyxRQUFLLE1BQUwsR0FBYyxPQUFkLENBQXNCLFFBQXRCLEVBTnFDO0dBQWhCO0FBUXRCLDBCQUF3QixnQ0FBUyxDQUFULEVBQVksRUFBWixFQUFnQjtBQUN2QyxPQUFJLE9BQU8sS0FBSyxPQUFMLENBQWEsTUFBYixDQUFQO09BQTZCLE9BQU8sRUFBRSxHQUFHLFVBQUgsQ0FBVCxDQURNO0FBRXZDLE9BQUcsQ0FBQyxLQUFLLEVBQUwsQ0FBUSxvQkFBUixDQUFELEVBQWdDLE9BQW5DO0FBQ0EsUUFBSyxXQUFMLENBQWlCLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBakIsRUFBa0MsTUFBbEMsR0FIdUM7QUFJdkMsUUFBSyxNQUFMLEdBSnVDO0dBQWhCO0VBVHpCLEVBbHpCMkI7O0FBczBCM0IsR0FBRSw2RUFBRixFQUFpRixPQUFqRixDQUF5RjtBQUd4RixvQkFBa0IsMEJBQVMsQ0FBVCxFQUFZO0FBQzdCLE9BQUksT0FBTyxLQUFLLE9BQUwsQ0FBYSxNQUFiLENBQVAsQ0FEeUI7O0FBSTdCLE9BQUksZUFBZSxFQUFmLENBSnlCO0FBSzdCLFFBQUssSUFBTCxDQUFVLGtCQUFWLEVBQThCLElBQTlCLENBQW1DLDZCQUFuQyxFQUFrRSxJQUFsRSxDQUF1RSxZQUFVO0FBRWhGLGlCQUFhLElBQWIsQ0FBa0IsRUFBRSxJQUFGLEVBQVEsSUFBUixDQUFhLElBQWIsQ0FBbEIsRUFGZ0Y7SUFBVixDQUF2RSxDQUw2Qjs7QUFVN0IsT0FBSSxnQkFBZ0IsRUFBRSx1QkFBRixFQUEyQixJQUEzQixFQUFpQyxRQUFqQyxDQUEwQyxzQkFBMUMsQ0FBaEIsQ0FWeUI7QUFXN0IsaUJBQWMsSUFBZCxDQUFtQixZQUFVO0FBQzVCLFFBQUksYUFBYSxFQUFFLElBQUYsRUFBUSxJQUFSLENBQWEsUUFBYixDQUFiLENBRHdCO0FBRTVCLFFBQUksY0FBYyxFQUFFLE9BQUYsQ0FBVSxVQUFWLEVBQXNCLFlBQXRCLEtBQXVDLENBQUMsQ0FBRCxFQUFJO0FBRTVELE9BQUUsSUFBRixFQUFRLE1BQVIsR0FGNEQ7QUFHNUQsVUFBSyxZQUFMLENBQWtCLFVBQWxCLEVBSDREO0tBQTdEO0lBRmtCLENBQW5CLENBWDZCOztBQW9CN0IsUUFBSyxNQUFMLEdBQWMsT0FBZCxDQUFzQixRQUF0QixFQXBCNkI7O0FBc0I3QixRQUFLLE1BQUwsR0F0QjZCO0dBQVo7O0VBSG5CLEVBdDBCMkI7O0FBbzJCM0IsR0FBRSxxRUFBRixFQUF5RSxPQUF6RSxDQUFpRjtBQUNoRixTQUFPLGlCQUFXO0FBQ2pCLFFBQUssTUFBTCxHQURpQjtBQUVqQixRQUFLLFFBQUwsR0FGaUI7R0FBWDs7QUFLUCxXQUFTLG1CQUFXO0FBQ25CLFFBQUssUUFBTCxHQURtQjtHQUFYOztBQUlULFlBQVUsb0JBQVc7QUFDcEIsUUFBSyxRQUFMLEdBRG9CO0dBQVg7O0FBSVYsZ0JBQWMsd0JBQVc7QUFDeEIsVUFBTyxLQUFLLE9BQUwsQ0FBYSxpQkFBYixFQUFnQyxJQUFoQyxDQUFxQyxnQkFBckMsQ0FBUCxDQUR3QjtHQUFYOztBQUlkLFlBQVUsb0JBQVc7QUFDcEIsT0FBSSxNQUFNLEtBQUssR0FBTCxFQUFOO09BQWtCLE9BQU8sR0FBUCxDQURGOztBQUdwQixTQUFNLEVBQUUsSUFBRixDQUFPLEdBQVAsQ0FBTixDQUhvQjtBQUlwQixTQUFNLElBQUksT0FBSixDQUFZLGVBQVosRUFBNkIsRUFBN0IsQ0FBTixDQUpvQjtBQUtwQixPQUFJLFNBQVMsR0FBVCxFQUFjLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBbEI7O0FBRUEsUUFBSyxZQUFMLEdBQW9CLE1BQXBCLENBQTJCLENBQUMsQ0FBQyxHQUFELEdBQU8sUUFBUixHQUFtQixTQUFuQixDQUEzQixDQVBvQjtBQVFwQixVQUFPLENBQUMsQ0FBQyxHQUFELENBUlk7R0FBWDtFQWxCWCxFQXAyQjJCOztBQXE0QjNCLEdBQUUsOERBQUYsRUFBa0UsT0FBbEUsQ0FBMEU7QUFDekUsZUFBYSx1QkFBVztBQUN2QixVQUFPLEtBQUssT0FBTCxDQUFhLGlCQUFiLEVBQWdDLElBQWhDLENBQXFDLGlCQUFyQyxDQUFQLENBRHVCO0dBQVg7O0FBSWIsV0FBUyxpQkFBUyxDQUFULEVBQVk7QUFDcEIsT0FBSSxXQUFXLEtBQUssV0FBTCxFQUFYO09BQStCLFlBQVksS0FBSyxPQUFMLENBQWEsaUJBQWIsQ0FBWjtPQUE2QyxPQUFPLEtBQUssT0FBTCxDQUFhLE1BQWIsQ0FBUCxDQUQ1RDs7QUFHcEIsT0FBSSxTQUFTLFFBQVQsRUFBSixFQUF5QjtBQUN4QixjQUFVLFFBQVYsQ0FBbUIsU0FBbkIsRUFEd0I7QUFFeEIsU0FBSyxZQUFMLENBQWtCLFlBQVksU0FBUyxHQUFULEVBQVosQ0FBbEIsQ0FBOEMsSUFBOUMsQ0FBbUQsWUFBVztBQUM3RCxlQUFVLFdBQVYsQ0FBc0IsU0FBdEIsRUFENkQ7O0FBRzdELFVBQUssTUFBTCxHQUFjLE9BQWQsQ0FBc0IsUUFBdEIsRUFINkQ7S0FBWCxDQUFuRCxDQUZ3QjtBQU94QixTQUFLLE1BQUwsR0FQd0I7SUFBekI7O0FBVUEsVUFBTyxLQUFQLENBYm9CO0dBQVo7RUFMVixFQXI0QjJCOztBQSs1QjNCLEdBQUUseURBQUYsRUFBNkQsT0FBN0QsQ0FBcUU7QUFJcEUsaUJBQWUseUJBQVcsRUFBWDs7QUFNZixnQkFBYyx3QkFBVyxFQUFYOztBQUtkLFdBQVMsbUJBQVc7QUFFbkIsVUFBTyxFQUFFLE9BQUYsRUFBVyxNQUFYLENBQ04sRUFBRSxNQUFGLEVBQVUsSUFBVixDQUFlLEVBQUMsTUFBTSxLQUFLLElBQUwsQ0FBVSxLQUFWLENBQU4sRUFBaEIsRUFBeUMsSUFBekMsQ0FBOEMsS0FBSyxJQUFMLENBQVUsT0FBVixFQUFtQixJQUFuQixFQUE5QyxDQURNLEVBRUwsSUFGSyxFQUFQLENBRm1CO0dBQVg7O0FBU1QsY0FBWSxvQkFBUyxFQUFULEVBQWE7QUFFeEIsTUFBRyxjQUFILENBQWtCLEtBQUssT0FBTCxFQUFsQixFQUZ3QjtHQUFiOztBQVNaLGtCQUFnQix3QkFBUyxJQUFULEVBQWUsRUFBZjs7QUFVaEIsb0JBQWtCLDBCQUFTLFdBQVQsRUFBc0IsSUFBdEIsRUFBNEIsSUFBNUIsRUFBa0M7QUFDbkQsT0FBSSxVQUFVLEtBQUssSUFBTCxDQUFVLG9CQUFWLENBQVY7T0FDSCxXQUFXLEtBQUssSUFBTCxDQUFVLHFCQUFWLENBQVg7T0FDQSxJQUFJLFFBQVEsR0FBUixFQUFKO09BQ0EsSUFBSSxTQUFTLEdBQVQsRUFBSjtPQUNBLE1BSkQsQ0FEbUQ7O0FBUW5ELE9BQUcsS0FBSyxDQUFMLEVBQVE7QUFDVixRQUFHLFdBQUgsRUFBZ0I7QUFDZixjQUFTLFNBQVMsVUFBVCxLQUF3QixRQUFRLFVBQVIsRUFBeEIsQ0FETTs7QUFHZixTQUFHLGVBQWUsT0FBZixFQUF3QjtBQUMxQixVQUFHLFFBQVEsSUFBSSxJQUFKLEVBQVUsSUFBSSxJQUFKLENBQXJCO0FBQ0EsVUFBSSxLQUFLLEtBQUwsQ0FBVyxJQUFJLE1BQUosQ0FBZixDQUYwQjtNQUEzQixNQUdPLElBQUcsZUFBZSxRQUFmLEVBQXlCO0FBQ2xDLFVBQUcsUUFBUSxJQUFJLElBQUosRUFBVSxJQUFJLElBQUosQ0FBckI7QUFDQSxVQUFJLEtBQUssSUFBTCxDQUFVLElBQUksTUFBSixDQUFkLENBRmtDO01BQTVCO0tBTlIsTUFVTztBQUNOLFNBQUcsUUFBUSxJQUFJLElBQUosRUFBVSxJQUFJLElBQUosQ0FBckI7QUFDQSxTQUFHLFFBQVEsSUFBSSxJQUFKLEVBQVUsSUFBSSxJQUFKLENBQXJCO0tBWkQ7O0FBZUEsWUFBUSxHQUFSLENBQVksQ0FBWixFQWhCVTtBQWlCVixhQUFTLEdBQVQsQ0FBYSxDQUFiLEVBakJVO0lBQVg7R0FSaUI7RUEzQ25CLEVBLzVCMkI7O0FBdytCM0IsR0FBRSwrREFBRixFQUFtRSxPQUFuRSxDQUEyRTtBQUMxRSxpQkFBZSx5QkFBVztBQUN6QixPQUFJLFFBQVEsS0FBSyxJQUFMLENBQVUsb0JBQVYsRUFBZ0MsR0FBaEMsRUFBUjtPQUNILFNBQVMsS0FBSyxJQUFMLENBQVUscUJBQVYsRUFBaUMsR0FBakMsRUFBVCxDQUZ3QjtBQUd6QixVQUFPO0FBQ04sV0FBUSxLQUFLLElBQUwsQ0FBVSxrQkFBVixFQUE4QixHQUE5QixFQUFSO0FBQ0EsV0FBUSxLQUFLLElBQUwsQ0FBVSxzQkFBVixFQUFrQyxHQUFsQyxFQUFSO0FBQ0EsYUFBVSxRQUFRLFNBQVMsS0FBVCxFQUFnQixFQUFoQixDQUFSLEdBQThCLElBQTlCO0FBQ1YsY0FBVyxTQUFTLFNBQVMsTUFBVCxFQUFpQixFQUFqQixDQUFULEdBQWdDLElBQWhDO0FBQ1gsYUFBVSxLQUFLLElBQUwsQ0FBVSxvQkFBVixFQUFnQyxHQUFoQyxFQUFWO0FBQ0EsYUFBVSxLQUFLLElBQUwsQ0FBVSx1QkFBVixFQUFtQyxHQUFuQyxFQUFWO0FBQ0EsZUFBWSxLQUFLLElBQUwsQ0FBVSxxQkFBVixFQUFpQyxHQUFqQyxFQUFaO0lBUEQsQ0FIeUI7R0FBWDtBQWFmLGdCQUFjLHdCQUFXO0FBQ3hCLFVBQU87QUFDTixtQkFBZSxLQUFLLElBQUwsQ0FBVSwwQkFBVixFQUFzQyxHQUF0QyxFQUFmO0lBREQsQ0FEd0I7R0FBWDtBQUtkLFdBQVMsbUJBQVcsRUFBWDs7QUFNVCxjQUFZLG9CQUFTLEVBQVQsRUFBYTtBQUN4QixPQUFJLE9BQU8sS0FBSyxPQUFMLENBQWEsTUFBYixDQUFQLENBRG9CO0FBRXhCLE9BQUksT0FBTyxLQUFLLFlBQUwsRUFBUCxDQUZvQjtBQUd4QixPQUFJLENBQUMsRUFBRCxFQUFLLEtBQUssS0FBSyxTQUFMLEVBQUwsQ0FBVDs7QUFHQSxPQUFJLFFBQVEsS0FBSyxhQUFMLEVBQVI7T0FBOEIsWUFBWSxLQUFLLFlBQUwsRUFBWixDQU5WOztBQVN4QixPQUFJLFdBQVcsSUFBQyxJQUFRLEtBQUssRUFBTCxDQUFRLEtBQVIsQ0FBUixHQUEwQixJQUEzQixHQUFrQyxJQUFsQyxDQVRTO0FBVXhCLE9BQUksWUFBWSxTQUFTLE1BQVQsR0FBa0IsRUFBbEIsQ0FBcUIsZUFBckIsQ0FBWixFQUFtRCxXQUFXLFNBQVMsTUFBVCxFQUFYLENBQXZEOztBQUdBLE9BQUksTUFBTSxJQUFDLElBQVEsS0FBSyxFQUFMLENBQVEsS0FBUixDQUFSLEdBQTBCLElBQTNCLEdBQWtDLEVBQUUsU0FBRixDQUFsQyxDQWJjO0FBY3hCLE9BQUksSUFBSixDQUFTLEtBQVQsRUFkd0I7O0FBaUJ4QixPQUFJLFlBQVksSUFBSSxNQUFKLENBQVcsZUFBWCxDQUFaO09BQXlDLFVBQVUsVUFBVSxJQUFWLENBQWUsVUFBZixDQUFWLENBakJyQjs7QUFvQnhCLE9BQUksVUFBVSxXQUFWLEVBQXVCO0FBQzFCLFFBQUksQ0FBQyxVQUFVLE1BQVYsRUFBa0I7QUFDdEIsaUJBQVksRUFBRSxhQUFGLENBQVosQ0FEc0I7S0FBdkI7O0FBSUEsY0FBVSxJQUFWLENBQWUsT0FBZixFQUF3QixrQkFBZ0IsTUFBTSxPQUFOLENBQWhCLENBQXhCLENBQXdELEdBQXhELENBQTRELE9BQTVELEVBQXFFLE1BQU0sS0FBTixDQUFyRSxDQUwwQjs7QUFPMUIsUUFBSSxDQUFDLFFBQVEsTUFBUixFQUFnQjtBQUNwQixlQUFVLEVBQUUseUJBQUYsRUFBNkIsUUFBN0IsQ0FBc0MsU0FBdEMsQ0FBVixDQURvQjtLQUFyQjs7QUFJQSxZQUFRLElBQVIsQ0FBYSxPQUFiLEVBQXNCLGFBQVcsTUFBTSxPQUFOLENBQVgsQ0FBdEIsQ0FBaUQsSUFBakQsQ0FBc0QsVUFBVSxXQUFWLENBQXRELENBWDBCO0lBQTNCLE1BY0s7QUFDSixpQkFBWSxVQUFVLElBQVYsQ0FEUjtLQWRMOztBQW1CQSxPQUFJLFdBQVcsWUFBWSxTQUFaLEdBQXdCLEdBQXhCLENBdkNTOztBQTBDeEIsT0FBSSxZQUFZLFNBQVMsR0FBVCxDQUFhLFFBQWIsRUFBdUIsTUFBdkIsRUFBK0I7QUFDOUMsYUFBUyxXQUFULENBQXFCLFFBQXJCLEVBRDhDO0lBQS9DOztBQU1BLE9BQUksU0FBSixFQUFlO0FBQ2QsY0FBVSxPQUFWLENBQWtCLEdBQWxCLEVBRGM7SUFBZjs7QUFLQSxPQUFJLENBQUMsUUFBRCxFQUFXO0FBRWQsT0FBRyxPQUFILEdBRmM7QUFHZCxPQUFHLGFBQUgsQ0FBaUIsRUFBRSxTQUFGLEVBQWEsTUFBYixDQUFvQixRQUFwQixFQUE4QixJQUE5QixFQUFqQixFQUF1RCxFQUFDLFdBQVksQ0FBWixFQUF4RCxFQUhjO0lBQWY7O0FBTUEsTUFBRyxPQUFILEdBM0R3QjtBQTREeEIsTUFBRyxPQUFILEdBNUR3QjtHQUFiO0FBOERaLGtCQUFnQix3QkFBUyxJQUFULEVBQWU7QUFDOUIsUUFBSyxJQUFMLENBQVUsc0JBQVYsRUFBa0MsR0FBbEMsQ0FBc0MsS0FBSyxJQUFMLENBQVUsS0FBVixDQUF0QyxFQUQ4QjtBQUU5QixRQUFLLElBQUwsQ0FBVSxvQkFBVixFQUFnQyxHQUFoQyxDQUFvQyxLQUFLLElBQUwsQ0FBVSxPQUFWLENBQXBDLEVBRjhCO0FBRzlCLFFBQUssSUFBTCxDQUFVLHVCQUFWLEVBQW1DLEdBQW5DLENBQXVDLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBdkMsRUFIOEI7QUFJOUIsUUFBSyxJQUFMLENBQVUsb0JBQVYsRUFBZ0MsR0FBaEMsQ0FBb0MsS0FBSyxLQUFMLEVBQXBDLEVBSjhCO0FBSzlCLFFBQUssSUFBTCxDQUFVLHFCQUFWLEVBQWlDLEdBQWpDLENBQXFDLEtBQUssTUFBTCxFQUFyQyxFQUw4QjtBQU05QixRQUFLLElBQUwsQ0FBVSwwQkFBVixFQUFzQyxHQUF0QyxDQUEwQyxLQUFLLFFBQUwsQ0FBYyxnQkFBZCxFQUFnQyxJQUFoQyxFQUExQyxFQU44QjtBQU85QixRQUFLLElBQUwsQ0FBVSxxQkFBVixFQUFpQyxHQUFqQyxDQUFxQyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQXJDLEVBUDhCO0dBQWY7RUF2RmpCLEVBeCtCMkI7O0FBK2tDM0IsR0FBRSwrREFBRixFQUFtRSxPQUFuRSxDQUEyRTtBQUMxRSxpQkFBZSx5QkFBVztBQUN6QixPQUFJLFFBQVEsS0FBSyxJQUFMLENBQVUsb0JBQVYsRUFBZ0MsR0FBaEMsRUFBUjtPQUNILFNBQVMsS0FBSyxJQUFMLENBQVUscUJBQVYsRUFBaUMsR0FBakMsRUFBVCxDQUZ3QjtBQUd6QixVQUFPO0FBQ04sV0FBUSxLQUFLLElBQUwsQ0FBVSxrQkFBVixFQUE4QixHQUE5QixFQUFSO0FBQ0EsYUFBVSxRQUFRLFNBQVMsS0FBVCxFQUFnQixFQUFoQixDQUFSLEdBQThCLElBQTlCO0FBQ1YsY0FBVyxTQUFTLFNBQVMsTUFBVCxFQUFpQixFQUFqQixDQUFULEdBQWdDLElBQWhDO0FBQ1gsbUJBQWdCLEtBQUssSUFBTCxDQUFVLHFCQUFWLEVBQWlDLEdBQWpDLEVBQWhCO0lBSkQsQ0FIeUI7R0FBWDtBQVVmLFdBQVMsbUJBQVc7QUFDbkIsT0FBSSxRQUFRLEtBQUssYUFBTCxFQUFSLENBRGU7O0FBSW5CLE9BQUksS0FBSyxRQUFRLFlBQVIsQ0FBcUIsT0FBckIsQ0FBNkIsS0FBN0IsQ0FBbUMsU0FBbkMsQ0FBNkM7QUFDckQsWUFBUSxPQUFSO0FBQ0EsYUFBUyxNQUFNLEtBQU47QUFDVCxjQUFVLE1BQU0sTUFBTjtBQUNWLGNBQVUsRUFBQyxPQUFPLE1BQU0sR0FBTixFQUFsQjtBQUNBLGFBQVMsRUFBQyxXQUFXLEVBQVgsRUFBVjtJQUxRLENBQUwsQ0FKZTs7QUFZbkIsVUFBTyxFQUFFLFNBQUYsRUFBYSxNQUFiLENBQW9CLEVBQXBCLEVBQXdCLElBQXhCLEVBQVAsQ0FabUI7R0FBWDtBQWNULGtCQUFnQix3QkFBUyxJQUFULEVBQWUsRUFBZjtFQXpCakIsRUEva0MyQjs7QUFrbkMzQixHQUFFLCtEQUFGLEVBQW1FLE9BQW5FLENBQTJFO0FBQzFFLGlCQUFlLHlCQUFXO0FBQ3pCLE9BQUksUUFBUSxLQUFLLElBQUwsQ0FBVSxvQkFBVixFQUFnQyxHQUFoQyxFQUFSO09BQ0gsU0FBUyxLQUFLLElBQUwsQ0FBVSxxQkFBVixFQUFpQyxHQUFqQyxFQUFULENBRndCO0FBR3pCLFVBQU87QUFDTixXQUFRLEtBQUssSUFBTCxDQUFVLG9CQUFWLEVBQWdDLElBQWhDLENBQXFDLEtBQXJDLENBQVI7QUFDQSxhQUFVLFFBQVEsU0FBUyxLQUFULEVBQWdCLEVBQWhCLENBQVIsR0FBOEIsSUFBOUI7QUFDVixjQUFXLFNBQVMsU0FBUyxNQUFULEVBQWlCLEVBQWpCLENBQVQsR0FBZ0MsSUFBaEM7QUFDWCxhQUFVLEtBQUssSUFBTCxDQUFVLHVCQUFWLEVBQW1DLEdBQW5DLEVBQVY7QUFDQSxXQUFRLEtBQUssSUFBTCxDQUFVLHNCQUFWLEVBQWtDLEdBQWxDLEVBQVI7QUFDQSxhQUFVLEtBQUssSUFBTCxDQUFVLG9CQUFWLEVBQWdDLEdBQWhDLEVBQVY7QUFDQSxtQkFBZ0IsS0FBSyxJQUFMLENBQVUscUJBQVYsRUFBaUMsR0FBakMsRUFBaEI7SUFQRCxDQUh5QjtHQUFYO0FBYWYsZ0JBQWMsd0JBQVc7QUFDeEIsT0FBSSxRQUFRLEtBQUssSUFBTCxDQUFVLG9CQUFWLEVBQWdDLEdBQWhDLEVBQVI7T0FDSCxTQUFTLEtBQUssSUFBTCxDQUFVLHFCQUFWLEVBQWlDLEdBQWpDLEVBQVQsQ0FGdUI7QUFHeEIsVUFBTztBQUNOLG1CQUFlLEtBQUssSUFBTCxDQUFVLDBCQUFWLEVBQXNDLEdBQXRDLEVBQWY7QUFDQSxXQUFPLEtBQUssSUFBTCxDQUFVLGtCQUFWLEVBQThCLEdBQTlCLEVBQVA7QUFDQSxpQkFBYSxLQUFLLElBQUwsQ0FBVSxvQkFBVixFQUFnQyxJQUFoQyxDQUFxQyxLQUFyQyxDQUFiO0FBQ0EsYUFBVSxRQUFRLFNBQVMsS0FBVCxFQUFnQixFQUFoQixDQUFSLEdBQThCLElBQTlCO0FBQ1YsY0FBVyxTQUFTLFNBQVMsTUFBVCxFQUFpQixFQUFqQixDQUFULEdBQWdDLElBQWhDO0FBQ1gsZ0JBQVksS0FBSyxJQUFMLENBQVUsdUJBQVYsRUFBbUMsR0FBbkMsRUFBWjtJQU5ELENBSHdCO0dBQVg7QUFZZCxXQUFTLG1CQUFXO0FBQ25CLE9BQUksRUFBSjtPQUNDLFFBQVEsS0FBSyxhQUFMLEVBQVI7T0FDQSxZQUFZLEtBQUssWUFBTCxFQUFaO09BRUEsUUFBUSxFQUFFLFNBQUYsRUFBYSxJQUFiLENBQWtCLEtBQWxCLEVBQXlCLFFBQXpCLENBQWtDLCtCQUFsQyxDQUFSLENBTGtCOztBQU9uQixLQUFFLElBQUYsQ0FBTyxTQUFQLEVBQWtCLFVBQVUsR0FBVixFQUFlLEtBQWYsRUFBc0I7QUFDdkMsVUFBTSxJQUFOLENBQVcsVUFBVSxHQUFWLEVBQWUsS0FBMUIsRUFEdUM7SUFBdEIsQ0FBbEIsQ0FQbUI7O0FBV25CLE9BQUcsVUFBVSxXQUFWLEVBQXVCO0FBQ3pCLFNBQUssRUFBRSx3QkFBd0IsTUFBTSxPQUFOLENBQXhCLEdBQXlDLDJCQUF6QyxHQUF1RSxNQUFNLE9BQU4sQ0FBdkUsR0FBd0YsdUJBQXhGLEdBQWtILFVBQVUsV0FBVixHQUF3QixZQUExSSxDQUFGLENBQTBKLE9BQTFKLENBQWtLLEtBQWxLLENBQUwsQ0FEeUI7SUFBMUIsTUFFTztBQUNOLFNBQUssS0FBTCxDQURNO0lBRlA7QUFLQSxVQUFPLEVBQUUsU0FBRixFQUFhLE1BQWIsQ0FBb0IsRUFBcEIsRUFBd0IsSUFBeEIsRUFBUCxDQWhCbUI7R0FBWDtBQWtCVCxrQkFBZ0Isd0JBQVMsSUFBVCxFQUFlO0FBQzlCLFFBQUssSUFBTCxDQUFVLHNCQUFWLEVBQWtDLEdBQWxDLENBQXNDLEtBQUssSUFBTCxDQUFVLEtBQVYsQ0FBdEMsRUFEOEI7QUFFOUIsUUFBSyxJQUFMLENBQVUsb0JBQVYsRUFBZ0MsR0FBaEMsQ0FBb0MsS0FBSyxJQUFMLENBQVUsT0FBVixDQUFwQyxFQUY4QjtBQUc5QixRQUFLLElBQUwsQ0FBVSxvQkFBVixFQUFnQyxHQUFoQyxDQUFvQyxLQUFLLEtBQUwsRUFBcEMsRUFIOEI7QUFJOUIsUUFBSyxJQUFMLENBQVUscUJBQVYsRUFBaUMsR0FBakMsQ0FBcUMsS0FBSyxNQUFMLEVBQXJDLEVBSjhCO0FBSzlCLFFBQUssSUFBTCxDQUFVLG9CQUFWLEVBQWdDLEdBQWhDLENBQW9DLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBcEMsRUFMOEI7QUFNOUIsUUFBSyxJQUFMLENBQVUsdUJBQVYsRUFBbUMsR0FBbkMsQ0FBdUMsS0FBSyxJQUFMLENBQVUsVUFBVixDQUF2QyxFQU44QjtBQU85QixRQUFLLElBQUwsQ0FBVSxxQkFBVixFQUFpQyxHQUFqQyxDQUFxQyxLQUFLLElBQUwsQ0FBVSxRQUFWLENBQXJDLEVBUDhCO0dBQWY7RUE1Q2pCLEVBbG5DMkI7O0FBeXFDM0IsR0FBRSw0RUFBRixFQUFnRixPQUFoRixDQUF3RjtBQUN2RixXQUFTLElBQVQ7QUFDQSxXQUFTLG1CQUFZO0FBQ3BCLFFBQUssTUFBTCxHQURvQjs7QUFHcEIsUUFBSyxVQUFMLENBQWdCLFNBQVMsS0FBSyxHQUFMLEVBQVQsRUFBcUIsRUFBckIsQ0FBaEIsRUFIb0I7R0FBWjtBQUtULGFBQVcscUJBQVc7QUFDckIsUUFBSyxNQUFMLEdBRHFCO0dBQVg7QUFHWCxjQUFZLG9CQUFTLENBQVQsRUFBWTtBQUN2QixRQUFLLE9BQUwsQ0FBYSwwQkFBYixFQUF5QyxnQkFBekMsQ0FBMEQsS0FBSyxJQUFMLENBQVUsTUFBVixDQUExRCxFQUR1QjtHQUFaO0VBVmIsRUF6cUMyQjs7QUEyckMzQixHQUFFLGlGQUFGLEVBQXFGLE9BQXJGLENBQTZGO0FBQzVGLFdBQVMsaUJBQVMsQ0FBVCxFQUFZO0FBQ3BCLE9BQUksT0FBTyxLQUFLLE9BQUwsQ0FBYSxNQUFiLENBQVA7T0FBNkIsT0FBTyxLQUFLLE9BQUwsQ0FBYSxxQkFBYixDQUFQLENBRGI7QUFFcEIsUUFBSyxJQUFMLENBQVUsZ0NBQWdDLEtBQUssSUFBTCxDQUFVLElBQVYsQ0FBaEMsR0FBa0QsR0FBbEQsQ0FBVixDQUFpRSxXQUFqRSxDQUE2RSxhQUE3RSxFQUZvQjtBQUdwQixRQUFLLE9BQUwsQ0FBYSxzQkFBYixFQUFxQyxNQUFyQyxHQUhvQjtBQUlwQixRQUFLLE1BQUwsR0FKb0I7QUFLcEIsS0FBRSxjQUFGLEdBTG9CO0dBQVo7RUFEVixFQTNyQzJCOztBQXFzQzNCLEdBQUUsc0dBQUYsRUFBMEcsT0FBMUcsQ0FBa0g7QUFDakgsZUFBYSx1QkFBVztBQUN2QixVQUFPLEtBQUssT0FBTCxDQUFhLHNCQUFiLEVBQXFDLElBQXJDLENBQTBDLCtCQUExQyxDQUFQLENBRHVCO0dBQVg7O0FBSWIsZ0JBQWM7QUFDYixhQUFVLGtCQUFTLENBQVQsRUFBVztBQUNwQixRQUFJLE9BQU8sRUFBRSxFQUFFLE1BQUYsQ0FBVCxDQURnQjtBQUVwQixTQUFLLFdBQUwsQ0FBaUIsUUFBakIsRUFGb0I7QUFHcEIsU0FBSyxRQUFMLENBQWMsUUFBZCxFQUhvQjtJQUFYO0dBRFg7O0FBUUEsV0FBUyxpQkFBUyxDQUFULEVBQVk7QUFDcEIsT0FBSSxXQUFXLEtBQUssV0FBTCxFQUFYLENBRGdCOztBQUtwQixPQUFJLEtBQUssT0FBTCxDQUFhLHNCQUFiLEVBQXFDLFFBQXJDLENBQThDLHlCQUE5QyxDQUFKLEVBQThFO0FBQzdFLGFBQVMsTUFBVCxDQUFnQixxQkFBaEIsRUFBdUMsV0FBdkMsQ0FBbUQsa0JBQW5ELEVBRDZFOztBQUc3RSxhQUFTLGNBQVQsR0FINkU7O0FBSzdFLE1BQUUsY0FBRixHQUw2RTs7QUFPN0UsV0FBTyxLQUFQLENBUDZFO0lBQTlFOztBQVVBLFFBQUssTUFBTCxDQUFZLENBQVosRUFmb0I7R0FBWjtFQWJWLEVBcnNDMkI7O0FBcXVDM0IsR0FBRSx1REFBRixFQUEyRCxPQUEzRCxDQUFtRTtBQUNsRSxrQkFBZ0Isd0JBQVMsSUFBVCxFQUFlO0FBQzlCLE9BQUksV0FBVyxLQUFLLElBQUwsQ0FBVSwyQkFBVixDQUFYO09BQW1ELFNBQVMsU0FBUyxJQUFULENBQWMsNkJBQWQsQ0FBVCxDQUR6QjtBQUU5QixPQUFJLE9BQUssRUFBTCxDQUYwQjs7QUFJOUIsT0FBRyxTQUFTLElBQVQsSUFBa0IsU0FBUyxLQUFULElBQWtCLEtBQUssTUFBTCxPQUFrQixDQUFsQixFQUFzQjtBQUM1RCxXQUFPLGVBQUssRUFBTCxDQUFRLHFCQUFSLEVBQStCLGFBQS9CLENBQVAsQ0FENEQ7QUFFNUQsU0FBSyxNQUFMLENBQVksTUFBWixFQUY0RDtBQUc1RCxhQUFTLElBQVQsQ0FBYyxzQkFBZCxFQUFzQyxRQUF0QyxDQUErQyxRQUEvQyxFQUg0RDtBQUk1RCxXQUFPLFdBQVAsQ0FBbUIsdUJBQW5CLEVBQTRDLFdBQTVDLENBQXdELHVCQUF4RCxFQUo0RDtJQUE3RCxNQUtPO0FBQ04sU0FBSyxNQUFMLENBQVksQ0FBWixFQURNO0FBRU4sYUFBUyxJQUFULENBQWMsc0JBQWQsRUFBc0MsV0FBdEMsQ0FBa0QsUUFBbEQsRUFGTTtBQUdOLFFBQUcsQ0FBQyxLQUFLLFFBQUwsQ0FBYyxRQUFkLENBQUQsRUFBeUI7QUFDM0IsWUFBTyxlQUFLLEVBQUwsQ0FBUSx1QkFBUixFQUFpQyxZQUFqQyxDQUFQLENBRDJCO0FBRTNCLFlBQU8sUUFBUCxDQUFnQix1QkFBaEIsRUFGMkI7S0FBNUIsTUFHSztBQUNKLFlBQU8sZUFBSyxFQUFMLENBQVEsMEJBQVIsRUFBb0MsY0FBcEMsQ0FBUCxDQURJO0FBRUosVUFBSyxXQUFMLENBQWlCLFFBQWpCLEVBRkk7QUFHSixZQUFPLFFBQVAsQ0FBZ0IsdUJBQWhCLEVBSEk7S0FITDtJQVJEO0FBa0JBLFVBQU8sSUFBUCxDQUFZLE9BQVosRUFBb0IsSUFBcEIsRUFBMEIsSUFBMUIsQ0FBK0IsSUFBL0IsRUF0QjhCO0dBQWY7RUFEakIsRUFydUMyQjs7QUFpd0MzQixHQUFFLGlGQUFGLEVBQXFGLE9BQXJGLENBQTZGO0FBQzVGLFNBQU8saUJBQVc7QUFDakIsUUFBSyxNQUFMLEdBRGlCOztBQUlqQixPQUFJLE9BQU8sSUFBUCxDQUphO0FBS2pCLFFBQUssSUFBTCxDQUFVLFFBQVYsRUFBb0IsWUFBVztBQUM5QixRQUFJLFdBQVcsS0FBSyxPQUFMLENBQWEsTUFBYixFQUFxQixJQUFyQixDQUEwQixlQUExQixDQUFYLENBRDBCO0FBRTlCLGFBQVMsUUFBVCxDQUFrQixVQUFsQixFQUE4QixLQUFLLFFBQUwsRUFBOUIsRUFGOEI7QUFHOUIsYUFBUyxNQUFULEdBSDhCO0lBQVgsQ0FBcEIsQ0FMaUI7R0FBWDtFQURSLEVBandDMkI7Q0FBWixDQUFoQjs7Ozs7Ozs7Ozs7QUN0UUEsaUJBQUUsT0FBRixDQUFVLElBQVYsRUFBZ0IsVUFBUyxDQUFULEVBQVc7QUFJMUIsR0FBRSxZQUFGLEVBQWdCLE9BQWhCLENBQXdCO0FBQ3ZCLGtCQUFnQixLQUFoQjs7QUFFQSxTQUFPLGlCQUFXO0FBQ2pCLE9BQUksT0FBTyxPQUFPLFFBQVAsQ0FBZ0IsSUFBaEIsQ0FETTs7QUFJakIsUUFBSyxVQUFMLEdBSmlCOztBQU1qQixPQUFJLFNBQVMsRUFBVCxFQUFhO0FBQ2hCLFNBQUssY0FBTCxDQUFvQixJQUFwQixFQURnQjtJQUFqQjs7QUFJQSxRQUFLLE1BQUwsR0FWaUI7R0FBWDs7QUFhUCxZQUFVLG9CQUFXO0FBQ3BCLE9BQUcsS0FBSyxJQUFMLENBQVUsTUFBVixDQUFILEVBQXNCLEtBQUssSUFBTCxDQUFVLFNBQVYsRUFBdEI7QUFDQSxRQUFLLE1BQUwsR0FGb0I7R0FBWDs7QUFLVixjQUFZLHNCQUFXO0FBQ3RCLFFBQUssZ0JBQUwsR0FEc0I7QUFFdEIsUUFBSyxJQUFMLEdBRnNCO0dBQVg7O0FBVVosa0JBQWdCLHdCQUFVLElBQVYsRUFBZ0I7QUFDL0IsT0FBSSxRQUFKLENBRCtCOztBQUkvQixLQUFFLElBQUYsQ0FBTyxLQUFLLElBQUwsQ0FBVSxpQkFBVixDQUFQLEVBQXFDLFlBQVk7QUFFaEQsUUFBSSxLQUFLLElBQUwsQ0FBVSxPQUFWLENBQWtCLElBQWxCLE1BQTRCLENBQUMsQ0FBRCxJQUFNLEVBQUUsSUFBRixFQUFRLE1BQVIsS0FBbUIsQ0FBbkIsRUFBc0I7QUFDM0QsZ0JBQVcsRUFBRSxJQUFGLENBQVgsQ0FEMkQ7QUFFM0QsWUFBTyxLQUFQLENBRjJEO0tBQTVEO0lBRm9DLENBQXJDLENBSitCOztBQWEvQixPQUFJLGFBQWEsS0FBSyxDQUFMLEVBQVE7QUFDeEIsV0FEd0I7SUFBekI7O0FBS0EsS0FBRSxNQUFGLEVBQVUsR0FBVixDQUFjLGNBQWQsRUFBOEIsWUFBWTtBQUN6QyxhQUFTLEtBQVQsR0FEeUM7SUFBWixDQUE5QixDQWxCK0I7R0FBaEI7O0FBMkJoQixvQkFBa0IsNEJBQVc7QUFDNUIsS0FBRSxJQUFGLEVBQVEsSUFBUixDQUFhLE1BQWIsRUFBcUIsSUFBckIsQ0FBMEIsWUFBVztBQUNwQyxRQUFJLENBQUMsRUFBRSxJQUFGLEVBQVEsSUFBUixDQUFhLE1BQWIsQ0FBRCxFQUF1QixPQUEzQjs7QUFFQSxRQUFJLFVBQVUsRUFBRSxJQUFGLEVBQVEsSUFBUixDQUFhLE1BQWIsRUFBcUIsS0FBckIsQ0FBMkIsS0FBM0IsQ0FBVixDQUhnQztBQUlwQyxRQUFHLENBQUMsT0FBRCxFQUFVLE9BQWI7QUFDQSxNQUFFLElBQUYsRUFBUSxJQUFSLENBQWEsTUFBYixFQUFxQixTQUFTLFFBQVQsQ0FBa0IsSUFBbEIsQ0FBdUIsT0FBdkIsQ0FBK0IsS0FBL0IsRUFBc0MsRUFBdEMsSUFBNEMsUUFBUSxDQUFSLENBQTVDLENBQXJCLENBTG9DO0lBQVgsQ0FBMUIsQ0FENEI7R0FBWDtFQTFEbkIsRUFKMEI7Q0FBWCxDQUFoQjs7Ozs7Ozs7Ozs7Ozs7O0FDQ0EsaUJBQUUsT0FBRixDQUFVLElBQVYsRUFBZ0IsVUFBUyxDQUFULEVBQVc7QUFLMUIsS0FBSSxXQUFKLEVBQWlCLFlBQWpCLENBTDBCO0FBTTFCLEdBQUUsTUFBRixFQUFVLElBQVYsQ0FBZSwwQkFBZixFQUEyQyxZQUFXO0FBRXJELE1BQUksS0FBSyxTQUFMLEVBQUssR0FBVztBQUFDLEtBQUUsb0JBQUYsRUFBd0IsVUFBeEIsR0FBRDtHQUFYLENBRjRDOztBQUtyRCxNQUFHLEVBQUUsT0FBRixDQUFVLElBQVYsSUFBa0IsU0FBUyxFQUFFLE9BQUYsQ0FBVSxPQUFWLEVBQW1CLEVBQTVCLElBQWtDLENBQWxDLEVBQXFDO0FBQ3pELE9BQUksaUJBQWlCLEVBQUUsTUFBRixFQUFVLEtBQVYsRUFBakI7T0FBb0Msa0JBQWtCLEVBQUUsTUFBRixFQUFVLE1BQVYsRUFBbEIsQ0FEaUI7QUFFekQsT0FBRyxrQkFBa0IsV0FBbEIsSUFBaUMsbUJBQW1CLFlBQW5CLEVBQWlDO0FBQ3BFLGtCQUFjLGNBQWQsQ0FEb0U7QUFFcEUsbUJBQWUsZUFBZixDQUZvRTtBQUdwRSxTQUhvRTtJQUFyRTtHQUZELE1BT087QUFDTixRQURNO0dBUFA7RUFMMEMsQ0FBM0MsQ0FOMEI7O0FBdUIxQixLQUFJLFVBQVU7QUFDYixjQUFZLGVBQUssRUFBTCxDQUFRLDRCQUFSLENBQVo7QUFDQSxnQkFBYyxNQUFNLGVBQUssRUFBTCxDQUFRLDhCQUFSLENBQU4sR0FBZ0QsR0FBaEQ7QUFDZCxzQkFBb0IsTUFBTSxlQUFLLEVBQUwsQ0FBUSxvQ0FBUixDQUFOLEdBQXNELEdBQXREO0VBSGpCLENBdkJzQjs7QUE2QjFCLEtBQUksZUFBZSxTQUFmLFlBQWUsQ0FBUyxDQUFULEVBQVk7QUFFOUIsTUFBRyxDQUFDLEVBQUUsRUFBRSxNQUFGLENBQUYsQ0FBWSxPQUFaLENBQW9CLG9CQUFwQixFQUEwQyxNQUExQyxFQUFrRCxFQUFFLG9CQUFGLEVBQXdCLFVBQXhCLEdBQXREO0VBRmtCLENBN0JPOztBQTJDMUIsR0FBRSxvQkFBRixFQUF3QixPQUF4QixDQUFnQztBQUcvQixjQUFZLElBQVo7O0FBRUEsU0FBTyxpQkFBVztBQUNqQixRQUFLLE1BQUwsQ0FDQyxrREFDQSw4R0FEQSxHQUVBLDRFQUZBLENBREQsQ0FEaUI7O0FBT2pCLE9BQUksWUFBWSxRQUFRLFFBQVIsQ0FQQztBQVFqQixPQUFHLFNBQUgsRUFBYyxLQUFLLElBQUwsQ0FBVSx1Q0FBVixFQUFtRCxJQUFuRCxDQUF3RCxPQUF4RCxFQUFpRSxTQUFqRSxFQUFkO0FBQ0EsT0FBRyxLQUFLLElBQUwsQ0FBVSxPQUFWLENBQUgsRUFBdUIsS0FBSyxRQUFMLENBQWMsS0FBSyxJQUFMLENBQVUsT0FBVixDQUFkLEVBQXZCOztBQUVBLFFBQUssUUFBTCxHQUFnQixJQUFoQixHQVhpQjtBQVlqQixRQUFLLE1BQUwsR0FaaUI7R0FBWDtBQWNQLFlBQVUsb0JBQVc7QUFDcEIsVUFBTyxLQUFLLElBQUwsQ0FBVSwwQkFBVixDQUFQLENBRG9CO0dBQVg7QUFHVixhQUFXLHFCQUFXO0FBRXJCLEtBQUUsb0JBQUYsRUFBd0IsVUFBeEIsR0FGcUI7O0FBS3JCLEtBQUUsTUFBRixFQUFVLElBQVYsQ0FBZSxPQUFmLEVBQXdCLFlBQXhCLEVBTHFCOztBQU9yQixPQUFJLFFBQVEsS0FBSyxRQUFMLEVBQVI7T0FBeUIsT0FBTyxLQUFLLElBQUwsQ0FBVSxjQUFWLENBQVAsQ0FQUjs7QUFTckIsU0FBTSxHQUFOLENBQVUsT0FBVixFQUFtQixLQUFLLEtBQUwsRUFBbkIsRUFUcUI7O0FBV3JCLFNBQU0sSUFBTixHQVhxQjs7QUFjckIsT0FBSSxTQUFTLEtBQUssSUFBTCxDQUFVLHNDQUFWLENBQVQsQ0FkaUI7QUFlckIsVUFBTyxRQUFQLENBQWdCLDZCQUFoQixFQWZxQjtBQWdCckIsUUFBSyxRQUFMLENBQWMsNkJBQWQsRUFoQnFCOztBQWtCckIsVUFBTyxJQUFQLENBQVksR0FBWixFQUNFLFdBREYsQ0FDYyxzQkFEZCxFQUVFLFFBRkYsQ0FFVyxzQkFGWCxFQWxCcUI7O0FBc0JyQixPQUFHLEtBQUssRUFBTCxDQUFRLFFBQVIsS0FBcUIsQ0FBQyxNQUFNLFFBQU4sQ0FBZSxTQUFmLENBQUQsRUFBNEI7QUFDbkQsU0FBSyxRQUFMLENBQWMsSUFBZCxFQUFvQixLQUFLLE9BQUwsQ0FBcEIsQ0FEbUQ7SUFBcEQsTUFFTztBQUNOLFNBQUssT0FBTCxHQURNO0lBRlA7O0FBTUEsUUFBSyxPQUFMLENBQWEsV0FBYixFQTVCcUI7R0FBWDtBQThCWCxXQUFTLG1CQUFXO0FBQ25CLE9BQUksWUFBWSxJQUFaO09BQ0gsV0FBVyxLQUFLLFFBQUwsRUFBWDtPQUNBLFNBQVMsS0FBSyxJQUFMLENBQVUsc0NBQVYsQ0FBVDtPQUNBLFlBQVksT0FBTyxXQUFQLEVBQVo7T0FDQSxRQUpEO09BS0MsS0FMRDtPQU1DLFdBTkQsQ0FEbUI7O0FBU25CLE9BQUksT0FBTyxNQUFQLEdBQWdCLENBQWhCLEVBQW1CO0FBQ3RCLGtCQUFjLENBQUMsQ0FBRSxNQUFGLEVBQVUsTUFBVixLQUFxQixFQUFFLFFBQUYsRUFBWSxTQUFaLEVBQXJCLEdBQWdELE9BQU8sV0FBUCxFQUFqRCxDQURRO0FBRXRCLFlBQVEsT0FBTyxNQUFQLEdBQWdCLEdBQWhCLENBRmM7QUFHdEIsZUFBVyxTQUFTLFdBQVQsRUFBWCxDQUhzQjs7QUFNdEIsUUFBSSxRQUFRLFFBQVIsR0FBbUIsV0FBbkIsSUFBa0MsUUFBUSxRQUFSLEdBQW1CLENBQW5CLEVBQXNCO0FBQzNELGVBQVUsUUFBVixDQUFtQiw2QkFBbkIsRUFEMkQ7QUFFM0QsaUJBQVksQ0FBQyxTQUFTLFdBQVQsRUFBRCxDQUYrQztLQUE1RCxNQUdPO0FBQ04sZUFBVSxXQUFWLENBQXNCLDZCQUF0QixFQURNO0tBSFA7SUFORDtBQWFBLFlBQVMsR0FBVCxDQUFhLEVBQUMsT0FBTyxZQUFZLElBQVosRUFBckIsRUF0Qm1CO0dBQVg7QUF3QlQsY0FBWSxzQkFBVztBQUN0QixVQUFPLE1BQVAsRUFBZSxNQUFmLENBQXNCLE9BQXRCLEVBQStCLFlBQS9CLEVBRHNCOztBQUl0QixPQUFJLFNBQVMsS0FBSyxJQUFMLENBQVUsc0NBQVYsQ0FBVCxDQUprQjtBQUt0QixVQUFPLFdBQVAsQ0FBbUIsNkJBQW5CLEVBTHNCO0FBTXRCLFFBQUssV0FBTCxDQUFpQix5REFBakIsRUFOc0I7O0FBUXRCLFVBQU8sSUFBUCxDQUFZLEdBQVosRUFDRSxXQURGLENBQ2Msc0JBRGQsRUFFRSxRQUZGLENBRVcsc0JBRlgsRUFSc0I7O0FBYXRCLFFBQUssUUFBTCxHQUFnQixJQUFoQixHQWJzQjtBQWN0QixRQUFLLE9BQUwsQ0FBYSxXQUFiLEVBZHNCO0dBQVg7QUFnQlosZUFBYSx1QkFBVztBQUN2QixRQUFLLEtBQUssUUFBTCxHQUFnQixFQUFoQixDQUFtQixVQUFuQixJQUFpQyxZQUFqQyxHQUFnRCxXQUFoRCxDQUFMLEdBRHVCO0dBQVg7QUFHYixZQUFVLGtCQUFTLEtBQVQsRUFBZ0I7QUFDekIsV0FBUSxTQUFTLEtBQUssSUFBTCxDQUFVLE9BQVYsQ0FBVCxJQUErQixRQUFRLFVBQVIsQ0FEZDs7QUFHekIsUUFBSyxJQUFMLENBQVUsMEJBQVYsRUFBc0MsSUFBdEMsQ0FBMkMsS0FBM0MsRUFIeUI7QUFJekIsUUFBSyxJQUFMLENBQVUsT0FBVixFQUFtQixLQUFuQixFQUp5QjtHQUFoQjtBQU1WLFlBQVUsb0JBQVc7QUFDcEIsVUFBTyxLQUFLLElBQUwsQ0FBVSwwQkFBVixFQUFzQyxJQUF0QyxFQUFQLENBRG9CO0dBQVg7O0FBTVYsZUFBYSx1QkFBVztBQUN2QixPQUFJLE9BQU8sSUFBUDtPQUFhLE9BQU8sS0FBSyxJQUFMLENBQVUsY0FBVixDQUFQO09BQWtDLE1BQU0sS0FBSyxRQUFMLEVBQU4sQ0FENUI7QUFFdkIsT0FBSSxXQUFXLFNBQVgsUUFBVyxHQUFXO0FBQ3pCLFFBQUksTUFBTSxLQUFLLFFBQUwsRUFBTixDQURxQjtBQUV6QixRQUFHLEdBQUgsRUFBUTs7QUFFUCxTQUFJLE9BQU8sS0FBSyxJQUFMLENBQVUsZ0JBQWdCLEdBQWhCLEdBQXNCLElBQXRCLENBQWpCO1NBQ0gsUUFBUSxLQUFLLFFBQUwsQ0FBYyxHQUFkLEVBQW1CLElBQW5CLENBQXdCLHNCQUF4QixJQUFnRCxLQUFLLFFBQUwsQ0FBYyxHQUFkLEVBQW1CLElBQW5CLENBQXdCLFdBQXhCLEVBQXFDLElBQXJDLEVBQWhELEdBQTRGLElBQTVGLENBSEY7QUFJUCxTQUFHLENBQUMsS0FBRCxFQUFRLFFBQU0sSUFBQyxDQUFLLE1BQUwsR0FBYyxDQUFkLEdBQW1CLEtBQUssTUFBTCxDQUFZLFVBQVosRUFBd0IsS0FBSyxDQUFMLENBQXhCLENBQXBCLEdBQXVELElBQXZELENBQWpCOztBQUVBLFNBQUcsS0FBSCxFQUFVO0FBQ1QsV0FBSyxRQUFMLENBQWMsS0FBZCxFQURTO0FBRVQsV0FBSyxJQUFMLENBQVUsT0FBVixFQUFtQixLQUFuQixFQUZTO01BQVY7QUFJQSxTQUFHLElBQUgsRUFBUyxLQUFLLE1BQUwsQ0FBWSxhQUFaLEVBQTJCLElBQTNCLEVBQVQ7S0FWRCxNQVlLO0FBQ0osVUFBSyxRQUFMLENBQWMsS0FBSyxJQUFMLENBQVUsYUFBVixDQUFkLEVBREk7QUFFSixVQUFLLFVBQUwsQ0FBZ0IsT0FBaEIsRUFGSTtLQVpMO0lBRmMsQ0FGUTs7QUF1QnZCLE9BQUcsQ0FBQyxLQUFLLEVBQUwsQ0FBUSxRQUFSLENBQUQsSUFBc0IsQ0FBQyxHQUFELEVBQU0sV0FBL0IsS0FDSyxLQUFLLFFBQUwsQ0FBYyxFQUFDLFlBQVksR0FBWixFQUFmLEVBQWlDLFFBQWpDLEVBREw7R0F2Qlk7QUEwQmIsWUFBVSxrQkFBUyxHQUFULEVBQWM7QUFDdkIsUUFBSyxJQUFMLENBQVUsVUFBVixFQUFzQixFQUFFLE1BQUYsQ0FBUyxLQUFLLElBQUwsQ0FBVSxVQUFWLENBQVQsRUFBZ0MsRUFBQyxJQUFJLEdBQUosRUFBakMsQ0FBdEIsRUFEdUI7QUFFdkIsUUFBSyxJQUFMLENBQVUsZUFBVixFQUEyQixHQUEzQixDQUErQixHQUEvQixFQUdFLE9BSEYsQ0FHVSxjQUhWLEVBSUUsT0FKRixDQUlVLFFBSlYsRUFGdUI7R0FBZDtBQVFWLFlBQVUsb0JBQVc7QUFDcEIsVUFBTyxLQUFLLElBQUwsQ0FBVSxlQUFWLEVBQTJCLEdBQTNCLEVBQVAsQ0FEb0I7R0FBWDtBQUdWLFlBQVUsa0JBQVMsTUFBVCxFQUFpQixRQUFqQixFQUEyQjtBQUNwQyxPQUFJLE9BQU8sSUFBUDtPQUFhLFFBQVEsS0FBSyxRQUFMLEVBQVI7T0FBeUIsYUFBYSxFQUFFLEtBQUYsRUFBUyxJQUFULENBQWMsY0FBZCxDQUFiO09BQ3pDLFNBQVMsU0FBVyxFQUFFLE1BQUYsQ0FBUyxFQUFULEVBQWEsS0FBSyxnQkFBTCxFQUFiLEVBQXNDLE1BQXRDLENBQVgsR0FBMkQsS0FBSyxnQkFBTCxFQUEzRDtPQUFvRixHQUQ5RixDQURvQzs7QUFJcEMsT0FBRyxLQUFLLGFBQUwsRUFBSCxFQUF5QixLQUFLLGFBQUwsR0FBcUIsS0FBckIsR0FBekI7QUFDQSxTQUFNLFFBQU4sQ0FBZSxTQUFmLEVBTG9DO0FBTXBDLFNBQU0sRUFBRSxJQUFGLENBQU87QUFDWixTQUFLLEtBQUssSUFBTCxDQUFVLFNBQVYsQ0FBTDtBQUNBLFVBQU0sTUFBTjtBQUNBLGNBQVUsa0JBQVMsR0FBVCxFQUFjLE1BQWQsRUFBc0I7QUFDL0IsV0FBTSxXQUFOLENBQWtCLFNBQWxCLEVBRCtCO0tBQXRCO0FBR1YsYUFBUyxpQkFBUyxJQUFULEVBQWUsTUFBZixFQUF1QixHQUF2QixFQUE0QjtBQUNwQyxnQkFBVyxJQUFYLENBQWdCLElBQWhCLEVBRG9DO0FBRXBDLFNBQUksWUFBWSxJQUFaLENBRmdDO0FBR3BDLGdCQUNFLE1BREYsQ0FDUyxTQURULEVBRUUsSUFGRixDQUVPLGVBRlAsRUFFd0IsVUFBUyxDQUFULEVBQVksSUFBWixFQUFrQjtBQUN4QyxVQUFJLE1BQU0sS0FBSyxRQUFMLEVBQU47VUFBdUIsYUFBYSxXQUFXLElBQVgsQ0FBZ0IsZ0JBQWdCLEdBQWhCLEdBQXNCLElBQXRCLENBQTdCO1VBQzFCLGNBQWMsS0FBSyxJQUFMLENBQVUsWUFBVixFQUFkLENBRnVDO0FBR3hDLFVBQUcsT0FBTyxjQUFjLFdBQWQsRUFBMkIsS0FBSyxJQUFMLENBQVUsV0FBVixDQUFzQixVQUF0QixFQUFyQztBQUNBLGtCQUFZLEtBQVosQ0FKd0M7QUFLeEMsVUFBRyxRQUFILEVBQWEsU0FBUyxLQUFULENBQWUsSUFBZixFQUFiO01BTHNCLENBRnhCLENBU0UsTUFURixDQVNTLEtBQUssYUFBTCxFQVRULEVBVUUsSUFWRixDQVVPLG9CQVZQLEVBVTZCLFVBQVMsQ0FBVCxFQUFZLElBQVosRUFBa0I7QUFDN0MsVUFBSSxPQUFPLEtBQUssSUFBTCxDQUFVLEdBQVY7VUFBZSxLQUFLLEVBQUUsSUFBRixFQUFRLElBQVIsQ0FBYSxJQUFiLENBQUwsQ0FEbUI7QUFFN0MsVUFBRyxDQUFDLFNBQUQsSUFBYyxLQUFLLFFBQUwsTUFBbUIsRUFBbkIsRUFBdUI7QUFFdkMsWUFBSyxJQUFMLENBQVUsVUFBVixFQUFzQixJQUF0QixFQUZ1QztBQUd2QyxZQUFLLFFBQUwsQ0FBYyxJQUFkLEVBSHVDO0FBSXZDLFlBQUssUUFBTCxDQUFjLElBQWQsRUFKdUM7QUFLdkMsWUFBSyxJQUFMLENBQVUsYUFBVixDQUF3QixJQUF4QixFQUx1QztPQUF4QyxNQU1PO0FBQ04sWUFBSyxJQUFMLENBQVUsVUFBVixFQUFzQixFQUFFLE1BQUYsQ0FBUyxFQUFDLElBQUksRUFBSixFQUFWLEVBQW1CLEVBQUUsSUFBRixFQUFRLFdBQVIsRUFBbkIsQ0FBdEIsRUFETTtBQUVOLFlBQUssUUFBTCxDQUFjLEtBQUssSUFBTCxDQUFVLFFBQVYsQ0FBbUIsSUFBbkIsQ0FBZCxFQUZNO0FBR04sWUFBSyxRQUFMLENBQWMsRUFBZCxFQUhNO09BTlA7O0FBYUEsVUFBRyxDQUFDLFNBQUQsRUFBWSxLQUFLLFVBQUwsR0FBZjtBQUNBLGtCQUFVLEtBQVYsQ0FoQjZDO01BQWxCLENBVjdCLENBSG9DOztBQWdDcEMsVUFBSyxhQUFMLENBQW1CLElBQW5CLEVBaENvQztLQUE1QjtJQU5KLENBQU4sQ0FOb0M7QUErQ3BDLFFBQUssYUFBTCxDQUFtQixHQUFuQixFQS9Db0M7R0FBM0I7QUFpRFYsaUJBQWUseUJBQVc7QUFDekIsT0FBSSxPQUFPLElBQVAsQ0FEcUI7QUFFekIsVUFBTztBQUNOLFlBQVE7QUFDUCxvQkFBZSxJQUFmOztBQUVBLGtCQUFhLENBQWI7S0FIRDtBQUtBLGlCQUFhO0FBRVosYUFBUSxLQUFLLFFBQUwsR0FBZ0IsSUFBaEIsQ0FBcUIsY0FBckIsRUFBcUMsSUFBckMsRUFBUjtBQUNBLGFBQVE7QUFDUCxhQUFPLGFBQVMsSUFBVCxFQUFlO0FBQ3JCLFdBQUksTUFBTSxFQUFFLElBQUYsQ0FBTyxRQUFQLENBQWdCLEtBQUssSUFBTCxDQUFVLFNBQVYsQ0FBaEIsRUFBc0MsWUFBdEMsQ0FEVztBQUVyQixjQUFPLE1BQU0sR0FBTixJQUFhLEVBQUUsSUFBRixFQUFRLElBQVIsQ0FBYSxJQUFiLElBQXFCLEVBQUUsSUFBRixFQUFRLElBQVIsQ0FBYSxJQUFiLENBQXJCLEdBQTBDLENBQTFDLENBQWIsQ0FGYztPQUFmO0FBSVAsY0FBUSxjQUFTLElBQVQsRUFBZTtBQUN0QixXQUFJLFFBQVEsRUFBRSxLQUFGLENBQVEsSUFBUixDQUFhLEtBQUssSUFBTCxDQUFVLFNBQVYsQ0FBYixFQUFtQyxJQUFuQyxDQURVO0FBRXRCLFdBQUksU0FBUyxLQUFLLGdCQUFMLEVBQVQsQ0FGa0I7QUFHdEIsZ0JBQVMsRUFBRSxNQUFGLENBQVMsRUFBVCxFQUFhLEtBQWIsRUFBb0IsTUFBcEIsRUFBNEIsRUFBQyxNQUFNLENBQU4sRUFBN0IsQ0FBVCxDQUhzQjtBQUl0QixjQUFPLE1BQVAsQ0FKc0I7T0FBZjtNQUxUO0tBSEQ7QUFnQkEsVUFBTTtBQUNMLHFCQUFpQixDQUFqQjtBQUNBLHlCQUFvQixDQUFDLEtBQUssUUFBTCxHQUFnQixJQUFoQixDQUFxQixVQUFyQixFQUFpQyxJQUFqQyxDQUFzQyxJQUF0QyxDQUFELENBQXBCO0tBRkQ7QUFJQSxjQUFVO0FBQ1QsY0FBUyxPQUFUO0tBREQ7QUFHQSxhQUFVO0FBQ1QsY0FBVTtBQUNULGlCQUFXO0FBQ1YscUJBQWMsb0JBQVMsSUFBVCxFQUFlO0FBQzVCLGVBQVMsQ0FBRSxLQUFLLFFBQUwsQ0FBYyxVQUFkLENBQUYsQ0FEbUI7UUFBZjtBQUdkLHVCQUFnQixzQkFBUyxJQUFULEVBQWU7QUFDOUIsZUFBUyxDQUFFLEtBQUssUUFBTCxDQUFjLFVBQWQsQ0FBRixDQURxQjtRQUFmO0FBR2hCLHNCQUFlLHFCQUFTLElBQVQsRUFBZTtBQUM3QixlQUFTLENBQUUsS0FBSyxRQUFMLENBQWMsVUFBZCxDQUFGLENBRG9CO1FBQWY7QUFHZix3QkFBaUIsdUJBQVMsSUFBVCxFQUFlO0FBQy9CLGVBQVMsQ0FBRSxLQUFLLFFBQUwsQ0FBYyxVQUFkLENBQUYsQ0FEc0I7UUFBZjtPQVZsQjtNQUREO0tBREQ7QUFrQkEsZUFBVyxDQUFDLFdBQUQsRUFBYyxJQUFkLEVBQW9CLFFBQXBCLEVBQThCLE9BQTlCLENBQVg7SUEvQ0QsQ0FGeUI7R0FBWDs7QUEyRGYsb0JBQWtCLDRCQUFXO0FBQzVCLFVBQU8sRUFBUCxDQUQ0QjtHQUFYO0VBNVBuQixFQTNDMEI7O0FBNFMxQixHQUFFLG9DQUFGLEVBQXdDLE9BQXhDLENBQWdEO0FBTy9DLGVBQWEsdUJBQVc7QUFDdkIsT0FBSSxVQUFVLEtBQUssSUFBTCxDQUFVLE9BQVYsRUFBbUIsS0FBbkIsQ0FBeUIsaUJBQXpCLENBQVYsQ0FEbUI7QUFFdkIsT0FBSSxRQUFRLFVBQVUsUUFBUSxDQUFSLENBQVYsR0FBdUIsRUFBdkIsQ0FGVztBQUd2QixVQUFPLEVBQUMsV0FBVyxLQUFYLEVBQVIsQ0FIdUI7R0FBWDtFQVBkLEVBNVMwQjs7QUEwVDFCLEdBQUUsc0JBQUYsRUFBMEIsT0FBMUIsQ0FBa0M7QUFDakMsWUFBVSxvQkFBVztBQUNwQixVQUFPLEtBQUssT0FBTCxDQUFhLDBCQUFiLENBQVAsQ0FEb0I7R0FBWDtFQURYLEVBMVQwQjs7QUFnVTFCLEdBQUUsb0JBQUYsRUFBd0IsT0FBeEIsQ0FBZ0M7QUFDL0IsV0FBUyxpQkFBUyxDQUFULEVBQVk7QUFDcEIsUUFBSyxXQUFMLEdBRG9COztBQUdwQixVQUFPLEtBQVAsQ0FIb0I7R0FBWjtFQURWLEVBaFUwQjs7QUF3VTFCLEdBQUUsNkNBQUYsRUFBaUQsT0FBakQsQ0FBeUQ7QUFDeEQsV0FBUyxpQkFBUyxDQUFULEVBQVk7QUFDcEIsVUFBTyxLQUFQLENBRG9CO0dBQVo7RUFEVixFQXhVMEI7O0FBOFUxQixHQUFFLCtCQUFGLEVBQW1DLE9BQW5DLENBQTJDO0FBQzFDLFNBQU8saUJBQVc7QUFDakIsUUFBSyxNQUFMLEdBRGlCO0FBRWpCLE9BQUksUUFBUSxlQUFLLEVBQUwsQ0FBUSxpQ0FBUixDQUFSLENBRmE7QUFHakIsUUFBSyxJQUFMLENBQVUsMEJBQVYsRUFBc0MsT0FBdEMsQ0FDQyxFQUFFLHdHQUF3RyxLQUF4RyxHQUFnSCxlQUFoSCxDQURILEVBSGlCO0dBQVg7QUFPUCxVQUFRLGdCQUFTLEdBQVQsRUFBYyxRQUFkLEVBQXdCO0FBQy9CLFFBQUssU0FBTCxHQUQrQjtBQUUvQixRQUFLLFFBQUwsQ0FBYyxFQUFDLFFBQVEsR0FBUixFQUFmLEVBQTZCLFFBQTdCLEVBRitCO0dBQXhCO0FBSVIsZ0JBQWMsd0JBQVc7QUFDeEIsUUFBSyxVQUFMLEdBRHdCO0FBRXhCLFFBQUssUUFBTCxHQUZ3QjtHQUFYO0VBWmYsRUE5VTBCOztBQWdXMUIsR0FBRSw0Q0FBRixFQUFnRCxPQUFoRCxDQUF3RDtBQUN2RCxhQUFXLG1CQUFTLENBQVQsRUFBWTtBQUN0QixPQUFJLFFBQVEsS0FBSyxRQUFMLEVBQVIsQ0FEa0I7QUFFdEIsT0FBRyxFQUFFLE9BQUYsSUFBYSxFQUFiLEVBQWlCO0FBRW5CLFVBQU0sTUFBTixDQUFhLEtBQUssR0FBTCxFQUFiLEVBRm1CO0FBR25CLFdBQU8sS0FBUCxDQUhtQjtJQUFwQixNQUlPLElBQUcsRUFBRSxPQUFGLElBQWEsRUFBYixFQUFpQjtBQUUxQixVQUFNLFlBQU4sR0FGMEI7SUFBcEI7R0FORztFQURaLEVBaFcwQjs7QUE4VzFCLEdBQUUsNkJBQUYsRUFBaUMsT0FBakMsQ0FBeUM7QUFDeEMsaUJBQWUseUJBQVc7QUFDekIsT0FBSSxNQUFNLEtBQUssTUFBTCxFQUFOLENBRHFCO0FBRXpCLE9BQUksUUFBSixHQUFlLEVBQUMsYUFBYSxJQUFiLEVBQW1CLFdBQVcsSUFBWCxFQUFuQyxDQUZ5QjtBQUd6QixPQUFJLE9BQUosQ0FBWSxJQUFaLENBQWlCLFVBQWpCLEVBSHlCO0FBSXpCLE9BQUksRUFBSixDQUFPLFlBQVAsR0FBc0IsQ0FBQyxDQUFELENBSkc7QUFLekIsVUFBTyxHQUFQLENBTHlCO0dBQVg7QUFPZixZQUFVLGtCQUFTLE1BQVQsRUFBaUIsUUFBakIsRUFBMkI7QUFDcEMsT0FBSSxPQUFPLElBQVA7T0FBYSxRQUFRLEtBQUssUUFBTCxFQUFSO09BQXlCLGFBQWEsRUFBRSxLQUFGLEVBQVMsSUFBVCxDQUFjLGNBQWQsQ0FBYixDQUROO0FBRXBDLE9BQUksU0FBUyxTQUFXLEVBQUUsTUFBRixDQUFTLEVBQVQsRUFBYSxLQUFLLGdCQUFMLEVBQWIsRUFBc0MsTUFBdEMsQ0FBWCxHQUEyRCxLQUFLLGdCQUFMLEVBQTNEO09BQW9GLEdBQWpHLENBRm9DOztBQUlwQyxPQUFHLEtBQUssYUFBTCxFQUFILEVBQXlCLEtBQUssYUFBTCxHQUFxQixLQUFyQixHQUF6QjtBQUNBLFNBQU0sUUFBTixDQUFlLFNBQWYsRUFMb0M7QUFNcEMsU0FBTSxFQUFFLElBQUYsQ0FBTztBQUNaLFNBQUssS0FBSyxJQUFMLENBQVUsU0FBVixDQUFMO0FBQ0EsVUFBTSxNQUFOO0FBQ0EsY0FBVSxrQkFBUyxHQUFULEVBQWMsTUFBZCxFQUFzQjtBQUMvQixXQUFNLFdBQU4sQ0FBa0IsU0FBbEIsRUFEK0I7S0FBdEI7QUFHVixhQUFTLGlCQUFTLElBQVQsRUFBZSxNQUFmLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3BDLGdCQUFXLElBQVgsQ0FBZ0IsSUFBaEIsRUFEb0M7QUFFcEMsU0FBSSxZQUFZLElBQVosQ0FGZ0M7QUFHcEMsVUFBSyxhQUFMLENBQW1CLElBQW5CLEVBSG9DO0FBSXBDLGdCQUNFLE1BREYsQ0FDUyxTQURULEVBRUUsSUFGRixDQUVPLGVBRlAsRUFFd0IsVUFBUyxDQUFULEVBQVksSUFBWixFQUFrQjtBQUN4QyxRQUFFLElBQUYsQ0FBTyxLQUFLLFFBQUwsRUFBUCxFQUF3QixVQUFTLENBQVQsRUFBWSxHQUFaLEVBQWlCO0FBQ3hDLFlBQUssSUFBTCxDQUFVLFVBQVYsQ0FBcUIsV0FBVyxJQUFYLENBQWdCLGVBQWUsR0FBZixHQUFxQixHQUFyQixDQUFyQyxFQUR3QztPQUFqQixDQUF4QixDQUR3QztBQUl4QyxrQkFBWSxLQUFaLENBSndDO0FBS3hDLFVBQUcsUUFBSCxFQUFhLFNBQVMsS0FBVCxDQUFlLElBQWYsRUFBYjtNQUxzQixDQUZ4QixDQVNFLE1BVEYsQ0FTUyxLQUFLLGFBQUwsRUFUVCxFQVVFLElBVkYsQ0FVTyx1Q0FWUCxFQVVnRCxVQUFTLENBQVQsRUFBWSxJQUFaLEVBQWtCO0FBQ2hFLFVBQUksUUFBUSxLQUFLLElBQUwsQ0FBVSxXQUFWLENBQXNCLElBQXRCLEVBQTRCLElBQTVCLENBQVIsQ0FENEQ7QUFFaEUsV0FBSyxRQUFMLENBQWMsRUFBRSxHQUFGLENBQU0sS0FBTixFQUFhLFVBQVMsRUFBVCxFQUFhLENBQWIsRUFBZ0I7QUFDMUMsY0FBTyxFQUFFLEVBQUYsRUFBTSxJQUFOLENBQVcsSUFBWCxDQUFQLENBRDBDO09BQWhCLENBQTNCLEVBRmdFO0FBS2hFLFdBQUssUUFBTCxDQUFjLEVBQUUsR0FBRixDQUFNLEtBQU4sRUFBYSxVQUFTLEVBQVQsRUFBYSxDQUFiLEVBQWdCO0FBQzFDLGNBQU8sS0FBSyxJQUFMLENBQVUsUUFBVixDQUFtQixFQUFuQixDQUFQLENBRDBDO09BQWhCLENBQTNCLEVBTGdFO0FBUWhFLFdBQUssSUFBTCxDQUFVLFVBQVYsRUFBc0IsRUFBRSxHQUFGLENBQU0sS0FBTixFQUFhLFVBQVMsRUFBVCxFQUFhLENBQWIsRUFBZ0I7QUFDbEQsY0FBTyxFQUFDLElBQUksRUFBRSxFQUFGLEVBQU0sSUFBTixDQUFXLElBQVgsQ0FBSixFQUFzQixVQUFVLEVBQUUsRUFBRixFQUFNLFdBQU4sRUFBVixFQUE5QixDQURrRDtPQUFoQixDQUFuQyxFQVJnRTtNQUFsQixDQVZoRCxDQUpvQztLQUE1QjtJQU5KLENBQU4sQ0FOb0M7QUF3Q3BDLFFBQUssYUFBTCxDQUFtQixHQUFuQixFQXhDb0M7R0FBM0I7QUEwQ1YsWUFBVSxvQkFBVztBQUNwQixPQUFJLE1BQU0sS0FBSyxNQUFMLEVBQU4sQ0FEZ0I7QUFFcEIsVUFBTyxJQUFJLEtBQUosQ0FBVSxPQUFWLENBQVAsQ0FGb0I7R0FBWDtBQUlWLFlBQVUsa0JBQVMsR0FBVCxFQUFjO0FBQ3ZCLFFBQUssTUFBTCxDQUFZLEVBQUUsT0FBRixDQUFVLEdBQVYsSUFBaUIsSUFBSSxJQUFKLENBQVMsR0FBVCxDQUFqQixHQUFpQyxHQUFqQyxDQUFaLENBRHVCO0dBQWQ7QUFHVixZQUFVLGtCQUFTLEtBQVQsRUFBZ0I7QUFDekIsUUFBSyxNQUFMLENBQVksRUFBRSxPQUFGLENBQVUsS0FBVixJQUFtQixNQUFNLElBQU4sQ0FBVyxJQUFYLENBQW5CLEdBQXNDLEtBQXRDLENBQVosQ0FEeUI7R0FBaEI7QUFHVixlQUFhLHVCQUFXLEVBQVg7RUE1RGQsRUE5VzBCOztBQSthMUIsR0FBRSx1Q0FBRixFQUEyQyxPQUEzQyxDQUFtRDtBQUNsRCxTQUFPLGlCQUFXO0FBQ2pCLFFBQUssTUFBTCxHQURpQjtBQUVqQixRQUFLLElBQUwsQ0FBVSwwQkFBVixFQUFzQyxZQUFXO0FBQ2hELE1BQUUsSUFBRixFQUFRLFFBQVIsR0FBbUIsV0FBbkIsR0FEZ0Q7SUFBWCxDQUF0QyxDQUZpQjtHQUFYO0FBTVAsWUFBVSxvQkFBVztBQUNwQixRQUFLLE1BQUwsR0FEb0I7QUFFcEIsUUFBSyxNQUFMLENBQVksb0JBQVosRUFGb0I7R0FBWDtFQVBYLEVBL2EwQjtDQUFYLENBQWhCOzs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzltQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdnRFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvaGRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3JTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0lDcCtJTTs7Ozs7OzttQ0FTZ0IsS0FBSztBQUNuQixtQkFBTyxPQUFPLEVBQVAsQ0FBVSxNQUFWLENBQWlCLFFBQWpCLENBQTBCLEdBQTFCLENBQVAsQ0FEbUI7Ozs7NENBU0k7QUFDdkIsZ0JBQUksaUJBQWlCLEVBQWpCLENBRG1COztBQUd2QixtQkFBTyxJQUFQLENBQVksT0FBTyxFQUFQLENBQVUsTUFBVixDQUFpQixRQUFqQixDQUFaLENBQXVDLE9BQXZDLENBQStDLFVBQUMsR0FBRCxFQUFTO0FBQ3BELG9CQUFNLFFBQVEsT0FBTyxFQUFQLENBQVUsTUFBVixDQUFpQixRQUFqQixDQUEwQixHQUExQixFQUErQixLQUEvQixDQURzQztBQUVwRCxvQkFBTSxrQkFBa0IsTUFBTSxPQUFOLENBQWMsR0FBZCxNQUF1QixDQUFDLENBQUQsQ0FGSztBQUdwRCxvQkFBTSxXQUFXLGVBQWUsT0FBZixDQUF1QixLQUF2QixNQUFrQyxDQUFDLENBQUQsQ0FIQzs7QUFPcEQsb0JBQUksbUJBQW1CLFFBQW5CLEVBQTZCO0FBQzdCLG1DQUFlLElBQWYsQ0FBb0IsS0FBcEIsRUFENkI7aUJBQWpDO2FBUDJDLENBQS9DLENBSHVCOztBQWV2QixtQkFBTyxjQUFQLENBZnVCOzs7O1dBbEJ6Qjs7O2tCQXNDUzs7Ozs7Ozs7Ozs7OztJQzVCVDtBQUNMLFVBREssSUFDTCxHQUFjO3dCQURULE1BQ1M7O0FBQ2IsT0FBSyxhQUFMLEdBQXFCLElBQXJCLENBRGE7QUFFYixPQUFLLGFBQUwsR0FBcUIsT0FBckIsQ0FGYTtBQUdiLE9BQUssSUFBTCxHQUFZLEVBQVosQ0FIYTtFQUFkOztjQURLOzs0QkFZSyxRQUFRO0FBQ2pCLFFBQUssYUFBTCxHQUFxQixNQUFyQixDQURpQjs7Ozs4QkFTTjtBQUNYLFVBQU8sS0FBSyxhQUFMLEtBQXVCLElBQXZCLEdBQThCLEtBQUssYUFBTCxHQUFxQixLQUFLLGFBQUwsQ0FEL0M7Ozs7cUJBZVQsUUFBUSxnQkFBZ0IsVUFBVSxTQUFTO0FBQzdDLE9BQU0sV0FBVyxLQUFLLFNBQUwsR0FBaUIsT0FBakIsQ0FBeUIsU0FBekIsRUFBb0MsRUFBcEMsQ0FBWCxDQUR1QztBQUU3QyxPQUFNLGtCQUFrQixLQUFLLGFBQUwsQ0FBbUIsT0FBbkIsQ0FBMkIsU0FBM0IsRUFBc0MsRUFBdEMsQ0FBbEIsQ0FGdUM7O0FBSTdDLE9BQUksS0FBSyxJQUFMLElBQWEsS0FBSyxJQUFMLENBQVUsS0FBSyxTQUFMLEVBQVYsQ0FBYixJQUE0QyxLQUFLLElBQUwsQ0FBVSxLQUFLLFNBQUwsRUFBVixFQUE0QixNQUE1QixDQUE1QyxFQUFpRjtBQUNwRixXQUFPLEtBQUssSUFBTCxDQUFVLEtBQUssU0FBTCxFQUFWLEVBQTRCLE1BQTVCLENBQVAsQ0FEb0Y7SUFBckYsTUFFTyxJQUFJLEtBQUssSUFBTCxJQUFhLEtBQUssSUFBTCxDQUFVLFFBQVYsQ0FBYixJQUFvQyxLQUFLLElBQUwsQ0FBVSxRQUFWLEVBQW9CLE1BQXBCLENBQXBDLEVBQWlFO0FBQzNFLFdBQU8sS0FBSyxJQUFMLENBQVUsUUFBVixFQUFvQixNQUFwQixDQUFQLENBRDJFO0lBQXJFLE1BRUEsSUFBSSxLQUFLLElBQUwsSUFBYSxLQUFLLElBQUwsQ0FBVSxLQUFLLGFBQUwsQ0FBdkIsSUFBOEMsS0FBSyxJQUFMLENBQVUsS0FBSyxhQUFMLENBQVYsQ0FBOEIsTUFBOUIsQ0FBOUMsRUFBcUY7QUFDL0YsV0FBTyxLQUFLLElBQUwsQ0FBVSxLQUFLLGFBQUwsQ0FBVixDQUE4QixNQUE5QixDQUFQLENBRCtGO0lBQXpGLE1BRUEsSUFBSSxLQUFLLElBQUwsSUFBYSxLQUFLLElBQUwsQ0FBVSxlQUFWLENBQWIsSUFBMkMsS0FBSyxJQUFMLENBQVUsZUFBVixFQUEyQixNQUEzQixDQUEzQyxFQUErRTtBQUN6RixXQUFPLEtBQUssSUFBTCxDQUFVLGVBQVYsRUFBMkIsTUFBM0IsQ0FBUCxDQUR5RjtJQUFuRixNQUVBLElBQUcsY0FBSCxFQUFtQjtBQUN6QixXQUFPLGNBQVAsQ0FEeUI7SUFBbkIsTUFFQTtBQUNOLFdBQU8sRUFBUCxDQURNO0lBRkE7Ozs7Z0NBZU0sUUFBUSxNQUFNO0FBQzNCLE9BQUksT0FBTyxLQUFLLElBQUwsQ0FBVSxNQUFWLENBQVAsS0FBNkIsV0FBN0IsRUFBMEM7QUFDN0MsU0FBSyxJQUFMLENBQVUsTUFBVixJQUFvQixFQUFwQixDQUQ2QztJQUE5Qzs7QUFJQSxRQUFLLElBQUksTUFBSixJQUFjLElBQW5CLEVBQXlCO0FBQ3hCLFNBQUssSUFBTCxDQUFVLE1BQVYsRUFBa0IsTUFBbEIsSUFBNEIsS0FBSyxNQUFMLENBQTVCLENBRHdCO0lBQXpCOzs7O2dDQVVhLFFBQVE7QUFDckIsVUFBTyxLQUFLLElBQUwsQ0FBVSxNQUFWLENBQVAsQ0FEcUI7Ozs7MkJBU2IsS0FBSztBQUNiLFVBQU8sSUFBSSxPQUFKLENBQVksTUFBWixFQUFvQixFQUFwQixFQUF3QixPQUF4QixDQUFnQyxNQUFoQyxFQUF3QyxFQUF4QyxDQUFQLENBRGE7Ozs7NkJBU0gsS0FBSztBQUdmLE9BQUksUUFBUSxJQUFJLEtBQUosQ0FBVSxJQUFWLENBQVIsQ0FIVzs7QUFLZixRQUFLLElBQUksSUFBSSxDQUFKLEVBQU8sSUFBSSxNQUFNLE1BQU4sRUFBYyxLQUFLLENBQUwsRUFBUTtBQUN6QyxVQUFNLENBQU4sSUFBVyxTQUFTLE1BQU0sQ0FBTixDQUFULENBQVgsQ0FEeUM7SUFBMUM7O0FBTUEsVUFBTyxTQUFTLE1BQU0sSUFBTixDQUFXLEdBQVgsQ0FBVCxDQUFQLENBWGU7Ozs7MEJBcUJSLEdBQWM7cUNBQVI7O0lBQVE7O0FBQ3JCLE9BQUksT0FBTyxNQUFQLEtBQWtCLENBQWxCLEVBQXFCO0FBQ3hCLFdBQU8sQ0FBUCxDQUR3QjtJQUF6Qjs7QUFJQSxPQUFNLE9BQU8sSUFBSSxNQUFKLENBQVcsVUFBWCxFQUF1QixHQUF2QixDQUFQLENBTGU7O0FBT3JCLE9BQUksSUFBSSxDQUFKLENBUGlCOztBQVNyQixVQUFPLEVBQUUsT0FBRixDQUFVLElBQVYsRUFBZ0IsVUFBVSxLQUFWLEVBQWlCLFNBQWpCLEVBQTRCLFNBQTVCLEVBQXVDLE1BQXZDLEVBQStDLE1BQS9DLEVBQXVEO0FBRTdFLFFBQUksY0FBYyxHQUFkLEVBQW1CO0FBQ3RCLFlBQU8sS0FBUCxDQURzQjtLQUF2Qjs7QUFJQSxXQUFPLFlBQVksT0FBTyxHQUFQLENBQVosQ0FOc0U7SUFBdkQsQ0FBdkIsQ0FUcUI7Ozs7eUJBMEJmLEdBQUcsS0FBSztBQUNkLE9BQU0sT0FBTyxJQUFJLE1BQUosQ0FBVyxxQkFBWCxFQUFrQyxHQUFsQyxDQUFQLENBRFE7O0FBR2QsVUFBTyxFQUFFLE9BQUYsQ0FBVSxJQUFWLEVBQWdCLFVBQVUsS0FBVixFQUFpQixHQUFqQixFQUFzQixNQUF0QixFQUE4QixNQUE5QixFQUFzQztBQUM1RCxXQUFPLEdBQUMsQ0FBSSxHQUFKLENBQUQsR0FBYSxJQUFJLEdBQUosQ0FBYixHQUF3QixLQUF4QixDQURxRDtJQUF0QyxDQUF2QixDQUhjOzs7O2lDQWlCQTtBQUNkLE9BQUksU0FBSixDQURjO0FBRWQsT0FBSSxjQUFKLENBRmM7O0FBS2QsZUFBWSxPQUFPLE1BQVAsRUFBZSxJQUFmLENBQW9CLE1BQXBCLENBQVosQ0FMYzs7QUFRZCxPQUFJLENBQUMsU0FBRCxFQUFZO0FBQ2YsUUFBSSxRQUFRLFNBQVMsb0JBQVQsQ0FBOEIsTUFBOUIsQ0FBUixDQURXOztBQUdmLFNBQUssSUFBSSxJQUFFLENBQUYsRUFBSyxJQUFFLE1BQU0sTUFBTixFQUFjLEdBQTlCLEVBQW1DO0FBQ2xDLFNBQUksTUFBTSxDQUFOLEVBQVMsVUFBVCxDQUFvQixZQUFwQixLQUFxQyxNQUFNLENBQU4sRUFBUyxVQUFULENBQW9CLFlBQXBCLEVBQWtDLFNBQWxDLENBQTRDLFdBQTVDLE1BQTZELGtCQUE3RCxFQUFpRjtBQUN6SCxrQkFBWSxNQUFNLENBQU4sRUFBUyxVQUFULENBQW9CLFNBQXBCLEVBQStCLFNBQS9CLENBRDZHO01BQTFIO0tBREQ7SUFIRDs7QUFXQSxPQUFJLENBQUMsU0FBRCxFQUFZO0FBQ2YsZ0JBQVksS0FBSyxhQUFMLENBREc7SUFBaEI7O0FBSUEsT0FBSSxpQkFBaUIsVUFBVSxLQUFWLENBQWdCLG9CQUFoQixDQUFqQixDQXZCVTs7QUEwQmQsT0FBSSxVQUFVLE1BQVYsSUFBb0IsQ0FBcEIsRUFBdUI7QUFDMUIsU0FBSyxJQUFJLGFBQUosSUFBcUIsS0FBSyxJQUFMLEVBQVc7QUFDcEMsU0FBSSxjQUFjLE1BQWQsQ0FBcUIsQ0FBckIsRUFBdUIsQ0FBdkIsRUFBMEIsV0FBMUIsTUFBMkMsVUFBVSxXQUFWLEVBQTNDLEVBQW9FO0FBQ3ZFLHVCQUFpQixhQUFqQixDQUR1RTtBQUV2RSxZQUZ1RTtNQUF4RTtLQUREO0lBREQsTUFPTyxJQUFJLGNBQUosRUFBb0I7QUFDMUIscUJBQWlCLGVBQWUsQ0FBZixFQUFrQixXQUFsQixLQUFrQyxHQUFsQyxHQUF3QyxlQUFlLENBQWYsRUFBa0IsV0FBbEIsRUFBeEMsQ0FEUztJQUFwQjs7QUFJUCxVQUFPLGNBQVAsQ0FyQ2M7Ozs7MkJBNkNOLEtBQUssUUFBUSxJQUFJLFlBQVk7QUFDckMsT0FBSSxJQUFJLGdCQUFKLEVBQXNCO0FBQ3pCLFFBQUksZ0JBQUosQ0FBcUIsTUFBckIsRUFBNkIsRUFBN0IsRUFBaUMsVUFBakMsRUFEeUI7QUFFekIsV0FBTyxJQUFQLENBRnlCO0lBQTFCLE1BR08sSUFBSSxJQUFJLFdBQUosRUFBaUI7QUFDM0IsV0FBTyxJQUFJLFdBQUosQ0FBZ0IsT0FBTyxNQUFQLEVBQWUsRUFBL0IsQ0FBUCxDQUQyQjtJQUFyQixNQUVBO0FBQ04sWUFBUSxHQUFSLENBQVksK0JBQVosRUFETTtJQUZBOzs7O1FBak5IOzs7QUF5Tk4sSUFBSSxRQUFRLElBQUksSUFBSixFQUFSOztBQUdKLE9BQU8sRUFBUCxHQUFZLE9BQU8sT0FBTyxFQUFQLEtBQWMsV0FBckIsR0FBbUMsT0FBTyxFQUFQLEdBQVksRUFBL0M7QUFDWixPQUFPLEVBQVAsQ0FBVSxJQUFWLEdBQWlCLE9BQU8sSUFBUCxHQUFjLEtBQWQ7O2tCQUVGOzs7OztBQzFPZixJQUFJLFNBQVMsT0FBTyxPQUFPLE1BQVAsS0FBa0IsV0FBekIsR0FBdUMsT0FBTyxNQUFQLEdBQWdCLElBQXZEOztBQUViLE9BQU8sT0FBUCxHQUFpQixNQUFqQjs7Ozs7Ozs7Ozs7Ozs7O0FDRUEsU0FBUyxJQUFULENBQWMsUUFBZCxFQUF3QjtBQUNwQixXQUFPLFVBQUMsSUFBRCxFQUFPLEtBQVAsRUFBYyxRQUFkLEVBQXdCLElBQXhCLEVBQWlDO0FBSXBDLFlBQUksS0FBSyxTQUFTLGFBQVQsQ0FBdUIsR0FBdkIsQ0FBTCxDQUpnQztBQUtwQyxXQUFHLElBQUgsR0FBVSxJQUFWLENBTG9DOztBQU9wQyxlQUFPLFNBQVMsR0FBRyxRQUFILEVBQWEsS0FBdEIsRUFBNkIsUUFBN0IsRUFBdUMsSUFBdkMsQ0FBUCxDQVBvQztLQUFqQyxDQURhO0NBQXhCOztBQVlBLGVBQUssSUFBTCxHQUFZLEtBQUssZUFBSyxJQUFMLENBQWpCIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsInJlcXVpcmUoJy4uLy4uLy4uLy4uL3RoaXJkcGFydHkvanF1ZXJ5L2pxdWVyeS5qcycpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vdGhpcmRwYXJ0eS9qcXVlcnktb25kZW1hbmQvanF1ZXJ5Lm9uZGVtYW5kLmpzJyk7XG5yZXF1aXJlKCcuLi8uLi9zcmMvc3NwYXRoLmpzJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi90aGlyZHBhcnR5L2pxdWVyeS11aS9qcXVlcnktdWkuanMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uL3RoaXJkcGFydHkvanNvbi1qcy9qc29uMi5qcycpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vdGhpcmRwYXJ0eS9qcXVlcnktZW50d2luZS9kaXN0L2pxdWVyeS5lbnR3aW5lLWRpc3QuanMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uL3RoaXJkcGFydHkvanF1ZXJ5LWNvb2tpZS9qcXVlcnkuY29va2llLmpzJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi90aGlyZHBhcnR5L2pxdWVyeS1xdWVyeS9qcXVlcnkucXVlcnkuanMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uL3RoaXJkcGFydHkvanF1ZXJ5LWZvcm0vanF1ZXJ5LmZvcm0uanMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uL3RoaXJkcGFydHkvanF1ZXJ5LW5vdGljZS9qcXVlcnkubm90aWNlLmpzJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi90aGlyZHBhcnR5L2pzaXplcy9saWIvanF1ZXJ5LnNpemVzLmpzJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi90aGlyZHBhcnR5L2psYXlvdXQvbGliL2psYXlvdXQuYm9yZGVyLmpzJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi90aGlyZHBhcnR5L2psYXlvdXQvbGliL2pxdWVyeS5qbGF5b3V0LmpzJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi90aGlyZHBhcnR5L2pzdHJlZS9qcXVlcnkuanN0cmVlLmpzJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi90aGlyZHBhcnR5L2Nob3Nlbi9jaG9zZW4vY2hvc2VuLmpxdWVyeS5qcycpO1xucmVxdWlyZSgnLi4vLi4vLi4vdGhpcmRwYXJ0eS9qcXVlcnktaG92ZXJJbnRlbnQvanF1ZXJ5LmhvdmVySW50ZW50LmpzJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi90aGlyZHBhcnR5L2pxdWVyeS1jaGFuZ2V0cmFja2VyL2xpYi9qcXVlcnkuY2hhbmdldHJhY2tlci5qcycpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vamF2YXNjcmlwdC9zcmMvVHJlZURyb3Bkb3duRmllbGQuanMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uL2phdmFzY3JpcHQvc3JjL0RhdGVGaWVsZC5qcycpO1xucmVxdWlyZSgnLi4vLi4vLi4vLi4vamF2YXNjcmlwdC9zcmMvSHRtbEVkaXRvckZpZWxkLmpzJyk7XG5yZXF1aXJlKCcuLi8uLi8uLi8uLi9qYXZhc2NyaXB0L3NyYy9UYWJTZXQuanMnKTtcbnJlcXVpcmUoJy4uLy4uL3NyYy9zc3VpLmNvcmUuanMnKTtcbnJlcXVpcmUoJy4uLy4uLy4uLy4uL2phdmFzY3JpcHQvc3JjL0dyaWRGaWVsZC5qcycpO1xuIiwiaW1wb3J0ICQgZnJvbSAnalF1ZXJ5JztcblxuLy8gQ29weXJpZ2h0IChjKSAyMDExIEpvaG4gUmVzaWcsIGh0dHA6Ly9qcXVlcnkuY29tL1xuXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbi8vIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbi8vIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuLy8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuLy8gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4vLyBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4vLyBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG4vLyBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG4vLyBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vL2RlZmluZSB2YXJzIGZvciBpbnRlcmFsIHVzZVxudmFyICR3aW5kb3cgPSAkKCB3aW5kb3cgKSxcblx0JGh0bWwgPSAkKCAnaHRtbCcgKSxcblx0JGhlYWQgPSAkKCAnaGVhZCcgKSxcblxuXHQvL3VybCBwYXRoIGhlbHBlcnMgZm9yIHVzZSBpbiByZWxhdGl2ZSB1cmwgbWFuYWdlbWVudFxuXHRwYXRoID0ge1xuXG5cdFx0Ly8gVGhpcyBzY2FyeSBsb29raW5nIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXJzZXMgYW4gYWJzb2x1dGUgVVJMIG9yIGl0cyByZWxhdGl2ZVxuXHRcdC8vIHZhcmlhbnRzIChwcm90b2NvbCwgc2l0ZSwgZG9jdW1lbnQsIHF1ZXJ5LCBhbmQgaGFzaCksIGludG8gdGhlIHZhcmlvdXNcblx0XHQvLyBjb21wb25lbnRzIChwcm90b2NvbCwgaG9zdCwgcGF0aCwgcXVlcnksIGZyYWdtZW50LCBldGMgdGhhdCBtYWtlIHVwIHRoZVxuXHRcdC8vIFVSTCBhcyB3ZWxsIGFzIHNvbWUgb3RoZXIgY29tbW9ubHkgdXNlZCBzdWItcGFydHMuIFdoZW4gdXNlZCB3aXRoIFJlZ0V4cC5leGVjKClcblx0XHQvLyBvciBTdHJpbmcubWF0Y2gsIGl0IHBhcnNlcyB0aGUgVVJMIGludG8gYSByZXN1bHRzIGFycmF5IHRoYXQgbG9va3MgbGlrZSB0aGlzOlxuXHRcdC8vXG5cdFx0Ly8gICAgIFswXTogaHR0cDovL2pibGFzOnBhc3N3b3JkQG15Y29tcGFueS5jb206ODA4MC9tYWlsL2luYm94P21zZz0xMjM0JnR5cGU9dW5yZWFkI21zZy1jb250ZW50XG5cdFx0Ly8gICAgIFsxXTogaHR0cDovL2pibGFzOnBhc3N3b3JkQG15Y29tcGFueS5jb206ODA4MC9tYWlsL2luYm94P21zZz0xMjM0JnR5cGU9dW5yZWFkXG5cdFx0Ly8gICAgIFsyXTogaHR0cDovL2pibGFzOnBhc3N3b3JkQG15Y29tcGFueS5jb206ODA4MC9tYWlsL2luYm94XG5cdFx0Ly8gICAgIFszXTogaHR0cDovL2pibGFzOnBhc3N3b3JkQG15Y29tcGFueS5jb206ODA4MFxuXHRcdC8vICAgICBbNF06IGh0dHA6XG5cdFx0Ly8gICAgIFs1XTogLy9cblx0XHQvLyAgICAgWzZdOiBqYmxhczpwYXNzd29yZEBteWNvbXBhbnkuY29tOjgwODBcblx0XHQvLyAgICAgWzddOiBqYmxhczpwYXNzd29yZFxuXHRcdC8vICAgICBbOF06IGpibGFzXG5cdFx0Ly8gICAgIFs5XTogcGFzc3dvcmRcblx0XHQvLyAgICBbMTBdOiBteWNvbXBhbnkuY29tOjgwODBcblx0XHQvLyAgICBbMTFdOiBteWNvbXBhbnkuY29tXG5cdFx0Ly8gICAgWzEyXTogODA4MFxuXHRcdC8vICAgIFsxM106IC9tYWlsL2luYm94XG5cdFx0Ly8gICAgWzE0XTogL21haWwvXG5cdFx0Ly8gICAgWzE1XTogaW5ib3hcblx0XHQvLyAgICBbMTZdOiA/bXNnPTEyMzQmdHlwZT11bnJlYWRcblx0XHQvLyAgICBbMTddOiAjbXNnLWNvbnRlbnRcblx0XHQvL1xuXHRcdHVybFBhcnNlUkU6IC9eKCgoKFteOlxcLyNcXD9dKzopPyg/OihcXC9cXC8pKCg/OigoW146QFxcLyNcXD9dKykoPzpcXDooW146QFxcLyNcXD9dKykpPylAKT8oKFteOlxcLyNcXD9cXF1cXFtdK3xcXFtbXlxcL1xcXUAjP10rXFxdKSg/OlxcOihbMC05XSspKT8pKT8pPyk/KChcXC8/KD86W15cXC9cXD8jXStcXC8rKSopKFteXFw/I10qKSkpPyhcXD9bXiNdKyk/KSgjLiopPy8sXG5cblx0XHQvL1BhcnNlIGEgVVJMIGludG8gYSBzdHJ1Y3R1cmUgdGhhdCBhbGxvd3MgZWFzeSBhY2Nlc3MgdG9cblx0XHQvL2FsbCBvZiB0aGUgVVJMIGNvbXBvbmVudHMgYnkgbmFtZS5cblx0XHRwYXJzZVVybDogZnVuY3Rpb24oIHVybCApIHtcblx0XHRcdC8vIElmIHdlJ3JlIHBhc3NlZCBhbiBvYmplY3QsIHdlJ2xsIGFzc3VtZSB0aGF0IGl0IGlzXG5cdFx0XHQvLyBhIHBhcnNlZCB1cmwgb2JqZWN0IGFuZCBqdXN0IHJldHVybiBpdCBiYWNrIHRvIHRoZSBjYWxsZXIuXG5cdFx0XHRpZiAoICQudHlwZSggdXJsICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRcdHJldHVybiB1cmw7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBtYXRjaGVzID0gcGF0aC51cmxQYXJzZVJFLmV4ZWMoIHVybCB8fCBcIlwiICkgfHwgW107XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIGFuIG9iamVjdCB0aGF0IGFsbG93cyB0aGUgY2FsbGVyIHRvIGFjY2VzcyB0aGUgc3ViLW1hdGNoZXNcblx0XHRcdFx0Ly8gYnkgbmFtZS4gTm90ZSB0aGF0IElFIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nIGluc3RlYWQgb2YgdW5kZWZpbmVkLFxuXHRcdFx0XHQvLyBsaWtlIGFsbCBvdGhlciBicm93c2VycyBkbywgc28gd2Ugbm9ybWFsaXplIGV2ZXJ5dGhpbmcgc28gaXRzIGNvbnNpc3RlbnRcblx0XHRcdFx0Ly8gbm8gbWF0dGVyIHdoYXQgYnJvd3NlciB3ZSdyZSBydW5uaW5nIG9uLlxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGhyZWY6ICAgICAgICAgbWF0Y2hlc1sgIDAgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdGhyZWZOb0hhc2g6ICAgbWF0Y2hlc1sgIDEgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdGhyZWZOb1NlYXJjaDogbWF0Y2hlc1sgIDIgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdGRvbWFpbjogICAgICAgbWF0Y2hlc1sgIDMgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdHByb3RvY29sOiAgICAgbWF0Y2hlc1sgIDQgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdGRvdWJsZVNsYXNoOiAgbWF0Y2hlc1sgIDUgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdGF1dGhvcml0eTogICAgbWF0Y2hlc1sgIDYgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdHVzZXJuYW1lOiAgICAgbWF0Y2hlc1sgIDggXSB8fCBcIlwiLFxuXHRcdFx0XHRcdHBhc3N3b3JkOiAgICAgbWF0Y2hlc1sgIDkgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdGhvc3Q6ICAgICAgICAgbWF0Y2hlc1sgMTAgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdGhvc3RuYW1lOiAgICAgbWF0Y2hlc1sgMTEgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdHBvcnQ6ICAgICAgICAgbWF0Y2hlc1sgMTIgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdHBhdGhuYW1lOiAgICAgbWF0Y2hlc1sgMTMgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdGRpcmVjdG9yeTogICAgbWF0Y2hlc1sgMTQgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdGZpbGVuYW1lOiAgICAgbWF0Y2hlc1sgMTUgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdHNlYXJjaDogICAgICAgbWF0Y2hlc1sgMTYgXSB8fCBcIlwiLFxuXHRcdFx0XHRcdGhhc2g6ICAgICAgICAgbWF0Y2hlc1sgMTcgXSB8fCBcIlwiXG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8vVHVybiByZWxQYXRoIGludG8gYW4gYXNib2x1dGUgcGF0aC4gYWJzUGF0aCBpc1xuXHRcdC8vYW4gb3B0aW9uYWwgYWJzb2x1dGUgcGF0aCB3aGljaCBkZXNjcmliZXMgd2hhdFxuXHRcdC8vcmVsUGF0aCBpcyByZWxhdGl2ZSB0by5cblx0XHRtYWtlUGF0aEFic29sdXRlOiBmdW5jdGlvbiggcmVsUGF0aCwgYWJzUGF0aCApIHtcblx0XHRcdGlmICggcmVsUGF0aCAmJiByZWxQYXRoLmNoYXJBdCggMCApID09PSBcIi9cIiApIHtcblx0XHRcdFx0cmV0dXJuIHJlbFBhdGg7XG5cdFx0XHR9XG5cblx0XHRcdHJlbFBhdGggPSByZWxQYXRoIHx8IFwiXCI7XG5cdFx0XHRhYnNQYXRoID0gYWJzUGF0aCA/IGFic1BhdGgucmVwbGFjZSggL15cXC98KFxcL1teXFwvXSp8W15cXC9dKykkL2csIFwiXCIgKSA6IFwiXCI7XG5cblx0XHRcdHZhciBhYnNTdGFjayA9IGFic1BhdGggPyBhYnNQYXRoLnNwbGl0KCBcIi9cIiApIDogW10sXG5cdFx0XHRcdHJlbFN0YWNrID0gcmVsUGF0aC5zcGxpdCggXCIvXCIgKTtcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHJlbFN0YWNrLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YXIgZCA9IHJlbFN0YWNrWyBpIF07XG5cdFx0XHRcdHN3aXRjaCAoIGQgKSB7XG5cdFx0XHRcdFx0Y2FzZSBcIi5cIjpcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCIuLlwiOlxuXHRcdFx0XHRcdFx0aWYgKCBhYnNTdGFjay5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdGFic1N0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGFic1N0YWNrLnB1c2goIGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gXCIvXCIgKyBhYnNTdGFjay5qb2luKCBcIi9cIiApO1xuXHRcdH0sXG5cblx0XHQvL1JldHVybnMgdHJ1ZSBpZiBib3RoIHVybHMgaGF2ZSB0aGUgc2FtZSBkb21haW4uXG5cdFx0aXNTYW1lRG9tYWluOiBmdW5jdGlvbiggYWJzVXJsMSwgYWJzVXJsMiApIHtcblx0XHRcdHJldHVybiBwYXRoLnBhcnNlVXJsKCBhYnNVcmwxICkuZG9tYWluID09PSBwYXRoLnBhcnNlVXJsKCBhYnNVcmwyICkuZG9tYWluO1xuXHRcdH0sXG5cblx0XHQvL1JldHVybnMgdHJ1ZSBmb3IgYW55IHJlbGF0aXZlIHZhcmlhbnQuXG5cdFx0aXNSZWxhdGl2ZVVybDogZnVuY3Rpb24oIHVybCApIHtcblx0XHRcdC8vIEFsbCByZWxhdGl2ZSBVcmwgdmFyaWFudHMgaGF2ZSBvbmUgdGhpbmcgaW4gY29tbW9uLCBubyBwcm90b2NvbC5cblx0XHRcdHJldHVybiBwYXRoLnBhcnNlVXJsKCB1cmwgKS5wcm90b2NvbCA9PT0gXCJcIjtcblx0XHR9LFxuXG5cdFx0Ly9SZXR1cm5zIHRydWUgZm9yIGFuIGFic29sdXRlIHVybC5cblx0XHRpc0Fic29sdXRlVXJsOiBmdW5jdGlvbiggdXJsICkge1xuXHRcdFx0cmV0dXJuIHBhdGgucGFyc2VVcmwoIHVybCApLnByb3RvY29sICE9PSBcIlwiO1xuXHRcdH0sXG5cblx0XHQvL1R1cm4gdGhlIHNwZWNpZmllZCByZWFsdGl2ZSBVUkwgaW50byBhbiBhYnNvbHV0ZSBvbmUuIFRoaXMgZnVuY3Rpb25cblx0XHQvL2NhbiBoYW5kbGUgYWxsIHJlbGF0aXZlIHZhcmlhbnRzIChwcm90b2NvbCwgc2l0ZSwgZG9jdW1lbnQsIHF1ZXJ5LCBmcmFnbWVudCkuXG5cdFx0bWFrZVVybEFic29sdXRlOiBmdW5jdGlvbiggcmVsVXJsLCBhYnNVcmwgKSB7XG5cdFx0XHRpZiAoICFwYXRoLmlzUmVsYXRpdmVVcmwoIHJlbFVybCApICkge1xuXHRcdFx0XHRyZXR1cm4gcmVsVXJsO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcmVsT2JqID0gcGF0aC5wYXJzZVVybCggcmVsVXJsICksXG5cdFx0XHRcdGFic09iaiA9IHBhdGgucGFyc2VVcmwoIGFic1VybCApLFxuXHRcdFx0XHRwcm90b2NvbCA9IHJlbE9iai5wcm90b2NvbCB8fCBhYnNPYmoucHJvdG9jb2wsXG5cdFx0XHRcdGRvdWJsZVNsYXNoID0gcmVsT2JqLnByb3RvY29sID8gcmVsT2JqLmRvdWJsZVNsYXNoIDogKCByZWxPYmouZG91YmxlU2xhc2ggfHwgYWJzT2JqLmRvdWJsZVNsYXNoICksXG5cdFx0XHRcdGF1dGhvcml0eSA9IHJlbE9iai5hdXRob3JpdHkgfHwgYWJzT2JqLmF1dGhvcml0eSxcblx0XHRcdFx0aGFzUGF0aCA9IHJlbE9iai5wYXRobmFtZSAhPT0gXCJcIixcblx0XHRcdFx0cGF0aG5hbWUgPSBwYXRoLm1ha2VQYXRoQWJzb2x1dGUoIHJlbE9iai5wYXRobmFtZSB8fCBhYnNPYmouZmlsZW5hbWUsIGFic09iai5wYXRobmFtZSApLFxuXHRcdFx0XHRzZWFyY2ggPSByZWxPYmouc2VhcmNoIHx8ICggIWhhc1BhdGggJiYgYWJzT2JqLnNlYXJjaCApIHx8IFwiXCIsXG5cdFx0XHRcdGhhc2ggPSByZWxPYmouaGFzaDtcblxuXHRcdFx0cmV0dXJuIHByb3RvY29sICsgZG91YmxlU2xhc2ggKyBhdXRob3JpdHkgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG5cdFx0fSxcblxuXHRcdC8vQWRkIHNlYXJjaCAoYWthIHF1ZXJ5KSBwYXJhbXMgdG8gdGhlIHNwZWNpZmllZCB1cmwuXG5cdFx0Ly8gMjAxMy0xMi0wNiBpc2Nob21tZXI6IEN1c3RvbWl6ZWQgdG8gbWVyZ2Ugd2l0aCBleGlzdGluZyBrZXlzXG5cdFx0YWRkU2VhcmNoUGFyYW1zOiBmdW5jdGlvbiggdXJsLCBwYXJhbXMgKSB7XG5cdFx0XHR2YXIgdSA9IHBhdGgucGFyc2VVcmwoIHVybCApLFxuXHRcdFx0XHRwYXJhbXMgPSAoIHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIgKSA/IHBhdGguY29udmVydFNlYXJjaFRvQXJyYXkoIHBhcmFtcyApIDogcGFyYW1zLFxuXHRcdFx0XHRuZXdQYXJhbXMgPSAkLmV4dGVuZCggcGF0aC5jb252ZXJ0U2VhcmNoVG9BcnJheSggdS5zZWFyY2ggKSwgcGFyYW1zICk7XG5cdFx0XHRyZXR1cm4gdS5ocmVmTm9TZWFyY2ggKyAnPycgKyAkLnBhcmFtKCBuZXdQYXJhbXMgKSArICggdS5oYXNoIHx8IFwiXCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gMjAxMy0xMi0wNiBpc2Nob21tZXI6IEFkZGVkIHRvIGFsbG93IG1lcmdlIHdpdGggZXhpc3Rpbmcga2V5c1xuXHRcdGdldFNlYXJjaFBhcmFtczogZnVuY3Rpb24odXJsKSB7XG5cdFx0XHR2YXIgdSA9IHBhdGgucGFyc2VVcmwoIHVybCApO1xuXHRcdFx0cmV0dXJuIHBhdGguY29udmVydFNlYXJjaFRvQXJyYXkoIHUuc2VhcmNoICk7XG5cdFx0fSxcblxuXHRcdC8vIENvbnZlcnRzIHF1ZXJ5IHN0cmluZ3MgKGZvbz1iYXImYmF6PWJsYSkgdG8gYSBoYXNoLlxuXHRcdC8vIFRPRE8gSGFuZGxlIHJlcGVhdGluZyBlbGVtZW50cyAoZS5nLiBhcnJbXT1vbmUmYXJyW109dHdvKVxuXHRcdC8vIDIwMTMtMTItMDYgaXNjaG9tbWVyOiBBZGRlZCB0byBhbGxvdyBtZXJnZSB3aXRoIGV4aXN0aW5nIGtleXNcblx0XHRjb252ZXJ0U2VhcmNoVG9BcnJheTogZnVuY3Rpb24oc2VhcmNoKSB7XG5cdFx0XHR2YXIgcGFyYW1zID0ge30sIFxuXHRcdFx0XHRzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSggL15cXD8vLCAnJyApLFxuXHRcdFx0XHRwYXJ0cyA9IHNlYXJjaCA/IHNlYXJjaC5zcGxpdCggJyYnICkgOiBbXSwgaSwgdG1wO1xuXHRcdFx0Zm9yKGk9MDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRtcCA9IHBhcnRzW2ldLnNwbGl0KCAnPScgKTtcblx0XHRcdFx0cGFyYW1zW3RtcFswXV0gPSB0bXBbMV07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGFyYW1zO1xuXHRcdH0sXG5cblx0XHRjb252ZXJ0VXJsVG9EYXRhVXJsOiBmdW5jdGlvbiggYWJzVXJsICkge1xuXHRcdFx0dmFyIHUgPSBwYXRoLnBhcnNlVXJsKCBhYnNVcmwgKTtcblx0XHRcdGlmICggcGF0aC5pc0VtYmVkZGVkUGFnZSggdSApICkge1xuXHRcdFx0XHQvLyBGb3IgZW1iZWRkZWQgcGFnZXMsIHJlbW92ZSB0aGUgZGlhbG9nIGhhc2gga2V5IGFzIGluIGdldEZpbGVQYXRoKCksXG5cdFx0XHRcdC8vIG90aGVyd2lzZSB0aGUgRGF0YSBVcmwgd29uJ3QgbWF0Y2ggdGhlIGlkIG9mIHRoZSBlbWJlZGRlZCBQYWdlLlxuXHRcdFx0XHRyZXR1cm4gdS5oYXNoLnNwbGl0KCBkaWFsb2dIYXNoS2V5IClbMF0ucmVwbGFjZSggL14jLywgXCJcIiApO1xuXHRcdFx0fSBlbHNlIGlmICggcGF0aC5pc1NhbWVEb21haW4oIHUsIGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdHJldHVybiB1LmhyZWZOb0hhc2gucmVwbGFjZSggZG9jdW1lbnQuZG9tYWluLCBcIlwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYWJzVXJsO1xuXHRcdH0sXG5cblx0XHQvL2dldCBwYXRoIGZyb20gY3VycmVudCBoYXNoLCBvciBmcm9tIGEgZmlsZSBwYXRoXG5cdFx0Z2V0OiBmdW5jdGlvbiggbmV3UGF0aCApIHtcblx0XHRcdGlmKCBuZXdQYXRoID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdG5ld1BhdGggPSBsb2NhdGlvbi5oYXNoO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhdGguc3RyaXBIYXNoKCBuZXdQYXRoICkucmVwbGFjZSggL1teXFwvXSpcXC5bXlxcLypdKyQvLCAnJyApO1xuXHRcdH0sXG5cblx0XHQvL3JldHVybiB0aGUgc3Vic3RyaW5nIG9mIGEgZmlsZXBhdGggYmVmb3JlIHRoZSBzdWItcGFnZSBrZXksIGZvciBtYWtpbmcgYSBzZXJ2ZXIgcmVxdWVzdFxuXHRcdGdldEZpbGVQYXRoOiBmdW5jdGlvbiggcGF0aCApIHtcblx0XHRcdHZhciBzcGxpdGtleSA9ICcmJyArICQubW9iaWxlLnN1YlBhZ2VVcmxLZXk7XG5cdFx0XHRyZXR1cm4gcGF0aCAmJiBwYXRoLnNwbGl0KCBzcGxpdGtleSApWzBdLnNwbGl0KCBkaWFsb2dIYXNoS2V5IClbMF07XG5cdFx0fSxcblxuXHRcdC8vc2V0IGxvY2F0aW9uIGhhc2ggdG8gcGF0aFxuXHRcdHNldDogZnVuY3Rpb24oIHBhdGggKSB7XG5cdFx0XHRsb2NhdGlvbi5oYXNoID0gcGF0aDtcblx0XHR9LFxuXG5cdFx0Ly90ZXN0IGlmIGEgZ2l2ZW4gdXJsIChzdHJpbmcpIGlzIGEgcGF0aFxuXHRcdC8vTk9URSBtaWdodCBiZSBleGNlcHRpb25hbGx5IG5haXZlXG5cdFx0aXNQYXRoOiBmdW5jdGlvbiggdXJsICkge1xuXHRcdFx0cmV0dXJuICggL1xcLy8gKS50ZXN0KCB1cmwgKTtcblx0XHR9LFxuXG5cdFx0Ly9yZXR1cm4gYSB1cmwgcGF0aCB3aXRoIHRoZSB3aW5kb3cncyBsb2NhdGlvbiBwcm90b2NvbC9ob3N0bmFtZS9wYXRobmFtZSByZW1vdmVkXG5cdFx0Y2xlYW46IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdFx0XHRyZXR1cm4gdXJsLnJlcGxhY2UoIGRvY3VtZW50LmRvbWFpbiwgXCJcIiApO1xuXHRcdH0sXG5cblx0XHQvL2p1c3QgcmV0dXJuIHRoZSB1cmwgd2l0aG91dCBhbiBpbml0aWFsICNcblx0XHRzdHJpcEhhc2g6IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdFx0XHRyZXR1cm4gdXJsLnJlcGxhY2UoIC9eIy8sIFwiXCIgKTtcblx0XHR9LFxuXG5cdFx0Ly9yZW1vdmUgdGhlIHByZWNlZGluZyBoYXNoLCBhbnkgcXVlcnkgcGFyYW1zLCBhbmQgZGlhbG9nIG5vdGF0aW9uc1xuXHRcdGNsZWFuSGFzaDogZnVuY3Rpb24oIGhhc2ggKSB7XG5cdFx0XHRyZXR1cm4gcGF0aC5zdHJpcEhhc2goIGhhc2gucmVwbGFjZSggL1xcPy4qJC8sIFwiXCIgKS5yZXBsYWNlKCBkaWFsb2dIYXNoS2V5LCBcIlwiICkgKTtcblx0XHR9LFxuXG5cdFx0Ly9jaGVjayB3aGV0aGVyIGEgdXJsIGlzIHJlZmVyZW5jaW5nIHRoZSBzYW1lIGRvbWFpbiwgb3IgYW4gZXh0ZXJuYWwgZG9tYWluIG9yIGRpZmZlcmVudCBwcm90b2NvbFxuXHRcdC8vY291bGQgYmUgbWFpbHRvLCBldGNcblx0XHRpc0V4dGVybmFsOiBmdW5jdGlvbiggdXJsICkge1xuXHRcdFx0dmFyIHUgPSBwYXRoLnBhcnNlVXJsKCB1cmwgKTtcblx0XHRcdHJldHVybiB1LnByb3RvY29sICYmIHUuZG9tYWluICE9PSBkb2N1bWVudC5kb21haW4gPyB0cnVlIDogZmFsc2U7XG5cdFx0fSxcblxuXHRcdGhhc1Byb3RvY29sOiBmdW5jdGlvbiggdXJsICkge1xuXHRcdFx0cmV0dXJuICggL14oOj9cXHcrOikvICkudGVzdCggdXJsICk7XG5cdFx0fVxufTtcblxuJC5wYXRoID0gcGF0aDtcbiIsImltcG9ydCAkIGZyb20gJ2pRdWVyeSc7XG5cbi8qKlxuICogQWxsb3dzIGljb24gZGVmaW5pdGlvbiB2aWEgSFRNTDUgZGF0YSBhdHRycyBmb3IgZWFzaWVyIGhhbmRsaW5nIGluIFBIUC5cbiAqXG4gKiBBZGRzIGFuIGFsdGVybmF0aXZlIGFwcGVhcmFuY2Ugc28gd2UgY2FuIHRvZ2dsZSBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIHRoZW1cbiAqIGFuZCByZWdpc3RlciBldmVudCBoYW5kbGVycyB0byBhZGQgY3VzdG9tIHN0eWxpbmcgYW5kIGJlaGF2aW91ci4gRXhhbXBsZSB1c2VcbiAqIGlzIGluIHRoZSBDTVMgd2l0aCB0aGUgc2F2aW5nIGJ1dHRvbnMgLSBkZXBlbmRpbmcgb24gdGhlIHBhZ2UncyBzdGF0ZSBvbmUgb2ZcbiAqIHRoZW0gd2lsbCBlaXRoZXIgc2F5IFwiU2F2ZSBkcmFmdFwiIG9yIFwiU2F2ZWRcIiwgYW5kIHdpbGwgaGF2ZSBkaWZmZXJlbnQgY29sb3VyLlxuICovXG4kLndpZGdldCgnc3N1aS5idXR0b24nLCAkLnVpLmJ1dHRvbiwge1xuXHRvcHRpb25zOiB7XG5cdFx0YWx0ZXJuYXRlOiB7XG5cdFx0XHRpY29uOiBudWxsLFxuXHRcdFx0dGV4dDogbnVsbFxuXHRcdH0sXG5cdFx0c2hvd2luZ0FsdGVybmF0ZTogZmFsc2Vcblx0fSxcblxuXHQvKipcblx0ICogU3dpdGNoIGJldHdlZW4gdGhlIGFsdGVybmF0ZSBhcHBlYXJhbmNlcy5cblx0ICovXG5cdHRvZ2dsZUFsdGVybmF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX3RyaWdnZXIoJ29udG9nZ2xlYWx0ZXJuYXRlJyk9PT1mYWxzZSkgcmV0dXJuO1xuXG5cdFx0Ly8gT25seSBzd2l0Y2ggdG8gYWx0ZXJuYXRlIGlmIGl0IGhhcyBiZWVuIGVuYWJsZWQgdGhyb3VnaCBvcHRpb25zLiBcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5hbHRlcm5hdGUuaWNvbiAmJiAhdGhpcy5vcHRpb25zLmFsdGVybmF0ZS50ZXh0KSByZXR1cm47XG5cblx0XHR0aGlzLm9wdGlvbnMuc2hvd2luZ0FsdGVybmF0ZSA9ICF0aGlzLm9wdGlvbnMuc2hvd2luZ0FsdGVybmF0ZTtcblx0XHR0aGlzLnJlZnJlc2goKTtcblx0fSxcblxuXHQvKipcblx0ICogQWRqdXN0IHRoZSBhcHBlYXJhbmNlIHRvIGZpdCB3aXRoIHRoZSBjdXJyZW50IHNldHRpbmdzLlxuXHQgKi9cblx0X3JlZnJlc2hBbHRlcm5hdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3RyaWdnZXIoJ2JlZm9yZXJlZnJlc2hhbHRlcm5hdGUnKTtcblxuXHRcdC8vIE9ubHkgc3dpdGNoIHRvIGFsdGVybmF0ZSBpZiBpdCBoYXMgYmVlbiBlbmFibGVkIHRocm91Z2ggb3B0aW9ucy4gXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYWx0ZXJuYXRlLmljb24gJiYgIXRoaXMub3B0aW9ucy5hbHRlcm5hdGUudGV4dCkgcmV0dXJuO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5zaG93aW5nQWx0ZXJuYXRlKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnLnVpLWJ1dHRvbi1pY29uLXByaW1hcnknKS5oaWRlKCk7XG5cdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnLnVpLWJ1dHRvbi10ZXh0JykuaGlkZSgpO1xuXHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoJy51aS1idXR0b24taWNvbi1hbHRlcm5hdGUnKS5zaG93KCk7XG5cdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnLnVpLWJ1dHRvbi10ZXh0LWFsdGVybmF0ZScpLnNob3coKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnLnVpLWJ1dHRvbi1pY29uLXByaW1hcnknKS5zaG93KCk7XG5cdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnLnVpLWJ1dHRvbi10ZXh0Jykuc2hvdygpO1xuXHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoJy51aS1idXR0b24taWNvbi1hbHRlcm5hdGUnKS5oaWRlKCk7XG5cdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnLnVpLWJ1dHRvbi10ZXh0LWFsdGVybmF0ZScpLmhpZGUoKTtcblx0XHR9XG5cblx0XHR0aGlzLl90cmlnZ2VyKCdhZnRlcnJlZnJlc2hhbHRlcm5hdGUnKTtcblx0fSxcblxuXHQvKipcblx0ICogQ29uc3RydWN0IGJ1dHRvbiAtIHB1bGxzIGluIG9wdGlvbnMgZnJvbSBkYXRhIGF0dHJpYnV0ZXMuXG5cdCAqIEluamVjdHMgbmV3IGVsZW1lbnRzIGZvciBhbHRlcm5hdGUgYXBwZWFyYW5jZSAoaWYgcmVxdWVzdGVkIHZpYSBvcHRpb25zKS5cblx0ICovXG5cdF9yZXNldEJ1dHRvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGljb25QcmltYXJ5ID0gdGhpcy5lbGVtZW50LmRhdGEoJ2ljb24tcHJpbWFyeScpLFxuXHRcdFx0aWNvblNlY29uZGFyeSA9IHRoaXMuZWxlbWVudC5kYXRhKCdpY29uLXNlY29uZGFyeScpO1xuXG5cdFx0aWYgKCFpY29uUHJpbWFyeSkgaWNvblByaW1hcnkgPSB0aGlzLmVsZW1lbnQuZGF0YSgnaWNvbicpO1xuXG5cdFx0Ly8gVE9ETyBNb3ZlIHByZWZpeCBvdXQgb2YgdGhpcyBtZXRob2QsIHdpdGhvdXQgcmVxdXJpaW5nIGl0IGZvciBldmVyeSBpY29uIGRlZmluaXRpb24gaW4gYSBkYXRhIGF0dHJcblx0XHRpZihpY29uUHJpbWFyeSkgdGhpcy5vcHRpb25zLmljb25zLnByaW1hcnkgPSAnYnRuLWljb24tJyArIGljb25QcmltYXJ5O1xuXHRcdGlmKGljb25TZWNvbmRhcnkpIHRoaXMub3B0aW9ucy5pY29ucy5zZWNvbmRhcnkgPSAnYnRuLWljb24tJyArIGljb25TZWNvbmRhcnk7XG5cblx0XHQkLnVpLmJ1dHRvbi5wcm90b3R5cGUuX3Jlc2V0QnV0dG9uLmNhbGwodGhpcyk7XG5cblx0XHQvLyBQdWxsIG9wdGlvbnMgZnJvbSBkYXRhIGF0dHJpYnV0ZXMuIE92ZXJyaWRlbiBieSBleHBsaWNpdCBvcHRpb25zIGdpdmVuIG9uIHdpZGdldCBjcmVhdGlvbi5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5hbHRlcm5hdGUudGV4dCkge1xuXHRcdFx0dGhpcy5vcHRpb25zLmFsdGVybmF0ZS50ZXh0ID0gdGhpcy5lbGVtZW50LmRhdGEoJ3RleHQtYWx0ZXJuYXRlJyk7XG5cdFx0fVxuXHRcdGlmICghdGhpcy5vcHRpb25zLmFsdGVybmF0ZS5pY29uKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuYWx0ZXJuYXRlLmljb24gPSB0aGlzLmVsZW1lbnQuZGF0YSgnaWNvbi1hbHRlcm5hdGUnKTtcblx0XHR9XG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuc2hvd2luZ0FsdGVybmF0ZSkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnNob3dpbmdBbHRlcm5hdGUgPSB0aGlzLmVsZW1lbnQuaGFzQ2xhc3MoJ3NzLXVpLWFsdGVybmF0ZScpO1xuXHRcdH1cblxuXHRcdC8vIENyZWF0ZSBtaXNzaW5nIGVsZW1lbnRzLlxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYWx0ZXJuYXRlLmljb24pIHtcblx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudC5hcHBlbmQoXG5cdFx0XHRcdFwiPHNwYW4gY2xhc3M9J3VpLWJ1dHRvbi1pY29uLWFsdGVybmF0ZSB1aS1idXR0b24taWNvbi1wcmltYXJ5IHVpLWljb24gYnRuLWljb24tXCIgXG5cdFx0XHRcdCsgdGhpcy5vcHRpb25zLmFsdGVybmF0ZS5pY29uICsgXCInPjwvc3Bhbj5cIlxuXHRcdFx0KTtcblx0XHR9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hbHRlcm5hdGUudGV4dCkge1xuXHRcdFx0dGhpcy5idXR0b25FbGVtZW50LmFwcGVuZChcblx0XHRcdFx0XCI8c3BhbiBjbGFzcz0ndWktYnV0dG9uLXRleHQtYWx0ZXJuYXRlIHVpLWJ1dHRvbi10ZXh0Jz5cIiArIHRoaXMub3B0aW9ucy5hbHRlcm5hdGUudGV4dCArIFwiPC9zcGFuPlwiXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3JlZnJlc2hBbHRlcm5hdGUoKTtcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHQkLnVpLmJ1dHRvbi5wcm90b3R5cGUucmVmcmVzaC5jYWxsKHRoaXMpO1xuXG5cdFx0dGhpcy5fcmVmcmVzaEFsdGVybmF0ZSgpO1xuXHR9LFxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudC5maW5kKCcudWktYnV0dG9uLXRleHQtYWx0ZXJuYXRlJykucmVtb3ZlKCk7XG5cdFx0dGhpcy5lbGVtZW50LmZpbmQoJy51aS1idXR0b24taWNvbi1hbHRlcm5hdGUnKS5yZW1vdmUoKTtcblxuXHRcdCQudWkuYnV0dG9uLnByb3RvdHlwZS5kZXN0cm95LmNhbGwoIHRoaXMgKTtcblx0fVxufSk7XG5cbi8qKlxuICogRXh0ZW5kcyBqUXVlcnlVSSBkaWFsb2cgd2l0aCBpZnJhbWUgYWJpbGl0aWVzIChhbmQgcmVsYXRlZCByZXNpemluZyBsb2dpYyksXG4gKiBhbmQgc2V0cyBzb21lIENNUy13aWRlIGRlZmF1bHRzLlxuICpcbiAqIEFkZGl0aW9uYWwgc2V0dGluZ3M6XG4gKiAtICdhdXRvUG9zaXRpb24nOiBBdXRvbWF0aWNhbGx5IHJlcG9zaXRpb24gd2luZG93IG9uIHJlc2l6ZSBiYXNlZCBvbiAncG9zaXRpb24nIG9wdGlvblxuICogLSAnd2lkdGhSYXRpbyc6IFNldHMgd2lkdGggYmFzZWQgb24gcGVyY2VudGFnZSBvZiB3aW5kb3cgKHZhbHVlIGJldHdlZW4gMCBhbmQgMSlcbiAqIC0gJ2hlaWdodFJhdGlvJzogU2V0cyB3aWR0aCBiYXNlZCBvbiBwZXJjZW50YWdlIG9mIHdpbmRvdyAodmFsdWUgYmV0d2VlbiAwIGFuZCAxKVxuICogLSAncmVsb2FkT25PcGVuJzogUmVsb2FkcyB0aGUgaWZyYW1lIHdoZW5ldmVyIHRoZSBkaWFsb2cgaXMgcmVvcGVuZWRcbiAqIC0gJ2lmcmFtZVVybCc6IENyZWF0ZSBhbiBpZnJhbWUgZWxlbWVudCBhbmQgbG9hZCB0aGlzIFVSTCB3aGVuIHRoZSBkaWFsb2cgaXMgY3JlYXRlZFxuICovXG4kLndpZGdldChcInNzdWkuc3NkaWFsb2dcIiwgJC51aS5kaWFsb2csIHtcblx0b3B0aW9uczoge1xuXHRcdC8vIEN1c3RvbSBwcm9wZXJ0aWVzXG5cdFx0aWZyYW1lVXJsOiAnJyxcblx0XHRyZWxvYWRPbk9wZW46IHRydWUsXG5cdFx0ZGlhbG9nRXh0cmFDbGFzczogJycsXG5cblx0XHQvLyBEZWZhdWx0c1xuXHRcdG1vZGFsOiB0cnVlLFxuXHRcdGJnaWZyYW1lOiB0cnVlLFxuXHRcdGF1dG9PcGVuOiBmYWxzZSxcblx0XHRhdXRvUG9zaXRpb246IHRydWUsXG5cdFx0bWluV2lkdGg6IDUwMCxcblx0XHRtYXhXaWR0aDogODAwLFxuXHRcdG1pbkhlaWdodDogMzAwLFxuXHRcdG1heEhlaWdodDogNzAwLFxuXHRcdHdpZHRoUmF0aW86IDAuOCxcblx0XHRoZWlnaHRSYXRpbzogMC44LFxuXHRcdHJlc2l6YWJsZTogZmFsc2Vcblx0fSxcblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0JC51aS5kaWFsb2cucHJvdG90eXBlLl9jcmVhdGUuY2FsbCh0aGlzKTtcblxuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdC8vIENyZWF0ZSBpZnJhbWVcblx0XHR2YXIgaWZyYW1lID0gJCgnPGlmcmFtZSBtYXJnaW5XaWR0aD1cIjBcIiBtYXJnaW5IZWlnaHQ9XCIwXCIgZnJhbWVCb3JkZXI9XCIwXCIgc2Nyb2xsaW5nPVwiYXV0b1wiPjwvaWZyYW1lPicpO1xuXHRcdGlmcmFtZS5iaW5kKCdsb2FkJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYoJCh0aGlzKS5hdHRyKCdzcmMnKSA9PSAnYWJvdXQ6YmxhbmsnKSByZXR1cm47XG5cdFx0XHRcblx0XHRcdGlmcmFtZS5hZGRDbGFzcygnbG9hZGVkJykuc2hvdygpOyAvLyBtb3JlIHJlbGlhYmxlIHRoYW4gJ3NyYycgYXR0ciBjaGVjayAoaW4gSUUpXG5cdFx0XHRzZWxmLl9yZXNpemVJZnJhbWUoKTtcblx0XHRcdHNlbGYudWlEaWFsb2cucmVtb3ZlQ2xhc3MoJ2xvYWRpbmcnKTtcblx0XHR9KS5oaWRlKCk7XG5cdFx0XG5cdFx0aWYodGhpcy5vcHRpb25zLmRpYWxvZ0V4dHJhQ2xhc3MpIHRoaXMudWlEaWFsb2cuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmRpYWxvZ0V4dHJhQ2xhc3MpO1xuXHRcdHRoaXMuZWxlbWVudC5hcHBlbmQoaWZyYW1lKTtcblxuXHRcdC8vIExldCB0aGUgaWZyYW1lIGhhbmRsZSBpdHMgc2Nyb2xsaW5nXG5cdFx0aWYodGhpcy5vcHRpb25zLmlmcmFtZVVybCkgdGhpcy5lbGVtZW50LmNzcygnb3ZlcmZsb3cnLCAnaGlkZGVuJyk7XG5cdH0sXG5cdG9wZW46IGZ1bmN0aW9uKCkge1xuXHRcdCQudWkuZGlhbG9nLnByb3RvdHlwZS5vcGVuLmNhbGwodGhpcyk7XG5cdFx0XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBpZnJhbWUgPSB0aGlzLmVsZW1lbnQuY2hpbGRyZW4oJ2lmcmFtZScpO1xuXG5cdFx0Ly8gTG9hZCBpZnJhbWVcblx0XHRpZih0aGlzLm9wdGlvbnMuaWZyYW1lVXJsICYmICghaWZyYW1lLmhhc0NsYXNzKCdsb2FkZWQnKSB8fCB0aGlzLm9wdGlvbnMucmVsb2FkT25PcGVuKSkge1xuXHRcdFx0aWZyYW1lLmhpZGUoKTtcblx0XHRcdGlmcmFtZS5hdHRyKCdzcmMnLCB0aGlzLm9wdGlvbnMuaWZyYW1lVXJsKTtcblx0XHRcdHRoaXMudWlEaWFsb2cuYWRkQ2xhc3MoJ2xvYWRpbmcnKTtcblx0XHR9XG5cblx0XHQvLyBSZXNpemUgZXZlbnRzXG5cdFx0JCh3aW5kb3cpLmJpbmQoJ3Jlc2l6ZS5zc2RpYWxvZycsIGZ1bmN0aW9uKCkge3NlbGYuX3Jlc2l6ZUlmcmFtZSgpO30pO1xuXHR9LFxuXHRjbG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0JC51aS5kaWFsb2cucHJvdG90eXBlLmNsb3NlLmNhbGwodGhpcyk7XG5cblx0XHR0aGlzLnVpRGlhbG9nLnVuYmluZCgncmVzaXplLnNzZGlhbG9nJyk7XG5cdFx0JCh3aW5kb3cpLnVuYmluZCgncmVzaXplLnNzZGlhbG9nJyk7XG5cdH0sXG5cdF9yZXNpemVJZnJhbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvcHRzID0ge30sIG5ld1dpZHRoLCBuZXdIZWlnaHQsIGlmcmFtZSA9IHRoaXMuZWxlbWVudC5jaGlsZHJlbignaWZyYW1lJyk7O1xuXHRcdGlmKHRoaXMub3B0aW9ucy53aWR0aFJhdGlvKSB7XG5cdFx0XHRuZXdXaWR0aCA9ICQod2luZG93KS53aWR0aCgpICogdGhpcy5vcHRpb25zLndpZHRoUmF0aW87XG5cdFx0XHRpZih0aGlzLm9wdGlvbnMubWluV2lkdGggJiYgbmV3V2lkdGggPCB0aGlzLm9wdGlvbnMubWluV2lkdGgpIHtcblx0XHRcdFx0b3B0cy53aWR0aCA9IHRoaXMub3B0aW9ucy5taW5XaWR0aFxuXHRcdFx0fSBlbHNlIGlmKHRoaXMub3B0aW9ucy5tYXhXaWR0aCAmJiBuZXdXaWR0aCA+IHRoaXMub3B0aW9ucy5tYXhXaWR0aCkge1xuXHRcdFx0XHRvcHRzLndpZHRoID0gdGhpcy5vcHRpb25zLm1heFdpZHRoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0cy53aWR0aCA9IG5ld1dpZHRoO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZih0aGlzLm9wdGlvbnMuaGVpZ2h0UmF0aW8pIHtcblx0XHRcdG5ld0hlaWdodCA9ICQod2luZG93KS5oZWlnaHQoKSAqIHRoaXMub3B0aW9ucy5oZWlnaHRSYXRpbztcblx0XHRcdGlmKHRoaXMub3B0aW9ucy5taW5IZWlnaHQgJiYgbmV3SGVpZ2h0IDwgdGhpcy5vcHRpb25zLm1pbkhlaWdodCkge1xuXHRcdFx0XHRvcHRzLmhlaWdodCA9IHRoaXMub3B0aW9ucy5taW5IZWlnaHRcblx0XHRcdH0gZWxzZSBpZih0aGlzLm9wdGlvbnMubWF4SGVpZ2h0ICYmIG5ld0hlaWdodCA+IHRoaXMub3B0aW9ucy5tYXhIZWlnaHQpIHtcblx0XHRcdFx0b3B0cy5oZWlnaHQgPSB0aGlzLm9wdGlvbnMubWF4SGVpZ2h0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0cy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYoIWpRdWVyeS5pc0VtcHR5T2JqZWN0KG9wdHMpKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb25zKG9wdHMpO1xuXG5cdFx0XHQvLyBSZXNpemUgaWZyYW1lIHdpdGhpbiBkaWFsb2dcblx0XHRcdGlmcmFtZS5hdHRyKCd3aWR0aCcsIFxuXHRcdFx0XHRvcHRzLndpZHRoIFxuXHRcdFx0XHQtIHBhcnNlRmxvYXQodGhpcy5lbGVtZW50LmNzcygncGFkZGluZ0xlZnQnKSlcblx0XHRcdFx0LSBwYXJzZUZsb2F0KHRoaXMuZWxlbWVudC5jc3MoJ3BhZGRpbmdSaWdodCcpKVxuXHRcdFx0KTtcblx0XHRcdGlmcmFtZS5hdHRyKCdoZWlnaHQnLCBcblx0XHRcdFx0b3B0cy5oZWlnaHRcblx0XHRcdFx0LSBwYXJzZUZsb2F0KHRoaXMuZWxlbWVudC5jc3MoJ3BhZGRpbmdUb3AnKSkgXG5cdFx0XHRcdC0gcGFyc2VGbG9hdCh0aGlzLmVsZW1lbnQuY3NzKCdwYWRkaW5nQm90dG9tJykpXG5cdFx0XHQpO1xuXG5cdFx0XHQvLyBFbmZvcmNlIG5ldyBwb3NpdGlvblxuXHRcdFx0aWYodGhpcy5vcHRpb25zLmF1dG9Qb3NpdGlvbikge1xuXHRcdFx0XHR0aGlzLl9zZXRPcHRpb24oXCJwb3NpdGlvblwiLCB0aGlzLm9wdGlvbnMucG9zaXRpb24pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbiQud2lkZ2V0KFwic3N1aS50aXRsZWJhclwiLCB7XG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMub3JpZ2luYWxUaXRsZSA9IHRoaXMuZWxlbWVudC5hdHRyKCd0aXRsZScpO1xuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dmFyIHRpdGxlID0gb3B0aW9ucy50aXRsZSB8fCB0aGlzLm9yaWdpbmFsVGl0bGUgfHwgJyZuYnNwOyc7XG5cdFx0dmFyIHRpdGxlSWQgPSAkLnVpLmRpYWxvZy5nZXRUaXRsZUlkKHRoaXMuZWxlbWVudCk7XG5cblx0XHR0aGlzLmVsZW1lbnQucGFyZW50KCkuYWRkQ2xhc3MoJ3VpLWRpYWxvZycpO1xuXG5cdFx0dmFyIHVpRGlhbG9nVGl0bGViYXIgPSB0aGlzLmVsZW1lbnQuXG5cdFx0XHRhZGRDbGFzcyhcblx0XHRcdFx0J3VpLWRpYWxvZy10aXRsZWJhciAnICtcblx0XHRcdFx0J3VpLXdpZGdldC1oZWFkZXIgJyArXG5cdFx0XHRcdCd1aS1jb3JuZXItYWxsICcgK1xuXHRcdFx0XHQndWktaGVscGVyLWNsZWFyZml4J1xuXHRcdFx0KTtcblxuXHRcdFx0Ly8gQnkgZGVmYXVsdCwgdGhlXG5cblx0XHRcdGlmKG9wdGlvbnMuY2xvc2VCdXR0b24pIHtcblx0XHRcdFx0dmFyIHVpRGlhbG9nVGl0bGViYXJDbG9zZSA9ICQoJzxhIGhyZWY9XCIjXCIvPicpXG5cdFx0XHRcdFx0LmFkZENsYXNzKFxuXHRcdFx0XHRcdFx0J3VpLWRpYWxvZy10aXRsZWJhci1jbG9zZSAnICtcblx0XHRcdFx0XHRcdCd1aS1jb3JuZXItYWxsJ1xuXHRcdFx0XHRcdClcblx0XHRcdFx0XHQuYXR0cigncm9sZScsICdidXR0b24nKVxuXHRcdFx0XHRcdC5ob3Zlcihcblx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR1aURpYWxvZ1RpdGxlYmFyQ2xvc2UuYWRkQ2xhc3MoJ3VpLXN0YXRlLWhvdmVyJyk7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHVpRGlhbG9nVGl0bGViYXJDbG9zZS5yZW1vdmVDbGFzcygndWktc3RhdGUtaG92ZXInKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0LmZvY3VzKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dWlEaWFsb2dUaXRsZWJhckNsb3NlLmFkZENsYXNzKCd1aS1zdGF0ZS1mb2N1cycpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmJsdXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR1aURpYWxvZ1RpdGxlYmFyQ2xvc2UucmVtb3ZlQ2xhc3MoJ3VpLXN0YXRlLWZvY3VzJyk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQubW91c2Vkb3duKGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdFx0XHRldi5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5hcHBlbmRUbyh1aURpYWxvZ1RpdGxlYmFyKTtcblxuXHRcdFx0XHR2YXIgdWlEaWFsb2dUaXRsZWJhckNsb3NlVGV4dCA9ICh0aGlzLnVpRGlhbG9nVGl0bGViYXJDbG9zZVRleHQgPSAkKCc8c3Bhbi8+JykpXG5cdFx0XHRcdFx0LmFkZENsYXNzKFxuXHRcdFx0XHRcdFx0J3VpLWljb24gJyArXG5cdFx0XHRcdFx0XHQndWktaWNvbi1jbG9zZXRoaWNrJ1xuXHRcdFx0XHRcdClcblx0XHRcdFx0XHQudGV4dChvcHRpb25zLmNsb3NlVGV4dClcblx0XHRcdFx0XHQuYXBwZW5kVG8odWlEaWFsb2dUaXRsZWJhckNsb3NlKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHVpRGlhbG9nVGl0bGUgPSAkKCc8c3Bhbi8+Jylcblx0XHRcdFx0LmFkZENsYXNzKCd1aS1kaWFsb2ctdGl0bGUnKVxuXHRcdFx0XHQuYXR0cignaWQnLCB0aXRsZUlkKVxuXHRcdFx0XHQuaHRtbCh0aXRsZSlcblx0XHRcdFx0LnByZXBlbmRUbyh1aURpYWxvZ1RpdGxlYmFyKTtcblxuXHRcdFx0dWlEaWFsb2dUaXRsZWJhci5maW5kKFwiKlwiKS5hZGQodWlEaWFsb2dUaXRsZWJhcikuZGlzYWJsZVNlbGVjdGlvbigpO1xuXHR9LFxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnVuYmluZCgnLmRpYWxvZycpXG5cdFx0XHQucmVtb3ZlRGF0YSgnZGlhbG9nJylcblx0XHRcdC5yZW1vdmVDbGFzcygndWktZGlhbG9nLWNvbnRlbnQgdWktd2lkZ2V0LWNvbnRlbnQnKVxuXHRcdFx0LmhpZGUoKS5hcHBlbmRUbygnYm9keScpO1xuXG5cdFx0KHRoaXMub3JpZ2luYWxUaXRsZSAmJiB0aGlzLmVsZW1lbnQuYXR0cigndGl0bGUnLCB0aGlzLm9yaWdpbmFsVGl0bGUpKTtcblx0fVxufSk7XG5cbiQuZXh0ZW5kKCQuc3N1aS50aXRsZWJhciwge1xuXHR2ZXJzaW9uOiBcIjAuMC4xXCIsXG5cdG9wdGlvbnM6IHtcblx0XHR0aXRsZTogJycsXG5cdFx0Y2xvc2VCdXR0b246IGZhbHNlLFxuXHRcdGNsb3NlVGV4dDogJ2Nsb3NlJ1xuXHR9LFxuXG5cdHV1aWQ6IDAsXG5cblx0Z2V0VGl0bGVJZDogZnVuY3Rpb24oJGVsKSB7XG5cdFx0cmV0dXJuICd1aS1kaWFsb2ctdGl0bGUtJyArICgkZWwuYXR0cignaWQnKSB8fCArK3RoaXMudXVpZCk7XG5cdH1cbn0pO1xuIiwiLy8gQ2hvc2VuLCBhIFNlbGVjdCBCb3ggRW5oYW5jZXIgZm9yIGpRdWVyeSBhbmQgUHJvdG95cGVcbi8vIGJ5IFBhdHJpY2sgRmlsbGVyIGZvciBIYXJ2ZXN0LCBodHRwOi8vZ2V0aGFydmVzdC5jb21cbi8vIFxuLy8gVmVyc2lvbiAwLjkuOFxuLy8gRnVsbCBzb3VyY2UgYXQgaHR0cHM6Ly9naXRodWIuY29tL2hhcnZlc3RocS9jaG9zZW5cbi8vIENvcHlyaWdodCAoYykgMjAxMSBIYXJ2ZXN0IGh0dHA6Ly9nZXRoYXJ2ZXN0LmNvbVxuXG4vLyBNSVQgTGljZW5zZSwgaHR0cHM6Ly9naXRodWIuY29tL2hhcnZlc3RocS9jaG9zZW4vYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuLy8gYmFzZWQgb24gdmVyc2lvbiAwLjkuOCwgYXBwbGllZCBhIHZlcnkgc2ltcGxlIHBhdGNoIHRoYXQgZml4ZXMgcGVyY2VudGFnZSB3aWR0aCBzdXBwb3J0IG9uIHNlbGVjdCB0YWcsIGFuZCBlbmFibGVzIHJpc2UtdXAgZnVuY3Rpb25hbGl0eVxuLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBgY2FrZSBidWlsZGAsIGRvIG5vdCBlZGl0IGl0IGJ5IGhhbmQuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBTZWxlY3RQYXJzZXI7XG5cbiAgU2VsZWN0UGFyc2VyID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gT3JpZ2lvbmFsIC0gWW91IGNhbid0IGFzc2lnbiB0byBmdW5jdGlvbnMgbGlrZSB0aGlzIGluIHN0cmljdCBtb2RlLlxuICAgIC8vU2VsZWN0UGFyc2VyLm5hbWUgPSAnU2VsZWN0UGFyc2VyJztcblxuICAgIGZ1bmN0aW9uIFNlbGVjdFBhcnNlcigpIHtcbiAgICAgIHRoaXMub3B0aW9uc19pbmRleCA9IDA7XG4gICAgICB0aGlzLnBhcnNlZCA9IFtdO1xuICAgIH1cblxuICAgIC8vIFNpbHZlclN0cmlwZSBjdXN0b21cbiAgICBTZWxlY3RQYXJzZXIucHJvdG90eXBlLm5hbWUgPSAnU2VsZWN0UGFyc2VyJztcblxuICAgIFNlbGVjdFBhcnNlci5wcm90b3R5cGUuYWRkX25vZGUgPSBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiT1BUR1JPVVBcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRfZ3JvdXAoY2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkX29wdGlvbihjaGlsZCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFNlbGVjdFBhcnNlci5wcm90b3R5cGUuYWRkX2dyb3VwID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgIHZhciBncm91cF9wb3NpdGlvbiwgb3B0aW9uLCBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICBncm91cF9wb3NpdGlvbiA9IHRoaXMucGFyc2VkLmxlbmd0aDtcbiAgICAgIHRoaXMucGFyc2VkLnB1c2goe1xuICAgICAgICBhcnJheV9pbmRleDogZ3JvdXBfcG9zaXRpb24sXG4gICAgICAgIGdyb3VwOiB0cnVlLFxuICAgICAgICBsYWJlbDogZ3JvdXAubGFiZWwsXG4gICAgICAgIGNoaWxkcmVuOiAwLFxuICAgICAgICBkaXNhYmxlZDogZ3JvdXAuZGlzYWJsZWRcbiAgICAgIH0pO1xuICAgICAgX3JlZiA9IGdyb3VwLmNoaWxkTm9kZXM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIG9wdGlvbiA9IF9yZWZbX2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMuYWRkX29wdGlvbihvcHRpb24sIGdyb3VwX3Bvc2l0aW9uLCBncm91cC5kaXNhYmxlZCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBTZWxlY3RQYXJzZXIucHJvdG90eXBlLmFkZF9vcHRpb24gPSBmdW5jdGlvbihvcHRpb24sIGdyb3VwX3Bvc2l0aW9uLCBncm91cF9kaXNhYmxlZCkge1xuICAgICAgaWYgKG9wdGlvbi5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIk9QVElPTlwiKSB7XG4gICAgICAgIC8vIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9oYXJ2ZXN0aHEvY2hvc2VuL2lzc3Vlcy8yMTI1XG4gICAgICAgIGlmICghb3B0aW9uLnRleHQubWF0Y2goL15cXHMqJC9nKSkge1xuICAgICAgICAgIGlmIChncm91cF9wb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFtncm91cF9wb3NpdGlvbl0uY2hpbGRyZW4gKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wYXJzZWQucHVzaCh7XG4gICAgICAgICAgICBhcnJheV9pbmRleDogdGhpcy5wYXJzZWQubGVuZ3RoLFxuICAgICAgICAgICAgb3B0aW9uc19pbmRleDogdGhpcy5vcHRpb25zX2luZGV4LFxuICAgICAgICAgICAgdmFsdWU6IG9wdGlvbi52YWx1ZSxcbiAgICAgICAgICAgIHRleHQ6IG9wdGlvbi50ZXh0LFxuICAgICAgICAgICAgaHRtbDogb3B0aW9uLmlubmVySFRNTCxcbiAgICAgICAgICAgIHNlbGVjdGVkOiBvcHRpb24uc2VsZWN0ZWQsXG4gICAgICAgICAgICBkaXNhYmxlZDogZ3JvdXBfZGlzYWJsZWQgPT09IHRydWUgPyBncm91cF9kaXNhYmxlZCA6IG9wdGlvbi5kaXNhYmxlZCxcbiAgICAgICAgICAgIGdyb3VwX2FycmF5X2luZGV4OiBncm91cF9wb3NpdGlvbixcbiAgICAgICAgICAgIGNsYXNzZXM6IG9wdGlvbi5jbGFzc05hbWUsXG4gICAgICAgICAgICBzdHlsZTogb3B0aW9uLnN0eWxlLmNzc1RleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhcnNlZC5wdXNoKHtcbiAgICAgICAgICAgIGFycmF5X2luZGV4OiB0aGlzLnBhcnNlZC5sZW5ndGgsXG4gICAgICAgICAgICBvcHRpb25zX2luZGV4OiB0aGlzLm9wdGlvbnNfaW5kZXgsXG4gICAgICAgICAgICBlbXB0eTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNfaW5kZXggKz0gMTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFNlbGVjdFBhcnNlcjtcblxuICB9KSgpO1xuXG4gIFNlbGVjdFBhcnNlci5zZWxlY3RfdG9fYXJyYXkgPSBmdW5jdGlvbihzZWxlY3QpIHtcbiAgICB2YXIgY2hpbGQsIHBhcnNlciwgX2ksIF9sZW4sIF9yZWY7XG4gICAgcGFyc2VyID0gbmV3IFNlbGVjdFBhcnNlcigpO1xuICAgIF9yZWYgPSBzZWxlY3QuY2hpbGROb2RlcztcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGNoaWxkID0gX3JlZltfaV07XG4gICAgICBwYXJzZXIuYWRkX25vZGUoY2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlZDtcbiAgfTtcblxuICB0aGlzLlNlbGVjdFBhcnNlciA9IFNlbGVjdFBhcnNlcjtcblxuLy8gT3JpZ2lvbmFsIC0gJ3RoaXMnICE9PSAnd2luZG93JyBpbiBicm93c2VyaWZ5XG4vL30pLmNhbGwodGhpcyk7XG5cbi8vIFNpbHZlclN0cmlwZSBjdXN0b21cbn0pLmNhbGwod2luZG93KTtcblxuLypcbkNob3NlbiBzb3VyY2U6IGdlbmVyYXRlIG91dHB1dCB1c2luZyAnY2FrZSBidWlsZCdcbkNvcHlyaWdodCAoYykgMjAxMSBieSBIYXJ2ZXN0XG4qL1xuXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIEFic3RyYWN0Q2hvc2VuLCByb290O1xuXG4gIHJvb3QgPSB0aGlzO1xuXG4gIEFic3RyYWN0Q2hvc2VuID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gT3JpZ2lvbmFsIC0gWW91IGNhbid0IGFzc2lnbiB0byBmdW5jdGlvbnMgbGlrZSB0aGlzIGluIHN0cmljdCBtb2RlLlxuICAgIC8vQWJzdHJhY3RDaG9zZW4ubmFtZSA9ICdBYnN0cmFjdENob3Nlbic7XG5cbiAgICBmdW5jdGlvbiBBYnN0cmFjdENob3Nlbihmb3JtX2ZpZWxkLCBvcHRpb25zKSB7XG4gICAgICB0aGlzLmZvcm1fZmllbGQgPSBmb3JtX2ZpZWxkO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9O1xuICAgICAgdGhpcy5zZXRfZGVmYXVsdF92YWx1ZXMoKTtcbiAgICAgIHRoaXMuaXNfbXVsdGlwbGUgPSB0aGlzLmZvcm1fZmllbGQubXVsdGlwbGU7XG4gICAgICB0aGlzLnNldF9kZWZhdWx0X3RleHQoKTtcbiAgICAgIHRoaXMuc2V0dXAoKTtcbiAgICAgIHRoaXMuc2V0X3VwX2h0bWwoKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJfb2JzZXJ2ZXJzKCk7XG4gICAgICB0aGlzLmZpbmlzaF9zZXR1cCgpO1xuICAgIH1cblxuICAgIC8vIFNpbHZlclN0cmlwZSBjdXN0b21cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUubmFtZSA9ICdBYnN0cmFjdENob3Nlbic7XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuc2V0X2RlZmF1bHRfdmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5jbGlja190ZXN0X2FjdGlvbiA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMudGVzdF9hY3RpdmVfY2xpY2soZXZ0KTtcbiAgICAgIH07XG4gICAgICB0aGlzLmFjdGl2YXRlX2FjdGlvbiA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuYWN0aXZhdGVfZmllbGQoZXZ0KTtcbiAgICAgIH07XG4gICAgICB0aGlzLmFjdGl2ZV9maWVsZCA9IGZhbHNlO1xuICAgICAgdGhpcy5tb3VzZV9vbl9jb250YWluZXIgPSBmYWxzZTtcbiAgICAgIHRoaXMucmVzdWx0c19zaG93aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLnJlc3VsdF9oaWdobGlnaHRlZCA9IG51bGw7XG4gICAgICB0aGlzLnJlc3VsdF9zaW5nbGVfc2VsZWN0ZWQgPSBudWxsO1xuICAgICAgdGhpcy5hbGxvd19zaW5nbGVfZGVzZWxlY3QgPSAodGhpcy5vcHRpb25zLmFsbG93X3NpbmdsZV9kZXNlbGVjdCAhPSBudWxsKVxuXHRcdFx0ICAmJiAodGhpcy5mb3JtX2ZpZWxkLm9wdGlvbnNbMF0gIT0gbnVsbClcblx0XHRcdCAgLy8gd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2hhcnZlc3RocS9jaG9zZW4vaXNzdWVzLzIxMjVcblx0XHRcdCAgJiYgdGhpcy5mb3JtX2ZpZWxkLm9wdGlvbnNbMF0udGV4dC5tYXRjaCgvXlxccyokL2cpXG5cdFx0XHRcdD8gdGhpcy5vcHRpb25zLmFsbG93X3NpbmdsZV9kZXNlbGVjdFxuXHRcdFx0XHQ6IGZhbHNlO1xuICAgICAgdGhpcy5kaXNhYmxlX3NlYXJjaF90aHJlc2hvbGQgPSB0aGlzLm9wdGlvbnMuZGlzYWJsZV9zZWFyY2hfdGhyZXNob2xkIHx8IDA7XG4gICAgICB0aGlzLmRpc2FibGVfc2VhcmNoID0gdGhpcy5vcHRpb25zLmRpc2FibGVfc2VhcmNoIHx8IGZhbHNlO1xuICAgICAgdGhpcy5zZWFyY2hfY29udGFpbnMgPSB0aGlzLm9wdGlvbnMuc2VhcmNoX2NvbnRhaW5zIHx8IGZhbHNlO1xuICAgICAgdGhpcy5jaG9pY2VzID0gMDtcbiAgICAgIHRoaXMuc2luZ2xlX2JhY2tzdHJva2VfZGVsZXRlID0gdGhpcy5vcHRpb25zLnNpbmdsZV9iYWNrc3Ryb2tlX2RlbGV0ZSB8fCBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLm1heF9zZWxlY3RlZF9vcHRpb25zID0gdGhpcy5vcHRpb25zLm1heF9zZWxlY3RlZF9vcHRpb25zIHx8IEluZmluaXR5O1xuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuc2V0X2RlZmF1bHRfdGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZm9ybV9maWVsZC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBsYWNlaG9sZGVyXCIpKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdF90ZXh0ID0gdGhpcy5mb3JtX2ZpZWxkLmdldEF0dHJpYnV0ZShcImRhdGEtcGxhY2Vob2xkZXJcIik7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0X3RleHQgPSB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXJfdGV4dF9tdWx0aXBsZSB8fCB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXJfdGV4dCB8fCBcIlNlbGVjdCBTb21lIE9wdGlvbnNcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdF90ZXh0ID0gdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyX3RleHRfc2luZ2xlIHx8IHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcl90ZXh0IHx8IFwiU2VsZWN0IGFuIE9wdGlvblwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19ub25lX2ZvdW5kID0gdGhpcy5mb3JtX2ZpZWxkLmdldEF0dHJpYnV0ZShcImRhdGEtbm9fcmVzdWx0c190ZXh0XCIpIHx8IHRoaXMub3B0aW9ucy5ub19yZXN1bHRzX3RleHQgfHwgXCJObyByZXN1bHRzIG1hdGNoXCI7XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5tb3VzZV9lbnRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubW91c2Vfb25fY29udGFpbmVyID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLm1vdXNlX2xlYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb3VzZV9vbl9jb250YWluZXIgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmlucHV0X2ZvY3VzID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZV9maWVsZCkge1xuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb250YWluZXJfbW91c2Vkb3duKCk7XG4gICAgICAgICAgfSksIDUwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZV9maWVsZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2YXRlX2ZpZWxkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmlucHV0X2JsdXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMubW91c2Vfb25fY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlX2ZpZWxkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuYmx1cl90ZXN0KCk7XG4gICAgICAgIH0pLCAxMDApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUucmVzdWx0X2FkZF9vcHRpb24gPSBmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgIHZhciBjbGFzc2VzLCBzdHlsZTtcbiAgICAgIGlmICghb3B0aW9uLmRpc2FibGVkKSB7XG4gICAgICAgIG9wdGlvbi5kb21faWQgPSB0aGlzLmNvbnRhaW5lcl9pZCArIFwiX29fXCIgKyBvcHRpb24uYXJyYXlfaW5kZXg7XG4gICAgICAgIGNsYXNzZXMgPSBvcHRpb24uc2VsZWN0ZWQgJiYgdGhpcy5pc19tdWx0aXBsZSA/IFtdIDogW1wiYWN0aXZlLXJlc3VsdFwiXTtcbiAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICAgIGNsYXNzZXMucHVzaChcInJlc3VsdC1zZWxlY3RlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9uLmdyb3VwX2FycmF5X2luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICBjbGFzc2VzLnB1c2goXCJncm91cC1vcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbi5jbGFzc2VzICE9PSBcIlwiKSB7XG4gICAgICAgICAgY2xhc3Nlcy5wdXNoKG9wdGlvbi5jbGFzc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZSA9IG9wdGlvbi5zdHlsZS5jc3NUZXh0ICE9PSBcIlwiID8gXCIgc3R5bGU9XFxcIlwiICsgb3B0aW9uLnN0eWxlICsgXCJcXFwiXCIgOiBcIlwiO1xuICAgICAgICByZXR1cm4gJzxsaSBpZD1cIicgKyBvcHRpb24uZG9tX2lkICsgJ1wiIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyArIHN0eWxlICsgJz4nICsgb3B0aW9uLmh0bWwgKyAnPC9saT4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5yZXN1bHRzX3VwZGF0ZV9maWVsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHRoaXMucmVzdWx0c19yZXNldF9jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc3VsdF9jbGVhcl9oaWdobGlnaHQoKTtcbiAgICAgIHRoaXMucmVzdWx0X3NpbmdsZV9zZWxlY3RlZCA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX2J1aWxkKCk7XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5yZXN1bHRzX3RvZ2dsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucmVzdWx0c19zaG93aW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHNfaGlkZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19zaG93KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5yZXN1bHRzX3NlYXJjaCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKHRoaXMucmVzdWx0c19zaG93aW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpbm5vd19yZXN1bHRzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3Nob3coKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmtleXVwX2NoZWNrZXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBzdHJva2UsIF9yZWY7XG4gICAgICBzdHJva2UgPSAoX3JlZiA9IGV2dC53aGljaCkgIT0gbnVsbCA/IF9yZWYgOiBldnQua2V5Q29kZTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkX3NjYWxlKCk7XG4gICAgICBzd2l0Y2ggKHN0cm9rZSkge1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUgJiYgdGhpcy5iYWNrc3Ryb2tlX2xlbmd0aCA8IDEgJiYgdGhpcy5jaG9pY2VzID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5ZG93bl9iYWNrc3Ryb2tlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5wZW5kaW5nX2JhY2tzdHJva2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19zZWFyY2goKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgaWYgKHRoaXMucmVzdWx0c19zaG93aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRfc2VsZWN0KGV2dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIGlmICh0aGlzLnJlc3VsdHNfc2hvd2luZykge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzX2hpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgY2FzZSAzODpcbiAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgY2FzZSA5MTpcbiAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3NlYXJjaCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuZ2VuZXJhdGVfZmllbGRfaWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuZXdfaWQ7XG4gICAgICBuZXdfaWQgPSB0aGlzLmdlbmVyYXRlX3JhbmRvbV9pZCgpO1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkLmlkID0gbmV3X2lkO1xuICAgICAgcmV0dXJuIG5ld19pZDtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmdlbmVyYXRlX3JhbmRvbV9jaGFyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2hhcnMsIG5ld2NoYXIsIHJhbmQ7XG4gICAgICBjaGFycyA9IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCI7XG4gICAgICByYW5kID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXdjaGFyID0gY2hhcnMuc3Vic3RyaW5nKHJhbmQsIHJhbmQgKyAxKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEFic3RyYWN0Q2hvc2VuO1xuXG4gIH0pKCk7XG5cbiAgcm9vdC5BYnN0cmFjdENob3NlbiA9IEFic3RyYWN0Q2hvc2VuO1xuXG4vLyBPcmlnaW9uYWwgLSAndGhpcycgIT09ICd3aW5kb3cnIGluIGJyb3dzZXJpZnlcbi8vfSkuY2FsbCh0aGlzKTtcblxuLy8gU2lsdmVyU3RyaXBlIGN1c3RvbVxufSkuY2FsbCh3aW5kb3cpO1xuXG4vKlxuQ2hvc2VuIHNvdXJjZTogZ2VuZXJhdGUgb3V0cHV0IHVzaW5nICdjYWtlIGJ1aWxkJ1xuQ29weXJpZ2h0IChjKSAyMDExIGJ5IEhhcnZlc3RcbiovXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgJCwgQ2hvc2VuLCBnZXRfc2lkZV9ib3JkZXJfcGFkZGluZywgcm9vdCxcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XG5cbiAgcm9vdCA9IHRoaXM7XG5cbiAgJCA9IGpRdWVyeTtcblxuICAkLmZuLmV4dGVuZCh7XG4gICAgY2hvc2VuOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoJC5icm93c2VyLm1zaWUgJiYgKCQuYnJvd3Nlci52ZXJzaW9uID09PSBcIjYuMFwiIHx8ICgkLmJyb3dzZXIudmVyc2lvbiA9PT0gXCI3LjBcIiAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPT09IDcpKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaW5wdXRfZmllbGQpIHtcbiAgICAgICAgdmFyICR0aGlzO1xuICAgICAgICAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgIGlmICghJHRoaXMuaGFzQ2xhc3MoXCJjaHpuLWRvbmVcIikpIHtcbiAgICAgICAgICByZXR1cm4gJHRoaXMuZGF0YSgnY2hvc2VuJywgbmV3IENob3Nlbih0aGlzLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgQ2hvc2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuXG4gICAgX19leHRlbmRzKENob3NlbiwgX3N1cGVyKTtcblxuICAgIC8vIE9yaWdpb25hbCAtIFlvdSBjYW4ndCBhc3NpZ24gdG8gZnVuY3Rpb25zIGxpa2UgdGhpcyBpbiBzdHJpY3QgbW9kZS5cbiAgICAvL0Nob3Nlbi5uYW1lID0gJ0Nob3Nlbic7XG5cbiAgICBmdW5jdGlvbiBDaG9zZW4oKSB7XG4gICAgICByZXR1cm4gQ2hvc2VuLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFNpbHZlclN0cmlwZSBjdXN0b21cbiAgICBDaG9zZW4ucHJvdG90eXBlLm5hbWUgPSAnQ2hvc2VuJztcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZm9ybV9maWVsZF9qcSA9ICQodGhpcy5mb3JtX2ZpZWxkKTtcbiAgICAgIHRoaXMuY3VycmVudF92YWx1ZSA9IHRoaXMuZm9ybV9maWVsZF9qcS52YWwoKTtcbiAgICAgIHJldHVybiB0aGlzLmlzX3J0bCA9IHRoaXMuZm9ybV9maWVsZF9qcS5oYXNDbGFzcyhcImNoem4tcnRsXCIpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmZpbmlzaF9zZXR1cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybV9maWVsZF9qcS5hZGRDbGFzcyhcImNoem4tZG9uZVwiKTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5zZXRfdXBfaHRtbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvbnRhaW5lcl9kaXYsIGRkX3RvcCwgZGRfd2lkdGgsIHJpc2UsIHNmX3dpZHRoO1xuICAgICAgdGhpcy5jb250YWluZXJfaWQgPSB0aGlzLmZvcm1fZmllbGQuaWQubGVuZ3RoID8gdGhpcy5mb3JtX2ZpZWxkLmlkLnJlcGxhY2UoLyg6fFxcLikvZywgJ18nKSA6IHRoaXMuZ2VuZXJhdGVfZmllbGRfaWQoKTtcbiAgICAgIHRoaXMuY29udGFpbmVyX2lkICs9IFwiX2Noem5cIjtcbiAgICAgIHRoaXMuZl93aWR0aCA9IHRoaXMuZm9ybV9maWVsZF9qcS5vdXRlcldpZHRoKCk7XG4gICAgICB0aGlzLmRlZmF1bHRfdGV4dCA9IHRoaXMuZm9ybV9maWVsZF9qcS5kYXRhKCdwbGFjZWhvbGRlcicpID8gdGhpcy5mb3JtX2ZpZWxkX2pxLmRhdGEoJ3BsYWNlaG9sZGVyJykgOiB0aGlzLmRlZmF1bHRfdGV4dF9kZWZhdWx0O1xuICAgICAgY29udGFpbmVyX2RpdiA9ICQoXCI8ZGl2IC8+XCIsIHtcbiAgICAgICAgaWQ6IHRoaXMuY29udGFpbmVyX2lkLFxuICAgICAgICBcImNsYXNzXCI6IFwiY2h6bi1jb250YWluZXJcIiArICh0aGlzLmlzX3J0bCA/ICcgY2h6bi1ydGwnIDogJycpLFxuICAgICAgICBzdHlsZTogJ3dpZHRoOiAnICsgKHRoaXMub3B0aW9ucy53aWR0aCB8fCB0aGlzLmZfd2lkdGgpICsgJ3B4OydcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgY29udGFpbmVyX2Rpdi5odG1sKCc8dWwgY2xhc3M9XCJjaHpuLWNob2ljZXNcIj48bGkgY2xhc3M9XCJzZWFyY2gtZmllbGRcIj48aW5wdXQgdHlwZT1cInRleHRcIiB2YWx1ZT1cIicgKyB0aGlzLmRlZmF1bHRfdGV4dCArICdcIiBjbGFzcz1cImRlZmF1bHRcIiBhdXRvY29tcGxldGU9XCJvZmZcIiBzdHlsZT1cIndpZHRoOjI1cHg7XCIgLz48L2xpPjwvdWw+PGRpdiBjbGFzcz1cImNoem4tZHJvcFwiIHN0eWxlPVwibGVmdDotOTAwMHB4O1wiPjx1bCBjbGFzcz1cImNoem4tcmVzdWx0c1wiPjwvdWw+PC9kaXY+Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXJfZGl2Lmh0bWwoJzxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBjbGFzcz1cImNoem4tc2luZ2xlIGNoem4tZGVmYXVsdFwiIHRhYmluZGV4PVwiLTFcIj48c3Bhbj4nICsgdGhpcy5kZWZhdWx0X3RleHQgKyAnPC9zcGFuPjxkaXY+PGI+PC9iPjwvZGl2PjwvYT48ZGl2IGNsYXNzPVwiY2h6bi1kcm9wXCIgc3R5bGU9XCJsZWZ0Oi05MDAwcHg7XCI+PGRpdiBjbGFzcz1cImNoem4tc2VhcmNoXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgLz48L2Rpdj48dWwgY2xhc3M9XCJjaHpuLXJlc3VsdHNcIj48L3VsPjwvZGl2PicpO1xuICAgICAgfVxuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLmhpZGUoKS5hZnRlcihjb250YWluZXJfZGl2KTtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gJCgnIycgKyB0aGlzLmNvbnRhaW5lcl9pZCk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcyhcImNoem4tY29udGFpbmVyLVwiICsgKHRoaXMuaXNfbXVsdGlwbGUgPyBcIm11bHRpXCIgOiBcInNpbmdsZVwiKSk7XG4gICAgICB0aGlzLmRyb3Bkb3duID0gdGhpcy5jb250YWluZXIuZmluZCgnZGl2LmNoem4tZHJvcCcpLmZpcnN0KCk7XG4gICAgICAvKlxuICAgICAgICAgICAgQ0FMTCBDVVNUT00gRlVOQ1RJT046IHJpc2VfdXBcbiAgICAgICAgICAgICAgIyBpZiByaXNlLXVwIHRydWUsIHJldmVyc2UgZHJvcC11cCBkaXJlY3Rpb25cbiAgICAgICovXG5cbiAgICAgIHJpc2UgPSB0aGlzLnJpc2VfdXAodGhpcy5jb250YWluZXIsIHRoaXMuZHJvcGRvd24pO1xuICAgICAgZGRfdG9wID0gcmlzZSA/IC10aGlzLmNvbnRhaW5lci5maW5kKCcuY2h6bi1kcm9wJykuaGVpZ2h0KCkgOiB0aGlzLmNvbnRhaW5lci5oZWlnaHQoKTtcbiAgICAgIGRkX3dpZHRoID0gdGhpcy5jb250YWluZXIud2lkdGgoKSAtIGdldF9zaWRlX2JvcmRlcl9wYWRkaW5nKHRoaXMuZHJvcGRvd24pO1xuICAgICAgdGhpcy5kcm9wZG93bi5jc3Moe1xuICAgICAgICBcIndpZHRoXCI6IGRkX3dpZHRoICsgXCJweFwiLFxuICAgICAgICBcInRvcFwiOiBkZF90b3AgKyBcInB4XCJcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQgPSB0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dCcpLmZpcnN0KCk7XG4gICAgICB0aGlzLnNlYXJjaF9yZXN1bHRzID0gdGhpcy5jb250YWluZXIuZmluZCgndWwuY2h6bi1yZXN1bHRzJykuZmlyc3QoKTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkX3NjYWxlKCk7XG4gICAgICB0aGlzLnNlYXJjaF9ub19yZXN1bHRzID0gdGhpcy5jb250YWluZXIuZmluZCgnbGkubm8tcmVzdWx0cycpLmZpcnN0KCk7XG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICB0aGlzLnNlYXJjaF9jaG9pY2VzID0gdGhpcy5jb250YWluZXIuZmluZCgndWwuY2h6bi1jaG9pY2VzJykuZmlyc3QoKTtcbiAgICAgICAgdGhpcy5zZWFyY2hfY29udGFpbmVyID0gdGhpcy5jb250YWluZXIuZmluZCgnbGkuc2VhcmNoLWZpZWxkJykuZmlyc3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VhcmNoX2NvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLmZpbmQoJ2Rpdi5jaHpuLXNlYXJjaCcpLmZpcnN0KCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfaXRlbSA9IHRoaXMuY29udGFpbmVyLmZpbmQoJy5jaHpuLXNpbmdsZScpLmZpcnN0KCk7XG4gICAgICAgIHNmX3dpZHRoID0gZGRfd2lkdGggLSBnZXRfc2lkZV9ib3JkZXJfcGFkZGluZyh0aGlzLnNlYXJjaF9jb250YWluZXIpIC0gZ2V0X3NpZGVfYm9yZGVyX3BhZGRpbmcodGhpcy5zZWFyY2hfZmllbGQpO1xuICAgICAgICB0aGlzLnNlYXJjaF9maWVsZC5jc3Moe1xuICAgICAgICAgIFwid2lkdGhcIjogc2Zfd2lkdGggKyBcInB4XCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc3VsdHNfYnVpbGQoKTtcbiAgICAgIHRoaXMuc2V0X3RhYl9pbmRleCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwibGlzenQ6cmVhZHlcIiwge1xuICAgICAgICBjaG9zZW46IHRoaXNcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlZ2lzdGVyX29ic2VydmVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMuY29udGFpbmVyLm1vdXNlZG93bihmdW5jdGlvbihldnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmNvbnRhaW5lcl9tb3VzZWRvd24oZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb250YWluZXIubW91c2V1cChmdW5jdGlvbihldnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmNvbnRhaW5lcl9tb3VzZXVwKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29udGFpbmVyLm1vdXNlZW50ZXIoZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5tb3VzZV9lbnRlcihldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5tb3VzZWxlYXZlKGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMubW91c2VfbGVhdmUoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfcmVzdWx0cy5tb3VzZXVwKGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuc2VhcmNoX3Jlc3VsdHNfbW91c2V1cChldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNlYXJjaF9yZXN1bHRzLm1vdXNlb3ZlcihmdW5jdGlvbihldnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnNlYXJjaF9yZXN1bHRzX21vdXNlb3ZlcihldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNlYXJjaF9yZXN1bHRzLm1vdXNlb3V0KGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuc2VhcmNoX3Jlc3VsdHNfbW91c2VvdXQoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLmJpbmQoXCJsaXN6dDp1cGRhdGVkXCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMucmVzdWx0c191cGRhdGVfZmllbGQoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLmJpbmQoXCJsaXN6dDphY3RpdmF0ZVwiLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmFjdGl2YXRlX2ZpZWxkKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS5iaW5kKFwibGlzenQ6b3BlblwiLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmNvbnRhaW5lcl9tb3VzZWRvd24oZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQuYmx1cihmdW5jdGlvbihldnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmlucHV0X2JsdXIoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQua2V5dXAoZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5rZXl1cF9jaGVja2VyKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLmtleWRvd24oZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5rZXlkb3duX2NoZWNrZXIoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQuZm9jdXMoZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5pbnB1dF9mb2N1cyhldnQpO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hfY2hvaWNlcy5jbGljayhmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuY2hvaWNlc19jbGljayhldnQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5jbGljayhmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICByZXR1cm4gZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNlYXJjaF9maWVsZF9kaXNhYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pc19kaXNhYmxlZCA9IHRoaXMuZm9ybV9maWVsZF9qcVswXS5kaXNhYmxlZDtcbiAgICAgIGlmICh0aGlzLmlzX2Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKCdjaHpuLWRpc2FibGVkJyk7XG4gICAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkWzBdLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZF9pdGVtLnVuYmluZChcImZvY3VzXCIsIHRoaXMuYWN0aXZhdGVfYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZV9maWVsZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2xhc3MoJ2Noem4tZGlzYWJsZWQnKTtcbiAgICAgICAgdGhpcy5zZWFyY2hfZmllbGRbMF0uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRfaXRlbS5iaW5kKFwiZm9jdXNcIiwgdGhpcy5hY3RpdmF0ZV9hY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY29udGFpbmVyX21vdXNlZG93biA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIHRhcmdldF9jbG9zZWxpbms7XG4gICAgICBpZiAoIXRoaXMuaXNfZGlzYWJsZWQpIHtcbiAgICAgICAgdGFyZ2V0X2Nsb3NlbGluayA9IGV2dCAhPSBudWxsID8gKCQoZXZ0LnRhcmdldCkpLmhhc0NsYXNzKFwic2VhcmNoLWNob2ljZS1jbG9zZVwiKSA6IGZhbHNlO1xuICAgICAgICBpZiAoZXZ0ICYmIGV2dC50eXBlID09PSBcIm1vdXNlZG93blwiICYmICF0aGlzLnJlc3VsdHNfc2hvd2luZykge1xuICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucGVuZGluZ19kZXN0cm95X2NsaWNrICYmICF0YXJnZXRfY2xvc2VsaW5rKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZV9maWVsZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZWFyY2hfZmllbGQudmFsKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJChkb2N1bWVudCkuY2xpY2sodGhpcy5jbGlja190ZXN0X2FjdGlvbik7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdHNfc2hvdygpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNfbXVsdGlwbGUgJiYgZXZ0ICYmICgoJChldnQudGFyZ2V0KVswXSA9PT0gdGhpcy5zZWxlY3RlZF9pdGVtWzBdKSB8fCAkKGV2dC50YXJnZXQpLnBhcmVudHMoXCJhLmNoem4tc2luZ2xlXCIpLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzX3RvZ2dsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmF0ZV9maWVsZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBlbmRpbmdfZGVzdHJveV9jbGljayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY29udGFpbmVyX21vdXNldXAgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGlmIChldnQudGFyZ2V0Lm5vZGVOYW1lID09PSBcIkFCQlJcIiAmJiAhdGhpcy5pc19kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3Jlc2V0KGV2dCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuYmx1cl90ZXN0ID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBpZiAoIXRoaXMuYWN0aXZlX2ZpZWxkICYmIHRoaXMuY29udGFpbmVyLmhhc0NsYXNzKFwiY2h6bi1jb250YWluZXItYWN0aXZlXCIpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlX2ZpZWxkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY2xvc2VfZmllbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgICQoZG9jdW1lbnQpLnVuYmluZChcImNsaWNrXCIsIHRoaXMuY2xpY2tfdGVzdF9hY3Rpb24pO1xuICAgICAgaWYgKCF0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfaXRlbS5hdHRyKFwidGFiaW5kZXhcIiwgdGhpcy5zZWFyY2hfZmllbGQuYXR0cihcInRhYmluZGV4XCIpKTtcbiAgICAgICAgdGhpcy5zZWFyY2hfZmllbGQuYXR0cihcInRhYmluZGV4XCIsIC0xKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWN0aXZlX2ZpZWxkID0gZmFsc2U7XG4gICAgICB0aGlzLnJlc3VsdHNfaGlkZSgpO1xuICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2xhc3MoXCJjaHpuLWNvbnRhaW5lci1hY3RpdmVcIik7XG4gICAgICB0aGlzLndpbm5vd19yZXN1bHRzX2NsZWFyKCk7XG4gICAgICB0aGlzLmNsZWFyX2JhY2tzdHJva2UoKTtcbiAgICAgIHRoaXMuc2hvd19zZWFyY2hfZmllbGRfZGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoX2ZpZWxkX3NjYWxlKCk7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuYWN0aXZhdGVfZmllbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKFwiY2h6bi1jb250YWluZXItYWN0aXZlXCIpO1xuICAgICAgdGhpcy5hY3RpdmVfZmllbGQgPSB0cnVlO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQudmFsKHRoaXMuc2VhcmNoX2ZpZWxkLnZhbCgpKTtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZC5mb2N1cygpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnRlc3RfYWN0aXZlX2NsaWNrID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBpZiAoJChldnQudGFyZ2V0KS5wYXJlbnRzKCcjJyArIHRoaXMuY29udGFpbmVyX2lkKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlX2ZpZWxkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlX2ZpZWxkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0c19idWlsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvbnRlbnQsIGRhdGEsIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgdGhpcy5wYXJzaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVzdWx0c19kYXRhID0gcm9vdC5TZWxlY3RQYXJzZXIuc2VsZWN0X3RvX2FycmF5KHRoaXMuZm9ybV9maWVsZCk7XG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSAmJiB0aGlzLmNob2ljZXMgPiAwKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoX2Nob2ljZXMuZmluZChcImxpLnNlYXJjaC1jaG9pY2VcIikucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuY2hvaWNlcyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfaXRlbS5hZGRDbGFzcyhcImNoem4tZGVmYXVsdFwiKS5maW5kKFwic3BhblwiKS50ZXh0KHRoaXMuZGVmYXVsdF90ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZV9zZWFyY2ggfHwgdGhpcy5mb3JtX2ZpZWxkLm9wdGlvbnMubGVuZ3RoIDw9IHRoaXMuZGlzYWJsZV9zZWFyY2hfdGhyZXNob2xkKSB7XG4gICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoXCJjaHpuLWNvbnRhaW5lci1zaW5nbGUtbm9zZWFyY2hcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2xhc3MoXCJjaHpuLWNvbnRhaW5lci1zaW5nbGUtbm9zZWFyY2hcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnRlbnQgPSAnJztcbiAgICAgIF9yZWYgPSB0aGlzLnJlc3VsdHNfZGF0YTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBkYXRhID0gX3JlZltfaV07XG4gICAgICAgIGlmIChkYXRhLmdyb3VwKSB7XG4gICAgICAgICAgY29udGVudCArPSB0aGlzLnJlc3VsdF9hZGRfZ3JvdXAoZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWRhdGEuZW1wdHkpIHtcbiAgICAgICAgICBjb250ZW50ICs9IHRoaXMucmVzdWx0X2FkZF9vcHRpb24oZGF0YSk7XG4gICAgICAgICAgaWYgKGRhdGEuc2VsZWN0ZWQgJiYgdGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICAgICAgdGhpcy5jaG9pY2VfYnVpbGQoZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnNlbGVjdGVkICYmICF0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkX2l0ZW0ucmVtb3ZlQ2xhc3MoXCJjaHpuLWRlZmF1bHRcIikuZmluZChcInNwYW5cIikudGV4dChkYXRhLnRleHQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dfc2luZ2xlX2Rlc2VsZWN0KSB7XG4gICAgICAgICAgICAgIHRoaXMuc2luZ2xlX2Rlc2VsZWN0X2NvbnRyb2xfYnVpbGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkX2Rpc2FibGVkKCk7XG4gICAgICB0aGlzLnNob3dfc2VhcmNoX2ZpZWxkX2RlZmF1bHQoKTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkX3NjYWxlKCk7XG4gICAgICB0aGlzLnNlYXJjaF9yZXN1bHRzLmh0bWwoY29udGVudCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzaW5nID0gZmFsc2U7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0X2FkZF9ncm91cCA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICBpZiAoIWdyb3VwLmRpc2FibGVkKSB7XG4gICAgICAgIGdyb3VwLmRvbV9pZCA9IHRoaXMuY29udGFpbmVyX2lkICsgXCJfZ19cIiArIGdyb3VwLmFycmF5X2luZGV4O1xuICAgICAgICByZXR1cm4gJzxsaSBpZD1cIicgKyBncm91cC5kb21faWQgKyAnXCIgY2xhc3M9XCJncm91cC1yZXN1bHRcIj4nICsgJChcIjxkaXYgLz5cIikudGV4dChncm91cC5sYWJlbCkuaHRtbCgpICsgJzwvbGk+JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9kb19oaWdobGlnaHQgPSBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIGhpZ2hfYm90dG9tLCBoaWdoX3RvcCwgbWF4SGVpZ2h0LCB2aXNpYmxlX2JvdHRvbSwgdmlzaWJsZV90b3A7XG4gICAgICBpZiAoZWwubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICB0aGlzLnJlc3VsdF9oaWdobGlnaHQgPSBlbDtcbiAgICAgICAgdGhpcy5yZXN1bHRfaGlnaGxpZ2h0LmFkZENsYXNzKFwiaGlnaGxpZ2h0ZWRcIik7XG4gICAgICAgIG1heEhlaWdodCA9IHBhcnNlSW50KHRoaXMuc2VhcmNoX3Jlc3VsdHMuY3NzKFwibWF4SGVpZ2h0XCIpLCAxMCk7XG4gICAgICAgIHZpc2libGVfdG9wID0gdGhpcy5zZWFyY2hfcmVzdWx0cy5zY3JvbGxUb3AoKTtcbiAgICAgICAgdmlzaWJsZV9ib3R0b20gPSBtYXhIZWlnaHQgKyB2aXNpYmxlX3RvcDtcbiAgICAgICAgaGlnaF90b3AgPSB0aGlzLnJlc3VsdF9oaWdobGlnaHQucG9zaXRpb24oKS50b3AgKyB0aGlzLnNlYXJjaF9yZXN1bHRzLnNjcm9sbFRvcCgpO1xuICAgICAgICBoaWdoX2JvdHRvbSA9IGhpZ2hfdG9wICsgdGhpcy5yZXN1bHRfaGlnaGxpZ2h0Lm91dGVySGVpZ2h0KCk7XG4gICAgICAgIGlmIChoaWdoX2JvdHRvbSA+PSB2aXNpYmxlX2JvdHRvbSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzLnNjcm9sbFRvcCgoaGlnaF9ib3R0b20gLSBtYXhIZWlnaHQpID4gMCA/IGhpZ2hfYm90dG9tIC0gbWF4SGVpZ2h0IDogMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGlnaF90b3AgPCB2aXNpYmxlX3RvcCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzLnNjcm9sbFRvcChoaWdoX3RvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZXN1bHRfY2xlYXJfaGlnaGxpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5yZXN1bHRfaGlnaGxpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVzdWx0X2hpZ2hsaWdodC5yZW1vdmVDbGFzcyhcImhpZ2hsaWdodGVkXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0X2hpZ2hsaWdodCA9IG51bGw7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0c19zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGRfdG9wLCBkZF93aWR0aCwgcmlzZTtcbiAgICAgIGlmICghdGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkX2l0ZW0uYWRkQ2xhc3MoXCJjaHpuLXNpbmdsZS13aXRoLWRyb3BcIik7XG4gICAgICAgIGlmICh0aGlzLnJlc3VsdF9zaW5nbGVfc2VsZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLnJlc3VsdF9kb19oaWdobGlnaHQodGhpcy5yZXN1bHRfc2luZ2xlX3NlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGRfd2lkdGggPSB0aGlzLmNvbnRhaW5lci53aWR0aCgpIC0gZ2V0X3NpZGVfYm9yZGVyX3BhZGRpbmcodGhpcy5kcm9wZG93bik7XG4gICAgICAvKlxuICAgICAgICAgICAgQ0FMTCBDVVNUT00gRlVOQ1RJT046IHJpc2VfdXBcbiAgICAgICAgICAgICAgIyBpZiByaXNlLXVwIHRydWUsIHJldmVyc2UgZHJvcC11cCBkaXJlY3Rpb25cbiAgICAgICovXG5cbiAgICAgIHJpc2UgPSB0aGlzLnJpc2VfdXAodGhpcy5jb250YWluZXIsIHRoaXMuZHJvcGRvd24pO1xuICAgICAgZGRfdG9wID0gcmlzZSA/IC10aGlzLmNvbnRhaW5lci5maW5kKCcuY2h6bi1kcm9wJykuaGVpZ2h0KCkgOiB0aGlzLmlzX211bHRpcGxlID8gdGhpcy5jb250YWluZXIuaGVpZ2h0KCkgOiB0aGlzLmNvbnRhaW5lci5oZWlnaHQoKSAtIDE7XG4gICAgICB0aGlzLmZvcm1fZmllbGRfanEudHJpZ2dlcihcImxpc3p0OnNob3dpbmdfZHJvcGRvd25cIiwge1xuICAgICAgICBjaG9zZW46IHRoaXNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kcm9wZG93bi5jc3Moe1xuICAgICAgICBcInRvcFwiOiBkZF90b3AgKyBcInB4XCIsXG4gICAgICAgIFwibGVmdFwiOiAwXG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVzdWx0c19zaG93aW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLmNzcygnd2lkdGgnLCAoZGRfd2lkdGggLSBnZXRfc2lkZV9ib3JkZXJfcGFkZGluZyh0aGlzLnNlYXJjaF9jb250YWluZXIpIC0gZ2V0X3NpZGVfYm9yZGVyX3BhZGRpbmcodGhpcy5zZWFyY2hfZmllbGQpKSArICdweCcpO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQuZm9jdXMoKTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLnZhbCh0aGlzLnNlYXJjaF9maWVsZC52YWwoKSk7XG4gICAgICByZXR1cm4gdGhpcy53aW5ub3dfcmVzdWx0cygpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdHNfaGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfaXRlbS5yZW1vdmVDbGFzcyhcImNoem4tc2luZ2xlLXdpdGgtZHJvcFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLnRyaWdnZXIoXCJsaXN6dDpoaWRpbmdfZHJvcGRvd25cIiwge1xuICAgICAgICBjaG9zZW46IHRoaXNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kcm9wZG93bi5jc3Moe1xuICAgICAgICBcImxlZnRcIjogXCItOTAwMHB4XCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19zaG93aW5nID0gZmFsc2U7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2V0X3RhYl9pbmRleCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgdGk7XG4gICAgICBpZiAodGhpcy5mb3JtX2ZpZWxkX2pxLmF0dHIoXCJ0YWJpbmRleFwiKSkge1xuICAgICAgICB0aSA9IHRoaXMuZm9ybV9maWVsZF9qcS5hdHRyKFwidGFiaW5kZXhcIik7XG4gICAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS5hdHRyKFwidGFiaW5kZXhcIiwgLTEpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hfZmllbGQuYXR0cihcInRhYmluZGV4XCIsIHRpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5zaG93X3NlYXJjaF9maWVsZF9kZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSAmJiB0aGlzLmNob2ljZXMgPCAxICYmICF0aGlzLmFjdGl2ZV9maWVsZCkge1xuICAgICAgICB0aGlzLnNlYXJjaF9maWVsZC52YWwodGhpcy5kZWZhdWx0X3RleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hfZmllbGQuYWRkQ2xhc3MoXCJkZWZhdWx0XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWFyY2hfZmllbGQudmFsKFwiXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hfZmllbGQucmVtb3ZlQ2xhc3MoXCJkZWZhdWx0XCIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNlYXJjaF9yZXN1bHRzX21vdXNldXAgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciB0YXJnZXQ7XG4gICAgICB0YXJnZXQgPSAkKGV2dC50YXJnZXQpLmhhc0NsYXNzKFwiYWN0aXZlLXJlc3VsdFwiKSA/ICQoZXZ0LnRhcmdldCkgOiAkKGV2dC50YXJnZXQpLnBhcmVudHMoXCIuYWN0aXZlLXJlc3VsdFwiKS5maXJzdCgpO1xuICAgICAgaWYgKHRhcmdldC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5yZXN1bHRfaGlnaGxpZ2h0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnJlc3VsdF9zZWxlY3QoZXZ0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoX2ZpZWxkLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2VhcmNoX3Jlc3VsdHNfbW91c2VvdmVyID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgdGFyZ2V0O1xuICAgICAgdGFyZ2V0ID0gJChldnQudGFyZ2V0KS5oYXNDbGFzcyhcImFjdGl2ZS1yZXN1bHRcIikgPyAkKGV2dC50YXJnZXQpIDogJChldnQudGFyZ2V0KS5wYXJlbnRzKFwiLmFjdGl2ZS1yZXN1bHRcIikuZmlyc3QoKTtcbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0X2RvX2hpZ2hsaWdodCh0YXJnZXQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNlYXJjaF9yZXN1bHRzX21vdXNlb3V0ID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBpZiAoJChldnQudGFyZ2V0KS5oYXNDbGFzcyhcImFjdGl2ZS1yZXN1bHRcIiB8fCAkKGV2dC50YXJnZXQpLnBhcmVudHMoJy5hY3RpdmUtcmVzdWx0JykuZmlyc3QoKSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmNob2ljZXNfY2xpY2sgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKHRoaXMuYWN0aXZlX2ZpZWxkICYmICEoJChldnQudGFyZ2V0KS5oYXNDbGFzcyhcInNlYXJjaC1jaG9pY2VcIiB8fCAkKGV2dC50YXJnZXQpLnBhcmVudHMoJy5zZWFyY2gtY2hvaWNlJykuZmlyc3QpKSAmJiAhdGhpcy5yZXN1bHRzX3Nob3dpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19zaG93KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY2hvaWNlX2J1aWxkID0gZnVuY3Rpb24oaXRlbSkge1xuICAgICAgdmFyIGNob2ljZV9pZCwgaHRtbCwgbGluayxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgY2hvaWNlX2lkID0gdGhpcy5jb250YWluZXJfaWQgKyBcIl9jX1wiICsgaXRlbS5hcnJheV9pbmRleDtcbiAgICAgIHRoaXMuY2hvaWNlcyArPSAxO1xuICAgICAgaWYgKGl0ZW0uZGlzYWJsZWQpIHtcbiAgICAgICAgaHRtbCA9ICc8bGkgY2xhc3M9XCJzZWFyY2gtY2hvaWNlIHNlYXJjaC1jaG9pY2UtZGlzYWJsZWRcIiBpZD1cIicgKyBjaG9pY2VfaWQgKyAnXCI+PHNwYW4+JyArIGl0ZW0uaHRtbCArICc8L3NwYW4+PC9saT4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHRtbCA9ICc8bGkgY2xhc3M9XCJzZWFyY2gtY2hvaWNlXCIgaWQ9XCInICsgY2hvaWNlX2lkICsgJ1wiPjxzcGFuPicgKyBpdGVtLmh0bWwgKyAnPC9zcGFuPjxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBjbGFzcz1cInNlYXJjaC1jaG9pY2UtY2xvc2VcIiByZWw9XCInICsgaXRlbS5hcnJheV9pbmRleCArICdcIj48L2E+PC9saT4nO1xuICAgICAgfVxuICAgICAgdGhpcy5zZWFyY2hfY29udGFpbmVyLmJlZm9yZShodG1sKTtcbiAgICAgIGxpbmsgPSAkKCcjJyArIGNob2ljZV9pZCkuZmluZChcImFcIikuZmlyc3QoKTtcbiAgICAgIHJldHVybiBsaW5rLmNsaWNrKGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuY2hvaWNlX2Rlc3Ryb3lfbGlua19jbGljayhldnQpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY2hvaWNlX2Rlc3Ryb3lfbGlua19jbGljayA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIXRoaXMuaXNfZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nX2Rlc3Ryb3lfY2xpY2sgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5jaG9pY2VfZGVzdHJveSgkKGV2dC50YXJnZXQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBldnQuc3RvcFByb3BhZ2F0aW9uO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmNob2ljZV9kZXN0cm95ID0gZnVuY3Rpb24obGluaykge1xuICAgICAgaWYgKHRoaXMucmVzdWx0X2Rlc2VsZWN0KGxpbmsuYXR0cihcInJlbFwiKSkpIHtcbiAgICAgICAgdGhpcy5jaG9pY2VzIC09IDE7XG4gICAgICAgIHRoaXMuc2hvd19zZWFyY2hfZmllbGRfZGVmYXVsdCgpO1xuICAgICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSAmJiB0aGlzLmNob2ljZXMgPiAwICYmIHRoaXMuc2VhcmNoX2ZpZWxkLnZhbCgpLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICB0aGlzLnJlc3VsdHNfaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5rLnBhcmVudHMoJ2xpJykuZmlyc3QoKS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZXN1bHRzX3Jlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmZvcm1fZmllbGQub3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICB0aGlzLnNlbGVjdGVkX2l0ZW0uZmluZChcInNwYW5cIikudGV4dCh0aGlzLmRlZmF1bHRfdGV4dCk7XG4gICAgICBpZiAoIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZF9pdGVtLmFkZENsYXNzKFwiY2h6bi1kZWZhdWx0XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zaG93X3NlYXJjaF9maWVsZF9kZWZhdWx0KCk7XG4gICAgICB0aGlzLnJlc3VsdHNfcmVzZXRfY2xlYW51cCgpO1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLnRyaWdnZXIoXCJjaGFuZ2VcIik7XG4gICAgICBpZiAodGhpcy5hY3RpdmVfZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19oaWRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0c19yZXNldF9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmN1cnJlbnRfdmFsdWUgPSB0aGlzLmZvcm1fZmllbGRfanEudmFsKCk7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZF9pdGVtLmZpbmQoXCJhYmJyXCIpLnJlbW92ZSgpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9zZWxlY3QgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBoaWdoLCBoaWdoX2lkLCBpdGVtLCBwb3NpdGlvbjtcbiAgICAgIGlmICh0aGlzLnJlc3VsdF9oaWdobGlnaHQpIHtcbiAgICAgICAgaGlnaCA9IHRoaXMucmVzdWx0X2hpZ2hsaWdodDtcbiAgICAgICAgaGlnaF9pZCA9IGhpZ2guYXR0cihcImlkXCIpO1xuICAgICAgICB0aGlzLnJlc3VsdF9jbGVhcl9oaWdobGlnaHQoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgICB0aGlzLnJlc3VsdF9kZWFjdGl2YXRlKGhpZ2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2VhcmNoX3Jlc3VsdHMuZmluZChcIi5yZXN1bHQtc2VsZWN0ZWRcIikucmVtb3ZlQ2xhc3MoXCJyZXN1bHQtc2VsZWN0ZWRcIik7XG4gICAgICAgICAgdGhpcy5yZXN1bHRfc2luZ2xlX3NlbGVjdGVkID0gaGlnaDtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkX2l0ZW0ucmVtb3ZlQ2xhc3MoXCJjaHpuLWRlZmF1bHRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaGlnaC5hZGRDbGFzcyhcInJlc3VsdC1zZWxlY3RlZFwiKTtcbiAgICAgICAgcG9zaXRpb24gPSBoaWdoX2lkLnN1YnN0cihoaWdoX2lkLmxhc3RJbmRleE9mKFwiX1wiKSArIDEpO1xuICAgICAgICBpdGVtID0gdGhpcy5yZXN1bHRzX2RhdGFbcG9zaXRpb25dO1xuICAgICAgICBpdGVtLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mb3JtX2ZpZWxkLm9wdGlvbnNbaXRlbS5vcHRpb25zX2luZGV4XS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgICAgdGhpcy5jaG9pY2VfYnVpbGQoaXRlbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZF9pdGVtLmZpbmQoXCJzcGFuXCIpLmZpcnN0KCkudGV4dChpdGVtLnRleHQpO1xuICAgICAgICAgIGlmICh0aGlzLmFsbG93X3NpbmdsZV9kZXNlbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5zaW5nbGVfZGVzZWxlY3RfY29udHJvbF9idWlsZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIShldnQubWV0YUtleSAmJiB0aGlzLmlzX211bHRpcGxlKSkge1xuICAgICAgICAgIHRoaXMucmVzdWx0c19oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWFyY2hfZmllbGQudmFsKFwiXCIpO1xuICAgICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSB8fCB0aGlzLmZvcm1fZmllbGRfanEudmFsKCkgIT09IHRoaXMuY3VycmVudF92YWx1ZSkge1xuICAgICAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hhbmdlXCIsIHtcbiAgICAgICAgICAgICdzZWxlY3RlZCc6IHRoaXMuZm9ybV9maWVsZC5vcHRpb25zW2l0ZW0ub3B0aW9uc19pbmRleF0udmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRfdmFsdWUgPSB0aGlzLmZvcm1fZmllbGRfanEudmFsKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZF9zY2FsZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9hY3RpdmF0ZSA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICByZXR1cm4gZWwuYWRkQ2xhc3MoXCJhY3RpdmUtcmVzdWx0XCIpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9kZWFjdGl2YXRlID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiBlbC5yZW1vdmVDbGFzcyhcImFjdGl2ZS1yZXN1bHRcIik7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0X2Rlc2VsZWN0ID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgICB2YXIgcmVzdWx0LCByZXN1bHRfZGF0YTtcbiAgICAgIHJlc3VsdF9kYXRhID0gdGhpcy5yZXN1bHRzX2RhdGFbcG9zXTtcbiAgICAgIGlmICghdGhpcy5mb3JtX2ZpZWxkLm9wdGlvbnNbcmVzdWx0X2RhdGEub3B0aW9uc19pbmRleF0uZGlzYWJsZWQpIHtcbiAgICAgICAgcmVzdWx0X2RhdGEuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mb3JtX2ZpZWxkLm9wdGlvbnNbcmVzdWx0X2RhdGEub3B0aW9uc19pbmRleF0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmVzdWx0ID0gJChcIiNcIiArIHRoaXMuY29udGFpbmVyX2lkICsgXCJfb19cIiArIHBvcyk7XG4gICAgICAgIHJlc3VsdC5yZW1vdmVDbGFzcyhcInJlc3VsdC1zZWxlY3RlZFwiKS5hZGRDbGFzcyhcImFjdGl2ZS1yZXN1bHRcIikuc2hvdygpO1xuICAgICAgICB0aGlzLnJlc3VsdF9jbGVhcl9oaWdobGlnaHQoKTtcbiAgICAgICAgdGhpcy53aW5ub3dfcmVzdWx0cygpO1xuICAgICAgICB0aGlzLmZvcm1fZmllbGRfanEudHJpZ2dlcihcImNoYW5nZVwiLCB7XG4gICAgICAgICAgZGVzZWxlY3RlZDogdGhpcy5mb3JtX2ZpZWxkLm9wdGlvbnNbcmVzdWx0X2RhdGEub3B0aW9uc19pbmRleF0udmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkX3NjYWxlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNpbmdsZV9kZXNlbGVjdF9jb250cm9sX2J1aWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5hbGxvd19zaW5nbGVfZGVzZWxlY3QgJiYgdGhpcy5zZWxlY3RlZF9pdGVtLmZpbmQoXCJhYmJyXCIpLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRfaXRlbS5maW5kKFwic3BhblwiKS5maXJzdCgpLmFmdGVyKFwiPGFiYnIgY2xhc3M9XFxcInNlYXJjaC1jaG9pY2UtY2xvc2VcXFwiPjwvYWJicj5cIik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUud2lubm93X3Jlc3VsdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBmb3VuZCwgb3B0aW9uLCBwYXJ0LCBwYXJ0cywgcmVnZXgsIHJlZ2V4QW5jaG9yLCByZXN1bHQsIHJlc3VsdF9pZCwgcmVzdWx0cywgc2VhcmNoVGV4dCwgc3RhcnRwb3MsIHRleHQsIHpyZWdleCwgX2ksIF9qLCBfbGVuLCBfbGVuMSwgX3JlZjtcbiAgICAgIHRoaXMubm9fcmVzdWx0c19jbGVhcigpO1xuICAgICAgcmVzdWx0cyA9IDA7XG4gICAgICBzZWFyY2hUZXh0ID0gdGhpcy5zZWFyY2hfZmllbGQudmFsKCkgPT09IHRoaXMuZGVmYXVsdF90ZXh0ID8gXCJcIiA6ICQoJzxkaXYvPicpLnRleHQoJC50cmltKHRoaXMuc2VhcmNoX2ZpZWxkLnZhbCgpKSkuaHRtbCgpO1xuICAgICAgcmVnZXhBbmNob3IgPSB0aGlzLnNlYXJjaF9jb250YWlucyA/IFwiXCIgOiBcIl5cIjtcbiAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleEFuY2hvciArIHNlYXJjaFRleHQucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csIFwiXFxcXCQmXCIpLCAnaScpO1xuICAgICAgenJlZ2V4ID0gbmV3IFJlZ0V4cChzZWFyY2hUZXh0LnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCBcIlxcXFwkJlwiKSwgJ2knKTtcbiAgICAgIF9yZWYgPSB0aGlzLnJlc3VsdHNfZGF0YTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBvcHRpb24gPSBfcmVmW19pXTtcbiAgICAgICAgaWYgKCFvcHRpb24uZGlzYWJsZWQgJiYgIW9wdGlvbi5lbXB0eSkge1xuICAgICAgICAgIGlmIChvcHRpb24uZ3JvdXApIHtcbiAgICAgICAgICAgICQoJyMnICsgb3B0aW9uLmRvbV9pZCkuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCEodGhpcy5pc19tdWx0aXBsZSAmJiBvcHRpb24uc2VsZWN0ZWQpKSB7XG4gICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmVzdWx0X2lkID0gb3B0aW9uLmRvbV9pZDtcbiAgICAgICAgICAgIHJlc3VsdCA9ICQoXCIjXCIgKyByZXN1bHRfaWQpO1xuICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3Qob3B0aW9uLmh0bWwpKSB7XG4gICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVzdWx0cyArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb24uaHRtbC5pbmRleE9mKFwiIFwiKSA+PSAwIHx8IG9wdGlvbi5odG1sLmluZGV4T2YoXCJbXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgIHBhcnRzID0gb3B0aW9uLmh0bWwucmVwbGFjZSgvXFxbfFxcXS9nLCBcIlwiKS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBwYXJ0cy5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgICAgICAgIHBhcnQgPSBwYXJ0c1tfal07XG4gICAgICAgICAgICAgICAgICBpZiAocmVnZXgudGVzdChwYXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgKz0gMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICBpZiAoc2VhcmNoVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzdGFydHBvcyA9IG9wdGlvbi5odG1sLnNlYXJjaCh6cmVnZXgpO1xuICAgICAgICAgICAgICAgIHRleHQgPSBvcHRpb24uaHRtbC5zdWJzdHIoMCwgc3RhcnRwb3MgKyBzZWFyY2hUZXh0Lmxlbmd0aCkgKyAnPC9lbT4nICsgb3B0aW9uLmh0bWwuc3Vic3RyKHN0YXJ0cG9zICsgc2VhcmNoVGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cigwLCBzdGFydHBvcykgKyAnPGVtPicgKyB0ZXh0LnN1YnN0cihzdGFydHBvcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IG9wdGlvbi5odG1sO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdC5odG1sKHRleHQpO1xuICAgICAgICAgICAgICB0aGlzLnJlc3VsdF9hY3RpdmF0ZShyZXN1bHQpO1xuICAgICAgICAgICAgICBpZiAob3B0aW9uLmdyb3VwX2FycmF5X2luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAkKFwiI1wiICsgdGhpcy5yZXN1bHRzX2RhdGFbb3B0aW9uLmdyb3VwX2FycmF5X2luZGV4XS5kb21faWQpLmNzcygnZGlzcGxheScsICdsaXN0LWl0ZW0nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0X2hpZ2hsaWdodCAmJiByZXN1bHRfaWQgPT09IHRoaXMucmVzdWx0X2hpZ2hsaWdodC5hdHRyKCdpZCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRfY2xlYXJfaGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5yZXN1bHRfZGVhY3RpdmF0ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdHMgPCAxICYmIHNlYXJjaFRleHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vX3Jlc3VsdHMoc2VhcmNoVGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy53aW5ub3dfcmVzdWx0c19zZXRfaGlnaGxpZ2h0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUud2lubm93X3Jlc3VsdHNfY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaSwgbGlzLCBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZC52YWwoXCJcIik7XG4gICAgICBsaXMgPSB0aGlzLnNlYXJjaF9yZXN1bHRzLmZpbmQoXCJsaVwiKTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGxpcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBsaSA9IGxpc1tfaV07XG4gICAgICAgIGxpID0gJChsaSk7XG4gICAgICAgIGlmIChsaS5oYXNDbGFzcyhcImdyb3VwLXJlc3VsdFwiKSkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2gobGkuY3NzKCdkaXNwbGF5JywgJ2F1dG8nKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNfbXVsdGlwbGUgfHwgIWxpLmhhc0NsYXNzKFwicmVzdWx0LXNlbGVjdGVkXCIpKSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLnJlc3VsdF9hY3RpdmF0ZShsaSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLndpbm5vd19yZXN1bHRzX3NldF9oaWdobGlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkb19oaWdoLCBzZWxlY3RlZF9yZXN1bHRzO1xuICAgICAgaWYgKCF0aGlzLnJlc3VsdF9oaWdobGlnaHQpIHtcbiAgICAgICAgc2VsZWN0ZWRfcmVzdWx0cyA9ICF0aGlzLmlzX211bHRpcGxlID8gdGhpcy5zZWFyY2hfcmVzdWx0cy5maW5kKFwiLnJlc3VsdC1zZWxlY3RlZC5hY3RpdmUtcmVzdWx0XCIpIDogW107XG4gICAgICAgIGRvX2hpZ2ggPSBzZWxlY3RlZF9yZXN1bHRzLmxlbmd0aCA/IHNlbGVjdGVkX3Jlc3VsdHMuZmlyc3QoKSA6IHRoaXMuc2VhcmNoX3Jlc3VsdHMuZmluZChcIi5hY3RpdmUtcmVzdWx0XCIpLmZpcnN0KCk7XG4gICAgICAgIGlmIChkb19oaWdoICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRfZG9faGlnaGxpZ2h0KGRvX2hpZ2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUubm9fcmVzdWx0cyA9IGZ1bmN0aW9uKHRlcm1zKSB7XG4gICAgICB2YXIgbm9fcmVzdWx0c19odG1sO1xuICAgICAgbm9fcmVzdWx0c19odG1sID0gJCgnPGxpIGNsYXNzPVwibm8tcmVzdWx0c1wiPicgKyB0aGlzLnJlc3VsdHNfbm9uZV9mb3VuZCArICcgXCI8c3Bhbj48L3NwYW4+XCI8L2xpPicpO1xuICAgICAgbm9fcmVzdWx0c19odG1sLmZpbmQoXCJzcGFuXCIpLmZpcnN0KCkuaHRtbCh0ZXJtcyk7XG4gICAgICByZXR1cm4gdGhpcy5zZWFyY2hfcmVzdWx0cy5hcHBlbmQobm9fcmVzdWx0c19odG1sKTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5ub19yZXN1bHRzX2NsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWFyY2hfcmVzdWx0cy5maW5kKFwiLm5vLXJlc3VsdHNcIikucmVtb3ZlKCk7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUua2V5ZG93bl9hcnJvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGZpcnN0X2FjdGl2ZSwgbmV4dF9zaWI7XG4gICAgICBpZiAoIXRoaXMucmVzdWx0X2hpZ2hsaWdodCkge1xuICAgICAgICBmaXJzdF9hY3RpdmUgPSB0aGlzLnNlYXJjaF9yZXN1bHRzLmZpbmQoXCJsaS5hY3RpdmUtcmVzdWx0XCIpLmZpcnN0KCk7XG4gICAgICAgIGlmIChmaXJzdF9hY3RpdmUpIHtcbiAgICAgICAgICB0aGlzLnJlc3VsdF9kb19oaWdobGlnaHQoJChmaXJzdF9hY3RpdmUpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLnJlc3VsdHNfc2hvd2luZykge1xuICAgICAgICBuZXh0X3NpYiA9IHRoaXMucmVzdWx0X2hpZ2hsaWdodC5uZXh0QWxsKFwibGkuYWN0aXZlLXJlc3VsdFwiKS5maXJzdCgpO1xuICAgICAgICBpZiAobmV4dF9zaWIpIHtcbiAgICAgICAgICB0aGlzLnJlc3VsdF9kb19oaWdobGlnaHQobmV4dF9zaWIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucmVzdWx0c19zaG93aW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHNfc2hvdygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmtleXVwX2Fycm93ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHJldl9zaWJzO1xuICAgICAgaWYgKCF0aGlzLnJlc3VsdHNfc2hvd2luZyAmJiAhdGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3Nob3coKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZXN1bHRfaGlnaGxpZ2h0KSB7XG4gICAgICAgIHByZXZfc2licyA9IHRoaXMucmVzdWx0X2hpZ2hsaWdodC5wcmV2QWxsKFwibGkuYWN0aXZlLXJlc3VsdFwiKTtcbiAgICAgICAgaWYgKHByZXZfc2licy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRfZG9faGlnaGxpZ2h0KHByZXZfc2licy5maXJzdCgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5jaG9pY2VzID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzX2hpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUua2V5ZG93bl9iYWNrc3Ryb2tlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmV4dF9hdmFpbGFibGVfZGVzdHJveTtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdfYmFja3N0cm9rZSkge1xuICAgICAgICB0aGlzLmNob2ljZV9kZXN0cm95KHRoaXMucGVuZGluZ19iYWNrc3Ryb2tlLmZpbmQoXCJhXCIpLmZpcnN0KCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jbGVhcl9iYWNrc3Ryb2tlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0X2F2YWlsYWJsZV9kZXN0cm95ID0gdGhpcy5zZWFyY2hfY29udGFpbmVyLnNpYmxpbmdzKFwibGkuc2VhcmNoLWNob2ljZVwiKS5sYXN0KCk7XG4gICAgICAgIGlmIChuZXh0X2F2YWlsYWJsZV9kZXN0cm95Lmxlbmd0aCAmJiAhbmV4dF9hdmFpbGFibGVfZGVzdHJveS5oYXNDbGFzcyhcInNlYXJjaC1jaG9pY2UtZGlzYWJsZWRcIikpIHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdfYmFja3N0cm9rZSA9IG5leHRfYXZhaWxhYmxlX2Rlc3Ryb3k7XG4gICAgICAgICAgaWYgKHRoaXMuc2luZ2xlX2JhY2tzdHJva2VfZGVsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlkb3duX2JhY2tzdHJva2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ19iYWNrc3Ryb2tlLmFkZENsYXNzKFwic2VhcmNoLWNob2ljZS1mb2N1c1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5jbGVhcl9iYWNrc3Ryb2tlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nX2JhY2tzdHJva2UpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nX2JhY2tzdHJva2UucmVtb3ZlQ2xhc3MoXCJzZWFyY2gtY2hvaWNlLWZvY3VzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ19iYWNrc3Ryb2tlID0gbnVsbDtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5rZXlkb3duX2NoZWNrZXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBzdHJva2UsIF9yZWY7XG4gICAgICBzdHJva2UgPSAoX3JlZiA9IGV2dC53aGljaCkgIT0gbnVsbCA/IF9yZWYgOiBldnQua2V5Q29kZTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkX3NjYWxlKCk7XG4gICAgICBpZiAoc3Ryb2tlICE9PSA4ICYmIHRoaXMucGVuZGluZ19iYWNrc3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuY2xlYXJfYmFja3N0cm9rZSgpO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChzdHJva2UpIHtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHRoaXMuYmFja3N0cm9rZV9sZW5ndGggPSB0aGlzLnNlYXJjaF9maWVsZC52YWwoKS5sZW5ndGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBpZiAodGhpcy5yZXN1bHRzX3Nob3dpbmcgJiYgIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0X3NlbGVjdChldnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm1vdXNlX29uX2NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMua2V5dXBfYXJyb3coKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICB0aGlzLmtleWRvd25fYXJyb3coKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5zZWFyY2hfZmllbGRfc2NhbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkZF90b3AsIGRpdiwgaCwgcmlzZSwgc3R5bGUsIHN0eWxlX2Jsb2NrLCBzdHlsZXMsIHcsIF9pLCBfbGVuO1xuICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgaCA9IDA7XG4gICAgICAgIHcgPSAwO1xuICAgICAgICBzdHlsZV9ibG9jayA9IFwicG9zaXRpb246YWJzb2x1dGU7IGxlZnQ6IC0xMDAwcHg7IHRvcDogLTEwMDBweDsgZGlzcGxheTpub25lO1wiO1xuICAgICAgICBzdHlsZXMgPSBbJ2ZvbnQtc2l6ZScsICdmb250LXN0eWxlJywgJ2ZvbnQtd2VpZ2h0JywgJ2ZvbnQtZmFtaWx5JywgJ2xpbmUtaGVpZ2h0JywgJ3RleHQtdHJhbnNmb3JtJywgJ2xldHRlci1zcGFjaW5nJ107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gc3R5bGVzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgc3R5bGUgPSBzdHlsZXNbX2ldO1xuICAgICAgICAgIHN0eWxlX2Jsb2NrICs9IHN0eWxlICsgXCI6XCIgKyB0aGlzLnNlYXJjaF9maWVsZC5jc3Moc3R5bGUpICsgXCI7XCI7XG4gICAgICAgIH1cbiAgICAgICAgZGl2ID0gJCgnPGRpdiAvPicsIHtcbiAgICAgICAgICAnc3R5bGUnOiBzdHlsZV9ibG9ja1xuICAgICAgICB9KTtcbiAgICAgICAgZGl2LnRleHQodGhpcy5zZWFyY2hfZmllbGQudmFsKCkpO1xuICAgICAgICAkKCdib2R5JykuYXBwZW5kKGRpdik7XG4gICAgICAgIHcgPSBkaXYud2lkdGgoKSArIDI1O1xuICAgICAgICBkaXYucmVtb3ZlKCk7XG4gICAgICAgIGlmICh3ID4gdGhpcy5mX3dpZHRoIC0gMTApIHtcbiAgICAgICAgICB3ID0gdGhpcy5mX3dpZHRoIC0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWFyY2hfZmllbGQuY3NzKHtcbiAgICAgICAgICAnd2lkdGgnOiB3ICsgJ3B4J1xuICAgICAgICB9KTtcbiAgICAgICAgLypcbiAgICAgICAgICAgICAgICBDQUxMIENVU1RPTSBGVU5DVElPTjogcmlzZV91cFxuICAgICAgICAgICAgICAgICAgIyBpZiByaXNlLXVwIHRydWUsIHJldmVyc2UgZHJvcC11cCBkaXJlY3Rpb25cbiAgICAgICAgKi9cblxuICAgICAgICByaXNlID0gdGhpcy5yaXNlX3VwKHRoaXMuY29udGFpbmVyLCB0aGlzLmRyb3Bkb3duKTtcbiAgICAgICAgZGRfdG9wID0gcmlzZSA/IC10aGlzLmNvbnRhaW5lci5maW5kKCcuY2h6bi1kcm9wJykuaGVpZ2h0KCkgOiB0aGlzLmNvbnRhaW5lci5oZWlnaHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd24uY3NzKHtcbiAgICAgICAgICBcInRvcFwiOiBkZF90b3AgKyBcInB4XCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuZ2VuZXJhdGVfcmFuZG9tX2lkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RyaW5nO1xuICAgICAgc3RyaW5nID0gXCJzZWxcIiArIHRoaXMuZ2VuZXJhdGVfcmFuZG9tX2NoYXIoKSArIHRoaXMuZ2VuZXJhdGVfcmFuZG9tX2NoYXIoKSArIHRoaXMuZ2VuZXJhdGVfcmFuZG9tX2NoYXIoKTtcbiAgICAgIHdoaWxlICgkKFwiI1wiICsgc3RyaW5nKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0cmluZyArPSB0aGlzLmdlbmVyYXRlX3JhbmRvbV9jaGFyKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAgU0lMVkVSU1RSSVBFIENVU1RPTSBGVU5DVElPTlxuICAgICAgICBSaXNlX3VwIGZ1bmN0aW9uIGhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgYSBkcm9wZG93biBleGNlZWRzIHRoZSBoZWlnaHQgb2YgdGhlIHdpbmRvd1xuICAgICAgICAgICMgQWRkcyBjbGFzcyBpZiB0cnVlLCByZXR1cm5zIHRydWVcbiAgICAgICAgICAjIFJlbW92ZXMgY2xhc3MgaWYgZmFsc2UsIHJldHVybnMgZmFsc2UgXG4gICAgICAgIFRoaXMgZmFjaWxpdGF0ZXMgdGhlIGJlaGF2aW91ciB3aGVyZSB0aGUgZHJvcC1kb3duIHdpbGwgZHJvcCB1cCBpZiB0aGVyZSBpcyBubyByb29tIFxuICAgICAgICB0byBkcm9wIGRvd25cbiAgICAqL1xuXG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJpc2VfdXAgPSBmdW5jdGlvbihjb250YWluZXIsIGRyb3Bkb3duKSB7XG4gICAgICB2YXIgZWxIZWlnaHQsIGVsUG9zLCBlbmRPZldpbmRvdywgdHJpZ2dlcjtcbiAgICAgIHRyaWdnZXIgPSBjb250YWluZXIuZmluZCgnYS5jaHpuLXNpbmdsZScpO1xuICAgICAgaWYgKHRyaWdnZXIubGVuZ3RoID4gMCkge1xuICAgICAgICBlbmRPZldpbmRvdyA9ICgkKHdpbmRvdykuaGVpZ2h0KCkgKyAkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSkgLSBjb250YWluZXIuZmluZCgnYScpLmlubmVySGVpZ2h0KCk7XG4gICAgICAgIGVsUG9zID0gdHJpZ2dlci5vZmZzZXQoKS50b3A7XG4gICAgICAgIGVsSGVpZ2h0ID0gZHJvcGRvd24uaW5uZXJIZWlnaHQoKTtcbiAgICAgICAgaWYgKGVsUG9zICsgZWxIZWlnaHQgPiBlbmRPZldpbmRvdyAmJiBlbFBvcyAtIGVsSGVpZ2h0ID4gMCkge1xuICAgICAgICAgIGNvbnRhaW5lci5hZGRDbGFzcygnY2h6bi13aXRoLXJpc2UnKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2xhc3MoJ2Noem4td2l0aC1yaXNlJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBDaG9zZW47XG5cbiAgfSkoQWJzdHJhY3RDaG9zZW4pO1xuXG4gIGdldF9zaWRlX2JvcmRlcl9wYWRkaW5nID0gZnVuY3Rpb24oZWxtdCkge1xuICAgIHZhciBzaWRlX2JvcmRlcl9wYWRkaW5nO1xuICAgIHJldHVybiBzaWRlX2JvcmRlcl9wYWRkaW5nID0gZWxtdC5vdXRlcldpZHRoKCkgLSBlbG10LndpZHRoKCk7XG4gIH07XG5cbiAgcm9vdC5nZXRfc2lkZV9ib3JkZXJfcGFkZGluZyA9IGdldF9zaWRlX2JvcmRlcl9wYWRkaW5nO1xuXG4vLyBPcmlnaW9uYWwgLSAndGhpcycgIT09ICd3aW5kb3cnIGluIGJyb3dzZXJpZnlcbi8vfSkuY2FsbCh0aGlzKTtcblxuLy8gU2lsdmVyU3RyaXBlIGN1c3RvbVxufSkuY2FsbCh3aW5kb3cpO1xuIiwiLyoqXG4gKiBAcHJlc2VydmUgakxheW91dCBCb3JkZXIgTGF5b3V0IC0gSmF2YVNjcmlwdCBMYXlvdXQgQWxnb3JpdGhtcyB2MC40XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIG5ldyBCU0QgTGljZW5zZS5cbiAqIENvcHlyaWdodCAyMDA4LTIwMDksIEJyYW0gU3RlaW5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbi8qZ2xvYmFsIGpMYXlvdXQ6dHJ1ZSAqL1xuKGZ1bmN0aW9uICgpIHtcblx0Ly8gQ3VzdG9taXNlZFxuXHQvLyBEZWZpbmluZyBnbG9iYWwgYWxpYXMgYmVjYXVzZSBCcm93c2VyaWZ5IGFkZHMgJ3VzZSBzdHJpY3QnXG5cdC8vIHdoaWNoIHRocm93cyBhIHJ1bnRpbWUgZXJyb3IgaWYgZ2xvYmFscyBhcmUgdW5kZWZpbmVkIGFuZCBub3QgZGVjbGFyZWQuXG5cblx0Ly8gT3JpZ2luYWxcblx0Ly8gakxheW91dCA9ICh0eXBlb2YgakxheW91dCA9PT0gJ3VuZGVmaW5lZCcpID8ge30gOiBqTGF5b3V0O1xuXG5cdHdpbmRvdy5qTGF5b3V0ID0gKHR5cGVvZiB3aW5kb3cuakxheW91dCA9PT0gJ3VuZGVmaW5lZCcpID8ge30gOiB3aW5kb3cuakxheW91dDtcblxuXHRqTGF5b3V0LmJvcmRlciA9IGZ1bmN0aW9uIChzcGVjKSB7XG5cdFx0dmFyIG15ID0ge30sXG5cdFx0XHR0aGF0ID0ge30sXG5cdFx0XHRlYXN0ID0gc3BlYy5lYXN0LFxuXHRcdFx0d2VzdCA9IHNwZWMud2VzdCxcblx0XHRcdG5vcnRoID0gc3BlYy5ub3J0aCxcblx0XHRcdHNvdXRoID0gc3BlYy5zb3V0aCxcblx0XHRcdGNlbnRlciA9IHNwZWMuY2VudGVyO1xuXG5cdFx0bXkuaGdhcCA9IHNwZWMuaGdhcCB8fCAwO1xuXHRcdG15LnZnYXAgPSBzcGVjLnZnYXAgfHwgMDtcblxuXHRcdHRoYXQuaXRlbXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgaXRlbXMgPSBbXTtcblx0XHRcdGlmIChlYXN0KSB7XG5cdFx0XHRcdGl0ZW1zLnB1c2goZWFzdCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh3ZXN0KSB7XG5cdFx0XHRcdGl0ZW1zLnB1c2god2VzdCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChub3J0aCkge1xuXHRcdFx0XHRpdGVtcy5wdXNoKG5vcnRoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHNvdXRoKSB7XG5cdFx0XHRcdGl0ZW1zLnB1c2goc291dGgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2VudGVyKSB7XG5cdFx0XHRcdGl0ZW1zLnB1c2goY2VudGVyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9O1x0XHRcblxuXHRcdHRoYXQubGF5b3V0ID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuXHRcdFx0dmFyIHNpemUgPSBjb250YWluZXIuYm91bmRzKCksXG5cdFx0XHRcdGluc2V0cyA9IGNvbnRhaW5lci5pbnNldHMoKSxcblx0XHRcdFx0dG9wID0gaW5zZXRzLnRvcCxcblx0XHRcdFx0Ym90dG9tID0gc2l6ZS5oZWlnaHQgLSBpbnNldHMuYm90dG9tLFxuXHRcdFx0XHRsZWZ0ID0gaW5zZXRzLmxlZnQsXG5cdFx0XHRcdHJpZ2h0ID0gc2l6ZS53aWR0aCAtIGluc2V0cy5yaWdodCxcblx0XHRcdFx0dG1wO1xuXG5cdFx0XHRpZiAobm9ydGggJiYgbm9ydGguaXNWaXNpYmxlKCkpIHtcblx0XHRcdFx0dG1wID0gbm9ydGgucHJlZmVycmVkU2l6ZSgpO1xuXHRcdFx0XHRub3J0aC5ib3VuZHMoeyd4JzogbGVmdCwgJ3knOiB0b3AsICd3aWR0aCc6IHJpZ2h0IC0gbGVmdCwgJ2hlaWdodCc6IHRtcC5oZWlnaHR9KTtcblx0XHRcdFx0bm9ydGguZG9MYXlvdXQoKTtcblxuXHRcdFx0XHR0b3AgKz0gdG1wLmhlaWdodCArIG15LnZnYXA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc291dGggJiYgc291dGguaXNWaXNpYmxlKCkpIHtcblx0XHRcdFx0dG1wID0gc291dGgucHJlZmVycmVkU2l6ZSgpO1xuXHRcdFx0XHRzb3V0aC5ib3VuZHMoeyd4JzogbGVmdCwgJ3knOiBib3R0b20gLSB0bXAuaGVpZ2h0LCAnd2lkdGgnOiByaWdodCAtIGxlZnQsICdoZWlnaHQnOiB0bXAuaGVpZ2h0fSk7XG5cdFx0XHRcdHNvdXRoLmRvTGF5b3V0KCk7XG5cblx0XHRcdFx0Ym90dG9tIC09IHRtcC5oZWlnaHQgKyBteS52Z2FwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVhc3QgJiYgZWFzdC5pc1Zpc2libGUoKSkge1xuXHRcdFx0XHR0bXAgPSBlYXN0LnByZWZlcnJlZFNpemUoKTtcblx0XHRcdFx0ZWFzdC5ib3VuZHMoeyd4JzogcmlnaHQgLSB0bXAud2lkdGgsICd5JzogdG9wLCAnd2lkdGgnOiB0bXAud2lkdGgsICdoZWlnaHQnOiBib3R0b20gLSB0b3B9KTtcblx0XHRcdFx0ZWFzdC5kb0xheW91dCgpO1xuXG5cdFx0XHRcdHJpZ2h0IC09IHRtcC53aWR0aCArIG15LmhnYXA7XG5cdFx0XHR9XG5cdFx0XHRpZiAod2VzdCAmJiB3ZXN0LmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRcdHRtcCA9IHdlc3QucHJlZmVycmVkU2l6ZSgpO1xuXHRcdFx0XHR3ZXN0LmJvdW5kcyh7J3gnOiBsZWZ0LCAneSc6IHRvcCwgJ3dpZHRoJzogdG1wLndpZHRoLCAnaGVpZ2h0JzogYm90dG9tIC0gdG9wfSk7XG5cdFx0XHRcdHdlc3QuZG9MYXlvdXQoKTtcblxuXHRcdFx0XHRsZWZ0ICs9IHRtcC53aWR0aCArIG15LmhnYXA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2VudGVyICYmIGNlbnRlci5pc1Zpc2libGUoKSkge1xuXHRcdFx0XHRjZW50ZXIuYm91bmRzKHsneCc6IGxlZnQsICd5JzogdG9wLCAnd2lkdGgnOiByaWdodCAtIGxlZnQsICdoZWlnaHQnOiBib3R0b20gLSB0b3B9KTtcblx0XHRcdFx0Y2VudGVyLmRvTGF5b3V0KCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29udGFpbmVyO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB0eXBlTGF5b3V0KHR5cGUpIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG5cdFx0XHRcdHZhciBpbnNldHMgPSBjb250YWluZXIuaW5zZXRzKCksXG5cdFx0XHRcdFx0d2lkdGggPSAwLFxuXHRcdFx0XHRcdGhlaWdodCA9IDAsXG5cdFx0XHRcdFx0dHlwZV9zaXplO1xuXG5cdFx0XHRcdGlmIChlYXN0ICYmIGVhc3QuaXNWaXNpYmxlKCkpIHtcblx0XHRcdFx0XHR0eXBlX3NpemUgPSBlYXN0W3R5cGUgKyAnU2l6ZSddKCk7XG5cdFx0XHRcdFx0d2lkdGggKz0gdHlwZV9zaXplLndpZHRoICsgbXkuaGdhcDtcblx0XHRcdFx0XHRoZWlnaHQgPSB0eXBlX3NpemUuaGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh3ZXN0ICYmIHdlc3QuaXNWaXNpYmxlKCkpIHtcblx0XHRcdFx0XHR0eXBlX3NpemUgPSB3ZXN0W3R5cGUgKyAnU2l6ZSddKCk7XG5cdFx0XHRcdFx0d2lkdGggKz0gdHlwZV9zaXplLndpZHRoICsgbXkuaGdhcDtcblx0XHRcdFx0XHRoZWlnaHQgPSBNYXRoLm1heCh0eXBlX3NpemUuaGVpZ2h0LCBoZWlnaHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjZW50ZXIgJiYgY2VudGVyLmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRcdFx0dHlwZV9zaXplID0gY2VudGVyW3R5cGUgKyAnU2l6ZSddKCk7XG5cdFx0XHRcdFx0d2lkdGggKz0gdHlwZV9zaXplLndpZHRoO1xuXHRcdFx0XHRcdGhlaWdodCA9IE1hdGgubWF4KHR5cGVfc2l6ZS5oZWlnaHQsIGhlaWdodCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5vcnRoICYmIG5vcnRoLmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRcdFx0dHlwZV9zaXplID0gbm9ydGhbdHlwZSArICdTaXplJ10oKTtcblx0XHRcdFx0XHR3aWR0aCA9IE1hdGgubWF4KHR5cGVfc2l6ZS53aWR0aCwgd2lkdGgpO1xuXHRcdFx0XHRcdGhlaWdodCArPSB0eXBlX3NpemUuaGVpZ2h0ICsgbXkudmdhcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc291dGggJiYgc291dGguaXNWaXNpYmxlKCkpIHtcblx0XHRcdFx0XHR0eXBlX3NpemUgPSBzb3V0aFt0eXBlICsgJ1NpemUnXSgpO1xuXHRcdFx0XHRcdHdpZHRoID0gTWF0aC5tYXgodHlwZV9zaXplLndpZHRoLCB3aWR0aCk7XG5cdFx0XHRcdFx0aGVpZ2h0ICs9IHR5cGVfc2l6ZS5oZWlnaHQgKyBteS52Z2FwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHQnd2lkdGgnOiB3aWR0aCArIGluc2V0cy5sZWZ0ICsgaW5zZXRzLnJpZ2h0LCBcblx0XHRcdFx0XHQnaGVpZ2h0JzogaGVpZ2h0ICsgaW5zZXRzLnRvcCArIGluc2V0cy5ib3R0b21cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHRoYXQucHJlZmVycmVkID0gdHlwZUxheW91dCgncHJlZmVycmVkJyk7XG5cdFx0dGhhdC5taW5pbXVtID0gdHlwZUxheW91dCgnbWluaW11bScpO1xuXHRcdHRoYXQubWF4aW11bSA9IHR5cGVMYXlvdXQoJ21heGltdW0nKTtcblx0XHRyZXR1cm4gdGhhdDtcblx0fTtcbn0oKSk7XG4iLCIvKipcbiAqIEBwcmVzZXJ2ZSBqTGF5b3V0IEpRdWVyeSBQbHVnaW4gdjAuMTdcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgbmV3IEJTRCBMaWNlbnNlLlxuICogQ29weXJpZ2h0IDIwMDgtMjAwOSBCcmFtIFN0ZWluXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4vKmdsb2JhbCBqUXVlcnkgakxheW91dCovXG5cbi8vIEN1c3RvbWlzZWRcbi8vIERlZmluaW5nIGdsb2JhbCBhbGlhcyBiZWNhdXNlIEJyb3dzZXJpZnkgYWRkcyAndXNlIHN0cmljdCdcbi8vIHdoaWNoIHRocm93cyBhIHJ1bnRpbWUgZXJyb3IgaWYgZ2xvYmFscyBhcmUgdW5kZWZpbmVkIGFuZCBub3QgZGVjbGFyZWQuXG52YXIgalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblx0akxheW91dCA9IHdpbmRvdy5qTGF5b3V0O1xuXG5pZiAoalF1ZXJ5ICYmIGpMYXlvdXQpIHtcblx0KGZ1bmN0aW9uICgkKSB7XG5cdFx0LyoqXG5cdFx0ICogVGhpcyB3cmFwcyBqUXVlcnkgb2JqZWN0cyBpbiBhbm90aGVyIG9iamVjdCB0aGF0IHN1cHBsaWVzXG5cdFx0ICogdGhlIG1ldGhvZHMgcmVxdWlyZWQgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtcy5cblx0XHQgKi9cblx0XHQvLyBDVVNUT00gaGZyaWVkbGFuZGVyIDIwMTItMTAtMjYgZm9yIHNpZGUtYnktc2lkZSBlZGl0aW5nLlxuXHRcdC8vIGZ1bmN0aW9uIHdyYXAoaXRlbSwgcmVzaXplKSB7XG5cdFx0dmFyIHdyYXAgPSAkLmpMYXlvdXRXcmFwID0gZnVuY3Rpb24oaXRlbSwgcmVzaXplKSB7XG5cdFx0Ly8gQ1VTVE9NIEVORFxuXHRcdFx0dmFyIHRoYXQgPSB7fTtcblx0XHRcdC8vIENVU1RPTSBoZnJpZWRsYW5kZXIgMjAxMi0xMC0yNiBmb3Igc2lkZS1ieS1zaWRlIGVkaXRpbmcuXG5cdFx0XHR0aGF0Lml0ZW0gPSBpdGVtO1xuXHRcdFx0Ly8gQ1VTVE9NIEVORFxuXG5cdFx0XHQkLmVhY2goWydtaW4nLCAnbWF4J10sIGZ1bmN0aW9uIChpLCBuYW1lKSB7XG5cdFx0XHRcdHRoYXRbbmFtZSArICdpbXVtU2l6ZSddID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsID0gaXRlbS5kYXRhKCdqbGF5b3V0Jyk7XG4gICAgICAgICAgICAgICAgICAgIFxuXHRcdFx0XHRcdGlmIChsKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbFtuYW1lICsgJ2ltdW0nXSh0aGF0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGl0ZW1bbmFtZSArICdTaXplJ10odmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXG5cdFx0XHQkLmV4dGVuZCh0aGF0LCB7XG5cdFx0XHRcdGRvTGF5b3V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0Ly8gQ1VTVE9NIGhmcmllZGxhbmRlciAyMDEyLTEwLTI2IGZvciBzaWRlLWJ5LXNpZGUgZWRpdGluZy5cblx0XHRcdFx0XHQvL3ZhciBsID0gaXRlbS5kYXRhKCdqbGF5b3V0Jyk7XG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHQvL2lmIChsKSB7XG5cdFx0XHRcdFx0Ly9cdGwubGF5b3V0KHRoYXQpO1xuXHRcdFx0XHRcdC8vfVxuXHRcdFx0XHRcdC8vXG5cdFx0XHRcdFx0dmFyIGwgPSBpdGVtLmRhdGEoJ2psYXlvdXQnKTtcblx0XHRcdFx0XHRpZiAobCkgbC5sYXlvdXQodGhhdCk7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoaXRlbS5pcygnW2RhdGEtbGF5b3V0LXR5cGVdJykpIHtcblx0XHRcdFx0XHRcdGl0ZW0ubGF5b3V0KHtyZXNpemU6IGZhbHNlfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIENVU1RPTSBFTkRcblxuXHRcdFx0XHRcdGl0ZW0uY3NzKHtwb3NpdGlvbjogJ2Fic29sdXRlJ30pO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRpc1Zpc2libGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gaXRlbS5pc1Zpc2libGUoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0aW5zZXRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIHAgPSBpdGVtLnBhZGRpbmcoKSxcblx0XHRcdFx0XHRcdGIgPSBpdGVtLmJvcmRlcigpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0b3AnOiBwLnRvcCwgXG5cdFx0XHRcdFx0XHQnYm90dG9tJzogcC5ib3R0b20gKyBiLmJvdHRvbSArIGIudG9wLCBcblx0XHRcdFx0XHRcdCdsZWZ0JzogcC5sZWZ0LCBcblx0XHRcdFx0XHRcdCdyaWdodCc6IHAucmlnaHQgKyBiLnJpZ2h0ICsgYi5sZWZ0XG4gICAgICAgICAgICAgICAgICAgIH07XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGJvdW5kczogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdFx0dmFyIHRtcCA9IHt9O1xuXG5cdFx0XHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHZhbHVlLnggPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0XHRcdHRtcC5sZWZ0ID0gdmFsdWUueDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgdmFsdWUueSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRcdFx0dG1wLnRvcCA9IHZhbHVlLnk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHZhbHVlLndpZHRoID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRcdFx0XHR0bXAud2lkdGggPSAodmFsdWUud2lkdGggLSAoaXRlbS5vdXRlcldpZHRoKHRydWUpIC0gaXRlbS53aWR0aCgpKSk7XG5cdFx0XHRcdFx0XHRcdHRtcC53aWR0aCA9ICh0bXAud2lkdGggPj0gMCkgPyB0bXAud2lkdGggOiAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiB2YWx1ZS5oZWlnaHQgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0XHRcdHRtcC5oZWlnaHQgPSB2YWx1ZS5oZWlnaHQgLSAoaXRlbS5vdXRlckhlaWdodCh0cnVlKSAtIGl0ZW0uaGVpZ2h0KCkpO1xuXHRcdFx0XHRcdFx0XHR0bXAuaGVpZ2h0ID0gKHRtcC5oZWlnaHQgPj0gMCkgPyB0bXAuaGVpZ2h0IDogMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGl0ZW0uY3NzKHRtcCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaXRlbTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dG1wID0gaXRlbS5wb3NpdGlvbigpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0J3gnOiB0bXAubGVmdCxcblx0XHRcdFx0XHRcdFx0J3knOiB0bXAudG9wLFxuXHRcdFx0XHRcdFx0XHQnd2lkdGgnOiBpdGVtLm91dGVyV2lkdGgoZmFsc2UpLFxuXHRcdFx0XHRcdFx0XHQnaGVpZ2h0JzogaXRlbS5vdXRlckhlaWdodChmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRwcmVmZXJyZWRTaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIG1pblNpemUsXG5cdFx0XHRcdFx0XHRtYXhTaXplLFxuXHRcdFx0XHRcdFx0bWFyZ2luID0gaXRlbS5tYXJnaW4oKSxcblx0XHRcdFx0XHRcdHNpemUgPSB7d2lkdGg6IDAsIGhlaWdodDogMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gaXRlbS5kYXRhKCdqbGF5b3V0Jyk7XG5cblx0XHRcdFx0XHRpZiAobCAmJiByZXNpemUpIHtcblx0XHRcdFx0XHRcdHNpemUgPSBsLnByZWZlcnJlZCh0aGF0KTtcblxuXHRcdFx0XHRcdFx0bWluU2l6ZSA9IHRoYXQubWluaW11bVNpemUoKTtcblx0XHRcdFx0XHRcdG1heFNpemUgPSB0aGF0Lm1heGltdW1TaXplKCk7XG5cblx0XHRcdFx0XHRcdHNpemUud2lkdGggKz0gbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQ7XG5cdFx0XHRcdFx0XHRzaXplLmhlaWdodCArPSBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbTtcblxuXHRcdFx0XHRcdFx0aWYgKHNpemUud2lkdGggPCBtaW5TaXplLndpZHRoIHx8IHNpemUuaGVpZ2h0IDwgbWluU2l6ZS5oZWlnaHQpIHtcblx0XHRcdFx0XHRcdFx0c2l6ZS53aWR0aCA9IE1hdGgubWF4KHNpemUud2lkdGgsIG1pblNpemUud2lkdGgpO1xuXHRcdFx0XHRcdFx0XHRzaXplLmhlaWdodCA9IE1hdGgubWF4KHNpemUuaGVpZ2h0LCBtaW5TaXplLmhlaWdodCk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHNpemUud2lkdGggPiBtYXhTaXplLndpZHRoIHx8IHNpemUuaGVpZ2h0ID4gbWF4U2l6ZS5oZWlnaHQpIHtcblx0XHRcdFx0XHRcdFx0c2l6ZS53aWR0aCA9IE1hdGgubWluKHNpemUud2lkdGgsIG1heFNpemUud2lkdGgpO1xuXHRcdFx0XHRcdFx0XHRzaXplLmhlaWdodCA9IE1hdGgubWluKHNpemUuaGVpZ2h0LCBtYXhTaXplLmhlaWdodCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgPSB0aGF0LmJvdW5kcygpO1xuXHRcdFx0XHRcdFx0c2l6ZS53aWR0aCArPSBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodDtcblx0XHRcdFx0XHRcdHNpemUuaGVpZ2h0ICs9IG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gc2l6ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gdGhhdDtcblx0XHR9XG5cblx0XHQkLmZuLmxheW91dCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0XHR2YXIgb3B0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmxheW91dC5kZWZhdWx0cywgb3B0aW9ucyk7XG5cdFx0XHRyZXR1cm4gJC5lYWNoKHRoaXMsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGVsZW1lbnQgPSAkKHRoaXMpLFxuXHRcdFx0XHRcdG8gPSAkLm1ldGFkYXRhICYmIGVsZW1lbnQubWV0YWRhdGEoKS5sYXlvdXQgPyAkLmV4dGVuZChvcHRzLCBlbGVtZW50Lm1ldGFkYXRhKCkubGF5b3V0KSA6IG9wdHMsXG5cdFx0XHRcdFx0Ly8gQ1VTVE9NIGlzY2hvbW1lciAyMDEyLTE2LTAyIEFsbG93IHR5cGUgc2V0dGluZyB0aHJvZ2ggYnVpbHQtaW4galF1ZXJ5IEhUTUw1IGRhdGEgZ2V0dGVycywgdG8gYXZvaWQgaW5jbHVkaW5nIGpRdWVyeS5tZXRhZGF0YS5qc1xuXHRcdFx0XHRcdG8gPSBlbGVtZW50LmRhdGEoJ2xheW91dFR5cGUnKSA/ICQuZXh0ZW5kKG8sIHt0eXBlOiBlbGVtZW50LmRhdGEoJ2xheW91dFR5cGUnKX0pIDogbyxcblx0XHRcdFx0XHQvLyBDVVNUT00gRU5EXG5cdFx0XHRcdFx0ZWxlbWVudFdyYXBwZXIgPSB3cmFwKGVsZW1lbnQsIG8ucmVzaXplKTtcblx0XHRcdFx0aWYgKG8udHlwZSA9PT0gJ2JvcmRlcicgJiYgdHlwZW9mIGpMYXlvdXQuYm9yZGVyICE9PSAndW5kZWZpbmVkJykgeyAgICAgICAgICAgICAgICBcblx0XHRcdFx0XHQkLmVhY2goWydub3J0aCcsICdzb3V0aCcsICd3ZXN0JywgJ2Vhc3QnLCAnY2VudGVyJ10sIGZ1bmN0aW9uIChpLCBuYW1lKSB7XG5cdFx0XHRcdFx0XHRpZiAoZWxlbWVudC5jaGlsZHJlbigpLmhhc0NsYXNzKG5hbWUpKSB7XG5cdFx0XHRcdFx0XHRcdG9bbmFtZV0gPSB3cmFwKGVsZW1lbnQuY2hpbGRyZW4oJy4nICsgbmFtZSArICc6Zmlyc3QnKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0ZWxlbWVudC5kYXRhKCdqbGF5b3V0JywgakxheW91dC5ib3JkZXIobykpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG8udHlwZSA9PT0gJ2dyaWQnICYmIHR5cGVvZiBqTGF5b3V0LmdyaWQgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0by5pdGVtcyA9IFtdO1xuXHRcdFx0XHRcdGVsZW1lbnQuY2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRcdFx0XHRpZiAoISQodGhpcykuaGFzQ2xhc3MoJ3VpLXJlc2l6YWJsZS1oYW5kbGUnKSkge1xuXHRcdFx0XHRcdFx0XHRvLml0ZW1zW2ldID0gd3JhcCgkKHRoaXMpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRlbGVtZW50LmRhdGEoJ2psYXlvdXQnLCBqTGF5b3V0LmdyaWQobykpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG8udHlwZSA9PT0gJ2ZsZXhHcmlkJyAmJiB0eXBlb2YgakxheW91dC5mbGV4R3JpZCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRvLml0ZW1zID0gW107XG5cdFx0XHRcdFx0ZWxlbWVudC5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24gKGkpIHtcblx0XHRcdFx0XHRcdGlmICghJCh0aGlzKS5oYXNDbGFzcygndWktcmVzaXphYmxlLWhhbmRsZScpKSB7XG5cdFx0XHRcdFx0XHRcdG8uaXRlbXNbaV0gPSB3cmFwKCQodGhpcykpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGVsZW1lbnQuZGF0YSgnamxheW91dCcsIGpMYXlvdXQuZmxleEdyaWQobykpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG8udHlwZSA9PT0gJ2NvbHVtbicgJiYgdHlwZW9mIGpMYXlvdXQuY29sdW1uICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdG8uaXRlbXMgPSBbXTtcblx0XHRcdFx0XHRlbGVtZW50LmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbiAoaSkge1xuXHRcdFx0XHRcdFx0aWYgKCEkKHRoaXMpLmhhc0NsYXNzKCd1aS1yZXNpemFibGUtaGFuZGxlJykpIHtcblx0XHRcdFx0XHRcdFx0by5pdGVtc1tpXSA9IHdyYXAoJCh0aGlzKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0ZWxlbWVudC5kYXRhKCdqbGF5b3V0JywgakxheW91dC5jb2x1bW4obykpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG8udHlwZSA9PT0gJ2Zsb3cnICYmIHR5cGVvZiBqTGF5b3V0LmZsb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0by5pdGVtcyA9IFtdO1xuXHRcdFx0XHRcdGVsZW1lbnQuY2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRcdFx0XHRpZiAoISQodGhpcykuaGFzQ2xhc3MoJ3VpLXJlc2l6YWJsZS1oYW5kbGUnKSkge1xuXHRcdFx0XHRcdFx0XHRvLml0ZW1zW2ldID0gd3JhcCgkKHRoaXMpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRlbGVtZW50LmRhdGEoJ2psYXlvdXQnLCBqTGF5b3V0LmZsb3cobykpO1x0XHRcdFx0XHRcblx0XHRcdFx0fVxuICAgICAgICAgICAgICAgIFxuXHRcdFx0XHRpZiAoby5yZXNpemUpIHtcblx0XHRcdFx0XHRlbGVtZW50V3JhcHBlci5ib3VuZHMoZWxlbWVudFdyYXBwZXIucHJlZmVycmVkU2l6ZSgpKTtcblx0XHRcdFx0fVxuICAgICAgICAgICAgICAgIFxuXHRcdFx0XHRlbGVtZW50V3JhcHBlci5kb0xheW91dCgpO1xuXHRcdFx0XHRlbGVtZW50LmNzcyh7cG9zaXRpb246ICdyZWxhdGl2ZSd9KTtcblx0XHRcdFx0aWYgKCQudWkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGVsZW1lbnQuYWRkQ2xhc3MoJ3VpLXdpZGdldCcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0JC5mbi5sYXlvdXQuZGVmYXVsdHMgPSB7XG5cdFx0XHRyZXNpemU6IHRydWUsXG5cdFx0XHR0eXBlOiAnZ3JpZCdcblx0XHR9O1xuXHR9KGpRdWVyeSkpO1xufVxuIiwiLyoqXG4qIGhvdmVySW50ZW50IGlzIHNpbWlsYXIgdG8galF1ZXJ5J3MgYnVpbHQtaW4gXCJob3ZlclwiIGZ1bmN0aW9uIGV4Y2VwdCB0aGF0XG4qIGluc3RlYWQgb2YgZmlyaW5nIHRoZSBvbk1vdXNlT3ZlciBldmVudCBpbW1lZGlhdGVseSwgaG92ZXJJbnRlbnQgY2hlY2tzXG4qIHRvIHNlZSBpZiB0aGUgdXNlcidzIG1vdXNlIGhhcyBzbG93ZWQgZG93biAoYmVuZWF0aCB0aGUgc2Vuc2l0aXZpdHlcbiogdGhyZXNob2xkKSBiZWZvcmUgZmlyaW5nIHRoZSBvbk1vdXNlT3ZlciBldmVudC5cbipcbiogaG92ZXJJbnRlbnQgcjYgLy8gMjAxMS4wMi4yNiAvLyBqUXVlcnkgMS41LjErXG4qIDxodHRwOi8vY2hlcm5lLm5ldC9icmlhbi9yZXNvdXJjZXMvanF1ZXJ5LmhvdmVySW50ZW50Lmh0bWw+XG4qXG4qIGhvdmVySW50ZW50IGlzIGN1cnJlbnRseSBhdmFpbGFibGUgZm9yIHVzZSBpbiBhbGwgcGVyc29uYWwgb3IgY29tbWVyY2lhbFxuKiBwcm9qZWN0cyB1bmRlciBib3RoIE1JVCBhbmQgR1BMIGxpY2Vuc2VzLiBUaGlzIG1lYW5zIHRoYXQgeW91IGNhbiBjaG9vc2VcbiogdGhlIGxpY2Vuc2UgdGhhdCBiZXN0IHN1aXRzIHlvdXIgcHJvamVjdCwgYW5kIHVzZSBpdCBhY2NvcmRpbmdseS5cbipcbiogLy8gYmFzaWMgdXNhZ2UgKGp1c3QgbGlrZSAuaG92ZXIpIHJlY2VpdmVzIG9uTW91c2VPdmVyIGFuZCBvbk1vdXNlT3V0IGZ1bmN0aW9uc1xuKiAkKFwidWwgbGlcIikuaG92ZXJJbnRlbnQoIHNob3dOYXYgLCBoaWRlTmF2ICk7XG4qXG4qIC8vIGFkdmFuY2VkIHVzYWdlIHJlY2VpdmVzIGNvbmZpZ3VyYXRpb24gb2JqZWN0IG9ubHlcbiogJChcInVsIGxpXCIpLmhvdmVySW50ZW50KHtcbipcdHNlbnNpdGl2aXR5OiA3LCAvLyBudW1iZXIgPSBzZW5zaXRpdml0eSB0aHJlc2hvbGQgKG11c3QgYmUgMSBvciBoaWdoZXIpXG4qXHRpbnRlcnZhbDogMTAwLCAgIC8vIG51bWJlciA9IG1pbGxpc2Vjb25kcyBvZiBwb2xsaW5nIGludGVydmFsXG4qXHRvdmVyOiBzaG93TmF2LCAgLy8gZnVuY3Rpb24gPSBvbk1vdXNlT3ZlciBjYWxsYmFjayAocmVxdWlyZWQpXG4qXHR0aW1lb3V0OiAzNTAsICAgLy8gbnVtYmVyID0gbWlsbGlzZWNvbmRzIGRlbGF5IGJlZm9yZSBvbk1vdXNlT3V0IGZ1bmN0aW9uIGNhbGxcbipcdG91dDogaGlkZU5hdiAgICAvLyBmdW5jdGlvbiA9IG9uTW91c2VPdXQgY2FsbGJhY2sgKHJlcXVpcmVkKVxuKiB9KTtcbipcbiogQHBhcmFtICBmICBvbk1vdXNlT3ZlciBmdW5jdGlvbiB8fCBBbiBvYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiogQHBhcmFtICBnICBvbk1vdXNlT3V0IGZ1bmN0aW9uICB8fCBOb3RoaW5nICh1c2UgY29uZmlndXJhdGlvbiBvcHRpb25zIG9iamVjdClcbiogQGF1dGhvciAgICBCcmlhbiBDaGVybmUgYnJpYW4oYXQpY2hlcm5lKGRvdCluZXRcbiovXG4oZnVuY3Rpb24oJCkge1xuXHQkLmZuLmhvdmVySW50ZW50ID0gZnVuY3Rpb24oZixnKSB7XG5cdFx0Ly8gZGVmYXVsdCBjb25maWd1cmF0aW9uIG9wdGlvbnNcblx0XHR2YXIgY2ZnID0ge1xuXHRcdFx0c2Vuc2l0aXZpdHk6IDcsXG5cdFx0XHRpbnRlcnZhbDogMTAwLFxuXHRcdFx0dGltZW91dDogMzUwXG5cdFx0fTtcblx0XHQvLyBvdmVycmlkZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgd2l0aCB1c2VyIHN1cHBsaWVkIG9iamVjdFxuXHRcdGNmZyA9ICQuZXh0ZW5kKGNmZywgZyA/IHsgb3ZlcjogZiwgb3V0OiBnIH0gOiBmICk7XG5cblx0XHQvLyBpbnN0YW50aWF0ZSB2YXJpYWJsZXNcblx0XHQvLyBjWCwgY1kgPSBjdXJyZW50IFggYW5kIFkgcG9zaXRpb24gb2YgbW91c2UsIHVwZGF0ZWQgYnkgbW91c2Vtb3ZlIGV2ZW50XG5cdFx0Ly8gcFgsIHBZID0gcHJldmlvdXMgWCBhbmQgWSBwb3NpdGlvbiBvZiBtb3VzZSwgc2V0IGJ5IG1vdXNlb3ZlciBhbmQgcG9sbGluZyBpbnRlcnZhbFxuXHRcdHZhciBjWCwgY1ksIHBYLCBwWTtcblxuXHRcdC8vIEEgcHJpdmF0ZSBmdW5jdGlvbiBmb3IgZ2V0dGluZyBtb3VzZSBwb3NpdGlvblxuXHRcdHZhciB0cmFjayA9IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRjWCA9IGV2LnBhZ2VYO1xuXHRcdFx0Y1kgPSBldi5wYWdlWTtcblx0XHR9O1xuXG5cdFx0Ly8gQSBwcml2YXRlIGZ1bmN0aW9uIGZvciBjb21wYXJpbmcgY3VycmVudCBhbmQgcHJldmlvdXMgbW91c2UgcG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9IGZ1bmN0aW9uKGV2LG9iKSB7XG5cdFx0XHRvYi5ob3ZlckludGVudF90ID0gY2xlYXJUaW1lb3V0KG9iLmhvdmVySW50ZW50X3QpO1xuXHRcdFx0Ly8gY29tcGFyZSBtb3VzZSBwb3NpdGlvbnMgdG8gc2VlIGlmIHRoZXkndmUgY3Jvc3NlZCB0aGUgdGhyZXNob2xkXG5cdFx0XHRpZiAoICggTWF0aC5hYnMocFgtY1gpICsgTWF0aC5hYnMocFktY1kpICkgPCBjZmcuc2Vuc2l0aXZpdHkgKSB7XG5cdFx0XHRcdCQob2IpLnVuYmluZChcIm1vdXNlbW92ZVwiLHRyYWNrKTtcblx0XHRcdFx0Ly8gc2V0IGhvdmVySW50ZW50IHN0YXRlIHRvIHRydWUgKHNvIG1vdXNlT3V0IGNhbiBiZSBjYWxsZWQpXG5cdFx0XHRcdG9iLmhvdmVySW50ZW50X3MgPSAxO1xuXHRcdFx0XHRyZXR1cm4gY2ZnLm92ZXIuYXBwbHkob2IsW2V2XSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBzZXQgcHJldmlvdXMgY29vcmRpbmF0ZXMgZm9yIG5leHQgdGltZVxuXHRcdFx0XHRwWCA9IGNYOyBwWSA9IGNZO1xuXHRcdFx0XHQvLyB1c2Ugc2VsZi1jYWxsaW5nIHRpbWVvdXQsIGd1YXJhbnRlZXMgaW50ZXJ2YWxzIGFyZSBzcGFjZWQgb3V0IHByb3Blcmx5IChhdm9pZHMgSmF2YVNjcmlwdCB0aW1lciBidWdzKVxuXHRcdFx0XHRvYi5ob3ZlckludGVudF90ID0gc2V0VGltZW91dCggZnVuY3Rpb24oKXtjb21wYXJlKGV2LCBvYik7fSAsIGNmZy5pbnRlcnZhbCApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBBIHByaXZhdGUgZnVuY3Rpb24gZm9yIGRlbGF5aW5nIHRoZSBtb3VzZU91dCBmdW5jdGlvblxuXHRcdHZhciBkZWxheSA9IGZ1bmN0aW9uKGV2LG9iKSB7XG5cdFx0XHRvYi5ob3ZlckludGVudF90ID0gY2xlYXJUaW1lb3V0KG9iLmhvdmVySW50ZW50X3QpO1xuXHRcdFx0b2IuaG92ZXJJbnRlbnRfcyA9IDA7XG5cdFx0XHRyZXR1cm4gY2ZnLm91dC5hcHBseShvYixbZXZdKTtcblx0XHR9O1xuXG5cdFx0Ly8gQSBwcml2YXRlIGZ1bmN0aW9uIGZvciBoYW5kbGluZyBtb3VzZSAnaG92ZXJpbmcnXG5cdFx0dmFyIGhhbmRsZUhvdmVyID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0Ly8gY29weSBvYmplY3RzIHRvIGJlIHBhc3NlZCBpbnRvIHQgKHJlcXVpcmVkIGZvciBldmVudCBvYmplY3QgdG8gYmUgcGFzc2VkIGluIElFKVxuXHRcdFx0dmFyIGV2ID0galF1ZXJ5LmV4dGVuZCh7fSxlKTtcblx0XHRcdHZhciBvYiA9IHRoaXM7XG5cblx0XHRcdC8vIGNhbmNlbCBob3ZlckludGVudCB0aW1lciBpZiBpdCBleGlzdHNcblx0XHRcdGlmIChvYi5ob3ZlckludGVudF90KSB7IG9iLmhvdmVySW50ZW50X3QgPSBjbGVhclRpbWVvdXQob2IuaG92ZXJJbnRlbnRfdCk7IH1cblxuXHRcdFx0Ly8gaWYgZS50eXBlID09IFwibW91c2VlbnRlclwiXG5cdFx0XHRpZiAoZS50eXBlID09IFwibW91c2VlbnRlclwiKSB7XG5cdFx0XHRcdC8vIHNldCBcInByZXZpb3VzXCIgWCBhbmQgWSBwb3NpdGlvbiBiYXNlZCBvbiBpbml0aWFsIGVudHJ5IHBvaW50XG5cdFx0XHRcdHBYID0gZXYucGFnZVg7IHBZID0gZXYucGFnZVk7XG5cdFx0XHRcdC8vIHVwZGF0ZSBcImN1cnJlbnRcIiBYIGFuZCBZIHBvc2l0aW9uIGJhc2VkIG9uIG1vdXNlbW92ZVxuXHRcdFx0XHQkKG9iKS5iaW5kKFwibW91c2Vtb3ZlXCIsdHJhY2spO1xuXHRcdFx0XHQvLyBzdGFydCBwb2xsaW5nIGludGVydmFsIChzZWxmLWNhbGxpbmcgdGltZW91dCkgdG8gY29tcGFyZSBtb3VzZSBjb29yZGluYXRlcyBvdmVyIHRpbWVcblx0XHRcdFx0aWYgKG9iLmhvdmVySW50ZW50X3MgIT0gMSkgeyBvYi5ob3ZlckludGVudF90ID0gc2V0VGltZW91dCggZnVuY3Rpb24oKXtjb21wYXJlKGV2LG9iKTt9ICwgY2ZnLmludGVydmFsICk7fVxuXG5cdFx0XHQvLyBlbHNlIGUudHlwZSA9PSBcIm1vdXNlbGVhdmVcIlxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gdW5iaW5kIGV4cGVuc2l2ZSBtb3VzZW1vdmUgZXZlbnRcblx0XHRcdFx0JChvYikudW5iaW5kKFwibW91c2Vtb3ZlXCIsdHJhY2spO1xuXHRcdFx0XHQvLyBpZiBob3ZlckludGVudCBzdGF0ZSBpcyB0cnVlLCB0aGVuIGNhbGwgdGhlIG1vdXNlT3V0IGZ1bmN0aW9uIGFmdGVyIHRoZSBzcGVjaWZpZWQgZGVsYXlcblx0XHRcdFx0aWYgKG9iLmhvdmVySW50ZW50X3MgPT0gMSkgeyBvYi5ob3ZlckludGVudF90ID0gc2V0VGltZW91dCggZnVuY3Rpb24oKXtkZWxheShldixvYik7fSAsIGNmZy50aW1lb3V0ICk7fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBiaW5kIHRoZSBmdW5jdGlvbiB0byB0aGUgdHdvIGV2ZW50IGxpc3RlbmVyc1xuXHRcdHJldHVybiB0aGlzLmJpbmQoJ21vdXNlZW50ZXInLGhhbmRsZUhvdmVyKS5iaW5kKCdtb3VzZWxlYXZlJyxoYW5kbGVIb3Zlcik7XG5cdH07XG59KShqUXVlcnkpOyIsIi8qKlxuKlx0alF1ZXJ5Lm5vdGljZUFkZCgpIGFuZCBqUXVlcnkubm90aWNlUmVtb3ZlKClcbipcdFRoZXNlIGZ1bmN0aW9ucyBjcmVhdGUgYW5kIHJlbW92ZSBncm93bC1saWtlIG5vdGljZXNcbipcdFx0XG4qICAgQ29weXJpZ2h0IChjKSAyMDA5IFRpbSBCZW5uaWtzXG4qXG4qXHRQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4qXHRvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4qXHRpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4qXHR0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4qXHRjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbipcdGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4qXG4qXHRUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuKlx0YWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4qXG4qXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4qXHRJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbipcdEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuKlx0QVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuKlx0TElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbipcdE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbipcdFRIRSBTT0ZUV0FSRS5cbipcdFxuKlx0QGF1dGhvciBcdFRpbSBCZW5uaWtzIDx0aW1AdGltYmVubmlrcy5jb20+XG4qIFx0QGNvcHlyaWdodCAgMjAwOSB0aW1iZW5uaWtzLmNvbVxuKlx0QHZlcnNpb24gICAgJElkOiBqcXVlcnkubm90aWNlLmpzIDEgMjAwOS0wMS0yNCAxMjoyNDoxOFogdGltYmVubmlrcyAkXG4qKi9cbihmdW5jdGlvbihqUXVlcnkpXG57XG5cdGpRdWVyeS5leHRlbmQoe1x0XHRcdFxuXHRcdG5vdGljZUFkZDogZnVuY3Rpb24ob3B0aW9ucylcblx0XHR7XHRcblx0XHRcdHZhciBkZWZhdWx0cyA9IHtcblx0XHRcdFx0aW5FZmZlY3Q6IFx0XHRcdHtvcGFjaXR5OiAnc2hvdyd9LFx0Ly8gaW4gZWZmZWN0XG5cdFx0XHRcdGluRWZmZWN0RHVyYXRpb246IFx0NjAwLFx0XHRcdFx0Ly8gaW4gZWZmZWN0IGR1cmF0aW9uIGluIG1pbGlzZWNvbmRzXG5cdFx0XHRcdHN0YXlUaW1lOiBcdFx0XHQzMDAwLFx0XHRcdFx0Ly8gdGltZSBpbiBtaWxpc2Vjb25kcyBiZWZvcmUgdGhlIGl0ZW0gaGFzIHRvIGRpc2FwcGVhclxuXHRcdFx0XHR0ZXh0OiBcdFx0XHRcdCcnLFx0XHRcdFx0XHQvLyBjb250ZW50IG9mIHRoZSBpdGVtXG5cdFx0XHRcdHN0YXk6IFx0XHRcdFx0ZmFsc2UsXHRcdFx0XHQvLyBzaG91bGQgdGhlIG5vdGljZSBpdGVtIHN0YXkgb3Igbm90P1xuXHRcdFx0XHR0eXBlOiBcdFx0XHRcdCdub3RpY2UnIFx0XHRcdC8vIGNvdWxkIGFsc28gYmUgZXJyb3IsIHN1Y2Nlc1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBkZWNsYXJlIHZhcmFpYmxlc1xuXHRcdFx0dmFyIG9wdGlvbnMsIG5vdGljZVdyYXBBbGwsIG5vdGljZUl0ZW1PdXRlciwgbm90aWNlSXRlbUlubmVyLCBub3RpY2VJdGVtQ2xvc2UsIGhvdmVyID0gZmFsc2U7XG5cdFx0XHRcblx0XHRcdG9wdGlvbnMgXHRcdD0galF1ZXJ5LmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuXHRcdFx0bm90aWNlV3JhcEFsbFx0PSAoIWpRdWVyeSgnLm5vdGljZS13cmFwJykubGVuZ3RoKSA/IGpRdWVyeSgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnbm90aWNlLXdyYXAnKS5hcHBlbmRUbygnYm9keScpIDogalF1ZXJ5KCcubm90aWNlLXdyYXAnKTtcblx0XHRcdG5vdGljZUl0ZW1PdXRlclx0PSBqUXVlcnkoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ25vdGljZS1pdGVtLXdyYXBwZXInKTtcblx0XHRcdG5vdGljZUl0ZW1Jbm5lclx0PSBqUXVlcnkoJzxkaXY+PC9kaXY+JykuaGlkZSgpLmFkZENsYXNzKCdub3RpY2UtaXRlbSAnICsgb3B0aW9ucy50eXBlKS5hcHBlbmRUbyhub3RpY2VXcmFwQWxsKS5odG1sKCc8cD4nK29wdGlvbnMudGV4dCsnPC9wPicpLmFuaW1hdGUob3B0aW9ucy5pbkVmZmVjdCwgb3B0aW9ucy5pbkVmZmVjdER1cmF0aW9uKS53cmFwKG5vdGljZUl0ZW1PdXRlcik7XG5cdFx0XHRub3RpY2VJdGVtQ2xvc2VcdD0galF1ZXJ5KCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdub3RpY2UtaXRlbS1jbG9zZScpLnByZXBlbmRUbyhub3RpY2VJdGVtSW5uZXIpLmh0bWwoJ3gnKS5jbGljayhmdW5jdGlvbigpIHsgalF1ZXJ5Lm5vdGljZVJlbW92ZShub3RpY2VJdGVtSW5uZXIpIH0pO1xuXHRcdFx0XG5cdFx0XHRub3RpY2VJdGVtSW5uZXIuaG92ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvdmVyID0gdHJ1ZTtcblx0XHRcdH0sIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aG92ZXIgPSBmYWxzZTtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoIW9wdGlvbnMuc3RheSkge1xuXHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIG5vdGljZUhvdmVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aWYoIWhvdmVyKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5ub3RpY2VSZW1vdmUobm90aWNlSXRlbUlubmVyKTtcblx0XHRcdFx0XHRcdFx0Y2xlYXJJbnRlcnZhbChub3RpY2VIb3Zlcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgMTAwMCk7XG5cdFx0XHRcdH0sIG9wdGlvbnMuc3RheVRpbWUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0bm90aWNlUmVtb3ZlOiBmdW5jdGlvbihvYmopXG5cdFx0e1xuXHRcdFx0b2JqLmFuaW1hdGUoe29wYWNpdHk6ICcwJ30sIDYwMCwgZnVuY3Rpb24oKVxuXHRcdFx0e1xuXHRcdFx0XHRvYmoucGFyZW50KCkuYW5pbWF0ZSh7aGVpZ2h0OiAnMHB4J30sIDMwMCwgZnVuY3Rpb24oKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0b2JqLnBhcmVudCgpLnJlbW92ZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG59KShqUXVlcnkpOyIsIi8qKlxuICogQHByZXNlcnZlIEpTaXplcyAtIEpRdWVyeSBwbHVnaW4gdjAuMzNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgcmV2aXNlZCBCU0QgTGljZW5zZS5cbiAqIENvcHlyaWdodCAyMDA4LTIwMTAgQnJhbSBTdGVpblxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuLypnbG9iYWwgalF1ZXJ5Ki9cbihmdW5jdGlvbiAoJCkge1xuXHQndXNlIHN0cmljdCc7XG5cdHZhciBudW0gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApIHx8IDA7XG5cdFx0fTtcblxuXHQvKipcblx0ICogU2V0cyBvciBnZXRzIHRoZSB2YWx1ZXMgZm9yIG1pbi13aWR0aCwgbWluLWhlaWdodCwgbWF4LXdpZHRoXG5cdCAqIGFuZCBtYXgtaGVpZ2h0LlxuXHQgKi9cblx0JC5lYWNoKFsnbWluJywgJ21heCddLCBmdW5jdGlvbiAoaSwgbmFtZSkge1xuXHRcdCQuZm5bbmFtZSArICdTaXplJ10gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdHZhciB3aWR0aCwgaGVpZ2h0O1xuXHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdGlmICh2YWx1ZS53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGhpcy5jc3MobmFtZSArICctd2lkdGgnLCB2YWx1ZS53aWR0aCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHZhbHVlLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGhpcy5jc3MobmFtZSArICctaGVpZ2h0JywgdmFsdWUuaGVpZ2h0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2lkdGggPSB0aGlzLmNzcyhuYW1lICsgJy13aWR0aCcpO1xuXHRcdFx0XHRoZWlnaHQgPSB0aGlzLmNzcyhuYW1lICsgJy1oZWlnaHQnKTtcblx0XHRcdFx0Ly8gQXBwYXJlbnRseTpcblx0XHRcdFx0Ly8gICogT3BlcmEgcmV0dXJucyAtMXB4IGluc3RlYWQgb2Ygbm9uZVxuXHRcdFx0XHQvLyAgKiBJRTYgcmV0dXJucyB1bmRlZmluZWQgaW5zdGVhZCBvZiBub25lXG5cdFx0XHRcdHJldHVybiB7J3dpZHRoJzogKG5hbWUgPT09ICdtYXgnICYmICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IHdpZHRoID09PSAnbm9uZScgfHwgbnVtKHdpZHRoKSA9PT0gLTEpICYmIE51bWJlci5NQVhfVkFMVUUpIHx8IG51bSh3aWR0aCksIFxuXHRcdFx0XHRcdFx0J2hlaWdodCc6IChuYW1lID09PSAnbWF4JyAmJiAoaGVpZ2h0ID09PSB1bmRlZmluZWQgfHwgaGVpZ2h0ID09PSAnbm9uZScgfHwgbnVtKGhlaWdodCkgPT09IC0xKSAmJiBOdW1iZXIuTUFYX1ZBTFVFKSB8fCBudW0oaGVpZ2h0KX07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbiBlbGVtZW50IGlzIHZpc2libGUuXG5cdCAqL1xuXHQkLmZuLmlzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pcygnOnZpc2libGUnKTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyBvciBnZXRzIHRoZSB2YWx1ZXMgZm9yIGJvcmRlciwgbWFyZ2luIGFuZCBwYWRkaW5nLlxuXHQgKi9cblx0JC5lYWNoKFsnYm9yZGVyJywgJ21hcmdpbicsICdwYWRkaW5nJ10sIGZ1bmN0aW9uIChpLCBuYW1lKSB7XG5cdFx0JC5mbltuYW1lXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdGlmICh2YWx1ZS50b3AgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRoaXMuY3NzKG5hbWUgKyAnLXRvcCcgKyAobmFtZSA9PT0gJ2JvcmRlcicgPyAnLXdpZHRoJyA6ICcnKSwgdmFsdWUudG9wKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodmFsdWUuYm90dG9tICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0aGlzLmNzcyhuYW1lICsgJy1ib3R0b20nICsgKG5hbWUgPT09ICdib3JkZXInID8gJy13aWR0aCcgOiAnJyksIHZhbHVlLmJvdHRvbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHZhbHVlLmxlZnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRoaXMuY3NzKG5hbWUgKyAnLWxlZnQnICsgKG5hbWUgPT09ICdib3JkZXInID8gJy13aWR0aCcgOiAnJyksIHZhbHVlLmxlZnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2YWx1ZS5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGhpcy5jc3MobmFtZSArICctcmlnaHQnICsgKG5hbWUgPT09ICdib3JkZXInID8gJy13aWR0aCcgOiAnJyksIHZhbHVlLnJpZ2h0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHt0b3A6IG51bSh0aGlzLmNzcyhuYW1lICsgJy10b3AnICsgKG5hbWUgPT09ICdib3JkZXInID8gJy13aWR0aCcgOiAnJykpKSxcblx0XHRcdFx0XHRcdGJvdHRvbTogbnVtKHRoaXMuY3NzKG5hbWUgKyAnLWJvdHRvbScgKyAobmFtZSA9PT0gJ2JvcmRlcicgPyAnLXdpZHRoJyA6ICcnKSkpLFxuXHRcdFx0XHRcdFx0bGVmdDogbnVtKHRoaXMuY3NzKG5hbWUgKyAnLWxlZnQnICsgKG5hbWUgPT09ICdib3JkZXInID8gJy13aWR0aCcgOiAnJykpKSxcblx0XHRcdFx0XHRcdHJpZ2h0OiBudW0odGhpcy5jc3MobmFtZSArICctcmlnaHQnICsgKG5hbWUgPT09ICdib3JkZXInID8gJy13aWR0aCcgOiAnJykpKX07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KTtcbn0oalF1ZXJ5KSk7XG4iLCJpbXBvcnQgJCBmcm9tICcuL2pRdWVyeSc7XG5cbiQuZm4uZXh0ZW5kKHtcblx0c3NEYXRlcGlja2VyOiBmdW5jdGlvbihvcHRzKSB7XG5cdFx0cmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmKCQodGhpcykuZGF0YSgnZGF0ZXBpY2tlcicpKSByZXR1cm47IC8vIGFscmVhZHkgYXBwbGllZFxuXG5cdFx0XHQkKHRoaXMpLnNpYmxpbmdzKFwiYnV0dG9uXCIpLmFkZENsYXNzKFwidWktaWNvbiB1aS1pY29uLWNhbGVuZGFyXCIpO1xuXHRcdFx0XG5cdFx0XHR2YXIgaG9sZGVyID0gJCh0aGlzKS5wYXJlbnRzKCcuZmllbGQuZGF0ZTpmaXJzdCcpLCBcblx0XHRcdFx0Y29uZmlnID0gJC5leHRlbmQob3B0cyB8fCB7fSwgJCh0aGlzKS5kYXRhKCksICQodGhpcykuZGF0YSgnanF1ZXJ5dWljb25maWcnKSwge30pO1xuXHRcdFx0aWYoIWNvbmZpZy5zaG93Y2FsZW5kYXIpIHJldHVybjtcblxuXHRcdFx0aWYoY29uZmlnLmxvY2FsZSAmJiAkLmRhdGVwaWNrZXIucmVnaW9uYWxbY29uZmlnLmxvY2FsZV0pIHtcblx0XHRcdFx0Y29uZmlnID0gJC5leHRlbmQoY29uZmlnLCAkLmRhdGVwaWNrZXIucmVnaW9uYWxbY29uZmlnLmxvY2FsZV0sIHt9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYoY29uZmlnLm1pbikgY29uZmlnLm1pbkRhdGUgPSAkLmRhdGVwaWNrZXIucGFyc2VEYXRlKCd5eS1tbS1kZCcsIGNvbmZpZy5taW4pO1xuXHRcdFx0aWYoY29uZmlnLm1heCkgY29uZmlnLm1heERhdGUgPSAkLmRhdGVwaWNrZXIucGFyc2VEYXRlKCd5eS1tbS1kZCcsIGNvbmZpZy5tYXgpO1xuXG5cdFx0XHQvLyBJbml0aWFsaXplIGFuZCBvcGVuIGEgZGF0ZXBpY2tlciBcblx0XHRcdC8vIGxpdmUoKSBkb2Vzbid0IGhhdmUgXCJvbm1hdGNoXCIsIGFuZCBqUXVlcnkuZW50d2luZSBpcyBhIGJpdCB0b28gaGVhdnl3ZWlnaHQgZm9yIHRoaXMsIHNvIHdlIG5lZWQgdG8gZG8gdGhpcyBvbmNsaWNrLlxuXHRcdFx0Y29uZmlnLmRhdGVGb3JtYXQgPSBjb25maWcuanF1ZXJ5ZGF0ZWZvcm1hdDtcblx0XHRcdCQodGhpcykuZGF0ZXBpY2tlcihjb25maWcpO1xuXHRcdH0pO1xuXHR9XG59KTtcblxuJChkb2N1bWVudCkub24oXCJjbGlja1wiLCBcIi5maWVsZC5kYXRlIGlucHV0LnRleHQsaW5wdXQudGV4dC5kYXRlXCIsIGZ1bmN0aW9uKCkge1xuXHQkKHRoaXMpLnNzRGF0ZXBpY2tlcigpO1xuXG5cdGlmKCQodGhpcykuZGF0YSgnZGF0ZXBpY2tlcicpKSB7XG5cdFx0JCh0aGlzKS5kYXRlcGlja2VyKCdzaG93Jyk7XG5cdH1cbn0pO1xuIiwiaW1wb3J0ICQgZnJvbSAnLi9qUXVlcnknO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi9pMThuJztcblxuJC5lbnR3aW5lKCdzcycsIGZ1bmN0aW9uKCQpIHtcblx0JCgnLnNzLWdyaWRmaWVsZCcpLmVudHdpbmUoe1xuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGpRdWVyeS5hamF4KCkgY2FsbFxuXHRcdCAqIEBwYXJhbSB7c3VjY2Vzc0NhbGxiYWNrfSBjYWxsYmFjayB0byBjYWxsIGFmdGVyIHJlbG9hZGluZyBzdWNjZWVkZWQuXG5cdFx0ICovXG5cblx0XHRyZWxvYWQ6IGZ1bmN0aW9uKGFqYXhPcHRzLCBzdWNjZXNzQ2FsbGJhY2spIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcywgZm9ybSA9IHRoaXMuY2xvc2VzdCgnZm9ybScpLFxuXHRcdFx0XHRmb2N1c2VkRWxOYW1lID0gdGhpcy5maW5kKCc6aW5wdXQ6Zm9jdXMnKS5hdHRyKCduYW1lJyksIC8vIFNhdmUgZm9jdXNlZCBlbGVtZW50IGZvciByZXN0b3JpbmcgYWZ0ZXIgcmVmcmVzaFxuXHRcdFx0XHRkYXRhID0gZm9ybS5maW5kKCc6aW5wdXQnKS5zZXJpYWxpemVBcnJheSgpO1xuXG5cdFx0XHRpZighYWpheE9wdHMpIGFqYXhPcHRzID0ge307XG5cdFx0XHRpZighYWpheE9wdHMuZGF0YSkgYWpheE9wdHMuZGF0YSA9IFtdO1xuXHRcdFx0YWpheE9wdHMuZGF0YSA9IGFqYXhPcHRzLmRhdGEuY29uY2F0KGRhdGEpO1xuXG5cblx0XHRcdC8vIEluY2x1ZGUgYW55IEdFVCBwYXJhbWV0ZXJzIGZyb20gdGhlIGN1cnJlbnQgVVJMLCBhcyB0aGUgdmlldyBzdGF0ZSBtaWdodCBkZXBlbmQgb24gaXQuXG5cdFx0XHQvLyBGb3IgZXhhbXBsZSwgYSBsaXN0IHByZWZpbHRlcmVkIHRocm91Z2ggZXh0ZXJuYWwgc2VhcmNoIGNyaXRlcmlhIG1pZ2h0IGJlIHBhc3NlZCB0byBHcmlkRmllbGQuXG5cdFx0XHRpZih3aW5kb3cubG9jYXRpb24uc2VhcmNoKSB7XG5cdFx0XHRcdGFqYXhPcHRzLmRhdGEgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgKyAnJicgKyAkLnBhcmFtKGFqYXhPcHRzLmRhdGEpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3JtLmFkZENsYXNzKCdsb2FkaW5nJyk7XG5cblx0XHRcdCQuYWpheCgkLmV4dGVuZCh7fSwge1xuXHRcdFx0XHRoZWFkZXJzOiB7XCJYLVBqYXhcIiA6ICdDdXJyZW50RmllbGQnfSxcblx0XHRcdFx0dHlwZTogXCJQT1NUXCIsXG5cdFx0XHRcdHVybDogdGhpcy5kYXRhKCd1cmwnKSxcblx0XHRcdFx0ZGF0YVR5cGU6ICdodG1sJyxcblx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHRcdC8vIFJlcGxhY2UgdGhlIGdyaWQgZmllbGQgd2l0aCByZXNwb25zZSwgbm90IHRoZSBmb3JtLlxuXHRcdFx0XHRcdC8vIFRPRE8gT25seSByZXBsYWNlcyBhbGwgaXRzIGNoaWxkcmVuLCB0byBhdm9pZCByZXBsYWNpbmcgdGhlIGN1cnJlbnQgc2NvcGVcblx0XHRcdFx0XHQvLyBvZiB0aGUgZXhlY3V0aW5nIG1ldGhvZC4gTWVhbnMgdGhhdCBpdCBkb2Vzbid0IHJldHJpZ2dlciB0aGUgb25tYXRjaCgpIG9uIHRoZSBtYWluIGNvbnRhaW5lci5cblx0XHRcdFx0XHRzZWxmLmVtcHR5KCkuYXBwZW5kKCQoZGF0YSkuY2hpbGRyZW4oKSk7XG5cblx0XHRcdFx0XHQvLyBSZWZvY3VzIHByZXZpb3VzbHkgZm9jdXNlZCBlbGVtZW50LiBVc2VmdWwgZS5nLiBmb3IgZmluZGluZythZGRpbmdcblx0XHRcdFx0XHQvLyBtdWx0aXBsZSByZWxhdGlvbnNoaXBzIHZpYSBrZXlib2FyZC5cblx0XHRcdFx0XHRpZihmb2N1c2VkRWxOYW1lKSBzZWxmLmZpbmQoJzppbnB1dFtuYW1lPVwiJyArIGZvY3VzZWRFbE5hbWUgKyAnXCJdJykuZm9jdXMoKTtcblxuXHRcdFx0XHRcdC8vIFVwZGF0ZSBmaWx0ZXJcblx0XHRcdFx0XHRpZihzZWxmLmZpbmQoJy5maWx0ZXItaGVhZGVyJykubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR2YXIgY29udGVudDtcblx0XHRcdFx0XHRcdGlmKGFqYXhPcHRzLmRhdGFbMF0uZmlsdGVyPT1cInNob3dcIikge1xuXHRcdFx0XHRcdFx0XHRjb250ZW50ID0gJzxzcGFuIGNsYXNzPVwibm9uLXNvcnRhYmxlXCI+PC9zcGFuPic7XG5cdFx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoJ3Nob3ctZmlsdGVyJykuZmluZCgnLmZpbHRlci1oZWFkZXInKS5zaG93KCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjb250ZW50ID0gJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIG5hbWU9XCJzaG93RmlsdGVyXCIgY2xhc3M9XCJzcy1ncmlkZmllbGQtYnV0dG9uLWZpbHRlciB0cmlnZ2VyXCI+PC9idXR0b24+Jztcblx0XHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcygnc2hvdy1maWx0ZXInKS5maW5kKCcuZmlsdGVyLWhlYWRlcicpLmhpZGUoKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c2VsZi5maW5kKCcuc29ydGFibGUtaGVhZGVyIHRoOmxhc3QnKS5odG1sKGNvbnRlbnQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvcm0ucmVtb3ZlQ2xhc3MoJ2xvYWRpbmcnKTtcblx0XHRcdFx0XHRpZihzdWNjZXNzQ2FsbGJhY2spIHN1Y2Nlc3NDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdHNlbGYudHJpZ2dlcigncmVsb2FkJywgc2VsZik7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yOiBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0YWxlcnQoaTE4bi5fdCgnR1JJREZJRUxELkVSUk9SSU5UUkFOU0FDVElPTicpKTtcblx0XHRcdFx0XHRmb3JtLnJlbW92ZUNsYXNzKCdsb2FkaW5nJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIGFqYXhPcHRzKSk7XG5cdFx0fSxcblx0XHRzaG93RGV0YWlsVmlldzogZnVuY3Rpb24odXJsKSB7XG5cdFx0XHR3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcblx0XHR9LFxuXHRcdGdldEl0ZW1zOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmZpbmQoJy5zcy1ncmlkZmllbGQtaXRlbScpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9XG5cdFx0ICogQHBhcmFtIHtNaXhlZH1cblx0XHQgKi9cblx0XHRzZXRTdGF0ZTogZnVuY3Rpb24oaywgdikge1xuXHRcdFx0dmFyIHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuXHRcdFx0c3RhdGVba10gPSB2O1xuXHRcdFx0dGhpcy5maW5kKCc6aW5wdXRbbmFtZT1cIicgKyB0aGlzLmRhdGEoJ25hbWUnKSArICdbR3JpZFN0YXRlXVwiXScpLnZhbChKU09OLnN0cmluZ2lmeShzdGF0ZSkpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdGdldFN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBKU09OLnBhcnNlKHRoaXMuZmluZCgnOmlucHV0W25hbWU9XCInICsgdGhpcy5kYXRhKCduYW1lJykgKyAnW0dyaWRTdGF0ZV1cIl0nKS52YWwoKSk7XG5cdFx0fVxuXHR9KTtcblxuXHQkKCcuc3MtZ3JpZGZpZWxkIConKS5lbnR3aW5lKHtcblx0XHRnZXRHcmlkRmllbGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY2xvc2VzdCgnLnNzLWdyaWRmaWVsZCcpO1xuXHRcdH1cblx0fSk7XG5cblxuXG5cdCQoJy5zcy1ncmlkZmllbGQgOmJ1dHRvbltuYW1lPXNob3dGaWx0ZXJdJykuZW50d2luZSh7XG5cdFx0b25jbGljazogZnVuY3Rpb24oZSkge1xuXHRcdFx0JCgnLmZpbHRlci1oZWFkZXInKVxuXHRcdFx0XHQuc2hvdygnc2xvdycpIC8vIGFuaW1hdGUgdmlzaWJpbGl0eVxuXHRcdFx0XHQuZmluZCgnOmlucHV0OmZpcnN0JykuZm9jdXMoKTsgLy8gZm9jdXMgZmlyc3Qgc2VhcmNoIGZpZWxkXG5cdFx0XHR0aGlzLmNsb3Nlc3QoJy5zcy1ncmlkZmllbGQnKS5hZGRDbGFzcygnc2hvdy1maWx0ZXInKTtcblx0XHRcdHRoaXMucGFyZW50KCkuaHRtbCgnPHNwYW4gY2xhc3M9XCJub24tc29ydGFibGVcIj48L3NwYW4+Jyk7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9KTtcblxuXG5cdCQoJy5zcy1ncmlkZmllbGQgLnNzLWdyaWRmaWVsZC1pdGVtJykuZW50d2luZSh7XG5cdFx0b25jbGljazogZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYoJChlLnRhcmdldCkuY2xvc2VzdCgnLmFjdGlvbicpLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLl9zdXBlcihlKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZWRpdExpbmsgPSB0aGlzLmZpbmQoJy5lZGl0LWxpbmsnKTtcblx0XHRcdGlmKGVkaXRMaW5rLmxlbmd0aCkgdGhpcy5nZXRHcmlkRmllbGQoKS5zaG93RGV0YWlsVmlldyhlZGl0TGluay5wcm9wKCdocmVmJykpO1xuXHRcdH0sXG5cdFx0b25tb3VzZW92ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYodGhpcy5maW5kKCcuZWRpdC1saW5rJykubGVuZ3RoKSB0aGlzLmNzcygnY3Vyc29yJywgJ3BvaW50ZXInKTtcblx0XHR9LFxuXHRcdG9ubW91c2VvdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5jc3MoJ2N1cnNvcicsICdkZWZhdWx0Jyk7XG5cdFx0fVxuXHR9KTtcblxuXHQkKCcuc3MtZ3JpZGZpZWxkIC5hY3Rpb24nKS5lbnR3aW5lKHtcblx0XHRvbmNsaWNrOiBmdW5jdGlvbihlKXtcblx0XHRcdHZhciBmaWx0ZXJTdGF0ZT0nc2hvdyc7IC8vZmlsdGVyc3RhdGUgc2hvdWxkIGVxdWFsIGN1cnJlbnQgc3RhdGUuXG5cblx0XHRcdC8vIElmIHRoZSBidXR0b24gaXMgZGlzYWJsZWQsIGRvIG5vdGhpbmcuXG5cdFx0XHRpZiAodGhpcy5idXR0b24oJ29wdGlvbicsICdkaXNhYmxlZCcpKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZih0aGlzLmhhc0NsYXNzKCdzcy1ncmlkZmllbGQtYnV0dG9uLWNsb3NlJykgfHwgISh0aGlzLmNsb3Nlc3QoJy5zcy1ncmlkZmllbGQnKS5oYXNDbGFzcygnc2hvdy1maWx0ZXInKSkpe1xuXHRcdFx0XHRmaWx0ZXJTdGF0ZT0naGlkZGVuJztcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5nZXRHcmlkRmllbGQoKS5yZWxvYWQoe2RhdGE6IFt7bmFtZTogdGhpcy5hdHRyKCduYW1lJyksIHZhbHVlOiB0aGlzLnZhbCgpLCBmaWx0ZXI6IGZpbHRlclN0YXRlfV19KTtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIEdldCB0aGUgdXJsIHRoaXMgYWN0aW9uIHNob3VsZCBzdWJtaXQgdG9cblx0XHQgKi9cblx0XHRhY3Rpb251cmw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGJ0biA9IHRoaXMuY2xvc2VzdCgnOmJ1dHRvbicpLCBncmlkID0gdGhpcy5nZXRHcmlkRmllbGQoKSxcblx0XHRcdFx0Zm9ybSA9IHRoaXMuY2xvc2VzdCgnZm9ybScpLCBkYXRhID0gZm9ybS5maW5kKCc6aW5wdXQuZ3JpZHN0YXRlJykuc2VyaWFsaXplKCksXG5cdFx0XHRcdGNzcmYgPSBmb3JtLmZpbmQoJ2lucHV0W25hbWU9XCJTZWN1cml0eUlEXCJdJykudmFsKCk7XG5cblx0XHRcdC8vIEFkZCBjdXJyZW50IGJ1dHRvblxuXHRcdFx0ZGF0YSArPSBcIiZcIiArIGVuY29kZVVSSUNvbXBvbmVudChidG4uYXR0cignbmFtZScpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChidG4udmFsKCkpO1xuXG5cdFx0XHQvLyBBZGQgY3NyZlxuXHRcdFx0aWYoY3NyZikge1xuXHRcdFx0XHRkYXRhICs9IFwiJlNlY3VyaXR5SUQ9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoY3NyZik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY2x1ZGUgYW55IEdFVCBwYXJhbWV0ZXJzIGZyb20gdGhlIGN1cnJlbnQgVVJMLCBhcyB0aGUgdmlld1xuXHRcdFx0Ly8gc3RhdGUgbWlnaHQgZGVwZW5kIG9uIGl0LiBGb3IgZXhhbXBsZSwgYSBsaXN0IHByZS1maWx0ZXJlZFxuXHRcdFx0Ly8gdGhyb3VnaCBleHRlcm5hbCBzZWFyY2ggY3JpdGVyaWEgbWlnaHQgYmUgcGFzc2VkIHRvIEdyaWRGaWVsZC5cblx0XHRcdGlmKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpIHtcblx0XHRcdFx0ZGF0YSA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSArICcmJyArIGRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGRlY2lkZSB3aGV0aGVyIHdlIHNob3VsZCB1c2UgPyBvciAmIHRvIGNvbm5lY3QgdGhlIFVSTFxuXHRcdFx0dmFyIGNvbm5lY3RvciA9IGdyaWQuZGF0YSgndXJsJykuaW5kZXhPZignPycpID09IC0xID8gJz8nIDogJyYnO1xuXG5cdFx0XHRyZXR1cm4gJC5wYXRoLm1ha2VVcmxBYnNvbHV0ZShcblx0XHRcdFx0Z3JpZC5kYXRhKCd1cmwnKSArIGNvbm5lY3RvciArIGRhdGEsXG5cdFx0XHRcdCQoJ2Jhc2UnKS5hdHRyKCdocmVmJylcblx0XHRcdCk7XG5cdFx0fVxuXG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBEb24ndCBhbGxvdyB1c2VycyB0byBzdWJtaXQgZW1wdHkgdmFsdWVzIGluIGdyaWQgZmllbGQgYXV0byBjb21wbGV0ZSBpbnB1dHMuXG5cdCAqL1xuXHQkKCcuc3MtZ3JpZGZpZWxkIC5hZGQtZXhpc3RpbmctYXV0b2NvbXBsZXRlcicpLmVudHdpbmUoe1xuXHRcdG9uYnV0dG9uY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRcdHRoaXMudG9nZ2xlRGlzYWJsZWQoKTtcblxuXHRcdFx0dGhpcy5maW5kKCdpbnB1dFt0eXBlPVwidGV4dFwiXScpLm9uKCdrZXl1cCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi50b2dnbGVEaXNhYmxlZCgpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRvbnVubWF0Y2g6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuZmluZCgnaW5wdXRbdHlwZT1cInRleHRcIl0nKS5vZmYoJ2tleXVwJyk7XG5cdFx0fSxcblx0XHR0b2dnbGVEaXNhYmxlZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyICRidXR0b24gPSB0aGlzLmZpbmQoJy5zcy11aS1idXR0b24nKSxcblx0XHRcdFx0JGlucHV0ID0gdGhpcy5maW5kKCdpbnB1dFt0eXBlPVwidGV4dFwiXScpLFxuXHRcdFx0XHRpbnB1dEhhc1ZhbHVlID0gJGlucHV0LnZhbCgpICE9PSAnJyxcblx0XHRcdFx0YnV0dG9uRGlzYWJsZWQgPSAkYnV0dG9uLmlzKCc6ZGlzYWJsZWQnKTtcblxuXHRcdFx0aWYgKChpbnB1dEhhc1ZhbHVlICYmIGJ1dHRvbkRpc2FibGVkKSB8fCAoIWlucHV0SGFzVmFsdWUgJiYgIWJ1dHRvbkRpc2FibGVkKSkge1xuXHRcdFx0XHQkYnV0dG9uLmJ1dHRvbihcIm9wdGlvblwiLCBcImRpc2FibGVkXCIsICFidXR0b25EaXNhYmxlZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBDb3ZlcnMgYm90aCB0YWJ1bGFyIGRlbGV0ZSBidXR0b24sIGFuZCB0aGUgYnV0dG9uIG9uIHRoZSBkZXRhaWwgZm9ybVxuXHQkKCcuc3MtZ3JpZGZpZWxkIC5jb2wtYnV0dG9ucyAuYWN0aW9uLmdyaWRmaWVsZC1idXR0b24tZGVsZXRlLCAuY21zLWVkaXQtZm9ybSAuQWN0aW9ucyBidXR0b24uYWN0aW9uLmFjdGlvbi1kZWxldGUnKS5lbnR3aW5lKHtcblx0XHRvbmNsaWNrOiBmdW5jdGlvbihlKXtcblx0XHRcdGlmKCFjb25maXJtKGkxOG4uX3QoJ1RBQkxFRklFTEQuREVMRVRFQ09ORklSTU1FU1NBR0UnKSkpIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9zdXBlcihlKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdCQoJy5zcy1ncmlkZmllbGQgLmFjdGlvbi5ncmlkZmllbGQtYnV0dG9uLXByaW50JykuZW50d2luZSh7XG5cdFx0VVVJRDogbnVsbCxcblx0XHRvbm1hdGNoOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0XHR0aGlzLnNldFVVSUQobmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuXHRcdH0sXG5cdFx0b251bm1hdGNoOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0fSxcblx0XHRvbmNsaWNrOiBmdW5jdGlvbihlKXtcblx0XHRcdHZhciB1cmwgPSB0aGlzLmFjdGlvbnVybCgpO1xuXHRcdFx0d2luZG93Lm9wZW4odXJsKTtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0pO1xuXG5cdCQoJy5zcy1ncmlkZmllbGQtcHJpbnQtaWZyYW1lJykuZW50d2luZSh7XG5cdFx0b25tYXRjaDogZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cblx0XHRcdHRoaXMuaGlkZSgpLmJpbmQoJ2xvYWQnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHR2YXIgaWZXaW4gPSB0aGlzLmNvbnRlbnRXaW5kb3cgfHwgdGhpcztcblx0XHRcdFx0aWZXaW4ucHJpbnQoKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0b251bm1hdGNoOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogUHJldmVudHMgYWN0aW9ucyBmcm9tIGNhdXNpbmcgYW4gYWpheCByZWxvYWQgb2YgdGhlIGZpZWxkLlxuXHQgKlxuXHQgKiBVc2VmdWwgZS5nLiBmb3IgYWN0aW9ucyB3aGljaCByZWx5IG9uIEhUVFAgcmVzcG9uc2UgaGVhZGVycyBiZWluZ1xuXHQgKiBpbnRlcnByZXRlZCBuYXRpdmVseSBieSB0aGUgYnJvd3NlciwgbGlrZSBmaWxlIGRvd25sb2FkIHRyaWdnZXJzLlxuXHQgKi9cblx0JCgnLnNzLWdyaWRmaWVsZCAuYWN0aW9uLm5vLWFqYXgnKS5lbnR3aW5lKHtcblx0XHRvbmNsaWNrOiBmdW5jdGlvbihlKXtcblx0XHRcdHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdGhpcy5hY3Rpb251cmwoKTtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0pO1xuXG5cdCQoJy5zcy1ncmlkZmllbGQgLmFjdGlvbi1kZXRhaWwnKS5lbnR3aW5lKHtcblx0XHRvbmNsaWNrOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuZ2V0R3JpZEZpZWxkKCkuc2hvd0RldGFpbFZpZXcoJCh0aGlzKS5wcm9wKCdocmVmJykpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIEFsbG93cyBzZWxlY3Rpb24gb2Ygb25lIG9yIG1vcmUgcm93cyBpbiB0aGUgZ3JpZCBmaWVsZC5cblx0ICogUHVyZWx5IGNsaWVudHNpZGUgYXQgdGhlIG1vbWVudC5cblx0ICovXG5cdCQoJy5zcy1ncmlkZmllbGRbZGF0YS1zZWxlY3RhYmxlXScpLmVudHdpbmUoe1xuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm4ge2pRdWVyeX0gQ29sbGVjdGlvblxuXHRcdCAqL1xuXHRcdGdldFNlbGVjdGVkSXRlbXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZmluZCgnLnNzLWdyaWRmaWVsZC1pdGVtLnVpLXNlbGVjdGVkJyk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBAcmV0dXJuIHtBcnJheX0gT2YgcmVjb3JkIElEc1xuXHRcdCAqL1xuXHRcdGdldFNlbGVjdGVkSURzOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAkLm1hcCh0aGlzLmdldFNlbGVjdGVkSXRlbXMoKSwgZnVuY3Rpb24oZWwpIHtyZXR1cm4gJChlbCkuZGF0YSgnaWQnKTt9KTtcblx0XHR9XG5cdH0pO1xuXHQkKCcuc3MtZ3JpZGZpZWxkW2RhdGEtc2VsZWN0YWJsZV0gLnNzLWdyaWRmaWVsZC1pdGVtcycpLmVudHdpbmUoe1xuXHRcdG9uYWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cblx0XHRcdC8vIFRPRE8gTGltaXQgdG8gc2luZ2xlIHNlbGVjdGlvblxuXHRcdFx0dGhpcy5zZWxlY3RhYmxlKCk7XG5cdFx0fSxcblx0XHRvbnJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdFx0aWYgKHRoaXMuZGF0YSgnc2VsZWN0YWJsZScpKSB0aGlzLnNlbGVjdGFibGUoJ2Rlc3Ryb3knKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBDYXRjaCBzdWJtaXNzaW9uIGV2ZW50IGluIGZpbHRlciBpbnB1dCBmaWVsZHMsIGFuZCBzdWJtaXQgdGhlIGNvcnJlY3QgYnV0dG9uXG5cdCAqIHJhdGhlciB0aGFuIHRoZSB3aG9sZSBmb3JtLlxuXHQgKi9cblx0JCgnLnNzLWdyaWRmaWVsZCAuZmlsdGVyLWhlYWRlciA6aW5wdXQnKS5lbnR3aW5lKHtcblx0XHRvbm1hdGNoOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBmaWx0ZXJidG4gPSB0aGlzLmNsb3Nlc3QoJy5maWVsZGdyb3VwJykuZmluZCgnLnNzLWdyaWRmaWVsZC1idXR0b24tZmlsdGVyJyksXG5cdFx0XHRcdHJlc2V0YnRuID0gdGhpcy5jbG9zZXN0KCcuZmllbGRncm91cCcpLmZpbmQoJy5zcy1ncmlkZmllbGQtYnV0dG9uLXJlc2V0Jyk7XG5cblx0XHRcdGlmKHRoaXMudmFsKCkpIHtcblx0XHRcdFx0ZmlsdGVyYnRuLmFkZENsYXNzKCdmaWx0ZXJlZCcpO1xuXHRcdFx0XHRyZXNldGJ0bi5hZGRDbGFzcygnZmlsdGVyZWQnKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0fSxcblx0XHRvbnVubWF0Y2g6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHR9LFxuXHRcdG9ua2V5ZG93bjogZnVuY3Rpb24oZSkge1xuXHRcdFx0Ly8gU2tpcCByZXNldCBidXR0b24gZXZlbnRzLCB0aGV5IHNob3VsZCB0cmlnZ2VyIGRlZmF1bHQgc3VibWlzc2lvblxuXHRcdFx0aWYodGhpcy5jbG9zZXN0KCcuc3MtZ3JpZGZpZWxkLWJ1dHRvbi1yZXNldCcpLmxlbmd0aCkgcmV0dXJuO1xuXG5cdFx0XHR2YXIgZmlsdGVyYnRuID0gdGhpcy5jbG9zZXN0KCcuZmllbGRncm91cCcpLmZpbmQoJy5zcy1ncmlkZmllbGQtYnV0dG9uLWZpbHRlcicpLFxuXHRcdFx0XHRyZXNldGJ0biA9IHRoaXMuY2xvc2VzdCgnLmZpZWxkZ3JvdXAnKS5maW5kKCcuc3MtZ3JpZGZpZWxkLWJ1dHRvbi1yZXNldCcpO1xuXG5cdFx0XHRpZihlLmtleUNvZGUgPT0gJzEzJykge1xuXHRcdFx0XHR2YXIgYnRucyA9IHRoaXMuY2xvc2VzdCgnLmZpbHRlci1oZWFkZXInKS5maW5kKCcuc3MtZ3JpZGZpZWxkLWJ1dHRvbi1maWx0ZXInKTtcblx0XHRcdFx0dmFyIGZpbHRlclN0YXRlPSdzaG93JzsgLy9maWx0ZXJzdGF0ZSBzaG91bGQgZXF1YWwgY3VycmVudCBzdGF0ZS5cblx0XHRcdFx0aWYodGhpcy5oYXNDbGFzcygnc3MtZ3JpZGZpZWxkLWJ1dHRvbi1jbG9zZScpfHwhKHRoaXMuY2xvc2VzdCgnLnNzLWdyaWRmaWVsZCcpLmhhc0NsYXNzKCdzaG93LWZpbHRlcicpKSl7XG5cdFx0XHRcdFx0ZmlsdGVyU3RhdGU9J2hpZGRlbic7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmdldEdyaWRGaWVsZCgpLnJlbG9hZCh7ZGF0YTogW3tuYW1lOiBidG5zLmF0dHIoJ25hbWUnKSwgdmFsdWU6IGJ0bnMudmFsKCksIGZpbHRlcjogZmlsdGVyU3RhdGV9XX0pO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0ZmlsdGVyYnRuLmFkZENsYXNzKCdob3Zlci1hbGlrZScpO1xuXHRcdFx0XHRyZXNldGJ0bi5hZGRDbGFzcygnaG92ZXItYWxpa2UnKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdCQoXCIuc3MtZ3JpZGZpZWxkIC5yZWxhdGlvbi1zZWFyY2hcIikuZW50d2luZSh7XG5cdFx0b25mb2N1c2luOiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdHRoaXMuYXV0b2NvbXBsZXRlKHtcblx0XHRcdFx0c291cmNlOiBmdW5jdGlvbihyZXF1ZXN0LCByZXNwb25zZSl7XG5cdFx0XHRcdFx0dmFyIHNlYXJjaEZpZWxkID0gJCh0aGlzLmVsZW1lbnQpO1xuXHRcdFx0XHRcdHZhciBmb3JtID0gJCh0aGlzLmVsZW1lbnQpLmNsb3Nlc3QoXCJmb3JtXCIpO1xuXHRcdFx0XHRcdCQuYWpheCh7XG5cdFx0XHRcdFx0XHRoZWFkZXJzOiB7XG5cdFx0XHRcdFx0XHRcdFwiWC1QamF4XCIgOiAnUGFydGlhbCdcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdFx0XHRcdFx0dXJsOiAkKHNlYXJjaEZpZWxkKS5kYXRhKCdzZWFyY2hVcmwnKSxcblx0XHRcdFx0XHRcdGRhdGE6IGVuY29kZVVSSUNvbXBvbmVudChzZWFyY2hGaWVsZC5hdHRyKCduYW1lJykpKyc9JytlbmNvZGVVUklDb21wb25lbnQoc2VhcmNoRmllbGQudmFsKCkpLFxuXHRcdFx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSggJC5tYXAoSlNPTi5wYXJzZShkYXRhKSwgZnVuY3Rpb24oIG5hbWUsIGlkICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB7IGxhYmVsOiBuYW1lLCB2YWx1ZTogbmFtZSwgaWQ6IGlkIH07XG5cdFx0XHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRlcnJvcjogZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdFx0XHRhbGVydChpMThuLl90KCdHUklERklFTEQuRVJST1JJTlRSQU5TQUNUSU9OJywgJ0FuIGVycm9yIG9jY3VyZWQgd2hpbGUgZmV0Y2hpbmcgZGF0YSBmcm9tIHRoZSBzZXJ2ZXJcXG4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci4nKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNlbGVjdDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cdFx0XHRcdFx0JCh0aGlzKS5jbG9zZXN0KFwiLnNzLWdyaWRmaWVsZFwiKS5maW5kKFwiI2FjdGlvbl9ncmlkZmllbGRfcmVsYXRpb25maW5kXCIpLnJlcGxhY2VXaXRoKFxuXHRcdFx0XHRcdFx0JzxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cInJlbGF0aW9uSURcIiB2YWx1ZT1cIicrdWkuaXRlbS5pZCsnXCIgaWQ9XCJyZWxhdGlvbklEXCIvPidcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHZhciBhZGRidXR0b24gPSAkKHRoaXMpLmNsb3Nlc3QoXCIuc3MtZ3JpZGZpZWxkXCIpLmZpbmQoXCIjYWN0aW9uX2dyaWRmaWVsZF9yZWxhdGlvbmFkZFwiKTtcblx0XHRcdFx0XHRpZihhZGRidXR0b24uZGF0YSgnYnV0dG9uJykpe1xuXHRcdFx0XHRcdFx0YWRkYnV0dG9uLmJ1dHRvbignZW5hYmxlJyk7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRhZGRidXR0b24ucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cblx0JChcIi5zcy1ncmlkZmllbGQgLnBhZ2luYXRpb24tcGFnZS1udW1iZXIgaW5wdXRcIikuZW50d2luZSh7XG5cdFx0b25rZXlkb3duOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0aWYoZXZlbnQua2V5Q29kZSA9PSAxMykge1xuXHRcdFx0XHR2YXIgbmV3cGFnZSA9IHBhcnNlSW50KCQodGhpcykudmFsKCksIDEwKTtcblxuXHRcdFx0XHR2YXIgZ3JpZGZpZWxkID0gJCh0aGlzKS5nZXRHcmlkRmllbGQoKTtcblx0XHRcdFx0Z3JpZGZpZWxkLnNldFN0YXRlKCdHcmlkRmllbGRQYWdpbmF0b3InLCB7Y3VycmVudFBhZ2U6IG5ld3BhZ2V9KTtcblx0XHRcdFx0Z3JpZGZpZWxkLnJlbG9hZCgpO1xuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufSk7XG4iLCIvKipcbiAqIEZ1bmN0aW9ucyBmb3IgSHRtbEVkaXRvckZpZWxkcyBpbiB0aGUgYmFjayBlbmQuXG4gKiBJbmNsdWRlcyB0aGUgSlMgZm9yIHRoZSBJbWFnZVVwbG9hZCBmb3Jtcy5cbiAqXG4gKiBSZWxpZXMgb24gdGhlIGpxdWVyeS5mb3JtLmpzIHBsdWdpbiB0byBwb3dlciB0aGVcbiAqIGFqYXggLyBpZnJhbWUgc3VibWlzc2lvbnNcbiAqL1xuXG5pbXBvcnQgJCBmcm9tICcuL2pRdWVyeSc7XG5pbXBvcnQgaTE4biBmcm9tICcuL2kxOG4nO1xuXG52YXIgc3MgPSB0eXBlb2Ygd2luZG93LnNzICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5zcyA6IHt9O1xuXG4vKipcbiAqIFdyYXBwZXIgZm9yIEhUTUwgV1lTSVdZRyBsaWJyYXJpZXMsIHdoaWNoIGFic3RyYWN0cyBsaWJyYXJ5IGludGVybmFsc1xuICogZnJvbSBpbnRlcmZhY2UgY29uY2VybnMgbGlrZSBpbnNlcnRpbmcgYW5kIGVkaXRpbmcgbGlua3MuXG4gKiBDYXV0aW9uOiBJbmNvbXBsZXRlIGFuZCB1bnN0YWJsZSBBUEkuXG4gKi9cbnNzLmVkaXRvcldyYXBwZXJzID0ge307XG5zcy5lZGl0b3JXcmFwcGVycy50aW55TUNFID0gKGZ1bmN0aW9uKCkge1xuXG5cdC8vIElEIG9mIGVkaXRvciB0aGlzIGlzIGFzc2lnbmVkIHRvXG5cdHZhciBlZGl0b3JJRDtcblxuXHRyZXR1cm4ge1xuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpc2UgdGhlIGVkaXRvclxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IElEIG9mIHBhcmVudCB0ZXh0YXJlYSBkb21JRFxuICAgICAgICAgKi9cblx0XHRpbml0OiBmdW5jdGlvbihJRCkge1xuXHRcdFx0ZWRpdG9ySUQgPSBJRDtcblxuXHRcdFx0dGhpcy5jcmVhdGUoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIHRoZSBlZGl0b3IgYW5kIGNsZWFudXBcblx0XHQgKi9cblx0XHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRcdHRpbnltY2UuRWRpdG9yTWFuYWdlci5leGVjQ29tbWFuZCgnbWNlUmVtb3ZlRWRpdG9yJywgZmFsc2UsIGVkaXRvcklEKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IFRpbnlNQ0UgRWRpdG9yIGluc3RhbmNlXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJucyBFZGl0b3JcbiAgICAgICAgICovXG5cdFx0Z2V0SW5zdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRpbnltY2UuRWRpdG9yTWFuYWdlci5nZXQoZWRpdG9ySUQpO1xuXHRcdH0sXG5cblx0XHQvKiooXG5cdFx0ICogSW52b2tlZCB3aGVuIGEgY29udGVudC1tb2RpZnlpbmcgVUkgaXMgb3BlbmVkLlxuXHRcdCAqL1xuXHRcdG9ub3BlbjogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBOT09QXG5cdFx0fSxcblxuXHRcdC8qKihcblx0XHQgKiBJbnZva2VkIHdoZW4gYSBjb250ZW50LW1vZGlmeWluZyBVSSBpcyBjbG9zZWQuXG5cdFx0ICovXG5cdFx0b25jbG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBOT09QXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdldCBjb25maWcgZm9yIHRoaXMgZGF0YVxuXHRcdCAqXG5cdFx0ICogQHJldHVybnMgYXJyYXlcbiAgICAgICAgICovXG5cdFx0Z2V0Q29uZmlnOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxlY3RvciA9IFwiI1wiICsgZWRpdG9ySUQsXG5cdFx0XHRcdGNvbmZpZyA9ICQoc2VsZWN0b3IpLmRhdGEoJ2NvbmZpZycpLFxuXHRcdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdFx0Ly8gQWRkIGluc3RhbmNlIHNwZWNpZmljIGRhdGEgdG8gY29uZmlnXG5cdFx0XHRjb25maWcuc2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdFx0Ly8gRW5zdXJlIHNhdmUgZXZlbnRzIHdyaXRlIGJhY2sgdG8gdGV4dGFyZWFcblx0XHRcdGNvbmZpZy5zZXR1cCA9IGZ1bmN0aW9uKGVkKSB7XG5cdFx0XHRcdGVkLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzZWxmLnNhdmUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGNvbmZpZztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogV3JpdGUgdGhlIEhUTUwgYmFjayB0byB0aGUgb3JpZ2luYWwgdGV4dCBhcmVhIGZpZWxkLlxuXHRcdCAqL1xuXHRcdHNhdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluc3RhbmNlID0gdGhpcy5nZXRJbnN0YW5jZSgpO1xuXHRcdFx0aW5zdGFuY2Uuc2F2ZSgpO1xuXG5cdFx0XHQvLyBVcGRhdGUgY2hhbmdlIGRldGVjdGlvblxuXHRcdFx0JChpbnN0YW5jZS5nZXRFbGVtZW50KCkpLnRyaWdnZXIoXCJjaGFuZ2VcIik7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBiYXNlZCBvbiBhIHRleHRhcmVhIGZpZWxkLlxuXHRcdCAqL1xuXHRcdGNyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY29uZmlnID0gdGhpcy5nZXRDb25maWcoKTtcblx0XHRcdC8vIGhhY2sgdG8gc2V0IGJhc2VVUkwgc2FmZWx5XG5cdFx0XHRpZih0eXBlb2YgY29uZmlnLmJhc2VVUkwgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHRpbnltY2UuRWRpdG9yTWFuYWdlci5iYXNlVVJMID0gY29uZmlnLmJhc2VVUkw7XG5cdFx0XHR9XG5cdFx0XHR0aW55bWNlLmluaXQoY29uZmlnKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVxdWVzdCBhbiB1cGRhdGUgdG8gZWRpdG9yIGNvbnRlbnRcblx0XHQgKi9cblx0XHRyZXBhaW50OiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIE5PT1Bcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQHJldHVybiBib29sZWFuXG5cdFx0ICovXG5cdFx0aXNEaXJ0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSgpLmlzRGlydHkoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSFRNTCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZWRpdGVkIGNvbnRlbnQuXG5cdFx0ICpcblx0XHQgKiBSZXR1cm5zOiB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGdldENvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoKS5nZXRDb250ZW50KCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERPTSB0cmVlIG9mIHRoZSBlZGl0ZWQgY29udGVudFxuXHRcdCAqXG5cdFx0ICogUmV0dXJuczogRE9NRWxlbWVudFxuXHRcdCAqL1xuXHRcdGdldERPTTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSgpLmdldEVsZW1lbnQoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuczogRE9NRWxlbWVudFxuXHRcdCAqL1xuXHRcdGdldENvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSgpLmdldENvbnRhaW5lcigpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIGNsb3Nlc3Qgbm9kZSBtYXRjaGluZyB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG5cdFx0ICpcblx0XHQgKiBSZXR1cm5zOiB7alF1ZXJ5fSBET01FbGVtZW50XG5cdFx0ICovXG5cdFx0Z2V0U2VsZWN0ZWROb2RlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldEluc3RhbmNlKCkuc2VsZWN0aW9uLmdldE5vZGUoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2VsZWN0IHRoZSBnaXZlbiBub2RlIHdpdGhpbiB0aGUgZWRpdG9yIERPTVxuXHRcdCAqXG5cdFx0ICogUGFyYW1ldGVyczoge0RPTUVsZW1lbnR9XG5cdFx0ICovXG5cdFx0c2VsZWN0Tm9kZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dGhpcy5nZXRJbnN0YW5jZSgpLnNlbGVjdGlvbi5zZWxlY3Qobm9kZSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlcGxhY2UgZW50aXJlIGNvbnRlbnRcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdHNcblx0XHQgKi9cblx0XHRzZXRDb250ZW50OiBmdW5jdGlvbihodG1sLCBvcHRzKSB7XG5cdFx0XHR0aGlzLmdldEluc3RhbmNlKCkuc2V0Q29udGVudChodG1sLCBvcHRzKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW5zZXJ0IGNvbnRlbnQgYXQgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb25cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IG9wdHNcblx0XHQgKi9cblx0XHRpbnNlcnRDb250ZW50OiBmdW5jdGlvbihodG1sLCBvcHRzKSB7XG5cdFx0XHR0aGlzLmdldEluc3RhbmNlKCkuaW5zZXJ0Q29udGVudChodG1sLCBvcHRzKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIFJlcGxhY2UgY3VycmVudGx5IHNlbGVjdGVkIGNvbnRlbnRcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG5cdFx0ICovXG5cdFx0cmVwbGFjZUNvbnRlbnQ6IGZ1bmN0aW9uKGh0bWwsIG9wdHMpIHtcblx0XHRcdHRoaXMuZ2V0SW5zdGFuY2UoKS5leGVjQ29tbWFuZCgnbWNlUmVwbGFjZUNvbnRlbnQnLCBmYWxzZSwgaHRtbCwgb3B0cyk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBJbnNlcnQgb3IgdXBkYXRlIGEgbGluayBpbiB0aGUgY29udGVudCBhcmVhIChiYXNlZCBvbiBjdXJyZW50IGVkaXRvciBzZWxlY3Rpb24pXG5cdFx0ICpcblx0XHQgKiBQYXJhbWV0ZXJzOiB7T2JqZWN0fSBhdHRyc1xuXHRcdCAqL1xuXHRcdGluc2VydExpbms6IGZ1bmN0aW9uKGF0dHJzLCBvcHRzKSB7XG5cdFx0XHR0aGlzLmdldEluc3RhbmNlKCkuZXhlY0NvbW1hbmQoXCJtY2VJbnNlcnRMaW5rXCIsIGZhbHNlLCBhdHRycywgb3B0cyk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBSZW1vdmUgdGhlIGxpbmsgZnJvbSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vZGUgKGlmIGFueSkuXG5cdFx0ICovXG5cdFx0cmVtb3ZlTGluazogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmdldEluc3RhbmNlKCkuZXhlY0NvbW1hbmQoJ3VubGluaycsIGZhbHNlKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIFN0cmlwIGFueSBlZGl0b3Itc3BlY2lmaWMgbm90YXRpb24gZnJvbSBsaW5rIGluIG9yZGVyIHRvIG1ha2UgaXQgcHJlc2VudGFibGUgaW4gdGhlIFVJLlxuXHRcdCAqXG5cdFx0ICogUGFyYW1ldGVyczpcblx0XHQgKiAge09iamVjdH1cblx0XHQgKiAge0RPTUVsZW1lbnR9XG5cdFx0ICovXG5cdFx0Y2xlYW5MaW5rOiBmdW5jdGlvbihocmVmLCBub2RlKSB7XG5cdFx0XHR2YXIgc2V0dGluZ3MgPSB0aGlzLmdldENvbmZpZyxcblx0XHRcdFx0Y2IgPSBzZXR0aW5nc1sndXJsY29udmVydGVyX2NhbGxiYWNrJ107XG5cdFx0XHRpZihjYikgaHJlZiA9IGV2YWwoY2IgKyBcIihocmVmLCBub2RlLCB0cnVlKTtcIik7XG5cblx0XHRcdC8vIFR1cm4gaW50byByZWxhdGl2ZVxuXHRcdFx0aWYoaHJlZi5tYXRjaChuZXcgUmVnRXhwKCdeJyArIHRpbnlNQ0Uuc2V0dGluZ3NbJ2RvY3VtZW50X2Jhc2VfdXJsJ10gKyAnKC4qKSQnKSkpIHtcblx0XHRcdFx0aHJlZiA9IFJlZ0V4cC4kMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR2V0IHJpZCBvZiBUaW55TUNFJ3MgdGVtcG9yYXJ5IFVSTHNcblx0XHRcdGlmKGhyZWYubWF0Y2goL15qYXZhc2NyaXB0OlxccyptY3RtcC8pKSBocmVmID0gJyc7XG5cblx0XHRcdHJldHVybiBocmVmO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBhIGJvb2ttYXJrIGZvciB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHJhbmdlLFxuXHRcdCAqIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlc2VsZWN0IHRoaXMgcmFuZ2UgYXQgYSBsYXRlciBwb2ludC5cblx0XHQgKiBAcmV0dXJuIHttaXhlZH1cblx0XHQgKi9cblx0XHRjcmVhdGVCb29rbWFyazogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSgpLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogU2VsZWN0cyBhIGJvb2ttYXJrZWQgcmFuZ2UgcHJldmlvdXNseSBzYXZlZCB0aHJvdWdoIGNyZWF0ZUJvb2ttYXJrKCkuXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IGJvb2ttYXJrXG5cdFx0ICovXG5cdFx0bW92ZVRvQm9va21hcms6IGZ1bmN0aW9uKGJvb2ttYXJrKSB7XG5cdFx0XHR0aGlzLmdldEluc3RhbmNlKCkuc2VsZWN0aW9uLm1vdmVUb0Jvb2ttYXJrKGJvb2ttYXJrKTtcblx0XHRcdHRoaXMuZ2V0SW5zdGFuY2UoKS5mb2N1cygpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlcyBhbnkgc2VsZWN0aW9uICYgZGUtZm9jdXNlcyB0aGlzIGVkaXRvclxuXHRcdCAqL1xuXHRcdGJsdXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5nZXRJbnN0YW5jZSgpLnNlbGVjdGlvbi5jb2xsYXBzZSgpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogQWRkIG5ldyB1bmRvIHBvaW50IHdpdGggdGhlIGN1cnJlbnQgRE9NIGNvbnRlbnQuXG5cdFx0ICovXG5cdFx0YWRkVW5kbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmdldEluc3RhbmNlKCkudW5kb01hbmFnZXIuYWRkKCk7XG5cdFx0fVxuXHR9O1xufSk7XG4vLyBPdmVycmlkZSB0aGlzIHRvIHN3aXRjaCBlZGl0b3Igd3JhcHBlcnNcbnNzLmVkaXRvcldyYXBwZXJzWydkZWZhdWx0J10gPSBzcy5lZGl0b3JXcmFwcGVycy50aW55TUNFO1xuXG4kLmVudHdpbmUoJ3NzJywgZnVuY3Rpb24oJCkge1xuXG5cdC8qKlxuXHQgKiBDbGFzczogdGV4dGFyZWEuaHRtbGVkaXRvclxuXHQgKlxuXHQgKiBBZGQgdGlueW1jZSB0byBIdG1sRWRpdG9yRmllbGRzIHdpdGhpbiB0aGUgQ01TLiBXb3JrcyBpbiBjb21iaW5hdGlvblxuXHQgKiB3aXRoIGEgVGlueU1DRS5pbml0KCkgY2FsbCB3aGljaCBpcyBwcmVwb3B1bGF0ZWQgd2l0aCB0aGUgdXNlZCBIVE1MRWRpdG9yQ29uZmlnIHNldHRpbmdzLFxuXHQgKiBhbmQgaW5jbHVkZWQgaW4gdGhlIHBhZ2UgYXMgYW4gaW5saW5lIDxzY3JpcHQ+IHRhZy5cblx0ICovXG5cdCQoJ3RleHRhcmVhLmh0bWxlZGl0b3InKS5lbnR3aW5lKHtcblxuXHRcdEVkaXRvcjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIENvbnN0cnVjdG9yOiBvbm1hdGNoXG5cdFx0ICovXG5cdFx0b25hZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGVkQ2xhc3MgPSB0aGlzLmRhdGEoJ2VkaXRvcicpIHx8ICdkZWZhdWx0Jyxcblx0XHRcdFx0ZWQgPSBzcy5lZGl0b3JXcmFwcGVyc1tlZENsYXNzXSgpO1xuXHRcdFx0dGhpcy5zZXRFZGl0b3IoZWQpO1xuXG5cdFx0XHRlZC5pbml0KHRoaXMuYXR0cignaWQnKSk7XG5cblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERlc3RydWN0b3I6IG9udW5tYXRjaFxuXHRcdCAqL1xuXHRcdG9ucmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuZ2V0RWRpdG9yKCkuZGVzdHJveSgpO1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTWFrZSBzdXJlIHRoZSBlZGl0b3IgaGFzIGZsdXNoZWQgYWxsIGl0J3MgYnVmZmVycyBiZWZvcmUgdGhlIGZvcm0gaXMgc3VibWl0dGVkLlxuXHRcdCAqL1xuXHRcdCdmcm9tIC5jbXMtZWRpdC1mb3JtJzoge1xuXHRcdFx0b25iZWZvcmVzdWJtaXRmb3JtOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5nZXRFZGl0b3IoKS5zYXZlKCk7XG5cdFx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRyaWdnZXJzIGluc2VydC1saW5rIGRpYWxvZ1xuXHRcdCAqIFNlZSBlZGl0b3JfcGx1Z2luX3NyYy5qc1xuXHRcdCAqL1xuXHRcdG9wZW5MaW5rRGlhbG9nOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMub3BlbkRpYWxvZygnbGluaycpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUcmlnZ2VycyBpbnNlcnQtbWVkaWEgZGlhbG9nXG5cdFx0ICogU2VlIGVkaXRvcl9wbHVnaW5fc3JjLmpzXG5cdFx0ICovXG5cdFx0b3Blbk1lZGlhRGlhbG9nOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMub3BlbkRpYWxvZygnbWVkaWEnKTtcblx0XHR9LFxuXG5cdFx0b3BlbkRpYWxvZzogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbih0ZXh0KSB7XG5cdFx0XHRcdHJldHVybiB0ZXh0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4dC5zbGljZSgxKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fTtcblxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHR1cmwgPSAkKCcjY21zLWVkaXRvci1kaWFsb2dzJykuZGF0YSgndXJsJyArIGNhcGl0YWxpemUodHlwZSkgKyAnZm9ybScpLFxuXHRcdFx0XHRkaWFsb2cgPSAkKCcuaHRtbGVkaXRvcmZpZWxkLScgKyB0eXBlICsgJ2RpYWxvZycpO1xuXG5cdFx0XHRpZihkaWFsb2cubGVuZ3RoKSB7XG5cdFx0XHRcdC8vIENsZWFuIGV4aXN0aW5nIGRpYWxvZyBmb3IgcmVsb2FkXG5cdFx0XHRcdGRpYWxvZy5nZXRGb3JtKCkuc2V0RWxlbWVudCh0aGlzKTtcblx0XHRcdFx0ZGlhbG9nLmh0bWwoJycpO1xuXHRcdFx0XHRkaWFsb2cuYWRkQ2xhc3MoJ2xvYWRpbmcnKTtcblx0XHRcdFx0ZGlhbG9nLm9wZW4oKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFNob3cgYSBwbGFjZWhvbGRlciBmb3IgaW5zdGFudCBmZWVkYmFjay4gV2lsbCBiZSByZXBsYWNlZCB3aXRoIGFjdHVhbFxuXHRcdFx0XHQvLyBmb3JtIGRpYWxvZyBvbmNlIGl0cyBsb2FkZWQuXG5cdFx0XHRcdGRpYWxvZyA9ICQoJzxkaXYgY2xhc3M9XCJodG1sZWRpdG9yZmllbGQtZGlhbG9nIGh0bWxlZGl0b3JmaWVsZC0nICsgdHlwZSArICdkaWFsb2cgbG9hZGluZ1wiPicpO1xuXHRcdFx0XHQkKCdib2R5JykuYXBwZW5kKGRpYWxvZyk7XG5cdFx0XHR9XG5cblx0XHRcdCQuYWpheCh7XG5cdFx0XHRcdHVybDogdXJsLFxuXHRcdFx0XHRjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGlhbG9nLnJlbW92ZUNsYXNzKCdsb2FkaW5nJyk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uKGh0bWwpIHtcblx0XHRcdFx0XHRkaWFsb2cuaHRtbChodG1sKTtcblx0XHRcdFx0XHRkaWFsb2cuZ2V0Rm9ybSgpLnNldEVsZW1lbnQoc2VsZik7XG5cdFx0XHRcdFx0ZGlhbG9nLnRyaWdnZXIoJ3NzZGlhbG9nb3BlbicpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xuXG5cdCQoJy5odG1sZWRpdG9yZmllbGQtZGlhbG9nJykuZW50d2luZSh7XG5cdFx0b25hZGQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDcmVhdGUgalF1ZXJ5IGRpYWxvZ1xuXHRcdFx0aWYgKCF0aGlzLmlzKCcudWktZGlhbG9nLWNvbnRlbnQnKSkge1xuXHRcdFx0XHR0aGlzLnNzZGlhbG9nKHtcblx0XHRcdFx0XHRhdXRvT3BlbjogdHJ1ZSxcblx0XHRcdFx0XHRidXR0b25zOiB7XG5cdFx0XHRcdFx0XHQnaW5zZXJ0Jzoge1xuXHRcdFx0XHRcdFx0XHR0ZXh0OiBpMThuLl90KFxuXHRcdFx0XHRcdFx0XHRcdCdIdG1sRWRpdG9yRmllbGQuSU5TRVJUJyxcblx0XHRcdFx0XHRcdFx0XHQnSW5zZXJ0J1xuXHRcdFx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdFx0XHQnZGF0YS1pY29uJzogJ2FjY2VwdCcsXG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAnc3MtdWktYWN0aW9uLWNvbnN0cnVjdGl2ZSBtZWRpYS1pbnNlcnQnLFxuXHRcdFx0XHRcdFx0XHRjbGljazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0JCh0aGlzKS5maW5kKCdmb3JtJykuc3VibWl0KCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdH0sXG5cblx0XHRnZXRGb3JtOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmZpbmQoJ2Zvcm0nKTtcblx0XHR9LFxuXHRcdG9wZW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5zc2RpYWxvZygnb3BlbicpO1xuXHRcdH0sXG5cdFx0Y2xvc2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5zc2RpYWxvZygnY2xvc2UnKTtcblx0XHR9LFxuXHRcdHRvZ2dsZTogZnVuY3Rpb24oYm9vbCkge1xuXHRcdFx0aWYodGhpcy5pcygnOnZpc2libGUnKSkgdGhpcy5jbG9zZSgpO1xuXHRcdFx0ZWxzZSB0aGlzLm9wZW4oKTtcblx0XHR9LFxuXHRcdG9uc2Nyb2xsOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmFuaW1hdGUoe1xuXHRcdFx0XHRzY3JvbGxUb3A6IHRoaXMuZmluZCgnZm9ybScpLmhlaWdodCgpXG5cdFx0XHR9LCA1MDApO1xuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIEJhc2UgZm9ybSBpbXBsZW1lbnRhdGlvbiBmb3IgaW50ZXJhY3Rpb25zIHdpdGggYW4gZWRpdG9yIGluc3RhbmNlLFxuXHQgKiBtb3N0bHkgZ2VhcmVkIHRvd2FyZHMgbW9kaWZpY2F0aW9uIGFuZCBpbnNlcnRpb24gb2YgY29udGVudC5cblx0ICovXG5cdCQoJ2Zvcm0uaHRtbGVkaXRvcmZpZWxkLWZvcm0nKS5lbnR3aW5lKHtcblx0XHRTZWxlY3Rpb246IG51bGwsXG5cblx0XHQvLyBJbXBsZW1lbnRhdGlvbi1kZXBlbmRlbnQgc2VyaWFsaXphdGlvbiBvZiB0aGUgY3VycmVudCBlZGl0b3Igc2VsZWN0aW9uIHN0YXRlXG5cdFx0Qm9va21hcms6IG51bGwsXG5cblx0XHQvLyBET01FbGVtZW50IHBvaW50aW5nIHRvIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRleHRhcmVhXG5cdFx0RWxlbWVudDogbnVsbCxcblxuXHRcdHNldFNlbGVjdGlvbjogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3N1cGVyKCQobm9kZSkpO1xuXHRcdH0sXG5cblx0XHRvbmFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBNb3ZlIHRpdGxlIGZyb20gaGVhZGxpbmUgdG8gKGpRdWVyeSBjb21wYXRpYmxlKSB0aXRsZSBhdHRyaWJ1dGVcblx0XHRcdHZhciB0aXRsZUVsID0gdGhpcy5maW5kKCc6aGVhZGVyOmZpcnN0Jyk7XG5cdFx0XHR0aGlzLmdldERpYWxvZygpLmF0dHIoJ3RpdGxlJywgdGl0bGVFbC50ZXh0KCkpO1xuXG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdH0sXG5cdFx0b25yZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5zZXRTZWxlY3Rpb24obnVsbCk7XG5cdFx0XHR0aGlzLnNldEJvb2ttYXJrKG51bGwpO1xuXHRcdFx0dGhpcy5zZXRFbGVtZW50KG51bGwpO1xuXG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdH0sXG5cblx0XHRnZXREaWFsb2c6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gVE9ETyBSZWZhY3RvciB0byBsaXN0ZW4gdG8gZm9ybSBldmVudHMgdG8gcmVtb3ZlIHR3by13YXkgY291cGxpbmdcblx0XHRcdHJldHVybiB0aGlzLmNsb3Nlc3QoJy5odG1sZWRpdG9yZmllbGQtZGlhbG9nJyk7XG5cdFx0fSxcblxuXHRcdGZyb21EaWFsb2c6IHtcblx0XHRcdG9uc3NkaWFsb2dvcGVuOiBmdW5jdGlvbigpe1xuXHRcdFx0XHR2YXIgZWQgPSB0aGlzLmdldEVkaXRvcigpO1xuXG5cdFx0XHRcdHRoaXMuc2V0U2VsZWN0aW9uKGVkLmdldFNlbGVjdGVkTm9kZSgpKTtcblx0XHRcdFx0dGhpcy5zZXRCb29rbWFyayhlZC5jcmVhdGVCb29rbWFyaygpKTtcblxuXHRcdFx0XHRlZC5ibHVyKCk7XG5cblx0XHRcdFx0dGhpcy5maW5kKCc6aW5wdXQ6bm90KDpzdWJtaXQpW2RhdGEtc2tpcC1hdXRvZm9jdXMhPVwidHJ1ZVwiXScpXG5cdFx0XHRcdFx0LmZpbHRlcignOnZpc2libGU6ZW5hYmxlZCcpXG5cdFx0XHRcdFx0LmVxKDApXG5cdFx0XHRcdFx0LmZvY3VzKCk7XG5cblx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRcdFx0dGhpcy51cGRhdGVGcm9tRWRpdG9yKCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRvbnNzZGlhbG9nY2xvc2U6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHZhciBlZCA9IHRoaXMuZ2V0RWRpdG9yKCk7XG5cblx0XHRcdFx0ZWQubW92ZVRvQm9va21hcmsodGhpcy5nZXRCb29rbWFyaygpKTtcblxuXHRcdFx0XHR0aGlzLnNldFNlbGVjdGlvbihudWxsKTtcblx0XHRcdFx0dGhpcy5zZXRCb29rbWFyayhudWxsKTtcblxuXHRcdFx0XHR0aGlzLnJlc2V0RmllbGRzKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm4gT2JqZWN0IHNzLmVkaXRvcldyYXBwZXIgaW5zdGFuY2Vcblx0XHQgKi9cblx0XHRnZXRFZGl0b3I6IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRFbGVtZW50KCkuZ2V0RWRpdG9yKCk7XG5cdFx0fSxcblxuXHRcdG1vZGlmeVNlbGVjdGlvbjogZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdHZhciBlZCA9IHRoaXMuZ2V0RWRpdG9yKCk7XG5cblx0XHRcdGVkLm1vdmVUb0Jvb2ttYXJrKHRoaXMuZ2V0Qm9va21hcmsoKSk7XG5cdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIGVkKTtcblxuXHRcdFx0dGhpcy5zZXRTZWxlY3Rpb24oZWQuZ2V0U2VsZWN0ZWROb2RlKCkpO1xuXHRcdFx0dGhpcy5zZXRCb29rbWFyayhlZC5jcmVhdGVCb29rbWFyaygpKTtcblxuXHRcdFx0ZWQuYmx1cigpO1xuXHRcdH0sXG5cblx0XHR1cGRhdGVGcm9tRWRpdG9yOiBmdW5jdGlvbigpIHtcblx0XHRcdC8qIE5PUCAqL1xuXHRcdH0sXG5cdFx0cmVkcmF3OiBmdW5jdGlvbigpIHtcblx0XHRcdC8qIE5PUCAqL1xuXHRcdH0sXG5cdFx0cmVzZXRGaWVsZHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gRmx1c2ggdGhlIHRyZWUgZHJvcCBkb3duIGZpZWxkcywgYXMgdGhlaXIgY29udGVudCBtaWdodCBnZXQgY2hhbmdlZCBpbiBvdGhlciBwYXJ0cyBvZiB0aGUgQ01TLCBpZSBpbiBGaWxlcyBhbmQgaW1hZ2VzXG5cdFx0XHR0aGlzLmZpbmQoJy50cmVlLWhvbGRlcicpLmVtcHR5KCk7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogSW5zZXJ0cyBhbmQgZWRpdHMgbGlua3MgaW4gYW4gaHRtbCBlZGl0b3IsIGluY2x1ZGluZyBpbnRlcm5hbC9leHRlcm5hbCB3ZWIgbGlua3MsXG5cdCAqIGxpbmtzIHRvIGZpbGVzIG9uIHRoZSB3ZWJzZXJ2ZXIsIGVtYWlsIGFkZHJlc3NlcywgYW5kIGFuY2hvcnMgaW4gdGhlIGV4aXN0aW5nIGh0bWwgY29udGVudC5cblx0ICogRXZlcnkgdmFyaWF0aW9uIGhhcyBpdHMgb3duIGZpZWxkcyAoZS5nLiBhIFwidGFyZ2V0XCIgYXR0cmlidXRlIGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3IgYW4gZW1haWwgbGluayksXG5cdCAqIHdoaWNoIGFyZSB0b2dnbGVkIHRocm91Z2ggYSB0eXBlIGRyb3Bkb3duLiBWYXJpYXRpb25zIHNoYXJlIGZpZWxkcywgc28gdGhlcmUncyBvbmx5IG9uZSBcInRpdGxlXCIgZmllbGQgaW4gdGhlIGZvcm0uXG5cdCAqL1xuXHQkKCdmb3JtLmh0bWxlZGl0b3JmaWVsZC1saW5rZm9ybScpLmVudHdpbmUoe1xuXG5cdFx0Ly8gVE9ETyBFbnR3aW5lIGRvZXNuJ3QgcmVzcGVjdCBzdWJtaXRzIHRyaWdnZXJlZCBieSBFTlRFUiBrZXlcblx0XHRvbnN1Ym1pdDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dGhpcy5pbnNlcnRMaW5rKCk7XG5cdFx0XHR0aGlzLmdldERpYWxvZygpLmNsb3NlKCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRyZXNldEZpZWxkczogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXG5cdFx0XHQvLyBSZXNldCB0aGUgZm9ybSB1c2luZyBhIG5hdGl2ZSBjYWxsLiBUaGlzIHdpbGwgYWxzbyBjb3JyZWN0bHkgcmVzZXQgY2hlY2tib3hlcyBhbmQgcmFkaW8gYnV0dG9ucy5cblx0XHRcdHRoaXNbMF0ucmVzZXQoKTtcblx0XHR9LFxuXHRcdHJlZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXG5cdFx0XHR2YXIgbGlua1R5cGUgPSB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUxpbmtUeXBlXTpjaGVja2VkJykudmFsKCk7XG5cblx0XHRcdHRoaXMuYWRkQW5jaG9yU2VsZWN0b3IoKTtcblxuXHRcdFx0dGhpcy5yZXNldEZpbGVGaWVsZCgpO1xuXG5cdFx0XHQvLyBUb2dnbGUgZmllbGQgdmlzaWJpbGl0eSBkZXBlbmRpbmcgb24gdGhlIGxpbmsgdHlwZS5cblx0XHRcdHRoaXMuZmluZCgnZGl2LmNvbnRlbnQgLmZpZWxkJykuaGlkZSgpO1xuXHRcdFx0dGhpcy5maW5kKCcuZmllbGRbaWQkPVwiTGlua1R5cGVcIl0nKS5zaG93KCk7XG5cdFx0XHR0aGlzLmZpbmQoJy5maWVsZFtpZCQ9XCInICsgbGlua1R5cGUgKydfSG9sZGVyXCJdJykuc2hvdygpO1xuXG5cdFx0XHRpZihsaW5rVHlwZSA9PSAnaW50ZXJuYWwnIHx8IGxpbmtUeXBlID09ICdhbmNob3InKSB7XG5cdFx0XHRcdHRoaXMuZmluZCgnLmZpZWxkW2lkJD1cIkFuY2hvcl9Ib2xkZXJcIl0nKS5zaG93KCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKGxpbmtUeXBlID09ICdlbWFpbCcpIHtcblx0XHRcdFx0dGhpcy5maW5kKCcuZmllbGRbaWQkPVwiU3ViamVjdF9Ib2xkZXJcIl0nKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmZpbmQoJy5maWVsZFtpZCQ9XCJUYXJnZXRCbGFua19Ib2xkZXJcIl0nKS5zaG93KCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKGxpbmtUeXBlID09ICdhbmNob3InKSB7XG5cdFx0XHRcdHRoaXMuZmluZCgnLmZpZWxkW2lkJD1cIkFuY2hvclNlbGVjdG9yX0hvbGRlclwiXScpLnNob3coKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZmluZCgnLmZpZWxkW2lkJD1cIkRlc2NyaXB0aW9uX0hvbGRlclwiXScpLnNob3coKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm4gT2JqZWN0IEtleXM6ICdocmVmJywgJ3RhcmdldCcsICd0aXRsZSdcblx0XHQgKi9cblx0XHRnZXRMaW5rQXR0cmlidXRlczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaHJlZixcblx0XHRcdFx0dGFyZ2V0ID0gbnVsbCxcblx0XHRcdFx0c3ViamVjdCA9IHRoaXMuZmluZCgnOmlucHV0W25hbWU9U3ViamVjdF0nKS52YWwoKSxcblx0XHRcdFx0YW5jaG9yID0gdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1BbmNob3JdJykudmFsKCk7XG5cblx0XHRcdC8vIERldGVybWluZSB0YXJnZXRcblx0XHRcdGlmKHRoaXMuZmluZCgnOmlucHV0W25hbWU9VGFyZ2V0QmxhbmtdJykuaXMoJzpjaGVja2VkJykpIHtcblx0XHRcdFx0dGFyZ2V0ID0gJ19ibGFuayc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFsbCBvdGhlciBhdHRyaWJ1dGVzXG5cdFx0XHRzd2l0Y2godGhpcy5maW5kKCc6aW5wdXRbbmFtZT1MaW5rVHlwZV06Y2hlY2tlZCcpLnZhbCgpKSB7XG5cdFx0XHRcdGNhc2UgJ2ludGVybmFsJzpcblx0XHRcdFx0XHRocmVmID0gJ1tzaXRldHJlZV9saW5rLGlkPScgKyB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPWludGVybmFsXScpLnZhbCgpICsgJ10nO1xuXG5cdFx0XHRcdFx0aWYoYW5jaG9yKSB7XG5cdFx0XHRcdFx0XHRocmVmICs9ICcjJyArIGFuY2hvcjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdhbmNob3InOlxuXHRcdFx0XHRcdGhyZWYgPSAnIycgKyBhbmNob3I7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZmlsZSc6XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlaWQgPSB0aGlzLmZpbmQoJy5zcy11cGxvYWRmaWVsZCAuc3MtdXBsb2FkZmllbGQtaXRlbScpLmF0dHIoJ2RhdGEtZmlsZWlkJyk7XG4gICAgICAgICAgICAgICAgICAgIGhyZWYgPSBmaWxlaWQgPyAnW2ZpbGVfbGluayxpZD0nICsgZmlsZWlkICsgJ10nIDogJyc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZW1haWwnOlxuXHRcdFx0XHRcdGhyZWYgPSAnbWFpbHRvOicgKyB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPWVtYWlsXScpLnZhbCgpO1xuXHRcdFx0XHRcdGlmKHN1YmplY3QpIHtcblx0XHRcdFx0XHRcdGhyZWYgKz0gJz9zdWJqZWN0PScgKyBlbmNvZGVVUklDb21wb25lbnQoc3ViamVjdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRhcmdldCA9IG51bGw7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Ly8gY2FzZSAnZXh0ZXJuYWwnOlxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGhyZWYgPSB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPWV4dGVybmFsXScpLnZhbCgpO1xuXHRcdFx0XHRcdC8vIFByZWZpeCB0aGUgVVJMIHdpdGggXCJodHRwOi8vXCIgaWYgbm8gcHJlZml4IGlzIGZvdW5kXG5cdFx0XHRcdFx0aWYoaHJlZi5pbmRleE9mKCc6Ly8nKSA9PSAtMSkgaHJlZiA9ICdodHRwOi8vJyArIGhyZWY7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGhyZWYgOiBocmVmLFxuXHRcdFx0XHR0YXJnZXQgOiB0YXJnZXQsXG5cdFx0XHRcdHRpdGxlIDogdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1EZXNjcmlwdGlvbl0nKS52YWwoKVxuXHRcdFx0fTtcblx0XHR9LFxuXHRcdGluc2VydExpbms6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5tb2RpZnlTZWxlY3Rpb24oZnVuY3Rpb24oZWQpe1xuXHRcdFx0XHRlZC5pbnNlcnRMaW5rKHRoaXMuZ2V0TGlua0F0dHJpYnV0ZXMoKSk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdHJlbW92ZUxpbms6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5tb2RpZnlTZWxlY3Rpb24oZnVuY3Rpb24oZWQpe1xuXHRcdFx0XHRlZC5yZW1vdmVMaW5rKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5yZXNldEZpbGVGaWVsZCgpO1xuXHRcdFx0dGhpcy5jbG9zZSgpO1xuXHRcdH0sXG5cblx0XHRyZXNldEZpbGVGaWVsZDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBJZiB0aGVyZSdzIGFuIGF0dGFjaGVkIGl0ZW0sIHJlbW92ZSBpdFxuXHRcdFx0dmFyIGZpbGVGaWVsZCA9IHRoaXMuZmluZCgnLnNzLXVwbG9hZGZpZWxkW2lkJD1cImZpbGVfSG9sZGVyXCJdJyksXG5cdFx0XHRcdGZpbGVVcGxvYWQgPSBmaWxlRmllbGQuZGF0YSgnZmlsZXVwbG9hZCcpLFxuXHRcdFx0XHRjdXJyZW50SXRlbSA9IGZpbGVGaWVsZC5maW5kKCcuc3MtdXBsb2FkZmllbGQtaXRlbVtkYXRhLWZpbGVpZF0nKTtcblxuXHRcdFx0aWYoY3VycmVudEl0ZW0ubGVuZ3RoKSB7XG5cdFx0XHRcdGZpbGVVcGxvYWQuX3RyaWdnZXIoJ2Rlc3Ryb3knLCBudWxsLCB7Y29udGV4dDogY3VycmVudEl0ZW19KTtcblx0XHRcdFx0ZmlsZUZpZWxkLmZpbmQoJy5zcy11cGxvYWRmaWVsZC1hZGRmaWxlJykucmVtb3ZlQ2xhc3MoJ2JvcmRlclRvcCcpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBCdWlsZHMgYW4gYW5jaG9yIHNlbGVjdG9yIGVsZW1lbnQgYW5kIGluamVjdHMgaXQgaW50byB0aGUgRE9NIG5leHQgdG8gdGhlIGFuY2hvciBmaWVsZC5cblx0XHQgKi9cblx0XHRhZGRBbmNob3JTZWxlY3RvcjogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBBdm9pZCBhZGRpbmcgdHdpY2Vcblx0XHRcdGlmKHRoaXMuZmluZCgnOmlucHV0W25hbWU9QW5jaG9yU2VsZWN0b3JdJykubGVuZ3RoKSByZXR1cm47XG5cblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhciBhbmNob3JTZWxlY3RvciA9ICQoXG5cdFx0XHRcdCc8c2VsZWN0IGlkPVwiRm9ybV9FZGl0b3JUb29sYmFyTGlua0Zvcm1fQW5jaG9yU2VsZWN0b3JcIiBuYW1lPVwiQW5jaG9yU2VsZWN0b3JcIj48L3NlbGVjdD4nXG5cdFx0XHQpO1xuXHRcdFx0dGhpcy5maW5kKCc6aW5wdXRbbmFtZT1BbmNob3JdJykucGFyZW50KCkuYXBwZW5kKGFuY2hvclNlbGVjdG9yKTtcblxuXHRcdFx0Ly8gSW5pdGlhbGlzZSB0aGUgYW5jaG9yIGRyb3Bkb3duLlxuXHRcdFx0dGhpcy51cGRhdGVBbmNob3JTZWxlY3RvcigpO1xuXG5cdFx0XHQvLyBjb3B5IHRoZSB2YWx1ZSBmcm9tIGRyb3Bkb3duIHRvIHRoZSB0ZXh0IGZpZWxkXG5cdFx0XHRhbmNob3JTZWxlY3Rvci5jaGFuZ2UoZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRzZWxmLmZpbmQoJzppbnB1dFtuYW1lPVwiQW5jaG9yXCJdJykudmFsKCQodGhpcykudmFsKCkpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZldGNoIHJlbGV2YW50IGFuY2hvcnMsIGRlcGVuZGluZyBvbiB0aGUgbGluayB0eXBlLlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiAkLkRlZmVycmVkIEEgcHJvbWlzZSBvZiBhbiBhbmNob3IgYXJyYXksIG9yIGFuIGVycm9yIG1lc3NhZ2UuXG5cdFx0ICovXG5cdFx0Z2V0QW5jaG9yczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbGlua1R5cGUgPSB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUxpbmtUeXBlXTpjaGVja2VkJykudmFsKCk7XG5cdFx0XHR2YXIgZGZkQW5jaG9ycyA9ICQuRGVmZXJyZWQoKTtcblxuXHRcdFx0c3dpdGNoIChsaW5rVHlwZSkge1xuXHRcdFx0XHRjYXNlICdhbmNob3InOlxuXHRcdFx0XHRcdC8vIEZldGNoIGZyb20gdGhlIGxvY2FsIGVkaXRvci5cblx0XHRcdFx0XHR2YXIgY29sbGVjdGVkQW5jaG9ycyA9IFtdO1xuXHRcdFx0XHRcdHZhciBlZCA9IHRoaXMuZ2V0RWRpdG9yKCk7XG5cdFx0XHRcdFx0Ly8gbmFtZSBhdHRyaWJ1dGUgaXMgZGVmaW5lZCBhcyBDREFUQSwgc2hvdWxkIGFjY2VwdCBhbGwgY2hhcmFjdGVycyBhbmQgZW50aXRpZXNcblx0XHRcdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8xOTk5L1JFQy1odG1sNDAxLTE5OTkxMjI0L3N0cnVjdC9saW5rcy5odG1sI2gtMTIuMlxuXG5cdFx0XHRcdFx0aWYoZWQpIHtcblx0XHRcdFx0XHRcdHZhciByYXcgPSBlZC5nZXRDb250ZW50KClcblx0XHRcdFx0XHRcdFx0Lm1hdGNoKC9cXHMrKG5hbWV8aWQpXFxzKj1cXHMqKFtcIiddKShbXlxcMlxccz5dKj8pXFwyfFxccysobmFtZXxpZClcXHMqPVxccyooW15cIiddKylbXFxzICs+XS9naW0pO1xuXHRcdFx0XHRcdFx0aWYgKHJhdyAmJiByYXcubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgaW5kZXhTdGFydCA9IChyYXdbaV0uaW5kZXhPZignaWQ9JykgPT0gLTEpID8gNyA6IDU7XG5cdFx0XHRcdFx0XHRcdFx0Y29sbGVjdGVkQW5jaG9ycy5wdXNoKHJhd1tpXS5zdWJzdHIoaW5kZXhTdGFydCkucmVwbGFjZSgvXCIkLywgJycpKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGRmZEFuY2hvcnMucmVzb2x2ZShjb2xsZWN0ZWRBbmNob3JzKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdpbnRlcm5hbCc6XG5cdFx0XHRcdFx0Ly8gRmV0Y2ggYXZhaWxhYmxlIGFuY2hvcnMgZnJvbSB0aGUgdGFyZ2V0IGludGVybmFsIHBhZ2UuXG5cdFx0XHRcdFx0dmFyIHBhZ2VJZCA9IHRoaXMuZmluZCgnOmlucHV0W25hbWU9aW50ZXJuYWxdJykudmFsKCk7XG5cblx0XHRcdFx0XHRpZiAocGFnZUlkKSB7XG5cdFx0XHRcdFx0XHQkLmFqYXgoe1xuXHRcdFx0XHRcdFx0XHR1cmw6ICQucGF0aC5hZGRTZWFyY2hQYXJhbXMoXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCdhY3Rpb24nKS5yZXBsYWNlKCdMaW5rRm9ybScsICdnZXRhbmNob3JzJyksXG5cdFx0XHRcdFx0XHRcdFx0eydQYWdlSUQnOiBwYXJzZUludChwYWdlSWQpfVxuXHRcdFx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdFx0XHRzdWNjZXNzOiBmdW5jdGlvbihib2R5LCBzdGF0dXMsIHhocikge1xuXHRcdFx0XHRcdFx0XHRcdGRmZEFuY2hvcnMucmVzb2x2ZSgkLnBhcnNlSlNPTihib2R5KSk7XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGVycm9yOiBmdW5jdGlvbih4aHIsIHN0YXR1cykge1xuXHRcdFx0XHRcdFx0XHRcdGRmZEFuY2hvcnMucmVqZWN0KHhoci5yZXNwb25zZVRleHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZGZkQW5jaG9ycy5yZXNvbHZlKFtdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHQvLyBUaGlzIHR5cGUgZG9lcyBub3Qgc3VwcG9ydCBhbmNob3JzIGF0IGFsbC5cblx0XHRcdFx0XHRkZmRBbmNob3JzLnJlamVjdChpMThuLl90KFxuXHRcdFx0XHRcdFx0J0h0bWxFZGl0b3JGaWVsZC5BTkNIT1JTTk9UU1VQUE9SVEVEJyxcblx0XHRcdFx0XHRcdCdBbmNob3JzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIGxpbmsgdHlwZS4nXG5cdFx0XHRcdFx0KSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkZmRBbmNob3JzLnByb21pc2UoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlIHRoZSBhbmNob3IgbGlzdCBpbiB0aGUgZHJvcGRvd24uXG5cdFx0ICovXG5cdFx0dXBkYXRlQW5jaG9yU2VsZWN0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIHNlbGVjdG9yID0gdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1BbmNob3JTZWxlY3Rvcl0nKTtcblx0XHRcdHZhciBkZmRBbmNob3JzID0gdGhpcy5nZXRBbmNob3JzKCk7XG5cblx0XHRcdC8vIEluZm9ybSB0aGUgdXNlciB3ZSBhcmUgbG9hZGluZy5cblx0XHRcdHNlbGVjdG9yLmVtcHR5KCk7XG5cdFx0XHRzZWxlY3Rvci5hcHBlbmQoJChcblx0XHRcdFx0JzxvcHRpb24gdmFsdWU9XCJcIiBzZWxlY3RlZD1cIjFcIj4nICtcblx0XHRcdFx0aTE4bi5fdCgnSHRtbEVkaXRvckZpZWxkLkxPT0tJTkdGT1JBTkNIT1JTJywgJ0xvb2tpbmcgZm9yIGFuY2hvcnMuLi4nKSArXG5cdFx0XHRcdCc8L29wdGlvbj4nXG5cdFx0XHQpKTtcblxuXHRcdFx0ZGZkQW5jaG9ycy5kb25lKGZ1bmN0aW9uKGFuY2hvcnMpIHtcblx0XHRcdFx0c2VsZWN0b3IuZW1wdHkoKTtcblx0XHRcdFx0c2VsZWN0b3IuYXBwZW5kKCQoXG5cdFx0XHRcdFx0JzxvcHRpb24gdmFsdWU9XCJcIiBzZWxlY3RlZD1cIjFcIj4nICtcblx0XHRcdFx0XHRpMThuLl90KCdIdG1sRWRpdG9yRmllbGQuU2VsZWN0QW5jaG9yJykgK1xuXHRcdFx0XHRcdCc8L29wdGlvbj4nXG5cdFx0XHRcdCkpO1xuXG5cdFx0XHRcdGlmIChhbmNob3JzKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBhbmNob3JzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0XHRzZWxlY3Rvci5hcHBlbmQoJCgnPG9wdGlvbiB2YWx1ZT1cIicrYW5jaG9yc1tqXSsnXCI+JythbmNob3JzW2pdKyc8L29wdGlvbj4nKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH0pLmZhaWwoZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdFx0XHRzZWxlY3Rvci5lbXB0eSgpO1xuXHRcdFx0XHRzZWxlY3Rvci5hcHBlbmQoJChcblx0XHRcdFx0XHQnPG9wdGlvbiB2YWx1ZT1cIlwiIHNlbGVjdGVkPVwiMVwiPicgK1xuXHRcdFx0XHRcdG1lc3NhZ2UgK1xuXHRcdFx0XHRcdCc8L29wdGlvbj4nXG5cdFx0XHRcdCkpO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIFBva2UgdGhlIHNlbGVjdG9yIGZvciBJRTgsIG90aGVyd2lzZSB0aGUgY2hhbmdlcyB3b24ndCBiZSBub3RpY2VkLlxuXHRcdFx0aWYgKCQuYnJvd3Nlci5tc2llKSBzZWxlY3Rvci5oaWRlKCkuc2hvdygpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgZGlhbG9nIGlucHV0cyB0byBtYXRjaCB0aGUgZWRpdG9yIHNlbGVjdGlvbi5cblx0XHQgKiBJZiBzZWxlY3Rpb24gZG9lcyBub3QgY29udGFpbiBhIGxpbmssIHJlc2V0cyB0aGUgZmllbGRzLlxuXHRcdCAqL1xuXHRcdHVwZGF0ZUZyb21FZGl0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGh0bWxUYWdQYXR0ZXJuID0gLzxcXFNbXj48XSo+L2csIGZpZWxkTmFtZSwgZGF0YSA9IHRoaXMuZ2V0Q3VycmVudExpbmsoKTtcblxuXHRcdFx0aWYoZGF0YSkge1xuXHRcdFx0XHRmb3IoZmllbGROYW1lIGluIGRhdGEpIHtcblx0XHRcdFx0XHR2YXIgZWwgPSB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPScgKyBmaWVsZE5hbWUgKyAnXScpLCBzZWxlY3RlZCA9IGRhdGFbZmllbGROYW1lXTtcblx0XHRcdFx0XHQvLyBSZW1vdmUgaHRtbCB0YWdzIGluIHRoZSBzZWxlY3RlZCB0ZXh0IHRoYXQgb2NjdXJzIG9uIElFIGJyb3dzZXJzXG5cdFx0XHRcdFx0aWYodHlwZW9mKHNlbGVjdGVkKSA9PSAnc3RyaW5nJykgc2VsZWN0ZWQgPSBzZWxlY3RlZC5yZXBsYWNlKGh0bWxUYWdQYXR0ZXJuLCAnJyk7XG5cblx0XHRcdFx0XHQvLyBTZXQgdmFsdWVzIGFuZCBpbnZva2UgdGhlIHRyaWdnZXJzIChlLmcuIGZvciBUcmVlRHJvcGRvd25GaWVsZCkuXG5cdFx0XHRcdFx0aWYoZWwuaXMoJzpjaGVja2JveCcpKSB7XG5cdFx0XHRcdFx0XHRlbC5wcm9wKCdjaGVja2VkJywgc2VsZWN0ZWQpLmNoYW5nZSgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZihlbC5pcygnOnJhZGlvJykpIHtcblx0XHRcdFx0XHRcdGVsLnZhbChbc2VsZWN0ZWRdKS5jaGFuZ2UoKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYoZmllbGROYW1lID09ICdmaWxlJykge1xuXHRcdFx0XHRcdFx0Ly8gVXBsb2FkRmllbGQgaW5wdXRzIGhhdmUgYSBzbGlnaHRseSBkaWZmZXJlbnQgbmFtaW5nIGNvbnZlbnRpb25cblx0XHRcdFx0XHRcdGVsID0gdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1cIicgKyBmaWVsZE5hbWUgKyAnW1VwbG9hZHNdW11cIl0nKTtcblx0XHRcdFx0XHRcdC8vIFdlIG5lZWQgdGhlIFVwbG9hZEZpZWxkIFwiZmllbGRcIiwgbm90IGp1c3QgdGhlIGlucHV0XG5cdFx0XHRcdFx0XHRlbCA9IGVsLnBhcmVudHMoJy5zcy11cGxvYWRmaWVsZCcpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBoYXZlIHRvIHdhaXQgZm9yIHRoZSBVcGxvYWRGaWVsZCB0byBpbml0aWFsaXNlXG5cdFx0XHRcdFx0XHQoZnVuY3Rpb24gYXR0YWNoKGVsLCBzZWxlY3RlZCkge1xuXHRcdFx0XHRcdFx0XHRpZiggISBlbC5nZXRDb25maWcoKSkge1xuXHRcdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgYXR0YWNoKGVsLCBzZWxlY3RlZCk7IH0sIDUwKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRlbC5hdHRhY2hGaWxlcyhbc2VsZWN0ZWRdKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSkoZWwsIHNlbGVjdGVkKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZWwudmFsKHNlbGVjdGVkKS5jaGFuZ2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbGluaywgc3VpdGFibGUgZm9yIHBvcHVsYXRpb24gb2YgdGhlIGxpbmsgZm9ybS5cblx0XHQgKlxuXHRcdCAqIFJldHVybnMgbnVsbCBpZiBubyBsaW5rIHdhcyBjdXJyZW50bHkgc2VsZWN0ZWQuXG5cdFx0ICovXG5cdFx0Z2V0Q3VycmVudExpbms6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGVjdGVkRWwgPSB0aGlzLmdldFNlbGVjdGlvbigpLFxuXHRcdFx0XHRocmVmID0gXCJcIiwgdGFyZ2V0ID0gXCJcIiwgdGl0bGUgPSBcIlwiLCBhY3Rpb24gPSBcImluc2VydFwiLCBzdHlsZV9jbGFzcyA9IFwiXCI7XG5cblx0XHRcdC8vIFdlIHVzZSBhIHNlcGFyYXRlIGZpZWxkIGZvciBsaW5rRGF0YVNvdXJjZSBmcm9tIHRpbnlNQ0UubGlua0VsZW1lbnQuXG5cdFx0XHQvLyBJZiB3ZSBoYXZlIHNlbGVjdGVkIGJleW9uZCB0aGUgcmFuZ2Ugb2YgYW4gPGE+IGVsZW1lbnQsIHRoZW4gdXNlIHVzZSB0aGF0IDxhPiBlbGVtZW50IHRvIGdldCB0aGUgbGluayBkYXRhIHNvdXJjZSxcblx0XHRcdC8vIGJ1dCB3ZSBkb24ndCB1c2UgaXQgYXMgdGhlIGRlc3RpbmF0aW9uIGZvciB0aGUgbGluayBpbnNlcnRpb25cblx0XHRcdHZhciBsaW5rRGF0YVNvdXJjZSA9IG51bGw7XG5cdFx0XHRpZihzZWxlY3RlZEVsLmxlbmd0aCkge1xuXHRcdFx0XHRpZihzZWxlY3RlZEVsLmlzKCdhJykpIHtcblx0XHRcdFx0XHQvLyBFbGVtZW50IGlzIGEgbGlua1xuXHRcdFx0XHRcdGxpbmtEYXRhU291cmNlID0gc2VsZWN0ZWRFbDtcblx0XHRcdFx0Ly8gVE9ETyBMaW1pdCB0byBpbmxpbmUgZWxlbWVudHMsIG90aGVyd2lzZSB3aWxsIGFsc28gYXBwbHkgdG8gZS5nLiBwYXJhZ3JhcGhzIHdoaWNoIGFscmVhZHkgY29udGFpbiBvbmUgb3IgbW9yZSBsaW5rc1xuXHRcdFx0XHQvLyB9IGVsc2UgaWYoKHNlbGVjdGVkRWwuZmluZCgnYScpLmxlbmd0aCkpIHtcblx0XHRcdFx0XHQvLyBcdC8vIEVsZW1lbnQgY29udGFpbnMgYSBsaW5rXG5cdFx0XHRcdFx0Ly8gXHR2YXIgZmlyc3RMaW5rRWwgPSBzZWxlY3RlZEVsLmZpbmQoJ2E6Zmlyc3QnKTtcblx0XHRcdFx0XHQvLyBcdGlmKGZpcnN0TGlua0VsLmxlbmd0aCkgbGlua0RhdGFTb3VyY2UgPSBmaXJzdExpbmtFbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBFbGVtZW50IGlzIGEgY2hpbGQgb2YgYSBsaW5rXG5cdFx0XHRcdFx0bGlua0RhdGFTb3VyY2UgPSBzZWxlY3RlZEVsID0gc2VsZWN0ZWRFbC5wYXJlbnRzKCdhOmZpcnN0Jyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKGxpbmtEYXRhU291cmNlICYmIGxpbmtEYXRhU291cmNlLmxlbmd0aCkgdGhpcy5tb2RpZnlTZWxlY3Rpb24oZnVuY3Rpb24oZWQpe1xuXHRcdFx0XHRlZC5zZWxlY3ROb2RlKGxpbmtEYXRhU291cmNlWzBdKTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBJcyBhbmNob3Igbm90IGEgbGlua1xuXHRcdFx0aWYgKCFsaW5rRGF0YVNvdXJjZS5hdHRyKCdocmVmJykpIGxpbmtEYXRhU291cmNlID0gbnVsbDtcblxuXHRcdFx0aWYgKGxpbmtEYXRhU291cmNlKSB7XG5cdFx0XHRcdGhyZWYgPSBsaW5rRGF0YVNvdXJjZS5hdHRyKCdocmVmJyk7XG5cdFx0XHRcdHRhcmdldCA9IGxpbmtEYXRhU291cmNlLmF0dHIoJ3RhcmdldCcpO1xuXHRcdFx0XHR0aXRsZSA9IGxpbmtEYXRhU291cmNlLmF0dHIoJ3RpdGxlJyk7XG5cdFx0XHRcdHN0eWxlX2NsYXNzID0gbGlua0RhdGFTb3VyY2UuYXR0cignY2xhc3MnKTtcblx0XHRcdFx0aHJlZiA9IHRoaXMuZ2V0RWRpdG9yKCkuY2xlYW5MaW5rKGhyZWYsIGxpbmtEYXRhU291cmNlKTtcblx0XHRcdFx0YWN0aW9uID0gXCJ1cGRhdGVcIjtcblx0XHRcdH1cblxuXHRcdFx0aWYoaHJlZi5tYXRjaCgvXm1haWx0bzooLiopJC8pKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0TGlua1R5cGU6ICdlbWFpbCcsXG5cdFx0XHRcdFx0ZW1haWw6IFJlZ0V4cC4kMSxcblx0XHRcdFx0XHREZXNjcmlwdGlvbjogdGl0bGVcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZihocmVmLm1hdGNoKC9eKGFzc2V0c1xcLy4qKSQvKSB8fCBocmVmLm1hdGNoKC9eXFxbZmlsZV9saW5rXFxzKig/Olxccyp8JTIwfCwpP2lkPShbMC05XSspXFxdPygjLiopPyQvKSkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdExpbmtUeXBlOiAnZmlsZScsXG5cdFx0XHRcdFx0ZmlsZTogUmVnRXhwLiQxLFxuXHRcdFx0XHRcdERlc2NyaXB0aW9uOiB0aXRsZSxcblx0XHRcdFx0XHRUYXJnZXRCbGFuazogdGFyZ2V0ID8gdHJ1ZSA6IGZhbHNlXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYoaHJlZi5tYXRjaCgvXiMoLiopJC8pKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0TGlua1R5cGU6ICdhbmNob3InLFxuXHRcdFx0XHRcdEFuY2hvcjogUmVnRXhwLiQxLFxuXHRcdFx0XHRcdERlc2NyaXB0aW9uOiB0aXRsZSxcblx0XHRcdFx0XHRUYXJnZXRCbGFuazogdGFyZ2V0ID8gdHJ1ZSA6IGZhbHNlXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2UgaWYoaHJlZi5tYXRjaCgvXlxcW3NpdGV0cmVlX2xpbmsoPzpcXHMqfCUyMHwsKT9pZD0oWzAtOV0rKVxcXT8oIy4qKT8kL2kpKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0TGlua1R5cGU6ICdpbnRlcm5hbCcsXG5cdFx0XHRcdFx0aW50ZXJuYWw6IFJlZ0V4cC4kMSxcblx0XHRcdFx0XHRBbmNob3I6IFJlZ0V4cC4kMiA/IFJlZ0V4cC4kMi5zdWJzdHIoMSkgOiAnJyxcblx0XHRcdFx0XHREZXNjcmlwdGlvbjogdGl0bGUsXG5cdFx0XHRcdFx0VGFyZ2V0Qmxhbms6IHRhcmdldCA/IHRydWUgOiBmYWxzZVxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmKGhyZWYpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRMaW5rVHlwZTogJ2V4dGVybmFsJyxcblx0XHRcdFx0XHRleHRlcm5hbDogaHJlZixcblx0XHRcdFx0XHREZXNjcmlwdGlvbjogdGl0bGUsXG5cdFx0XHRcdFx0VGFyZ2V0Qmxhbms6IHRhcmdldCA/IHRydWUgOiBmYWxzZVxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gTm8gbGluay9pbnZhbGlkIGxpbmsgc2VsZWN0ZWQuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0JCgnZm9ybS5odG1sZWRpdG9yZmllbGQtbGlua2Zvcm0gaW5wdXRbbmFtZT1MaW5rVHlwZV0nKS5lbnR3aW5lKHtcblx0XHRvbmNsaWNrOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR0aGlzLnBhcmVudHMoJ2Zvcm06Zmlyc3QnKS5yZWRyYXcoKTtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0fSxcblx0XHRvbmNoYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnBhcmVudHMoJ2Zvcm06Zmlyc3QnKS5yZWRyYXcoKTtcblxuXHRcdFx0Ly8gVXBkYXRlIGlmIGEgYW5jaG9yLXN1cHBvcnRpbmcgbGluayB0eXBlIGlzIHNlbGVjdGVkLlxuXHRcdFx0dmFyIGxpbmtUeXBlID0gdGhpcy5wYXJlbnQoKS5maW5kKCc6Y2hlY2tlZCcpLnZhbCgpO1xuXHRcdFx0aWYgKGxpbmtUeXBlPT09J2FuY2hvcicgfHwgbGlua1R5cGU9PT0naW50ZXJuYWwnKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50cygnZm9ybS5odG1sZWRpdG9yZmllbGQtbGlua2Zvcm0nKS51cGRhdGVBbmNob3JTZWxlY3RvcigpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHR9XG5cdH0pO1xuXG5cdCQoJ2Zvcm0uaHRtbGVkaXRvcmZpZWxkLWxpbmtmb3JtIGlucHV0W25hbWU9aW50ZXJuYWxdJykuZW50d2luZSh7XG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlIHRoZSBhbmNob3IgZHJvcGRvd24gaWYgYSBkaWZmZXJlbnQgcGFnZSBpcyBzZWxlY3RlZCBpbiB0aGUgXCJpbnRlcm5hbFwiIGRyb3Bkb3duLlxuXHRcdCAqL1xuXHRcdG9udmFsdWV1cGRhdGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMucGFyZW50cygnZm9ybS5odG1sZWRpdG9yZmllbGQtbGlua2Zvcm0nKS51cGRhdGVBbmNob3JTZWxlY3RvcigpO1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHR9XG5cdH0pO1xuXG5cdCQoJ2Zvcm0uaHRtbGVkaXRvcmZpZWxkLWxpbmtmb3JtIDpzdWJtaXRbbmFtZT1hY3Rpb25fcmVtb3ZlXScpLmVudHdpbmUoe1xuXHRcdG9uY2xpY2s6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHRoaXMucGFyZW50cygnZm9ybTpmaXJzdCcpLnJlbW92ZUxpbmsoKTtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogUmVzcG9uc2libGUgZm9yIGluc2VydGluZyBtZWRpYSBmaWxlcywgYWx0aG91Z2ggb25seSBpbWFnZXMgYXJlIHN1cHBvcnRlZCBzbyBmYXIuXG5cdCAqIEFsbG93cyB0byBzZWxlY3Qgb25lIG9yIG1vcmUgZmlsZXMsIGFuZCBsb2FkIGZvcm0gZmllbGRzIGZvciBlYWNoIGZpbGUgdmlhIGFqYXguXG5cdCAqIFRoaXMgYWxsb3dzIHVzIHRvIHRhaWxvciB0aGUgZm9ybSBmaWVsZHMgdG8gdGhlIGZpbGUgdHlwZSAoZS5nLiBkaWZmZXJlbnQgb25lcyBmb3IgaW1hZ2VzIGFuZCBmbGFzaCksXG5cdCAqIGFzIHdlbGwgYXMgYWRkIG5ldyBmb3JtIGZpZWxkcyB2aWEgZnJhbWV3b3JrIGV4dGVuc2lvbnMuXG5cdCAqIFRoZSBpbnB1dHMgb24gZWFjaCBvZiB0aG9zZSBmaWxlcyBhcmUgdXNlZCBmb3IgY29uc3RydWN0aW5nIHRoZSBIVE1MIHRvIGluc2VydCBpbnRvXG5cdCAqIHRoZSByaWNoIHRleHQgZWRpdG9yLiBBbHNvIGFsbG93cyBlZGl0aW5nIHRoZSBwcm9wZXJ0aWVzIG9mIGV4aXN0aW5nIGZpbGVzIGlmIGFueSBhcmUgc2VsZWN0ZWQgaW4gdGhlIGVkaXRvci5cblx0ICogTm90ZTogTm90IGVhY2ggZmlsZSBoYXMgYSByZXByZXNlbnRhdGlvbiBvbiB0aGUgd2Vic2VydmVyIGZpbGVzeXN0ZW0sIHN1cHBvcnRzIGluc2VydGlvbiBhbmQgZWRpdGluZ1xuXHQgKiBvZiByZW1vdmUgZmlsZXMgYXMgd2VsbC5cblx0ICovXG5cdCQoJ2Zvcm0uaHRtbGVkaXRvcmZpZWxkLW1lZGlhZm9ybScpLmVudHdpbmUoe1xuXHRcdHRvZ2dsZUNsb3NlQnV0dG9uOiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIHVwZGF0ZUV4aXN0aW5nID0gQm9vbGVhbih0aGlzLmZpbmQoJy5zcy1odG1sZWRpdG9yZmllbGQtZmlsZScpLmxlbmd0aCk7XG5cdFx0XHR0aGlzLmZpbmQoJy5vdmVydmlldyAuYWN0aW9uLWRlbGV0ZScpW3VwZGF0ZUV4aXN0aW5nID8gJ2hpZGUnIDogJ3Nob3cnXSgpO1xuXHRcdH0sXG5cdFx0b25zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5tb2RpZnlTZWxlY3Rpb24oZnVuY3Rpb24oZWQpe1xuXHRcdFx0XHR0aGlzLmZpbmQoJy5zcy1odG1sZWRpdG9yZmllbGQtZmlsZScpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0JCh0aGlzKS5pbnNlcnRIVE1MKGVkKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5nZXREaWFsb2coKS5jbG9zZSgpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0dXBkYXRlRnJvbUVkaXRvcjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsIG5vZGUgPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuXG5cdFx0XHQvLyBUT0RPIERlcGVuZHMgb24gbWFuYWdlZCBtaW1lIHR5cGVcblx0XHRcdGlmKG5vZGUuaXMoJ2ltZycpKSB7XG5cdFx0XHRcdHZhciBpZE9yVXJsID0gbm9kZS5kYXRhKCdpZCcpIHx8IG5vZGUuZGF0YSgndXJsJykgfHwgbm9kZS5hdHRyKCdzcmMnKTtcblx0XHRcdFx0dGhpcy5zaG93RmlsZVZpZXcoaWRPclVybCkuZG9uZShmdW5jdGlvbihmaWxlZmllbGQpIHtcblx0XHRcdFx0XHRmaWxlZmllbGQudXBkYXRlRnJvbU5vZGUobm9kZSk7XG5cdFx0XHRcdFx0c2VsZi50b2dnbGVDbG9zZUJ1dHRvbigpO1xuXHRcdFx0XHRcdHNlbGYucmVkcmF3KCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHR9LFxuXHRcdHJlZHJhdzogZnVuY3Rpb24odXBkYXRlRXhpc3RpbmcpIHtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cblx0XHRcdHZhciBub2RlID0gdGhpcy5nZXRTZWxlY3Rpb24oKSxcblx0XHRcdFx0aGFzSXRlbXMgPSBCb29sZWFuKHRoaXMuZmluZCgnLnNzLWh0bWxlZGl0b3JmaWVsZC1maWxlJykubGVuZ3RoKSxcblx0XHRcdFx0ZWRpdGluZ1NlbGVjdGVkID0gbm9kZS5pcygnaW1nJyksXG5cdFx0XHRcdGluc2VydGluZ1VSTCA9IHRoaXMuaGFzQ2xhc3MoJ2luc2VydGluZ1VSTCcpLFxuXHRcdFx0XHRoZWFkZXIgPSB0aGlzLmZpbmQoJy5oZWFkZXItZWRpdCcpO1xuXG5cdFx0XHQvLyBPbmx5IHNob3cgc2Vjb25kIHN0ZXAgaWYgZmlsZXMgYXJlIHNlbGVjdGVkXG5cdFx0XHRoZWFkZXJbKGhhc0l0ZW1zKSA/ICdzaG93JyA6ICdoaWRlJ10oKTtcblxuXHRcdFx0Ly8gRGlzYWJsZSBcImluc2VydFwiIGJ1dHRvbiBpZiBubyBmaWxlcyBhcmUgc2VsZWN0ZWRcblx0XHRcdHRoaXMuY2xvc2VzdCgndWktZGlhbG9nJylcblx0XHRcdFx0LmZpbmQoJ3VpLWRpYWxvZy1idXR0b25wYW5lIC5tZWRpYS1pbnNlcnQnKVxuXHRcdFx0XHQuYnV0dG9uKGhhc0l0ZW1zID8gJ2VuYWJsZScgOiAnZGlzYWJsZScpXG5cdFx0XHRcdC50b2dnbGVDbGFzcygndWktc3RhdGUtZGlzYWJsZWQnLCAhaGFzSXRlbXMpO1xuXG5cdFx0XHQvLyBIaWRlIGZpbGUgc2VsZWN0aW9uIGFuZCBzdGVwIGxhYmVscyB3aGVuIGVkaXRpbmcgYW4gZXhpc3RpbmcgZmlsZVxuXHRcdFx0dGhpcy5maW5kKCcuaHRtbGVkaXRvcmZpZWxkLWRlZmF1bHQtcGFuZWwnKVtlZGl0aW5nU2VsZWN0ZWQgfHwgaW5zZXJ0aW5nVVJMID8gJ2hpZGUnIDogJ3Nob3cnXSgpO1xuXHRcdFx0dGhpcy5maW5kKCcuaHRtbGVkaXRvcmZpZWxkLXdlYi1wYW5lbCcpW2VkaXRpbmdTZWxlY3RlZCB8fCAhaW5zZXJ0aW5nVVJMID8gJ2hpZGUnIDogJ3Nob3cnXSgpO1xuXG5cdFx0XHR2YXIgbWVkaWFGb3JtSGVhZGluZyA9IHRoaXMuZmluZCgnLmh0bWxlZGl0b3JmaWVsZC1tZWRpYWZvcm0taGVhZGluZy5pbnNlcnQnKTtcblxuXHRcdFx0aWYgKGVkaXRpbmdTZWxlY3RlZCkge1xuXHRcdFx0XHQvL1doZW4gZWRpdGluZyBkZXRhaWxzIG9mIGEgZmlsZVxuXHRcdFx0XHRtZWRpYUZvcm1IZWFkaW5nLmhpZGUoKTtcblx0XHRcdH0gZWxzZSBpZiAoaW5zZXJ0aW5nVVJMKSB7XG5cdFx0XHRcdC8vV2hlbiBpbnNlcnRpbmcgYW4gaW1hZ2UgZnJvbSBhIFVSTFxuXHRcdFx0XHRtZWRpYUZvcm1IZWFkaW5nXG5cdFx0XHRcdFx0LnNob3coKVxuXHRcdFx0XHRcdC50ZXh0KGkxOG4uX3QoXCJIdG1sRWRpdG9yRmllbGQuSU5TRVJUVVJMXCIpKVxuXHRcdFx0XHRcdC5wcmVwZW5kKCc8YnV0dG9uIGNsYXNzPVwiYmFjay1idXR0b24gZm9udC1pY29uLWxlZnQtb3BlbiBuby10ZXh0XCIgdGl0bGU9XCInICsgaTE4bi5fdChcIkh0bWxFZGl0b3JGaWVsZC5CQUNLXCIpICsgJ1wiPjwvYnV0dG9uPicpO1xuXG5cdFx0XHRcdHRoaXMuZmluZCgnLmh0bWxlZGl0b3JmaWVsZC13ZWItcGFuZWwgaW5wdXQucmVtb3RldXJsJykuZm9jdXMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vRGVmYXVsdCB2aWV3IHdoZW4gbW9kYWwgaXMgb3BlbmVkXG5cdFx0XHRcdG1lZGlhRm9ybUhlYWRpbmdcblx0XHRcdFx0XHQuc2hvdygpXG5cdFx0XHRcdFx0LnRleHQoaTE4bi5fdChcIkh0bWxFZGl0b3JGaWVsZC5JTlNFUlRGUk9NXCIpKVxuXHRcdFx0XHRcdC5maW5kKCcuYmFjay1idXR0b24nKS5yZW1vdmUoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVE9ETyBXYXkgdG9vIG11Y2gga25vd2xlZGdlIG9uIFVwbG9hZEZpZWxkIGludGVybmFscywgdXNlIHZpZXdmaWxlIFVSTCBkaXJlY3RseSBpbnN0ZWFkXG5cdFx0XHR0aGlzLmZpbmQoJy5odG1sZWRpdG9yZmllbGQtbWVkaWFmb3JtLWhlYWRpbmcudXBkYXRlJylbZWRpdGluZ1NlbGVjdGVkID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xuXHRcdFx0dGhpcy5maW5kKCcuc3MtdXBsb2FkZmllbGQtaXRlbS1hY3Rpb25zJylbZWRpdGluZ1NlbGVjdGVkID8gJ2hpZGUnIDogJ3Nob3cnXSgpO1xuXHRcdFx0dGhpcy5maW5kKCcuc3MtdXBsb2FkZmllbGQtaXRlbS1uYW1lJylbZWRpdGluZ1NlbGVjdGVkID8gJ2hpZGUnIDogJ3Nob3cnXSgpO1xuXHRcdFx0dGhpcy5maW5kKCcuc3MtdXBsb2FkZmllbGQtaXRlbS1wcmV2aWV3JylbZWRpdGluZ1NlbGVjdGVkID8gJ2hpZGUnIDogJ3Nob3cnXSgpO1xuXHRcdFx0dGhpcy5maW5kKCcuQWN0aW9ucyAubWVkaWEtdXBkYXRlJylbZWRpdGluZ1NlbGVjdGVkID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xuXHRcdFx0dGhpcy5maW5kKCcuc3MtdXBsb2FkZmllbGQtaXRlbS1lZGl0Zm9ybScpLnRvZ2dsZUVkaXRGb3JtKGVkaXRpbmdTZWxlY3RlZCk7XG5cdFx0XHR0aGlzLmZpbmQoJy5odG1sZWRpdG9yZmllbGQtZnJvbS1jbXMgLmZpZWxkLnRyZWVkcm9wZG93bicpLmNzcygnbGVmdCcsICQoJy5odG1sZWRpdG9yZmllbGQtbWVkaWFmb3JtLWhlYWRpbmc6dmlzaWJsZScpLm91dGVyV2lkdGgoKSk7XG5cdFx0XHR0aGlzLmNsb3Nlc3QoJy51aS1kaWFsb2cnKS5hZGRDbGFzcygnc3MtdXBsb2FkZmllbGQtZHJvcHpvbmUnKTtcblx0XHRcdHRoaXMuY2xvc2VzdCgnLnVpLWRpYWxvZycpXG5cdFx0XHRcdC5maW5kKCcudWktZGlhbG9nLWJ1dHRvbnBhbmUgLm1lZGlhLWluc2VydCAudWktYnV0dG9uLXRleHQnKVxuXHRcdFx0XHQudGV4dChbZWRpdGluZ1NlbGVjdGVkID8gaTE4bi5fdChcblx0XHRcdFx0J0h0bWxFZGl0b3JGaWVsZC5VUERBVEUnLFxuXHRcdFx0XHQnVXBkYXRlJ1xuXHRcdFx0KSA6IGkxOG4uX3QoXG5cdFx0XHRcdCdIdG1sRWRpdG9yRmllbGQuSU5TRVJUJyxcblx0XHRcdFx0J0luc2VydCdcblx0XHRcdCldKTtcblx0XHR9LFxuXHRcdHJlc2V0RmllbGRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuZmluZCgnLnNzLWh0bWxlZGl0b3JmaWVsZC1maWxlJykucmVtb3ZlKCk7IC8vIFJlbW92ZSBhbnkgZXhpc3Rpbmcgdmlld3Ncblx0XHRcdHRoaXMuZmluZCgnLnNzLWdyaWRmaWVsZC1pdGVtcyAudWktc2VsZWN0ZWQnKS5yZW1vdmVDbGFzcygndWktc2VsZWN0ZWQnKTsgLy8gVW5zZWxlY3QgYWxsIGl0ZW1zXG5cdFx0XHR0aGlzLmZpbmQoJ2xpLnNzLXVwbG9hZGZpZWxkLWl0ZW0nKS5yZW1vdmUoKTsgLy8gUmVtb3ZlIGFsbCBzZWxlY3RlZCBpdGVtc1xuXHRcdFx0dGhpcy5yZWRyYXcoKTtcblxuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHR9LFxuXHRcdGdldEZpbGVWaWV3OiBmdW5jdGlvbihpZE9yVXJsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5maW5kKCcuc3MtaHRtbGVkaXRvcmZpZWxkLWZpbGVbZGF0YS1pZD0nICsgaWRPclVybCArICddJyk7XG5cdFx0fSxcblx0XHRzaG93RmlsZVZpZXc6IGZ1bmN0aW9uKGlkT3JVcmwpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcywgcGFyYW1zID0gKE51bWJlcihpZE9yVXJsKSA9PSBpZE9yVXJsKSA/IHtJRDogaWRPclVybH0gOiB7RmlsZVVSTDogaWRPclVybH07XG5cblx0XHRcdHZhciBpdGVtID0gJCgnPGRpdiBjbGFzcz1cInNzLWh0bWxlZGl0b3JmaWVsZC1maWxlIGxvYWRpbmdcIiAvPicpO1xuXHRcdFx0dGhpcy5maW5kKCcuY29udGVudC1lZGl0JykucHJlcGVuZChpdGVtKTtcblxuXHRcdFx0dmFyIGRmciA9ICQuRGVmZXJyZWQoKTtcblxuXHRcdFx0JC5hamF4KHtcblx0XHRcdFx0dXJsOiAkLnBhdGguYWRkU2VhcmNoUGFyYW1zKHRoaXMuYXR0cignYWN0aW9uJykucmVwbGFjZSgvTWVkaWFGb3JtLywgJ3ZpZXdmaWxlJyksIHBhcmFtcyksXG5cdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uKGh0bWwsIHN0YXR1cywgeGhyKSB7XG5cdFx0XHRcdFx0dmFyIG5ld0l0ZW0gPSAkKGh0bWwpLmZpbHRlcignLnNzLWh0bWxlZGl0b3JmaWVsZC1maWxlJyk7XG5cdFx0XHRcdFx0aXRlbS5yZXBsYWNlV2l0aChuZXdJdGVtKTtcblx0XHRcdFx0XHRzZWxmLnJlZHJhdygpO1xuXHRcdFx0XHRcdGRmci5yZXNvbHZlKG5ld0l0ZW0pO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdFx0XHRkZnIucmVqZWN0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gZGZyLnByb21pc2UoKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vV2hlbiAnSW5zZXJ0IGZyb20gVVJMJyBidXR0b24gaXMgY2xpY2tlZFxuXHQkKCdmb3JtLmh0bWxlZGl0b3JmaWVsZC1tZWRpYWZvcm0gZGl2LnNzLXVwbG9hZCAudXBsb2FkLXVybCcpLmVudHdpbmUoe1xuXHRcdG9uY2xpY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBmb3JtID0gdGhpcy5jbG9zZXN0KCdmb3JtJyk7XG5cblx0XHRcdGZvcm0uYWRkQ2xhc3MoJ2luc2VydGluZ1VSTCcpO1xuXHRcdFx0Zm9ybS5yZWRyYXcoKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vV2hlbiBiYWNrIGJ1dHRvbiBpcyBjbGlja2VkIHdoaWxlIGluc2VydGluZyBVUkxcblx0JCgnZm9ybS5odG1sZWRpdG9yZmllbGQtbWVkaWFmb3JtIC5odG1sZWRpdG9yZmllbGQtbWVkaWFmb3JtLWhlYWRpbmcgLmJhY2stYnV0dG9uJykuZW50d2luZSh7XG5cdFx0b25jbGljazogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZm9ybSA9IHRoaXMuY2xvc2VzdCgnZm9ybScpO1xuXG5cdFx0XHRmb3JtLnJlbW92ZUNsYXNzKCdpbnNlcnRpbmdVUkwnKTtcblx0XHRcdGZvcm0ucmVkcmF3KCk7XG5cdFx0fVxuXHR9KTtcblxuXHQkKCdmb3JtLmh0bWxlZGl0b3JmaWVsZC1tZWRpYWZvcm0gLnNzLWdyaWRmaWVsZC1pdGVtcycpLmVudHdpbmUoe1xuXHRcdG9uc2VsZWN0YWJsZXNlbGVjdGVkOiBmdW5jdGlvbihlLCB1aSkge1xuXHRcdFx0dmFyIGZvcm0gPSB0aGlzLmNsb3Nlc3QoJ2Zvcm0nKSwgaXRlbSA9ICQodWkuc2VsZWN0ZWQpO1xuXHRcdFx0aWYoIWl0ZW0uaXMoJy5zcy1ncmlkZmllbGQtaXRlbScpKSByZXR1cm47XG5cdFx0XHRmb3JtLmNsb3Nlc3QoJ2Zvcm0nKS5zaG93RmlsZVZpZXcoaXRlbS5kYXRhKCdpZCcpKTtcblx0XHRcdGZvcm0ucmVkcmF3KCk7XG5cblx0XHRcdGZvcm0ucGFyZW50KCkudHJpZ2dlcignc2Nyb2xsJyk7XG5cdFx0fSxcblx0XHRvbnNlbGVjdGFibGV1bnNlbGVjdGVkOiBmdW5jdGlvbihlLCB1aSkge1xuXHRcdFx0dmFyIGZvcm0gPSB0aGlzLmNsb3Nlc3QoJ2Zvcm0nKSwgaXRlbSA9ICQodWkudW5zZWxlY3RlZCk7XG5cdFx0XHRpZighaXRlbS5pcygnLnNzLWdyaWRmaWVsZC1pdGVtJykpIHJldHVybjtcblx0XHRcdGZvcm0uZ2V0RmlsZVZpZXcoaXRlbS5kYXRhKCdpZCcpKS5yZW1vdmUoKTtcblx0XHRcdGZvcm0ucmVkcmF3KCk7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogU2hvdyB0aGUgc2Vjb25kIHN0ZXAgYWZ0ZXIgdXBsb2FkaW5nIGFuIGltYWdlXG5cdCAqL1xuXHQkKCdmb3JtLmh0bWxlZGl0b3JmaWVsZC1mb3JtLmh0bWxlZGl0b3JmaWVsZC1tZWRpYWZvcm0gZGl2LnNzLWFzc2V0dXBsb2FkZmllbGQnKS5lbnR3aW5lKHtcblx0XHQvL3RoZSBVcGxvYWRGaWVsZCBkaXYuc3MtdXBsb2FkZmllbGQtZWRpdGFuZG9yZ2FuaXplIGlzIGhpZGRlbiBpbiBDU1MsXG5cdFx0Ly8gYmVjYXVzZSB3ZSB1c2UgdGhlIGRldGFpbCB2aWV3IGZvciBlYWNoIGluZGl2aWR1YWwgZmlsZSBpbnN0ZWFkXG5cdFx0b25maWxldXBsb2Fkc3RvcDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIGZvcm0gPSB0aGlzLmNsb3Nlc3QoJ2Zvcm0nKTtcblxuXHRcdFx0Ly91cGRhdGUgdGhlIGVkaXRGaWVsZHMgdG8gc2hvdyB0aG9zZSBGaWxlcyB0aGF0IGFyZSBuZXdseSB1cGxvYWRlZFxuXHRcdFx0dmFyIGVkaXRGaWVsZElEcyA9IFtdO1xuXHRcdFx0Zm9ybS5maW5kKCdkaXYuY29udGVudC1lZGl0JykuZmluZCgnZGl2LnNzLWh0bWxlZGl0b3JmaWVsZC1maWxlJykuZWFjaChmdW5jdGlvbigpe1xuXHRcdFx0XHQvL2dldCB0aGUgdXBsb2FkZWQgZmlsZSBJRCB3aGVuIHRoaXMgZXZlbnQgdHJpZ2dlcnMsIHNpZ25hbGluZyB0aGUgdXBsb2FkIGhhcyBjb21wZWxldGVkIHN1Y2Nlc3NmdWxseVxuXHRcdFx0XHRlZGl0RmllbGRJRHMucHVzaCgkKHRoaXMpLmRhdGEoJ2lkJykpO1xuXHRcdFx0fSk7XG5cdFx0XHQvLyB3ZSBvbmx5IHdhbnQgdGhpcyAuc3MtdXBsb2FkZmllbGQtZmlsZXMgLSBlbHNlIHdlIGdldCBhbGwgc3MtdXBsb2FkZmllbGQtZmlsZXMgd2ljaCBpbmNsdWRlIHRoZSBvbmVzIG5vdCByZWxhdGVkIHRvICN0aW55bWNlIGluc2VydG1lZGlhXG5cdFx0XHR2YXIgdXBsb2FkZWRGaWxlcyA9ICQoJy5zcy11cGxvYWRmaWVsZC1maWxlcycsIHRoaXMpLmNoaWxkcmVuKCcuc3MtdXBsb2FkZmllbGQtaXRlbScpO1xuXHRcdFx0dXBsb2FkZWRGaWxlcy5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHZhciB1cGxvYWRlZElEID0gJCh0aGlzKS5kYXRhKCdmaWxlaWQnKTtcblx0XHRcdFx0aWYgKHVwbG9hZGVkSUQgJiYgJC5pbkFycmF5KHVwbG9hZGVkSUQsIGVkaXRGaWVsZElEcykgPT0gLTEpIHtcblx0XHRcdFx0XHQvL3RyaWdnZXIgdGhlIGRldGFpbCB2aWV3IGZvciBmaWxsaW5nIG91dCBkZXRhaWxzIGFib3V0IHRoZSBmaWxlIHdlIGFyZSBhYm91dCB0byBpbnNlcnQgaW50byBUaW55TUNFXG5cdFx0XHRcdFx0JCh0aGlzKS5yZW1vdmUoKTsgLy8gUmVtb3ZlIHN1Y2Nlc3NmdWxseSBhZGRlZCBpdGVtIGZyb20gdGhlIHF1ZXVlXG5cdFx0XHRcdFx0Zm9ybS5zaG93RmlsZVZpZXcodXBsb2FkZWRJRCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRmb3JtLnBhcmVudCgpLnRyaWdnZXIoJ3Njcm9sbCcpO1xuXG5cdFx0XHRmb3JtLnJlZHJhdygpO1xuXHRcdH1cblxuXHR9KTtcblxuXHQkKCdmb3JtLmh0bWxlZGl0b3JmaWVsZC1mb3JtLmh0bWxlZGl0b3JmaWVsZC1tZWRpYWZvcm0gaW5wdXQucmVtb3RldXJsJykuZW50d2luZSh7XG5cdFx0b25hZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHRcdHRoaXMudmFsaWRhdGUoKTtcblx0XHR9LFxuXG5cdFx0b25rZXl1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnZhbGlkYXRlKCk7XG5cdFx0fSxcblxuXHRcdG9uY2hhbmdlOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMudmFsaWRhdGUoKTtcblx0XHR9LFxuXG5cdFx0Z2V0QWRkQnV0dG9uOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmNsb3Nlc3QoJy5Db21wb3NpdGVGaWVsZCcpLmZpbmQoJ2J1dHRvbi5hZGQtdXJsJyk7XG5cdFx0fSxcblxuXHRcdHZhbGlkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB2YWwgPSB0aGlzLnZhbCgpLCBvcmlnID0gdmFsO1xuXG5cdFx0XHR2YWwgPSAkLnRyaW0odmFsKTtcblx0XHRcdHZhbCA9IHZhbC5yZXBsYWNlKC9eaHR0cHM/OlxcL1xcLy9pLCAnJyk7XG5cdFx0XHRpZiAob3JpZyAhPT0gdmFsKSB0aGlzLnZhbCh2YWwpO1xuXG5cdFx0XHR0aGlzLmdldEFkZEJ1dHRvbigpLmJ1dHRvbighIXZhbCA/ICdlbmFibGUnIDogJ2Rpc2FibGUnKTtcblx0XHRcdHJldHVybiAhIXZhbDtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBTaG93IHRoZSBzZWNvbmQgc3RlcCBhZnRlciBhZGRpbmcgYSBVUkxcblx0ICovXG5cdCQoJ2Zvcm0uaHRtbGVkaXRvcmZpZWxkLWZvcm0uaHRtbGVkaXRvcmZpZWxkLW1lZGlhZm9ybSAuYWRkLXVybCcpLmVudHdpbmUoe1xuXHRcdGdldFVSTEZpZWxkOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmNsb3Nlc3QoJy5Db21wb3NpdGVGaWVsZCcpLmZpbmQoJ2lucHV0LnJlbW90ZXVybCcpO1xuXHRcdH0sXG5cblx0XHRvbmNsaWNrOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgdXJsRmllbGQgPSB0aGlzLmdldFVSTEZpZWxkKCksIGNvbnRhaW5lciA9IHRoaXMuY2xvc2VzdCgnLkNvbXBvc2l0ZUZpZWxkJyksIGZvcm0gPSB0aGlzLmNsb3Nlc3QoJ2Zvcm0nKTtcblxuXHRcdFx0aWYgKHVybEZpZWxkLnZhbGlkYXRlKCkpIHtcblx0XHRcdFx0Y29udGFpbmVyLmFkZENsYXNzKCdsb2FkaW5nJyk7XG5cdFx0XHRcdGZvcm0uc2hvd0ZpbGVWaWV3KCdodHRwOi8vJyArIHVybEZpZWxkLnZhbCgpKS5kb25lKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNvbnRhaW5lci5yZW1vdmVDbGFzcygnbG9hZGluZycpO1xuXG5cdFx0XHRcdFx0Zm9ybS5wYXJlbnQoKS50cmlnZ2VyKCdzY3JvbGwnKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGZvcm0ucmVkcmF3KCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBSZXByZXNlbnRzIGEgc2luZ2xlIHNlbGVjdGVkIGZpbGUsIHRvZ2V0aGVyIHdpdGggYSBzZXQgb2YgZm9ybSBmaWVsZHMgdG8gZWRpdCBpdHMgcHJvcGVydGllcy5cblx0ICogT3ZlcmxvYWQgdGhpcyBiYXNlZCBvbiB0aGUgbWVkaWEgdHlwZSB0byBkZXRlcm1pbmUgaG93IHRoZSBIVE1MIHNob3VsZCBiZSBjcmVhdGVkLlxuXHQgKi9cblx0JCgnZm9ybS5odG1sZWRpdG9yZmllbGQtbWVkaWFmb3JtIC5zcy1odG1sZWRpdG9yZmllbGQtZmlsZScpLmVudHdpbmUoe1xuXHRcdC8qKlxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gTWFwIG9mIEhUTUwgYXR0cmlidXRlcyB3aGljaCBjYW4gYmUgc2V0IG9uIHRoZSBjcmVhdGVkIERPTSBub2RlLlxuXHRcdCAqL1xuXHRcdGdldEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBNYXAgb2YgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHdoaWNoIGNhbiBiZSBldmFsdWF0ZWRcblx0XHQgKiBieSB0aGUgc3BlY2lmaWMgbWVkaWEgdHlwZS5cblx0XHQgKi9cblx0XHRnZXRFeHRyYURhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBIVE1MIHN1aXRhYmxlIGZvciBpbnNlcnRpb24gaW50byB0aGUgcmljaCB0ZXh0IGVkaXRvclxuXHRcdCAqL1xuXHRcdGdldEhUTUw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gQXNzdW1lcyBVcGxvYWRGaWVsZCBtYXJrdXAgc3RydWN0dXJlXG5cdFx0XHRyZXR1cm4gJCgnPGRpdj4nKS5hcHBlbmQoXG5cdFx0XHRcdCQoJzxhLz4nKS5hdHRyKHtocmVmOiB0aGlzLmRhdGEoJ3VybCcpfSkudGV4dCh0aGlzLmZpbmQoJy5uYW1lJykudGV4dCgpKVxuXHRcdFx0KS5odG1sKCk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBJbnNlcnQgdXBkYXRlZCBIVE1MIGNvbnRlbnQgaW50byB0aGUgcmljaCB0ZXh0IGVkaXRvclxuXHRcdCAqL1xuXHRcdGluc2VydEhUTUw6IGZ1bmN0aW9uKGVkKSB7XG5cdFx0XHQvLyBJbnNlcnQgY29udGVudFxuXHRcdFx0ZWQucmVwbGFjZUNvbnRlbnQodGhpcy5nZXRIVE1MKCkpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlcyB0aGUgZm9ybSB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBub2RlIGluIHRoZSBlZGl0b3IuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0RPTUVsZW1lbnR9XG5cdFx0ICovXG5cdFx0dXBkYXRlRnJvbU5vZGU6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIFRyYW5zZm9ybXMgdmFsdWVzIHNldCBvbiB0aGUgZGltZW5zaW9ucyBmb3JtIGZpZWxkcyBiYXNlZCBvbiB0d28gY29uc3RyYWludHM6XG5cdFx0ICogQW4gYXNwZWN0IHJhdGlvbiwgYW5kIG1heCB3aWR0aC9oZWlnaHQgdmFsdWVzLiBXcml0ZXMgYmFjayB0byB0aGUgZmllbGQgcHJvcGVydGllcyBhcyByZXF1aXJlZC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBUaGUgZGltZW5zaW9uIHRvIGNvbnN0cmFpbiB0aGUgb3RoZXIgdmFsdWUgYnksIGlmIGFueSAoXCJXaWR0aFwiIG9yIFwiSGVpZ2h0XCIpXG5cdFx0ICogQHBhcmFtIHtJbnR9IE9wdGlvbmFsIG1heCB3aWR0aFxuXHRcdCAqIEBwYXJhbSB7SW50fSBPcHRpb25hbCBtYXggaGVpZ2h0XG5cdFx0ICovXG5cdFx0dXBkYXRlRGltZW5zaW9uczogZnVuY3Rpb24oY29uc3RyYWluQnksIG1heFcsIG1heEgpIHtcblx0XHRcdHZhciB3aWR0aEVsID0gdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1XaWR0aF0nKSxcblx0XHRcdFx0aGVpZ2h0RWwgPSB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUhlaWdodF0nKSxcblx0XHRcdFx0dyA9IHdpZHRoRWwudmFsKCksXG5cdFx0XHRcdGggPSBoZWlnaHRFbC52YWwoKSxcblx0XHRcdFx0YXNwZWN0O1xuXG5cdFx0XHQvLyBQcm9wb3J0aW9uYXRlIHVwZGF0aW5nIG9mIGhlaWdodHMsIHVzaW5nIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdGlmKHcgJiYgaCkge1xuXHRcdFx0XHRpZihjb25zdHJhaW5CeSkge1xuXHRcdFx0XHRcdGFzcGVjdCA9IGhlaWdodEVsLmdldE9yaWdWYWwoKSAvIHdpZHRoRWwuZ2V0T3JpZ1ZhbCgpO1xuXHRcdFx0XHRcdC8vIFVzZXMgZmxvb3IoKSBhbmQgY2VpbCgpIHRvIGF2b2lkIGJvdGggZmllbGRzIGNvbnN0YW50bHkgbG93ZXJpbmcgZWFjaCBvdGhlcidzIHZhbHVlcyBpbiByb3VuZGluZyBzaXR1YXRpb25zXG5cdFx0XHRcdFx0aWYoY29uc3RyYWluQnkgPT0gJ1dpZHRoJykge1xuXHRcdFx0XHRcdFx0aWYobWF4VyAmJiB3ID4gbWF4VykgdyA9IG1heFc7XG5cdFx0XHRcdFx0XHRoID0gTWF0aC5mbG9vcih3ICogYXNwZWN0KTtcblx0XHRcdFx0XHR9IGVsc2UgaWYoY29uc3RyYWluQnkgPT0gJ0hlaWdodCcpIHtcblx0XHRcdFx0XHRcdGlmKG1heEggJiYgaCA+IG1heEgpIGggPSBtYXhIO1xuXHRcdFx0XHRcdFx0dyA9IE1hdGguY2VpbChoIC8gYXNwZWN0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYobWF4VyAmJiB3ID4gbWF4VykgdyA9IG1heFc7XG5cdFx0XHRcdFx0aWYobWF4SCAmJiBoID4gbWF4SCkgaCA9IG1heEg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3aWR0aEVsLnZhbCh3KTtcblx0XHRcdFx0aGVpZ2h0RWwudmFsKGgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0JCgnZm9ybS5odG1sZWRpdG9yZmllbGQtbWVkaWFmb3JtIC5zcy1odG1sZWRpdG9yZmllbGQtZmlsZS5pbWFnZScpLmVudHdpbmUoe1xuXHRcdGdldEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHdpZHRoID0gdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1XaWR0aF0nKS52YWwoKSxcblx0XHRcdFx0aGVpZ2h0ID0gdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1IZWlnaHRdJykudmFsKCk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHQnc3JjJyA6IHRoaXMuZmluZCgnOmlucHV0W25hbWU9VVJMXScpLnZhbCgpLFxuXHRcdFx0XHQnYWx0JyA6IHRoaXMuZmluZCgnOmlucHV0W25hbWU9QWx0VGV4dF0nKS52YWwoKSxcblx0XHRcdFx0J3dpZHRoJyA6IHdpZHRoID8gcGFyc2VJbnQod2lkdGgsIDEwKSA6IG51bGwsXG5cdFx0XHRcdCdoZWlnaHQnIDogaGVpZ2h0ID8gcGFyc2VJbnQoaGVpZ2h0LCAxMCkgOiBudWxsLFxuXHRcdFx0XHQndGl0bGUnIDogdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1UaXRsZV0nKS52YWwoKSxcblx0XHRcdFx0J2NsYXNzJyA6IHRoaXMuZmluZCgnOmlucHV0W25hbWU9Q1NTQ2xhc3NdJykudmFsKCksXG5cdFx0XHRcdCdkYXRhLWlkJyA6IHRoaXMuZmluZCgnOmlucHV0W25hbWU9RmlsZUlEXScpLnZhbCgpXG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0Z2V0RXh0cmFEYXRhOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdCdDYXB0aW9uVGV4dCc6IHRoaXMuZmluZCgnOmlucHV0W25hbWU9Q2FwdGlvblRleHRdJykudmFsKClcblx0XHRcdH07XG5cdFx0fSxcblx0XHRnZXRIVE1MOiBmdW5jdGlvbigpIHtcblx0XHRcdC8qIE5PUCAqL1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogTG9naWMgc2ltaWxhciB0byBUaW55TUNFICdhZHZpbWFnZScgcGx1Z2luLCBpbnNlcnRBbmRDbG9zZSgpIG1ldGhvZC5cblx0XHQgKi9cblx0XHRpbnNlcnRIVE1MOiBmdW5jdGlvbihlZCkge1xuXHRcdFx0dmFyIGZvcm0gPSB0aGlzLmNsb3Nlc3QoJ2Zvcm0nKTtcblx0XHRcdHZhciBub2RlID0gZm9ybS5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdGlmICghZWQpIGVkID0gZm9ybS5nZXRFZGl0b3IoKTtcblxuXHRcdFx0Ly8gR2V0IHRoZSBhdHRyaWJ1dGVzICYgZXh0cmEgZGF0YVxuXHRcdFx0dmFyIGF0dHJzID0gdGhpcy5nZXRBdHRyaWJ1dGVzKCksIGV4dHJhRGF0YSA9IHRoaXMuZ2V0RXh0cmFEYXRhKCk7XG5cblx0XHRcdC8vIEZpbmQgdGhlIGVsZW1lbnQgd2UgYXJlIHJlcGxhY2luZyAtIGVpdGhlciB0aGUgaW1nLCBpdCdzIHdyYXBwZXIgcGFyZW50LCBvciBub3RoaW5nIChpZiBjcmVhdGluZylcblx0XHRcdHZhciByZXBsYWNlZSA9IChub2RlICYmIG5vZGUuaXMoJ2ltZycpKSA/IG5vZGUgOiBudWxsO1xuXHRcdFx0aWYgKHJlcGxhY2VlICYmIHJlcGxhY2VlLnBhcmVudCgpLmlzKCcuY2FwdGlvbkltYWdlJykpIHJlcGxhY2VlID0gcmVwbGFjZWUucGFyZW50KCk7XG5cblx0XHRcdC8vIEZpbmQgdGhlIGltZyBub2RlIC0gZWl0aGVyIHRoZSBleGlzdGluZyBpbWcgb3IgYSBuZXcgb25lLCBhbmQgdXBkYXRlIGl0XG5cdFx0XHR2YXIgaW1nID0gKG5vZGUgJiYgbm9kZS5pcygnaW1nJykpID8gbm9kZSA6ICQoJzxpbWcgLz4nKTtcblx0XHRcdGltZy5hdHRyKGF0dHJzKTtcblxuXHRcdFx0Ly8gQW55IGV4aXN0aW5nIGZpZ3VyZSBvciBjYXB0aW9uIG5vZGVcblx0XHRcdHZhciBjb250YWluZXIgPSBpbWcucGFyZW50KCcuY2FwdGlvbkltYWdlJyksIGNhcHRpb24gPSBjb250YWluZXIuZmluZCgnLmNhcHRpb24nKTtcblxuXHRcdFx0Ly8gSWYgd2UndmUgZ290IGNhcHRpb24gdGV4dCwgd2UgbmVlZCBhIHdyYXBwaW5nIGRpdi5jYXB0aW9uSW1hZ2UgYW5kIHNpYmxpbmcgcC5jYXB0aW9uXG5cdFx0XHRpZiAoZXh0cmFEYXRhLkNhcHRpb25UZXh0KSB7XG5cdFx0XHRcdGlmICghY29udGFpbmVyLmxlbmd0aCkge1xuXHRcdFx0XHRcdGNvbnRhaW5lciA9ICQoJzxkaXY+PC9kaXY+Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb250YWluZXIuYXR0cignY2xhc3MnLCAnY2FwdGlvbkltYWdlICcrYXR0cnNbJ2NsYXNzJ10pLmNzcygnd2lkdGgnLCBhdHRycy53aWR0aCk7XG5cblx0XHRcdFx0aWYgKCFjYXB0aW9uLmxlbmd0aCkge1xuXHRcdFx0XHRcdGNhcHRpb24gPSAkKCc8cCBjbGFzcz1cImNhcHRpb25cIj48L3A+JykuYXBwZW5kVG8oY29udGFpbmVyKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhcHRpb24uYXR0cignY2xhc3MnLCAnY2FwdGlvbiAnK2F0dHJzWydjbGFzcyddKS50ZXh0KGV4dHJhRGF0YS5DYXB0aW9uVGV4dCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBPdGhlcndpc2UgZm9yZ2V0IHRoZXkgZXhpc3Rcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRjb250YWluZXIgPSBjYXB0aW9uID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnQgd2UgYXJlIHJlcGxhY2luZyB0aGUgcmVwbGFjZWUgd2l0aFxuXHRcdFx0dmFyIHJlcGxhY2VyID0gY29udGFpbmVyID8gY29udGFpbmVyIDogaW1nO1xuXG5cdFx0XHQvLyBJZiB3ZSdyZSByZXBsYWNpbmcgc29tZXRoaW5nLCBhbmQgaXQncyBub3Qgd2l0aCBpdHNlbGYsIGRvIHNvXG5cdFx0XHRpZiAocmVwbGFjZWUgJiYgcmVwbGFjZWUubm90KHJlcGxhY2VyKS5sZW5ndGgpIHtcblx0XHRcdFx0cmVwbGFjZWUucmVwbGFjZVdpdGgocmVwbGFjZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB3ZSBoYXZlIGEgd3JhcHBlciBlbGVtZW50LCBtYWtlIHN1cmUgdGhlIGltZyBpcyB0aGUgZmlyc3QgY2hpbGQgLSBpbWcgbWlnaHQgYmUgdGhlXG5cdFx0XHQvLyByZXBsYWNlZSwgYW5kIHRoZSB3cmFwcGVyIHRoZSByZXBsYWNlciwgYW5kIHdlIGNhbid0IGRvIHRoaXMgdGlsbCBhZnRlciB0aGUgcmVwbGFjZSBoYXMgaGFwcGVuZWRcblx0XHRcdGlmIChjb250YWluZXIpIHtcblx0XHRcdFx0Y29udGFpbmVyLnByZXBlbmQoaW1nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHJlcGxhY2VlLCB0aGVuIHdlIG5lZWQgdG8gaW5zZXJ0IHRoZSB3aG9sZSBIVE1MXG5cdFx0XHRpZiAoIXJlcGxhY2VlKSB7XG5cdFx0XHRcdC8vIE90aGVyd2lzZSBpbnNlcnQgdGhlIHdob2xlIEhUTUwgY29udGVudFxuXHRcdFx0XHRlZC5yZXBhaW50KCk7XG5cdFx0XHRcdGVkLmluc2VydENvbnRlbnQoJCgnPGRpdiAvPicpLmFwcGVuZChyZXBsYWNlcikuaHRtbCgpLCB7c2tpcF91bmRvIDogMX0pO1xuXHRcdFx0fVxuXG5cdFx0XHRlZC5hZGRVbmRvKCk7XG5cdFx0XHRlZC5yZXBhaW50KCk7XG5cdFx0fSxcblx0XHR1cGRhdGVGcm9tTm9kZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dGhpcy5maW5kKCc6aW5wdXRbbmFtZT1BbHRUZXh0XScpLnZhbChub2RlLmF0dHIoJ2FsdCcpKTtcblx0XHRcdHRoaXMuZmluZCgnOmlucHV0W25hbWU9VGl0bGVdJykudmFsKG5vZGUuYXR0cigndGl0bGUnKSk7XG5cdFx0XHR0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUNTU0NsYXNzXScpLnZhbChub2RlLmF0dHIoJ2NsYXNzJykpO1xuXHRcdFx0dGhpcy5maW5kKCc6aW5wdXRbbmFtZT1XaWR0aF0nKS52YWwobm9kZS53aWR0aCgpKTtcblx0XHRcdHRoaXMuZmluZCgnOmlucHV0W25hbWU9SGVpZ2h0XScpLnZhbChub2RlLmhlaWdodCgpKTtcblx0XHRcdHRoaXMuZmluZCgnOmlucHV0W25hbWU9Q2FwdGlvblRleHRdJykudmFsKG5vZGUuc2libGluZ3MoJy5jYXB0aW9uOmZpcnN0JykudGV4dCgpKTtcblx0XHRcdHRoaXMuZmluZCgnOmlucHV0W25hbWU9RmlsZUlEXScpLnZhbChub2RlLmRhdGEoJ2lkJykpO1xuXHRcdH1cblx0fSk7XG5cblxuXHQvKipcblx0ICogSW5zZXJ0IGEgZmxhc2ggb2JqZWN0IHRhZyBpbnRvIHRoZSBjb250ZW50LlxuXHQgKiBSZXF1aXJlcyB0aGUgJ21lZGlhJyBwbHVnaW4gZm9yIHNlcmlhbGl6YXRpb24gb2YgdGFncyBpbnRvIDxpbWc+IHBsYWNlaG9sZGVycy5cblx0ICovXG5cdCQoJ2Zvcm0uaHRtbGVkaXRvcmZpZWxkLW1lZGlhZm9ybSAuc3MtaHRtbGVkaXRvcmZpZWxkLWZpbGUuZmxhc2gnKS5lbnR3aW5lKHtcblx0XHRnZXRBdHRyaWJ1dGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB3aWR0aCA9IHRoaXMuZmluZCgnOmlucHV0W25hbWU9V2lkdGhdJykudmFsKCksXG5cdFx0XHRcdGhlaWdodCA9IHRoaXMuZmluZCgnOmlucHV0W25hbWU9SGVpZ2h0XScpLnZhbCgpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0J3NyYycgOiB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPVVSTF0nKS52YWwoKSxcblx0XHRcdFx0J3dpZHRoJyA6IHdpZHRoID8gcGFyc2VJbnQod2lkdGgsIDEwKSA6IG51bGwsXG5cdFx0XHRcdCdoZWlnaHQnIDogaGVpZ2h0ID8gcGFyc2VJbnQoaGVpZ2h0LCAxMCkgOiBudWxsLFxuXHRcdFx0XHQnZGF0YS1maWxlaWQnIDogdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1GaWxlSURdJykudmFsKClcblx0XHRcdH07XG5cdFx0fSxcblx0XHRnZXRIVE1MOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhdHRycyA9IHRoaXMuZ2V0QXR0cmlidXRlcygpO1xuXG5cdFx0XHQvLyBFbXVsYXRlIHNlcmlhbGl6YXRpb24gZnJvbSAnbWVkaWEnIHBsdWdpblxuXHRcdFx0dmFyIGVsID0gdGlueU1DRS5hY3RpdmVFZGl0b3IucGx1Z2lucy5tZWRpYS5kYXRhVG9JbWcoe1xuXHRcdFx0XHQndHlwZSc6ICdmbGFzaCcsXG5cdFx0XHRcdCd3aWR0aCc6IGF0dHJzLndpZHRoLFxuXHRcdFx0XHQnaGVpZ2h0JzogYXR0cnMuaGVpZ2h0LFxuXHRcdFx0XHQncGFyYW1zJzogeydzcmMnOiBhdHRycy5zcmN9LFxuXHRcdFx0XHQndmlkZW8nOiB7J3NvdXJjZXMnOiBbXX1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gJCgnPGRpdiAvPicpLmFwcGVuZChlbCkuaHRtbCgpOyAvLyBMaXR0bGUgaGFjayB0byBnZXQgb3V0ZXJIVE1MIHN0cmluZ1xuXHRcdH0sXG5cdFx0dXBkYXRlRnJvbU5vZGU6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdC8vIFRPRE8gTm90IGltcGxlbWVudGVkXG5cdFx0fVxuXHR9KTtcblxuXG5cdC8qKlxuXHQgKiBJbnNlcnQgYW4gb2VtYmVkIG9iamVjdCB0YWcgaW50byB0aGUgY29udGVudC5cblx0ICogUmVxdWlyZXMgdGhlICdtZWRpYScgcGx1Z2luIGZvciBzZXJpYWxpemF0aW9uIG9mIHRhZ3MgaW50byA8aW1nPiBwbGFjZWhvbGRlcnMuXG5cdCAqL1xuXHQkKCdmb3JtLmh0bWxlZGl0b3JmaWVsZC1tZWRpYWZvcm0gLnNzLWh0bWxlZGl0b3JmaWVsZC1maWxlLmVtYmVkJykuZW50d2luZSh7XG5cdFx0Z2V0QXR0cmlidXRlczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgd2lkdGggPSB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPVdpZHRoXScpLnZhbCgpLFxuXHRcdFx0XHRoZWlnaHQgPSB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUhlaWdodF0nKS52YWwoKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdCdzcmMnIDogdGhpcy5maW5kKCcudGh1bWJuYWlsLXByZXZpZXcnKS5hdHRyKCdzcmMnKSxcblx0XHRcdFx0J3dpZHRoJyA6IHdpZHRoID8gcGFyc2VJbnQod2lkdGgsIDEwKSA6IG51bGwsXG5cdFx0XHRcdCdoZWlnaHQnIDogaGVpZ2h0ID8gcGFyc2VJbnQoaGVpZ2h0LCAxMCkgOiBudWxsLFxuXHRcdFx0XHQnY2xhc3MnIDogdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1DU1NDbGFzc10nKS52YWwoKSxcblx0XHRcdFx0J2FsdCcgOiB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUFsdFRleHRdJykudmFsKCksXG5cdFx0XHRcdCd0aXRsZScgOiB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPVRpdGxlXScpLnZhbCgpLFxuXHRcdFx0XHQnZGF0YS1maWxlaWQnIDogdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1GaWxlSURdJykudmFsKClcblx0XHRcdH07XG5cdFx0fSxcblx0XHRnZXRFeHRyYURhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHdpZHRoID0gdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1XaWR0aF0nKS52YWwoKSxcblx0XHRcdFx0aGVpZ2h0ID0gdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1IZWlnaHRdJykudmFsKCk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHQnQ2FwdGlvblRleHQnOiB0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUNhcHRpb25UZXh0XScpLnZhbCgpLFxuXHRcdFx0XHQnVXJsJzogdGhpcy5maW5kKCc6aW5wdXRbbmFtZT1VUkxdJykudmFsKCksXG5cdFx0XHRcdCd0aHVtYm5haWwnOiB0aGlzLmZpbmQoJy50aHVtYm5haWwtcHJldmlldycpLmF0dHIoJ3NyYycpLFxuXHRcdFx0XHQnd2lkdGgnIDogd2lkdGggPyBwYXJzZUludCh3aWR0aCwgMTApIDogbnVsbCxcblx0XHRcdFx0J2hlaWdodCcgOiBoZWlnaHQgPyBwYXJzZUludChoZWlnaHQsIDEwKSA6IG51bGwsXG5cdFx0XHRcdCdjc3NjbGFzcyc6IHRoaXMuZmluZCgnOmlucHV0W25hbWU9Q1NTQ2xhc3NdJykudmFsKClcblx0XHRcdH07XG5cdFx0fSxcblx0XHRnZXRIVE1MOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBlbCxcblx0XHRcdFx0YXR0cnMgPSB0aGlzLmdldEF0dHJpYnV0ZXMoKSxcblx0XHRcdFx0ZXh0cmFEYXRhID0gdGhpcy5nZXRFeHRyYURhdGEoKSxcblx0XHRcdFx0Ly8gaW1nRWwgPSAkKCc8aW1nIGlkPVwiX3NzX3RtcF9pbWdcIiAvPicpO1xuXHRcdFx0XHRpbWdFbCA9ICQoJzxpbWcgLz4nKS5hdHRyKGF0dHJzKS5hZGRDbGFzcygnc3MtaHRtbGVkaXRvcmZpZWxkLWZpbGUgZW1iZWQnKTtcblxuXHRcdFx0JC5lYWNoKGV4dHJhRGF0YSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHRcdFx0aW1nRWwuYXR0cignZGF0YS0nICsga2V5LCB2YWx1ZSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYoZXh0cmFEYXRhLkNhcHRpb25UZXh0KSB7XG5cdFx0XHRcdGVsID0gJCgnPGRpdiBzdHlsZT1cIndpZHRoOiAnICsgYXR0cnNbJ3dpZHRoJ10gKyAncHg7XCIgY2xhc3M9XCJjYXB0aW9uSW1hZ2UgJyArIGF0dHJzWydjbGFzcyddICsgJ1wiPjxwIGNsYXNzPVwiY2FwdGlvblwiPicgKyBleHRyYURhdGEuQ2FwdGlvblRleHQgKyAnPC9wPjwvZGl2PicpLnByZXBlbmQoaW1nRWwpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWwgPSBpbWdFbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiAkKCc8ZGl2IC8+JykuYXBwZW5kKGVsKS5odG1sKCk7IC8vIExpdHRsZSBoYWNrIHRvIGdldCBvdXRlckhUTUwgc3RyaW5nXG5cdFx0fSxcblx0XHR1cGRhdGVGcm9tTm9kZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dGhpcy5maW5kKCc6aW5wdXRbbmFtZT1BbHRUZXh0XScpLnZhbChub2RlLmF0dHIoJ2FsdCcpKTtcblx0XHRcdHRoaXMuZmluZCgnOmlucHV0W25hbWU9VGl0bGVdJykudmFsKG5vZGUuYXR0cigndGl0bGUnKSk7XG5cdFx0XHR0aGlzLmZpbmQoJzppbnB1dFtuYW1lPVdpZHRoXScpLnZhbChub2RlLndpZHRoKCkpO1xuXHRcdFx0dGhpcy5maW5kKCc6aW5wdXRbbmFtZT1IZWlnaHRdJykudmFsKG5vZGUuaGVpZ2h0KCkpO1xuXHRcdFx0dGhpcy5maW5kKCc6aW5wdXRbbmFtZT1UaXRsZV0nKS52YWwobm9kZS5hdHRyKCd0aXRsZScpKTtcblx0XHRcdHRoaXMuZmluZCgnOmlucHV0W25hbWU9Q1NTQ2xhc3NdJykudmFsKG5vZGUuZGF0YSgnY3NzY2xhc3MnKSk7XG5cdFx0XHR0aGlzLmZpbmQoJzppbnB1dFtuYW1lPUZpbGVJRF0nKS52YWwobm9kZS5kYXRhKCdmaWxlaWQnKSk7XG5cdFx0fVxuXHR9KTtcblxuXHQkKCdmb3JtLmh0bWxlZGl0b3JmaWVsZC1tZWRpYWZvcm0gLnNzLWh0bWxlZGl0b3JmaWVsZC1maWxlIC5kaW1lbnNpb25zIDppbnB1dCcpLmVudHdpbmUoe1xuXHRcdE9yaWdWYWw6IG51bGwsXG5cdFx0b25tYXRjaDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblxuXHRcdFx0dGhpcy5zZXRPcmlnVmFsKHBhcnNlSW50KHRoaXMudmFsKCksIDEwKSk7XG5cdFx0fSxcblx0XHRvbnVubWF0Y2g6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHR9LFxuXHRcdG9uZm9jdXNvdXQ6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHRoaXMuY2xvc2VzdCgnLnNzLWh0bWxlZGl0b3JmaWVsZC1maWxlJykudXBkYXRlRGltZW5zaW9ucyh0aGlzLmF0dHIoJ25hbWUnKSk7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogRGVzZWxlY3QgaXRlbSBhbmQgcmVtb3ZlIHRoZSAnZWRpdCcgdmlld1xuXHQgKi9cblx0JCgnZm9ybS5odG1sZWRpdG9yZmllbGQtbWVkaWFmb3JtIC5zcy11cGxvYWRmaWVsZC1pdGVtIC5zcy11cGxvYWRmaWVsZC1pdGVtLWNhbmNlbCcpLmVudHdpbmUoe1xuXHRcdG9uY2xpY2s6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBmb3JtID0gdGhpcy5jbG9zZXN0KCdmb3JtJyksIGZpbGUgPSB0aGlzLmNsb3Nlc3QoJ3NzLXVwbG9hZGZpZWxkLWl0ZW0nKTtcblx0XHRcdGZvcm0uZmluZCgnLnNzLWdyaWRmaWVsZC1pdGVtW2RhdGEtaWQ9JyArIGZpbGUuZGF0YSgnaWQnKSArICddJykucmVtb3ZlQ2xhc3MoJ3VpLXNlbGVjdGVkJyk7XG5cdFx0XHR0aGlzLmNsb3Nlc3QoJy5zcy11cGxvYWRmaWVsZC1pdGVtJykucmVtb3ZlKCk7XG5cdFx0XHRmb3JtLnJlZHJhdygpO1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSk7XG5cblx0JCgnZGl2LnNzLWFzc2V0dXBsb2FkZmllbGQgLnNzLXVwbG9hZGZpZWxkLWl0ZW0tZWRpdCwgZGl2LnNzLWFzc2V0dXBsb2FkZmllbGQgLnNzLXVwbG9hZGZpZWxkLWl0ZW0tbmFtZScpLmVudHdpbmUoe1xuXHRcdGdldEVkaXRGb3JtOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmNsb3Nlc3QoJy5zcy11cGxvYWRmaWVsZC1pdGVtJykuZmluZCgnLnNzLXVwbG9hZGZpZWxkLWl0ZW0tZWRpdGZvcm0nKTtcblx0XHR9LFxuXG5cdFx0ZnJvbUVkaXRGb3JtOiB7XG5cdFx0XHRvbmNoYW5nZTogZnVuY3Rpb24oZSl7XG5cdFx0XHRcdHZhciBmb3JtID0gJChlLnRhcmdldCk7XG5cdFx0XHRcdGZvcm0ucmVtb3ZlQ2xhc3MoJ2VkaXRlZCcpOyAvL3NvIGVkaXRlZCBjbGFzcyBpcyBvbmx5IHRoZXJlIG9uY2Vcblx0XHRcdFx0Zm9ybS5hZGRDbGFzcygnZWRpdGVkJyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG9uY2xpY2s6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBlZGl0Rm9ybSA9IHRoaXMuZ2V0RWRpdEZvcm0oKTtcblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlJ3JlIGluIGFuIEh0bWxFZGl0b3JGaWVsZCBoZXJlLCBvciBmYWxsLWJhY2sgdG8gX3N1cGVyKCkuIEh0bWxFZGl0b3JGaWVsZCB3aXRoXG5cdFx0XHQvLyBBc3NldFVwbG9hZEZpZWxkIGRvZXNuJ3QgdXNlIGlmcmFtZXMsIHNvIG5lZWRzIGl0cyBvd24gdG9nZ2xlRWRpdEZvcm0oKSBsb2dpY1xuXHRcdFx0aWYgKHRoaXMuY2xvc2VzdCgnLnNzLXVwbG9hZGZpZWxkLWl0ZW0nKS5oYXNDbGFzcygnc3MtaHRtbGVkaXRvcmZpZWxkLWZpbGUnKSkge1xuXHRcdFx0XHRlZGl0Rm9ybS5wYXJlbnQoJ3NzLXVwbG9hZGZpZWxkLWl0ZW0nKS5yZW1vdmVDbGFzcygndWktc3RhdGUtd2FybmluZycpO1xuXG5cdFx0XHRcdGVkaXRGb3JtLnRvZ2dsZUVkaXRGb3JtKCk7XG5cblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBBdm9pZCBhIGZvcm0gc3VibWl0XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBBdm9pZCBkdXBsaWNhdGlvbiBmcm9tIGJ1dHRvblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9zdXBlcihlKTtcblx0XHR9XG5cdH0pO1xuXG5cdCQoJ2Rpdi5zcy1hc3NldHVwbG9hZGZpZWxkIC5zcy11cGxvYWRmaWVsZC1pdGVtLWVkaXRmb3JtJykuZW50d2luZSh7XG5cdFx0dG9nZ2xlRWRpdEZvcm06IGZ1bmN0aW9uKGJvb2wpIHtcblx0XHRcdHZhciBpdGVtSW5mbyA9IHRoaXMucHJldignLnNzLXVwbG9hZGZpZWxkLWl0ZW0taW5mbycpLCBzdGF0dXMgPSBpdGVtSW5mby5maW5kKCcuc3MtdXBsb2FkZmllbGQtaXRlbS1zdGF0dXMnKTtcblx0XHRcdHZhciB0ZXh0PVwiXCI7XG5cblx0XHRcdGlmKGJvb2wgPT09IHRydWUgfHwgKGJvb2wgIT09IGZhbHNlICYmIHRoaXMuaGVpZ2h0KCkgPT09IDApKSB7XG5cdFx0XHRcdHRleHQgPSBpMThuLl90KCdVcGxvYWRGaWVsZC5FZGl0aW5nJywgXCJFZGl0aW5nIC4uLlwiKTtcblx0XHRcdFx0dGhpcy5oZWlnaHQoJ2F1dG8nKTtcblx0XHRcdFx0aXRlbUluZm8uZmluZCgnLnRvZ2dsZS1kZXRhaWxzLWljb24nKS5hZGRDbGFzcygnb3BlbmVkJyk7XG5cdFx0XHRcdHN0YXR1cy5yZW1vdmVDbGFzcygndWktc3RhdGUtc3VjY2Vzcy10ZXh0JykucmVtb3ZlQ2xhc3MoJ3VpLXN0YXRlLXdhcm5pbmctdGV4dCcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5oZWlnaHQoMCk7XG5cdFx0XHRcdGl0ZW1JbmZvLmZpbmQoJy50b2dnbGUtZGV0YWlscy1pY29uJykucmVtb3ZlQ2xhc3MoJ29wZW5lZCcpO1xuXHRcdFx0XHRpZighdGhpcy5oYXNDbGFzcygnZWRpdGVkJykpe1xuXHRcdFx0XHRcdHRleHQgPSBpMThuLl90KCdVcGxvYWRGaWVsZC5OT0NIQU5HRVMnLCAnTm8gQ2hhbmdlcycpO1xuXHRcdFx0XHRcdHN0YXR1cy5hZGRDbGFzcygndWktc3RhdGUtc3VjY2Vzcy10ZXh0Jyk7XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdHRleHQgPSBpMThuLl90KCdVcGxvYWRGaWVsZC5DSEFOR0VTU0FWRUQnLCAnQ2hhbmdlcyBNYWRlJyk7XG5cdFx0XHRcdFx0dGhpcy5yZW1vdmVDbGFzcygnZWRpdGVkJyk7XG5cdFx0XHRcdFx0c3RhdHVzLmFkZENsYXNzKCd1aS1zdGF0ZS1zdWNjZXNzLXRleHQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0XHRzdGF0dXMuYXR0cigndGl0bGUnLHRleHQpLnRleHQodGV4dCk7XG5cdFx0fVxuXHR9KTtcblxuXG5cdCQoJ2Zvcm0uaHRtbGVkaXRvcmZpZWxkLW1lZGlhZm9ybSAuZmllbGRbaWQkPVwiUGFyZW50SURfSG9sZGVyXCJdIC5UcmVlRHJvcGRvd25GaWVsZCcpLmVudHdpbmUoe1xuXHRcdG9uYWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cblx0XHRcdC8vIFRPRE8gQ3VzdG9tIGV2ZW50IGRvZXNuJ3QgZmlyZSBpbiBJRSBpZiByZWdpc3RlcmVkIHRocm91Z2ggb2JqZWN0IGxpdGVyYWxcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHRoaXMuYmluZCgnY2hhbmdlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBmaWxlTGlzdCA9IHNlbGYuY2xvc2VzdCgnZm9ybScpLmZpbmQoJy5zcy1ncmlkZmllbGQnKTtcblx0XHRcdFx0ZmlsZUxpc3Quc2V0U3RhdGUoJ1BhcmVudElEJywgc2VsZi5nZXRWYWx1ZSgpKTtcblx0XHRcdFx0ZmlsZUxpc3QucmVsb2FkKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xuXG59KTtcbiIsImltcG9ydCAkIGZyb20gJy4valF1ZXJ5JztcblxuJC5lbnR3aW5lKCdzcycsIGZ1bmN0aW9uKCQpe1xuXHQvKipcblx0ICogTGlnaHR3ZWlnaHQgd3JhcHBlciBhcm91bmQgalF1ZXJ5IFVJIHRhYnMgZm9yIGdlbmVyaWMgdGFiIHNldC11cFxuXHQgKi9cblx0JCgnLnNzLXRhYnNldCcpLmVudHdpbmUoe1xuXHRcdElnbm9yZVRhYlN0YXRlOiBmYWxzZSxcblxuXHRcdG9uYWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cblx0XHRcdC8vIENhbid0IG5hbWUgcmVkcmF3KCkgYXMgaXQgY2xhc2hlcyB3aXRoIG90aGVyIENNUyBlbnR3aW5lIGNsYXNzZXNcblx0XHRcdHRoaXMucmVkcmF3VGFicygpO1xuXG5cdFx0XHRpZiAoaGFzaCAhPT0gJycpIHtcblx0XHRcdFx0dGhpcy5vcGVuVGFiRnJvbVVSTChoYXNoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHR9LFxuXG5cdFx0b25yZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYodGhpcy5kYXRhKCd0YWJzJykpIHRoaXMudGFicygnZGVzdHJveScpO1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHR9LFxuXG5cdFx0cmVkcmF3VGFiczogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnJld3JpdGVIYXNobGlua3MoKTtcblx0XHRcdHRoaXMudGFicygpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAZnVuYyBvcGVuVGFiRnJvbVVSTFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoXG5cdFx0ICogQGRlc2MgQWxsb3dzIGxpbmtpbmcgdG8gYSBzcGVjaWZpYyB0YWIuXG5cdFx0ICovXG5cdFx0b3BlblRhYkZyb21VUkw6IGZ1bmN0aW9uIChoYXNoKSB7XG5cdFx0XHR2YXIgJHRyaWdnZXI7XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGUgaGFzaCByZWxhdGVzIHRvIGEgdmFsaWQgdGFiLlxuXHRcdFx0JC5lYWNoKHRoaXMuZmluZCgnLmNtcy1wYW5lbC1saW5rJyksIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gVGhlIGhhc2ggaW4gaW4gdGhlIGJ1dHRvbidzIGhyZWYgYW5kIHRoZXJlIGlzIGV4YWN0bHkgb25lIHRhYiB3aXRoIHRoYXQgaWQuXG5cdFx0XHRcdGlmICh0aGlzLmhyZWYuaW5kZXhPZihoYXNoKSAhPT0gLTEgJiYgJChoYXNoKS5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHQkdHJpZ2dlciA9ICQodGhpcyk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBicmVhayB0aGUgbG9vcFxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBubyB0YWIsIGl0IG1lYW5zIHRoZSBoYXNoIGlzIGludmFsaWQsIHNvIGRvIG5vdGhpbmcuXG5cdFx0XHRpZiAoJHRyaWdnZXIgPT09IHZvaWQgMCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN3aXRjaCB0byB0aGUgY29ycmVjdCB0YWIgd2hlbiBBSkFYIGxvYWRpbmcgY29tcGxldGVzLlxuXHRcdFx0JCh3aW5kb3cpLm9uZSgnYWpheENvbXBsZXRlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQkdHJpZ2dlci5jbGljaygpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBmdW5jIHJld3JpdGVIYXNobGlua3Ncblx0XHQgKiBAZGVzYyBFbnN1cmUgaGFzaCBsaW5rcyBhcmUgcHJlZml4ZWQgd2l0aCB0aGUgY3VycmVudCBwYWdlIFVSTCwgb3RoZXJ3aXNlIGpRdWVyeSBpbnRlcnByZXRzIHRoZW0gYXMgYmVpbmcgZXh0ZXJuYWwuXG5cdFx0ICovXG5cdFx0cmV3cml0ZUhhc2hsaW5rczogZnVuY3Rpb24oKSB7XG5cdFx0XHQkKHRoaXMpLmZpbmQoJ3VsIGEnKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoISQodGhpcykuYXR0cignaHJlZicpKSByZXR1cm47XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9ICQodGhpcykuYXR0cignaHJlZicpLm1hdGNoKC8jLiovKTtcblx0XHRcdFx0aWYoIW1hdGNoZXMpIHJldHVybjtcblx0XHRcdFx0JCh0aGlzKS5hdHRyKCdocmVmJywgZG9jdW1lbnQubG9jYXRpb24uaHJlZi5yZXBsYWNlKC8jLiovLCAnJykgKyBtYXRjaGVzWzBdKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG59KTtcbiIsImltcG9ydCAkIGZyb20gJy4valF1ZXJ5JztcbmltcG9ydCBpMThuIGZyb20gJy4vaTE4bic7XG5cbiQuZW50d2luZSgnc3MnLCBmdW5jdGlvbigkKXtcblx0LyoqXG5cdCAqIE9uIHJlc2l6ZSBvZiBhbnkgY2xvc2UgdGhlIG9wZW4gdHJlZWRyb3Bkb3duZmllbGRzXG5cdCAqIGFzIHdlJ2xsIG5lZWQgdG8gcmVkbyB3aXRoIHdpZHRoc1xuXHQgKi9cblx0dmFyIHdpbmRvd1dpZHRoLCB3aW5kb3dIZWlnaHQ7XG5cdCQod2luZG93KS5iaW5kKCdyZXNpemUudHJlZWRyb3Bkb3duZmllbGQnLCBmdW5jdGlvbigpIHtcblx0XHQvLyBFbnR3aW5lJ3MgJ2Zyb21XaW5kb3c6Om9ucmVzaXplJyBkb2VzIG5vdCB0cmlnZ2VyIG9uIElFOC4gVXNlIHN5bnRoZXRpYyBldmVudC5cblx0XHR2YXIgY2IgPSBmdW5jdGlvbigpIHskKCcuVHJlZURyb3Bkb3duRmllbGQnKS5jbG9zZVBhbmVsKCk7fTtcblxuXHRcdC8vIFdvcmthcm91bmQgdG8gYXZvaWQgSUU4IGluZmluaXRlIGxvb3BzIHdoZW4gZWxlbWVudHMgYXJlIHJlc2l6ZWQgYXMgYSByZXN1bHQgb2YgdGhpcyBldmVudCBcblx0XHRpZigkLmJyb3dzZXIubXNpZSAmJiBwYXJzZUludCgkLmJyb3dzZXIudmVyc2lvbiwgMTApIDwgOSkge1xuXHRcdFx0dmFyIG5ld1dpbmRvd1dpZHRoID0gJCh3aW5kb3cpLndpZHRoKCksIG5ld1dpbmRvd0hlaWdodCA9ICQod2luZG93KS5oZWlnaHQoKTtcblx0XHRcdGlmKG5ld1dpbmRvd1dpZHRoICE9IHdpbmRvd1dpZHRoIHx8IG5ld1dpbmRvd0hlaWdodCAhPSB3aW5kb3dIZWlnaHQpIHtcblx0XHRcdFx0d2luZG93V2lkdGggPSBuZXdXaW5kb3dXaWR0aDtcblx0XHRcdFx0d2luZG93SGVpZ2h0ID0gbmV3V2luZG93SGVpZ2h0O1xuXHRcdFx0XHRjYigpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYigpO1xuXHRcdH1cblx0fSk7XG5cdFxuXHR2YXIgc3RyaW5ncyA9IHtcblx0XHQnb3BlbmxpbmsnOiBpMThuLl90KCdUcmVlRHJvcGRvd25GaWVsZC5PcGVuTGluaycpLFxuXHRcdCdmaWVsZFRpdGxlJzogJygnICsgaTE4bi5fdCgnVHJlZURyb3Bkb3duRmllbGQuRmllbGRUaXRsZScpICsgJyknLFxuXHRcdCdzZWFyY2hGaWVsZFRpdGxlJzogJygnICsgaTE4bi5fdCgnVHJlZURyb3Bkb3duRmllbGQuU2VhcmNoRmllbGRUaXRsZScpICsgJyknXG5cdH07XG5cblx0dmFyIF9jbGlja1Rlc3RGbiA9IGZ1bmN0aW9uKGUpIHtcblx0XHQvLyBJZiB0aGUgY2xpY2sgdGFyZ2V0IGlzIG5vdCBhIGNoaWxkIG9mIHRoZSBjdXJyZW50IGZpZWxkLCBjbG9zZSB0aGUgcGFuZWwgYXV0b21hdGljYWxseS5cblx0XHRpZighJChlLnRhcmdldCkucGFyZW50cygnLlRyZWVEcm9wZG93bkZpZWxkJykubGVuZ3RoKSAkKCcuVHJlZURyb3Bkb3duRmllbGQnKS5jbG9zZVBhbmVsKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEB0b2RvIEVycm9yIGRpc3BsYXlcblx0ICogQHRvZG8gTm8gcmVzdWx0cyBkaXNwbGF5IGZvciBzZWFyY2hcblx0ICogQHRvZG8gQXV0b21hdGljIGV4cGFuc2lvbiBvZiBhamF4IGNoaWxkcmVuIHdoZW4gbXVsdGlzZWxlY3QgaXMgdHJpZ2dlcmVkXG5cdCAqIEB0b2RvIEF1dG9tYXRpYyBwYW5lbCBwb3NpdGlvbmluZyBiYXNlZCBvbiBhdmFpbGFibGUgc3BhY2UgKHRvcC9ib3R0b20pXG5cdCAqIEB0b2RvIGZvcmNlVmFsdWVcblx0ICogQHRvZG8gQXV0b21hdGljIHdpZHRoXG5cdCAqIEB0b2RvIEV4cGFuZCB0aXRsZSBoZWlnaHQgdG8gZml0IGFsbCBlbGVtZW50c1xuXHQgKi9cblx0JCgnLlRyZWVEcm9wZG93bkZpZWxkJykuZW50d2luZSh7XG5cblx0XHQvLyBYTUxIdHRwUmVxdWVzdFxuXHRcdEN1cnJlbnRYaHI6IG51bGwsXG5cblx0XHRvbmFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmFwcGVuZChcblx0XHRcdFx0JzxzcGFuIGNsYXNzPVwidHJlZWRyb3Bkb3duZmllbGQtdGl0bGVcIj48L3NwYW4+JyArXG5cdFx0XHRcdCc8ZGl2IGNsYXNzPVwidHJlZWRyb3Bkb3duZmllbGQtdG9nZ2xlLXBhbmVsLWxpbmtcIj48YSBocmVmPVwiI1wiIGNsYXNzPVwidWktaWNvbiB1aS1pY29uLXRyaWFuZ2xlLTEtc1wiPjwvYT48L2Rpdj4nICtcblx0XHRcdFx0JzxkaXYgY2xhc3M9XCJ0cmVlZHJvcGRvd25maWVsZC1wYW5lbFwiPjxkaXYgY2xhc3M9XCJ0cmVlLWhvbGRlclwiPjwvZGl2PjwvZGl2Pidcblx0XHRcdCk7XG5cdFx0XG5cdFx0XHR2YXIgbGlua1RpdGxlID0gc3RyaW5ncy5vcGVuTGluaztcblx0XHRcdGlmKGxpbmtUaXRsZSkgdGhpcy5maW5kKFwidHJlZWRyb3Bkb3duZmllbGQtdG9nZ2xlLXBhbmVsLWxpbmsgYVwiKS5hdHRyKCd0aXRsZScsIGxpbmtUaXRsZSk7XG5cdFx0XHRpZih0aGlzLmRhdGEoJ3RpdGxlJykpIHRoaXMuc2V0VGl0bGUodGhpcy5kYXRhKCd0aXRsZScpKTtcblx0XHRcdFxuXHRcdFx0dGhpcy5nZXRQYW5lbCgpLmhpZGUoKTtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0fSxcblx0XHRnZXRQYW5lbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5maW5kKCcudHJlZWRyb3Bkb3duZmllbGQtcGFuZWwnKTtcblx0XHR9LFxuXHRcdG9wZW5QYW5lbDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBjbG9zZSBhbGwgb3RoZXIgcGFuZWxzXG5cdFx0XHQkKCcuVHJlZURyb3Bkb3duRmllbGQnKS5jbG9zZVBhbmVsKCk7XG5cblx0XHRcdC8vIExpc3RlbiBmb3IgY2xpY2tzIG91dHNpZGUgb2YgdGhlIGZpZWxkIHRvIGF1dG8tY2xvc2UgaXRcblx0XHRcdCQoJ2JvZHknKS5iaW5kKCdjbGljaycsIF9jbGlja1Rlc3RGbik7XG5cdFx0XHRcblx0XHRcdHZhciBwYW5lbCA9IHRoaXMuZ2V0UGFuZWwoKSwgdHJlZSA9IHRoaXMuZmluZCgnLnRyZWUtaG9sZGVyJyk7XG5cblx0XHRcdHBhbmVsLmNzcygnd2lkdGgnLCB0aGlzLndpZHRoKCkpO1xuXHRcdFx0XG5cdFx0XHRwYW5lbC5zaG93KCk7XG5cdFx0XHRcblx0XHRcdC8vIHN3YXAgdGhlIGRvd24gYXJyb3cgd2l0aCBhbiB1cCBhcnJvd1xuXHRcdFx0dmFyIHRvZ2dsZSA9IHRoaXMuZmluZChcIi50cmVlZHJvcGRvd25maWVsZC10b2dnbGUtcGFuZWwtbGlua1wiKTtcblx0XHRcdHRvZ2dsZS5hZGRDbGFzcygndHJlZWRyb3Bkb3duZmllbGQtb3Blbi10cmVlJyk7XG5cdFx0XHR0aGlzLmFkZENsYXNzKFwidHJlZWRyb3Bkb3duZmllbGQtb3Blbi10cmVlXCIpO1xuXHRcdFx0XG5cdFx0XHR0b2dnbGUuZmluZChcImFcIilcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCd1aS1pY29uLXRyaWFuZ2xlLTEtcycpXG5cdFx0XHRcdC5hZGRDbGFzcygndWktaWNvbi10cmlhbmdsZS0xLW4nKTtcblx0XHRcdFxuXHRcdFx0aWYodHJlZS5pcygnOmVtcHR5JykgJiYgIXBhbmVsLmhhc0NsYXNzKCdsb2FkaW5nJykpIHtcblx0XHRcdFx0dGhpcy5sb2FkVHJlZShudWxsLCB0aGlzLl9yaXNlVXApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fcmlzZVVwKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudHJpZ2dlcigncGFuZWxzaG93Jyk7XG5cdFx0fSxcblx0XHRfcmlzZVVwOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjb250YWluZXIgPSB0aGlzLFxuXHRcdFx0XHRkcm9wZG93biA9IHRoaXMuZ2V0UGFuZWwoKSxcblx0XHRcdFx0dG9nZ2xlID0gdGhpcy5maW5kKFwiLnRyZWVkcm9wZG93bmZpZWxkLXRvZ2dsZS1wYW5lbC1saW5rXCIpLFxuXHRcdFx0XHRvZmZzZXRUb3AgPSB0b2dnbGUuaW5uZXJIZWlnaHQoKSxcblx0XHRcdFx0ZWxIZWlnaHQsXG5cdFx0XHRcdGVsUG9zLFxuXHRcdFx0XHRlbmRPZldpbmRvdztcblxuXHRcdFx0aWYgKHRvZ2dsZS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGVuZE9mV2luZG93ID0gKCQod2luZG93KS5oZWlnaHQoKSArICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpKSAtIHRvZ2dsZS5pbm5lckhlaWdodCgpO1xuXHRcdFx0XHRlbFBvcyA9IHRvZ2dsZS5vZmZzZXQoKS50b3A7XG5cdFx0XHRcdGVsSGVpZ2h0ID0gZHJvcGRvd24uaW5uZXJIZWlnaHQoKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIElmIHRoZSBkcm9wZG93biBpcyB0b28gY2xvc2UgdG8gdGhlIGJvdHRvbSBvZiB0aGUgcGFnZSwgcG9zaXRpb24gaXQgYWJvdmUgdGhlICd0cmlnZ2VyJ1xuXHRcdFx0XHRpZiAoZWxQb3MgKyBlbEhlaWdodCA+IGVuZE9mV2luZG93ICYmIGVsUG9zIC0gZWxIZWlnaHQgPiAwKSB7XG5cdFx0XHRcdFx0Y29udGFpbmVyLmFkZENsYXNzKCd0cmVlZHJvcGRvd25maWVsZC13aXRoLXJpc2UnKTtcblx0XHRcdFx0XHRvZmZzZXRUb3AgPSAtZHJvcGRvd24ub3V0ZXJIZWlnaHQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250YWluZXIucmVtb3ZlQ2xhc3MoJ3RyZWVkcm9wZG93bmZpZWxkLXdpdGgtcmlzZScpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRkcm9wZG93bi5jc3Moe1widG9wXCI6IG9mZnNldFRvcCArIFwicHhcIn0pO1xuXHRcdH0sXG5cdFx0Y2xvc2VQYW5lbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoJ2JvZHknKS51bmJpbmQoJ2NsaWNrJywgX2NsaWNrVGVzdEZuKTtcblxuXHRcdFx0Ly8gc3dhcCB0aGUgdXAgYXJyb3cgd2l0aCBhIGRvd24gYXJyb3dcblx0XHRcdHZhciB0b2dnbGUgPSB0aGlzLmZpbmQoXCIudHJlZWRyb3Bkb3duZmllbGQtdG9nZ2xlLXBhbmVsLWxpbmtcIik7XG5cdFx0XHR0b2dnbGUucmVtb3ZlQ2xhc3MoJ3RyZWVkcm9wZG93bmZpZWxkLW9wZW4tdHJlZScpO1xuXHRcdFx0dGhpcy5yZW1vdmVDbGFzcygndHJlZWRyb3Bkb3duZmllbGQtb3Blbi10cmVlIHRyZWVkcm9wZG93bmZpZWxkLXdpdGgtcmlzZScpO1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdHRvZ2dsZS5maW5kKFwiYVwiKVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoJ3VpLWljb24tdHJpYW5nbGUtMS1uJylcblx0XHRcdFx0LmFkZENsYXNzKCd1aS1pY29uLXRyaWFuZ2xlLTEtcycpO1xuXHRcdFx0XHRcblxuXHRcdFx0dGhpcy5nZXRQYW5lbCgpLmhpZGUoKTtcblx0XHRcdHRoaXMudHJpZ2dlcigncGFuZWxoaWRlJyk7XG5cdFx0fSxcblx0XHR0b2dnbGVQYW5lbDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzW3RoaXMuZ2V0UGFuZWwoKS5pcygnOnZpc2libGUnKSA/ICdjbG9zZVBhbmVsJyA6ICdvcGVuUGFuZWwnXSgpO1xuXHRcdH0sXG5cdFx0c2V0VGl0bGU6IGZ1bmN0aW9uKHRpdGxlKSB7XG5cdFx0XHR0aXRsZSA9IHRpdGxlIHx8IHRoaXMuZGF0YSgndGl0bGUnKSB8fCBzdHJpbmdzLmZpZWxkVGl0bGU7XG5cdFx0XHRcblx0XHRcdHRoaXMuZmluZCgnLnRyZWVkcm9wZG93bmZpZWxkLXRpdGxlJykuaHRtbCh0aXRsZSk7XG5cdFx0XHR0aGlzLmRhdGEoJ3RpdGxlJywgdGl0bGUpOyAvLyBzZXBhcmF0ZSB2aWV3IGZyb20gc3RvcmFnZSAoaW1wb3J0YW50IGZvciBzZWFyY2ggY2FuY2VsbGF0aW9uKVxuXHRcdH0sXG5cdFx0Z2V0VGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZmluZCgnLnRyZWVkcm9wZG93bmZpZWxkLXRpdGxlJykudGV4dCgpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlIHRpdGxlIGZyb20gdHJlZSBub2RlIHZhbHVlXG5cdFx0ICovXG5cdFx0dXBkYXRlVGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLCB0cmVlID0gc2VsZi5maW5kKCcudHJlZS1ob2xkZXInKSwgdmFsID0gdGhpcy5nZXRWYWx1ZSgpO1xuXHRcdFx0dmFyIHVwZGF0ZUZuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB2YWwgPSBzZWxmLmdldFZhbHVlKCk7XG5cdFx0XHRcdGlmKHZhbCkge1xuXG5cdFx0XHRcdFx0dmFyIG5vZGUgPSB0cmVlLmZpbmQoJypbZGF0YS1pZD1cIicgKyB2YWwgKyAnXCJdJyksXG5cdFx0XHRcdFx0XHR0aXRsZSA9IG5vZGUuY2hpbGRyZW4oJ2EnKS5maW5kKFwic3Bhbi5qc3RyZWVfcGFnZWljb25cIik/bm9kZS5jaGlsZHJlbignYScpLmZpbmQoXCJzcGFuLml0ZW1cIikuaHRtbCgpOm51bGw7XG5cdFx0XHRcdFx0aWYoIXRpdGxlKSB0aXRsZT0obm9kZS5sZW5ndGggPiAwKSA/IHRyZWUuanN0cmVlKCdnZXRfdGV4dCcsIG5vZGVbMF0pIDogbnVsbDtcblxuXHRcdFx0XHRcdGlmKHRpdGxlKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnNldFRpdGxlKHRpdGxlKTtcblx0XHRcdFx0XHRcdHNlbGYuZGF0YSgndGl0bGUnLCB0aXRsZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKG5vZGUpIHRyZWUuanN0cmVlKCdzZWxlY3Rfbm9kZScsIG5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYuc2V0VGl0bGUoc2VsZi5kYXRhKCdlbXB0eS10aXRsZScpKTtcblx0XHRcdFx0XHRzZWxmLnJlbW92ZURhdGEoJ3RpdGxlJyk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8vIExvYWQgdGhlIHRyZWUgaWYgaXRzIG5vdCBhbHJlYWR5IHByZXNlbnRcblx0XHRcdGlmKCF0cmVlLmlzKCc6ZW1wdHknKSB8fCAhdmFsKSB1cGRhdGVGbigpO1xuXHRcdFx0ZWxzZSB0aGlzLmxvYWRUcmVlKHtmb3JjZVZhbHVlOiB2YWx9LCB1cGRhdGVGbik7XG5cdFx0fSxcblx0XHRzZXRWYWx1ZTogZnVuY3Rpb24odmFsKSB7XG5cdFx0XHR0aGlzLmRhdGEoJ21ldGFkYXRhJywgJC5leHRlbmQodGhpcy5kYXRhKCdtZXRhZGF0YScpLCB7aWQ6IHZhbH0pKTtcblx0XHRcdHRoaXMuZmluZCgnOmlucHV0OmhpZGRlbicpLnZhbCh2YWwpXG5cdFx0XHRcdC8vIFRyaWdnZXIgc3ludGhldGljIGV2ZW50IHNvIHN1YnNjcmliZXJzIGNhbiB3b3JrYXJvdW5kIHRoZSBJRTggcHJvYmxlbSB3aXRoICdjaGFuZ2UnIGV2ZW50c1xuXHRcdFx0XHQvLyBub3QgcHJvcGFnYXRpbmcgb24gaGlkZGVuIGlucHV0cy4gJ2NoYW5nZScgaXMgc3RpbGwgdHJpZ2dlcmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJsaXR5LlxuXHRcdFx0XHQudHJpZ2dlcigndmFsdWV1cGRhdGVkJylcblx0XHRcdFx0LnRyaWdnZXIoJ2NoYW5nZScpO1xuXHRcdH0sXG5cdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZmluZCgnOmlucHV0OmhpZGRlbicpLnZhbCgpO1xuXHRcdH0sXG5cdFx0bG9hZFRyZWU6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcywgcGFuZWwgPSB0aGlzLmdldFBhbmVsKCksIHRyZWVIb2xkZXIgPSAkKHBhbmVsKS5maW5kKCcudHJlZS1ob2xkZXInKSxcblx0XHRcdFx0cGFyYW1zID0gKHBhcmFtcykgPyAkLmV4dGVuZCh7fSwgdGhpcy5nZXRSZXF1ZXN0UGFyYW1zKCksIHBhcmFtcykgOiB0aGlzLmdldFJlcXVlc3RQYXJhbXMoKSwgeGhyO1xuXG5cdFx0XHRpZih0aGlzLmdldEN1cnJlbnRYaHIoKSkgdGhpcy5nZXRDdXJyZW50WGhyKCkuYWJvcnQoKTtcblx0XHRcdHBhbmVsLmFkZENsYXNzKCdsb2FkaW5nJyk7XG5cdFx0XHR4aHIgPSAkLmFqYXgoe1xuXHRcdFx0XHR1cmw6IHRoaXMuZGF0YSgndXJsVHJlZScpLFxuXHRcdFx0XHRkYXRhOiBwYXJhbXMsXG5cdFx0XHRcdGNvbXBsZXRlOiBmdW5jdGlvbih4aHIsIHN0YXR1cykge1xuXHRcdFx0XHRcdHBhbmVsLnJlbW92ZUNsYXNzKCdsb2FkaW5nJyk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uKGh0bWwsIHN0YXR1cywgeGhyKSB7XG5cdFx0XHRcdFx0dHJlZUhvbGRlci5odG1sKGh0bWwpO1xuXHRcdFx0XHRcdHZhciBmaXJzdExvYWQgPSB0cnVlO1xuXHRcdFx0XHRcdHRyZWVIb2xkZXJcblx0XHRcdFx0XHRcdC5qc3RyZWUoJ2Rlc3Ryb3knKVxuXHRcdFx0XHRcdFx0LmJpbmQoJ2xvYWRlZC5qc3RyZWUnLCBmdW5jdGlvbihlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB2YWwgPSBzZWxmLmdldFZhbHVlKCksIHNlbGVjdE5vZGUgPSB0cmVlSG9sZGVyLmZpbmQoJypbZGF0YS1pZD1cIicgKyB2YWwgKyAnXCJdJyksIFxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnROb2RlID0gZGF0YS5pbnN0LmdldF9zZWxlY3RlZCgpO1xuXHRcdFx0XHRcdFx0XHRpZih2YWwgJiYgc2VsZWN0Tm9kZSAhPSBjdXJyZW50Tm9kZSkgZGF0YS5pbnN0LnNlbGVjdF9ub2RlKHNlbGVjdE5vZGUpO1xuXHRcdFx0XHRcdFx0XHRmaXJzdExvYWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0aWYoY2FsbGJhY2spIGNhbGxiYWNrLmFwcGx5KHNlbGYpO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdC5qc3RyZWUoc2VsZi5nZXRUcmVlQ29uZmlnKCkpXG5cdFx0XHRcdFx0XHQuYmluZCgnc2VsZWN0X25vZGUuanN0cmVlJywgZnVuY3Rpb24oZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgbm9kZSA9IGRhdGEucnNsdC5vYmosIGlkID0gJChub2RlKS5kYXRhKCdpZCcpO1xuXHRcdFx0XHRcdFx0XHRpZighZmlyc3RMb2FkICYmIHNlbGYuZ2V0VmFsdWUoKSA9PSBpZCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFZhbHVlIGlzIGFscmVhZHkgc2VsZWN0ZWQsIHVuc2VsZWN0IGl0IChmb3IgbGFjayBvZiBhIGJldHRlciBVSSB0byBkbyB0aGlzKVxuXHRcdFx0XHRcdFx0XHRcdHNlbGYuZGF0YSgnbWV0YWRhdGEnLCBudWxsKTtcblx0XHRcdFx0XHRcdFx0XHRzZWxmLnNldFRpdGxlKG51bGwpO1xuXHRcdFx0XHRcdFx0XHRcdHNlbGYuc2V0VmFsdWUobnVsbCk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5pbnN0LmRlc2VsZWN0X25vZGUobm9kZSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0c2VsZi5kYXRhKCdtZXRhZGF0YScsICQuZXh0ZW5kKHtpZDogaWR9LCAkKG5vZGUpLmdldE1ldGFEYXRhKCkpKTtcblx0XHRcdFx0XHRcdFx0XHRzZWxmLnNldFRpdGxlKGRhdGEuaW5zdC5nZXRfdGV4dChub2RlKSk7XG5cdFx0XHRcdFx0XHRcdFx0c2VsZi5zZXRWYWx1ZShpZCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdC8vIEF2b2lkIGF1dG8tY2xvc2luZyBwYW5lbCBvbiBmaXJzdCBsb2FkXG5cdFx0XHRcdFx0XHRcdGlmKCFmaXJzdExvYWQpIHNlbGYuY2xvc2VQYW5lbCgpO1xuXHRcdFx0XHRcdFx0XHRmaXJzdExvYWQ9ZmFsc2U7XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdHNlbGYuc2V0Q3VycmVudFhocihudWxsKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLnNldEN1cnJlbnRYaHIoeGhyKTtcblx0XHR9LFxuXHRcdGdldFRyZWVDb25maWc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0J2NvcmUnOiB7XG5cdFx0XHRcdFx0J2h0bWxfdGl0bGVzJzogdHJ1ZSxcblx0XHRcdFx0XHQvLyAnaW5pdGlhbGx5X29wZW4nOiBbJ3JlY29yZC0wJ10sXG5cdFx0XHRcdFx0J2FuaW1hdGlvbic6IDBcblx0XHRcdFx0fSxcblx0XHRcdFx0J2h0bWxfZGF0YSc6IHtcblx0XHRcdFx0XHQvLyBUT0RPIEhhY2sgdG8gYXZvaWQgYWpheCBsb2FkIG9uIGluaXQsIHNlZSBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvanN0cmVlL2lzc3Vlcy9kZXRhaWw/aWQ9OTExXG5cdFx0XHRcdFx0J2RhdGEnOiB0aGlzLmdldFBhbmVsKCkuZmluZCgnLnRyZWUtaG9sZGVyJykuaHRtbCgpLFxuXHRcdFx0XHRcdCdhamF4Jzoge1xuXHRcdFx0XHRcdFx0J3VybCc6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHVybCA9ICQucGF0aC5wYXJzZVVybChzZWxmLmRhdGEoJ3VybFRyZWUnKSkuaHJlZk5vU2VhcmNoO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdXJsICsgJy8nICsgKCQobm9kZSkuZGF0YShcImlkXCIpID8gJChub2RlKS5kYXRhKFwiaWRcIikgOiAwKTtcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHQnZGF0YSc6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHF1ZXJ5ID0gJC5xdWVyeS5sb2FkKHNlbGYuZGF0YSgndXJsVHJlZScpKS5rZXlzO1xuXHRcdFx0XHRcdFx0XHR2YXIgcGFyYW1zID0gc2VsZi5nZXRSZXF1ZXN0UGFyYW1zKCk7XG5cdFx0XHRcdFx0XHRcdHBhcmFtcyA9ICQuZXh0ZW5kKHt9LCBxdWVyeSwgcGFyYW1zLCB7YWpheDogMX0pO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcGFyYW1zO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0J3VpJzoge1xuXHRcdFx0XHRcdFwic2VsZWN0X2xpbWl0XCIgOiAxLFxuXHRcdFx0XHRcdCdpbml0aWFsbHlfc2VsZWN0JzogW3RoaXMuZ2V0UGFuZWwoKS5maW5kKCcuY3VycmVudCcpLmF0dHIoJ2lkJyldXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCd0aGVtZXMnOiB7XG5cdFx0XHRcdFx0J3RoZW1lJzogJ2FwcGxlJ1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQndHlwZXMnIDoge1xuXHRcdFx0XHRcdCd0eXBlcycgOiB7XG5cdFx0XHRcdFx0XHQnZGVmYXVsdCc6IHtcblx0XHRcdFx0XHRcdFx0J2NoZWNrX25vZGUnOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICggISBub2RlLmhhc0NsYXNzKCdkaXNhYmxlZCcpKTtcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0J3VuY2hlY2tfbm9kZSc6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKCAhIG5vZGUuaGFzQ2xhc3MoJ2Rpc2FibGVkJykpO1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHQnc2VsZWN0X25vZGUnOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICggISBub2RlLmhhc0NsYXNzKCdkaXNhYmxlZCcpKTtcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0J2Rlc2VsZWN0X25vZGUnOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICggISBub2RlLmhhc0NsYXNzKCdkaXNhYmxlZCcpKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0J3BsdWdpbnMnOiBbJ2h0bWxfZGF0YScsICd1aScsICd0aGVtZXMnLCAndHlwZXMnXVxuXHRcdFx0fTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIElmIHRoZSBmaWVsZCBpcyBjb250YWluZWQgaW4gYSBmb3JtLCBzdWJtaXQgYWxsIGZvcm0gcGFyYW1ldGVycyBieSBkZWZhdWx0LlxuXHRcdCAqIFRoaXMgaXMgdXNlZnVsIHRvIGtlZXAgc3RhdGUgbGlrZSBsb2NhbGUgdmFsdWVzIHdoaWNoIGFyZSB0eXBpY2FsbHlcblx0XHQgKiBlbmNvZGVkIGluIGhpZGRlbiBmaWVsZHMgdGhyb3VnaCB0aGUgZm9ybS5cblx0XHQgKiBcblx0XHQgKiBAcmV0dXJuIHtvYmplY3R9XG5cdFx0ICovXG5cdFx0Z2V0UmVxdWVzdFBhcmFtczogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4ge307XG5cdFx0fVxuXHR9KTtcblx0XG5cdCQoJy5UcmVlRHJvcGRvd25GaWVsZCAudHJlZS1ob2xkZXIgbGknKS5lbnR3aW5lKHtcblx0XHQvKipcblx0XHQgKiBPdmVybG9hZCB0byByZXR1cm4gbW9yZSBkYXRhLiBUaGUgc2FtZSBkYXRhIHNob3VsZCBiZSBzZXQgb24gaW5pdGlhbFxuXHRcdCAqIHZhbHVlIHRocm91Z2ggUEhQIGFzIHdlbGwgKHNlZSBUcmVlRHJvcGRvd25GaWVsZC0+RmllbGQoKSkuXG5cdFx0ICogXG5cdFx0ICogQHJldHVybiB7b2JqZWN0fVxuXHRcdCAqL1xuXHRcdGdldE1ldGFEYXRhOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBtYXRjaGVzID0gdGhpcy5hdHRyKCdjbGFzcycpLm1hdGNoKC9jbGFzcy0oW15cXHNdKikvaSk7XG5cdFx0XHR2YXIga2xhc3MgPSBtYXRjaGVzID8gbWF0Y2hlc1sxXSA6ICcnO1xuXHRcdFx0cmV0dXJuIHtDbGFzc05hbWU6IGtsYXNzfTtcblx0XHR9XG5cdH0pO1xuXHRcblx0JCgnLlRyZWVEcm9wZG93bkZpZWxkIConKS5lbnR3aW5lKHtcblx0XHRnZXRGaWVsZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnRzKCcuVHJlZURyb3Bkb3duRmllbGQ6Zmlyc3QnKTtcblx0XHR9XG5cdH0pO1xuXHRcblx0JCgnLlRyZWVEcm9wZG93bkZpZWxkJykuZW50d2luZSh7XG5cdFx0b25jbGljazogZnVuY3Rpb24oZSkge1xuXHRcdFx0dGhpcy50b2dnbGVQYW5lbCgpO1xuXHRcdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0pO1xuXG5cdCQoJy5UcmVlRHJvcGRvd25GaWVsZCAudHJlZWRyb3Bkb3duZmllbGQtcGFuZWwnKS5lbnR3aW5lKHtcblx0XHRvbmNsaWNrOiBmdW5jdGlvbihlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9KTtcblx0XG5cdCQoJy5UcmVlRHJvcGRvd25GaWVsZC5zZWFyY2hhYmxlJykuZW50d2luZSh7XG5cdFx0b25hZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHRcdHZhciB0aXRsZSA9IGkxOG4uX3QoJ1RyZWVEcm9wZG93bkZpZWxkLkVOVEVSVE9TRUFSQ0gnKTtcblx0XHRcdHRoaXMuZmluZCgnLnRyZWVkcm9wZG93bmZpZWxkLXBhbmVsJykucHJlcGVuZChcblx0XHRcdFx0JCgnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJzZWFyY2ggdHJlZWRyb3Bkb3duZmllbGQtc2VhcmNoXCIgZGF0YS1za2lwLWF1dG9mb2N1cz1cInRydWVcIiBwbGFjZWhvbGRlcj1cIicgKyB0aXRsZSArICdcIiB2YWx1ZT1cIlwiIC8+Jylcblx0XHRcdCk7XG5cdFx0fSxcblx0XHRzZWFyY2g6IGZ1bmN0aW9uKHN0ciwgY2FsbGJhY2spIHtcblx0XHRcdHRoaXMub3BlblBhbmVsKCk7XG5cdFx0XHR0aGlzLmxvYWRUcmVlKHtzZWFyY2g6IHN0cn0sIGNhbGxiYWNrKTtcblx0XHR9LFxuXHRcdGNhbmNlbFNlYXJjaDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmNsb3NlUGFuZWwoKTtcblx0XHRcdHRoaXMubG9hZFRyZWUoKTtcblx0XHR9XG5cdH0pO1xuXHRcblx0JCgnLlRyZWVEcm9wZG93bkZpZWxkLnNlYXJjaGFibGUgaW5wdXQuc2VhcmNoJykuZW50d2luZSh7XG5cdFx0b25rZXlkb3duOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgZmllbGQgPSB0aGlzLmdldEZpZWxkKCk7XG5cdFx0XHRpZihlLmtleUNvZGUgPT0gMTMpIHtcblx0XHRcdFx0Ly8gdHJpZ2dlciBzZWFyY2ggb24gRU5URVIga2V5XG5cdFx0XHRcdGZpZWxkLnNlYXJjaCh0aGlzLnZhbCgpKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmKGUua2V5Q29kZSA9PSAyNykge1xuXHRcdFx0XHQvLyBjYW5jZWwgc2VhcmNoIG9uIEVTQyBrZXlcblx0XHRcdFx0ZmllbGQuY2FuY2VsU2VhcmNoKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblx0XG5cdCQoJy5UcmVlRHJvcGRvd25GaWVsZC5tdWx0aXBsZScpLmVudHdpbmUoe1xuXHRcdGdldFRyZWVDb25maWc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNmZyA9IHRoaXMuX3N1cGVyKCk7XG5cdFx0XHRjZmcuY2hlY2tib3ggPSB7b3ZlcnJpZGVfdWk6IHRydWUsIHR3b19zdGF0ZTogdHJ1ZX07XG5cdFx0XHRjZmcucGx1Z2lucy5wdXNoKCdjaGVja2JveCcpO1xuXHRcdFx0Y2ZnLnVpLnNlbGVjdF9saW1pdCA9IC0xO1xuXHRcdFx0cmV0dXJuIGNmZztcblx0XHR9LFxuXHRcdGxvYWRUcmVlOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsIHBhbmVsID0gdGhpcy5nZXRQYW5lbCgpLCB0cmVlSG9sZGVyID0gJChwYW5lbCkuZmluZCgnLnRyZWUtaG9sZGVyJyk7XG5cdFx0XHR2YXIgcGFyYW1zID0gKHBhcmFtcykgPyAkLmV4dGVuZCh7fSwgdGhpcy5nZXRSZXF1ZXN0UGFyYW1zKCksIHBhcmFtcykgOiB0aGlzLmdldFJlcXVlc3RQYXJhbXMoKSwgeGhyO1xuXG5cdFx0XHRpZih0aGlzLmdldEN1cnJlbnRYaHIoKSkgdGhpcy5nZXRDdXJyZW50WGhyKCkuYWJvcnQoKTtcblx0XHRcdHBhbmVsLmFkZENsYXNzKCdsb2FkaW5nJyk7XG5cdFx0XHR4aHIgPSAkLmFqYXgoe1xuXHRcdFx0XHR1cmw6IHRoaXMuZGF0YSgndXJsVHJlZScpLFxuXHRcdFx0XHRkYXRhOiBwYXJhbXMsXG5cdFx0XHRcdGNvbXBsZXRlOiBmdW5jdGlvbih4aHIsIHN0YXR1cykge1xuXHRcdFx0XHRcdHBhbmVsLnJlbW92ZUNsYXNzKCdsb2FkaW5nJyk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uKGh0bWwsIHN0YXR1cywgeGhyKSB7XG5cdFx0XHRcdFx0dHJlZUhvbGRlci5odG1sKGh0bWwpO1xuXHRcdFx0XHRcdHZhciBmaXJzdExvYWQgPSB0cnVlO1xuXHRcdFx0XHRcdHNlbGYuc2V0Q3VycmVudFhocihudWxsKTtcblx0XHRcdFx0XHR0cmVlSG9sZGVyXG5cdFx0XHRcdFx0XHQuanN0cmVlKCdkZXN0cm95Jylcblx0XHRcdFx0XHRcdC5iaW5kKCdsb2FkZWQuanN0cmVlJywgZnVuY3Rpb24oZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0XHQkLmVhY2goc2VsZi5nZXRWYWx1ZSgpLCBmdW5jdGlvbihpLCB2YWwpIHtcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmluc3QuY2hlY2tfbm9kZSh0cmVlSG9sZGVyLmZpbmQoJypbZGF0YS1pZD0nICsgdmFsICsgJ10nKSk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRmaXJzdExvYWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0aWYoY2FsbGJhY2spIGNhbGxiYWNrLmFwcGx5KHNlbGYpO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdC5qc3RyZWUoc2VsZi5nZXRUcmVlQ29uZmlnKCkpXG5cdFx0XHRcdFx0XHQuYmluZCgndW5jaGVja19ub2RlLmpzdHJlZSBjaGVja19ub2RlLmpzdHJlZScsIGZ1bmN0aW9uKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG5vZGVzID0gZGF0YS5pbnN0LmdldF9jaGVja2VkKG51bGwsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRzZWxmLnNldFZhbHVlKCQubWFwKG5vZGVzLCBmdW5jdGlvbihlbCwgaSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAkKGVsKS5kYXRhKCdpZCcpO1xuXHRcdFx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdFx0XHRcdHNlbGYuc2V0VGl0bGUoJC5tYXAobm9kZXMsIGZ1bmN0aW9uKGVsLCBpKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGRhdGEuaW5zdC5nZXRfdGV4dChlbCk7XG5cdFx0XHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0XHRcdFx0c2VsZi5kYXRhKCdtZXRhZGF0YScsICQubWFwKG5vZGVzLCBmdW5jdGlvbihlbCwgaSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB7aWQ6ICQoZWwpLmRhdGEoJ2lkJyksIG1ldGFkYXRhOiAkKGVsKS5nZXRNZXRhRGF0YSgpfTtcblx0XHRcdFx0XHRcdFx0fSkpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5zZXRDdXJyZW50WGhyKHhocik7XG5cdFx0fSxcblx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdmFsID0gdGhpcy5fc3VwZXIoKTtcblx0XHRcdHJldHVybiB2YWwuc3BsaXQoLyAqLCAqLyk7XG5cdFx0fSxcblx0XHRzZXRWYWx1ZTogZnVuY3Rpb24odmFsKSB7XG5cdFx0XHR0aGlzLl9zdXBlcigkLmlzQXJyYXkodmFsKSA/IHZhbC5qb2luKCcsJykgOiB2YWwpO1xuXHRcdH0sXG5cdFx0c2V0VGl0bGU6IGZ1bmN0aW9uKHRpdGxlKSB7XG5cdFx0XHR0aGlzLl9zdXBlcigkLmlzQXJyYXkodGl0bGUpID8gdGl0bGUuam9pbignLCAnKSA6IHRpdGxlKTtcblx0XHR9LFxuXHRcdHVwZGF0ZVRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIFRPRE8gTm90IHN1cHBvcnRlZCBkdWUgdG8gbXVsdGlwbGUgdmFsdWVzL3RpdGxlcyB5ZXRcblx0XHR9XG5cdH0pO1xuXG5cdCQoJy5UcmVlRHJvcGRvd25GaWVsZCBpbnB1dFt0eXBlPWhpZGRlbl0nKS5lbnR3aW5lKHtcblx0XHRvbmFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdFx0dGhpcy5iaW5kKCdjaGFuZ2UuVHJlZURyb3Bkb3duRmllbGQnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0JCh0aGlzKS5nZXRGaWVsZCgpLnVwZGF0ZVRpdGxlKCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdG9ucmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0XHR0aGlzLnVuYmluZCgnLlRyZWVEcm9wZG93bkZpZWxkJyk7XG5cdFx0fVxuXHR9KTtcbn0pO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIgIC8qIGdsb2JhbHMgcmVxdWlyZSwgbW9kdWxlICovXG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICAgKi9cblxuICB2YXIgcGF0aHRvUmVnZXhwID0gcmVxdWlyZSgncGF0aC10by1yZWdleHAnKTtcblxuICAvKipcbiAgICogTW9kdWxlIGV4cG9ydHMuXG4gICAqL1xuXG4gIG1vZHVsZS5leHBvcnRzID0gcGFnZTtcblxuICAvKipcbiAgICogRGV0ZWN0IGNsaWNrIGV2ZW50XG4gICAqL1xuICB2YXIgY2xpY2tFdmVudCA9ICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGRvY3VtZW50KSAmJiBkb2N1bWVudC5vbnRvdWNoc3RhcnQgPyAndG91Y2hzdGFydCcgOiAnY2xpY2snO1xuXG4gIC8qKlxuICAgKiBUbyB3b3JrIHByb3Blcmx5IHdpdGggdGhlIFVSTFxuICAgKiBoaXN0b3J5LmxvY2F0aW9uIGdlbmVyYXRlZCBwb2x5ZmlsbCBpbiBodHRwczovL2dpdGh1Yi5jb20vZGV2b3RlL0hUTUw1LUhpc3RvcnktQVBJXG4gICAqL1xuXG4gIHZhciBsb2NhdGlvbiA9ICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIHdpbmRvdykgJiYgKHdpbmRvdy5oaXN0b3J5LmxvY2F0aW9uIHx8IHdpbmRvdy5sb2NhdGlvbik7XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gaW5pdGlhbCBkaXNwYXRjaC5cbiAgICovXG5cbiAgdmFyIGRpc3BhdGNoID0gdHJ1ZTtcblxuXG4gIC8qKlxuICAgKiBEZWNvZGUgVVJMIGNvbXBvbmVudHMgKHF1ZXJ5IHN0cmluZywgcGF0aG5hbWUsIGhhc2gpLlxuICAgKiBBY2NvbW1vZGF0ZXMgYm90aCByZWd1bGFyIHBlcmNlbnQgZW5jb2RpbmcgYW5kIHgtd3d3LWZvcm0tdXJsZW5jb2RlZCBmb3JtYXQuXG4gICAqL1xuICB2YXIgZGVjb2RlVVJMQ29tcG9uZW50cyA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEJhc2UgcGF0aC5cbiAgICovXG5cbiAgdmFyIGJhc2UgPSAnJztcblxuICAvKipcbiAgICogUnVubmluZyBmbGFnLlxuICAgKi9cblxuICB2YXIgcnVubmluZztcblxuICAvKipcbiAgICogSGFzaEJhbmcgb3B0aW9uXG4gICAqL1xuXG4gIHZhciBoYXNoYmFuZyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBQcmV2aW91cyBjb250ZXh0LCBmb3IgY2FwdHVyaW5nXG4gICAqIHBhZ2UgZXhpdCBldmVudHMuXG4gICAqL1xuXG4gIHZhciBwcmV2Q29udGV4dDtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYHBhdGhgIHdpdGggY2FsbGJhY2sgYGZuKClgLFxuICAgKiBvciByb3V0ZSBgcGF0aGAsIG9yIHJlZGlyZWN0aW9uLFxuICAgKiBvciBgcGFnZS5zdGFydCgpYC5cbiAgICpcbiAgICogICBwYWdlKGZuKTtcbiAgICogICBwYWdlKCcqJywgZm4pO1xuICAgKiAgIHBhZ2UoJy91c2VyLzppZCcsIGxvYWQsIHVzZXIpO1xuICAgKiAgIHBhZ2UoJy91c2VyLycgKyB1c2VyLmlkLCB7IHNvbWU6ICd0aGluZycgfSk7XG4gICAqICAgcGFnZSgnL3VzZXIvJyArIHVzZXIuaWQpO1xuICAgKiAgIHBhZ2UoJy9mcm9tJywgJy90bycpXG4gICAqICAgcGFnZSgpO1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gcGF0aFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbi4uLlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBwYWdlKHBhdGgsIGZuKSB7XG4gICAgLy8gPGNhbGxiYWNrPlxuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgcGF0aCkge1xuICAgICAgcmV0dXJuIHBhZ2UoJyonLCBwYXRoKTtcbiAgICB9XG5cbiAgICAvLyByb3V0ZSA8cGF0aD4gdG8gPGNhbGxiYWNrIC4uLj5cbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZuKSB7XG4gICAgICB2YXIgcm91dGUgPSBuZXcgUm91dGUocGF0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBwYWdlLmNhbGxiYWNrcy5wdXNoKHJvdXRlLm1pZGRsZXdhcmUoYXJndW1lbnRzW2ldKSk7XG4gICAgICB9XG4gICAgICAvLyBzaG93IDxwYXRoPiB3aXRoIFtzdGF0ZV1cbiAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgcGF0aCkge1xuICAgICAgcGFnZVsnc3RyaW5nJyA9PT0gdHlwZW9mIGZuID8gJ3JlZGlyZWN0JyA6ICdzaG93J10ocGF0aCwgZm4pO1xuICAgICAgLy8gc3RhcnQgW29wdGlvbnNdXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhZ2Uuc3RhcnQocGF0aCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgICovXG5cbiAgcGFnZS5jYWxsYmFja3MgPSBbXTtcbiAgcGFnZS5leGl0cyA9IFtdO1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IHBhdGggYmVpbmcgcHJvY2Vzc2VkXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBwYWdlLmN1cnJlbnQgPSAnJztcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHBhZ2VzIG5hdmlnYXRlZCB0by5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICpcbiAgICogICAgIHBhZ2UubGVuID09IDA7XG4gICAqICAgICBwYWdlKCcvbG9naW4nKTtcbiAgICogICAgIHBhZ2UubGVuID09IDE7XG4gICAqL1xuXG4gIHBhZ2UubGVuID0gMDtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCBiYXNlcGF0aCB0byBgcGF0aGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHBhZ2UuYmFzZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBpZiAoMCA9PT0gYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGJhc2U7XG4gICAgYmFzZSA9IHBhdGg7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJpbmQgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuICAgKlxuICAgKiBPcHRpb25zOlxuICAgKlxuICAgKiAgICAtIGBjbGlja2AgYmluZCB0byBjbGljayBldmVudHMgW3RydWVdXG4gICAqICAgIC0gYHBvcHN0YXRlYCBiaW5kIHRvIHBvcHN0YXRlIFt0cnVlXVxuICAgKiAgICAtIGBkaXNwYXRjaGAgcGVyZm9ybSBpbml0aWFsIGRpc3BhdGNoIFt0cnVlXVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBwYWdlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChydW5uaW5nKSByZXR1cm47XG4gICAgcnVubmluZyA9IHRydWU7XG4gICAgaWYgKGZhbHNlID09PSBvcHRpb25zLmRpc3BhdGNoKSBkaXNwYXRjaCA9IGZhbHNlO1xuICAgIGlmIChmYWxzZSA9PT0gb3B0aW9ucy5kZWNvZGVVUkxDb21wb25lbnRzKSBkZWNvZGVVUkxDb21wb25lbnRzID0gZmFsc2U7XG4gICAgaWYgKGZhbHNlICE9PSBvcHRpb25zLnBvcHN0YXRlKSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvbnBvcHN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKGZhbHNlICE9PSBvcHRpb25zLmNsaWNrKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGNsaWNrRXZlbnQsIG9uY2xpY2ssIGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKHRydWUgPT09IG9wdGlvbnMuaGFzaGJhbmcpIGhhc2hiYW5nID0gdHJ1ZTtcbiAgICBpZiAoIWRpc3BhdGNoKSByZXR1cm47XG4gICAgdmFyIHVybCA9IChoYXNoYmFuZyAmJiB+bG9jYXRpb24uaGFzaC5pbmRleE9mKCcjIScpKSA/IGxvY2F0aW9uLmhhc2guc3Vic3RyKDIpICsgbG9jYXRpb24uc2VhcmNoIDogbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoO1xuICAgIHBhZ2UucmVwbGFjZSh1cmwsIG51bGwsIHRydWUsIGRpc3BhdGNoKTtcbiAgfTtcblxuICAvKipcbiAgICogVW5iaW5kIGNsaWNrIGFuZCBwb3BzdGF0ZSBldmVudCBoYW5kbGVycy5cbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgcGFnZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFydW5uaW5nKSByZXR1cm47XG4gICAgcGFnZS5jdXJyZW50ID0gJyc7XG4gICAgcGFnZS5sZW4gPSAwO1xuICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGNsaWNrRXZlbnQsIG9uY2xpY2ssIGZhbHNlKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvbnBvcHN0YXRlLCBmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3cgYHBhdGhgIHdpdGggb3B0aW9uYWwgYHN0YXRlYCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpc3BhdGNoXG4gICAqIEByZXR1cm4ge0NvbnRleHR9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHBhZ2Uuc2hvdyA9IGZ1bmN0aW9uKHBhdGgsIHN0YXRlLCBkaXNwYXRjaCwgcHVzaCkge1xuICAgIHZhciBjdHggPSBuZXcgQ29udGV4dChwYXRoLCBzdGF0ZSk7XG4gICAgcGFnZS5jdXJyZW50ID0gY3R4LnBhdGg7XG4gICAgaWYgKGZhbHNlICE9PSBkaXNwYXRjaCkgcGFnZS5kaXNwYXRjaChjdHgpO1xuICAgIGlmIChmYWxzZSAhPT0gY3R4LmhhbmRsZWQgJiYgZmFsc2UgIT09IHB1c2gpIGN0eC5wdXNoU3RhdGUoKTtcbiAgICByZXR1cm4gY3R4O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHb2VzIGJhY2sgaW4gdGhlIGhpc3RvcnlcbiAgICogQmFjayBzaG91bGQgYWx3YXlzIGxldCB0aGUgY3VycmVudCByb3V0ZSBwdXNoIHN0YXRlIGFuZCB0aGVuIGdvIGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gZmFsbGJhY2sgcGF0aCB0byBnbyBiYWNrIGlmIG5vIG1vcmUgaGlzdG9yeSBleGlzdHMsIGlmIHVuZGVmaW5lZCBkZWZhdWx0cyB0byBwYWdlLmJhc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtzdGF0ZV1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgcGFnZS5iYWNrID0gZnVuY3Rpb24ocGF0aCwgc3RhdGUpIHtcbiAgICBpZiAocGFnZS5sZW4gPiAwKSB7XG4gICAgICAvLyB0aGlzIG1heSBuZWVkIG1vcmUgdGVzdGluZyB0byBzZWUgaWYgYWxsIGJyb3dzZXJzXG4gICAgICAvLyB3YWl0IGZvciB0aGUgbmV4dCB0aWNrIHRvIGdvIGJhY2sgaW4gaGlzdG9yeVxuICAgICAgaGlzdG9yeS5iYWNrKCk7XG4gICAgICBwYWdlLmxlbi0tO1xuICAgIH0gZWxzZSBpZiAocGF0aCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcGFnZS5zaG93KHBhdGgsIHN0YXRlKTtcbiAgICAgIH0pO1xuICAgIH1lbHNle1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcGFnZS5zaG93KGJhc2UsIHN0YXRlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciByb3V0ZSB0byByZWRpcmVjdCBmcm9tIG9uZSBwYXRoIHRvIG90aGVyXG4gICAqIG9yIGp1c3QgcmVkaXJlY3QgdG8gYW5vdGhlciByb3V0ZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZnJvbSAtIGlmIHBhcmFtICd0bycgaXMgdW5kZWZpbmVkIHJlZGlyZWN0cyB0byAnZnJvbSdcbiAgICogQHBhcmFtIHtTdHJpbmd9IFt0b11cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIHBhZ2UucmVkaXJlY3QgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICAgIC8vIERlZmluZSByb3V0ZSBmcm9tIGEgcGF0aCB0byBhbm90aGVyXG4gICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgZnJvbSAmJiAnc3RyaW5nJyA9PT0gdHlwZW9mIHRvKSB7XG4gICAgICBwYWdlKGZyb20sIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBwYWdlLnJlcGxhY2UodG8pO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFdhaXQgZm9yIHRoZSBwdXNoIHN0YXRlIGFuZCByZXBsYWNlIGl0IHdpdGggYW5vdGhlclxuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIGZyb20gJiYgJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0bykge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcGFnZS5yZXBsYWNlKGZyb20pO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlIGBwYXRoYCB3aXRoIG9wdGlvbmFsIGBzdGF0ZWAgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAgICogQHJldHVybiB7Q29udGV4dH1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cblxuICBwYWdlLnJlcGxhY2UgPSBmdW5jdGlvbihwYXRoLCBzdGF0ZSwgaW5pdCwgZGlzcGF0Y2gpIHtcbiAgICB2YXIgY3R4ID0gbmV3IENvbnRleHQocGF0aCwgc3RhdGUpO1xuICAgIHBhZ2UuY3VycmVudCA9IGN0eC5wYXRoO1xuICAgIGN0eC5pbml0ID0gaW5pdDtcbiAgICBjdHguc2F2ZSgpOyAvLyBzYXZlIGJlZm9yZSBkaXNwYXRjaGluZywgd2hpY2ggbWF5IHJlZGlyZWN0XG4gICAgaWYgKGZhbHNlICE9PSBkaXNwYXRjaCkgcGFnZS5kaXNwYXRjaChjdHgpO1xuICAgIHJldHVybiBjdHg7XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoIHRoZSBnaXZlbiBgY3R4YC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGN0eFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgcGFnZS5kaXNwYXRjaCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIHZhciBwcmV2ID0gcHJldkNvbnRleHQsXG4gICAgICBpID0gMCxcbiAgICAgIGogPSAwO1xuXG4gICAgcHJldkNvbnRleHQgPSBjdHg7XG5cbiAgICBmdW5jdGlvbiBuZXh0RXhpdCgpIHtcbiAgICAgIHZhciBmbiA9IHBhZ2UuZXhpdHNbaisrXTtcbiAgICAgIGlmICghZm4pIHJldHVybiBuZXh0RW50ZXIoKTtcbiAgICAgIGZuKHByZXYsIG5leHRFeGl0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXh0RW50ZXIoKSB7XG4gICAgICB2YXIgZm4gPSBwYWdlLmNhbGxiYWNrc1tpKytdO1xuXG4gICAgICBpZiAoY3R4LnBhdGggIT09IHBhZ2UuY3VycmVudCkge1xuICAgICAgICBjdHguaGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWZuKSByZXR1cm4gdW5oYW5kbGVkKGN0eCk7XG4gICAgICBmbihjdHgsIG5leHRFbnRlcik7XG4gICAgfVxuXG4gICAgaWYgKHByZXYpIHtcbiAgICAgIG5leHRFeGl0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRFbnRlcigpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVW5oYW5kbGVkIGBjdHhgLiBXaGVuIGl0J3Mgbm90IHRoZSBpbml0aWFsXG4gICAqIHBvcHN0YXRlIHRoZW4gcmVkaXJlY3QuIElmIHlvdSB3aXNoIHRvIGhhbmRsZVxuICAgKiA0MDRzIG9uIHlvdXIgb3duIHVzZSBgcGFnZSgnKicsIGNhbGxiYWNrKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29udGV4dH0gY3R4XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBmdW5jdGlvbiB1bmhhbmRsZWQoY3R4KSB7XG4gICAgaWYgKGN0eC5oYW5kbGVkKSByZXR1cm47XG4gICAgdmFyIGN1cnJlbnQ7XG5cbiAgICBpZiAoaGFzaGJhbmcpIHtcbiAgICAgIGN1cnJlbnQgPSBiYXNlICsgbG9jYXRpb24uaGFzaC5yZXBsYWNlKCcjIScsICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudCA9IGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50ID09PSBjdHguY2Fub25pY2FsUGF0aCkgcmV0dXJuO1xuICAgIHBhZ2Uuc3RvcCgpO1xuICAgIGN0eC5oYW5kbGVkID0gZmFsc2U7XG4gICAgbG9jYXRpb24uaHJlZiA9IGN0eC5jYW5vbmljYWxQYXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV4aXQgcm91dGUgb24gYHBhdGhgIHdpdGhcbiAgICogY2FsbGJhY2sgYGZuKClgLCB3aGljaCB3aWxsIGJlIGNhbGxlZFxuICAgKiBvbiB0aGUgcHJldmlvdXMgY29udGV4dCB3aGVuIGEgbmV3XG4gICAqIHBhZ2UgaXMgdmlzaXRlZC5cbiAgICovXG4gIHBhZ2UuZXhpdCA9IGZ1bmN0aW9uKHBhdGgsIGZuKSB7XG4gICAgaWYgKHR5cGVvZiBwYXRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcGFnZS5leGl0KCcqJywgcGF0aCk7XG4gICAgfVxuXG4gICAgdmFyIHJvdXRlID0gbmV3IFJvdXRlKHBhdGgpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBwYWdlLmV4aXRzLnB1c2gocm91dGUubWlkZGxld2FyZShhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBVUkwgZW5jb2RpbmcgZnJvbSB0aGUgZ2l2ZW4gYHN0cmAuXG4gICAqIEFjY29tbW9kYXRlcyB3aGl0ZXNwYWNlIGluIGJvdGggeC13d3ctZm9ybS11cmxlbmNvZGVkXG4gICAqIGFuZCByZWd1bGFyIHBlcmNlbnQtZW5jb2RlZCBmb3JtLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cn0gVVJMIGNvbXBvbmVudCB0byBkZWNvZGVcbiAgICovXG4gIGZ1bmN0aW9uIGRlY29kZVVSTEVuY29kZWRVUklDb21wb25lbnQodmFsKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnKSB7IHJldHVybiB2YWw7IH1cbiAgICByZXR1cm4gZGVjb2RlVVJMQ29tcG9uZW50cyA/IGRlY29kZVVSSUNvbXBvbmVudCh2YWwucmVwbGFjZSgvXFwrL2csICcgJykpIDogdmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYSBuZXcgXCJyZXF1ZXN0XCIgYENvbnRleHRgXG4gICAqIHdpdGggdGhlIGdpdmVuIGBwYXRoYCBhbmQgb3B0aW9uYWwgaW5pdGlhbCBgc3RhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gQ29udGV4dChwYXRoLCBzdGF0ZSkge1xuICAgIGlmICgnLycgPT09IHBhdGhbMF0gJiYgMCAhPT0gcGF0aC5pbmRleE9mKGJhc2UpKSBwYXRoID0gYmFzZSArIChoYXNoYmFuZyA/ICcjIScgOiAnJykgKyBwYXRoO1xuICAgIHZhciBpID0gcGF0aC5pbmRleE9mKCc/Jyk7XG5cbiAgICB0aGlzLmNhbm9uaWNhbFBhdGggPSBwYXRoO1xuICAgIHRoaXMucGF0aCA9IHBhdGgucmVwbGFjZShiYXNlLCAnJykgfHwgJy8nO1xuICAgIGlmIChoYXNoYmFuZykgdGhpcy5wYXRoID0gdGhpcy5wYXRoLnJlcGxhY2UoJyMhJywgJycpIHx8ICcvJztcblxuICAgIHRoaXMudGl0bGUgPSBkb2N1bWVudC50aXRsZTtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGUgfHwge307XG4gICAgdGhpcy5zdGF0ZS5wYXRoID0gcGF0aDtcbiAgICB0aGlzLnF1ZXJ5c3RyaW5nID0gfmkgPyBkZWNvZGVVUkxFbmNvZGVkVVJJQ29tcG9uZW50KHBhdGguc2xpY2UoaSArIDEpKSA6ICcnO1xuICAgIHRoaXMucGF0aG5hbWUgPSBkZWNvZGVVUkxFbmNvZGVkVVJJQ29tcG9uZW50KH5pID8gcGF0aC5zbGljZSgwLCBpKSA6IHBhdGgpO1xuICAgIHRoaXMucGFyYW1zID0ge307XG5cbiAgICAvLyBmcmFnbWVudFxuICAgIHRoaXMuaGFzaCA9ICcnO1xuICAgIGlmICghaGFzaGJhbmcpIHtcbiAgICAgIGlmICghfnRoaXMucGF0aC5pbmRleE9mKCcjJykpIHJldHVybjtcbiAgICAgIHZhciBwYXJ0cyA9IHRoaXMucGF0aC5zcGxpdCgnIycpO1xuICAgICAgdGhpcy5wYXRoID0gcGFydHNbMF07XG4gICAgICB0aGlzLmhhc2ggPSBkZWNvZGVVUkxFbmNvZGVkVVJJQ29tcG9uZW50KHBhcnRzWzFdKSB8fCAnJztcbiAgICAgIHRoaXMucXVlcnlzdHJpbmcgPSB0aGlzLnF1ZXJ5c3RyaW5nLnNwbGl0KCcjJylbMF07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9zZSBgQ29udGV4dGAuXG4gICAqL1xuXG4gIHBhZ2UuQ29udGV4dCA9IENvbnRleHQ7XG5cbiAgLyoqXG4gICAqIFB1c2ggc3RhdGUuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBDb250ZXh0LnByb3RvdHlwZS5wdXNoU3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgICBwYWdlLmxlbisrO1xuICAgIGhpc3RvcnkucHVzaFN0YXRlKHRoaXMuc3RhdGUsIHRoaXMudGl0bGUsIGhhc2hiYW5nICYmIHRoaXMucGF0aCAhPT0gJy8nID8gJyMhJyArIHRoaXMucGF0aCA6IHRoaXMuY2Fub25pY2FsUGF0aCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNhdmUgdGhlIGNvbnRleHQgc3RhdGUuXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIENvbnRleHQucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbigpIHtcbiAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZSh0aGlzLnN0YXRlLCB0aGlzLnRpdGxlLCBoYXNoYmFuZyAmJiB0aGlzLnBhdGggIT09ICcvJyA/ICcjIScgKyB0aGlzLnBhdGggOiB0aGlzLmNhbm9uaWNhbFBhdGgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGBSb3V0ZWAgd2l0aCB0aGUgZ2l2ZW4gSFRUUCBgcGF0aGAsXG4gICAqIGFuZCBhbiBhcnJheSBvZiBgY2FsbGJhY2tzYCBhbmQgYG9wdGlvbnNgLlxuICAgKlxuICAgKiBPcHRpb25zOlxuICAgKlxuICAgKiAgIC0gYHNlbnNpdGl2ZWAgICAgZW5hYmxlIGNhc2Utc2Vuc2l0aXZlIHJvdXRlc1xuICAgKiAgIC0gYHN0cmljdGAgICAgICAgZW5hYmxlIHN0cmljdCBtYXRjaGluZyBmb3IgdHJhaWxpbmcgc2xhc2hlc1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIFJvdXRlKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMubWV0aG9kID0gJ0dFVCc7XG4gICAgdGhpcy5yZWdleHAgPSBwYXRodG9SZWdleHAodGhpcy5wYXRoLFxuICAgICAgdGhpcy5rZXlzID0gW10sXG4gICAgICBvcHRpb25zLnNlbnNpdGl2ZSxcbiAgICAgIG9wdGlvbnMuc3RyaWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvc2UgYFJvdXRlYC5cbiAgICovXG5cbiAgcGFnZS5Sb3V0ZSA9IFJvdXRlO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gcm91dGUgbWlkZGxld2FyZSB3aXRoXG4gICAqIHRoZSBnaXZlbiBjYWxsYmFjayBgZm4oKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBSb3V0ZS5wcm90b3R5cGUubWlkZGxld2FyZSA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbihjdHgsIG5leHQpIHtcbiAgICAgIGlmIChzZWxmLm1hdGNoKGN0eC5wYXRoLCBjdHgucGFyYW1zKSkgcmV0dXJuIGZuKGN0eCwgbmV4dCk7XG4gICAgICBuZXh0KCk7XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhpcyByb3V0ZSBtYXRjaGVzIGBwYXRoYCwgaWYgc29cbiAgICogcG9wdWxhdGUgYHBhcmFtc2AuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIFJvdXRlLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uKHBhdGgsIHBhcmFtcykge1xuICAgIHZhciBrZXlzID0gdGhpcy5rZXlzLFxuICAgICAgcXNJbmRleCA9IHBhdGguaW5kZXhPZignPycpLFxuICAgICAgcGF0aG5hbWUgPSB+cXNJbmRleCA/IHBhdGguc2xpY2UoMCwgcXNJbmRleCkgOiBwYXRoLFxuICAgICAgbSA9IHRoaXMucmVnZXhwLmV4ZWMoZGVjb2RlVVJJQ29tcG9uZW50KHBhdGhuYW1lKSk7XG5cbiAgICBpZiAoIW0pIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBtLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpIC0gMV07XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWwgPSBkZWNvZGVVUkxFbmNvZGVkVVJJQ29tcG9uZW50KG1baV0pO1xuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQgfHwgIShoYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywga2V5Lm5hbWUpKSkge1xuICAgICAgICAgIHBhcmFtc1trZXkubmFtZV0gPSB2YWw7XG4gICAgICAgIH0gICAgICAgIFxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cblxuICAvKipcbiAgICogSGFuZGxlIFwicG9wdWxhdGVcIiBldmVudHMuXG4gICAqL1xuXG4gIHZhciBvbnBvcHN0YXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbG9hZGVkID0gZmFsc2U7XG4gICAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2Ygd2luZG93KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICBsb2FkZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxvYWRlZCA9IHRydWU7XG4gICAgICAgIH0sIDApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiBvbnBvcHN0YXRlKGUpIHtcbiAgICAgIGlmICghbG9hZGVkKSByZXR1cm47XG4gICAgICBpZiAoZS5zdGF0ZSkge1xuICAgICAgICB2YXIgcGF0aCA9IGUuc3RhdGUucGF0aDtcbiAgICAgICAgcGFnZS5yZXBsYWNlKHBhdGgsIGUuc3RhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFnZS5zaG93KGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uaGFzaCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuICAvKipcbiAgICogSGFuZGxlIFwiY2xpY2tcIiBldmVudHMuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uY2xpY2soZSkge1xuXG4gICAgaWYgKDEgIT09IHdoaWNoKGUpKSByZXR1cm47XG5cbiAgICBpZiAoZS5tZXRhS2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSByZXR1cm47XG4gICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXG5cblxuICAgIC8vIGVuc3VyZSBsaW5rXG4gICAgdmFyIGVsID0gZS50YXJnZXQ7XG4gICAgd2hpbGUgKGVsICYmICdBJyAhPT0gZWwubm9kZU5hbWUpIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgICBpZiAoIWVsIHx8ICdBJyAhPT0gZWwubm9kZU5hbWUpIHJldHVybjtcblxuXG5cbiAgICAvLyBJZ25vcmUgaWYgdGFnIGhhc1xuICAgIC8vIDEuIFwiZG93bmxvYWRcIiBhdHRyaWJ1dGVcbiAgICAvLyAyLiByZWw9XCJleHRlcm5hbFwiIGF0dHJpYnV0ZVxuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2Rvd25sb2FkJykgfHwgZWwuZ2V0QXR0cmlidXRlKCdyZWwnKSA9PT0gJ2V4dGVybmFsJykgcmV0dXJuO1xuXG4gICAgLy8gZW5zdXJlIG5vbi1oYXNoIGZvciB0aGUgc2FtZSBwYXRoXG4gICAgdmFyIGxpbmsgPSBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICBpZiAoIWhhc2hiYW5nICYmIGVsLnBhdGhuYW1lID09PSBsb2NhdGlvbi5wYXRobmFtZSAmJiAoZWwuaGFzaCB8fCAnIycgPT09IGxpbmspKSByZXR1cm47XG5cblxuXG4gICAgLy8gQ2hlY2sgZm9yIG1haWx0bzogaW4gdGhlIGhyZWZcbiAgICBpZiAobGluayAmJiBsaW5rLmluZGV4T2YoJ21haWx0bzonKSA+IC0xKSByZXR1cm47XG5cbiAgICAvLyBjaGVjayB0YXJnZXRcbiAgICBpZiAoZWwudGFyZ2V0KSByZXR1cm47XG5cbiAgICAvLyB4LW9yaWdpblxuICAgIGlmICghc2FtZU9yaWdpbihlbC5ocmVmKSkgcmV0dXJuO1xuXG5cblxuICAgIC8vIHJlYnVpbGQgcGF0aFxuICAgIHZhciBwYXRoID0gZWwucGF0aG5hbWUgKyBlbC5zZWFyY2ggKyAoZWwuaGFzaCB8fCAnJyk7XG5cbiAgICAvLyBzdHJpcCBsZWFkaW5nIFwiL1tkcml2ZSBsZXR0ZXJdOlwiIG9uIE5XLmpzIG9uIFdpbmRvd3NcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHBhdGgubWF0Y2goL15cXC9bYS16QS1aXTpcXC8vKSkge1xuICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcL1thLXpBLVpdOlxcLy8sICcvJyk7XG4gICAgfVxuXG4gICAgLy8gc2FtZSBwYWdlXG4gICAgdmFyIG9yaWcgPSBwYXRoO1xuXG4gICAgaWYgKHBhdGguaW5kZXhPZihiYXNlKSA9PT0gMCkge1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKGJhc2UubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzaGJhbmcpIHBhdGggPSBwYXRoLnJlcGxhY2UoJyMhJywgJycpO1xuXG4gICAgaWYgKGJhc2UgJiYgb3JpZyA9PT0gcGF0aCkgcmV0dXJuO1xuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHBhZ2Uuc2hvdyhvcmlnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBidXR0b24uXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHdoaWNoKGUpIHtcbiAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgcmV0dXJuIG51bGwgPT09IGUud2hpY2ggPyBlLmJ1dHRvbiA6IGUud2hpY2g7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYGhyZWZgIGlzIHRoZSBzYW1lIG9yaWdpbi5cbiAgICovXG5cbiAgZnVuY3Rpb24gc2FtZU9yaWdpbihocmVmKSB7XG4gICAgdmFyIG9yaWdpbiA9IGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3RuYW1lO1xuICAgIGlmIChsb2NhdGlvbi5wb3J0KSBvcmlnaW4gKz0gJzonICsgbG9jYXRpb24ucG9ydDtcbiAgICByZXR1cm4gKGhyZWYgJiYgKDAgPT09IGhyZWYuaW5kZXhPZihvcmlnaW4pKSk7XG4gIH1cblxuICBwYWdlLnNhbWVPcmlnaW4gPSBzYW1lT3JpZ2luO1xuIiwiLyoqXG4gKiBFeHBvc2UgYHBhdGh0b1JlZ2V4cGAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRodG9SZWdleHA7XG5cbi8qKlxuICogTWF0Y2ggbWF0Y2hpbmcgZ3JvdXBzIGluIGEgcmVndWxhciBleHByZXNzaW9uLlxuICovXG52YXIgTUFUQ0hJTkdfR1JPVVBfUkVHRVhQID0gL1xcKCg/IVxcPykvZztcblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLFxuICogcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IHNob3VsZCBiZSBwYXNzZWQsXG4gKiB3aGljaCB3aWxsIGNvbnRhaW4gdGhlIHBsYWNlaG9sZGVyXG4gKiBrZXkgbmFtZXMuIEZvciBleGFtcGxlIFwiL3VzZXIvOmlkXCIgd2lsbFxuICogdGhlbiBjb250YWluIFtcImlkXCJdLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ3xSZWdFeHB8QXJyYXl9IHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhdGh0b1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBrZXlzID0ga2V5cyB8fCBbXTtcbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xuICB2YXIgZW5kID0gb3B0aW9ucy5lbmQgIT09IGZhbHNlO1xuICB2YXIgZmxhZ3MgPSBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knO1xuICB2YXIgZXh0cmFPZmZzZXQgPSAwO1xuICB2YXIga2V5c09mZnNldCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBuYW1lID0gMDtcbiAgdmFyIG07XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICB3aGlsZSAobSA9IE1BVENISU5HX0dST1VQX1JFR0VYUC5leGVjKHBhdGguc291cmNlKSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgbmFtZTogbmFtZSsrLFxuICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgIG9mZnNldDogbS5pbmRleFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIC8vIE1hcCBhcnJheSBwYXJ0cyBpbnRvIHJlZ2V4cHMgYW5kIHJldHVybiB0aGVpciBzb3VyY2UuIFdlIGFsc28gcGFzc1xuICAgIC8vIHRoZSBzYW1lIGtleXMgYW5kIG9wdGlvbnMgaW5zdGFuY2UgaW50byBldmVyeSBnZW5lcmF0aW9uIHRvIGdldFxuICAgIC8vIGNvbnNpc3RlbnQgbWF0Y2hpbmcgZ3JvdXBzIGJlZm9yZSB3ZSBqb2luIHRoZSBzb3VyY2VzIHRvZ2V0aGVyLlxuICAgIHBhdGggPSBwYXRoLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBwYXRodG9SZWdleHAodmFsdWUsIGtleXMsIG9wdGlvbnMpLnNvdXJjZTtcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgUmVnRXhwKCcoPzonICsgcGF0aC5qb2luKCd8JykgKyAnKScsIGZsYWdzKTtcbiAgfVxuXG4gIHBhdGggPSAoJ14nICsgcGF0aCArIChzdHJpY3QgPyAnJyA6IHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJy8nID8gJz8nIDogJy8/JykpXG4gICAgLnJlcGxhY2UoL1xcL1xcKC9nLCAnLyg/OicpXG4gICAgLnJlcGxhY2UoLyhbXFwvXFwuXSkvZywgJ1xcXFwkMScpXG4gICAgLnJlcGxhY2UoLyhcXFxcXFwvKT8oXFxcXFxcLik/OihcXHcrKShcXCguKj9cXCkpPyhcXCopPyhcXD8pPy9nLCBmdW5jdGlvbiAobWF0Y2gsIHNsYXNoLCBmb3JtYXQsIGtleSwgY2FwdHVyZSwgc3Rhciwgb3B0aW9uYWwsIG9mZnNldCkge1xuICAgICAgc2xhc2ggPSBzbGFzaCB8fCAnJztcbiAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgIGNhcHR1cmUgPSBjYXB0dXJlIHx8ICcoW15cXFxcLycgKyBmb3JtYXQgKyAnXSs/KSc7XG4gICAgICBvcHRpb25hbCA9IG9wdGlvbmFsIHx8ICcnO1xuXG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIG9wdGlvbmFsOiAhIW9wdGlvbmFsLFxuICAgICAgICBvZmZzZXQ6IG9mZnNldCArIGV4dHJhT2Zmc2V0XG4gICAgICB9KTtcblxuICAgICAgdmFyIHJlc3VsdCA9ICcnXG4gICAgICAgICsgKG9wdGlvbmFsID8gJycgOiBzbGFzaClcbiAgICAgICAgKyAnKD86J1xuICAgICAgICArIGZvcm1hdCArIChvcHRpb25hbCA/IHNsYXNoIDogJycpICsgY2FwdHVyZVxuICAgICAgICArIChzdGFyID8gJygoPzpbXFxcXC8nICsgZm9ybWF0ICsgJ10uKz8pPyknIDogJycpXG4gICAgICAgICsgJyknXG4gICAgICAgICsgb3B0aW9uYWw7XG5cbiAgICAgIGV4dHJhT2Zmc2V0ICs9IHJlc3VsdC5sZW5ndGggLSBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSlcbiAgICAucmVwbGFjZSgvXFwqL2csIGZ1bmN0aW9uIChzdGFyLCBpbmRleCkge1xuICAgICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoXG5cbiAgICAgIHdoaWxlIChsZW4tLSA+IGtleXNPZmZzZXQgJiYga2V5c1tsZW5dLm9mZnNldCA+IGluZGV4KSB7XG4gICAgICAgIGtleXNbbGVuXS5vZmZzZXQgKz0gMzsgLy8gUmVwbGFjZW1lbnQgbGVuZ3RoIG1pbnVzIGFzdGVyaXNrIGxlbmd0aC5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcoLiopJztcbiAgICB9KTtcblxuICAvLyBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgaGFuZGxpbmcgdW5uYW1lZCBtYXRjaGluZyBncm91cHMuXG4gIHdoaWxlIChtID0gTUFUQ0hJTkdfR1JPVVBfUkVHRVhQLmV4ZWMocGF0aCkpIHtcbiAgICB2YXIgZXNjYXBlQ291bnQgPSAwO1xuICAgIHZhciBpbmRleCA9IG0uaW5kZXg7XG5cbiAgICB3aGlsZSAocGF0aC5jaGFyQXQoLS1pbmRleCkgPT09ICdcXFxcJykge1xuICAgICAgZXNjYXBlQ291bnQrKztcbiAgICB9XG5cbiAgICAvLyBJdCdzIHBvc3NpYmxlIHRvIGVzY2FwZSB0aGUgYnJhY2tldC5cbiAgICBpZiAoZXNjYXBlQ291bnQgJSAyID09PSAxKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoa2V5c09mZnNldCArIGkgPT09IGtleXMubGVuZ3RoIHx8IGtleXNba2V5c09mZnNldCArIGldLm9mZnNldCA+IG0uaW5kZXgpIHtcbiAgICAgIGtleXMuc3BsaWNlKGtleXNPZmZzZXQgKyBpLCAwLCB7XG4gICAgICAgIG5hbWU6IG5hbWUrKywgLy8gVW5uYW1lZCBtYXRjaGluZyBncm91cHMgbXVzdCBiZSBjb25zaXN0ZW50bHkgbGluZWFyLlxuICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgIG9mZnNldDogbS5pbmRleFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaSsrO1xuICB9XG5cbiAgLy8gSWYgdGhlIHBhdGggaXMgbm9uLWVuZGluZywgbWF0Y2ggdW50aWwgdGhlIGVuZCBvciBhIHNsYXNoLlxuICBwYXRoICs9IChlbmQgPyAnJCcgOiAocGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSAnLycgPyAnJyA6ICcoPz1cXFxcL3wkKScpKTtcblxuICByZXR1cm4gbmV3IFJlZ0V4cChwYXRoLCBmbGFncyk7XG59O1xuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDA5LCBTaWx2ZXJTdHJpcGUgTHRkLlxuLy8gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFxuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbi8vICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuLy8gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbi8vICAgICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIDxvcmdhbml6YXRpb24+IG5vciB0aGVcbi8vICAgICAgIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXG4vLyAgICAgICBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbi8vIFxuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBTaWx2ZXJTdHJpcGUgTHRkLiAnJ0FTIElTJycgQU5EIEFOWVxuLy8gRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuLy8gV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuLy8gRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgU2lsdmVyU3RyaXBlIEx0ZC4gQkUgTElBQkxFIEZPUiBBTllcbi8vIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4vLyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4vLyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbi8vIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuLy8gU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG5cbi8qKlxuICogQGNsYXNzIFRyYWNrcyBvbmNoYW5nZSBldmVudHMgb24gYWxsIGZvcm0gZmllbGRzLlxuICogXG4gKiBAdG9kbyBJbXBsZW1lbnQgZm9ybSByZXNldCBoYW5kbGluZ1xuICogIFxuICogQG5hbWUgalF1ZXJ5LmNoYW5nZXRyYWNrZXJcbiAqIEBhdXRob3IgSW5nbyBTY2hvbW1lciwgU2lsdmVyU3RyaXBlIEx0ZC5cbiAqIEBsaWNlbnNlIEJTRCBMaWNlbnNlXG4gKi9cbihmdW5jdGlvbigkKSB7XG5cdCQuZm4uY2hhbmdldHJhY2tlciA9IGZ1bmN0aW9uKF9vcHRpb25zKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYodGhpcy5sZW5ndGggPiAxKXtcblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbihpLCBpdGVtKSB7XG5cdFx0XHRcdHRoaXMuY2hhbmdldHJhY2tlcihfb3B0aW9ucyk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRoaXMuZGVmYXVsdHMgPSB7XG5cdFx0XHRmaWVsZFNlbGVjdG9yOiAnOmlucHV0Om5vdCg6c3VibWl0KScsXG5cdFx0XHRpZ25vcmVGaWVsZFNlbGVjdG9yOiBcIlwiLFxuXHRcdFx0Y2hhbmdlZENzc0NsYXNzOiAnY2hhbmdlZCdcblx0XHR9O1xuXG5cdFx0dmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0cywgX29wdGlvbnMpO1xuXG5cdFx0dGhpcy5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBvcHRpb25hbCBtZXRhZGF0YSBwbHVnaW4gc3VwcG9ydFxuXHRcdFx0aWYgKCQubWV0YSkgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBvcHRpb25zLCB0aGlzLmRhdGEoKSk7XG5cblx0XHRcdC8vIEZsYWcgaW5kaWNhdGluZyB0aGlzIGZvcm0gd2FzIGRpcnRpZWQgYnkgYW4gZXh0ZXJuYWwgY29tcG9uZW50XG5cdFx0XHR2YXIgZGlydHkgPSBmYWxzZTtcblxuXHRcdFx0dmFyIG9uY2hhbmdlID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHR2YXIgJGZpZWxkID0gJChlLnRhcmdldCk7XG5cdFx0XHRcdHZhciBvcmlnVmFsID0gJGZpZWxkLmRhdGEoJ2NoYW5nZXRyYWNrZXIub3JpZ1ZhbCcpLCBuZXdWYWw7XG5cblx0XHRcdFx0Ly8gRGV0ZXJtaW5lIHZhbHVlIGJhc2VkIG9uIGZpZWxkIHR5cGVcblx0XHRcdFx0aWYoJGZpZWxkLmlzKCc6Y2hlY2tib3gnKSkge1xuXHRcdFx0XHRcdG5ld1ZhbCA9ICRmaWVsZC5pcygnOmNoZWNrZWQnKSA/IDEgOiAwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5ld1ZhbCA9ICRmaWVsZC52YWwoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIERldGVybWluZSBjaGFuZ2VkIHN0YXRlIGJhc2VkIG9uIHZhbHVlIGNvbXBhcmlzb25zXG5cdFx0XHRcdGlmKG9yaWdWYWwgPT09IG51bGwgfHwgbmV3VmFsICE9IG9yaWdWYWwpIHtcblx0XHRcdFx0XHQkZmllbGQuYWRkQ2xhc3Mob3B0aW9ucy5jaGFuZ2VkQ3NzQ2xhc3MpO1xuXHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3Mob3B0aW9ucy5jaGFuZ2VkQ3NzQ2xhc3MpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCRmaWVsZC5yZW1vdmVDbGFzcyhvcHRpb25zLmNoYW5nZWRDc3NDbGFzcyk7XG5cdFx0XHRcdFx0Ly8gVW5zZXQgY2hhbmdlZCBzdGF0ZSBvbiBhbGwgcmFkaW8gYnV0dG9ucyBvZiB0aGUgc2FtZSBuYW1lXG5cdFx0XHRcdFx0aWYoJGZpZWxkLmlzKCc6cmFkaW8nKSkge1xuXHRcdFx0XHRcdFx0c2VsZi5maW5kKCc6cmFkaW9bbmFtZT0nICsgJGZpZWxkLmF0dHIoJ25hbWUnKSArICddJykucmVtb3ZlQ2xhc3Mob3B0aW9ucy5jaGFuZ2VkQ3NzQ2xhc3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBPbmx5IHVuc2V0IGZvcm0gc3RhdGUgaWYgbm8gb3RoZXIgZmllbGRzIGFyZSBjaGFuZ2VkIGFzIHdlbGwgYW5kIHRoZSBmb3JtIGlzbid0IGV4cGxpY2l0bHkgZGlydHlcblx0XHRcdFx0XHRpZighZGlydHkgJiYgIXNlbGYuZ2V0RmllbGRzKCkuZmlsdGVyKCcuJyArIG9wdGlvbnMuY2hhbmdlZENzc0NsYXNzKS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3Mob3B0aW9ucy5jaGFuZ2VkQ3NzQ2xhc3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gc2V0dXAgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR2YXIgZmllbGRzID0gdGhpcy5nZXRGaWVsZHMoKSwgb3JpZ1ZhbDtcblx0XHRcdGZpZWxkcy5maWx0ZXIoJzpyYWRpbyw6Y2hlY2tib3gnKS5iaW5kKCdjbGljay5jaGFuZ2V0cmFja2VyJywgb25jaGFuZ2UpO1xuXHRcdFx0ZmllbGRzLm5vdCgnOnJhZGlvLDpjaGVja2JveCcpLmJpbmQoJ2NoYW5nZS5jaGFuZ2V0cmFja2VyJywgb25jaGFuZ2UpO1xuXHRcdFx0ZmllbGRzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmKCQodGhpcykuaXMoJzpyYWRpbyw6Y2hlY2tib3gnKSkge1xuXHRcdFx0XHRcdG9yaWdWYWwgPSBzZWxmLmZpbmQoJzppbnB1dFtuYW1lPScgKyAkKHRoaXMpLmF0dHIoJ25hbWUnKSArICddOmNoZWNrZWQnKS52YWwoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvcmlnVmFsID0gJCh0aGlzKS52YWwoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkKHRoaXMpLmRhdGEoJ2NoYW5nZXRyYWNrZXIub3JpZ1ZhbCcsIG9yaWdWYWwpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHNlbGYuYmluZCgnZGlydHkuY2hhbmdldHJhY2tlcicsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkaXJ0eSA9IHRydWU7XG5cdFx0XHRcdHNlbGYuYWRkQ2xhc3Mob3B0aW9ucy5jaGFuZ2VkQ3NzQ2xhc3MpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuZGF0YSgnY2hhbmdldHJhY2tlcicsIHRydWUpO1xuXHRcdH07XG5cblx0XHR0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuZ2V0RmllbGRzKClcblx0XHRcdFx0LnVuYmluZCgnLmNoYW5nZXRyYWNrZXInKVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3Mob3B0aW9ucy5jaGFuZ2VkQ3NzQ2xhc3MpXG5cdFx0XHRcdC5yZW1vdmVEYXRhKCdjaGFuZ2V0cmFja2VyLm9yaWdWYWwnKTtcblx0XHRcdHRoaXMudW5iaW5kKCcuY2hhbmdldHJhY2tlcicpXG5cdFx0XHRcdC5yZW1vdmVEYXRhKCdjaGFuZ2V0cmFja2VyJyk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlc2V0IGNoYW5nZSBzdGF0ZSBvZiBhbGwgZm9ybSBmaWVsZHMgYW5kIHRoZSBmb3JtIGl0c2VsZi5cblx0XHQgKi9cblx0XHR0aGlzLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmdldEZpZWxkcygpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYucmVzZXRGaWVsZCh0aGlzKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLnJlbW92ZUNsYXNzKG9wdGlvbnMuY2hhbmdlZENzc0NsYXNzKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVzZXQgdGhlIGNoYW5nZSBzaW5nbGUgZm9ybSBmaWVsZC5cblx0XHQgKiBEb2VzIG5vdCByZXNldCB0byB0aGUgb3JpZ2luYWwgdmFsdWUuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0gRE9NRWxlbWVudCBmaWVsZFxuXHRcdCAqL1xuXHRcdHRoaXMucmVzZXRGaWVsZCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG5cdFx0XHRyZXR1cm4gJChmaWVsZCkucmVtb3ZlRGF0YSgnY2hhbmdldHJhY2tlci5vcmlnVmFsJykucmVtb3ZlQ2xhc3MoJ2NoYW5nZWQnKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQHJldHVybiBqUXVlcnkgQ29sbGVjdGlvbiBvZiBmaWVsZHNcblx0XHQgKi9cblx0XHR0aGlzLmdldEZpZWxkcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZmluZChvcHRpb25zLmZpZWxkU2VsZWN0b3IpLm5vdChvcHRpb25zLmlnbm9yZUZpZWxkU2VsZWN0b3IpO1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0IGludm9raW5nIFwicHVibGljXCIgbWV0aG9kcyBhcyBzdHJpbmcgYXJndW1lbnRzXG5cdFx0aWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHR2YXIgcHJvcGVydHkgPSBhcmd1bWVudHNbMV07XG5cdFx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0XHRhcmdzLnNwbGljZSgwLCAxKTtcblx0XHRcdHJldHVybiB0aGlzW2FyZ3VtZW50c1swXV0uYXBwbHkodGhpcywgYXJncyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmluaXRpYWxpemUoKTtcblx0XHR9XG5cblx0fTtcbn0oalF1ZXJ5KSk7XG4iLCIvKipcbiAqIENvb2tpZSBwbHVnaW5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDYgS2xhdXMgSGFydGwgKHN0aWxidWVyby5kZSlcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIGxpY2Vuc2VzOlxuICogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqIGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwuaHRtbFxuICpcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIGNvb2tpZSB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCB2YWx1ZSBhbmQgb3RoZXIgb3B0aW9uYWwgcGFyYW1ldGVycy5cbiAqXG4gKiBAZXhhbXBsZSAkLmNvb2tpZSgndGhlX2Nvb2tpZScsICd0aGVfdmFsdWUnKTtcbiAqIEBkZXNjIFNldCB0aGUgdmFsdWUgb2YgYSBjb29raWUuXG4gKiBAZXhhbXBsZSAkLmNvb2tpZSgndGhlX2Nvb2tpZScsICd0aGVfdmFsdWUnLCB7IGV4cGlyZXM6IDcsIHBhdGg6ICcvJywgZG9tYWluOiAnanF1ZXJ5LmNvbScsIHNlY3VyZTogdHJ1ZSB9KTtcbiAqIEBkZXNjIENyZWF0ZSBhIGNvb2tpZSB3aXRoIGFsbCBhdmFpbGFibGUgb3B0aW9ucy5cbiAqIEBleGFtcGxlICQuY29va2llKCd0aGVfY29va2llJywgJ3RoZV92YWx1ZScpO1xuICogQGRlc2MgQ3JlYXRlIGEgc2Vzc2lvbiBjb29raWUuXG4gKiBAZXhhbXBsZSAkLmNvb2tpZSgndGhlX2Nvb2tpZScsIG51bGwpO1xuICogQGRlc2MgRGVsZXRlIGEgY29va2llIGJ5IHBhc3NpbmcgbnVsbCBhcyB2YWx1ZS4gS2VlcCBpbiBtaW5kIHRoYXQgeW91IGhhdmUgdG8gdXNlIHRoZSBzYW1lIHBhdGggYW5kIGRvbWFpblxuICogICAgICAgdXNlZCB3aGVuIHRoZSBjb29raWUgd2FzIHNldC5cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvb2tpZS5cbiAqIEBwYXJhbSBTdHJpbmcgdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBjb29raWUuXG4gKiBAcGFyYW0gT2JqZWN0IG9wdGlvbnMgQW4gb2JqZWN0IGxpdGVyYWwgY29udGFpbmluZyBrZXkvdmFsdWUgcGFpcnMgdG8gcHJvdmlkZSBvcHRpb25hbCBjb29raWUgYXR0cmlidXRlcy5cbiAqIEBvcHRpb24gTnVtYmVyfERhdGUgZXhwaXJlcyBFaXRoZXIgYW4gaW50ZWdlciBzcGVjaWZ5aW5nIHRoZSBleHBpcmF0aW9uIGRhdGUgZnJvbSBub3cgb24gaW4gZGF5cyBvciBhIERhdGUgb2JqZWN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGEgbmVnYXRpdmUgdmFsdWUgaXMgc3BlY2lmaWVkIChlLmcuIGEgZGF0ZSBpbiB0aGUgcGFzdCksIHRoZSBjb29raWUgd2lsbCBiZSBkZWxldGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHNldCB0byBudWxsIG9yIG9taXR0ZWQsIHRoZSBjb29raWUgd2lsbCBiZSBhIHNlc3Npb24gY29va2llIGFuZCB3aWxsIG5vdCBiZSByZXRhaW5lZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW4gdGhlIHRoZSBicm93c2VyIGV4aXRzLlxuICogQG9wdGlvbiBTdHJpbmcgcGF0aCBUaGUgdmFsdWUgb2YgdGhlIHBhdGggYXRyaWJ1dGUgb2YgdGhlIGNvb2tpZSAoZGVmYXVsdDogcGF0aCBvZiBwYWdlIHRoYXQgY3JlYXRlZCB0aGUgY29va2llKS5cbiAqIEBvcHRpb24gU3RyaW5nIGRvbWFpbiBUaGUgdmFsdWUgb2YgdGhlIGRvbWFpbiBhdHRyaWJ1dGUgb2YgdGhlIGNvb2tpZSAoZGVmYXVsdDogZG9tYWluIG9mIHBhZ2UgdGhhdCBjcmVhdGVkIHRoZSBjb29raWUpLlxuICogQG9wdGlvbiBCb29sZWFuIHNlY3VyZSBJZiB0cnVlLCB0aGUgc2VjdXJlIGF0dHJpYnV0ZSBvZiB0aGUgY29va2llIHdpbGwgYmUgc2V0IGFuZCB0aGUgY29va2llIHRyYW5zbWlzc2lvbiB3aWxsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgYSBzZWN1cmUgcHJvdG9jb2wgKGxpa2UgSFRUUFMpLlxuICogQHR5cGUgdW5kZWZpbmVkXG4gKlxuICogQG5hbWUgJC5jb29raWVcbiAqIEBjYXQgUGx1Z2lucy9Db29raWVcbiAqIEBhdXRob3IgS2xhdXMgSGFydGwva2xhdXMuaGFydGxAc3RpbGJ1ZXJvLmRlXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGEgY29va2llIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gKlxuICogQGV4YW1wbGUgJC5jb29raWUoJ3RoZV9jb29raWUnKTtcbiAqIEBkZXNjIEdldCB0aGUgdmFsdWUgb2YgYSBjb29raWUuXG4gKlxuICogQHBhcmFtIFN0cmluZyBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjb29raWUuXG4gKiBAcmV0dXJuIFRoZSB2YWx1ZSBvZiB0aGUgY29va2llLlxuICogQHR5cGUgU3RyaW5nXG4gKlxuICogQG5hbWUgJC5jb29raWVcbiAqIEBjYXQgUGx1Z2lucy9Db29raWVcbiAqIEBhdXRob3IgS2xhdXMgSGFydGwva2xhdXMuaGFydGxAc3RpbGJ1ZXJvLmRlXG4gKi9cbmpRdWVyeS5jb29raWUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3VuZGVmaW5lZCcpIHsgLy8gbmFtZSBhbmQgdmFsdWUgZ2l2ZW4sIHNldCBjb29raWVcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIG9wdGlvbnMgPSBqUXVlcnkuZXh0ZW5kKHt9LCBvcHRpb25zKTsgLy8gY2xvbmUgb2JqZWN0IHNpbmNlIGl0J3MgdW5leHBlY3RlZCBiZWhhdmlvciBpZiB0aGUgZXhwaXJlZCBwcm9wZXJ0eSB3ZXJlIGNoYW5nZWRcbiAgICAgICAgICAgIG9wdGlvbnMuZXhwaXJlcyA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHBpcmVzID0gJyc7XG4gICAgICAgIGlmIChvcHRpb25zLmV4cGlyZXMgJiYgKHR5cGVvZiBvcHRpb25zLmV4cGlyZXMgPT0gJ251bWJlcicgfHwgb3B0aW9ucy5leHBpcmVzLnRvVVRDU3RyaW5nKSkge1xuICAgICAgICAgICAgdmFyIGRhdGU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZXhwaXJlcyA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIChvcHRpb25zLmV4cGlyZXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGUgPSBvcHRpb25zLmV4cGlyZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBpcmVzID0gJzsgZXhwaXJlcz0nICsgZGF0ZS50b1VUQ1N0cmluZygpOyAvLyB1c2UgZXhwaXJlcyBhdHRyaWJ1dGUsIG1heC1hZ2UgaXMgbm90IHN1cHBvcnRlZCBieSBJRVxuICAgICAgICB9XG4gICAgICAgIC8vIE5PVEUgTmVlZGVkIHRvIHBhcmVudGhlc2l6ZSBvcHRpb25zLnBhdGggYW5kIG9wdGlvbnMuZG9tYWluXG4gICAgICAgIC8vIGluIHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbnMsIG90aGVyd2lzZSB0aGV5IGV2YWx1YXRlIHRvIHVuZGVmaW5lZFxuICAgICAgICAvLyBpbiB0aGUgcGFja2VkIHZlcnNpb24gZm9yIHNvbWUgcmVhc29uLi4uXG4gICAgICAgIHZhciBwYXRoID0gb3B0aW9ucy5wYXRoID8gJzsgcGF0aD0nICsgKG9wdGlvbnMucGF0aCkgOiAnJztcbiAgICAgICAgdmFyIGRvbWFpbiA9IG9wdGlvbnMuZG9tYWluID8gJzsgZG9tYWluPScgKyAob3B0aW9ucy5kb21haW4pIDogJyc7XG4gICAgICAgIHZhciBzZWN1cmUgPSBvcHRpb25zLnNlY3VyZSA/ICc7IHNlY3VyZScgOiAnJztcbiAgICAgICAgZG9jdW1lbnQuY29va2llID0gW25hbWUsICc9JywgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmVdLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7IC8vIG9ubHkgbmFtZSBnaXZlbiwgZ2V0IGNvb2tpZVxuICAgICAgICB2YXIgY29va2llVmFsdWUgPSBudWxsO1xuICAgICAgICBpZiAoZG9jdW1lbnQuY29va2llICYmIGRvY3VtZW50LmNvb2tpZSAhPSAnJykge1xuICAgICAgICAgICAgdmFyIGNvb2tpZXMgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29va2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSBqUXVlcnkudHJpbShjb29raWVzW2ldKTtcbiAgICAgICAgICAgICAgICAvLyBEb2VzIHRoaXMgY29va2llIHN0cmluZyBiZWdpbiB3aXRoIHRoZSBuYW1lIHdlIHdhbnQ/XG4gICAgICAgICAgICAgICAgaWYgKGNvb2tpZS5zdWJzdHJpbmcoMCwgbmFtZS5sZW5ndGggKyAxKSA9PSAobmFtZSArICc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29va2llVmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQoY29va2llLnN1YnN0cmluZyhuYW1lLmxlbmd0aCArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb29raWVWYWx1ZTtcbiAgICB9XG59OyIsIi8qIGpRdWVyeS5FbnR3aW5lIC0gQ29weXJpZ2h0IDIwMDktMjAxMSBIYW1pc2ggRnJpZWRsYW5kZXIgYW5kIFNpbHZlclN0cmlwZS4gVmVyc2lvbiAuICovXG5cbi8qIHZlbmRvci9qcXVlcnkuc2VsZWN0b3IvanF1ZXJ5LmNsYXNzLmpzICovXG5cbi8qKlxuICogVmVyeSBiYXNpYyBDbGFzcyB1dGlsaXR5LiBCYXNlZCBvbiBiYXNlIGFuZCBqcXVlcnkuY2xhc3MuXG4gKiBcbiAqIENsYXNzIGRlZmluaXRpb246IHZhciBGb28gPSBCYXNlLmV4dGVuZCh7IGluaXQ6IGZ1bmN0aW9uKCl7IENvbnN0cnVjdG9yIH07IG1ldGhvZF9uYW1lOiBmdW5jdGlvbigpeyBNZXRob2QgfSB9KTtcbiAqXG4gKiBJbmhlcml0YW5jZTogdmFyIEJhciA9IEZvby5leHRlbmQoeyBtZXRob2RfbmFtZTogZnVuY3Rpb24oKXsgdGhpcy5fc3VwZXIoKTsgfSB9KTtcbiAqIFxuICogbmV3LWxlc3MgQ29uc3RydWN0b3I6IG5ldyBGb28oYXJnKSA8LXNhbWUgYXMtPiBGb28oYXJnKVxuICovICBcdFxuXG52YXIgQmFzZTtcblxuKGZ1bmN0aW9uKCl7XG5cdFxuXHR2YXIgbWFya2VyID0ge30sIGZuVGVzdCA9IC94eXovLnRlc3QoZnVuY3Rpb24oKXt2YXIgeHl6O30pID8gL1xcYl9zdXBlclxcYi8gOiAvLiovO1xuXG5cdC8vIFRoZSBiYXNlIENsYXNzIGltcGxlbWVudGF0aW9uIChkb2VzIG5vdGhpbmcpXG5cdEJhc2UgPSBmdW5jdGlvbigpe307XG4gXG5cdEJhc2UuYWRkTWV0aG9kID0gZnVuY3Rpb24obmFtZSwgZnVuYykge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9zdXBlciAmJiB0aGlzLl9zdXBlci5wcm90b3R5cGU7XG5cdFx0XG5cdFx0aWYgKHBhcmVudCAmJiBmblRlc3QudGVzdChmdW5jKSkge1xuXHRcdFx0dGhpcy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpe1xuXHRcdFx0XHR2YXIgdG1wID0gdGhpcy5fc3VwZXI7XG5cdFx0XHRcdHRoaXMuX3N1cGVyID0gcGFyZW50W25hbWVdO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciByZXQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZmluYWxseSB7XG5cdFx0XHRcdFx0dGhpcy5fc3VwZXIgPSB0bXA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2UgdGhpcy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jO1xuXHR9O1xuXG5cdEJhc2UuYWRkTWV0aG9kcyA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBwcm9wcykge1xuXHRcdFx0aWYgKHR5cGVvZiBwcm9wc1tuYW1lXSA9PSAnZnVuY3Rpb24nKSB0aGlzLmFkZE1ldGhvZChuYW1lLCBwcm9wc1tuYW1lXSk7XG5cdFx0XHRlbHNlIHRoaXMucHJvdG90eXBlW25hbWVdID0gcHJvcHNbbmFtZV07XG5cdFx0fVxuXHR9O1xuXG5cdEJhc2Uuc3ViY2xhc3NPZiA9IGZ1bmN0aW9uKHBhcmVudGtscykge1xuXHRcdHZhciBrbHMgPSB0aGlzO1xuXHRcdHdoaWxlIChrbHMpIHtcblx0XHRcdGlmIChrbHMgPT09IHBhcmVudGtscykgcmV0dXJuIHRydWU7XG5cdFx0XHRrbHMgPSBrbHMuX3N1cGVyO1xuXHRcdH1cblx0fTtcbiBcblx0Ly8gQ3JlYXRlIGEgbmV3IENsYXNzIHRoYXQgaW5oZXJpdHMgZnJvbSB0aGlzIGNsYXNzXG5cdEJhc2UuZXh0ZW5kID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgXHRcblx0XHQvLyBUaGUgZHVtbXkgY2xhc3MgY29uc3RydWN0b3Jcblx0XHR2YXIgS2xzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoYXJndW1lbnRzWzBdID09PSBtYXJrZXIpIHJldHVybjtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMgaW5zdGFuY2VvZiBLbHMpIHtcblx0XHRcdFx0aWYgKHRoaXMuaW5pdCkgdGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dmFyIHJldCA9IG5ldyBLbHMobWFya2VyKTsgaWYgKHJldC5pbml0KSByZXQuaW5pdC5hcHBseShyZXQsIGFyZ3VtZW50cyk7IHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fTtcbiAgIFxuXHRcdC8vIEFkZCB0aGUgY29tbW9uIGNsYXNzIHZhcmlhYmxlcyBhbmQgbWV0aG9kc1xuXHRcdEtscy5jb25zdHJ1Y3RvciA9IEtscztcblx0XHRLbHMuZXh0ZW5kID0gQmFzZS5leHRlbmQ7XG5cdFx0S2xzLmFkZE1ldGhvZCA9IEJhc2UuYWRkTWV0aG9kO1xuXHRcdEtscy5hZGRNZXRob2RzID0gQmFzZS5hZGRNZXRob2RzO1xuXHRcdEtscy5zdWJjbGFzc09mID0gQmFzZS5zdWJjbGFzc09mO1xuXHRcdFxuXHRcdEtscy5fc3VwZXIgPSB0aGlzO1xuXHRcblx0XHQvLyBBdHRhY2ggdGhlIHBhcmVudCBvYmplY3QgdG8gdGhlIGluaGVyaXRhbmNlIGNoYWluXG5cdFx0S2xzLnByb3RvdHlwZSA9IG5ldyB0aGlzKG1hcmtlcik7XG5cdFx0S2xzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtscztcblxuXHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb3ZlciBvbnRvIHRoZSBuZXcgcHJvdG90eXBlXG5cdFx0S2xzLmFkZE1ldGhvZHMocHJvcHMpO1xuXHRcdFxuXHRcdHJldHVybiBLbHM7XG5cdH07IFxufSkoKTs7XG5cblxuLyogdmVuZG9yL2pxdWVyeS5zZWxlY3Rvci9qcXVlcnkuc2VsZWN0b3IuanMgKi9cblxuKGZ1bmN0aW9uKCQpe1xuXG5cdHZhciB0b2tlbnMgPSB7XG5cdFx0VU5JQ09ERTogL1xcXFxbMC05YS1mXXsxLDZ9KD86XFxyXFxufFsgXFxuXFxyXFx0XFxmXSk/Lyxcblx0XHRFU0NBUEU6IC8oPzpVTklDT0RFKXxcXFxcW15cXG5cXHJcXGYwLTlhLWZdLyxcblx0XHROT05BU0NJSTogL1teXFx4MDAtXFx4N0ZdLyxcblx0XHROTVNUQVJUOiAvW19hLXpdfCg/Ok5PTkFTQ0lJKXwoPzpFU0NBUEUpLyxcblx0XHROTUNIQVI6IC9bX2EtejAtOS1dfCg/Ok5PTkFTQ0lJKXwoPzpFU0NBUEUpLyxcblx0XHRJREVOVDogLy0/KD86Tk1TVEFSVCkoPzpOTUNIQVIpKi8sXG5cdFx0XG5cdFx0Tkw6IC9cXG58XFxyXFxufFxccnxcXGYvLFxuXG5cdFx0U1RSSU5HOiAvKD86U1RSSU5HMSl8KD86U1RSSU5HMil8KD86U1RSSU5HQkFSRSkvLFxuXHRcdFNUUklORzE6IC9cIig/Oig/OkVTQ0FQRSl8XFxcXCg/Ok5MKXxbXlxcblxcclxcZlxcXCJdKSpcIi8sXG5cdFx0U1RSSU5HMjogLycoPzooPzpFU0NBUEUpfFxcXFwoPzpOTCl8W15cXG5cXHJcXGZcXCddKSonLyxcblx0XHRTVFJJTkdCQVJFOiAvKD86KD86RVNDQVBFKXxcXFxcKD86TkwpfFteXFxuXFxyXFxmXFxdXSkqLyxcblx0XHRcblx0XHRGVU5DVElPTjogLyg/OklERU5UKVxcKFxcKS8sXG5cdFx0XG5cdFx0SU5URUdFUjogL1swLTldKy8sXG5cdFx0XG5cdFx0V0lUSE46IC8oWy0rXSk/KElOVEVHRVIpPyhuKVxccyooPzooWy0rXSlcXHMqKElOVEVHRVIpKT8vLFxuXHRcdFdJVEhPVVROOiAvKFstK10pPyhJTlRFR0VSKS9cblx0fTtcblx0XG5cdHZhciByeCA9IHtcblx0XHRub3Q6IC86bm90XFwoLyxcblx0XHRub3RfZW5kOiAvXFwpLyxcblx0XHRcbiBcdFx0dGFnOiAvKCg/OklERU5UKXxcXCopLyxcblx0XHRpZDogLyMoSURFTlQpLyxcblx0XHRjbHM6IC9cXC4oSURFTlQpLyxcblx0XHRhdHRyOiAvXFxbXFxzKihJREVOVClcXHMqKD86KFtePV0/PSlcXHMqKFNUUklORylcXHMqKT9cXF0vLFxuXHRcdHBzZXVkb19lbDogLyg/OjooZmlyc3QtbGluZXxmaXJzdC1sZXR0ZXJ8YmVmb3JlfGFmdGVyKSl8KD86OjooKD86RlVOQ1RJT04pfCg/OklERU5UKSkpLyxcblx0XHRwc2V1ZG9fY2xzX250aDogLzpudGgtY2hpbGRcXChcXHMqKD86KD86V0lUSE4pfCg/OldJVEhPVVROKXwob2RkfGV2ZW4pKVxccypcXCkvLFxuXHRcdHBzZXVkb19jbHM6IC86KElERU5UKS8sXG5cblx0XHRjb21iOiAvXFxzKihcXCt8fnw+KVxccyp8XFxzKy8sXG5cdFx0Y29tbWE6IC9cXHMqLFxccyovLFxuXHRcdGltcG9ydGFudDogL1xccyshaW1wb3J0YW50XFxzKiQvXG5cdH07XG5cblx0LyogUmVwbGFjZSBwbGFjZWhvbGRlcnMgd2l0aCBhY3R1YWwgcmVnZXgsIGFuZCBtYXJrIGFsbCBhcyBjYXNlIGluc2Vuc2l0aXZlICovXG5cdHZhciB0b2tlbiA9IC9bQS1aXVtBLVowLTldKy87XG5cdGZvciAodmFyIGsgaW4gcngpIHtcblx0XHR2YXIgbSwgc3JjID0gcnhba10uc291cmNlO1xuXHRcdHdoaWxlIChtID0gc3JjLm1hdGNoKHRva2VuKSkgc3JjID0gc3JjLnJlcGxhY2UobVswXSwgdG9rZW5zW21bMF1dLnNvdXJjZSk7XG5cdFx0cnhba10gPSBuZXcgUmVnRXhwKHNyYywgJ2dpJyk7XG5cdH1cblxuXHQvKipcblx0ICogQSBzdHJpbmcgdGhhdCBtYXRjaGVzIGl0c2VsZiBhZ2FpbnN0IHJlZ2V4aWksIGFuZCBrZWVwcyB0cmFjayBvZiBob3cgbXVjaCBvZiBpdHNlbGYgaGFzIGJlZW4gbWF0Y2hlZFxuXHQgKi9cblx0dmFyIENvbnN1bWFibGVTdHJpbmcgPSBCYXNlLmV4dGVuZCh7XG5cdFx0aW5pdDogZnVuY3Rpb24oc3RyKSB7XG5cdFx0XHR0aGlzLnN0ciA9IHN0cjtcblx0XHRcdHRoaXMucG9zID0gMDtcblx0XHR9LFxuXHRcdG1hdGNoOiBmdW5jdGlvbihyeCkge1xuXHRcdFx0dmFyIG07XG5cdFx0XHRyeC5sYXN0SW5kZXggPSB0aGlzLnBvcztcblx0XHRcdGlmICgobSA9IHJ4LmV4ZWModGhpcy5zdHIpKSAmJiBtLmluZGV4ID09IHRoaXMucG9zICkge1xuXHRcdFx0XHR0aGlzLnBvcyA9IHJ4Lmxhc3RJbmRleCA/IHJ4Lmxhc3RJbmRleCA6IHRoaXMuc3RyLmxlbmd0aCA7XG5cdFx0XHRcdHJldHVybiBtO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRwZWVrOiBmdW5jdGlvbihyeCkge1xuXHRcdFx0dmFyIG07XG5cdFx0XHRyeC5sYXN0SW5kZXggPSB0aGlzLnBvcztcblx0XHRcdGlmICgobSA9IHJ4LmV4ZWModGhpcy5zdHIpKSAmJiBtLmluZGV4ID09IHRoaXMucG9zICkgcmV0dXJuIG07XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNob3dwb3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RyLnNsaWNlKDAsdGhpcy5wb3MpKyc8SEVSRT4nICsgdGhpcy5zdHIuc2xpY2UodGhpcy5wb3MpO1xuXHRcdH0sXG5cdFx0ZG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wb3MgPT0gdGhpcy5zdHIubGVuZ3RoO1xuXHRcdH1cblx0fSk7XG5cdFxuXHQvKiBBIGJhc2UgY2xhc3MgdGhhdCBhbGwgU2VsZWN0b3JzIGluaGVyaXQgb2ZmICovXG5cdHZhciBTZWxlY3RvckJhc2UgPSBCYXNlLmV4dGVuZCh7fSk7XG5cdFxuXHQvKipcblx0ICogQSBjbGFzcyByZXByZXNlbnRpbmcgYSBTaW1wbGUgU2VsZWN0b3IsIGFzIHBlciB0aGUgQ1NTMyBzZWxlY3RvciBzcGVjXG5cdCAqL1xuXHR2YXIgU2ltcGxlU2VsZWN0b3IgPSBTZWxlY3RvckJhc2UuZXh0ZW5kKHtcblx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMudGFnID0gbnVsbDtcblx0XHRcdHRoaXMuaWQgPSBudWxsO1xuXHRcdFx0dGhpcy5jbGFzc2VzID0gW107XG5cdFx0XHR0aGlzLmF0dHJzID0gW107XG5cdFx0XHR0aGlzLm5vdHMgPSBbXTtcblx0XHRcdHRoaXMucHNldWRvX2NsYXNzZXMgPSBbXTtcblx0XHRcdHRoaXMucHNldWRvX2VscyA9IFtdO1xuXHRcdH0sXG5cdFx0cGFyc2U6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG5cdFx0XHR2YXIgbTtcblx0XHRcdFxuXHRcdFx0LyogUHVsbCBvdXQgdGhlIGluaXRpYWwgdGFnIGZpcnN0LCBpZiB0aGVyZSBpcyBvbmUgKi9cblx0XHRcdGlmIChtID0gc2VsZWN0b3IubWF0Y2gocngudGFnKSkgdGhpcy50YWcgPSBtWzFdO1xuXHRcdFx0XG5cdFx0XHQvKiBUaGVuIGZvciBlYWNoIHNlbGVjdGlvbiB0eXBlLCB0cnkgYW5kIGZpbmQgYSBtYXRjaCAqL1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRpZiAobSA9IHNlbGVjdG9yLm1hdGNoKHJ4Lm5vdCkpIHtcblx0XHRcdFx0XHR0aGlzLm5vdHNbdGhpcy5ub3RzLmxlbmd0aF0gPSBTZWxlY3RvcnNHcm91cCgpLnBhcnNlKHNlbGVjdG9yKTtcblx0XHRcdFx0XHRpZiAoIShtID0gc2VsZWN0b3IubWF0Y2gocngubm90X2VuZCkpKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyAnSW52YWxpZCA6bm90IHRlcm0gaW4gc2VsZWN0b3InO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChtID0gc2VsZWN0b3IubWF0Y2gocnguaWQpKSAgICAgICAgIHRoaXMuaWQgPSBtWzFdO1xuXHRcdFx0XHRlbHNlIGlmIChtID0gc2VsZWN0b3IubWF0Y2gocnguY2xzKSkgICAgICAgIHRoaXMuY2xhc3Nlc1t0aGlzLmNsYXNzZXMubGVuZ3RoXSA9IG1bMV07XG5cdFx0XHRcdGVsc2UgaWYgKG0gPSBzZWxlY3Rvci5tYXRjaChyeC5hdHRyKSkgICAgICAgdGhpcy5hdHRyc1t0aGlzLmF0dHJzLmxlbmd0aF0gPSBbIG1bMV0sIG1bMl0sIG1bM10gXTtcblx0XHRcdFx0ZWxzZSBpZiAobSA9IHNlbGVjdG9yLm1hdGNoKHJ4LnBzZXVkb19lbCkpICB0aGlzLnBzZXVkb19lbHNbdGhpcy5wc2V1ZG9fZWxzLmxlbmd0aF0gPSBtWzFdIHx8IG1bMl07XG5cdFx0XHRcdGVsc2UgaWYgKG0gPSBzZWxlY3Rvci5tYXRjaChyeC5wc2V1ZG9fY2xzX250aCkpIHtcblx0XHRcdFx0XHRpZiAobVszXSkge1xuXHRcdFx0XHRcdFx0dmFyIGEgPSBwYXJzZUludCgobVsxXXx8JycpKyhtWzJdfHwnMScpKTtcblx0XHRcdFx0XHRcdHZhciBiID0gcGFyc2VJbnQoKG1bNF18fCcnKSsobVs1XXx8JzAnKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIGEgPSBtWzhdID8gMiA6IDA7XG5cdFx0XHRcdFx0XHR2YXIgYiA9IG1bOF0gPyAoNC1tWzhdLmxlbmd0aCkgOiBwYXJzZUludCgobVs2XXx8JycpK21bN10pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnBzZXVkb19jbGFzc2VzW3RoaXMucHNldWRvX2NsYXNzZXMubGVuZ3RoXSA9IFsnbnRoLWNoaWxkJywgW2EsIGJdXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChtID0gc2VsZWN0b3IubWF0Y2gocngucHNldWRvX2NscykpIHRoaXMucHNldWRvX2NsYXNzZXNbdGhpcy5wc2V1ZG9fY2xhc3Nlcy5sZW5ndGhdID0gW21bMV1dO1xuXHRcdFx0XHRcblx0XHRcdH0gd2hpbGUobSAmJiAhc2VsZWN0b3IuZG9uZSgpKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHR9KTtcblxuXHQvKipcblx0ICogQSBjbGFzcyByZXByZXNlbnRpbmcgYSBTZWxlY3RvciwgYXMgcGVyIHRoZSBDU1MzIHNlbGVjdG9yIHNwZWNcblx0ICovXG5cdHZhciBTZWxlY3RvciA9IFNlbGVjdG9yQmFzZS5leHRlbmQoeyBcblx0XHRpbml0OiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5wYXJ0cyA9IFtdO1xuXHRcdH0sXG5cdFx0cGFyc2U6IGZ1bmN0aW9uKGNvbnMpe1xuXHRcdFx0dGhpcy5wYXJ0c1t0aGlzLnBhcnRzLmxlbmd0aF0gPSBTaW1wbGVTZWxlY3RvcigpLnBhcnNlKGNvbnMpO1xuXHRcdFx0XG5cdFx0XHR3aGlsZSAoIWNvbnMuZG9uZSgpICYmICFjb25zLnBlZWsocnguY29tbWEpICYmIChtID0gY29ucy5tYXRjaChyeC5jb21iKSkpIHtcblx0XHRcdFx0dGhpcy5wYXJ0c1t0aGlzLnBhcnRzLmxlbmd0aF0gPSBtWzFdIHx8ICcgJztcblx0XHRcdFx0dGhpcy5wYXJ0c1t0aGlzLnBhcnRzLmxlbmd0aF0gPSBTaW1wbGVTZWxlY3RvcigpLnBhcnNlKGNvbnMpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJ0cy5sZW5ndGggPT0gMSA/IHRoaXMucGFydHNbMF0gOiB0aGlzO1xuXHRcdH1cblx0fSk7XG5cdFxuXHQvKipcblx0ICogQSBjbGFzcyByZXByZXNlbnRpbmcgYSBzZXF1ZW5jZSBvZiBzZWxlY3RvcnMsIGFzIHBlciB0aGUgQ1NTMyBzZWxlY3RvciBzcGVjXG5cdCAqL1xuXHR2YXIgU2VsZWN0b3JzR3JvdXAgPSBTZWxlY3RvckJhc2UuZXh0ZW5kKHsgXG5cdFx0aW5pdDogZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMucGFydHMgPSBbXTtcblx0XHR9LFxuXHRcdHBhcnNlOiBmdW5jdGlvbihjb25zKXtcblx0XHRcdHRoaXMucGFydHNbdGhpcy5wYXJ0cy5sZW5ndGhdID0gU2VsZWN0b3IoKS5wYXJzZShjb25zKTtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKCFjb25zLmRvbmUoKSAmJiAobSA9IGNvbnMubWF0Y2gocnguY29tbWEpKSkge1xuXHRcdFx0XHR0aGlzLnBhcnRzW3RoaXMucGFydHMubGVuZ3RoXSA9IFNlbGVjdG9yKCkucGFyc2UoY29ucyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0aGlzLnBhcnRzLmxlbmd0aCA9PSAxID8gdGhpcy5wYXJ0c1swXSA6IHRoaXM7XG5cdFx0fVxuXHR9KTtcblxuXHRcblx0JC5zZWxlY3RvciA9IGZ1bmN0aW9uKHMpe1xuXHRcdHZhciBjb25zID0gQ29uc3VtYWJsZVN0cmluZyhzKTtcblx0XHR2YXIgcmVzID0gU2VsZWN0b3JzR3JvdXAoKS5wYXJzZShjb25zKTsgXG5cdFx0XG5cdFx0cmVzLnNlbGVjdG9yID0gcztcblx0XHRcblx0XHRpZiAoIWNvbnMuZG9uZSgpKSB0aHJvdyAnQ291bGQgbm90IHBhcnNlIHNlbGVjdG9yIC0gJyArIGNvbnMuc2hvd3BvcygpIDtcblx0XHRlbHNlIHJldHVybiByZXM7XG5cdH07XG5cdFxuXHQkLnNlbGVjdG9yLlNlbGVjdG9yQmFzZSA9IFNlbGVjdG9yQmFzZTtcblx0JC5zZWxlY3Rvci5TaW1wbGVTZWxlY3RvciA9IFNpbXBsZVNlbGVjdG9yO1xuXHQkLnNlbGVjdG9yLlNlbGVjdG9yID0gU2VsZWN0b3I7XG5cdCQuc2VsZWN0b3IuU2VsZWN0b3JzR3JvdXAgPSBTZWxlY3RvcnNHcm91cDtcblx0XG59KShqUXVlcnkpO1xuO1xuXG5cbi8qIHZlbmRvci9qcXVlcnkuc2VsZWN0b3IvanF1ZXJ5LnNlbGVjdG9yLnNwZWNpZml0eS5qcyAqL1xuXG4oZnVuY3Rpb24oJCkge1xuXG5cdCQuc2VsZWN0b3IuU2ltcGxlU2VsZWN0b3IuYWRkTWV0aG9kKCdzcGVjaWZpdHknLCBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5zcGVjKSByZXR1cm4gdGhpcy5zcGVjO1xuXHRcdFxuXHRcdHZhciBzcGVjID0gW1xuXHRcdFx0dGhpcy5pZCA/IDEgOiAwLCBcblx0XHRcdHRoaXMuY2xhc3Nlcy5sZW5ndGggKyB0aGlzLmF0dHJzLmxlbmd0aCArIHRoaXMucHNldWRvX2NsYXNzZXMubGVuZ3RoLCBcblx0XHRcdCgodGhpcy50YWcgJiYgdGhpcy50YWcgIT0gJyonKSA/IDEgOiAwKSArIHRoaXMucHNldWRvX2Vscy5sZW5ndGhcblx0XHRdO1xuXHRcdCQuZWFjaCh0aGlzLm5vdHMsIGZ1bmN0aW9uKGksbm90KXtcblx0XHRcdHZhciBucyA9IG5vdC5zcGVjaWZpdHkoKTsgc3BlY1swXSArPSBuc1swXTsgc3BlY1sxXSArPSBuc1sxXTsgc3BlY1syXSArPSBuc1syXTsgXG5cdFx0fSk7XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXMuc3BlYyA9IHNwZWM7XG5cdH0pO1xuXG5cdCQuc2VsZWN0b3IuU2VsZWN0b3IuYWRkTWV0aG9kKCdzcGVjaWZpdHknLCBmdW5jdGlvbigpe1xuXHRcdGlmICh0aGlzLnNwZWMpIHJldHVybiB0aGlzLnNwZWM7XG5cdFx0XG5cdFx0dmFyIHNwZWMgPSBbMCwwLDBdO1xuXHRcdCQuZWFjaCh0aGlzLnBhcnRzLCBmdW5jdGlvbihpLHBhcnQpe1xuXHRcdFx0aWYgKGklMikgcmV0dXJuO1xuXHRcdFx0dmFyIHBzID0gcGFydC5zcGVjaWZpdHkoKTsgc3BlY1swXSArPSBwc1swXTsgc3BlY1sxXSArPSBwc1sxXTsgc3BlY1syXSArPSBwc1syXTsgXG5cdFx0fSk7XG5cdFx0XG5cdFx0cmV0dXJuIHRoaXMuc3BlYyA9IHNwZWM7XHRcblx0fSk7XG5cdFxuXHQkLnNlbGVjdG9yLlNlbGVjdG9yc0dyb3VwLmFkZE1ldGhvZCgnc3BlY2lmaXR5JywgZnVuY3Rpb24oKXtcblx0XHRpZiAodGhpcy5zcGVjKSByZXR1cm4gdGhpcy5zcGVjO1xuXHRcdFxuXHRcdHZhciBzcGVjID0gWzAsMCwwXTtcblx0XHQkLmVhY2godGhpcy5wYXJ0cywgZnVuY3Rpb24oaSxwYXJ0KXtcblx0XHRcdHZhciBwcyA9IHBhcnQuc3BlY2lmaXR5KCk7IHNwZWNbMF0gKz0gcHNbMF07IHNwZWNbMV0gKz0gcHNbMV07IHNwZWNbMl0gKz0gcHNbMl07IFxuXHRcdH0pO1xuXHRcdFxuXHRcdHJldHVybiB0aGlzLnNwZWMgPSBzcGVjO1x0XG5cdH0pO1xuXHRcblx0XG59KShqUXVlcnkpO1xuO1xuXG5cbi8qIHZlbmRvci9qcXVlcnkuc2VsZWN0b3IvanF1ZXJ5LnNlbGVjdG9yLm1hdGNoZXMuanMgKi9cblxuLypcblRoaXMgYXR0ZW1wdHMgdG8gZG8gdGhlIG9wcG9zaXRlIG9mIFNpenpsZS5cblNpenpsZSBpcyBnb29kIGZvciBmaW5kaW5nIGVsZW1lbnRzIGZvciBhIHNlbGVjdG9yLCBidXQgbm90IHNvIGdvb2QgZm9yIHRlbGxpbmcgaWYgYW4gaW5kaXZpZHVhbCBlbGVtZW50IG1hdGNoZXMgYSBzZWxlY3RvclxuKi9cblxuKGZ1bmN0aW9uKCQpIHtcblx0XG5cdC8qKioqIENBUEFCSUxJVFkgVEVTVFMgKioqKi9cblx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRkaXYuaW5uZXJIVE1MID0gJzxmb3JtIGlkPVwidGVzdFwiPjxpbnB1dCBuYW1lPVwiaWRcIiB0eXBlPVwidGV4dFwiLz48L2Zvcm0+Jztcblx0XG5cdC8vIEluIElFIDYtNywgZ2V0QXR0cmlidXRlIG9mdGVuIGRvZXMgdGhlIHdyb25nIHRoaW5nIChyZXR1cm5zIHNpbWlsYXIgdG8gZWwuYXR0ciksIHNvIHdlIG5lZWQgdG8gdXNlIGdldEF0dHJpYnV0ZU5vZGUgb24gdGhhdCBicm93c2VyXG5cdHZhciBnZXRBdHRyaWJ1dGVEb2RneSA9IGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSgnaWQnKSAhPT0gJ3Rlc3QnO1xuXHRcblx0Ly8gRG9lcyBicm93c2VyIHN1cHBvcnQgRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCwgRWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLCBldGMuXG5cdHZhciBoYXNFbGVtZW50VHJhdmVyc2FsID0gZGl2LmZpcnN0RWxlbWVudENoaWxkICYmIGRpdi5maXJzdEVsZW1lbnRDaGlsZC50YWdOYW1lID09ICdGT1JNJztcblx0XG5cdC8vIERvZXMgYnJvd3NlciBzdXBwb3J0IEVsZW1lbnQuY2hpbGRyZW5cblx0dmFyIGhhc0NoaWxkcmVuID0gZGl2LmNoaWxkcmVuICYmIGRpdi5jaGlsZHJlblswXS50YWdOYW1lID09ICdGT1JNJztcblxuXHQvKioqKiBJTlRSTyAqKioqL1xuXHRcblx0dmFyIEdPT0QgPSAvR09PRC9nO1xuXHR2YXIgQkFEID0gL0JBRC9nO1xuXHRcblx0dmFyIFNUQVJUU19XSVRIX1FVT1RFUyA9IC9eWydcIl0vZztcblx0XG5cdHZhciBqb2luID0gZnVuY3Rpb24oanMpIHtcblx0XHRyZXR1cm4ganMuam9pbignXFxuJyk7XG5cdH07XG5cdFxuXHR2YXIgam9pbl9jb21wbGV4ID0gZnVuY3Rpb24oanMpIHtcblx0XHR2YXIgY29kZSA9IG5ldyBTdHJpbmcoanMuam9pbignXFxuJykpOyAvLyBTdHJpbmcgb2JqZWN0cyBjYW4gaGF2ZSBwcm9wZXJ0aWVzIHNldC4gc3RyaW5ncyBjYW4ndFxuXHRcdGNvZGUuY29tcGxleCA9IHRydWU7XG5cdFx0cmV0dXJuIGNvZGU7XG5cdH07XG5cdFxuXHQvKioqKiBBVFRSSUJVVEUgQUNDRVNTT1JTICoqKiovXG5cdFxuXHQvLyBOb3QgYWxsIGF0dHJpYnV0ZSBuYW1lcyBjYW4gYmUgdXNlZCBhcyBpZGVudGlmaWVycywgc28gd2UgZW5jb2RlIGFueSBub24tYWNjZXB0YWJsZSBjaGFyYWN0ZXJzIGFzIGhleFxuXHR2YXIgdmFyRm9yQXR0ciA9IGZ1bmN0aW9uKGF0dHIpIHtcblx0XHRyZXR1cm4gJ18nICsgYXR0ci5yZXBsYWNlKC9eW15BLVphLXpdfFteQS1aYS16MC05XS9nLCBmdW5jdGlvbihtKXsgcmV0dXJuICdfMHgnICsgbS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSArICdfJzsgfSk7XG5cdH07XG5cdFxuXHR2YXIgZ2V0QXR0cjtcblx0XG5cdC8vIEdvb2QgYnJvd3NlcnNcblx0aWYgKCFnZXRBdHRyaWJ1dGVEb2RneSkge1xuXHRcdGdldEF0dHIgPSBmdW5jdGlvbihhdHRyKXsgcmV0dXJuICd2YXIgJyt2YXJGb3JBdHRyKGF0dHIpKycgPSBlbC5nZXRBdHRyaWJ1dGUoXCInK2F0dHIrJ1wiKTsnIDsgfTtcblx0fVxuXHQvLyBJRSA2LCA3XG5cdGVsc2Uge1xuXHRcdC8vIE9uIElFIDYgKyA3LCBnZXRBdHRyaWJ1dGUgc3RpbGwgaGFzIHRvIGJlIGNhbGxlZCB3aXRoIERPTSBwcm9wZXJ0eSBtaXJyb3IgbmFtZSwgbm90IGF0dHJpYnV0ZSBuYW1lLiBNYXAgYXR0cmlidXRlcyB0byB0aG9zZSBuYW1lc1xuXHRcdHZhciBnZXRBdHRySUVNYXAgPSB7ICdjbGFzcyc6ICdjbGFzc05hbWUnLCAnZm9yJzogJ2h0bWxGb3InIH07XG5cdFx0XG5cdFx0Z2V0QXR0ciA9IGZ1bmN0aW9uKGF0dHIpIHtcblx0XHRcdHZhciBpZWF0dHIgPSBnZXRBdHRySUVNYXBbYXR0cl0gfHwgYXR0cjtcblx0XHRcdHJldHVybiAndmFyICcrdmFyRm9yQXR0cihhdHRyKSsnID0gZWwuZ2V0QXR0cmlidXRlKFwiJytpZWF0dHIrJ1wiLDIpIHx8IChlbC5nZXRBdHRyaWJ1dGVOb2RlKFwiJythdHRyKydcIil8fHt9KS5ub2RlVmFsdWU7Jztcblx0XHR9O1xuXHR9XG5cdFxuXHQvKioqKiBBVFRSSUJVVEUgQ09NUEFSSVRPUlMgKioqKi9cblx0XG5cdHZhciBhdHRyY2hlY2tzID0ge1xuXHRcdCctJzogICchSycsXG5cdFx0Jz0nOiAgJ0sgIT0gXCJWXCInLFxuXHRcdCchPSc6ICdLID09IFwiVlwiJyxcblx0XHQnfj0nOiAnX1dTX0suaW5kZXhPZihcIiBWIFwiKSA9PSAtMScsXG5cdFx0J149JzogJyFLIHx8IEsuaW5kZXhPZihcIlZcIikgIT0gMCcsXG5cdFx0Jyo9JzogJyFLIHx8IEsuaW5kZXhPZihcIlZcIikgPT0gLTEnLFxuXHRcdCckPSc6ICchSyB8fCBLLnN1YnN0cihLLmxlbmd0aC1cIlZcIi5sZW5ndGgpICE9IFwiVlwiJ1xuXHR9O1xuXG5cdC8qKioqIFNUQVRFIFRSQUNLRVIgKioqKi9cblx0XG5cdHZhciBTdGF0ZSA9ICQuc2VsZWN0b3IuU3RhdGUgPSBCYXNlLmV4dGVuZCh7XG5cdFx0aW5pdDogZnVuY3Rpb24oKXsgXG5cdFx0XHR0aGlzLnJlc2V0KCk7IFxuXHRcdH0sXG5cdFx0cmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5hdHRycyA9IHt9OyB0aGlzLndzYXR0cnMgPSB7fTtcblx0XHR9LFxuXG5cdFx0cHJldjogZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHRcdGlmIChoYXNFbGVtZW50VHJhdmVyc2FsKSByZXR1cm4gJ2VsID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZyc7XG5cdFx0XHRyZXR1cm4gJ3doaWxlKChlbCA9IGVsLnByZXZpb3VzU2libGluZykgJiYgZWwubm9kZVR5cGUgIT0gMSkge30nO1xuXHRcdH0sXG5cdFx0bmV4dDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0XHRpZiAoaGFzRWxlbWVudFRyYXZlcnNhbCkgcmV0dXJuICdlbCA9IGVsLm5leHRFbGVtZW50U2libGluZyc7XG5cdFx0XHRyZXR1cm4gJ3doaWxlKChlbCA9IGVsLm5leHRTaWJsaW5nKSAmJiBlbC5ub2RlVHlwZSAhPSAxKSB7fSc7XG5cdFx0fSxcblx0XHRwcmV2TG9vcDogZnVuY3Rpb24oYm9keSl7XG5cdFx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0XHRpZiAoaGFzRWxlbWVudFRyYXZlcnNhbCkgcmV0dXJuIGpvaW4oWyAnd2hpbGUoZWwgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKXsnLCBib2R5XSk7XG5cdFx0XHRyZXR1cm4gam9pbihbXG5cdFx0XHRcdCd3aGlsZShlbCA9IGVsLnByZXZpb3VzU2libGluZyl7Jyxcblx0XHRcdFx0XHQnaWYgKGVsLm5vZGVUeXBlICE9IDEpIGNvbnRpbnVlOycsXG5cdFx0XHRcdFx0Ym9keVxuXHRcdFx0XSk7XG5cdFx0fSxcblx0XHRwYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZXNldCgpO1xuXHRcdFx0cmV0dXJuICdlbCA9IGVsLnBhcmVudE5vZGU7Jztcblx0XHR9LFxuXHRcdHBhcmVudExvb3A6IGZ1bmN0aW9uKGJvZHkpIHtcblx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHRcdHJldHVybiBqb2luKFtcblx0XHRcdFx0J3doaWxlKChlbCA9IGVsLnBhcmVudE5vZGUpICYmIGVsLm5vZGVUeXBlID09IDEpeycsXG5cdFx0XHRcdFx0Ym9keSxcblx0XHRcdFx0J30nXG5cdFx0XHRdKTtcblx0XHR9LFxuXHRcdFxuXHRcdHVzZXNfYXR0cjogZnVuY3Rpb24oYXR0cikge1xuXHRcdFx0aWYgKHRoaXMuYXR0cnNbYXR0cl0pIHJldHVybjtcblx0XHRcdHRoaXMuYXR0cnNbYXR0cl0gPSB0cnVlO1xuXHRcdFx0cmV0dXJuIGdldEF0dHIoYXR0cik7IFxuXHRcdH0sXG5cdFx0dXNlc193c2F0dHI6IGZ1bmN0aW9uKGF0dHIpIHtcblx0XHRcdGlmICh0aGlzLndzYXR0cnNbYXR0cl0pIHJldHVybjtcblx0XHRcdHRoaXMud3NhdHRyc1thdHRyXSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gam9pbihbdGhpcy51c2VzX2F0dHIoYXR0ciksICd2YXIgX1dTXycrdmFyRm9yQXR0cihhdHRyKSsnID0gXCIgXCIrJyt2YXJGb3JBdHRyKGF0dHIpKycrXCIgXCI7J10pOyBcblx0XHR9LFxuXG5cdFx0dXNlc19qcXVlcnlGaWx0ZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLmpxdWVyeUZpbHRlcnNBZGRlZCkgcmV0dXJuO1xuXHRcdFx0dGhpcy5qcXVlcnlGaWx0ZXJzQWRkZWQgPSB0cnVlO1xuXHRcdFx0cmV0dXJuICd2YXIgXyRmaWx0ZXJzID0galF1ZXJ5LmZpbmQuc2VsZWN0b3JzLmZpbHRlcnM7Jztcblx0XHR9LFxuXG5cdFx0c2F2ZTogZnVuY3Rpb24obGJsKSB7XG5cdFx0XHRyZXR1cm4gJ3ZhciBlbCcrbGJsKycgPSBlbDsnO1xuXHRcdH0sXG5cdFx0cmVzdG9yZTogZnVuY3Rpb24obGJsKSB7XG5cdFx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0XHRyZXR1cm4gJ2VsID0gZWwnK2xibCsnOyc7XG5cdFx0fVxuXHR9KTtcblx0XG5cdC8qKioqIFBTRVVETy1DTEFTUyBERVRBSUxTICoqKiovXG5cdFxuXHR2YXIgcHNldWRvY2xzY2hlY2tzID0ge1xuXHRcdCdmaXJzdC1jaGlsZCc6IGpvaW4oW1xuXHRcdFx0J3ZhciBjZWwgPSBlbDsnLFxuXHRcdFx0J3doaWxlKGNlbCA9IGNlbC5wcmV2aW91c1NpYmxpbmcpeyBpZiAoY2VsLm5vZGVUeXBlID09PSAxKSBCQUQ7IH0nXG5cdFx0XSksXG5cdFx0J2xhc3QtY2hpbGQnOiBqb2luKFtcblx0XHRcdCd2YXIgY2VsID0gZWw7Jyxcblx0XHRcdCd3aGlsZShjZWwgPSBjZWwubmV4dFNpYmxpbmcpeyBpZiAoY2VsLm5vZGVUeXBlID09PSAxKSBCQUQ7IH0nXG5cdFx0XSksXG5cdFx0J250aC1jaGlsZCc6IGZ1bmN0aW9uKGEsYikge1xuXHRcdFx0dmFyIGdldF9pID0gam9pbihbXG5cdFx0XHRcdCd2YXIgaSA9IDEsIGNlbCA9IGVsOycsXG5cdFx0XHRcdCd3aGlsZShjZWwgPSBjZWwucHJldmlvdXNTaWJsaW5nKXsnLFxuXHRcdFx0XHRcdCdpZiAoY2VsLm5vZGVUeXBlID09PSAxKSBpKys7Jyxcblx0XHRcdFx0J30nXG5cdFx0XHRdKTtcblx0XHRcdFxuXHRcdFx0aWYgKGEgPT0gMCkgcmV0dXJuIGpvaW4oW1xuXHRcdFx0XHRnZXRfaSxcblx0XHRcdFx0J2lmIChpLSAnK2IrJyAhPSAwKSBCQUQ7J1xuXHRcdFx0XSk7XG5cdFx0XHRlbHNlIGlmIChiID09IDAgJiYgYSA+PSAwKSByZXR1cm4gam9pbihbXG5cdFx0XHRcdGdldF9pLFxuXHRcdFx0XHQnaWYgKGklJythKycgIT0gMCB8fCBpLycrYSsnIDwgMCkgQkFEOydcblx0XHRcdF0pO1xuXHRcdFx0ZWxzZSBpZiAoYiA9PSAwICYmIGEgPCAwKSByZXR1cm4gam9pbihbXG5cdFx0XHRcdCdCQUQ7J1xuXHRcdFx0XSk7XG5cdFx0XHRlbHNlIHJldHVybiBqb2luKFtcblx0XHRcdFx0Z2V0X2ksXG5cdFx0XHRcdCdpZiAoKGktICcrYisnKSUnK2ErJyAhPSAwIHx8IChpLSAnK2IrJykvJythKycgPCAwKSBCQUQ7J1xuXHRcdFx0XSk7XG5cdFx0fVxuXHR9O1xuXHRcblx0Ly8gTmVlZHMgdG8gcmVmZW5jZSBjb250ZW50cyBvZiBvYmplY3QsIHNvIG11c3QgYmUgaW5qZWN0ZWQgYWZ0ZXIgZGVmaW5pdGlvblxuXHRwc2V1ZG9jbHNjaGVja3NbJ29ubHktY2hpbGQnXSA9IGpvaW4oW1xuXHRcdHBzZXVkb2Nsc2NoZWNrc1snZmlyc3QtY2hpbGQnXSxcblx0XHRwc2V1ZG9jbHNjaGVja3NbJ2xhc3QtY2hpbGQnXVxuXHRdKTtcblx0XG5cdC8qKioqIFNpbXBsZVNlbGVjdG9yICoqKiovXG5cdFxuXHQkLnNlbGVjdG9yLlNpbXBsZVNlbGVjdG9yLmFkZE1ldGhvZCgnY29tcGlsZScsIGZ1bmN0aW9uKGVsKSB7XG5cdFx0dmFyIGpzID0gW107XG5cdFx0XG5cdFx0LyogQ2hlY2sgYWdhaW5zdCBlbGVtZW50IG5hbWUgKi9cdFx0XHRcblx0XHRpZiAodGhpcy50YWcgJiYgdGhpcy50YWcgIT0gJyonKSB7XG5cdFx0XHRqc1tqcy5sZW5ndGhdID0gJ2lmIChlbC50YWdOYW1lICE9IFwiJyt0aGlzLnRhZy50b1VwcGVyQ2FzZSgpKydcIikgQkFEOyc7XG5cdFx0fVxuXG5cdFx0LyogQ2hlY2sgYWdhaW5zdCBJRCAqL1xuXHRcdGlmICh0aGlzLmlkKSB7XG5cdFx0XHRqc1tqcy5sZW5ndGhdID0gZWwudXNlc19hdHRyKCdpZCcpO1xuXHRcdFx0anNbanMubGVuZ3RoXSA9ICdpZiAoX2lkICE9PSBcIicrdGhpcy5pZCsnXCIpIEJBRDsnO1xuXHRcdH1cblx0XHRcblx0XHQvKiBCdWlsZCBjbGFzc05hbWUgY2hlY2tpbmcgdmFyaWFibGUgKi9cblx0XHRpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCkge1xuXHRcdFx0anNbanMubGVuZ3RoXSA9IGVsLnVzZXNfd3NhdHRyKCdjbGFzcycpO1xuXHRcdFx0XG5cdFx0XHQvKiBDaGVjayBhZ2FpbnN0IGNsYXNzIG5hbWVzICovXG5cdFx0XHQkLmVhY2godGhpcy5jbGFzc2VzLCBmdW5jdGlvbihpLCBjbHMpe1xuXHRcdFx0XHRqc1tqcy5sZW5ndGhdID0gJ2lmIChfV1NfX2NsYXNzLmluZGV4T2YoXCIgJytjbHMrJyBcIikgPT0gLTEpIEJBRDsnO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qIENoZWNrIGFnYWluc3QgYXR0cmlidXRlcyAqL1xuXHRcdCQuZWFjaCh0aGlzLmF0dHJzLCBmdW5jdGlvbihpLCBhdHRyKXtcblx0XHRcdGpzW2pzLmxlbmd0aF0gPSAoYXR0clsxXSA9PSAnfj0nKSA/IGVsLnVzZXNfd3NhdHRyKGF0dHJbMF0pIDogZWwudXNlc19hdHRyKGF0dHJbMF0pO1xuXHRcdFx0dmFyIGNoZWNrID0gYXR0cmNoZWNrc1sgYXR0clsxXSB8fCAnLScgXTtcblx0XHRcdGNoZWNrID0gY2hlY2sucmVwbGFjZSggL0svZywgdmFyRm9yQXR0cihhdHRyWzBdKSkucmVwbGFjZSggL1YvZywgYXR0clsyXSAmJiBhdHRyWzJdLm1hdGNoKFNUQVJUU19XSVRIX1FVT1RFUykgPyBhdHRyWzJdLnNsaWNlKDEsLTEpIDogYXR0clsyXSApO1xuXHRcdFx0anNbanMubGVuZ3RoXSA9ICdpZiAoJytjaGVjaysnKSBCQUQ7Jztcblx0XHR9KTtcblx0XHRcblx0XHQvKiBDaGVjayBhZ2FpbnN0IG5vdHMgKi9cblx0XHQkLmVhY2godGhpcy5ub3RzLCBmdW5jdGlvbihpLCBub3Qpe1xuXHRcdFx0dmFyIGxibCA9ICsrbGJsX2lkO1xuXHRcdFx0dmFyIGZ1bmMgPSBqb2luKFtcblx0XHRcdFx0J2wnK2xibCsnOnsnLFxuXHRcdFx0XHRcdG5vdC5jb21waWxlKGVsKS5yZXBsYWNlKEJBRCwgJ2JyZWFrIGwnK2xibCkucmVwbGFjZShHT09ELCAnQkFEJyksXG5cdFx0XHRcdCd9J1xuXHRcdFx0XSk7XG5cdFx0XHRcblx0XHRcdGlmICghKG5vdCBpbnN0YW5jZW9mICQuc2VsZWN0b3IuU2ltcGxlU2VsZWN0b3IpKSBmdW5jID0gam9pbihbXG5cdFx0XHRcdGVsLnNhdmUobGJsKSxcblx0XHRcdFx0ZnVuYyxcblx0XHRcdFx0ZWwucmVzdG9yZShsYmwpXG5cdFx0XHRdKTtcblx0XHRcdFx0XG5cdFx0XHRqc1tqcy5sZW5ndGhdID0gZnVuYztcblx0XHR9KTtcblx0XHRcblx0XHQvKiBDaGVjayBhZ2FpbnN0IHBzZXVkby1jbGFzc2VzICovXG5cdFx0JC5lYWNoKHRoaXMucHNldWRvX2NsYXNzZXMsIGZ1bmN0aW9uKGksIHBzY2xzKXtcblx0XHRcdHZhciBjaGVjayA9IHBzZXVkb2Nsc2NoZWNrc1twc2Nsc1swXV07XG5cdFx0XHRpZiAoY2hlY2spIHtcblx0XHRcdFx0anNbanMubGVuZ3RoXSA9ICggdHlwZW9mIGNoZWNrID09ICdmdW5jdGlvbicgPyBjaGVjay5hcHBseSh0aGlzLCBwc2Nsc1sxXSkgOiBjaGVjayApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoY2hlY2sgPSAkLmZpbmQuc2VsZWN0b3JzLmZpbHRlcnNbcHNjbHNbMF1dKSB7XG5cdFx0XHRcdGpzW2pzLmxlbmd0aF0gPSBlbC51c2VzX2pxdWVyeUZpbHRlcnMoKTtcblx0XHRcdFx0anNbanMubGVuZ3RoXSA9ICdpZiAoIV8kZmlsdGVycy4nK3BzY2xzWzBdKycoZWwpKSBCQUQ7Jztcblx0XHRcdH1cblx0XHR9KTtcblx0XHRcblx0XHRqc1tqcy5sZW5ndGhdID0gJ0dPT0QnO1xuXHRcdFxuXHRcdC8qIFBhc3MgKi9cblx0XHRyZXR1cm4gam9pbihqcyk7XG5cdH0pO1xuXHRcblx0dmFyIGxibF9pZCA9IDA7XG5cdC8qKiBUdXJucyBhbiBjb21waWxlZCBmcmFnbWVudCBpbnRvIHRoZSBmaXJzdCBwYXJ0IG9mIGEgY29tYmluYXRpb24gKi9cblx0ZnVuY3Rpb24gYXNfc3ViZXhwcihmKSB7XG5cdFx0aWYgKGYuY29tcGxleClcblx0XHRcdHJldHVybiBqb2luKFtcblx0XHRcdFx0J2wnKygrK2xibF9pZCkrJzp7Jyxcblx0XHRcdFx0XHRmLnJlcGxhY2UoR09PRCwgJ2JyZWFrIGwnK2xibF9pZCksXG5cdFx0XHRcdCd9J1xuXHRcdFx0XSk7XG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIGYucmVwbGFjZShHT09ELCAnJyk7XG5cdH1cblx0XG5cdHZhciBjb21iaW5lcyA9IHtcblx0XHQnICc6IGZ1bmN0aW9uKGVsLCBmMSwgZjIpIHtcblx0XHRcdHJldHVybiBqb2luX2NvbXBsZXgoW1xuXHRcdFx0XHRmMixcblx0XHRcdFx0J3doaWxlKHRydWUpeycsXG5cdFx0XHRcdFx0ZWwucGFyZW50KCksXG5cdFx0XHRcdFx0J2lmICghZWwgfHwgZWwubm9kZVR5cGUgIT09IDEpIEJBRDsnLFxuXHRcdFx0XHRcdGYxLmNvbXBpbGUoZWwpLnJlcGxhY2UoQkFELCAnY29udGludWUnKSxcblx0XHRcdFx0J30nXG5cdFx0XHRdKTtcblx0XHR9LFxuXHRcdFxuXHRcdCc+JzogZnVuY3Rpb24oZWwsIGYxLCBmMikge1xuXHRcdFx0cmV0dXJuIGpvaW4oW1xuXHRcdFx0XHRmMixcblx0XHRcdFx0ZWwucGFyZW50KCksXG5cdFx0XHRcdCdpZiAoIWVsIHx8IGVsLm5vZGVUeXBlICE9PSAxKSBCQUQ7Jyxcblx0XHRcdFx0ZjEuY29tcGlsZShlbClcblx0XHRcdF0pO1xuXHRcdH0sXG5cdFx0XG5cdFx0J34nOiBmdW5jdGlvbihlbCwgZjEsIGYyKSB7XG5cdFx0XHRyZXR1cm4gam9pbl9jb21wbGV4KFtcblx0XHRcdFx0ZjIsXG5cdFx0XHRcdGVsLnByZXZMb29wKCksXG5cdFx0XHRcdFx0ZjEuY29tcGlsZShlbCkucmVwbGFjZShCQUQsICdjb250aW51ZScpLFxuXHRcdFx0XHQnfScsXG5cdFx0XHRcdCdCQUQ7J1xuXHRcdFx0XSk7XG5cdFx0fSxcblx0XHRcblx0XHQnKyc6IGZ1bmN0aW9uKGVsLCBmMSwgZjIpIHtcblx0XHRcdHJldHVybiBqb2luKFtcblx0XHRcdFx0ZjIsXG5cdFx0XHRcdGVsLnByZXYoKSxcblx0XHRcdFx0J2lmICghZWwpIEJBRDsnLFxuXHRcdFx0XHRmMS5jb21waWxlKGVsKVxuXHRcdFx0XSk7XG5cdFx0fVxuXHR9O1xuXHRcblx0JC5zZWxlY3Rvci5TZWxlY3Rvci5hZGRNZXRob2QoJ2NvbXBpbGUnLCBmdW5jdGlvbihlbCkge1xuXHRcdHZhciBsID0gdGhpcy5wYXJ0cy5sZW5ndGg7XG5cdFx0XG5cdFx0dmFyIGV4cHIgPSB0aGlzLnBhcnRzWy0tbF0uY29tcGlsZShlbCk7XG5cdFx0d2hpbGUgKGwpIHtcblx0XHRcdHZhciBjb21iaW5hdG9yID0gdGhpcy5wYXJ0c1stLWxdO1xuXHRcdFx0ZXhwciA9IGNvbWJpbmVzW2NvbWJpbmF0b3JdKGVsLCB0aGlzLnBhcnRzWy0tbF0sIGFzX3N1YmV4cHIoZXhwcikpO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gZXhwcjtcblx0fSk7XG5cblx0JC5zZWxlY3Rvci5TZWxlY3RvcnNHcm91cC5hZGRNZXRob2QoJ2NvbXBpbGUnLCBmdW5jdGlvbihlbCkge1xuXHRcdHZhciBleHByID0gW10sIGxibCA9ICsrbGJsX2lkO1xuXHRcdFxuXHRcdGZvciAodmFyIGk9MDsgaSA8IHRoaXMucGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGV4cHJbZXhwci5sZW5ndGhdID0gam9pbihbXG5cdFx0XHRcdGkgPT0gMCA/IGVsLnNhdmUobGJsKSA6IGVsLnJlc3RvcmUobGJsKSwgXG5cdFx0XHRcdCdsJytsYmwrJ18nK2krJzp7Jyxcblx0XHRcdFx0XHR0aGlzLnBhcnRzW2ldLmNvbXBpbGUoZWwpLnJlcGxhY2UoQkFELCAnYnJlYWsgbCcrbGJsKydfJytpKSxcblx0XHRcdFx0J30nXG5cdFx0XHRdKTtcblx0XHR9XG5cdFx0XG5cdFx0ZXhwcltleHByLmxlbmd0aF0gPSAnQkFEOyc7XG5cdFx0cmV0dXJuIGpvaW4oZXhwcik7XG5cdH0pO1xuXG5cdCQuc2VsZWN0b3IuU2VsZWN0b3JCYXNlLmFkZE1ldGhvZCgnbWF0Y2hlcycsIGZ1bmN0aW9uKGVsKXtcdFxuXHRcdHRoaXMubWF0Y2hlcyA9IG5ldyBGdW5jdGlvbignZWwnLCBqb2luKFsgXG5cdFx0XHQnaWYgKCFlbCkgcmV0dXJuIGZhbHNlOycsXG5cdFx0XHR0aGlzLmNvbXBpbGUobmV3IFN0YXRlKCkpLnJlcGxhY2UoQkFELCAncmV0dXJuIGZhbHNlJykucmVwbGFjZShHT09ELCAncmV0dXJuIHRydWUnKVxuXHRcdF0pKTtcblx0XHRyZXR1cm4gdGhpcy5tYXRjaGVzKGVsKTtcblx0fSk7XG5cdFxufSkoalF1ZXJ5KTtcblxuO1xuXG5cbi8qIHNyYy9qcXVlcnkuc2VsZWN0b3IuYWZmZWN0ZWRieS5qcyAqL1xuXG4oZnVuY3Rpb24oJCkge1xuXG5cdC8vIFRPRE86XG5cdC8vIE1ha2UgYXR0cmlidXRlcyAmIElEcyB3b3JrXG5cblx0dmFyIERJUkVDVCA9IC9ESVJFQ1QvZztcblx0dmFyIENPTlRFWFQgPSAvQ09OVEVYVC9nO1xuXHR2YXIgRUlUSEVSID0gL0RJUkVDVHxDT05URVhUL2c7XG5cblx0JC5zZWxlY3Rvci5TZWxlY3RvckJhc2UuYWRkTWV0aG9kKCdhZmZlY3RlZEJ5JywgZnVuY3Rpb24ocHJvcHMpIHtcblx0XHR0aGlzLmFmZmVjdGVkQnkgPSBuZXcgRnVuY3Rpb24oJ3Byb3BzJywgKFtcblx0XHRcdCd2YXIgZGlyZWN0X2NsYXNzZXMsIGNvbnRleHRfY2xhc3NlcywgZGlyZWN0X2F0dHJzLCBjb250ZXh0X2F0dHJzLCB0OycsXG5cdFx0XHR0aGlzLkFCQ19jb21waWxlKCkucmVwbGFjZShESVJFQ1QsICdkaXJlY3QnKS5yZXBsYWNlKENPTlRFWFQsICdjb250ZXh0JyksXG5cdFx0XHQncmV0dXJuIHtjbGFzc2VzOiB7Y29udGV4dDogY29udGV4dF9jbGFzc2VzLCBkaXJlY3Q6IGRpcmVjdF9jbGFzc2VzfSwgYXR0cnM6IHtjb250ZXh0OiBjb250ZXh0X2F0dHJzLCBkaXJlY3Q6IGRpcmVjdF9hdHRyc319Oydcblx0XHRdKS5qb2luKFwiXFxuXCIpKTtcblxuXHRcdC8vIERFQlVHOiBQcmludCBvdXQgdGhlIGNvbXBpbGVkIGZ1bmNpdG9uXG5cdFx0Ly8gY29uc29sZS5sb2codGhpcy5zZWxlY3RvciwgJycrdGhpcy5hZmZlY3RlZEJ5KTtcblxuXHRcdHJldHVybiB0aGlzLmFmZmVjdGVkQnkocHJvcHMpO1xuXHR9KTtcblxuXHQkLnNlbGVjdG9yLlNpbXBsZVNlbGVjdG9yLmFkZE1ldGhvZCgnQUJDX2NvbXBpbGUnLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdCQuZWFjaCh0aGlzLmNsYXNzZXMsIGZ1bmN0aW9uKGksIGNscyl7XG5cdFx0XHRwYXJ0c1twYXJ0cy5sZW5ndGhdID0gXCJpZiAodCA9IHByb3BzLmNsYXNzZXNbJ1wiK2NscytcIiddKSAoRElSRUNUX2NsYXNzZXMgfHwgKERJUkVDVF9jbGFzc2VzID0ge30pKVsnXCIrY2xzK1wiJ10gPSB0O1wiO1xuXHRcdH0pO1xuXG5cdFx0JC5lYWNoKHRoaXMubm90cywgZnVuY3Rpb24oaSwgbm90KXtcblx0XHRcdHBhcnRzW3BhcnRzLmxlbmd0aF0gPSBub3QuQUJDX2NvbXBpbGUoKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBwYXJ0cy5qb2luKFwiXFxuXCIpO1xuXHR9KTtcblxuXHQkLnNlbGVjdG9yLlNlbGVjdG9yLmFkZE1ldGhvZCgnQUJDX2NvbXBpbGUnLCBmdW5jdGlvbihhcmcpe1xuXHRcdHZhciBwYXJ0cyA9IFtdO1xuXHRcdHZhciBpID0gdGhpcy5wYXJ0cy5sZW5ndGgtMTtcblxuXHRcdHBhcnRzW3BhcnRzLmxlbmd0aF0gPSB0aGlzLnBhcnRzW2ldLkFCQ19jb21waWxlKCk7XG5cdFx0d2hpbGUgKChpID0gaSAtIDIpID49IDApIHBhcnRzW3BhcnRzLmxlbmd0aF0gPSB0aGlzLnBhcnRzW2ldLkFCQ19jb21waWxlKCkucmVwbGFjZShFSVRIRVIsICdDT05URVhUJyk7XG5cblx0XHRyZXR1cm4gcGFydHMuam9pbihcIlxcblwiKTtcblx0fSk7XG5cblx0JC5zZWxlY3Rvci5TZWxlY3RvcnNHcm91cC5hZGRNZXRob2QoJ0FCQ19jb21waWxlJywgZnVuY3Rpb24oKXtcblx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdCQuZWFjaCh0aGlzLnBhcnRzLCBmdW5jdGlvbihpLHBhcnQpe1xuXHRcdFx0cGFydHNbcGFydHMubGVuZ3RoXSA9IHBhcnQuQUJDX2NvbXBpbGUoKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBwYXJ0cy5qb2luKFwiXFxuXCIpO1xuXHR9KTtcblxuXG59KShqUXVlcnkpO1xuO1xuXG5cbi8qIHNyYy9qcXVlcnkuZm9jdXNpbm91dC5qcyAqL1xuXG4oZnVuY3Rpb24oJCl7XHRcblx0XG5cdC8qKlxuXHQgKiBBZGQgZm9jdXNpbiBhbmQgZm9jdXNvdXQgc3VwcG9ydCB0byBiaW5kIGFuZCBsaXZlIGZvciBicm93ZXJzIG90aGVyIHRoYW4gSUUuIERlc2lnbmVkIHRvIGJlIHVzYWJsZSBpbiBhIGRlbGVnYXRlZCBmYXNoaW9uIChsaWtlICQubGl2ZSlcblx0ICogQ29weXJpZ2h0IChjKSAyMDA3IErDtnJuIFphZWZmZXJlclxuXHQgKi9cblx0aWYgKCQuc3VwcG9ydC5mb2N1c2luQnViYmxlcyA9PT0gdW5kZWZpbmVkKSAge1xuXHRcdCQuc3VwcG9ydC5mb2N1c2luQnViYmxlcyA9ICEhKCQuYnJvd3Nlci5tc2llKTtcblx0fVxuXG5cdGlmICghJC5zdXBwb3J0LmZvY3VzaW5CdWJibGVzICYmICEkLmV2ZW50LnNwZWNpYWwuZm9jdXNpbikge1xuXHRcdC8vIEVtdWxhdGUgZm9jdXNpbiBhbmQgZm9jdXNvdXQgYnkgYmluZGluZyBmb2N1cyBhbmQgYmx1ciBpbiBjYXB0dXJpbmcgbW9kZVxuXHRcdCQuZWFjaCh7Zm9jdXM6ICdmb2N1c2luJywgYmx1cjogJ2ZvY3Vzb3V0J30sIGZ1bmN0aW9uKG9yaWdpbmFsLCBmaXgpe1xuXHRcdFx0JC5ldmVudC5zcGVjaWFsW2ZpeF0gPSB7XG5cdFx0XHRcdHNldHVwOiBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGlmICghdGhpcy5hZGRFdmVudExpc3RlbmVyKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKG9yaWdpbmFsLCAkLmV2ZW50LnNwZWNpYWxbZml4XS5oYW5kbGVyLCB0cnVlKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIob3JpZ2luYWwsICQuZXZlbnQuc3BlY2lhbFtmaXhdLmhhbmRsZXIsIHRydWUpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRoYW5kbGVyOiBmdW5jdGlvbihlKXtcblx0XHRcdFx0XHRhcmd1bWVudHNbMF0gPSAkLmV2ZW50LmZpeChlKTtcblx0XHRcdFx0XHRhcmd1bWVudHNbMF0udHlwZSA9IGZpeDtcblx0XHRcdFx0XHRyZXR1cm4gJC5ldmVudC5oYW5kbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9KTtcblx0fVxuXHRcdFxuXHQoZnVuY3Rpb24oKXtcblx0XHQvL0lFIGhhcyBzb21lIHRyb3VibGUgd2l0aCBmb2N1c291dCB3aXRoIHNlbGVjdCBhbmQga2V5Ym9hcmQgbmF2aWdhdGlvblxuXHRcdHZhciBhY3RpdmVGb2N1cyA9IG51bGw7XG5cdFxuXHRcdCQoZG9jdW1lbnQpXG5cdFx0XHQuYmluZCgnZm9jdXNpbicsIGZ1bmN0aW9uKGUpe1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZS5yZWFsVGFyZ2V0IHx8IGUudGFyZ2V0O1xuXHRcdFx0XHRpZiAoYWN0aXZlRm9jdXMgJiYgYWN0aXZlRm9jdXMgIT09IHRhcmdldCkge1xuXHRcdFx0XHRcdGUudHlwZSA9ICdmb2N1c291dCc7XG5cdFx0XHRcdFx0JChhY3RpdmVGb2N1cykudHJpZ2dlcihlKTtcblx0XHRcdFx0XHRlLnR5cGUgPSAnZm9jdXNpbic7XG5cdFx0XHRcdFx0ZS50YXJnZXQgPSB0YXJnZXQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0YWN0aXZlRm9jdXMgPSB0YXJnZXQ7XG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoJ2ZvY3Vzb3V0JywgZnVuY3Rpb24oZSl7XG5cdFx0XHRcdGFjdGl2ZUZvY3VzID0gbnVsbDtcblx0XHRcdH0pO1xuXHR9KSgpO1xuXHRcbn0pKGpRdWVyeSk7O1xuXG5cbi8qIHNyYy9qcXVlcnkuZW50d2luZS5qcyAqL1xuXG50cnkge1xuXHRjb25zb2xlLmxvZztcbn1cbmNhdGNoIChlKSB7XG5cdHdpbmRvdy5jb25zb2xlID0gdW5kZWZpbmVkO1xufVxuXG4oZnVuY3Rpb24oJCkge1xuXG5cdC8qIENyZWF0ZSBhIHN1YmNsYXNzIG9mIHRoZSBqUXVlcnkgb2JqZWN0LiBUaGlzIHdhcyBpbnRyb2R1Y2VkIGluIGpRdWVyeSAxLjUsIGJ1dCByZW1vdmVkIGFnYWluIGluIDEuOSAqL1xuXHR2YXIgc3ViID0gZnVuY3Rpb24oKSB7XG5cdFx0ZnVuY3Rpb24galF1ZXJ5U3ViKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRcdHJldHVybiBuZXcgalF1ZXJ5U3ViLmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdFx0fVxuXG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgalF1ZXJ5U3ViLCAkICk7XG5cdFx0alF1ZXJ5U3ViLnN1cGVyY2xhc3MgPSAkO1xuXHRcdGpRdWVyeVN1Yi5mbiA9IGpRdWVyeVN1Yi5wcm90b3R5cGUgPSAkKCk7XG5cdFx0alF1ZXJ5U3ViLmZuLmNvbnN0cnVjdG9yID0galF1ZXJ5U3ViO1xuXHRcdGpRdWVyeVN1Yi5mbi5pbml0ID0gZnVuY3Rpb24gaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIGNvbnRleHQgJiYgY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSAmJiAhKGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnlTdWIpICkge1xuXHRcdFx0XHRjb250ZXh0ID0galF1ZXJ5U3ViKCBjb250ZXh0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBqUXVlcnkuZm4uaW5pdC5jYWxsKCB0aGlzLCBzZWxlY3RvciwgY29udGV4dCwgcm9vdGpRdWVyeVN1YiApO1xuXHRcdH07XG5cdFx0alF1ZXJ5U3ViLmZuLmluaXQucHJvdG90eXBlID0galF1ZXJ5U3ViLmZuO1xuXHRcdHZhciByb290alF1ZXJ5U3ViID0galF1ZXJ5U3ViKGRvY3VtZW50KTtcblx0XHRyZXR1cm4galF1ZXJ5U3ViO1xuXHR9O1xuXG5cdHZhciBuYW1lc3BhY2VzID0ge307XG5cblx0JC5lbnR3aW5lID0gZnVuY3Rpb24oKSB7XG5cdFx0JC5mbi5lbnR3aW5lLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQSBjb3VwbGUgb2YgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIGFjY2Vzc2luZyB0aGUgc3RvcmUgb3V0c2lkZSBvZiB0aGlzIGNsb3N1cmUsIGFuZCBmb3IgbWFraW5nIHRoaW5nc1xuXHQgKiBvcGVyYXRlIGluIGEgbGl0dGxlIG1vcmUgZWFzeS10by10ZXN0IG1hbm5lclxuXHQgKi9cblx0JC5leHRlbmQoJC5lbnR3aW5lLCB7XG5cdFx0LyoqXG5cdFx0ICogR2V0IGFsbCB0aGUgbmFtZXNwYWNlcy4gVXNlZnVsIGZvciBpbnRyb3NwZWN0aW9uPyBJbnRlcm5hbCBpbnRlcmZhY2Ugb2YgTmFtZXNwYWNlIG5vdCBndWFyYW50ZWVkIGNvbnNpc3RhbnRcblx0XHQgKi9cblx0XHRuYW1lc3BhY2VzOiBuYW1lc3BhY2VzLFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSBhbGwgZW50d2luZSBydWxlc1xuXHRcdCAqL1xuXHRcdGNsZWFyX2FsbF9ydWxlczogZnVuY3Rpb24oKSB7IFxuXHRcdFx0Ly8gUmVtb3ZlIHByb3h5IGZ1bmN0aW9uc1xuXHRcdFx0Zm9yICh2YXIgayBpbiAkLmZuKSB7IGlmICgkLmZuW2tdLmlzZW50d2luZW1ldGhvZCkgZGVsZXRlICQuZm5ba107IH1cblx0XHRcdC8vIFJlbW92ZSBib3VuZCBldmVudHMgLSBUT0RPOiBNYWtlIHRoaXMgcGx1Z2dhYmxlLCBzbyB0aGlzIGNvZGUgY2FuIGJlIG1vdmVkIHRvIGpxdWVyeS5lbnR3aW5lLmV2ZW50cy5qc1xuXHRcdFx0JChkb2N1bWVudCkudW5iaW5kKCcuZW50d2luZScpO1xuXHRcdFx0JCh3aW5kb3cpLnVuYmluZCgnLmVudHdpbmUnKTtcblx0XHRcdC8vIFJlbW92ZSBuYW1lc3BhY2VzLCBhbmQgc3RhcnQgb3ZlciBhZ2FpblxuXHRcdFx0Zm9yICh2YXIgayBpbiBuYW1lc3BhY2VzKSBkZWxldGUgbmFtZXNwYWNlc1trXTtcblx0XHRcdGZvciAodmFyIGsgaW4gJC5lbnR3aW5lLmNhcHR1cmVfYmluZGluZ3MpIGRlbGV0ZSAkLmVudHdpbmUuY2FwdHVyZV9iaW5kaW5nc1trXTtcblx0XHR9LFxuXHRcdFxuXHRcdFdBUk5fTEVWRUxfTk9ORTogMCxcblx0XHRXQVJOX0xFVkVMX0lNUE9SVEFOVDogMSxcblx0XHRXQVJOX0xFVkVMX0JFU1RQUkFDVElTRTogMixcblx0XHRcblx0XHQvKiogXG5cdFx0ICogV2FybmluZyBsZXZlbC4gU2V0IHRvIGEgaGlnaGVyIGxldmVsIHRvIGdldCB3YXJuaW5ncyBkdW1wZWQgdG8gY29uc29sZS5cblx0XHQgKi9cblx0XHR3YXJuaW5nTGV2ZWw6IDAsXG5cdFx0XG5cdFx0LyoqIFV0aWxpdHkgdG8gb3B0aW9uYWxseSBkaXNwbGF5IHdhcm5pbmcgbWVzc2FnZXMgZGVwZW5kaW5nIG9uIGxldmVsICovXG5cdFx0d2FybjogZnVuY3Rpb24obWVzc2FnZSwgbGV2ZWwpIHtcblx0XHRcdGlmIChsZXZlbCA8PSAkLmVudHdpbmUud2FybmluZ0xldmVsICYmIGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7IFxuXHRcdFx0XHRjb25zb2xlLndhcm4obWVzc2FnZSk7XG5cdFx0XHRcdGlmIChjb25zb2xlLnRyYWNlKSBjb25zb2xlLnRyYWNlKCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHR3YXJuX2V4Y2VwdGlvbjogZnVuY3Rpb24od2hlcmUsIC8qIG9wdGlvbmFsOiAqLyBvbiwgZSkge1xuXHRcdFx0aWYgKCQuZW50d2luZS5XQVJOX0xFVkVMX0lNUE9SVEFOVCA8PSAkLmVudHdpbmUud2FybmluZ0xldmVsICYmIGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XG5cdFx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHsgZSA9IG9uOyBvbiA9IG51bGw7IH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChvbikgY29uc29sZS53YXJuKCdVbmNhdWdodCBleGNlcHRpb24nLGUsJ2luJyx3aGVyZSwnb24nLG9uKTtcblx0XHRcdFx0ZWxzZSAgICBjb25zb2xlLndhcm4oJ1VuY2F1Z2h0IGV4Y2VwdGlvbicsZSwnaW4nLHdoZXJlKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChlLnN0YWNrKSBjb25zb2xlLndhcm4oXCJTdGFjayBUcmFjZTpcXG5cIiArIGUuc3RhY2spO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdFxuXG5cdC8qKiBTdG9yZXMgYSBjb3VudCBvZiBkZWZpbml0aW9ucywgc28gdGhhdCB3ZSBjYW4gc29ydCBpZGVudGljYWwgc2VsZWN0b3JzIGJ5IGRlZmluaXRpb24gb3JkZXIgKi9cblx0dmFyIHJ1bGVjb3VudCA9IDA7XG5cdFxuXHR2YXIgUnVsZSA9IEJhc2UuZXh0ZW5kKHtcblx0XHRpbml0OiBmdW5jdGlvbihzZWxlY3RvciwgbmFtZSkge1xuXHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5zcGVjaWZpdHkgPSBzZWxlY3Rvci5zcGVjaWZpdHkoKTtcblx0XHRcdHRoaXMuaW1wb3J0YW50ID0gMDtcblx0XHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0XHR0aGlzLnJ1bGVjb3VudCA9IHJ1bGVjb3VudCsrO1xuXHRcdH1cblx0fSk7XG5cdFxuXHRSdWxlLmNvbXBhcmUgPSBmdW5jdGlvbihhLCBiKSB7XG5cdFx0dmFyIGFzID0gYS5zcGVjaWZpdHksIGJzID0gYi5zcGVjaWZpdHk7XG5cdFx0XG5cdFx0cmV0dXJuIChhLmltcG9ydGFudCAtIGIuaW1wb3J0YW50KSB8fFxuXHRcdCAgICAgICAoYXNbMF0gLSBic1swXSkgfHxcblx0XHQgICAgICAgKGFzWzFdIC0gYnNbMV0pIHx8XG5cdFx0ICAgICAgIChhc1syXSAtIGJzWzJdKSB8fFxuXHRcdCAgICAgICAoYS5ydWxlY291bnQgLSBiLnJ1bGVjb3VudCkgO1xuXHR9O1xuXG5cdCQuZW50d2luZS5SdWxlTGlzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsaXN0ID0gW107XG5cdFx0XG5cdFx0bGlzdC5hZGRSdWxlID0gZnVuY3Rpb24oc2VsZWN0b3IsIG5hbWUpeyBcblx0XHRcdHZhciBydWxlID0gUnVsZShzZWxlY3RvciwgbmFtZSk7XG5cdFx0XHRcblx0XHRcdGxpc3RbbGlzdC5sZW5ndGhdID0gcnVsZTsgXG5cdFx0XHRsaXN0LnNvcnQoUnVsZS5jb21wYXJlKTsgXG5cdFx0XHRcblx0XHRcdHJldHVybiBydWxlO1xuXHRcdH07XG5cdFx0XG5cdFx0cmV0dXJuIGxpc3Q7XG5cdH07XG5cblx0dmFyIGhhbmRsZXJzID0gW107XG5cdFxuXHQvKipcblx0ICogQSBOYW1lc3BhY2UgaG9sZHMgYWxsIHRoZSBpbmZvcm1hdGlvbiBuZWVkZWQgZm9yIGFkZGluZyBlbnR3aW5lIG1ldGhvZHMgdG8gYSBuYW1lc3BhY2UgKGluY2x1ZGluZyB0aGUgX251bGxfIG5hbWVzcGFjZSlcblx0ICovXG5cdCQuZW50d2luZS5OYW1lc3BhY2UgPSBCYXNlLmV4dGVuZCh7XG5cdFx0aW5pdDogZnVuY3Rpb24obmFtZSl7XG5cdFx0XHRpZiAobmFtZSAmJiAhbmFtZS5tYXRjaCgvXltBLVphLXowLTkuXSskLykpICQuZW50d2luZS53YXJuKCdFbnR3aW5lIG5hbWVzcGFjZSAnK25hbWUrJyBpcyBub3QgZm9ybWF0dGVkIGFzIHBlcmlvZCBzZXBlcmF0ZWQgaWRlbnRpZmllcnMnLCAkLmVudHdpbmUuV0FSTl9MRVZFTF9CRVNUUFJBQ1RJU0UpO1xuXHRcdFx0bmFtZSA9IG5hbWUgfHwgJ19fYmFzZSc7XG5cdFx0XHRcblx0XHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0XHR0aGlzLnN0b3JlID0ge307XG5cdFx0XHRcblx0XHRcdG5hbWVzcGFjZXNbbmFtZV0gPSB0aGlzO1xuXHRcdFx0XG5cdFx0XHRpZiAobmFtZSA9PSBcIl9fYmFzZVwiKSB7XG5cdFx0XHRcdHRoaXMuaW5qZWN0ZWUgPSAkLmZuO1xuXHRcdFx0XHR0aGlzLiQgPSAkO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIFdlJ3JlIGluIGEgbmFtZXNwYWNlLCBzbyB3ZSBidWlsZCBhIENsYXNzIHRoYXQgc3ViY2xhc3NlcyB0aGUgalF1ZXJ5IE9iamVjdCBDbGFzcyB0byBpbmplY3QgbmFtZXNwYWNlIGZ1bmN0aW9ucyBpbnRvXG5cdFx0XHRcdHRoaXMuJCA9ICQuc3ViID8gJC5zdWIoKSA6IHN1YigpO1xuXHRcdFx0XHQvLyBXb3JrIGFyb3VuZCBidWcgaW4gc3ViKCkgLSBzdWJjbGFzcyBtdXN0IHNoYXJlIGNhY2hlIHdpdGggcm9vdCBvciBkYXRhIHdvbid0IGdldCBjbGVhcmVkIGJ5IGNsZWFuRGF0YVxuXHRcdFx0XHR0aGlzLiQuY2FjaGUgPSAkLmNhY2hlO1xuXG5cdFx0XHRcdHRoaXMuaW5qZWN0ZWUgPSB0aGlzLiQucHJvdG90eXBlO1xuXG5cdFx0XHRcdC8vIFdlIG92ZXJyaWRlIGVudHdpbmUgdG8gaW5qZWN0IHRoZSBuYW1lIG9mIHRoaXMgbmFtZXNwYWNlIHdoZW4gZGVmaW5pbmcgYmxvY2tzIGluc2lkZSB0aGlzIG5hbWVzcGFjZVxuXHRcdFx0XHR2YXIgZW50d2luZV93cmFwcGVyID0gdGhpcy5pbmplY3RlZS5lbnR3aW5lID0gZnVuY3Rpb24oc3BhY2VuYW1lKSB7XG5cdFx0XHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKCFzcGFjZW5hbWUgfHwgdHlwZW9mIHNwYWNlbmFtZSAhPSAnc3RyaW5nJykgeyBhcmdzID0gJC5tYWtlQXJyYXkoYXJncyk7IGFyZ3MudW5zaGlmdChuYW1lKTsgfVxuXHRcdFx0XHRcdGVsc2UgaWYgKHNwYWNlbmFtZS5jaGFyQXQoMCkgIT0gJy4nKSBhcmdzWzBdID0gbmFtZSsnLicrc3BhY2VuYW1lO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJldHVybiAkLmZuLmVudHdpbmUuYXBwbHkodGhpcywgYXJncyk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLiQuZW50d2luZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGVudHdpbmVfd3JhcHBlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBoYW5kbGVyID0gaGFuZGxlcnNbaV0sIGJ1aWxkZXI7XG5cblx0XHRcdFx0XHQvLyBJbmplY3QgalF1ZXJ5IG9iamVjdCBtZXRob2Qgb3ZlcnJpZGVzXG5cdFx0XHRcdFx0aWYgKGJ1aWxkZXIgPSBoYW5kbGVyLm5hbWVzcGFjZU1ldGhvZE92ZXJyaWRlcykge1xuXHRcdFx0XHRcdFx0dmFyIG92ZXJyaWRlcyA9IGJ1aWxkZXIodGhpcyk7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBrIGluIG92ZXJyaWRlcykgdGhpcy5pbmplY3RlZVtrXSA9IG92ZXJyaWRlc1trXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gSW5qZWN0ICQuZW50d2luZSBmdW5jdGlvbiBvdmVycmlkZXNcblx0XHRcdFx0XHRpZiAoYnVpbGRlciA9IGhhbmRsZXIubmFtZXNwYWNlU3RhdGljT3ZlcnJpZGVzKSB7XG5cdFx0XHRcdFx0XHR2YXIgb3ZlcnJpZGVzID0gYnVpbGRlcih0aGlzKTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGsgaW4gb3ZlcnJpZGVzKSB0aGlzLiQuZW50d2luZVtrXSA9IG92ZXJyaWRlc1trXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGRvZXMgc2VsZWN0b3IgbWF0Y2hpbmcgYWdhaW5zdCB0aGUgZnVuY3Rpb24gbGlzdCBmb3IgYSBmdW5jdGlvbiBuYW1lXG5cdFx0ICogVXNlZCBieSBwcm94eSBmb3IgYWxsIGNhbGxzLCBhbmQgYnkgY3RvclByb3h5IHRvIGhhbmRsZSBfc3VwZXIgY2FsbHNcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIGFzIHBhc3NlZCBpbiB0aGUgY29uc3RydWN0aW9uIG9iamVjdFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBmdW5jcHJvcCAtIHRoZSBwcm9wZXJ0eSBvbiB0aGUgUnVsZSBvYmplY3QgdGhhdCBnaXZlcyB0aGUgYWN0dWFsIGZ1bmN0aW9uIHRvIGNhbGxcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBiYXNlZnVuYyAtIHRoZSBub24tZW50d2luZSBmdW5jdGlvbiB0byB1c2UgYXMgdGhlIGNhdGNoLWFsbCBmdW5jdGlvbiBhdCB0aGUgYm90dG9tIG9mIHRoZSBzdGFja1xuXHRcdCAqL1xuXHRcdG9uZTogZnVuY3Rpb24obmFtZSwgZnVuY3Byb3AsIGJhc2VmdW5jKSB7XG5cdFx0XHR2YXIgbmFtZXNwYWNlID0gdGhpcztcblx0XHRcdHZhciBmdW5jcyA9IHRoaXMuc3RvcmVbbmFtZV07XG5cdFx0XHRcblx0XHRcdHZhciBvbmUgPSBmdW5jdGlvbihlbCwgYXJncywgaSl7XG5cdFx0XHRcdGlmIChpID09PSB1bmRlZmluZWQpIGkgPSBmdW5jcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRpZiAoZnVuY3NbaV0uc2VsZWN0b3IubWF0Y2hlcyhlbCkpIHtcblx0XHRcdFx0XHRcdHZhciByZXQsIHRtcF9pID0gZWwuaSwgdG1wX2YgPSBlbC5mO1xuXHRcdFx0XHRcdFx0ZWwuaSA9IGk7IGVsLmYgPSBvbmU7XG5cdFx0XHRcdFx0XHR0cnkgeyByZXQgPSBmdW5jc1tpXVtmdW5jcHJvcF0uYXBwbHkobmFtZXNwYWNlLiQoZWwpLCBhcmdzKTsgfVxuXHRcdFx0XHRcdFx0ZmluYWxseSB7IGVsLmkgPSB0bXBfaTsgZWwuZiA9IHRtcF9mOyB9XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhIGVudHdpbmUtZGVmaW5lZCBmdW5jdGlvbiwgYnV0IHRoZXJlIGlzIGEgbm9uLWVudHdpbmUgZnVuY3Rpb24gdG8gdXNlIGFzIGEgYmFzZSwgdHJ5IHRoYXRcblx0XHRcdFx0aWYgKGJhc2VmdW5jKSByZXR1cm4gYmFzZWZ1bmMuYXBwbHkobmFtZXNwYWNlLiQoZWwpLCBhcmdzKTtcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBvbmU7XG5cdFx0fSxcblx0XHRcblx0XHQvKipcblx0XHQgKiBBIHByb3h5IGlzIGEgZnVuY3Rpb24gYXR0YWNoZWQgdG8gYSBjYWxsYWJsZSBvYmplY3QgKGVpdGhlciB0aGUgYmFzZSBqUXVlcnkuZm4gb3IgYSBzdWJzcGFjZSBvYmplY3QpIHdoaWNoIGhhbmRsZXNcblx0XHQgKiBmaW5kaW5nIGFuZCBjYWxsaW5nIHRoZSBjb3JyZWN0IGZ1bmN0aW9uIGZvciBlYWNoIG1lbWJlciBvZiB0aGUgY3VycmVudCBqUXVlcnkgY29udGV4dFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbmFtZSBvZiB0aGUgZnVuY3Rpb24gYXMgcGFzc2VkIGluIHRoZSBjb25zdHJ1Y3Rpb24gb2JqZWN0XG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gYmFzZWZ1bmMgLSB0aGUgbm9uLWVudHdpbmUgZnVuY3Rpb24gdG8gdXNlIGFzIHRoZSBjYXRjaC1hbGwgZnVuY3Rpb24gYXQgdGhlIGJvdHRvbSBvZiB0aGUgc3RhY2tcblx0XHQgKi9cblx0XHRidWlsZF9wcm94eTogZnVuY3Rpb24obmFtZSwgYmFzZWZ1bmMpIHtcblx0XHRcdHZhciBvbmUgPSB0aGlzLm9uZShuYW1lLCAnZnVuYycsIGJhc2VmdW5jKTtcblx0XHRcdFxuXHRcdFx0dmFyIHByeHkgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHJ2LCBjdHggPSAkKHRoaXMpOyBcblx0XHRcdFx0XG5cdFx0XHRcdHZhciBpID0gY3R4Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKGktLSkgcnYgPSBvbmUoY3R4W2ldLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRyZXR1cm4gcnY7XG5cdFx0XHR9O1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gcHJ4eTtcblx0XHR9LFxuXHRcdFxuXHRcdGJpbmRfcHJveHk6IGZ1bmN0aW9uKHNlbGVjdG9yLCBuYW1lLCBmdW5jKSB7XG5cdFx0XHR2YXIgcnVsZWxpc3QgPSB0aGlzLnN0b3JlW25hbWVdIHx8ICh0aGlzLnN0b3JlW25hbWVdID0gJC5lbnR3aW5lLlJ1bGVMaXN0KCkpO1xuXHRcdFx0XG5cdFx0XHR2YXIgcnVsZSA9IHJ1bGVsaXN0LmFkZFJ1bGUoc2VsZWN0b3IsIG5hbWUpOyBydWxlLmZ1bmMgPSBmdW5jO1xuXHRcdFx0XG5cdFx0XHRpZiAoIXRoaXMuaW5qZWN0ZWUuaGFzT3duUHJvcGVydHkobmFtZSkgfHwgIXRoaXMuaW5qZWN0ZWVbbmFtZV0uaXNlbnR3aW5lbWV0aG9kKSB7XG5cdFx0XHRcdHRoaXMuaW5qZWN0ZWVbbmFtZV0gPSB0aGlzLmJ1aWxkX3Byb3h5KG5hbWUsIHRoaXMuaW5qZWN0ZWUuaGFzT3duUHJvcGVydHkobmFtZSkgPyB0aGlzLmluamVjdGVlW25hbWVdIDogbnVsbCk7XG5cdFx0XHRcdHRoaXMuaW5qZWN0ZWVbbmFtZV0uaXNlbnR3aW5lbWV0aG9kID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLmluamVjdGVlW25hbWVdLmlzZW50d2luZW1ldGhvZCkge1xuXHRcdFx0XHQkLmVudHdpbmUud2FybignV2FybmluZzogRW50d2luZSBmdW5jdGlvbiAnK25hbWUrJyBjbGFzaGVzIHdpdGggcmVndWxhciBqUXVlcnkgZnVuY3Rpb24gLSBlbnR3aW5lIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGNhbGxhYmxlIGRpcmVjdGx5IG9uIGpRdWVyeSBvYmplY3QnLCAkLmVudHdpbmUuV0FSTl9MRVZFTF9JTVBPUlRBTlQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XG5cdFx0YWRkOiBmdW5jdGlvbihzZWxlY3RvciwgZGF0YSkge1xuXHRcdFx0Ly8gRm9yIGV2ZXJ5IGl0ZW0gaW4gdGhlIGhhc2gsIHRyeSBldmVyIG1ldGhvZCBoYW5kbGVyLCB1bnRpbCBvbmUgcmV0dXJucyB0cnVlXG5cdFx0XHRmb3IgKHZhciBrIGluIGRhdGEpIHtcblx0XHRcdFx0dmFyIHYgPSBkYXRhW2tdO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChoYW5kbGVyc1tpXS5iaW5kICYmIGhhbmRsZXJzW2ldLmJpbmQuY2FsbCh0aGlzLCBzZWxlY3RvciwgaywgdikpIGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcblx0XHRoYXM6IGZ1bmN0aW9uKGN0eCwgbmFtZSkge1xuXHRcdFx0dmFyIHJ1bGVsaXN0ID0gdGhpcy5zdG9yZVtuYW1lXTtcblx0XHRcdGlmICghcnVsZWxpc3QpIHJldHVybiBmYWxzZTtcblx0XHRcdFxuXHRcdFx0LyogV2UgZ28gZm9yd2FyZCB0aGlzIHRpbWUsIHNpbmNlIGxvdyBzcGVjaWZpdHkgaXMgbGlrZWx5IHRvIGtub2NrIG91dCBhIGJ1bmNoIG9mIGVsZW1lbnRzIHF1aWNrbHkgKi9cblx0XHRcdGZvciAodmFyIGkgPSAwIDsgaSA8IHJ1bGVsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGN0eCA9IGN0eC5ub3QocnVsZWxpc3RbaV0uc2VsZWN0b3IpO1xuXHRcdFx0XHRpZiAoIWN0eC5sZW5ndGgpIHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSk7XG5cdFxuXHQvKipcblx0ICogQSBoYW5kbGVyIGlzIHNvbWUgamF2YXNjcmlwdCBjb2RlIHRoYXQgYWRkcyBzdXBwb3J0IGZvciBzb21lIHRpbWUgb2Yga2V5IC8gdmFsdWUgcGFpciBwYXNzZWQgaW4gdGhlIGhhc2ggdG8gdGhlIE5hbWVzcGFjZSBhZGQgbWV0aG9kLlxuXHQgKiBUaGUgZGVmYXVsdCBoYW5kbGVycyBwcm92aWRlZCAoYW5kIGluY2x1ZGVkIGJ5IGRlZmF1bHQpIGFyZSBldmVudCwgY3RvciBhbmQgcHJvcGVydGllc1xuXHQgKi9cblx0JC5lbnR3aW5lLk5hbWVzcGFjZS5hZGRIYW5kbGVyID0gZnVuY3Rpb24oaGFuZGxlcikge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoICYmIGhhbmRsZXJzW2ldLm9yZGVyIDwgaGFuZGxlci5vcmRlcjsgaSsrKSB7IC8qIFBhc3MgKi8gfVxuXHRcdGhhbmRsZXJzLnNwbGljZShpLCAwLCBoYW5kbGVyKTtcblx0fTtcblx0XG5cdCQuZW50d2luZS5OYW1lc3BhY2UuYWRkSGFuZGxlcih7XG5cdFx0b3JkZXI6IDUwLFxuXHRcdFxuXHRcdGJpbmQ6IGZ1bmN0aW9uKHNlbGVjdG9yLCBrLCB2KXtcblx0XHRcdGlmICgkLmlzRnVuY3Rpb24odikpIHtcblx0XHRcdFx0dGhpcy5iaW5kX3Byb3h5KHNlbGVjdG9yLCBrLCB2KTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHQkLmV4dGVuZCgkLmZuLCB7XG5cdFx0LyoqXG5cdFx0ICogTWFpbiBlbnR3aW5lIGZ1bmN0aW9uLiBVc2VkIGZvciBuZXcgZGVmaW5pdGlvbnMsIGNhbGxpbmcgaW50byBhIG5hbWVzcGFjZSAob3IgZm9yY2luZyB0aGUgYmFzZSBuYW1lc3BhY2UpIGFuZCBlbnRlcmluZyBhIHVzaW5nIGJsb2NrXG5cdFx0ICogXG5cdFx0ICovXG5cdFx0ZW50d2luZTogZnVuY3Rpb24oc3BhY2VuYW1lKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHQvKiBEb24ndCBhY3R1YWxseSB3b3JrIG91dCBzZWxlY3RvciB1bnRpbCB3ZSB0cnkgYW5kIGRlZmluZSBzb21ldGhpbmcgb24gaXQgLSB3ZSBtaWdodCBiZSBvcGVuaW5nIGEgbmFtZXNwYWNlIG9uIGFuIGZ1bmN0aW9uLXRyYXZlcmVzZWQgb2JqZWN0XG5cdFx0XHQgICB3aGljaCBoYXZlIG5vbi1zdGFuZGFyZCBzZWxlY3RvcnMgbGlrZSAucGFyZW50cyguZm9vKS5zbGljZSgwLDEpICovXG5cdFx0XHR2YXIgc2VsZWN0b3IgPSBudWxsOyAgXG5cdFx0XG5cdFx0XHQvKiBCeSBkZWZhdWx0IHdlIG9wZXJhdG9yIG9uIHRoZSBiYXNlIG5hbWVzcGFjZSAqL1xuXHRcdFx0dmFyIG5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuX19iYXNlIHx8ICQuZW50d2luZS5OYW1lc3BhY2UoKTtcblx0XHRcdFxuXHRcdFx0LyogSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nLCB0aGVuIGl0J3MgdGhlIG5hbWUgb2YgYSBuYW1lc3BhY2UuIExvb2sgaXQgdXAgKi9cblx0XHRcdGlmICh0eXBlb2Ygc3BhY2VuYW1lID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGlmIChzcGFjZW5hbWUuY2hhckF0KCcwJykgPT0gJy4nKSBzcGFjZW5hbWUgPSBzcGFjZW5hbWUuc3Vic3RyKDEpO1xuXHRcdFx0XHRpZiAoc3BhY2VuYW1lKSBuYW1lc3BhY2UgPSBuYW1lc3BhY2VzW3NwYWNlbmFtZV0gfHwgJC5lbnR3aW5lLk5hbWVzcGFjZShzcGFjZW5hbWUpO1xuXHRcdFx0XHRpPTE7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHQvKiBBbGwgcmVtYWluaW5nIGFyZ3VtZW50cyBzaG91bGQgZWl0aGVyIGJlIHVzaW5nIGJsb2NrcyBvciBkZWZpbml0aW9uIGhhc2hzICovXG5cdFx0XHR3aGlsZSAoaSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIHJlcyA9IGFyZ3VtZW50c1tpKytdO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uLCBjYWxsIGl0IC0gZWl0aGVyIGl0J3MgYSB1c2luZyBibG9jayBvciBpdCdzIGEgbmFtZXNwYWNlZCBlbnR3aW5lIGRlZmluaXRpb25cblx0XHRcdFx0aWYgKCQuaXNGdW5jdGlvbihyZXMpKSB7XG5cdFx0XHRcdFx0aWYgKHJlcy5sZW5ndGggIT0gMSkgJC5lbnR3aW5lLndhcm4oJ0Z1bmN0aW9uIGJsb2NrIGluc2lkZSBlbnR3aW5lIGRlZmluaXRpb24gZG9lcyBub3QgdGFrZSAkIGFyZ3VtZW50IHByb3Blcmx5JywgJC5lbnR3aW5lLldBUk5fTEVWRUxfSU1QT1JUQU5UKTtcblx0XHRcdFx0XHRyZXMgPSByZXMuY2FsbChuYW1lc3BhY2UuJCh0aGlzKSwgbmFtZXNwYWNlLiQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgZW50d2luZSBkZWZpbml0aW9uIGhhc2gsIGluamVjdCBpdCBpbnRvIG5hbWVzcGFjZVxuXHRcdFx0XHRpZiAocmVzKSB7XG5cdFx0XHRcdFx0aWYgKHNlbGVjdG9yID09PSBudWxsKSBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IgPyAkLnNlbGVjdG9yKHRoaXMuc2VsZWN0b3IpIDogZmFsc2U7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHNlbGVjdG9yKSBuYW1lc3BhY2UuYWRkKHNlbGVjdG9yLCByZXMpO1xuXHRcdFx0XHRcdGVsc2UgJC5lbnR3aW5lLndhcm4oJ0VudHdpbmUgYmxvY2sgZ2l2ZW4gdG8gZW50d2luZSBjYWxsIHdpdGhvdXQgc2VsZWN0b3IuIE1ha2Ugc3VyZSB5b3UgY2FsbCAkKHNlbGVjdG9yKS5lbnR3aW5lIHdoZW4gZGVmaW5pbmcgYmxvY2tzJywgJC5lbnR3aW5lLldBUk5fTEVWRUxfSU1QT1JUQU5UKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFxuXHRcdFx0LyogRmluYWxseSwgcmV0dXJuIHRoZSBqUXVlcnkgb2JqZWN0ICd0aGlzJyByZWZlcnMgdG8sIHdyYXBwZWQgaW4gdGhlIG5ldyBuYW1lc3BhY2UgKi9cblx0XHRcdHJldHVybiBuYW1lc3BhY2UuJCh0aGlzKTtcblx0XHR9LFxuXHRcdFxuXHRcdC8qKiBcblx0XHQgKiBDYWxscyB0aGUgbmV4dCBtb3N0IHNwZWNpZmljIHZlcnNpb24gb2YgdGhlIGN1cnJlbnQgZW50d2luZSBtZXRob2Rcblx0XHQgKi9cblx0XHRfc3VwZXI6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgcnYsIGkgPSB0aGlzLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0dmFyIGVsID0gdGhpc1swXTtcblx0XHRcdFx0cnYgPSBlbC5mKGVsLCBhcmd1bWVudHMsIGVsLmkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJ2O1xuXHRcdH1cblx0fSk7XG5cdFxufSkoalF1ZXJ5KTtcbjtcblxuXG4vKiBzcmMvZG9tZXZlbnRzL2pxdWVyeS5lbnR3aW5lLmRvbWV2ZW50cy5hZGRyZW0uanMgKi9cblxuKGZ1bmN0aW9uKCQpe1xuXG5cdC8vIEdldHMgYWxsIHRoZSBjaGlsZCBlbGVtZW50cyBvZiBhIHBhcnRpY3VsYXIgZWxlbWVudHMsIHN0b3JlcyBpdCBpbiBhbiBhcnJheVxuXHRmdW5jdGlvbiBnZXRFbGVtZW50cyhzdG9yZSwgb3JpZ2luYWwpIHtcblx0XHR2YXIgbm9kZSwgaSA9IHN0b3JlLmxlbmd0aCwgbmV4dCA9IG9yaWdpbmFsLmZpcnN0Q2hpbGQ7XG5cblx0XHR3aGlsZSAoKG5vZGUgPSBuZXh0KSkge1xuXHRcdFx0aWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHN0b3JlW2krK10gPSBub2RlO1xuXHRcdFx0bmV4dCA9IG5vZGUuZmlyc3RDaGlsZCB8fCBub2RlLm5leHRTaWJsaW5nO1xuXHRcdFx0d2hpbGUgKCFuZXh0ICYmIChub2RlID0gbm9kZS5wYXJlbnROb2RlKSAmJiBub2RlICE9PSBvcmlnaW5hbCkgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG5cdFx0fVxuXHR9XG5cblx0Ly8gVGhpcyBtaWdodCBiZSBmYXN0ZXI/IE9yIHNsb3dlcj8gQHRvZG86IGJlbmNobWFyay5cblx0ZnVuY3Rpb24gZ2V0RWxlbWVudHNBbHQoc3RvcmUsIG5vZGUpIHtcblx0XHRpZiAobm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSkge1xuXHRcdFx0dmFyIGVscyA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSwgbGVuID0gZWxzLmxlbmd0aCwgaSA9IDAsIGogPSBzdG9yZS5sZW5ndGg7XG5cdFx0XHRmb3IoOyBpIDwgbGVuOyBpKyssIGorKykge1xuXHRcdFx0XHRzdG9yZVtqXSA9IGVsc1tpXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAobm9kZS5jaGlsZE5vZGVzKSB7XG5cdFx0XHR2YXIgZWxzID0gbm9kZS5jaGlsZE5vZGVzLCBsZW4gPSBlbHMubGVuZ3RoLCBpID0gMDtcblx0XHRcdGZvcig7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRnZXRFbGVtZW50cyhzdG9yZSwgZWxzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgZG9udFRyaWdnZXIgPSBmYWxzZTtcblxuXHR2YXIgcGF0Y2hEb21NYW5pcENhbGxiYWNrID0gZnVuY3Rpb24ob3JpZ2luYWwpIHtcblx0XHR2YXIgcGF0Y2hlZCA9IGZ1bmN0aW9uKGVsZW0pe1xuXHRcdFx0dmFyIGFkZGVkID0gW107XG5cblx0XHRcdGlmICghZG9udFRyaWdnZXIpIHtcblx0XHRcdFx0aWYgKGVsZW0ubm9kZVR5cGUgPT0gMSkgYWRkZWRbYWRkZWQubGVuZ3RoXSA9IGVsZW07XG5cdFx0XHRcdGdldEVsZW1lbnRzKGFkZGVkLCBlbGVtKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHJ2ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHRcdFx0aWYgKCFkb250VHJpZ2dlciAmJiBhZGRlZC5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGV2ZW50ID0gJC5FdmVudCgnRW50d2luZUVsZW1lbnRzQWRkZWQnKTtcblx0XHRcdFx0ZXZlbnQudGFyZ2V0cyA9IGFkZGVkO1xuXHRcdFx0XHQkKGRvY3VtZW50KS50cmlnZ2VySGFuZGxlcihldmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBydjtcblx0XHR9XG5cdFx0cGF0Y2hlZC5wYXRjaGVkID0gdHJ1ZTtcblxuXHRcdHJldHVybiBwYXRjaGVkO1xuXHR9XG5cblx0dmFyIHZlcnNpb24gPSAkLnByb3RvdHlwZS5qcXVlcnkuc3BsaXQoJy4nKTtcblx0dmFyIGNhbGxiYWNrSWR4ID0gKHZlcnNpb25bMF0gPiAxIHx8IHZlcnNpb25bMV0gPj0gMTAgPyAxIDogMik7XG5cblx0Ly8gTW9ua2V5IHBhdGNoICQuZm4uZG9tTWFuaXAgdG8gY2F0Y2ggYWxsIHJlZ3VsYXIgalF1ZXJ5IGFkZCBlbGVtZW50IGNhbGxzXG5cdHZhciBfZG9tTWFuaXAgPSAkLnByb3RvdHlwZS5kb21NYW5pcDtcblx0JC5wcm90b3R5cGUuZG9tTWFuaXAgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIWFyZ3VtZW50c1tjYWxsYmFja0lkeF0ucGF0Y2hlZCkgYXJndW1lbnRzW2NhbGxiYWNrSWR4XSA9IHBhdGNoRG9tTWFuaXBDYWxsYmFjayhhcmd1bWVudHNbY2FsbGJhY2tJZHhdKTtcblx0XHRyZXR1cm4gX2RvbU1hbmlwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH1cblxuXHQvLyBNb25rZXkgcGF0Y2ggJC5mbi5odG1sIHRvIGNhdGNoIHdoZW4galF1ZXJ5IHNldHMgaW5uZXJIVE1MIGRpcmVjdGx5XG5cdHZhciBfaHRtbCA9ICQucHJvdG90eXBlLmh0bWw7XG5cdCQucHJvdG90eXBlLmh0bWwgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gX2h0bWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHRcdGRvbnRUcmlnZ2VyID0gdHJ1ZTtcblx0XHR2YXIgcmVzID0gX2h0bWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRkb250VHJpZ2dlciA9IGZhbHNlO1xuXG5cdFx0dmFyIGFkZGVkID0gW107XG5cblx0XHR2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXHRcdGZvciAoOyBpIDwgbGVuZ3RoOyBpKysgKSBnZXRFbGVtZW50cyhhZGRlZCwgdGhpc1tpXSk7XG5cblx0XHR2YXIgZXZlbnQgPSAkLkV2ZW50KCdFbnR3aW5lRWxlbWVudHNBZGRlZCcpO1xuXHRcdGV2ZW50LnRhcmdldHMgPSBhZGRlZDtcblx0XHQkKGRvY3VtZW50KS50cmlnZ2VySGFuZGxlcihldmVudCk7XG5cblx0XHRyZXR1cm4gcmVzO1xuXHR9XG5cblx0Ly8gSWYgdGhpcyBpcyB0cnVlLCB3ZSd2ZSBjaGFuZ2VkIHNvbWV0aGluZyB0byBjYWxsIGNsZWFuRGF0YSBzbyB0aGF0IHdlIGNhbiBjYXRjaCB0aGUgZWxlbWVudHMsIGJ1dCB3ZSBkb24ndFxuXHQvLyB3YW50IHRvIGNhbGwgdGhlIHVuZGVybHlpbmcgb3JpZ2luYWwgJC5jbGVhbkRhdGFcblx0dmFyIHN1cHJlc3NBY3R1YWxDbGVhbiA9IGZhbHNlO1xuXG5cdC8vIE1vbmtleSBwYXRjaCAkLmNsZWFuRGF0YSB0byBjYXRjaCBlbGVtZW50IHJlbW92YWxcblx0dmFyIF9jbGVhbkRhdGEgPSAkLmNsZWFuRGF0YTtcblx0JC5jbGVhbkRhdGEgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0Ly8gQnkgZGVmYXVsdCB3ZSBjYW4gYXNzdW1lIGFsbCBlbGVtZW50cyBwYXNzZWQgYXJlIGxlZ2l0aW1hdGVseSBiZWluZyByZW1vdmVlZFxuXHRcdHZhciByZW1vdmVkID0gZWxlbXM7XG5cblx0XHQvLyBFeGNlcHQgaWYgd2UncmUgc3VwcmVzc2luZyBhY3R1YWwgY2xlYW4gLSB3ZSBtaWdodCBiZSBiZWluZyBjYWxsZWQgYnkgalF1ZXJ5IFwiYmVpbmcgY2FyZWZ1bFwiIGFib3V0IGRldGFjaGluZyBub2Rlc1xuXHRcdC8vIGJlZm9yZSBhdHRhY2hpbmcgdGhlbS4gU28gd2UgbmVlZCB0byBjaGVjayB0byBtYWtlIHN1cmUgdGhlc2Ugbm9kZXMgY3VycmVudGx5IGFyZSBpbiBhIGRvY3VtZW50XG5cdFx0aWYgKHN1cHJlc3NBY3R1YWxDbGVhbikge1xuXHRcdFx0dmFyIGkgPSAwLCBsZW4gPSBlbGVtcy5sZW5ndGgsIHJlbW92ZWQgPSBbXSwgcmkgPSAwO1xuXHRcdFx0Zm9yKDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBub2RlID0gZWxlbXNbaV0sIGN1cnJlbnQgPSBub2RlO1xuXHRcdFx0XHR3aGlsZSAoY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZSkge1xuXHRcdFx0XHRcdGlmIChjdXJyZW50Lm5vZGVUeXBlID09IDkpIHsgcmVtb3ZlZFtyaSsrXSA9IG5vZGU7IGJyZWFrOyB9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocmVtb3ZlZC5sZW5ndGgpIHtcblx0XHRcdHZhciBldmVudCA9ICQuRXZlbnQoJ0VudHdpbmVFbGVtZW50c1JlbW92ZWQnKTtcblx0XHRcdGV2ZW50LnRhcmdldHMgPSByZW1vdmVkO1xuXHRcdFx0JChkb2N1bWVudCkudHJpZ2dlckhhbmRsZXIoZXZlbnQpO1xuXHRcdH1cblxuXHRcdGlmICghc3VwcmVzc0FjdHVhbENsZWFuKSBfY2xlYW5EYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH1cblxuXHQvLyBNb25rZXkgcGF0Y2ggJC5mbi5yZW1vdmUgdG8gY2F0Y2ggd2hlbiB3ZSdyZSBqdXN0IGRldGFjaGluZyAoa2VlcGRhdGEgPT0gMSkgLVxuXHQvLyB0aGlzIGRvZXNuJ3QgY2FsbCBjbGVhbkRhdGEgYnV0IHN0aWxsIG5lZWRzIHRvIHRyaWdnZXIgZXZlbnRcblx0dmFyIF9yZW1vdmUgPSAkLnByb3RvdHlwZS5yZW1vdmU7XG5cdCQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBrZWVwZGF0YSkge1xuXHRcdHN1cHJlc3NBY3R1YWxDbGVhbiA9IGtlZXBkYXRhO1xuXHRcdHZhciBydiA9IF9yZW1vdmUuY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG5cdFx0c3VwcmVzc0FjdHVhbENsZWFuID0gZmFsc2U7XG5cdFx0cmV0dXJuIHJ2O1xuXHR9XG5cblx0Ly8gQW5kIG9uIERPTSByZWFkeSwgdHJpZ2dlciBhZGRpbmcgb25jZVxuXHQkKGZ1bmN0aW9uKCl7XG5cdFx0dmFyIGFkZGVkID0gW107IGdldEVsZW1lbnRzKGFkZGVkLCBkb2N1bWVudCk7XG5cblx0XHR2YXIgZXZlbnQgPSAkLkV2ZW50KCdFbnR3aW5lRWxlbWVudHNBZGRlZCcpO1xuXHRcdGV2ZW50LnRhcmdldHMgPSBhZGRlZDtcblx0XHQkKGRvY3VtZW50KS50cmlnZ2VySGFuZGxlcihldmVudCk7XG5cdH0pO1xuXG5cbn0pKGpRdWVyeSk7O1xuXG5cbi8qIHNyYy9kb21ldmVudHMvanF1ZXJ5LmVudHdpbmUuZG9tZXZlbnRzLm1heWJlY2hhbmdlZC5qcyAqL1xuXG4oZnVuY3Rpb24oJCl7XG5cblx0LyoqIFV0aWxpdHkgZnVuY3Rpb24gdG8gbW9ua2V5LXBhdGNoIGEgalF1ZXJ5IG1ldGhvZCAqL1xuXHR2YXIgbW9ua2V5ID0gZnVuY3Rpb24oIC8qIG1ldGhvZCwgbWV0aG9kLCAuLi4uLCBwYXRjaCAqLyl7XG5cdFx0dmFyIG1ldGhvZHMgPSAkLm1ha2VBcnJheShhcmd1bWVudHMpO1xuXHRcdHZhciBwYXRjaCA9IG1ldGhvZHMucG9wKCk7XG5cblx0XHQkLmVhY2gobWV0aG9kcywgZnVuY3Rpb24oaSwgbWV0aG9kKXtcblx0XHRcdHZhciBvbGQgPSAkLmZuW21ldGhvZF07XG5cblx0XHRcdCQuZm5bbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSAkLm1ha2VBcnJheShhcmd1bWVudHMpO1xuXG5cdFx0XHRcdHZhciBydiA9IG9sZC5hcHBseShzZWxmLCBhcmdzKTtcblx0XHRcdFx0cGF0Y2guYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0XHRcdHJldHVybiBydjtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8qKiBXaGF0IHRvIGNhbGwgdG8gcnVuIGEgZnVuY3Rpb24gJ3Nvb24nLiBOb3JtYWxseSBzZXRUaW1lb3V0LCBidXQgZm9yIHN5bmNyb25vdXMgbW9kZSB3ZSBvdmVycmlkZSBzbyBzb29uID09PSBub3cgKi9cblx0dmFyIHJ1blNvb24gPSB3aW5kb3cuc2V0VGltZW91dDtcblx0XG5cdC8qKiBUaGUgdGltZXIgaGFuZGxlIGZvciB0aGUgYXN5bmNyb25vdXMgbWF0Y2hpbmcgY2FsbCAqL1xuXHR2YXIgQ2hhbmdlRGV0YWlscyA9IEJhc2UuZXh0ZW5kKHtcblxuXHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5nbG9iYWwgPSBmYWxzZTtcblx0XHRcdHRoaXMuYXR0cnMgPSB7fTtcblx0XHRcdHRoaXMuY2xhc3NlcyA9IHt9O1xuXHRcdH0sXG5cblx0XHQvKiogRmlyZSB0aGUgY2hhbmdlIGV2ZW50LiBPbmx5IGZpcmVzIG9uIHRoZSBkb2N1bWVudCBub2RlLCBzbyBiaW5kIHRvIHRoYXQgKi9cblx0XHR0cmlnZ2VyRXZlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gSWYgd2UncmUgbm90IHRoZSBhY3RpdmUgY2hhbmdlcyBpbnN0YW5jZSBhbnkgbW9yZSwgZG9uJ3QgdHJpZ2dlclxuXHRcdFx0aWYgKGNoYW5nZXMgIT0gdGhpcykgcmV0dXJuO1xuXG5cdFx0XHQvLyBDYW5jZWwgYW55IHBlbmRpbmcgdGltZW91dCAoaWYgd2UncmUgZGlyZWN0bHkgY2FsbGVkIGluIHRoZSBtZWFuIHRpbWUpXG5cdFx0XHRpZiAodGhpcy5jaGVja19pZCkgY2xlYXJUaW1lb3V0KHRoaXMuY2hlY2tfaWQpO1xuXG5cdFx0XHQvLyBSZXNldCB0aGUgZ2xvYmFsIGNoYW5nZXMgb2JqZWN0IHRvIGJlIGEgbmV3IGluc3RhbmNlIChkbyBiZWZvcmUgdHJpZ2dlciwgaW4gY2FzZSB0cmlnZ2VyIGZpcmVzIGNoYW5nZXMgaXRzZWxmKVxuXHRcdFx0Y2hhbmdlcyA9IG5ldyBDaGFuZ2VEZXRhaWxzKCk7XG5cblx0XHRcdC8vIEZpcmUgZXZlbnRcblx0XHRcdCQoZG9jdW1lbnQpLnRyaWdnZXJIYW5kbGVyKFwiRW50d2luZVN1YnRyZWVNYXliZUNoYW5nZWRcIiwgW3RoaXNdKTtcblx0XHR9LFxuXG5cdFx0Y2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIXRoaXMuY2hlY2tfaWQpIHtcblx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0XHR0aGlzLmNoZWNrX2lkID0gcnVuU29vbihmdW5jdGlvbigpeyBzZWxmLmNoZWNrX2lkID0gbnVsbDsgc2VsZi50cmlnZ2VyRXZlbnQoKTsgfSwgMTApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRhZGRBbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMuZ2xvYmFsKSByZXR1cm4gdGhpczsgLy8gSWYgd2UndmUgYWxyZWFkeSBmbGFnZ2VkIGFzIGEgZ2xvYmFsIGNoYW5nZSwganVzdCBza2lwXG5cblx0XHRcdHRoaXMuZ2xvYmFsID0gdHJ1ZTtcblx0XHRcdHRoaXMuY2hhbmdlZCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGFkZFN1YnRyZWU6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZEFsbCgpO1xuXHRcdH0sXG5cblx0XHQvKiBGb3Igbm93IHdlIGRvbid0IGRvIHRoaXMuIEl0J3MgZXhwZW5zaXZlLCBhbmQganF1ZXJ5LmVudHdpbmUuY3RvcnMgZG9lc24ndCB1c2UgdGhpcyBpbmZvcm1hdGlvbiBhbnl3YXkgKi9cblx0XHRhZGRTdWJ0cmVlRnV0dXJlOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRpZiAodGhpcy5nbG9iYWwpIHJldHVybiB0aGlzOyAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGZsYWdnZWQgYXMgYSBnbG9iYWwgY2hhbmdlLCBqdXN0IHNraXBcblxuXHRcdFx0dGhpcy5zdWJ0cmVlID0gdGhpcy5zdWJ0cmVlID8gdGhpcy5zdWJ0cmVlLmFkZChub2RlKSA6ICQobm9kZSk7XG5cdFx0XHR0aGlzLmNoYW5nZWQoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRhZGRBdHRyOiBmdW5jdGlvbihhdHRyLCBub2RlKSB7XG5cdFx0XHRpZiAodGhpcy5nbG9iYWwpIHJldHVybiB0aGlzO1xuXG5cdFx0XHR0aGlzLmF0dHJzW2F0dHJdID0gKGF0dHIgaW4gdGhpcy5hdHRycykgPyB0aGlzLmF0dHJzW2F0dHJdLmFkZChub2RlKSA6ICQobm9kZSk7XG5cdFx0XHR0aGlzLmNoYW5nZWQoKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRhZGRDbGFzczogZnVuY3Rpb24oa2xhc3MsIG5vZGUpIHtcblx0XHRcdGlmICh0aGlzLmdsb2JhbCkgcmV0dXJuIHRoaXM7XG5cblx0XHRcdHRoaXMuY2xhc3Nlc1trbGFzc10gPSAoa2xhc3MgaW4gdGhpcy5jbGFzc2VzKSA/IHRoaXMuY2xhc3Nlc1trbGFzc10uYWRkKG5vZGUpIDogJChub2RlKTtcblx0XHRcdHRoaXMuY2hhbmdlZCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHR9KTtcblxuXHR2YXIgY2hhbmdlcyA9IG5ldyBDaGFuZ2VEZXRhaWxzKCk7XG5cblx0Ly8gRWxlbWVudCBhZGQgZXZlbnRzIHRyaWdnZXIgbWF5YmVjaGFuZ2VkIGV2ZW50c1xuXG5cdCQoZG9jdW1lbnQpLmJpbmQoJ0VudHdpbmVFbGVtZW50c0FkZGVkJywgZnVuY3Rpb24oZSl7IGNoYW5nZXMuYWRkU3VidHJlZShlLnRhcmdldHMpOyB9KTtcblxuXHQvLyBFbGVtZW50IHJlbW92ZSBldmVudHMgdHJpZ2dlciBtYXliZWNoYW5nZWQgZXZlbnRzLCBidXQgd2UgaGF2ZSB0byB3YWl0IHVudGlsIGFmdGVyIHRoZSBub2RlcyBhcmUgYWN0dWFsbHkgcmVtb3ZlZFxuXHQvLyAoRW50d2luZUVsZW1lbnRzUmVtb3ZlZCBmaXJlcyBfanVzdCBiZWZvcmVfIHRoZSBlbGVtZW50cyBhcmUgcmVtb3ZlZCBzbyB0aGUgZGF0YSBzdGlsbCBleGlzdHMpLCBlc3BlY2lhbGx5IGluIHN5bmNyb25vdXMgbW9kZVxuXG5cdHZhciByZW1vdmVkID0gbnVsbDtcblx0JChkb2N1bWVudCkuYmluZCgnRW50d2luZUVsZW1lbnRzUmVtb3ZlZCcsIGZ1bmN0aW9uKGUpeyByZW1vdmVkID0gZS50YXJnZXRzOyB9KTtcblxuXHRtb25rZXkoJ3JlbW92ZScsICdodG1sJywgJ2VtcHR5JywgZnVuY3Rpb24oKXtcblx0XHR2YXIgc3VidHJlZSA9IHJlbW92ZWQ7IHJlbW92ZWQgPSBudWxsO1xuXHRcdGlmIChzdWJ0cmVlKSBjaGFuZ2VzLmFkZFN1YnRyZWUoc3VidHJlZSk7XG5cdH0pO1xuXG5cdC8vIFdlIGFsc28gbmVlZCB0byBrbm93IHdoZW4gYW4gYXR0cmlidXRlLCBjbGFzcywgZXRjIGNoYW5nZXMuIFBhdGNoIHRoZSByZWxldmFudCBqUXVlcnkgbWV0aG9kcyBoZXJlXG5cblx0bW9ua2V5KCdyZW1vdmVBdHRyJywgZnVuY3Rpb24oYXR0cil7XG5cdFx0Y2hhbmdlcy5hZGRBdHRyKGF0dHIsIHRoaXMpO1xuXHR9KTtcblxuXHRtb25rZXkoJ2FkZENsYXNzJywgJ3JlbW92ZUNsYXNzJywgJ3RvZ2dsZUNsYXNzJywgZnVuY3Rpb24oa2xhc3Mpe1xuXHRcdGlmICh0eXBlb2Yga2xhc3MgPT0gJ3N0cmluZycpIGNoYW5nZXMuYWRkQ2xhc3Moa2xhc3MsIHRoaXMpO1xuXHR9KTtcblxuXHRtb25rZXkoJ2F0dHInLCBmdW5jdGlvbihhLCBiKXtcblx0XHRpZiAoYiAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBhID09ICdzdHJpbmcnKSBjaGFuZ2VzLmFkZEF0dHIoYSwgdGhpcyk7XG5cdFx0ZWxzZSBpZiAodHlwZW9mIGEgIT0gJ3N0cmluZycpIHsgZm9yICh2YXIgayBpbiBhKSBjaGFuZ2VzLmFkZEF0dHIoaywgdGhpcyk7IH1cblx0fSk7XG5cblx0Ly8gQWRkIHNvbWUgdXNlZnVsbCBhY2Nlc3NvcnMgdG8gJC5lbnR3aW5lXG5cblx0JC5leHRlbmQoJC5lbnR3aW5lLCB7XG5cdFx0LyoqXG5cdFx0ICogTWFrZSBvbm1hdGNoIGFuZCBvbnVubWF0Y2ggd29yayBpbiBzeW5jaHJvbm91cyBtb2RlIC0gdGhhdCBpcywgbmV3IGVsZW1lbnRzIHdpbGwgYmUgZGV0ZWN0ZWQgaW1tZWRpYXRlbHkgYWZ0ZXJcblx0XHQgKiB0aGUgRE9NIG1hbmlwdWxhdGlvbiB0aGF0IG1hZGUgdGhlbSBtYXRjaC4gVGhpcyBpcyBvbmx5IHJlYWxseSB1c2VmdWwgZm9yIGR1cmluZyB0ZXN0aW5nLCBzaW5jZSBpdCdzIHByZXR0eSBzbG93XG5cdFx0ICogKG90aGVyd2lzZSB3ZSdkIG1ha2UgaXQgdGhlIGRlZmF1bHQpLlxuXHRcdCAqL1xuXHRcdHN5bmNocm9ub3VzX21vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKGNoYW5nZXMgJiYgY2hhbmdlcy5jaGVja19pZCkgY2xlYXJUaW1lb3V0KGNoYW5nZXMuY2hlY2tfaWQpO1xuXHRcdFx0Y2hhbmdlcyA9IG5ldyBDaGFuZ2VEZXRhaWxzKCk7XG5cblx0XHRcdHJ1blNvb24gPSBmdW5jdGlvbihmdW5jLCBkZWxheSl7IGZ1bmMuY2FsbCh0aGlzKTsgcmV0dXJuIG51bGw7IH07XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRyaWdnZXIgb25tYXRjaCBhbmQgb251bm1hdGNoIG5vdyAtIHVzZWZ1bGwgZm9yIGFmdGVyIERPTSBtYW5pcHVsYXRpb24gYnkgbWV0aG9kcyBvdGhlciB0aGFuIHRocm91Z2ggalF1ZXJ5LlxuXHRcdCAqIENhbGxlZCBhdXRvbWF0aWNhbGx5IG9uIGRvY3VtZW50LnJlYWR5XG5cdFx0ICovXG5cdFx0dHJpZ2dlck1hdGNoaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdGNoYW5nZXMuYWRkQWxsKCk7XG5cdFx0fVxuXHR9KTtcblxufSkoalF1ZXJ5KTs7XG5cblxuLyogc3JjL2pxdWVyeS5lbnR3aW5lLmV2ZW50cy5qcyAqL1xuXG4oZnVuY3Rpb24oJCkge1x0XG5cblx0LyoqIFRha2VuIGZyb20galF1ZXJ5IDEuNS4yIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAqL1xuXHRpZiAoJC5zdXBwb3J0LmNoYW5nZUJ1YmJsZXMgPT0gdW5kZWZpbmVkKSB7XG5cdFx0JC5zdXBwb3J0LmNoYW5nZUJ1YmJsZXMgPSB0cnVlO1xuXG5cdFx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRldmVudE5hbWUgPSBcIm9uY2hhbmdlXCI7XG5cblx0XHRpZiAoZWwuYXR0YWNoRXZlbnQpIHtcblx0XHRcdHZhciBpc1N1cHBvcnRlZCA9IChldmVudE5hbWUgaW4gZWwpO1xuXHRcdFx0aWYgKCFpc1N1cHBvcnRlZCkge1xuXHRcdFx0XHRlbC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCBcInJldHVybjtcIik7XG5cdFx0XHRcdGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsW2V2ZW50TmFtZV0gPT09IFwiZnVuY3Rpb25cIjtcblx0XHRcdH1cblxuXHRcdFx0JC5zdXBwb3J0LmNoYW5nZUJ1YmJsZXMgPSBpc1N1cHBvcnRlZDtcblx0XHR9XG5cdH1cblxuXHQvKiBSZXR1cm4gdHJ1ZSBpZiBub2RlIGIgaXMgdGhlIHNhbWUgYXMsIG9yIGlzIGEgZGVzY2VuZGFudCBvZiwgbm9kZSBhICovXG5cdGlmIChkb2N1bWVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuXHRcdHZhciBpc19vcl9jb250YWlucyA9IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhICYmIGIgJiYgKGEgPT0gYiB8fCAhIShhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpICYgMTYpKTtcblx0XHR9O1xuXHR9XG5cdGVsc2Uge1xuXHRcdHZhciBpc19vcl9jb250YWlucyA9IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhICYmIGIgJiYgKGEgPT0gYiB8fCAoYS5jb250YWlucyA/IGEuY29udGFpbnMoYikgOiB0cnVlKSk7XG5cdFx0fTtcblx0fVxuXG5cdC8qIEFkZCB0aGUgbWV0aG9kcyB0byBoYW5kbGUgZXZlbnQgYmluZGluZyB0byB0aGUgTmFtZXNwYWNlIGNsYXNzICovXG5cdCQuZW50d2luZS5OYW1lc3BhY2UuYWRkTWV0aG9kcyh7XG5cdFx0YnVpbGRfZXZlbnRfcHJveHk6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHZhciBvbmUgPSB0aGlzLm9uZShuYW1lLCAnZnVuYycpO1xuXHRcdFx0XG5cdFx0XHR2YXIgcHJ4eSA9IGZ1bmN0aW9uKGUsIGRhdGEpIHtcblx0XHRcdFx0Ly8gRm9yIGV2ZW50cyB0aGF0IGRvIG5vdCBidWJibGUgd2UgbWFudWFsbHkgdHJpZ2dlciBkZWxlZ2F0aW9uIChzZWUgZGVsZWdhdGVfc3VibWl0IGJlbG93KSBcblx0XHRcdFx0Ly8gSWYgdGhpcyBldmVudCBpcyBhIG1hbnVhbCB0cmlnZ2VyLCB0aGUgZXZlbnQgd2UgYWN0dWFsbHkgd2FudCB0byBidWJibGUgaXMgYXR0YWNoZWQgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcGFzc2VkIGV2ZW50XG5cdFx0XHRcdGUgPSBlLmRlbGVnYXRlZEV2ZW50IHx8IGU7XG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgZWwgPSBlLnRhcmdldDtcblx0XHRcdFx0d2hpbGUgKGVsICYmIGVsLm5vZGVUeXBlID09IDEgJiYgIWUuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuXHRcdFx0XHRcdHZhciByZXQgPSBvbmUoZWwsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0aWYgKHJldCAhPT0gdW5kZWZpbmVkKSBlLnJlc3VsdCA9IHJldDtcblx0XHRcdFx0XHRpZiAocmV0ID09PSBmYWxzZSkgeyBlLnByZXZlbnREZWZhdWx0KCk7IGUuc3RvcFByb3BhZ2F0aW9uKCk7IH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRlbCA9IGVsLnBhcmVudE5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdHJldHVybiBwcnh5O1xuXHRcdH0sXG5cdFx0XG5cdFx0YnVpbGRfbW91c2VlbnRlcmxlYXZlX3Byb3h5OiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHR2YXIgb25lID0gdGhpcy5vbmUobmFtZSwgJ2Z1bmMnKTtcblx0XHRcdFxuXHRcdFx0dmFyIHByeHkgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdHZhciBlbCA9IGUudGFyZ2V0O1xuXHRcdFx0XHR2YXIgcmVsID0gZS5yZWxhdGVkVGFyZ2V0O1xuXHRcdFx0XHRcblx0XHRcdFx0d2hpbGUgKGVsICYmIGVsLm5vZGVUeXBlID09IDEgJiYgIWUuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuXHRcdFx0XHRcdC8qIFdlIGtub3cgZWwgY29udGFpbmVkIHRhcmdldC4gSWYgaXQgYWxzbyBjb250YWlucyByZWxhdGVkVGFyZ2V0IHRoZW4gd2UgZGlkbid0IG1vdXNlZW50ZXIgLyBsZWF2ZS4gV2hhdCdzIG1vcmUsIGV2ZXJ5IGFuY2VzdG9yIHdpbGwgYWxzb1xuXHRcdFx0XHRcdGNvbnRhbiBlbCBhbmQgcmVsLCBhbmQgc28gd2UgY2FuIGp1c3Qgc3RvcCBidWJibGluZyAqL1xuXHRcdFx0XHRcdGlmIChpc19vcl9jb250YWlucyhlbCwgcmVsKSkgYnJlYWs7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dmFyIHJldCA9IG9uZShlbCwgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRpZiAocmV0ICE9PSB1bmRlZmluZWQpIGUucmVzdWx0ID0gcmV0O1xuXHRcdFx0XHRcdGlmIChyZXQgPT09IGZhbHNlKSB7IGUucHJldmVudERlZmF1bHQoKTsgZS5zdG9wUHJvcGFnYXRpb24oKTsgfVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGVsID0gZWwucGFyZW50Tm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHByeHk7XG5cdFx0fSxcblx0XHRcblx0XHRidWlsZF9jaGFuZ2VfcHJveHk6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHZhciBvbmUgPSB0aGlzLm9uZShuYW1lLCAnZnVuYycpO1xuXG5cdFx0XHQvKlxuXHRcdFx0VGhpcyBjaGFuZ2UgYnViYmxlIGVtdWxhdGlvbiBjb2RlIGlzIHRha2VuIG1vc3RseSBmcm9tIGpRdWVyeSAxLjYgLSB1bmZvcnR1bmF0ZWx5IHdlIGNhbid0IGVhc2lseSByZXVzZSBhbnkgb2Zcblx0XHRcdGl0IHdpdGhvdXQgZHVwbGljYXRpb24sIHNvIHdlJ2xsIGhhdmUgdG8gcmUtbWlncmF0ZSBhbnkgYnVnZml4ZXNcblx0XHRcdCovXG5cblx0XHRcdC8vIEdldCB0aGUgdmFsdWUgb2YgYW4gaXRlbS4gSXNuJ3Qgc3VwcG9zZWQgdG8gYmUgaW50ZXJwcmV0YWJsZSwganVzdCBzdGFibGUgZm9yIHNvbWUgdmFsdWUsIGFuZCBkaWZmZXJlbnRcblx0XHRcdC8vIG9uY2UgdGhlIHZhbHVlIGNoYW5nZXNcblx0XHRcdHZhciBnZXRWYWwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHR5cGUgPSBlbGVtLnR5cGUsIHZhbCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0aWYgKHR5cGUgPT09IFwicmFkaW9cIiB8fCB0eXBlID09PSBcImNoZWNrYm94XCIpIHtcblx0XHRcdFx0XHR2YWwgPSBlbGVtLmNoZWNrZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCJzZWxlY3QtbXVsdGlwbGVcIikge1xuXHRcdFx0XHRcdHZhbCA9IFwiXCI7XG5cdFx0XHRcdFx0aWYgKGVsZW0uc2VsZWN0ZWRJbmRleCA+IC0xKSB7XG5cdFx0XHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKGVsZW0ub3B0aW9ucywgZnVuY3Rpb24oZWxlbSl7IHJldHVybiBlbGVtLnNlbGVjdGVkOyB9KS5qb2luKFwiLVwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoalF1ZXJ5Lm5vZGVOYW1lKGVsZW0sIFwic2VsZWN0XCIpKSB7XG5cdFx0XHRcdFx0dmFsID0gZWxlbS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbDtcblx0XHRcdH07XG5cblx0XHRcdC8vIFRlc3QgaWYgYSBub2RlIG5hbWUgaXMgYSBmb3JtIGlucHV0XG5cdFx0XHR2YXIgcmZvcm1FbGVtcyA9IC9eKD86dGV4dGFyZWF8aW5wdXR8c2VsZWN0KSQvaTtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgdGhpcyBldmVudCBpcyBhIGNoYW5nZSwgYW5kIGJ1YmJsZSB0aGUgY2hhbmdlIGV2ZW50IGlmIGl0IGlzXG5cdFx0XHR2YXIgdGVzdENoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBlLnRhcmdldCwgZGF0YSwgdmFsO1xuXG5cdFx0XHRcdGlmICghcmZvcm1FbGVtcy50ZXN0KGVsZW0ubm9kZU5hbWUpIHx8IGVsZW0ucmVhZE9ubHkpIHJldHVybjtcblxuXHRcdFx0XHRkYXRhID0galF1ZXJ5LmRhdGEoZWxlbSwgXCJfZW50d2luZV9jaGFuZ2VfZGF0YVwiKTtcblx0XHRcdFx0dmFsID0gZ2V0VmFsKGVsZW0pO1xuXG5cdFx0XHRcdC8vIHRoZSBjdXJyZW50IGRhdGEgd2lsbCBiZSBhbHNvIHJldHJpZXZlZCBieSBiZWZvcmVhY3RpdmF0ZVxuXHRcdFx0XHRpZiAoZS50eXBlICE9PSBcImZvY3Vzb3V0XCIgfHwgZWxlbS50eXBlICE9PSBcInJhZGlvXCIpIHtcblx0XHRcdFx0XHRqUXVlcnkuZGF0YShlbGVtLCBcIl9lbnR3aW5lX2NoYW5nZV9kYXRhXCIsIHZhbCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZGF0YSA9PT0gdW5kZWZpbmVkIHx8IHZhbCA9PT0gZGF0YSkgcmV0dXJuO1xuXG5cdFx0XHRcdGlmIChkYXRhICE9IG51bGwgfHwgdmFsKSB7XG5cdFx0XHRcdFx0ZS50eXBlID0gXCJjaGFuZ2VcIjtcblxuXHRcdFx0XHRcdHdoaWxlIChlbGVtICYmIGVsZW0ubm9kZVR5cGUgPT0gMSAmJiAhZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG5cdFx0XHRcdFx0XHR2YXIgcmV0ID0gb25lKGVsZW0sIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHRpZiAocmV0ICE9PSB1bmRlZmluZWQpIGUucmVzdWx0ID0gcmV0O1xuXHRcdFx0XHRcdFx0aWYgKHJldCA9PT0gZmFsc2UpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBlLnN0b3BQcm9wYWdhdGlvbigpOyB9XG5cblx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBUaGUgYWN0dWFsIHByb3h5IC0gcmVzcG9uZHMgdG8gc2V2ZXJhbCBldmVudHMsIHNvbWUgb2Ygd2hpY2ggdHJpZ2VyIGEgY2hhbmdlIGNoZWNrLCBzb21lXG5cdFx0XHQvLyBvZiB3aGljaCBqdXN0IHN0b3JlIHRoZSB2YWx1ZSBmb3IgZnV0dXJlIGNoYW5nZSBjaGVja3Ncblx0XHRcdHZhciBwcnh5ID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0XHR2YXIgZXZlbnQgPSBlLnR5cGUsIGVsZW0gPSBlLnRhcmdldCwgdHlwZSA9IGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgPyBlbGVtLnR5cGUgOiBcIlwiO1xuXG5cdFx0XHRcdHN3aXRjaCAoZXZlbnQpIHtcblx0XHRcdFx0XHRjYXNlICdmb2N1c291dCc6XG5cdFx0XHRcdFx0Y2FzZSAnYmVmb3JlZGVhY3RpdmF0ZSc6XG5cdFx0XHRcdFx0XHR0ZXN0Q2hhbmdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2NsaWNrJzpcblx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJyYWRpb1wiIHx8IHR5cGUgPT09IFwiY2hlY2tib3hcIiB8fCBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwic2VsZWN0XCIgKSApIHtcblx0XHRcdFx0XHRcdFx0dGVzdENoYW5nZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHQvLyBDaGFuZ2UgaGFzIHRvIGJlIGNhbGxlZCBiZWZvcmUgc3VibWl0XG5cdFx0XHRcdFx0Ly8gS2V5ZG93biB3aWxsIGJlIGNhbGxlZCBiZWZvcmUga2V5cHJlc3MsIHdoaWNoIGlzIHVzZWQgaW4gc3VibWl0LWV2ZW50IGRlbGVnYXRpb25cblx0XHRcdFx0XHRjYXNlICdrZXlkb3duJzpcblx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0KGUua2V5Q29kZSA9PT0gMTMgJiYgIWpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0ZXh0YXJlYVwiICkgKSB8fFxuXHRcdFx0XHRcdFx0XHQoZS5rZXlDb2RlID09PSAzMiAmJiAodHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IHR5cGUgPT09IFwicmFkaW9cIikpIHx8XG5cdFx0XHRcdFx0XHRcdHR5cGUgPT09IFwic2VsZWN0LW11bHRpcGxlXCJcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHR0ZXN0Q2hhbmdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdC8vIEJlZm9yZWFjdGl2YXRlIGhhcHBlbnMgYWxzbyBiZWZvcmUgdGhlIHByZXZpb3VzIGVsZW1lbnQgaXMgYmx1cnJlZFxuXHRcdFx0XHRcdC8vIHdpdGggdGhpcyBldmVudCB5b3UgY2FuJ3QgdHJpZ2dlciBhIGNoYW5nZSBldmVudCwgYnV0IHlvdSBjYW4gc3RvcmVcblx0XHRcdFx0XHQvLyBpbmZvcm1hdGlvblxuXHRcdFx0XHRcdGNhc2UgJ2ZvY3VzaW4nOlxuXHRcdFx0XHRcdGNhc2UgJ2JlZm9yZWFjdGl2YXRlJzpcblx0XHRcdFx0XHRcdGpRdWVyeS5kYXRhKCBlbGVtLCBcIl9lbnR3aW5lX2NoYW5nZV9kYXRhXCIsIGdldFZhbChlbGVtKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByeHk7XG5cdFx0fSxcblx0XHRcblx0XHRiaW5kX2V2ZW50OiBmdW5jdGlvbihzZWxlY3RvciwgbmFtZSwgZnVuYywgZXZlbnQpIHtcblx0XHRcdHZhciBmdW5jcyA9IHRoaXMuc3RvcmVbbmFtZV0gfHwgKHRoaXMuc3RvcmVbbmFtZV0gPSAkLmVudHdpbmUuUnVsZUxpc3QoKSkgO1xuXHRcdFx0dmFyIHByb3hpZXMgPSBmdW5jcy5wcm94aWVzIHx8IChmdW5jcy5wcm94aWVzID0ge30pO1xuXHRcdFx0XG5cdFx0XHR2YXIgcnVsZSA9IGZ1bmNzLmFkZFJ1bGUoc2VsZWN0b3IsIG5hbWUpOyBydWxlLmZ1bmMgPSBmdW5jO1xuXHRcdFx0XG5cdFx0XHRpZiAoIXByb3hpZXNbbmFtZV0pIHtcblx0XHRcdFx0c3dpdGNoIChuYW1lKSB7XG5cdFx0XHRcdFx0Y2FzZSAnb25tb3VzZWVudGVyJzpcblx0XHRcdFx0XHRcdHByb3hpZXNbbmFtZV0gPSB0aGlzLmJ1aWxkX21vdXNlZW50ZXJsZWF2ZV9wcm94eShuYW1lKTtcblx0XHRcdFx0XHRcdGV2ZW50ID0gJ21vdXNlb3Zlcic7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdvbm1vdXNlbGVhdmUnOlxuXHRcdFx0XHRcdFx0cHJveGllc1tuYW1lXSA9IHRoaXMuYnVpbGRfbW91c2VlbnRlcmxlYXZlX3Byb3h5KG5hbWUpO1xuXHRcdFx0XHRcdFx0ZXZlbnQgPSAnbW91c2VvdXQnO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnb25jaGFuZ2UnOlxuXHRcdFx0XHRcdFx0aWYgKCEkLnN1cHBvcnQuY2hhbmdlQnViYmxlcykge1xuXHRcdFx0XHRcdFx0XHRwcm94aWVzW25hbWVdID0gdGhpcy5idWlsZF9jaGFuZ2VfcHJveHkobmFtZSk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50ID0gJ2NsaWNrIGtleWRvd24gZm9jdXNpbiBmb2N1c291dCBiZWZvcmVhY3RpdmF0ZSBiZWZvcmVkZWFjdGl2YXRlJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ29uc3VibWl0Jzpcblx0XHRcdFx0XHRcdGV2ZW50ID0gJ2RlbGVnYXRlZFN1Ym1pdCc7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdvbmZvY3VzJzpcblx0XHRcdFx0XHRjYXNlICdvbmJsdXInOlxuXHRcdFx0XHRcdFx0JC5lbnR3aW5lLndhcm4oJ0V2ZW50ICcrZXZlbnQrJyBub3Qgc3VwcG9ydGVkIC0gdXNpbmcgZm9jdXNpbiAvIGZvY3Vzb3V0IGluc3RlYWQnLCAkLmVudHdpbmUuV0FSTl9MRVZFTF9JTVBPUlRBTlQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBJZiBub25lIG9mIHRoZSBzcGVjaWFsIGhhbmRsZXJzIGNyZWF0ZWQgYSBwcm94eSwgdXNlIHRoZSBnZW5lcmljIHByb3h5XG5cdFx0XHRcdGlmICghcHJveGllc1tuYW1lXSkgcHJveGllc1tuYW1lXSA9IHRoaXMuYnVpbGRfZXZlbnRfcHJveHkobmFtZSk7XG5cblx0XHRcdFx0JChkb2N1bWVudCkuYmluZChldmVudC5yZXBsYWNlKC8oXFxzK3wkKS9nLCAnLmVudHdpbmUkMScpLCBwcm94aWVzW25hbWVdKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXHRcblx0JC5lbnR3aW5lLk5hbWVzcGFjZS5hZGRIYW5kbGVyKHtcblx0XHRvcmRlcjogNDAsXG5cdFx0XG5cdFx0YmluZDogZnVuY3Rpb24oc2VsZWN0b3IsIGssIHYpe1xuXHRcdFx0dmFyIG1hdGNoLCBldmVudDtcblx0XHRcdGlmICgkLmlzRnVuY3Rpb24odikgJiYgKG1hdGNoID0gay5tYXRjaCgvXm9uKC4qKS8pKSkge1xuXHRcdFx0XHRldmVudCA9IG1hdGNoWzFdO1xuXHRcdFx0XHR0aGlzLmJpbmRfZXZlbnQoc2VsZWN0b3IsIGssIHYsIGV2ZW50KTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblx0XG5cdC8vIEZpbmQgYWxsIGZvcm1zIGFuZCBiaW5kIG9uc3VibWl0IHRvIHRyaWdnZXIgb24gdGhlIGRvY3VtZW50IHRvby4gXG5cdC8vIFRoaXMgaXMgdGhlIG9ubHkgZXZlbnQgdGhhdCBjYW4ndCBiZSBncmFiYmVkIHZpYSBkZWxlZ2F0aW9uXG5cdFxuXHR2YXIgZGVsZWdhdGVfc3VibWl0ID0gZnVuY3Rpb24oZSwgZGF0YSl7XG5cdFx0dmFyIGRlbGVnYXRpb25FdmVudCA9ICQuRXZlbnQoJ2RlbGVnYXRlZFN1Ym1pdCcpOyBkZWxlZ2F0aW9uRXZlbnQuZGVsZWdhdGVkRXZlbnQgPSBlO1xuXHRcdHJldHVybiAkKGRvY3VtZW50KS50cmlnZ2VyKGRlbGVnYXRpb25FdmVudCwgZGF0YSk7IFxuXHR9O1xuXG5cdCQoZG9jdW1lbnQpLmJpbmQoJ0VudHdpbmVFbGVtZW50c0FkZGVkJywgZnVuY3Rpb24oZSl7XG5cdFx0dmFyIGZvcm1zID0gJChlLnRhcmdldHMpLmZpbHRlcignZm9ybScpO1xuXHRcdGlmICghZm9ybXMubGVuZ3RoKSByZXR1cm47XG5cblx0XHRmb3Jtcy5iaW5kKCdzdWJtaXQuZW50d2luZV9kZWxlZ2F0ZV9zdWJtaXQnLCBkZWxlZ2F0ZV9zdWJtaXQpO1xuXHR9KTtcblxufSkoalF1ZXJ5KTtcblx0O1xuXG5cbi8qIHNyYy9qcXVlcnkuZW50d2luZS5ldmVudGNhcHR1cmUuanMgKi9cblxuKGZ1bmN0aW9uKCQpIHtcblxuXHQkLmVudHdpbmUuTmFtZXNwYWNlLmFkZE1ldGhvZHMoe1xuXHRcdGJpbmRfY2FwdHVyZTogZnVuY3Rpb24oc2VsZWN0b3IsIGV2ZW50LCBuYW1lLCBjYXB0dXJlKSB7XG5cdFx0XHR2YXIgc3RvcmUgID0gdGhpcy5jYXB0dXJlcyB8fCAodGhpcy5jYXB0dXJlcyA9IHt9KTtcblx0XHRcdHZhciBydWxlbGlzdHMgPSBzdG9yZVtldmVudF0gfHwgKHN0b3JlW2V2ZW50XSA9IHt9KTtcblx0XHRcdHZhciBydWxlbGlzdCA9IHJ1bGVsaXN0c1tuYW1lXSB8fCAocnVsZWxpc3RzW25hbWVdID0gJC5lbnR3aW5lLlJ1bGVMaXN0KCkpO1xuXG5cdFx0XHR2YXIgcnVsZSA9IHJ1bGVsaXN0LmFkZFJ1bGUoc2VsZWN0b3IsIGV2ZW50KTtcblx0XHRcdHJ1bGUuaGFuZGxlciA9IG5hbWU7XG5cblx0XHRcdHRoaXMuYmluZF9wcm94eShzZWxlY3RvciwgbmFtZSwgY2FwdHVyZSk7XG5cdFx0fVxuXHR9KTtcblxuXHR2YXIgYmluZGluZ3MgPSAkLmVudHdpbmUuY2FwdHVyZV9iaW5kaW5ncyA9IHt9O1xuXG5cdHZhciBldmVudF9wcm94eSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciBuYW1lc3BhY2UsIGNhcHR1cmVsaXN0cywgZm9yZXZlbnQsIGNhcHR1cmVsaXN0LCBydWxlLCBoYW5kbGVyLCBzZWw7XG5cblx0XHRcdGZvciAodmFyIGsgaW4gJC5lbnR3aW5lLm5hbWVzcGFjZXMpIHtcblx0XHRcdFx0bmFtZXNwYWNlID0gJC5lbnR3aW5lLm5hbWVzcGFjZXNba107XG5cdFx0XHRcdGNhcHR1cmVsaXN0cyA9IG5hbWVzcGFjZS5jYXB0dXJlcztcblxuXHRcdFx0XHRpZiAoY2FwdHVyZWxpc3RzICYmIChmb3JldmVudCA9IGNhcHR1cmVsaXN0c1tldmVudF0pKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgayBpbiBmb3JldmVudCkge1xuXHRcdFx0XHRcdFx0dmFyIGNhcHR1cmVsaXN0ID0gZm9yZXZlbnRba107XG5cdFx0XHRcdFx0XHR2YXIgdHJpZ2dlcmVkID0gbmFtZXNwYWNlLiQoW10pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdGVwcGluZyB0aHJvdWdoIGVhY2ggc2VsZWN0b3IgZnJvbSBtb3N0IHRvIGxlYXN0IHNwZWNpZmljXG5cdFx0XHRcdFx0XHR2YXIgaiA9IGNhcHR1cmVsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlIChqLS0pIHtcblx0XHRcdFx0XHRcdFx0cnVsZSA9IGNhcHR1cmVsaXN0W2pdO1xuXHRcdFx0XHRcdFx0XHRoYW5kbGVyID0gcnVsZS5oYW5kbGVyO1xuXHRcdFx0XHRcdFx0XHRzZWwgPSBydWxlLnNlbGVjdG9yLnNlbGVjdG9yO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBtYXRjaGluZyA9IG5hbWVzcGFjZS4kKHNlbCkubm90KHRyaWdnZXJlZCk7XG5cdFx0XHRcdFx0XHRcdG1hdGNoaW5nW2hhbmRsZXJdLmFwcGx5KG1hdGNoaW5nLCBhcmd1bWVudHMpO1xuXG5cdFx0XHRcdFx0XHRcdHRyaWdnZXJlZCA9IHRyaWdnZXJlZC5hZGQobWF0Y2hpbmcpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHR2YXIgc2VsZWN0b3JfcHJveHkgPSBmdW5jdGlvbihzZWxlY3RvciwgaGFuZGxlciwgaW5jbHVkZWNoaWxkcmVuKSB7XG5cdFx0dmFyIG1hdGNoZXIgPSAkLnNlbGVjdG9yKHNlbGVjdG9yKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oZSl7XG5cdFx0XHRpZiAobWF0Y2hlci5tYXRjaGVzKGUudGFyZ2V0KSkgcmV0dXJuIGhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIGRvY3VtZW50X3Byb3h5ID0gZnVuY3Rpb24oc2VsZWN0b3IsIGhhbmRsZXIsIGluY2x1ZGVjaGlsZHJlbikge1xuXHRcdHJldHVybiBmdW5jdGlvbihlKXtcblx0XHRcdGlmIChlLnRhcmdldCA9PT0gZG9jdW1lbnQpIHJldHVybiBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciB3aW5kb3dfcHJveHkgPSBmdW5jdGlvbihzZWxlY3RvciwgaGFuZGxlciwgaW5jbHVkZWNoaWxkcmVuKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGUpe1xuXHRcdFx0aWYgKGUudGFyZ2V0ID09PSB3aW5kb3cpIHJldHVybiBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBwcm9wZXJ0eV9wcm94eSA9IGZ1bmN0aW9uKHByb3BlcnR5LCBoYW5kbGVyLCBpbmNsdWRlY2hpbGRyZW4pIHtcblx0XHR2YXIgbWF0Y2hlcjtcblxuXHRcdHJldHVybiBmdW5jdGlvbihlKXtcblx0XHRcdHZhciBtYXRjaCA9IHRoaXNbJ2dldCcrcHJvcGVydHldKCk7XG5cblx0XHRcdGlmICh0eXBlb2YobWF0Y2gpID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHZhciBtYXRjaGVyID0gKG1hdGNoZXIgJiYgbWF0Y2ggPT0gbWF0Y2hlci5zZWxlY3RvcikgPyBtYXRjaGVyIDogJC5zZWxlY3RvcihtYXRjaCk7XG5cdFx0XHRcdGlmIChtYXRjaGVyLm1hdGNoZXMoZS50YXJnZXQpKSByZXR1cm4gaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmICgkLmluQXJyYXkoZS50YXJnZXQsIG1hdGNoKSAhPT0gLTEpIHJldHVybiBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdCQuZW50d2luZS5OYW1lc3BhY2UuYWRkSGFuZGxlcih7XG5cdFx0b3JkZXI6IDEwLFxuXG5cdFx0YmluZDogZnVuY3Rpb24oc2VsZWN0b3IsIGssIHYpIHtcblx0XHRcdHZhciBtYXRjaDtcblx0XHRcdGlmICgkLmlzUGxhaW5PYmplY3QodikgJiYgKG1hdGNoID0gay5tYXRjaCgvXmZyb21cXHMqKC4qKS8pKSkge1xuXHRcdFx0XHR2YXIgZnJvbSA9IG1hdGNoWzFdO1xuXHRcdFx0XHR2YXIgcHJveHlHZW47XG5cblx0XHRcdFx0aWYgKGZyb20ubWF0Y2goL1teXFx3XS8pKSBwcm94eUdlbiA9IHNlbGVjdG9yX3Byb3h5O1xuXHRcdFx0XHRlbHNlIGlmIChmcm9tID09ICdXaW5kb3cnIHx8IGZyb20gPT0gJ3dpbmRvdycpIHByb3h5R2VuID0gd2luZG93X3Byb3h5O1xuXHRcdFx0XHRlbHNlIGlmIChmcm9tID09ICdEb2N1bWVudCcgfHwgZnJvbSA9PSAnZG9jdW1lbnQnKSBwcm94eUdlbiA9IGRvY3VtZW50X3Byb3h5O1xuXHRcdFx0XHRlbHNlIHByb3h5R2VuID0gcHJvcGVydHlfcHJveHk7XG5cblx0XHRcdFx0Zm9yICh2YXIgb25ldmVudCBpbiB2KSB7XG5cdFx0XHRcdFx0dmFyIGhhbmRsZXIgPSB2W29uZXZlbnRdO1xuXHRcdFx0XHRcdG1hdGNoID0gb25ldmVudC5tYXRjaCgvXm9uKC4qKS8pO1xuXHRcdFx0XHRcdHZhciBldmVudCA9IG1hdGNoWzFdO1xuXG5cdFx0XHRcdFx0dGhpcy5iaW5kX2NhcHR1cmUoc2VsZWN0b3IsIGV2ZW50LCBrICsgJ18nICsgZXZlbnQsIHByb3h5R2VuKGZyb20sIGhhbmRsZXIpKTtcblxuXHRcdFx0XHRcdGlmICghYmluZGluZ3NbZXZlbnRdKSB7XG5cdFx0XHRcdFx0XHR2YXIgbmFtZXNwYWNlZCA9IGV2ZW50LnJlcGxhY2UoLyhcXHMrfCQpL2csICcuZW50d2luZSQxJyk7XG5cdFx0XHRcdFx0XHRiaW5kaW5nc1tldmVudF0gPSBldmVudF9wcm94eShldmVudCk7XG5cblx0XHRcdFx0XHRcdCQocHJveHlHZW4gPT0gd2luZG93X3Byb3h5ID8gd2luZG93IDogZG9jdW1lbnQpLmJpbmQobmFtZXNwYWNlZCwgYmluZGluZ3NbZXZlbnRdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG59KShqUXVlcnkpO1xuO1xuXG5cbi8qIHNyYy9qcXVlcnkuZW50d2luZS5jdG9ycy5qcyAqL1xuXG4oZnVuY3Rpb24oJCkge1x0XG5cblx0LyogQWRkIHRoZSBtZXRob2RzIHRvIGhhbmRsZSBjb25zdHJ1Y3RvciAmIGRlc3RydWN0b3IgYmluZGluZyB0byB0aGUgTmFtZXNwYWNlIGNsYXNzICovXG5cdCQuZW50d2luZS5OYW1lc3BhY2UuYWRkTWV0aG9kcyh7XG5cdFx0YmluZF9jb25kZXNjOiBmdW5jdGlvbihzZWxlY3RvciwgbmFtZSwgZnVuYykge1xuXHRcdFx0dmFyIGN0b3JzID0gdGhpcy5zdG9yZS5jdG9ycyB8fCAodGhpcy5zdG9yZS5jdG9ycyA9ICQuZW50d2luZS5SdWxlTGlzdCgpKSA7XG5cdFx0XHRcblx0XHRcdHZhciBydWxlO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAgOyBpIDwgY3RvcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGN0b3JzW2ldLnNlbGVjdG9yLnNlbGVjdG9yID09IHNlbGVjdG9yLnNlbGVjdG9yKSB7XG5cdFx0XHRcdFx0cnVsZSA9IGN0b3JzW2ldOyBicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFydWxlKSB7XG5cdFx0XHRcdHJ1bGUgPSBjdG9ycy5hZGRSdWxlKHNlbGVjdG9yLCAnY3RvcnMnKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cnVsZVtuYW1lXSA9IGZ1bmM7XG5cdFx0XHRcblx0XHRcdGlmICghY3RvcnNbbmFtZSsncHJveHknXSkge1xuXHRcdFx0XHR2YXIgb25lID0gdGhpcy5vbmUoJ2N0b3JzJywgbmFtZSk7XG5cdFx0XHRcdHZhciBuYW1lc3BhY2UgPSB0aGlzO1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIHByb3h5ID0gZnVuY3Rpb24oZWxzLCBpLCBmdW5jKSB7XG5cdFx0XHRcdFx0dmFyIGogPSBlbHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlIChqLS0pIHtcblx0XHRcdFx0XHRcdHZhciBlbCA9IGVsc1tqXTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0dmFyIHRtcF9pID0gZWwuaSwgdG1wX2YgPSBlbC5mO1xuXHRcdFx0XHRcdFx0ZWwuaSA9IGk7IGVsLmYgPSBvbmU7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdHRyeSAgICAgIHsgZnVuYy5jYWxsKG5hbWVzcGFjZS4kKGVsKSk7IH1cblx0XHRcdFx0XHRcdGNhdGNoKGUpIHsgJC5lbnR3aW5lLndhcm5fZXhjZXB0aW9uKG5hbWUsIGVsLCBlKTsgfSBcblx0XHRcdFx0XHRcdGZpbmFsbHkgIHsgZWwuaSA9IHRtcF9pOyBlbC5mID0gdG1wX2Y7IH1cdFx0XHRcdFx0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRcblx0XHRcdFx0Y3RvcnNbbmFtZSsncHJveHknXSA9IHByb3h5O1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdFxuXHQkLmVudHdpbmUuTmFtZXNwYWNlLmFkZEhhbmRsZXIoe1xuXHRcdG9yZGVyOiAzMCxcblx0XHRcblx0XHRiaW5kOiBmdW5jdGlvbihzZWxlY3Rvciwgaywgdikge1xuXHRcdFx0aWYgKCQuaXNGdW5jdGlvbih2KSAmJiAoayA9PSAnb25tYXRjaCcgfHwgayA9PSAnb251bm1hdGNoJykpIHtcblx0XHRcdFx0Ly8gV2hlbiB3ZSBhZGQgbmV3IG1hdGNoZXJzIHdlIG5lZWQgdG8gdHJpZ2dlciBhIGZ1bGwgZ2xvYmFsIHJlY2FsYyBvbmNlLCByZWdhcmRsZXNzIG9mIHRoZSBET00gY2hhbmdlcyB0aGF0IHRyaWdnZXJlZCB0aGUgZXZlbnRcblx0XHRcdFx0dGhpcy5tYXRjaGVyc0RpcnR5ID0gdHJ1ZTtcblxuXHRcdFx0XHR0aGlzLmJpbmRfY29uZGVzYyhzZWxlY3Rvciwgaywgdik7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIEZpbmRzIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBub3cgbWF0Y2ggYSBkaWZmZXJlbnQgcnVsZSAob3IgaGF2ZSBiZWVuIHJlbW92ZWQpIGFuZCBjYWxsIG9ubWF0Y2ggb24gb251bm1hdGNoIGFzIGFwcHJvcHJpYXRlXG5cdCAqIFxuXHQgKiBCZWNhdXNlIHRoaXMgaGFzIHRvIHNjYW4gdGhlIERPTSwgYW5kIGlzIHRoZXJlZm9yZSBmYWlybHkgc2xvdywgdGhpcyBpcyBub3JtYWxseSB0cmlnZ2VyZWQgb2ZmIGEgc2hvcnQgdGltZW91dCwgc28gdGhhdFxuXHQgKiBhIHNlcmllcyBvZiBET00gbWFuaXB1bGF0aW9ucyB3aWxsIG9ubHkgdHJpZ2dlciB0aGlzIG9uY2UuXG5cdCAqIFxuXHQgKiBUaGUgZG93bnNpZGUgb2YgdGhpcyBpcyB0aGF0IHRoaW5ncyBsaWtlOlxuXHQgKiAgICQoJyNmb28nKS5hZGRDbGFzcygndGFicycpOyAkKCcjZm9vJykudGFiRnVuY3Rpb25CYXIoKTtcblx0ICogd29uJ3Qgd29yay5cblx0ICovXG5cdCQoZG9jdW1lbnQpLmJpbmQoJ0VudHdpbmVTdWJ0cmVlTWF5YmVDaGFuZ2VkJywgZnVuY3Rpb24oZSwgY2hhbmdlcyl7XG5cdFx0Ly8gdmFyIHN0YXJ0ID0gKG5ldyBEYXRlKS5nZXRUaW1lKCk7XG5cblx0XHQvLyBGb3IgZXZlcnkgbmFtZXNwYWNlXG5cdFx0Zm9yICh2YXIgayBpbiAkLmVudHdpbmUubmFtZXNwYWNlcykge1xuXHRcdFx0dmFyIG5hbWVzcGFjZSA9ICQuZW50d2luZS5uYW1lc3BhY2VzW2tdO1xuXG5cdFx0XHQvLyBUaGF0IGhhcyBjb25zdHJ1Y3RvcnMgb3IgZGVzdHJ1Y3RvcnNcblx0XHRcdHZhciBjdG9ycyA9IG5hbWVzcGFjZS5zdG9yZS5jdG9ycztcblx0XHRcdGlmIChjdG9ycykge1xuXHRcdFx0XG5cdFx0XHRcdC8vIEtlZXAgYSByZWNvcmQgb2YgZWxlbWVudHMgdGhhdCBoYXZlIG1hdGNoZWQgc29tZSBwcmV2aW91cyBtb3JlIHNwZWNpZmljIHJ1bGUuXG5cdFx0XHRcdC8vIE5vdCB0aGF0IHdlIF9kb24ndF8gYWN0dWFsbHkgZG8gdGhhdCB1bnRpbCB0aGlzIGlzIG5lZWRlZC4gSWYgbWF0Y2hlZCBpcyBudWxsLCBpdCdzIG5vdCBiZWVuIGNhbGN1bGF0ZWQgeWV0LlxuXHRcdFx0XHQvLyBXZSBhbHNvIGtlZXAgdHJhY2sgb2YgYW55IGVsZW1lbnRzIHRoYXQgaGF2ZSBuZXdseSBiZWVuIHRha2VuIG9yIHJlbGVhc2VkIGJ5IGEgc3BlY2lmaWMgcnVsZVxuXHRcdFx0XHR2YXIgbWF0Y2hlZCA9IG51bGwsIHRha2VuID0gJChbXSksIHJlbGVhc2VkID0gJChbXSk7XG5cblx0XHRcdFx0Ly8gVXBkYXRlcyBtYXRjaGVkIHRvIGNvbnRhaW4gYWxsIHRoZSBwcmV2aW91c2x5IG1hdGNoZWQgZWxlbWVudHMgYXMgaWYgd2UnZCBiZWVuIGtlZXBpbmcgdHJhY2sgYWxsIGFsb25nXG5cdFx0XHRcdHZhciBjYWxjbWF0Y2hlZCA9IGZ1bmN0aW9uKGope1xuXHRcdFx0XHRcdGlmIChtYXRjaGVkICE9PSBudWxsKSByZXR1cm47XG5cdFx0XHRcdFx0bWF0Y2hlZCA9ICQoW10pO1xuXG5cdFx0XHRcdFx0dmFyIGNhY2hlLCBrID0gY3RvcnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgoLS1rKSA+IGopIHtcblx0XHRcdFx0XHRcdGlmIChjYWNoZSA9IGN0b3JzW2tdLmNhY2hlKSBtYXRjaGVkID0gbWF0Y2hlZC5hZGQoY2FjaGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNvbWUgZGVjbGFyZWQgdmFyaWFibGVzIHVzZWQgaW4gdGhlIGxvb3Bcblx0XHRcdFx0dmFyIGFkZCwgcmVtLCByZXMsIHJ1bGUsIHNlbCwgY3RvciwgZHRvciwgZnVsbDtcblxuXHRcdFx0XHQvLyBTdGVwcGluZyB0aHJvdWdoIGVhY2ggc2VsZWN0b3IgZnJvbSBtb3N0IHRvIGxlYXN0IHNwZWNpZmljXG5cdFx0XHRcdHZhciBqID0gY3RvcnMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoai0tKSB7XG5cdFx0XHRcdFx0Ly8gQnVpbGQgc29tZSBxdWljay1hY2Nlc3MgdmFyaWFibGVzXG5cdFx0XHRcdFx0cnVsZSA9IGN0b3JzW2pdO1xuXHRcdFx0XHRcdHNlbCA9IHJ1bGUuc2VsZWN0b3Iuc2VsZWN0b3I7XG5cdFx0XHRcdFx0Y3RvciA9IHJ1bGUub25tYXRjaDsgXG5cdFx0XHRcdFx0ZHRvciA9IHJ1bGUub251bm1hdGNoO1xuXG5cdFx0XHRcdFx0Lypcblx0XHRcdFx0XHRcdFJ1bGUuY2FjaGUgbWlnaHQgYmUgc3RhbGUgb3IgZnJlc2guIEl0J2xsIGJlIHN0YWxlIGlmXG5cdFx0XHRcdFx0ICAgLSBzb21lIG1vcmUgc3BlY2lmaWMgc2VsZWN0b3Igbm93IGhhcyBzb21lIG9mIHJ1bGUuY2FjaGUgaW4gaXRcblx0XHRcdFx0XHRcdC0gc29tZSBjaGFuZ2UgaGFzIGhhcHBlbmVkIHRoYXQgbWVhbnMgbmV3IGVsZW1lbnRzIG1hdGNoIHRoaXMgc2VsZWN0b3Igbm93XG5cdFx0XHRcdFx0XHQtIHNvbWUgY2hhbmdlIGhhcyBoYXBwZW5lZCB0aGF0IG1lYW5zIGVsZW1lbnRzIG5vIGxvbmdlciBtYXRjaCB0aGlzIHNlbGVjdG9yXG5cblx0XHRcdFx0XHRcdFRoZSBmaXJzdCB3ZSBjYW4ganVzdCBjb21wYXJlIHJ1bGVzLmNhY2hlIHdpdGggbWF0Y2hlZCwgcmVtb3ZpbmcgYW55dGhpbmcgdGhhdCdzIHRoZXJlIGFscmVhZHkuXG5cdFx0XHRcdFx0Ki9cblxuXHRcdFx0XHRcdC8vIFJlc2V0IHRoZSBcImVsZW1lbnRzIHRoYXQgbWF0Y2ggdGhpcyBzZWxlY3RvciBhbmQgbm8gbW9yZSBzcGVjaWZpYyBzZWxlY3RvciB3aXRoIGFuIG9ubWF0Y2ggcnVsZVwiIHRvIG51bGwuXG5cdFx0XHRcdFx0Ly8gU3RheWluZyBudWxsIG1lYW5zIHRoaXMgc2VsZWN0b3IgaXMgZnJlc2guXG5cdFx0XHRcdFx0cmVzID0gbnVsbDtcblxuXHRcdFx0XHRcdC8vIElmIHRoaXMgZ2V0cyBjaGFuZ2VkIHRvIHRydWUsIGl0J3MgdG9vIGhhcmQgdG8gZG8gYSBkZWx0YSB1cGRhdGUsIHNvIGRvIGEgZnVsbCB1cGRhdGVcblx0XHRcdFx0XHRmdWxsID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAobmFtZXNwYWNlLm1hdGNoZXJzRGlydHkgfHwgY2hhbmdlcy5nbG9iYWwpIHtcblx0XHRcdFx0XHRcdC8vIEZvciBub3csIGp1c3QgZmFsbCBiYWNrIHRvIG9sZCB2ZXJzaW9uLiBXZSBuZWVkIHRvIGRvIHNvbWV0aGluZyBsaWtlIGNoYW5nZWQuU3VidHJlZS5maW5kKCcqJykuYW5kU2VsZigpLmZpbHRlcihzZWwpLCBidXQgdGhhdCdzIF93YXlfIHNsb3dlciBvbiBtb2Rlcm4gYnJvd3NlcnMgdGhhbiB0aGUgYmVsb3dcblx0XHRcdFx0XHRcdGZ1bGwgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IGRlYWwgd2l0aCBhdHRyaWJ1dGVzIHlldCwgc28gYW55IGF0dHJpYnV0ZSBjaGFuZ2UgbWVhbnMgd2UgbmVlZCB0byBkbyBhIGZ1bGwgcmVjYWxjXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBrIGluIGNoYW5nZXMuYXR0cnMpIHtcdGZ1bGwgPSB0cnVlOyBicmVhazsgfVxuXG5cdFx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdFx0IElmIGEgY2xhc3MgY2hhbmdlcywgYnV0IGl0IGlzbid0IGxpc3RlZCBpbiBvdXIgc2VsZWN0b3IsIHdlIGRvbid0IGNhcmUgLSB0aGUgY2hhbmdlIGNvdWxkbid0IGFmZmVjdCB3aGV0aGVyIG9yIG5vdCBhbnkgZWxlbWVudCBtYXRjaGVzXG5cblx0XHRcdFx0XHRcdCBJZiBpdCBpcyBsaXN0ZWQgb24gb3VyIHNlbGVjdG9yXG5cdFx0XHRcdFx0XHRcdC0gSWYgaXQgaXMgb24gdGhlIGRpcmVjdCBtYXRjaCBwYXJ0LCBpdCBjb3VsZCBoYXZlIGFkZGVkIG9yIHJlbW92ZWQgdGhlIG5vZGUgaXQgY2hhbmdlZCBvblxuXHRcdFx0XHRcdFx0XHQtIElmIGl0IGlzIG9uIHRoZSBjb250ZXh0IHBhcnQsIGl0IGNvdWxkIGhhdmUgYWRkZWQgb3IgcmVtb3ZlZCBhbnkgbm9kZSB0aGF0IHdlcmUgcHJldmlvdXNseSBpbmNsdWRlZCBvciBleGNsdWRlZCBiZWNhdXNlIG9mIGEgbWF0Y2ggb3IgZmFpbHVyZSB0byBtYXRjaCB3aXRoIHRoZSBjb250ZXh0IHJlcXVpcmVkIG9uIHRoYXQgbm9kZVxuXHRcdFx0XHRcdFx0XHQtIE5PVEU6IEl0IG1pZ2h0IGJlIG9uIF9ib3RoX1xuXHRcdFx0XHRcdFx0ICovXG5cblx0XHRcdFx0XHRcdHZhciBtZXRob2QgPSBydWxlLnNlbGVjdG9yLmFmZmVjdGVkQnkoY2hhbmdlcyk7XG5cblx0XHRcdFx0XHRcdGlmIChtZXRob2QuY2xhc3Nlcy5jb250ZXh0KSB7XG5cdFx0XHRcdFx0XHRcdGZ1bGwgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGsgaW4gbWV0aG9kLmNsYXNzZXMuZGlyZWN0KSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsY21hdGNoZWQoaik7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJlY2hlY2sgPSBjaGFuZ2VzLmNsYXNzZXNba10ubm90KG1hdGNoZWQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHJlcyA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzID0gcnVsZS5jYWNoZSA/IHJ1bGUuY2FjaGUubm90KHRha2VuKS5hZGQocmVsZWFzZWQuZmlsdGVyKHNlbCkpIDogJChbXSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0cmVzID0gcmVzLm5vdChyZWNoZWNrKS5hZGQocmVjaGVjay5maWx0ZXIoc2VsKSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZnVsbCkge1xuXHRcdFx0XHRcdFx0Y2FsY21hdGNoZWQoaik7XG5cdFx0XHRcdFx0XHRyZXMgPSAkKHNlbCkubm90KG1hdGNoZWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGlmICghcmVzKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFdlIHdlcmVuJ3Qgc3RhbGUgYmVjYXVzZSBvZiBhbnkgY2hhbmdlcyB0byB0aGUgRE9NIHRoYXQgYWZmZWN0ZWQgdGhpcyBzZWxlY3RvciwgYnV0IG1vcmUgc3BlY2lmaWNcblx0XHRcdFx0XHRcdFx0Ly8gb25tYXRjaGVzIG1pZ2h0IGhhdmUgY2F1c2VkIHN0YWxlLW5lc3NcblxuXHRcdFx0XHRcdFx0XHQvLyBEbyBhbnkgb2YgdGhlIHByZXZpb3VzIHJlbGVhc2VkIGVsZW1lbnRzIG1hdGNoIHRoaXMgc2VsZWN0b3I/XG5cdFx0XHRcdFx0XHRcdGFkZCA9IHJlbGVhc2VkLmxlbmd0aCAmJiByZWxlYXNlZC5maWx0ZXIoc2VsKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoYWRkICYmIGFkZC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBZZXMsIHNvIHdlJ3JlIHN0YWxlIGFzIHdlIG5lZWQgdG8gaW5jbHVkZSB0aGVtLiBGaWx0ZXIgZm9yIGFueSBwb3NzaWJsZSB0YWtlbiB2YWx1ZSBhdCB0aGUgc2FtZSB0aW1lXG5cdFx0XHRcdFx0XHRcdFx0cmVzID0gcnVsZS5jYWNoZSA/IHJ1bGUuY2FjaGUubm90KHRha2VuKS5hZGQoYWRkKSA6IGFkZDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBEbyB3ZSB0aGluayB3ZSBvd24gYW55IG9mIHRoZSBlbGVtZW50cyBub3cgdGFrZW4gYnkgbW9yZSBzcGVjaWZpYyBydWxlcz9cblx0XHRcdFx0XHRcdFx0XHRyZW0gPSB0YWtlbi5sZW5ndGggJiYgcnVsZS5jYWNoZSAmJiBydWxlLmNhY2hlLmZpbHRlcih0YWtlbik7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAocmVtICYmIHJlbS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFllcywgc28gd2UncmUgc3RhbGUgYXMgd2UgbmVlZCB0byBleGNsdWRlIHRoZW0uXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXMgPSBydWxlLmNhY2hlLm5vdChyZW0pO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFJlcyB3aWxsIGJlIG51bGwgaWYgd2Uga25vdyB3ZSBhcmUgZnJlc2ggKG5vIGZ1bGwgbmVlZGVkLCBzZWxlY3RvciBub3QgYWZmZWN0ZWRCeSBjaGFuZ2VzKVxuXHRcdFx0XHRcdGlmIChyZXMgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdC8vIElmIHdlIGFyZSB0cmFja2luZyBtYXRjaGVkLCBhZGQgb3Vyc2VsdmVzXG5cdFx0XHRcdFx0XHRpZiAobWF0Y2hlZCAmJiBydWxlLmNhY2hlKSBtYXRjaGVkID0gbWF0Y2hlZC5hZGQocnVsZS5jYWNoZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gSWYgdGhpcyBzZWxlY3RvciBoYXMgYSBsaXN0IG9mIGVsZW1lbnRzIGl0IG1hdGNoZWQgYWdhaW5zdCBsYXN0IHRpbWVcblx0XHRcdFx0XHRcdGlmIChydWxlLmNhY2hlKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEZpbmQgdGhlIG9uZXMgdGhhdCBhcmUgZXh0cmEgdGhpcyB0aW1lXG5cdFx0XHRcdFx0XHRcdGFkZCA9IHJlcy5ub3QocnVsZS5jYWNoZSk7XG5cdFx0XHRcdFx0XHRcdHJlbSA9IHJ1bGUuY2FjaGUubm90KHJlcyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0YWRkID0gcmVzOyByZW0gPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoKGFkZCAmJiBhZGQubGVuZ3RoKSB8fCAocmVtICYmIHJlbS5sZW5ndGgpKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChyZW0gJiYgcmVtLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdHJlbGVhc2VkID0gcmVsZWFzZWQuYWRkKHJlbSk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoZHRvciAmJiAhcnVsZS5vbnVubWF0Y2hSdW5uaW5nKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRydWxlLm9udW5tYXRjaFJ1bm5pbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3RvcnMub251bm1hdGNocHJveHkocmVtLCBqLCBkdG9yKTtcblx0XHRcdFx0XHRcdFx0XHRcdHJ1bGUub251bm1hdGNoUnVubmluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIENhbGwgdGhlIGNvbnN0cnVjdG9yIG9uIHRoZSBuZXdseSBtYXRjaGVkIG9uZXNcblx0XHRcdFx0XHRcdFx0aWYgKGFkZCAmJiBhZGQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFrZW4gPSB0YWtlbi5hZGQoYWRkKTtcblx0XHRcdFx0XHRcdFx0XHRyZWxlYXNlZCA9IHJlbGVhc2VkLm5vdChhZGQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGN0b3IgJiYgIXJ1bGUub25tYXRjaFJ1bm5pbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJ1bGUub25tYXRjaFJ1bm5pbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3RvcnMub25tYXRjaHByb3h5KGFkZCwgaiwgY3Rvcik7XG5cdFx0XHRcdFx0XHRcdFx0XHRydWxlLm9ubWF0Y2hSdW5uaW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIElmIHdlIGFyZSB0cmFja2luZyBtYXRjaGVkLCBhZGQgb3Vyc2VsdmVzXG5cdFx0XHRcdFx0XHRpZiAobWF0Y2hlZCkgbWF0Y2hlZCA9IG1hdGNoZWQuYWRkKHJlcyk7XG5cblx0XHRcdFx0XHRcdC8vIEFuZCByZW1lbWJlciB0aGlzIGxpc3Qgb2YgbWF0Y2hpbmcgZWxlbWVudHMgYWdhaW4gdGhpcyBzZWxlY3Rvciwgc28gbmV4dCBtYXRjaGluZyB3ZSBjYW4gZmluZCB0aGUgdW5tYXRjaGVkIG9uZXNcblx0XHRcdFx0XHRcdHJ1bGUuY2FjaGUgPSByZXM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bmFtZXNwYWNlLm1hdGNoZXJzRGlydHkgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBjb25zb2xlLmxvZygobmV3IERhdGUpLmdldFRpbWUoKSAtIHN0YXJ0KTtcblx0fSk7XG5cdFxuXG59KShqUXVlcnkpO1xuO1xuXG5cbi8qIHNyYy9qcXVlcnkuZW50d2luZS5hZGRyZW0uanMgKi9cblxuKGZ1bmN0aW9uKCQpIHtcblxuXHQkLmVudHdpbmUuTmFtZXNwYWNlLmFkZE1ldGhvZHMoe1xuXHRcdGJ1aWxkX2FkZHJlbV9wcm94eTogZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dmFyIG9uZSA9IHRoaXMub25lKG5hbWUsICdmdW5jJyk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKHRoaXMubGVuZ3RoID09PSAwKXtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAodGhpcy5sZW5ndGgpIHtcblx0XHRcdFx0XHR2YXIgcnYsIGkgPSB0aGlzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoaS0tKSBydiA9IG9uZSh0aGlzW2ldLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdHJldHVybiBydjtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gb25lKHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdGJpbmRfYWRkcmVtX3Byb3h5OiBmdW5jdGlvbihzZWxlY3RvciwgbmFtZSwgZnVuYykge1xuXHRcdFx0dmFyIHJ1bGVsaXN0ID0gdGhpcy5zdG9yZVtuYW1lXSB8fCAodGhpcy5zdG9yZVtuYW1lXSA9ICQuZW50d2luZS5SdWxlTGlzdCgpKTtcblxuXHRcdFx0dmFyIHJ1bGUgPSBydWxlbGlzdC5hZGRSdWxlKHNlbGVjdG9yLCBuYW1lKTsgcnVsZS5mdW5jID0gZnVuYztcblxuXHRcdFx0aWYgKCF0aGlzLmluamVjdGVlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHRcdHRoaXMuaW5qZWN0ZWVbbmFtZV0gPSB0aGlzLmJ1aWxkX2FkZHJlbV9wcm94eShuYW1lKTtcblx0XHRcdFx0dGhpcy5pbmplY3RlZVtuYW1lXS5pc2VudHdpbmVtZXRob2QgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0JC5lbnR3aW5lLk5hbWVzcGFjZS5hZGRIYW5kbGVyKHtcblx0XHRvcmRlcjogMzAsXG5cblx0XHRiaW5kOiBmdW5jdGlvbihzZWxlY3Rvciwgaywgdikge1xuXHRcdFx0aWYgKCQuaXNGdW5jdGlvbih2KSAmJiAoayA9PSAnb25hZGQnIHx8IGsgPT0gJ29ucmVtb3ZlJykpIHtcblx0XHRcdFx0dGhpcy5iaW5kX2FkZHJlbV9wcm94eShzZWxlY3Rvciwgaywgdik7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0JChkb2N1bWVudCkuYmluZCgnRW50d2luZUVsZW1lbnRzQWRkZWQnLCBmdW5jdGlvbihlKXtcblx0XHQvLyBGb3IgZXZlcnkgbmFtZXNwYWNlXG5cdFx0Zm9yICh2YXIgayBpbiAkLmVudHdpbmUubmFtZXNwYWNlcykge1xuXHRcdFx0dmFyIG5hbWVzcGFjZSA9ICQuZW50d2luZS5uYW1lc3BhY2VzW2tdO1xuXHRcdFx0aWYgKG5hbWVzcGFjZS5pbmplY3RlZS5vbmFkZCkgbmFtZXNwYWNlLmluamVjdGVlLm9uYWRkLmNhbGwoZS50YXJnZXRzKTtcblx0XHR9XG5cdH0pO1xuXG5cdCQoZG9jdW1lbnQpLmJpbmQoJ0VudHdpbmVFbGVtZW50c1JlbW92ZWQnLCBmdW5jdGlvbihlKXtcblx0XHRmb3IgKHZhciBrIGluICQuZW50d2luZS5uYW1lc3BhY2VzKSB7XG5cdFx0XHR2YXIgbmFtZXNwYWNlID0gJC5lbnR3aW5lLm5hbWVzcGFjZXNba107XG5cdFx0XHRpZiAobmFtZXNwYWNlLmluamVjdGVlLm9ucmVtb3ZlKSBuYW1lc3BhY2UuaW5qZWN0ZWUub25yZW1vdmUuY2FsbChlLnRhcmdldHMpO1xuXHRcdH1cblx0fSk7XG5cblxuXG5cbn0pKGpRdWVyeSk7XG47XG5cblxuLyogc3JjL2pxdWVyeS5lbnR3aW5lLnByb3BlcnRpZXMuanMgKi9cblxuKGZ1bmN0aW9uKCQpIHtcdFxuXG5cdHZhciBlbnR3aW5lX3ByZXBlbmQgPSAnX19lbnR3aW5lISc7XG5cdFxuXHR2YXIgZ2V0RW50d2luZURhdGEgPSBmdW5jdGlvbihlbCwgbmFtZXNwYWNlLCBwcm9wZXJ0eSkge1xuXHRcdHJldHVybiBlbC5kYXRhKGVudHdpbmVfcHJlcGVuZCArIG5hbWVzcGFjZSArICchJyArIHByb3BlcnR5KTtcblx0fTtcblx0XG5cdHZhciBzZXRFbnR3aW5lRGF0YSA9IGZ1bmN0aW9uKGVsLCBuYW1lc3BhY2UsIHByb3BlcnR5LCB2YWx1ZSkge1xuXHRcdHJldHVybiBlbC5kYXRhKGVudHdpbmVfcHJlcGVuZCArIG5hbWVzcGFjZSArICchJyArIHByb3BlcnR5LCB2YWx1ZSk7XG5cdH07XG5cdFxuXHR2YXIgZ2V0RW50d2luZURhdGFBc0hhc2ggPSBmdW5jdGlvbihlbCwgbmFtZXNwYWNlKSB7XG5cdFx0dmFyIGhhc2ggPSB7fTtcblx0XHR2YXIgaWQgPSBqUXVlcnkuZGF0YShlbFswXSk7XG5cdFx0XG5cdFx0dmFyIG1hdGNoc3RyID0gZW50d2luZV9wcmVwZW5kICsgbmFtZXNwYWNlICsgJyEnO1xuXHRcdHZhciBtYXRjaGxlbiA9IG1hdGNoc3RyLmxlbmd0aDtcblx0XHRcblx0XHR2YXIgY2FjaGUgPSBqUXVlcnkuY2FjaGVbaWRdO1xuXHRcdGZvciAodmFyIGsgaW4gY2FjaGUpIHtcblx0XHRcdGlmIChrLnN1YnN0cigwLG1hdGNobGVuKSA9PSBtYXRjaHN0cikgaGFzaFtrLnN1YnN0cihtYXRjaGxlbildID0gY2FjaGVba107XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBoYXNoO1xuXHR9O1xuXHRcblx0dmFyIHNldEVudHdpbmVEYXRhRnJvbUhhc2ggPSBmdW5jdGlvbihlbCwgbmFtZXNwYWNlLCBoYXNoKSB7XG5cdFx0Zm9yICh2YXIgayBpbiBoYXNoKSBzZXRFbnR3aW5lRGF0YShuYW1lc3BhY2UsIGssIGhhc2hba10pO1xuXHR9O1xuXG5cdHZhciBlbnR3aW5lRGF0YSA9IGZ1bmN0aW9uKGVsLCBuYW1lc3BhY2UsIGFyZ3MpIHtcblx0XHRzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG5cdFx0XHRjYXNlIDA6XG5cdFx0XHRcdHJldHVybiBnZXRFbnR3aW5lRGF0YUFzSGFzaChlbCwgbmFtZXNwYWNlKTtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdID09ICdzdHJpbmcnKSByZXR1cm4gZ2V0RW50d2luZURhdGEoZWwsIG5hbWVzcGFjZSwgYXJnc1swXSk7XG5cdFx0XHRcdGVsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldEVudHdpbmVEYXRhRnJvbUhhc2goZWwsIG5hbWVzcGFjZSwgYXJnc1swXSk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gc2V0RW50d2luZURhdGEoZWwsIG5hbWVzcGFjZSwgYXJnc1swXSwgYXJnc1sxXSk7XG5cdFx0fVxuXHR9O1xuIFxuXHQkLmV4dGVuZCgkLmZuLCB7XG5cdFx0ZW50d2luZURhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGVudHdpbmVEYXRhKHRoaXMsICdfX2Jhc2UnLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fSk7XG5cdFxuXHQkLmVudHdpbmUuTmFtZXNwYWNlLmFkZEhhbmRsZXIoe1xuXHRcdG9yZGVyOiA2MCxcblx0XHRcblx0XHRiaW5kOiBmdW5jdGlvbihzZWxlY3Rvciwgaywgdikge1xuXHRcdFx0aWYgKGsuY2hhckF0KDApICE9IGsuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkpICQuZW50d2luZS53YXJuKCdFbnR3aW5lIHByb3BlcnR5ICcraysnIGRvZXMgbm90IHN0YXJ0IHdpdGggYSBjYXBpdGFsIGxldHRlcicsICQuZW50d2luZS5XQVJOX0xFVkVMX0JFU1RQUkFDVElTRSk7XG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZ2V0dGVycyBhbmQgc2V0dGVyc1xuXG5cdFx0XHR2YXIgZ2V0dGVyTmFtZSA9ICdnZXQnK2s7XG5cdFx0XHR2YXIgc2V0dGVyTmFtZSA9ICdzZXQnK2s7XG5cblx0XHRcdHRoaXMuYmluZF9wcm94eShzZWxlY3RvciwgZ2V0dGVyTmFtZSwgZnVuY3Rpb24oKSB7IHZhciByID0gdGhpcy5lbnR3aW5lRGF0YShrKTsgcmV0dXJuIHIgPT09IHVuZGVmaW5lZCA/IHYgOiByOyB9KTtcblx0XHRcdHRoaXMuYmluZF9wcm94eShzZWxlY3Rvciwgc2V0dGVyTmFtZSwgZnVuY3Rpb24odil7IHJldHVybiB0aGlzLmVudHdpbmVEYXRhKGssIHYpOyB9KTtcblx0XHRcdFxuXHRcdFx0Ly8gR2V0IHRoZSBnZXQgYW5kIHNldCBwcm94aWVzIHdlIGp1c3QgY3JlYXRlZFxuXHRcdFx0XG5cdFx0XHR2YXIgZ2V0dGVyID0gdGhpcy5pbmplY3RlZVtnZXR0ZXJOYW1lXTtcblx0XHRcdHZhciBzZXR0ZXIgPSB0aGlzLmluamVjdGVlW3NldHRlck5hbWVdO1xuXHRcdFx0XG5cdFx0XHQvLyBBbmQgYmluZCBpbiB0aGUgalF1ZXJ5LXN0eWxlIGFjY2Vzc29yXG5cdFx0XHRcblx0XHRcdHRoaXMuYmluZF9wcm94eShzZWxlY3RvciwgaywgZnVuY3Rpb24odil7IHJldHVybiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxID8gc2V0dGVyIDogZ2V0dGVyKS5jYWxsKHRoaXMsIHYpIDsgfSk7XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cdFx0XG5cdFx0bmFtZXNwYWNlTWV0aG9kT3ZlcnJpZGVzOiBmdW5jdGlvbihuYW1lc3BhY2Upe1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZW50d2luZURhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBlbnR3aW5lRGF0YSh0aGlzLCBuYW1lc3BhY2UubmFtZSwgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdH0pO1xuXHRcbn0pKGpRdWVyeSk7XG47XG5cblxuLyogc3JjL2pxdWVyeS5lbnR3aW5lLmxlZ2FjeS5qcyAqL1xuXG4oZnVuY3Rpb24oJCkge1x0XG5cdFxuXHQvLyBBZGRzIGJhY2sgY29uY3JldGUgbWV0aG9kcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0JC5jb25jcmV0ZSA9ICQuZW50d2luZTtcblx0JC5mbi5jb25jcmV0ZSA9ICQuZm4uZW50d2luZTtcblx0JC5mbi5jb25jcmV0ZURhdGEgPSAkLmZuLmVudHdpbmVEYXRhO1xuXHRcblx0Ly8gVXNlIGFkZEhhbmRsZXIgdG8gaGFjayBpbiB0aGUgbmFtZXNwYWNlLiQuY29uY3JldGUgZXF1aXZpbGVudCB0byB0aGUgbmFtZXNwYWNlLiQuZW50d2luZSBuYW1lc3BhY2UtaW5qZWN0aW9uXG5cdCQuZW50d2luZS5OYW1lc3BhY2UuYWRkSGFuZGxlcih7XG5cdFx0b3JkZXI6IDEwMCxcblx0XHRiaW5kOiBmdW5jdGlvbihzZWxlY3RvciwgaywgdikgeyByZXR1cm4gZmFsc2U7IH0sXG5cdFxuXHRcdG5hbWVzcGFjZU1ldGhvZE92ZXJyaWRlczogZnVuY3Rpb24obmFtZXNwYWNlKXtcblx0XHRcdG5hbWVzcGFjZS4kLmNvbmNyZXRlID0gbmFtZXNwYWNlLiQuZW50d2luZTtcblx0XHRcdG5hbWVzcGFjZS5pbmplY3RlZS5jb25jcmV0ZSA9IG5hbWVzcGFjZS5pbmplY3RlZS5lbnR3aW5lO1xuXHRcdFx0bmFtZXNwYWNlLmluamVjdGVlLmNvbmNyZXRlRGF0YSA9IG5hbWVzcGFjZS5pbmplY3RlZS5lbnR3aW5lRGF0YTtcblx0XHRcdHJldHVybiB7fTtcblx0XHR9XG5cdH0pO1xuXG59KShqUXVlcnkpO1xuO1xuXG4iLCIvKiFcbiAqIGpRdWVyeSBGb3JtIFBsdWdpblxuICogdmVyc2lvbjogMi45NiAoMTYtRkVCLTIwMTIpXG4gKiBAcmVxdWlyZXMgalF1ZXJ5IHYxLjMuMiBvciBsYXRlclxuICpcbiAqIEV4YW1wbGVzIGFuZCBkb2N1bWVudGF0aW9uIGF0OiBodHRwOi8vbWFsc3VwLmNvbS9qcXVlcnkvZm9ybS9cbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIGxpY2Vuc2VzOlxuICpcdGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKlx0aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzL2dwbC5odG1sXG4gKi9cbjsoZnVuY3Rpb24oJCkge1xuXG4vKlxuXHRVc2FnZSBOb3RlOlxuXHQtLS0tLS0tLS0tLVxuXHREbyBub3QgdXNlIGJvdGggYWpheFN1Ym1pdCBhbmQgYWpheEZvcm0gb24gdGhlIHNhbWUgZm9ybS4gIFRoZXNlXG5cdGZ1bmN0aW9ucyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLiAgVXNlIGFqYXhTdWJtaXQgaWYgeW91IHdhbnRcblx0dG8gYmluZCB5b3VyIG93biBzdWJtaXQgaGFuZGxlciB0byB0aGUgZm9ybS4gIEZvciBleGFtcGxlLFxuXG5cdCQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXHRcdCQoJyNteUZvcm0nKS5iaW5kKCdzdWJtaXQnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7IC8vIDwtLSBpbXBvcnRhbnRcblx0XHRcdCQodGhpcykuYWpheFN1Ym1pdCh7XG5cdFx0XHRcdHRhcmdldDogJyNvdXRwdXQnXG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fSk7XG5cblx0VXNlIGFqYXhGb3JtIHdoZW4geW91IHdhbnQgdGhlIHBsdWdpbiB0byBtYW5hZ2UgYWxsIHRoZSBldmVudCBiaW5kaW5nXG5cdGZvciB5b3UuICBGb3IgZXhhbXBsZSxcblxuXHQkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcblx0XHQkKCcjbXlGb3JtJykuYWpheEZvcm0oe1xuXHRcdFx0dGFyZ2V0OiAnI291dHB1dCdcblx0XHR9KTtcblx0fSk7XG5cdFxuXHRZb3UgY2FuIGFsc28gdXNlIGFqYXhGb3JtIHdpdGggZGVsZWdhdGlvbiAocmVxdWlyZXMgalF1ZXJ5IHYxLjcrKSwgc28gdGhlXG5cdGZvcm0gZG9lcyBub3QgaGF2ZSB0byBleGlzdCB3aGVuIHlvdSBpbnZva2UgYWpheEZvcm06XG5cblx0JCgnI215Rm9ybScpLmFqYXhGb3JtKHtcblx0XHRkZWxlZ2F0aW9uOiB0cnVlLFxuXHRcdHRhcmdldDogJyNvdXRwdXQnXG5cdH0pO1xuXHRcblx0V2hlbiB1c2luZyBhamF4Rm9ybSwgdGhlIGFqYXhTdWJtaXQgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIGZvciB5b3Vcblx0YXQgdGhlIGFwcHJvcHJpYXRlIHRpbWUuXG4qL1xuXG4vKipcbiAqIGFqYXhTdWJtaXQoKSBwcm92aWRlcyBhIG1lY2hhbmlzbSBmb3IgaW1tZWRpYXRlbHkgc3VibWl0dGluZ1xuICogYW4gSFRNTCBmb3JtIHVzaW5nIEFKQVguXG4gKi9cbiQuZm4uYWpheFN1Ym1pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0Ly8gZmFzdCBmYWlsIGlmIG5vdGhpbmcgc2VsZWN0ZWQgKGh0dHA6Ly9kZXYuanF1ZXJ5LmNvbS90aWNrZXQvMjc1Milcblx0aWYgKCF0aGlzLmxlbmd0aCkge1xuXHRcdGxvZygnYWpheFN1Ym1pdDogc2tpcHBpbmcgc3VibWl0IHByb2Nlc3MgLSBubyBlbGVtZW50IHNlbGVjdGVkJyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0XG5cdHZhciBtZXRob2QsIGFjdGlvbiwgdXJsLCAkZm9ybSA9IHRoaXM7XG5cblx0aWYgKHR5cGVvZiBvcHRpb25zID09ICdmdW5jdGlvbicpIHtcblx0XHRvcHRpb25zID0geyBzdWNjZXNzOiBvcHRpb25zIH07XG5cdH1cblxuXHRtZXRob2QgPSB0aGlzLmF0dHIoJ21ldGhvZCcpO1xuXHRhY3Rpb24gPSB0aGlzLmF0dHIoJ2FjdGlvbicpO1xuXHR1cmwgPSAodHlwZW9mIGFjdGlvbiA9PT0gJ3N0cmluZycpID8gJC50cmltKGFjdGlvbikgOiAnJztcblx0dXJsID0gdXJsIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICcnO1xuXHRpZiAodXJsKSB7XG5cdFx0Ly8gY2xlYW4gdXJsIChkb24ndCBpbmNsdWRlIGhhc2ggdmF1ZSlcblx0XHR1cmwgPSAodXJsLm1hdGNoKC9eKFteI10rKS8pfHxbXSlbMV07XG5cdH1cblxuXHRvcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge1xuXHRcdHVybDogIHVybCxcblx0XHRzdWNjZXNzOiAkLmFqYXhTZXR0aW5ncy5zdWNjZXNzLFxuXHRcdHR5cGU6IG1ldGhvZCB8fCAnR0VUJyxcblx0XHRpZnJhbWVTcmM6IC9eaHR0cHMvaS50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICcnKSA/ICdqYXZhc2NyaXB0OmZhbHNlJyA6ICdhYm91dDpibGFuaydcblx0fSwgb3B0aW9ucyk7XG5cblx0Ly8gaG9vayBmb3IgbWFuaXB1bGF0aW5nIHRoZSBmb3JtIGRhdGEgYmVmb3JlIGl0IGlzIGV4dHJhY3RlZDtcblx0Ly8gY29udmVuaWVudCBmb3IgdXNlIHdpdGggcmljaCBlZGl0b3JzIGxpa2UgdGlueU1DRSBvciBGQ0tFZGl0b3Jcblx0dmFyIHZldG8gPSB7fTtcblx0dGhpcy50cmlnZ2VyKCdmb3JtLXByZS1zZXJpYWxpemUnLCBbdGhpcywgb3B0aW9ucywgdmV0b10pO1xuXHRpZiAodmV0by52ZXRvKSB7XG5cdFx0bG9nKCdhamF4U3VibWl0OiBzdWJtaXQgdmV0b2VkIHZpYSBmb3JtLXByZS1zZXJpYWxpemUgdHJpZ2dlcicpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Ly8gcHJvdmlkZSBvcHBvcnR1bml0eSB0byBhbHRlciBmb3JtIGRhdGEgYmVmb3JlIGl0IGlzIHNlcmlhbGl6ZWRcblx0aWYgKG9wdGlvbnMuYmVmb3JlU2VyaWFsaXplICYmIG9wdGlvbnMuYmVmb3JlU2VyaWFsaXplKHRoaXMsIG9wdGlvbnMpID09PSBmYWxzZSkge1xuXHRcdGxvZygnYWpheFN1Ym1pdDogc3VibWl0IGFib3J0ZWQgdmlhIGJlZm9yZVNlcmlhbGl6ZSBjYWxsYmFjaycpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0dmFyIHRyYWRpdGlvbmFsID0gb3B0aW9ucy50cmFkaXRpb25hbDtcblx0aWYgKCB0cmFkaXRpb25hbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHRyYWRpdGlvbmFsID0gJC5hamF4U2V0dGluZ3MudHJhZGl0aW9uYWw7XG5cdH1cblx0XG5cdHZhciBxeCxuLHYsYSA9IHRoaXMuZm9ybVRvQXJyYXkob3B0aW9ucy5zZW1hbnRpYyk7XG5cdGlmIChvcHRpb25zLmRhdGEpIHtcblx0XHRvcHRpb25zLmV4dHJhRGF0YSA9IG9wdGlvbnMuZGF0YTtcblx0XHRxeCA9ICQucGFyYW0ob3B0aW9ucy5kYXRhLCB0cmFkaXRpb25hbCk7XG5cdH1cblxuXHQvLyBnaXZlIHByZS1zdWJtaXQgY2FsbGJhY2sgYW4gb3Bwb3J0dW5pdHkgdG8gYWJvcnQgdGhlIHN1Ym1pdFxuXHRpZiAob3B0aW9ucy5iZWZvcmVTdWJtaXQgJiYgb3B0aW9ucy5iZWZvcmVTdWJtaXQoYSwgdGhpcywgb3B0aW9ucykgPT09IGZhbHNlKSB7XG5cdFx0bG9nKCdhamF4U3VibWl0OiBzdWJtaXQgYWJvcnRlZCB2aWEgYmVmb3JlU3VibWl0IGNhbGxiYWNrJyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvLyBmaXJlIHZldG9hYmxlICd2YWxpZGF0ZScgZXZlbnRcblx0dGhpcy50cmlnZ2VyKCdmb3JtLXN1Ym1pdC12YWxpZGF0ZScsIFthLCB0aGlzLCBvcHRpb25zLCB2ZXRvXSk7XG5cdGlmICh2ZXRvLnZldG8pIHtcblx0XHRsb2coJ2FqYXhTdWJtaXQ6IHN1Ym1pdCB2ZXRvZWQgdmlhIGZvcm0tc3VibWl0LXZhbGlkYXRlIHRyaWdnZXInKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHZhciBxID0gJC5wYXJhbShhLCB0cmFkaXRpb25hbCk7XG5cdGlmIChxeCkge1xuXHRcdHEgPSAoIHEgPyAocSArICcmJyArIHF4KSA6IHF4ICk7XG5cdH1cdFxuXHRpZiAob3B0aW9ucy50eXBlLnRvVXBwZXJDYXNlKCkgPT0gJ0dFVCcpIHtcblx0XHRvcHRpb25zLnVybCArPSAob3B0aW9ucy51cmwuaW5kZXhPZignPycpID49IDAgPyAnJicgOiAnPycpICsgcTtcblx0XHRvcHRpb25zLmRhdGEgPSBudWxsOyAgLy8gZGF0YSBpcyBudWxsIGZvciAnZ2V0J1xuXHR9XG5cdGVsc2Uge1xuXHRcdG9wdGlvbnMuZGF0YSA9IHE7IC8vIGRhdGEgaXMgdGhlIHF1ZXJ5IHN0cmluZyBmb3IgJ3Bvc3QnXG5cdH1cblxuXHR2YXIgY2FsbGJhY2tzID0gW107XG5cdGlmIChvcHRpb25zLnJlc2V0Rm9ybSkge1xuXHRcdGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uKCkgeyAkZm9ybS5yZXNldEZvcm0oKTsgfSk7XG5cdH1cblx0aWYgKG9wdGlvbnMuY2xlYXJGb3JtKSB7XG5cdFx0Y2FsbGJhY2tzLnB1c2goZnVuY3Rpb24oKSB7ICRmb3JtLmNsZWFyRm9ybShvcHRpb25zLmluY2x1ZGVIaWRkZW4pOyB9KTtcblx0fVxuXG5cdC8vIHBlcmZvcm0gYSBsb2FkIG9uIHRoZSB0YXJnZXQgb25seSBpZiBkYXRhVHlwZSBpcyBub3QgcHJvdmlkZWRcblx0aWYgKCFvcHRpb25zLmRhdGFUeXBlICYmIG9wdGlvbnMudGFyZ2V0KSB7XG5cdFx0dmFyIG9sZFN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3MgfHwgZnVuY3Rpb24oKXt9O1xuXHRcdGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdHZhciBmbiA9IG9wdGlvbnMucmVwbGFjZVRhcmdldCA/ICdyZXBsYWNlV2l0aCcgOiAnaHRtbCc7XG5cdFx0XHQkKG9wdGlvbnMudGFyZ2V0KVtmbl0oZGF0YSkuZWFjaChvbGRTdWNjZXNzLCBhcmd1bWVudHMpO1xuXHRcdH0pO1xuXHR9XG5cdGVsc2UgaWYgKG9wdGlvbnMuc3VjY2Vzcykge1xuXHRcdGNhbGxiYWNrcy5wdXNoKG9wdGlvbnMuc3VjY2Vzcyk7XG5cdH1cblxuXHRvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihkYXRhLCBzdGF0dXMsIHhocikgeyAvLyBqUXVlcnkgMS40KyBwYXNzZXMgeGhyIGFzIDNyZCBhcmdcblx0XHR2YXIgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCB8fCBvcHRpb25zO1x0Ly8galF1ZXJ5IDEuNCsgc3VwcG9ydHMgc2NvcGUgY29udGV4dCBcblx0XHRmb3IgKHZhciBpPTAsIG1heD1jYWxsYmFja3MubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcblx0XHRcdGNhbGxiYWNrc1tpXS5hcHBseShjb250ZXh0LCBbZGF0YSwgc3RhdHVzLCB4aHIgfHwgJGZvcm0sICRmb3JtXSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIGFyZSB0aGVyZSBmaWxlcyB0byB1cGxvYWQ/XG5cdHZhciBmaWxlSW5wdXRzID0gJCgnaW5wdXQ6ZmlsZTplbmFibGVkW3ZhbHVlXScsIHRoaXMpOyAvLyBbdmFsdWVdIChpc3N1ZSAjMTEzKVxuXHR2YXIgaGFzRmlsZUlucHV0cyA9IGZpbGVJbnB1dHMubGVuZ3RoID4gMDtcblx0dmFyIG1wID0gJ211bHRpcGFydC9mb3JtLWRhdGEnO1xuXHR2YXIgbXVsdGlwYXJ0ID0gKCRmb3JtLmF0dHIoJ2VuY3R5cGUnKSA9PSBtcCB8fCAkZm9ybS5hdHRyKCdlbmNvZGluZycpID09IG1wKTtcblxuXHR2YXIgZmlsZUFQSSA9ICEhKGhhc0ZpbGVJbnB1dHMgJiYgZmlsZUlucHV0cy5nZXQoMCkuZmlsZXMgJiYgd2luZG93LkZvcm1EYXRhKTtcblx0bG9nKFwiZmlsZUFQSSA6XCIgKyBmaWxlQVBJKTtcblx0dmFyIHNob3VsZFVzZUZyYW1lID0gKGhhc0ZpbGVJbnB1dHMgfHwgbXVsdGlwYXJ0KSAmJiAhZmlsZUFQSTtcblxuXHQvLyBvcHRpb25zLmlmcmFtZSBhbGxvd3MgdXNlciB0byBmb3JjZSBpZnJhbWUgbW9kZVxuXHQvLyAwNi1OT1YtMDk6IG5vdyBkZWZhdWx0aW5nIHRvIGlmcmFtZSBtb2RlIGlmIGZpbGUgaW5wdXQgaXMgZGV0ZWN0ZWRcblx0aWYgKG9wdGlvbnMuaWZyYW1lICE9PSBmYWxzZSAmJiAob3B0aW9ucy5pZnJhbWUgfHwgc2hvdWxkVXNlRnJhbWUpKSB7XG5cdFx0Ly8gaGFjayB0byBmaXggU2FmYXJpIGhhbmcgKHRoYW5rcyB0byBUaW0gTW9sZW5kaWprIGZvciB0aGlzKVxuXHRcdC8vIHNlZTogIGh0dHA6Ly9ncm91cHMuZ29vZ2xlLmNvbS9ncm91cC9qcXVlcnktZGV2L2Jyb3dzZV90aHJlYWQvdGhyZWFkLzM2Mzk1YjdhYjUxMGRkNWRcblx0XHRpZiAob3B0aW9ucy5jbG9zZUtlZXBBbGl2ZSkge1xuXHRcdFx0JC5nZXQob3B0aW9ucy5jbG9zZUtlZXBBbGl2ZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZpbGVVcGxvYWRJZnJhbWUoYSk7XG5cdFx0XHR9KTtcblx0XHR9XG4gIFx0XHRlbHNlIHtcblx0XHRcdGZpbGVVcGxvYWRJZnJhbWUoYSk7XG4gIFx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoKGhhc0ZpbGVJbnB1dHMgfHwgbXVsdGlwYXJ0KSAmJiBmaWxlQVBJKSB7XG5cdFx0b3B0aW9ucy5wcm9ncmVzcyA9IG9wdGlvbnMucHJvZ3Jlc3MgfHwgJC5ub29wO1xuXHRcdGZpbGVVcGxvYWRYaHIoYSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0JC5hamF4KG9wdGlvbnMpO1xuXHR9XG5cblx0IC8vIGZpcmUgJ25vdGlmeScgZXZlbnRcblx0IHRoaXMudHJpZ2dlcignZm9ybS1zdWJtaXQtbm90aWZ5JywgW3RoaXMsIG9wdGlvbnNdKTtcblx0IHJldHVybiB0aGlzO1xuXG5cdCAvLyBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyIGZpbGUgdXBsb2FkcyAoYmlnIGhhdCB0aXAgdG8gZnJhbmNvaXMybWV0eilcblx0ZnVuY3Rpb24gZmlsZVVwbG9hZFhocihhKSB7XG5cdFx0dmFyIGZvcm1kYXRhID0gbmV3IEZvcm1EYXRhKCk7XG5cblx0XHRmb3IgKHZhciBpPTA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoYVtpXS50eXBlID09ICdmaWxlJylcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRmb3JtZGF0YS5hcHBlbmQoYVtpXS5uYW1lLCBhW2ldLnZhbHVlKTtcblx0XHR9XG5cblx0XHQkZm9ybS5maW5kKCdpbnB1dDpmaWxlOmVuYWJsZWQnKS5lYWNoKGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgbmFtZSA9ICQodGhpcykuYXR0cignbmFtZScpLCBmaWxlcyA9IHRoaXMuZmlsZXM7XG5cdFx0XHRpZiAobmFtZSkge1xuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKylcblx0XHRcdFx0XHRmb3JtZGF0YS5hcHBlbmQobmFtZSwgZmlsZXNbaV0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKG9wdGlvbnMuZXh0cmFEYXRhKSB7XG5cdFx0XHRmb3IgKHZhciBrIGluIG9wdGlvbnMuZXh0cmFEYXRhKVxuXHRcdFx0XHRmb3JtZGF0YS5hcHBlbmQoaywgb3B0aW9ucy5leHRyYURhdGFba10pXG5cdFx0fVxuXG5cdFx0b3B0aW9ucy5kYXRhID0gbnVsbDtcblxuXHRcdHZhciBzID0gJC5leHRlbmQodHJ1ZSwge30sICQuYWpheFNldHRpbmdzLCBvcHRpb25zLCB7XG5cdFx0XHRjb250ZW50VHlwZTogZmFsc2UsXG5cdFx0XHRwcm9jZXNzRGF0YTogZmFsc2UsXG5cdFx0XHRjYWNoZTogZmFsc2UsXG5cdFx0XHR0eXBlOiAnUE9TVCdcblx0XHR9KTtcblxuICAgICAgLy9zLmNvbnRleHQgPSBzLmNvbnRleHQgfHwgcztcblxuICAgICAgcy5kYXRhID0gbnVsbDtcbiAgICAgIHZhciBiZWZvcmVTZW5kID0gcy5iZWZvcmVTZW5kO1xuICAgICAgcy5iZWZvcmVTZW5kID0gZnVuY3Rpb24oeGhyLCBvKSB7XG4gICAgICAgICAgby5kYXRhID0gZm9ybWRhdGE7XG4gICAgICAgICAgaWYoeGhyLnVwbG9hZCkgeyAvLyB1bmZvcnR1bmF0ZWx5LCBqUXVlcnkgZG9lc24ndCBleHBvc2UgdGhpcyBwcm9wIChodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMDE5MClcbiAgICAgICAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgIG8ucHJvZ3Jlc3MoZXZlbnQucG9zaXRpb24sIGV2ZW50LnRvdGFsKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoYmVmb3JlU2VuZClcbiAgICAgICAgICAgICAgYmVmb3JlU2VuZC5jYWxsKG8sIHhociwgb3B0aW9ucyk7XG4gICAgICB9O1xuICAgICAgJC5hamF4KHMpO1xuICAgfVxuXG5cdC8vIHByaXZhdGUgZnVuY3Rpb24gZm9yIGhhbmRsaW5nIGZpbGUgdXBsb2FkcyAoaGF0IHRpcCB0byBZQUhPTyEpXG5cdGZ1bmN0aW9uIGZpbGVVcGxvYWRJZnJhbWUoYSkge1xuXHRcdHZhciBmb3JtID0gJGZvcm1bMF0sIGVsLCBpLCBzLCBnLCBpZCwgJGlvLCBpbywgeGhyLCBzdWIsIG4sIHRpbWVkT3V0LCB0aW1lb3V0SGFuZGxlO1xuXHRcdHZhciB1c2VQcm9wID0gISEkLmZuLnByb3A7XG5cblx0XHRpZiAoYSkge1xuXHRcdFx0aWYgKCB1c2VQcm9wICkge1xuXHRcdFx0XHQvLyBlbnN1cmUgdGhhdCBldmVyeSBzZXJpYWxpemVkIGlucHV0IGlzIHN0aWxsIGVuYWJsZWRcblx0XHRcdFx0Zm9yIChpPTA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0ZWwgPSAkKGZvcm1bYVtpXS5uYW1lXSk7XG5cdFx0XHRcdFx0ZWwucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoaT0wOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGVsID0gJChmb3JtW2FbaV0ubmFtZV0pO1xuXHRcdFx0XHRcdGVsLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJyk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0aWYgKCQoJzppbnB1dFtuYW1lPXN1Ym1pdF0sOmlucHV0W2lkPXN1Ym1pdF0nLCBmb3JtKS5sZW5ndGgpIHtcblx0XHRcdC8vIGlmIHRoZXJlIGlzIGFuIGlucHV0IHdpdGggYSBuYW1lIG9yIGlkIG9mICdzdWJtaXQnIHRoZW4gd2Ugd29uJ3QgYmVcblx0XHRcdC8vIGFibGUgdG8gaW52b2tlIHRoZSBzdWJtaXQgZm4gb24gdGhlIGZvcm0gKGF0IGxlYXN0IG5vdCB4LWJyb3dzZXIpXG5cdFx0XHRhbGVydCgnRXJyb3I6IEZvcm0gZWxlbWVudHMgbXVzdCBub3QgaGF2ZSBuYW1lIG9yIGlkIG9mIFwic3VibWl0XCIuJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdFxuXHRcdHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgJC5hamF4U2V0dGluZ3MsIG9wdGlvbnMpO1xuXHRcdHMuY29udGV4dCA9IHMuY29udGV4dCB8fCBzO1xuXHRcdGlkID0gJ2pxRm9ybUlPJyArIChuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG5cdFx0aWYgKHMuaWZyYW1lVGFyZ2V0KSB7XG5cdFx0XHQkaW8gPSAkKHMuaWZyYW1lVGFyZ2V0KTtcblx0XHRcdG4gPSAkaW8uYXR0cignbmFtZScpO1xuXHRcdFx0aWYgKG4gPT0gbnVsbClcblx0XHRcdCBcdCRpby5hdHRyKCduYW1lJywgaWQpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRpZCA9IG47XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0JGlvID0gJCgnPGlmcmFtZSBuYW1lPVwiJyArIGlkICsgJ1wiIHNyYz1cIicrIHMuaWZyYW1lU3JjICsnXCIgLz4nKTtcblx0XHRcdCRpby5jc3MoeyBwb3NpdGlvbjogJ2Fic29sdXRlJywgdG9wOiAnLTEwMDBweCcsIGxlZnQ6ICctMTAwMHB4JyB9KTtcblx0XHR9XG5cdFx0aW8gPSAkaW9bMF07XG5cblxuXHRcdHhociA9IHsgLy8gbW9jayBvYmplY3Rcblx0XHRcdGFib3J0ZWQ6IDAsXG5cdFx0XHRyZXNwb25zZVRleHQ6IG51bGwsXG5cdFx0XHRyZXNwb25zZVhNTDogbnVsbCxcblx0XHRcdHN0YXR1czogMCxcblx0XHRcdHN0YXR1c1RleHQ6ICduL2EnLFxuXHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHt9LFxuXHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCkge30sXG5cdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbigpIHt9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKHN0YXR1cykge1xuXHRcdFx0XHR2YXIgZSA9IChzdGF0dXMgPT09ICd0aW1lb3V0JyA/ICd0aW1lb3V0JyA6ICdhYm9ydGVkJyk7XG5cdFx0XHRcdGxvZygnYWJvcnRpbmcgdXBsb2FkLi4uICcgKyBlKTtcblx0XHRcdFx0dGhpcy5hYm9ydGVkID0gMTtcblx0XHRcdFx0JGlvLmF0dHIoJ3NyYycsIHMuaWZyYW1lU3JjKTsgLy8gYWJvcnQgb3AgaW4gcHJvZ3Jlc3Ncblx0XHRcdFx0eGhyLmVycm9yID0gZTtcblx0XHRcdFx0cy5lcnJvciAmJiBzLmVycm9yLmNhbGwocy5jb250ZXh0LCB4aHIsIGUsIHN0YXR1cyk7XG5cdFx0XHRcdGcgJiYgJC5ldmVudC50cmlnZ2VyKFwiYWpheEVycm9yXCIsIFt4aHIsIHMsIGVdKTtcblx0XHRcdFx0cy5jb21wbGV0ZSAmJiBzLmNvbXBsZXRlLmNhbGwocy5jb250ZXh0LCB4aHIsIGUpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRnID0gcy5nbG9iYWw7XG5cdFx0Ly8gdHJpZ2dlciBhamF4IGdsb2JhbCBldmVudHMgc28gdGhhdCBhY3Rpdml0eS9ibG9jayBpbmRpY2F0b3JzIHdvcmsgbGlrZSBub3JtYWxcblx0XHRpZiAoZyAmJiAhICQuYWN0aXZlKyspIHtcblx0XHRcdCQuZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKTtcblx0XHR9XG5cdFx0aWYgKGcpIHtcblx0XHRcdCQuZXZlbnQudHJpZ2dlcihcImFqYXhTZW5kXCIsIFt4aHIsIHNdKTtcblx0XHR9XG5cblx0XHRpZiAocy5iZWZvcmVTZW5kICYmIHMuYmVmb3JlU2VuZC5jYWxsKHMuY29udGV4dCwgeGhyLCBzKSA9PT0gZmFsc2UpIHtcblx0XHRcdGlmIChzLmdsb2JhbCkge1xuXHRcdFx0XHQkLmFjdGl2ZS0tO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoeGhyLmFib3J0ZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBhZGQgc3VibWl0dGluZyBlbGVtZW50IHRvIGRhdGEgaWYgd2Uga25vdyBpdFxuXHRcdHN1YiA9IGZvcm0uY2xrO1xuXHRcdGlmIChzdWIpIHtcblx0XHRcdG4gPSBzdWIubmFtZTtcblx0XHRcdGlmIChuICYmICFzdWIuZGlzYWJsZWQpIHtcblx0XHRcdFx0cy5leHRyYURhdGEgPSBzLmV4dHJhRGF0YSB8fCB7fTtcblx0XHRcdFx0cy5leHRyYURhdGFbbl0gPSBzdWIudmFsdWU7XG5cdFx0XHRcdGlmIChzdWIudHlwZSA9PSBcImltYWdlXCIpIHtcblx0XHRcdFx0XHRzLmV4dHJhRGF0YVtuKycueCddID0gZm9ybS5jbGtfeDtcblx0XHRcdFx0XHRzLmV4dHJhRGF0YVtuKycueSddID0gZm9ybS5jbGtfeTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHR2YXIgQ0xJRU5UX1RJTUVPVVRfQUJPUlQgPSAxO1xuXHRcdHZhciBTRVJWRVJfQUJPUlQgPSAyO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0RG9jKGZyYW1lKSB7XG5cdFx0XHR2YXIgZG9jID0gZnJhbWUuY29udGVudFdpbmRvdyA/IGZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQgOiBmcmFtZS5jb250ZW50RG9jdW1lbnQgPyBmcmFtZS5jb250ZW50RG9jdW1lbnQgOiBmcmFtZS5kb2N1bWVudDtcblx0XHRcdHJldHVybiBkb2M7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIFJhaWxzIENTUkYgaGFjayAodGhhbmtzIHRvIFl2YW4gQmFydGhlbGVteSlcblx0XHR2YXIgY3NyZl90b2tlbiA9ICQoJ21ldGFbbmFtZT1jc3JmLXRva2VuXScpLmF0dHIoJ2NvbnRlbnQnKTtcblx0XHR2YXIgY3NyZl9wYXJhbSA9ICQoJ21ldGFbbmFtZT1jc3JmLXBhcmFtXScpLmF0dHIoJ2NvbnRlbnQnKTtcblx0XHRpZiAoY3NyZl9wYXJhbSAmJiBjc3JmX3Rva2VuKSB7XG5cdFx0XHRzLmV4dHJhRGF0YSA9IHMuZXh0cmFEYXRhIHx8IHt9O1xuXHRcdFx0cy5leHRyYURhdGFbY3NyZl9wYXJhbV0gPSBjc3JmX3Rva2VuO1xuXHRcdH1cblxuXHRcdC8vIHRha2UgYSBicmVhdGggc28gdGhhdCBwZW5kaW5nIHJlcGFpbnRzIGdldCBzb21lIGNwdSB0aW1lIGJlZm9yZSB0aGUgdXBsb2FkIHN0YXJ0c1xuXHRcdGZ1bmN0aW9uIGRvU3VibWl0KCkge1xuXHRcdFx0Ly8gbWFrZSBzdXJlIGZvcm0gYXR0cnMgYXJlIHNldFxuXHRcdFx0dmFyIHQgPSAkZm9ybS5hdHRyKCd0YXJnZXQnKSwgYSA9ICRmb3JtLmF0dHIoJ2FjdGlvbicpO1xuXG5cdFx0XHQvLyB1cGRhdGUgZm9ybSBhdHRycyBpbiBJRSBmcmllbmRseSB3YXlcblx0XHRcdGZvcm0uc2V0QXR0cmlidXRlKCd0YXJnZXQnLGlkKTtcblx0XHRcdGlmICghbWV0aG9kKSB7XG5cdFx0XHRcdGZvcm0uc2V0QXR0cmlidXRlKCdtZXRob2QnLCAnUE9TVCcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGEgIT0gcy51cmwpIHtcblx0XHRcdFx0Zm9ybS5zZXRBdHRyaWJ1dGUoJ2FjdGlvbicsIHMudXJsKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaWUgYm9ya3MgaW4gc29tZSBjYXNlcyB3aGVuIHNldHRpbmcgZW5jb2Rpbmdcblx0XHRcdGlmICghIHMuc2tpcEVuY29kaW5nT3ZlcnJpZGUgJiYgKCFtZXRob2QgfHwgL3Bvc3QvaS50ZXN0KG1ldGhvZCkpKSB7XG5cdFx0XHRcdCRmb3JtLmF0dHIoe1xuXHRcdFx0XHRcdGVuY29kaW5nOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsXG5cdFx0XHRcdFx0ZW5jdHlwZTogICdtdWx0aXBhcnQvZm9ybS1kYXRhJ1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc3VwcG9ydCB0aW1vdXRcblx0XHRcdGlmIChzLnRpbWVvdXQpIHtcblx0XHRcdFx0dGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRpbWVkT3V0ID0gdHJ1ZTsgY2IoQ0xJRU5UX1RJTUVPVVRfQUJPUlQpOyB9LCBzLnRpbWVvdXQpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBsb29rIGZvciBzZXJ2ZXIgYWJvcnRzXG5cdFx0XHRmdW5jdGlvbiBjaGVja1N0YXRlKCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciBzdGF0ZSA9IGdldERvYyhpbykucmVhZHlTdGF0ZTtcblx0XHRcdFx0XHRsb2coJ3N0YXRlID0gJyArIHN0YXRlKTtcblx0XHRcdFx0XHRpZiAoc3RhdGUudG9Mb3dlckNhc2UoKSA9PSAndW5pbml0aWFsaXplZCcpXG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGNoZWNrU3RhdGUsNTApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoKGUpIHtcblx0XHRcdFx0XHRsb2coJ1NlcnZlciBhYm9ydDogJyAsIGUsICcgKCcsIGUubmFtZSwgJyknKTtcblx0XHRcdFx0XHRjYihTRVJWRVJfQUJPUlQpO1xuXHRcdFx0XHRcdHRpbWVvdXRIYW5kbGUgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuXHRcdFx0XHRcdHRpbWVvdXRIYW5kbGUgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRkIFwiZXh0cmFcIiBkYXRhIHRvIGZvcm0gaWYgcHJvdmlkZWQgaW4gb3B0aW9uc1xuXHRcdFx0dmFyIGV4dHJhSW5wdXRzID0gW107XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAocy5leHRyYURhdGEpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBuIGluIHMuZXh0cmFEYXRhKSB7XG5cdFx0XHRcdFx0XHRleHRyYUlucHV0cy5wdXNoKFxuXHRcdFx0XHRcdFx0XHQkKCc8aW5wdXQgdHlwZT1cImhpZGRlblwiIG5hbWU9XCInK24rJ1wiPicpLmF0dHIoJ3ZhbHVlJyxzLmV4dHJhRGF0YVtuXSlcblx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kVG8oZm9ybSlbMF0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghcy5pZnJhbWVUYXJnZXQpIHtcblx0XHRcdFx0XHQvLyBhZGQgaWZyYW1lIHRvIGRvYyBhbmQgc3VibWl0IHRoZSBmb3JtXG5cdFx0XHRcdFx0JGlvLmFwcGVuZFRvKCdib2R5Jyk7XG5cdFx0XHRcdFx0aW8uYXR0YWNoRXZlbnQgPyBpby5hdHRhY2hFdmVudCgnb25sb2FkJywgY2IpIDogaW8uYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGNiLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2V0VGltZW91dChjaGVja1N0YXRlLDE1KTtcblx0XHRcdFx0Zm9ybS5zdWJtaXQoKTtcblx0XHRcdH1cblx0XHRcdGZpbmFsbHkge1xuXHRcdFx0XHQvLyByZXNldCBhdHRycyBhbmQgcmVtb3ZlIFwiZXh0cmFcIiBpbnB1dCBlbGVtZW50c1xuXHRcdFx0XHRmb3JtLnNldEF0dHJpYnV0ZSgnYWN0aW9uJyxhKTtcblx0XHRcdFx0aWYodCkge1xuXHRcdFx0XHRcdGZvcm0uc2V0QXR0cmlidXRlKCd0YXJnZXQnLCB0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkZm9ybS5yZW1vdmVBdHRyKCd0YXJnZXQnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkKGV4dHJhSW5wdXRzKS5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocy5mb3JjZVN5bmMpIHtcblx0XHRcdGRvU3VibWl0KCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c2V0VGltZW91dChkb1N1Ym1pdCwgMTApOyAvLyB0aGlzIGxldHMgZG9tIHVwZGF0ZXMgcmVuZGVyXG5cdFx0fVxuXG5cdFx0dmFyIGRhdGEsIGRvYywgZG9tQ2hlY2tDb3VudCA9IDUwLCBjYWxsYmFja1Byb2Nlc3NlZDtcblxuXHRcdGZ1bmN0aW9uIGNiKGUpIHtcblx0XHRcdGlmICh4aHIuYWJvcnRlZCB8fCBjYWxsYmFja1Byb2Nlc3NlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkb2MgPSBnZXREb2MoaW8pO1xuXHRcdFx0fVxuXHRcdFx0Y2F0Y2goZXgpIHtcblx0XHRcdFx0bG9nKCdjYW5ub3QgYWNjZXNzIHJlc3BvbnNlIGRvY3VtZW50OiAnLCBleCk7XG5cdFx0XHRcdGUgPSBTRVJWRVJfQUJPUlQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZSA9PT0gQ0xJRU5UX1RJTUVPVVRfQUJPUlQgJiYgeGhyKSB7XG5cdFx0XHRcdHhoci5hYm9ydCgndGltZW91dCcpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChlID09IFNFUlZFUl9BQk9SVCAmJiB4aHIpIHtcblx0XHRcdFx0eGhyLmFib3J0KCdzZXJ2ZXIgYWJvcnQnKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWRvYyB8fCBkb2MubG9jYXRpb24uaHJlZiA9PSBzLmlmcmFtZVNyYykge1xuXHRcdFx0XHQvLyByZXNwb25zZSBub3QgcmVjZWl2ZWQgeWV0XG5cdFx0XHRcdGlmICghdGltZWRPdXQpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aW8uZGV0YWNoRXZlbnQgPyBpby5kZXRhY2hFdmVudCgnb25sb2FkJywgY2IpIDogaW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGNiLCBmYWxzZSk7XG5cblx0XHRcdHZhciBzdGF0dXMgPSAnc3VjY2VzcycsIGVyck1zZztcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICh0aW1lZE91dCkge1xuXHRcdFx0XHRcdHRocm93ICd0aW1lb3V0Jztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBpc1htbCA9IHMuZGF0YVR5cGUgPT0gJ3htbCcgfHwgZG9jLlhNTERvY3VtZW50IHx8ICQuaXNYTUxEb2MoZG9jKTtcblx0XHRcdFx0bG9nKCdpc1htbD0nK2lzWG1sKTtcblx0XHRcdFx0aWYgKCFpc1htbCAmJiB3aW5kb3cub3BlcmEgJiYgKGRvYy5ib2R5ID09IG51bGwgfHwgZG9jLmJvZHkuaW5uZXJIVE1MID09ICcnKSkge1xuXHRcdFx0XHRcdGlmICgtLWRvbUNoZWNrQ291bnQpIHtcblx0XHRcdFx0XHRcdC8vIGluIHNvbWUgYnJvd3NlcnMgKE9wZXJhKSB0aGUgaWZyYW1lIERPTSBpcyBub3QgYWx3YXlzIHRyYXZlcnNhYmxlIHdoZW5cblx0XHRcdFx0XHRcdC8vIHRoZSBvbmxvYWQgY2FsbGJhY2sgZmlyZXMsIHNvIHdlIGxvb3AgYSBiaXQgdG8gYWNjb21tb2RhdGVcblx0XHRcdFx0XHRcdGxvZygncmVxdWVpbmcgb25Mb2FkIGNhbGxiYWNrLCBET00gbm90IGF2YWlsYWJsZScpO1xuXHRcdFx0XHRcdFx0c2V0VGltZW91dChjYiwgMjUwKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gbGV0IHRoaXMgZmFsbCB0aHJvdWdoIGJlY2F1c2Ugc2VydmVyIHJlc3BvbnNlIGNvdWxkIGJlIGFuIGVtcHR5IGRvY3VtZW50XG5cdFx0XHRcdFx0Ly9sb2coJ0NvdWxkIG5vdCBhY2Nlc3MgaWZyYW1lIERPTSBhZnRlciBtdXRpcGxlIHRyaWVzLicpO1xuXHRcdFx0XHRcdC8vdGhyb3cgJ0RPTUV4Y2VwdGlvbjogbm90IGF2YWlsYWJsZSc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL2xvZygncmVzcG9uc2UgZGV0ZWN0ZWQnKTtcblx0XHRcdFx0dmFyIGRvY1Jvb3QgPSBkb2MuYm9keSA/IGRvYy5ib2R5IDogZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdFx0eGhyLnJlc3BvbnNlVGV4dCA9IGRvY1Jvb3QgPyBkb2NSb290LmlubmVySFRNTCA6IG51bGw7XG5cdFx0XHRcdHhoci5yZXNwb25zZVhNTCA9IGRvYy5YTUxEb2N1bWVudCA/IGRvYy5YTUxEb2N1bWVudCA6IGRvYztcblx0XHRcdFx0aWYgKGlzWG1sKVxuXHRcdFx0XHRcdHMuZGF0YVR5cGUgPSAneG1sJztcblx0XHRcdFx0eGhyLmdldFJlc3BvbnNlSGVhZGVyID0gZnVuY3Rpb24oaGVhZGVyKXtcblx0XHRcdFx0XHR2YXIgaGVhZGVycyA9IHsnY29udGVudC10eXBlJzogcy5kYXRhVHlwZX07XG5cdFx0XHRcdFx0cmV0dXJuIGhlYWRlcnNbaGVhZGVyXTtcblx0XHRcdFx0fTtcblx0XHRcdFx0Ly8gc3VwcG9ydCBmb3IgWEhSICdzdGF0dXMnICYgJ3N0YXR1c1RleHQnIGVtdWxhdGlvbiA6XG5cdFx0XHRcdGlmIChkb2NSb290KSB7XG5cdFx0XHRcdFx0eGhyLnN0YXR1cyA9IE51bWJlciggZG9jUm9vdC5nZXRBdHRyaWJ1dGUoJ3N0YXR1cycpICkgfHwgeGhyLnN0YXR1cztcblx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCA9IGRvY1Jvb3QuZ2V0QXR0cmlidXRlKCdzdGF0dXNUZXh0JykgfHwgeGhyLnN0YXR1c1RleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZHQgPSAocy5kYXRhVHlwZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0dmFyIHNjciA9IC8oanNvbnxzY3JpcHR8dGV4dCkvLnRlc3QoZHQpO1xuXHRcdFx0XHRpZiAoc2NyIHx8IHMudGV4dGFyZWEpIHtcblx0XHRcdFx0XHQvLyBzZWUgaWYgdXNlciBlbWJlZGRlZCByZXNwb25zZSBpbiB0ZXh0YXJlYVxuXHRcdFx0XHRcdHZhciB0YSA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGV4dGFyZWEnKVswXTtcblx0XHRcdFx0XHRpZiAodGEpIHtcblx0XHRcdFx0XHRcdHhoci5yZXNwb25zZVRleHQgPSB0YS52YWx1ZTtcblx0XHRcdFx0XHRcdC8vIHN1cHBvcnQgZm9yIFhIUiAnc3RhdHVzJyAmICdzdGF0dXNUZXh0JyBlbXVsYXRpb24gOlxuXHRcdFx0XHRcdFx0eGhyLnN0YXR1cyA9IE51bWJlciggdGEuZ2V0QXR0cmlidXRlKCdzdGF0dXMnKSApIHx8IHhoci5zdGF0dXM7XG5cdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCA9IHRhLmdldEF0dHJpYnV0ZSgnc3RhdHVzVGV4dCcpIHx8IHhoci5zdGF0dXNUZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmIChzY3IpIHtcblx0XHRcdFx0XHRcdC8vIGFjY291bnQgZm9yIGJyb3dzZXJzIGluamVjdGluZyBwcmUgYXJvdW5kIGpzb24gcmVzcG9uc2Vcblx0XHRcdFx0XHRcdHZhciBwcmUgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ByZScpWzBdO1xuXHRcdFx0XHRcdFx0dmFyIGIgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXTtcblx0XHRcdFx0XHRcdGlmIChwcmUpIHtcblx0XHRcdFx0XHRcdFx0eGhyLnJlc3BvbnNlVGV4dCA9IHByZS50ZXh0Q29udGVudCA/IHByZS50ZXh0Q29udGVudCA6IHByZS5pbm5lclRleHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChiKSB7XG5cdFx0XHRcdFx0XHRcdHhoci5yZXNwb25zZVRleHQgPSBiLnRleHRDb250ZW50ID8gYi50ZXh0Q29udGVudCA6IGIuaW5uZXJUZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChkdCA9PSAneG1sJyAmJiAheGhyLnJlc3BvbnNlWE1MICYmIHhoci5yZXNwb25zZVRleHQgIT0gbnVsbCkge1xuXHRcdFx0XHRcdHhoci5yZXNwb25zZVhNTCA9IHRvWG1sKHhoci5yZXNwb25zZVRleHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRkYXRhID0gaHR0cERhdGEoeGhyLCBkdCwgcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRzdGF0dXMgPSAncGFyc2VyZXJyb3InO1xuXHRcdFx0XHRcdHhoci5lcnJvciA9IGVyck1zZyA9IChlIHx8IHN0YXR1cyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdGxvZygnZXJyb3IgY2F1Z2h0OiAnLGUpO1xuXHRcdFx0XHRzdGF0dXMgPSAnZXJyb3InO1xuXHRcdFx0XHR4aHIuZXJyb3IgPSBlcnJNc2cgPSAoZSB8fCBzdGF0dXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoeGhyLmFib3J0ZWQpIHtcblx0XHRcdFx0bG9nKCd1cGxvYWQgYWJvcnRlZCcpO1xuXHRcdFx0XHRzdGF0dXMgPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoeGhyLnN0YXR1cykgeyAvLyB3ZSd2ZSBzZXQgeGhyLnN0YXR1c1xuXHRcdFx0XHRzdGF0dXMgPSAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCB8fCB4aHIuc3RhdHVzID09PSAzMDQpID8gJ3N1Y2Nlc3MnIDogJ2Vycm9yJztcblx0XHRcdH1cblxuXHRcdFx0Ly8gb3JkZXJpbmcgb2YgdGhlc2UgY2FsbGJhY2tzL3RyaWdnZXJzIGlzIG9kZCwgYnV0IHRoYXQncyBob3cgJC5hamF4IGRvZXMgaXRcblx0XHRcdGlmIChzdGF0dXMgPT09ICdzdWNjZXNzJykge1xuXHRcdFx0XHRzLnN1Y2Nlc3MgJiYgcy5zdWNjZXNzLmNhbGwocy5jb250ZXh0LCBkYXRhLCAnc3VjY2VzcycsIHhocik7XG5cdFx0XHRcdGcgJiYgJC5ldmVudC50cmlnZ2VyKFwiYWpheFN1Y2Nlc3NcIiwgW3hociwgc10pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoc3RhdHVzKSB7XG5cdFx0XHRcdGlmIChlcnJNc2cgPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGVyck1zZyA9IHhoci5zdGF0dXNUZXh0O1xuXHRcdFx0XHRzLmVycm9yICYmIHMuZXJyb3IuY2FsbChzLmNvbnRleHQsIHhociwgc3RhdHVzLCBlcnJNc2cpO1xuXHRcdFx0XHRnICYmICQuZXZlbnQudHJpZ2dlcihcImFqYXhFcnJvclwiLCBbeGhyLCBzLCBlcnJNc2ddKTtcblx0XHRcdH1cblxuXHRcdFx0ZyAmJiAkLmV2ZW50LnRyaWdnZXIoXCJhamF4Q29tcGxldGVcIiwgW3hociwgc10pO1xuXG5cdFx0XHRpZiAoZyAmJiAhIC0tJC5hY3RpdmUpIHtcblx0XHRcdFx0JC5ldmVudC50cmlnZ2VyKFwiYWpheFN0b3BcIik7XG5cdFx0XHR9XG5cblx0XHRcdHMuY29tcGxldGUgJiYgcy5jb21wbGV0ZS5jYWxsKHMuY29udGV4dCwgeGhyLCBzdGF0dXMpO1xuXG5cdFx0XHRjYWxsYmFja1Byb2Nlc3NlZCA9IHRydWU7XG5cdFx0XHRpZiAocy50aW1lb3V0KVxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZSk7XG5cblx0XHRcdC8vIGNsZWFuIHVwXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIXMuaWZyYW1lVGFyZ2V0KVxuXHRcdFx0XHRcdCRpby5yZW1vdmUoKTtcblx0XHRcdFx0eGhyLnJlc3BvbnNlWE1MID0gbnVsbDtcblx0XHRcdH0sIDEwMCk7XG5cdFx0fVxuXG5cdFx0dmFyIHRvWG1sID0gJC5wYXJzZVhNTCB8fCBmdW5jdGlvbihzLCBkb2MpIHsgLy8gdXNlIHBhcnNlWE1MIGlmIGF2YWlsYWJsZSAoalF1ZXJ5IDEuNSspXG5cdFx0XHRpZiAod2luZG93LkFjdGl2ZVhPYmplY3QpIHtcblx0XHRcdFx0ZG9jID0gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxET00nKTtcblx0XHRcdFx0ZG9jLmFzeW5jID0gJ2ZhbHNlJztcblx0XHRcdFx0ZG9jLmxvYWRYTUwocyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZG9jID0gKG5ldyBET01QYXJzZXIoKSkucGFyc2VGcm9tU3RyaW5nKHMsICd0ZXh0L3htbCcpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIChkb2MgJiYgZG9jLmRvY3VtZW50RWxlbWVudCAmJiBkb2MuZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9ICdwYXJzZXJlcnJvcicpID8gZG9jIDogbnVsbDtcblx0XHR9O1xuXHRcdHZhciBwYXJzZUpTT04gPSAkLnBhcnNlSlNPTiB8fCBmdW5jdGlvbihzKSB7XG5cdFx0XHRyZXR1cm4gd2luZG93WydldmFsJ10oJygnICsgcyArICcpJyk7XG5cdFx0fTtcblxuXHRcdHZhciBodHRwRGF0YSA9IGZ1bmN0aW9uKCB4aHIsIHR5cGUsIHMgKSB7IC8vIG1vc3RseSBsaWZ0ZWQgZnJvbSBqcTEuNC40XG5cblx0XHRcdHZhciBjdCA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJykgfHwgJycsXG5cdFx0XHRcdHhtbCA9IHR5cGUgPT09ICd4bWwnIHx8ICF0eXBlICYmIGN0LmluZGV4T2YoJ3htbCcpID49IDAsXG5cdFx0XHRcdGRhdGEgPSB4bWwgPyB4aHIucmVzcG9uc2VYTUwgOiB4aHIucmVzcG9uc2VUZXh0O1xuXG5cdFx0XHRpZiAoeG1sICYmIGRhdGEuZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lID09PSAncGFyc2VyZXJyb3InKSB7XG5cdFx0XHRcdCQuZXJyb3IgJiYgJC5lcnJvcigncGFyc2VyZXJyb3InKTtcblx0XHRcdH1cblx0XHRcdGlmIChzICYmIHMuZGF0YUZpbHRlcikge1xuXHRcdFx0XHRkYXRhID0gcy5kYXRhRmlsdGVyKGRhdGEsIHR5cGUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2pzb24nIHx8ICF0eXBlICYmIGN0LmluZGV4T2YoJ2pzb24nKSA+PSAwKSB7XG5cdFx0XHRcdFx0ZGF0YSA9IHBhcnNlSlNPTihkYXRhKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSBcInNjcmlwdFwiIHx8ICF0eXBlICYmIGN0LmluZGV4T2YoXCJqYXZhc2NyaXB0XCIpID49IDApIHtcblx0XHRcdFx0XHQkLmdsb2JhbEV2YWwoZGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH07XG5cdH1cbn07XG5cbi8qKlxuICogYWpheEZvcm0oKSBwcm92aWRlcyBhIG1lY2hhbmlzbSBmb3IgZnVsbHkgYXV0b21hdGluZyBmb3JtIHN1Ym1pc3Npb24uXG4gKlxuICogVGhlIGFkdmFudGFnZXMgb2YgdXNpbmcgdGhpcyBtZXRob2QgaW5zdGVhZCBvZiBhamF4U3VibWl0KCkgYXJlOlxuICpcbiAqIDE6IFRoaXMgbWV0aG9kIHdpbGwgaW5jbHVkZSBjb29yZGluYXRlcyBmb3IgPGlucHV0IHR5cGU9XCJpbWFnZVwiIC8+IGVsZW1lbnRzIChpZiB0aGUgZWxlbWVudFxuICpcdGlzIHVzZWQgdG8gc3VibWl0IHRoZSBmb3JtKS5cbiAqIDIuIFRoaXMgbWV0aG9kIHdpbGwgaW5jbHVkZSB0aGUgc3VibWl0IGVsZW1lbnQncyBuYW1lL3ZhbHVlIGRhdGEgKGZvciB0aGUgZWxlbWVudCB0aGF0IHdhc1xuICpcdHVzZWQgdG8gc3VibWl0IHRoZSBmb3JtKS5cbiAqIDMuIFRoaXMgbWV0aG9kIGJpbmRzIHRoZSBzdWJtaXQoKSBtZXRob2QgdG8gdGhlIGZvcm0gZm9yIHlvdS5cbiAqXG4gKiBUaGUgb3B0aW9ucyBhcmd1bWVudCBmb3IgYWpheEZvcm0gd29ya3MgZXhhY3RseSBhcyBpdCBkb2VzIGZvciBhamF4U3VibWl0LiAgYWpheEZvcm0gbWVyZWx5XG4gKiBwYXNzZXMgdGhlIG9wdGlvbnMgYXJndW1lbnQgYWxvbmcgYWZ0ZXIgcHJvcGVybHkgYmluZGluZyBldmVudHMgZm9yIHN1Ym1pdCBlbGVtZW50cyBhbmRcbiAqIHRoZSBmb3JtIGl0c2VsZi5cbiAqL1xuJC5mbi5hamF4Rm9ybSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdG9wdGlvbnMuZGVsZWdhdGlvbiA9IG9wdGlvbnMuZGVsZWdhdGlvbiAmJiAkLmlzRnVuY3Rpb24oJC5mbi5vbik7XG5cdFxuXHQvLyBpbiBqUXVlcnkgMS4zKyB3ZSBjYW4gZml4IG1pc3Rha2VzIHdpdGggdGhlIHJlYWR5IHN0YXRlXG5cdGlmICghb3B0aW9ucy5kZWxlZ2F0aW9uICYmIHRoaXMubGVuZ3RoID09PSAwKSB7XG5cdFx0dmFyIG8gPSB7IHM6IHRoaXMuc2VsZWN0b3IsIGM6IHRoaXMuY29udGV4dCB9O1xuXHRcdGlmICghJC5pc1JlYWR5ICYmIG8ucykge1xuXHRcdFx0bG9nKCdET00gbm90IHJlYWR5LCBxdWV1aW5nIGFqYXhGb3JtJyk7XG5cdFx0XHQkKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkKG8ucyxvLmMpLmFqYXhGb3JtKG9wdGlvbnMpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0Ly8gaXMgeW91ciBET00gcmVhZHk/ICBodHRwOi8vZG9jcy5qcXVlcnkuY29tL1R1dG9yaWFsczpJbnRyb2R1Y2luZ18kKGRvY3VtZW50KS5yZWFkeSgpXG5cdFx0bG9nKCd0ZXJtaW5hdGluZzsgemVybyBlbGVtZW50cyBmb3VuZCBieSBzZWxlY3RvcicgKyAoJC5pc1JlYWR5ID8gJycgOiAnIChET00gbm90IHJlYWR5KScpKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGlmICggb3B0aW9ucy5kZWxlZ2F0aW9uICkge1xuXHRcdCQoZG9jdW1lbnQpXG5cdFx0XHQub2ZmKCdzdWJtaXQuZm9ybS1wbHVnaW4nLCB0aGlzLnNlbGVjdG9yLCBkb0FqYXhTdWJtaXQpXG5cdFx0XHQub2ZmKCdjbGljay5mb3JtLXBsdWdpbicsIHRoaXMuc2VsZWN0b3IsIGNhcHR1cmVTdWJtaXR0aW5nRWxlbWVudClcblx0XHRcdC5vbignc3VibWl0LmZvcm0tcGx1Z2luJywgdGhpcy5zZWxlY3Rvciwgb3B0aW9ucywgZG9BamF4U3VibWl0KVxuXHRcdFx0Lm9uKCdjbGljay5mb3JtLXBsdWdpbicsIHRoaXMuc2VsZWN0b3IsIG9wdGlvbnMsIGNhcHR1cmVTdWJtaXR0aW5nRWxlbWVudCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5hamF4Rm9ybVVuYmluZCgpXG5cdFx0LmJpbmQoJ3N1Ym1pdC5mb3JtLXBsdWdpbicsIG9wdGlvbnMsIGRvQWpheFN1Ym1pdClcblx0XHQuYmluZCgnY2xpY2suZm9ybS1wbHVnaW4nLCBvcHRpb25zLCBjYXB0dXJlU3VibWl0dGluZ0VsZW1lbnQpO1xufTtcblxuLy8gcHJpdmF0ZSBldmVudCBoYW5kbGVyc1x0XG5mdW5jdGlvbiBkb0FqYXhTdWJtaXQoZSkge1xuXHR2YXIgb3B0aW9ucyA9IGUuZGF0YTtcblx0aWYgKCFlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7IC8vIGlmIGV2ZW50IGhhcyBiZWVuIGNhbmNlbGVkLCBkb24ndCBwcm9jZWVkXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdCQodGhpcykuYWpheFN1Ym1pdChvcHRpb25zKTtcblx0fVxufVxuXHRcbmZ1bmN0aW9uIGNhcHR1cmVTdWJtaXR0aW5nRWxlbWVudChlKSB7XG5cdHZhciB0YXJnZXQgPSBlLnRhcmdldDtcblx0dmFyICRlbCA9ICQodGFyZ2V0KTtcblx0aWYgKCEoJGVsLmlzKFwiOnN1Ym1pdCxpbnB1dDppbWFnZVwiKSkpIHtcblx0XHQvLyBpcyB0aGlzIGEgY2hpbGQgZWxlbWVudCBvZiB0aGUgc3VibWl0IGVsPyAgKGV4OiBhIHNwYW4gd2l0aGluIGEgYnV0dG9uKVxuXHRcdHZhciB0ID0gJGVsLmNsb3Nlc3QoJzpzdWJtaXQnKTtcblx0XHRpZiAodC5sZW5ndGggPT0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0YXJnZXQgPSB0WzBdO1xuXHR9XG5cdHZhciBmb3JtID0gdGhpcztcblx0Zm9ybS5jbGsgPSB0YXJnZXQ7XG5cdGlmICh0YXJnZXQudHlwZSA9PSAnaW1hZ2UnKSB7XG5cdFx0aWYgKGUub2Zmc2V0WCAhPSB1bmRlZmluZWQpIHtcblx0XHRcdGZvcm0uY2xrX3ggPSBlLm9mZnNldFg7XG5cdFx0XHRmb3JtLmNsa195ID0gZS5vZmZzZXRZO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mICQuZm4ub2Zmc2V0ID09ICdmdW5jdGlvbicpIHtcblx0XHRcdHZhciBvZmZzZXQgPSAkZWwub2Zmc2V0KCk7XG5cdFx0XHRmb3JtLmNsa194ID0gZS5wYWdlWCAtIG9mZnNldC5sZWZ0O1xuXHRcdFx0Zm9ybS5jbGtfeSA9IGUucGFnZVkgLSBvZmZzZXQudG9wO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3JtLmNsa194ID0gZS5wYWdlWCAtIHRhcmdldC5vZmZzZXRMZWZ0O1xuXHRcdFx0Zm9ybS5jbGtfeSA9IGUucGFnZVkgLSB0YXJnZXQub2Zmc2V0VG9wO1xuXHRcdH1cblx0fVxuXHQvLyBjbGVhciBmb3JtIHZhcnNcblx0c2V0VGltZW91dChmdW5jdGlvbigpIHsgZm9ybS5jbGsgPSBmb3JtLmNsa194ID0gZm9ybS5jbGtfeSA9IG51bGw7IH0sIDEwMCk7XG59O1xuXG5cbi8vIGFqYXhGb3JtVW5iaW5kIHVuYmluZHMgdGhlIGV2ZW50IGhhbmRsZXJzIHRoYXQgd2VyZSBib3VuZCBieSBhamF4Rm9ybVxuJC5mbi5hamF4Rm9ybVVuYmluZCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy51bmJpbmQoJ3N1Ym1pdC5mb3JtLXBsdWdpbiBjbGljay5mb3JtLXBsdWdpbicpO1xufTtcblxuLyoqXG4gKiBmb3JtVG9BcnJheSgpIGdhdGhlcnMgZm9ybSBlbGVtZW50IGRhdGEgaW50byBhbiBhcnJheSBvZiBvYmplY3RzIHRoYXQgY2FuXG4gKiBiZSBwYXNzZWQgdG8gYW55IG9mIHRoZSBmb2xsb3dpbmcgYWpheCBmdW5jdGlvbnM6ICQuZ2V0LCAkLnBvc3QsIG9yIGxvYWQuXG4gKiBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXkgaGFzIGJvdGggYSAnbmFtZScgYW5kICd2YWx1ZScgcHJvcGVydHkuICBBbiBleGFtcGxlIG9mXG4gKiBhbiBhcnJheSBmb3IgYSBzaW1wbGUgbG9naW4gZm9ybSBtaWdodCBiZTpcbiAqXG4gKiBbIHsgbmFtZTogJ3VzZXJuYW1lJywgdmFsdWU6ICdqcmVzaWcnIH0sIHsgbmFtZTogJ3Bhc3N3b3JkJywgdmFsdWU6ICdzZWNyZXQnIH0gXVxuICpcbiAqIEl0IGlzIHRoaXMgYXJyYXkgdGhhdCBpcyBwYXNzZWQgdG8gcHJlLXN1Ym1pdCBjYWxsYmFjayBmdW5jdGlvbnMgcHJvdmlkZWQgdG8gdGhlXG4gKiBhamF4U3VibWl0KCkgYW5kIGFqYXhGb3JtKCkgbWV0aG9kcy5cbiAqL1xuJC5mbi5mb3JtVG9BcnJheSA9IGZ1bmN0aW9uKHNlbWFudGljKSB7XG5cdHZhciBhID0gW107XG5cdGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiBhO1xuXHR9XG5cblx0dmFyIGZvcm0gPSB0aGlzWzBdO1xuXHR2YXIgZWxzID0gc2VtYW50aWMgPyBmb3JtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykgOiBmb3JtLmVsZW1lbnRzO1xuXHRpZiAoIWVscykge1xuXHRcdHJldHVybiBhO1xuXHR9XG5cblx0dmFyIGksaixuLHYsZWwsbWF4LGptYXg7XG5cdGZvcihpPTAsIG1heD1lbHMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcblx0XHRlbCA9IGVsc1tpXTtcblx0XHRuID0gZWwubmFtZTtcblx0XHRpZiAoIW4pIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmIChzZW1hbnRpYyAmJiBmb3JtLmNsayAmJiBlbC50eXBlID09IFwiaW1hZ2VcIikge1xuXHRcdFx0Ly8gaGFuZGxlIGltYWdlIGlucHV0cyBvbiB0aGUgZmx5IHdoZW4gc2VtYW50aWMgPT0gdHJ1ZVxuXHRcdFx0aWYoIWVsLmRpc2FibGVkICYmIGZvcm0uY2xrID09IGVsKSB7XG5cdFx0XHRcdGEucHVzaCh7bmFtZTogbiwgdmFsdWU6ICQoZWwpLnZhbCgpLCB0eXBlOiBlbC50eXBlIH0pO1xuXHRcdFx0XHRhLnB1c2goe25hbWU6IG4rJy54JywgdmFsdWU6IGZvcm0uY2xrX3h9LCB7bmFtZTogbisnLnknLCB2YWx1ZTogZm9ybS5jbGtfeX0pO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0diA9ICQuZmllbGRWYWx1ZShlbCwgdHJ1ZSk7XG5cdFx0aWYgKHYgJiYgdi5jb25zdHJ1Y3RvciA9PSBBcnJheSkge1xuXHRcdFx0Zm9yKGo9MCwgam1heD12Lmxlbmd0aDsgaiA8IGptYXg7IGorKykge1xuXHRcdFx0XHRhLnB1c2goe25hbWU6IG4sIHZhbHVlOiB2W2pdfSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHYgIT09IG51bGwgJiYgdHlwZW9mIHYgIT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdGEucHVzaCh7bmFtZTogbiwgdmFsdWU6IHYsIHR5cGU6IGVsLnR5cGV9KTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIXNlbWFudGljICYmIGZvcm0uY2xrKSB7XG5cdFx0Ly8gaW5wdXQgdHlwZT09J2ltYWdlJyBhcmUgbm90IGZvdW5kIGluIGVsZW1lbnRzIGFycmF5ISBoYW5kbGUgaXQgaGVyZVxuXHRcdHZhciAkaW5wdXQgPSAkKGZvcm0uY2xrKSwgaW5wdXQgPSAkaW5wdXRbMF07XG5cdFx0biA9IGlucHV0Lm5hbWU7XG5cdFx0aWYgKG4gJiYgIWlucHV0LmRpc2FibGVkICYmIGlucHV0LnR5cGUgPT0gJ2ltYWdlJykge1xuXHRcdFx0YS5wdXNoKHtuYW1lOiBuLCB2YWx1ZTogJGlucHV0LnZhbCgpfSk7XG5cdFx0XHRhLnB1c2goe25hbWU6IG4rJy54JywgdmFsdWU6IGZvcm0uY2xrX3h9LCB7bmFtZTogbisnLnknLCB2YWx1ZTogZm9ybS5jbGtfeX0pO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYTtcbn07XG5cbi8qKlxuICogU2VyaWFsaXplcyBmb3JtIGRhdGEgaW50byBhICdzdWJtaXR0YWJsZScgc3RyaW5nLiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBhIHN0cmluZ1xuICogaW4gdGhlIGZvcm1hdDogbmFtZTE9dmFsdWUxJmFtcDtuYW1lMj12YWx1ZTJcbiAqL1xuJC5mbi5mb3JtU2VyaWFsaXplID0gZnVuY3Rpb24oc2VtYW50aWMpIHtcblx0Ly9oYW5kIG9mZiB0byBqUXVlcnkucGFyYW0gZm9yIHByb3BlciBlbmNvZGluZ1xuXHRyZXR1cm4gJC5wYXJhbSh0aGlzLmZvcm1Ub0FycmF5KHNlbWFudGljKSk7XG59O1xuXG4vKipcbiAqIFNlcmlhbGl6ZXMgYWxsIGZpZWxkIGVsZW1lbnRzIGluIHRoZSBqUXVlcnkgb2JqZWN0IGludG8gYSBxdWVyeSBzdHJpbmcuXG4gKiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBhIHN0cmluZyBpbiB0aGUgZm9ybWF0OiBuYW1lMT12YWx1ZTEmYW1wO25hbWUyPXZhbHVlMlxuICovXG4kLmZuLmZpZWxkU2VyaWFsaXplID0gZnVuY3Rpb24oc3VjY2Vzc2Z1bCkge1xuXHR2YXIgYSA9IFtdO1xuXHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG4gPSB0aGlzLm5hbWU7XG5cdFx0aWYgKCFuKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciB2ID0gJC5maWVsZFZhbHVlKHRoaXMsIHN1Y2Nlc3NmdWwpO1xuXHRcdGlmICh2ICYmIHYuY29uc3RydWN0b3IgPT0gQXJyYXkpIHtcblx0XHRcdGZvciAodmFyIGk9MCxtYXg9di5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuXHRcdFx0XHRhLnB1c2goe25hbWU6IG4sIHZhbHVlOiB2W2ldfSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHYgIT09IG51bGwgJiYgdHlwZW9mIHYgIT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdGEucHVzaCh7bmFtZTogdGhpcy5uYW1lLCB2YWx1ZTogdn0pO1xuXHRcdH1cblx0fSk7XG5cdC8vaGFuZCBvZmYgdG8galF1ZXJ5LnBhcmFtIGZvciBwcm9wZXIgZW5jb2Rpbmdcblx0cmV0dXJuICQucGFyYW0oYSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlKHMpIG9mIHRoZSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC4gIEZvciBleGFtcGxlLCBjb25zaWRlciB0aGUgZm9sbG93aW5nIGZvcm06XG4gKlxuICogIDxmb3JtPjxmaWVsZHNldD5cbiAqXHQgIDxpbnB1dCBuYW1lPVwiQVwiIHR5cGU9XCJ0ZXh0XCIgLz5cbiAqXHQgIDxpbnB1dCBuYW1lPVwiQVwiIHR5cGU9XCJ0ZXh0XCIgLz5cbiAqXHQgIDxpbnB1dCBuYW1lPVwiQlwiIHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwiQjFcIiAvPlxuICpcdCAgPGlucHV0IG5hbWU9XCJCXCIgdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9XCJCMlwiLz5cbiAqXHQgIDxpbnB1dCBuYW1lPVwiQ1wiIHR5cGU9XCJyYWRpb1wiIHZhbHVlPVwiQzFcIiAvPlxuICpcdCAgPGlucHV0IG5hbWU9XCJDXCIgdHlwZT1cInJhZGlvXCIgdmFsdWU9XCJDMlwiIC8+XG4gKiAgPC9maWVsZHNldD48L2Zvcm0+XG4gKlxuICogIHZhciB2ID0gJCgnOnRleHQnKS5maWVsZFZhbHVlKCk7XG4gKiAgLy8gaWYgbm8gdmFsdWVzIGFyZSBlbnRlcmVkIGludG8gdGhlIHRleHQgaW5wdXRzXG4gKiAgdiA9PSBbJycsJyddXG4gKiAgLy8gaWYgdmFsdWVzIGVudGVyZWQgaW50byB0aGUgdGV4dCBpbnB1dHMgYXJlICdmb28nIGFuZCAnYmFyJ1xuICogIHYgPT0gWydmb28nLCdiYXInXVxuICpcbiAqICB2YXIgdiA9ICQoJzpjaGVja2JveCcpLmZpZWxkVmFsdWUoKTtcbiAqICAvLyBpZiBuZWl0aGVyIGNoZWNrYm94IGlzIGNoZWNrZWRcbiAqICB2ID09PSB1bmRlZmluZWRcbiAqICAvLyBpZiBib3RoIGNoZWNrYm94ZXMgYXJlIGNoZWNrZWRcbiAqICB2ID09IFsnQjEnLCAnQjInXVxuICpcbiAqICB2YXIgdiA9ICQoJzpyYWRpbycpLmZpZWxkVmFsdWUoKTtcbiAqICAvLyBpZiBuZWl0aGVyIHJhZGlvIGlzIGNoZWNrZWRcbiAqICB2ID09PSB1bmRlZmluZWRcbiAqICAvLyBpZiBmaXJzdCByYWRpbyBpcyBjaGVja2VkXG4gKiAgdiA9PSBbJ0MxJ11cbiAqXG4gKiBUaGUgc3VjY2Vzc2Z1bCBhcmd1bWVudCBjb250cm9scyB3aGV0aGVyIG9yIG5vdCB0aGUgZmllbGQgZWxlbWVudCBtdXN0IGJlICdzdWNjZXNzZnVsJ1xuICogKHBlciBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNC9pbnRlcmFjdC9mb3Jtcy5odG1sI3N1Y2Nlc3NmdWwtY29udHJvbHMpLlxuICogVGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhlIHN1Y2Nlc3NmdWwgYXJndW1lbnQgaXMgdHJ1ZS4gIElmIHRoaXMgdmFsdWUgaXMgZmFsc2UgdGhlIHZhbHVlKHMpXG4gKiBmb3IgZWFjaCBlbGVtZW50IGlzIHJldHVybmVkLlxuICpcbiAqIE5vdGU6IFRoaXMgbWV0aG9kICphbHdheXMqIHJldHVybnMgYW4gYXJyYXkuICBJZiBubyB2YWxpZCB2YWx1ZSBjYW4gYmUgZGV0ZXJtaW5lZCB0aGVcbiAqXHRhcnJheSB3aWxsIGJlIGVtcHR5LCBvdGhlcndpc2UgaXQgd2lsbCBjb250YWluIG9uZSBvciBtb3JlIHZhbHVlcy5cbiAqL1xuJC5mbi5maWVsZFZhbHVlID0gZnVuY3Rpb24oc3VjY2Vzc2Z1bCkge1xuXHRmb3IgKHZhciB2YWw9W10sIGk9MCwgbWF4PXRoaXMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcblx0XHR2YXIgZWwgPSB0aGlzW2ldO1xuXHRcdHZhciB2ID0gJC5maWVsZFZhbHVlKGVsLCBzdWNjZXNzZnVsKTtcblx0XHRpZiAodiA9PT0gbnVsbCB8fCB0eXBlb2YgdiA9PSAndW5kZWZpbmVkJyB8fCAodi5jb25zdHJ1Y3RvciA9PSBBcnJheSAmJiAhdi5sZW5ndGgpKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0di5jb25zdHJ1Y3RvciA9PSBBcnJheSA/ICQubWVyZ2UodmFsLCB2KSA6IHZhbC5wdXNoKHYpO1xuXHR9XG5cdHJldHVybiB2YWw7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmaWVsZCBlbGVtZW50LlxuICovXG4kLmZpZWxkVmFsdWUgPSBmdW5jdGlvbihlbCwgc3VjY2Vzc2Z1bCkge1xuXHR2YXIgbiA9IGVsLm5hbWUsIHQgPSBlbC50eXBlLCB0YWcgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdGlmIChzdWNjZXNzZnVsID09PSB1bmRlZmluZWQpIHtcblx0XHRzdWNjZXNzZnVsID0gdHJ1ZTtcblx0fVxuXG5cdGlmIChzdWNjZXNzZnVsICYmICghbiB8fCBlbC5kaXNhYmxlZCB8fCB0ID09ICdyZXNldCcgfHwgdCA9PSAnYnV0dG9uJyB8fFxuXHRcdCh0ID09ICdjaGVja2JveCcgfHwgdCA9PSAncmFkaW8nKSAmJiAhZWwuY2hlY2tlZCB8fFxuXHRcdCh0ID09ICdzdWJtaXQnIHx8IHQgPT0gJ2ltYWdlJykgJiYgZWwuZm9ybSAmJiBlbC5mb3JtLmNsayAhPSBlbCB8fFxuXHRcdHRhZyA9PSAnc2VsZWN0JyAmJiBlbC5zZWxlY3RlZEluZGV4ID09IC0xKSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRpZiAodGFnID09ICdzZWxlY3QnKSB7XG5cdFx0dmFyIGluZGV4ID0gZWwuc2VsZWN0ZWRJbmRleDtcblx0XHRpZiAoaW5kZXggPCAwKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0dmFyIGEgPSBbXSwgb3BzID0gZWwub3B0aW9ucztcblx0XHR2YXIgb25lID0gKHQgPT0gJ3NlbGVjdC1vbmUnKTtcblx0XHR2YXIgbWF4ID0gKG9uZSA/IGluZGV4KzEgOiBvcHMubGVuZ3RoKTtcblx0XHRmb3IodmFyIGk9KG9uZSA/IGluZGV4IDogMCk7IGkgPCBtYXg7IGkrKykge1xuXHRcdFx0dmFyIG9wID0gb3BzW2ldO1xuXHRcdFx0aWYgKG9wLnNlbGVjdGVkKSB7XG5cdFx0XHRcdHZhciB2ID0gb3AudmFsdWU7XG5cdFx0XHRcdGlmICghdikgeyAvLyBleHRyYSBwYWluIGZvciBJRS4uLlxuXHRcdFx0XHRcdHYgPSAob3AuYXR0cmlidXRlcyAmJiBvcC5hdHRyaWJ1dGVzWyd2YWx1ZSddICYmICEob3AuYXR0cmlidXRlc1sndmFsdWUnXS5zcGVjaWZpZWQpKSA/IG9wLnRleHQgOiBvcC52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob25lKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHY7XG5cdFx0XHRcdH1cblx0XHRcdFx0YS5wdXNoKHYpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYTtcblx0fVxuXHRyZXR1cm4gJChlbCkudmFsKCk7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgZm9ybSBkYXRhLiAgVGFrZXMgdGhlIGZvbGxvd2luZyBhY3Rpb25zIG9uIHRoZSBmb3JtJ3MgaW5wdXQgZmllbGRzOlxuICogIC0gaW5wdXQgdGV4dCBmaWVsZHMgd2lsbCBoYXZlIHRoZWlyICd2YWx1ZScgcHJvcGVydHkgc2V0IHRvIHRoZSBlbXB0eSBzdHJpbmdcbiAqICAtIHNlbGVjdCBlbGVtZW50cyB3aWxsIGhhdmUgdGhlaXIgJ3NlbGVjdGVkSW5kZXgnIHByb3BlcnR5IHNldCB0byAtMVxuICogIC0gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cyB3aWxsIGhhdmUgdGhlaXIgJ2NoZWNrZWQnIHByb3BlcnR5IHNldCB0byBmYWxzZVxuICogIC0gaW5wdXRzIG9mIHR5cGUgc3VibWl0LCBidXR0b24sIHJlc2V0LCBhbmQgaGlkZGVuIHdpbGwgKm5vdCogYmUgZWZmZWN0ZWRcbiAqICAtIGJ1dHRvbiBlbGVtZW50cyB3aWxsICpub3QqIGJlIGVmZmVjdGVkXG4gKi9cbiQuZm4uY2xlYXJGb3JtID0gZnVuY3Rpb24oaW5jbHVkZUhpZGRlbikge1xuXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdCQoJ2lucHV0LHNlbGVjdCx0ZXh0YXJlYScsIHRoaXMpLmNsZWFyRmllbGRzKGluY2x1ZGVIaWRkZW4pO1xuXHR9KTtcbn07XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBzZWxlY3RlZCBmb3JtIGVsZW1lbnRzLlxuICovXG4kLmZuLmNsZWFyRmllbGRzID0gJC5mbi5jbGVhcklucHV0cyA9IGZ1bmN0aW9uKGluY2x1ZGVIaWRkZW4pIHtcblx0dmFyIHJlID0gL14oPzpjb2xvcnxkYXRlfGRhdGV0aW1lfGVtYWlsfG1vbnRofG51bWJlcnxwYXNzd29yZHxyYW5nZXxzZWFyY2h8dGVsfHRleHR8dGltZXx1cmx8d2VlaykkL2k7IC8vICdoaWRkZW4nIGlzIG5vdCBpbiB0aGlzIGxpc3Rcblx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHR2YXIgdCA9IHRoaXMudHlwZSwgdGFnID0gdGhpcy50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0aWYgKHJlLnRlc3QodCkgfHwgdGFnID09ICd0ZXh0YXJlYScgfHwgKGluY2x1ZGVIaWRkZW4gJiYgL2hpZGRlbi8udGVzdCh0KSkgKSB7XG5cdFx0XHR0aGlzLnZhbHVlID0gJyc7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHQgPT0gJ2NoZWNrYm94JyB8fCB0ID09ICdyYWRpbycpIHtcblx0XHRcdHRoaXMuY2hlY2tlZCA9IGZhbHNlO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0YWcgPT0gJ3NlbGVjdCcpIHtcblx0XHRcdHRoaXMuc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdH1cblx0fSk7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0aGUgZm9ybSBkYXRhLiAgQ2F1c2VzIGFsbCBmb3JtIGVsZW1lbnRzIHRvIGJlIHJlc2V0IHRvIHRoZWlyIG9yaWdpbmFsIHZhbHVlLlxuICovXG4kLmZuLnJlc2V0Rm9ybSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdC8vIGd1YXJkIGFnYWluc3QgYW4gaW5wdXQgd2l0aCB0aGUgbmFtZSBvZiAncmVzZXQnXG5cdFx0Ly8gbm90ZSB0aGF0IElFIHJlcG9ydHMgdGhlIHJlc2V0IGZ1bmN0aW9uIGFzIGFuICdvYmplY3QnXG5cdFx0aWYgKHR5cGVvZiB0aGlzLnJlc2V0ID09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiB0aGlzLnJlc2V0ID09ICdvYmplY3QnICYmICF0aGlzLnJlc2V0Lm5vZGVUeXBlKSkge1xuXHRcdFx0dGhpcy5yZXNldCgpO1xuXHRcdH1cblx0fSk7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgYW55IG1hdGNoaW5nIGVsZW1lbnRzLlxuICovXG4kLmZuLmVuYWJsZSA9IGZ1bmN0aW9uKGIpIHtcblx0aWYgKGIgPT09IHVuZGVmaW5lZCkge1xuXHRcdGIgPSB0cnVlO1xuXHR9XG5cdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kaXNhYmxlZCA9ICFiO1xuXHR9KTtcbn07XG5cbi8qKlxuICogQ2hlY2tzL3VuY2hlY2tzIGFueSBtYXRjaGluZyBjaGVja2JveGVzIG9yIHJhZGlvIGJ1dHRvbnMgYW5kXG4gKiBzZWxlY3RzL2Rlc2VsZWN0cyBhbmQgbWF0Y2hpbmcgb3B0aW9uIGVsZW1lbnRzLlxuICovXG4kLmZuLnNlbGVjdGVkID0gZnVuY3Rpb24oc2VsZWN0KSB7XG5cdGlmIChzZWxlY3QgPT09IHVuZGVmaW5lZCkge1xuXHRcdHNlbGVjdCA9IHRydWU7XG5cdH1cblx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHR2YXIgdCA9IHRoaXMudHlwZTtcblx0XHRpZiAodCA9PSAnY2hlY2tib3gnIHx8IHQgPT0gJ3JhZGlvJykge1xuXHRcdFx0dGhpcy5jaGVja2VkID0gc2VsZWN0O1xuXHRcdH1cblx0XHRlbHNlIGlmICh0aGlzLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSAnb3B0aW9uJykge1xuXHRcdFx0dmFyICRzZWwgPSAkKHRoaXMpLnBhcmVudCgnc2VsZWN0Jyk7XG5cdFx0XHRpZiAoc2VsZWN0ICYmICRzZWxbMF0gJiYgJHNlbFswXS50eXBlID09ICdzZWxlY3Qtb25lJykge1xuXHRcdFx0XHQvLyBkZXNlbGVjdCBhbGwgb3RoZXIgb3B0aW9uc1xuXHRcdFx0XHQkc2VsLmZpbmQoJ29wdGlvbicpLnNlbGVjdGVkKGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3Q7XG5cdFx0fVxuXHR9KTtcbn07XG5cbi8vIGV4cG9zZSBkZWJ1ZyB2YXJcbiQuZm4uYWpheFN1Ym1pdC5kZWJ1ZyA9IGZhbHNlO1xuXG4vLyBoZWxwZXIgZm4gZm9yIGNvbnNvbGUgbG9nZ2luZ1xuZnVuY3Rpb24gbG9nKCkge1xuXHRpZiAoISQuZm4uYWpheFN1Ym1pdC5kZWJ1ZykgXG5cdFx0cmV0dXJuO1xuXHR2YXIgbXNnID0gJ1tqcXVlcnkuZm9ybV0gJyArIEFycmF5LnByb3RvdHlwZS5qb2luLmNhbGwoYXJndW1lbnRzLCcnKTtcblx0aWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmxvZykge1xuXHRcdHdpbmRvdy5jb25zb2xlLmxvZyhtc2cpO1xuXHR9XG5cdGVsc2UgaWYgKHdpbmRvdy5vcGVyYSAmJiB3aW5kb3cub3BlcmEucG9zdEVycm9yKSB7XG5cdFx0d2luZG93Lm9wZXJhLnBvc3RFcnJvcihtc2cpO1xuXHR9XG59O1xuXG59KShqUXVlcnkpOyIsIi8qKlxuICogT24tZGVtYW5kIEphdmFTY3JpcHQgaGFuZGxlclxuICpcbiAqIEJhc2VkIG9uIGh0dHA6Ly9wbHVnaW5zLmpxdWVyeS5jb20vZmlsZXMvaXNzdWVzL2pxdWVyeS5vbmRlbWFuZC5qc18udHh0XG4gKiBhbmQgaGVhdmlseSBtb2RpZmllZCB0byBpbnRlZ3JhdGUgd2l0aCBTaWx2ZXJTdHJpcGUgYW5kIHByb3RvdHlwZS5qcy5cbiAqIEFkZHMgY2FwYWJpbGl0aWVzIGZvciBjdXN0b20gWC1JbmNsdWRlLUNTUyBhbmQgWC1JbmNsdWRlLUpTIEhUVFAgaGVhZGVyc1xuICogdG8gcmVxdWVzdCBsb2FkaW5nIG9mIGV4dGVybmFscyBhbG9uZ3NpZGUgYW4gYWpheCByZXNwb25zZS5cbiAqXG4gKiBSZXF1aXJlcyBqUXVlcnkgMS41ICgkLkRlZmVycmVkIHN1cHBvcnQpXG4gKlxuICogQ0FVVElPTjogUmVsaWVzIG9uIGN1c3RvbWl6YXRpb24gb2YgdGhlICdiZWZvcmVTZW5kJyBjYWxsYmFjayBpbiBqUXVlcnkuYWpheFNldHVwKClcbiAqXG4gKiBAYXV0aG9yIEluZ28gU2Nob21tZXIgKGluZ28gYXQgc2lsdmVyc3RyaXBlIGRvdCBjb20pXG4gKiBAYXV0aG9yIFNhbSBNaW5uZWUgKHNhbSBhdCBzaWx2ZXJzdHJpcGUgZG90IGNvbSlcbiAqL1xuKGZ1bmN0aW9uKCQpe1xuXG5cdHZhciBkZWNvZGVQYXRoID0gZnVuY3Rpb24oc3RyKSB7XG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8lMkMvZywnLCcpLnJlcGxhY2UoL1xcJmFtcDsvZywgJyYnKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG5cdH07XG5cblx0JC5leHRlbmQoe1xuXG5cdFx0Ly8gbG9hZGVkIGZpbGVzIGxpc3QgLSB0byBwcm90ZWN0IGFnYWluc3QgbG9hZGluZyBleGlzdGVkIGZpbGUgYWdhaW4gIChieSBQR0EpXG5cdFx0X29uZGVtYW5kX2xvYWRlZF9saXN0IDogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gQ1NTIG9yIEpTIHNjcmlwdCBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZFxuXHRcdCAqL1xuXHRcdGlzSXRlbUxvYWRlZCA6IGZ1bmN0aW9uKHNjcmlwdFVybCkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLCBzcmM7XG5cdFx0XHRpZih0aGlzLl9vbmRlbWFuZF9sb2FkZWRfbGlzdCA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl9vbmRlbWFuZF9sb2FkZWRfbGlzdCA9IHt9O1xuXHRcdFx0XHQkKCdzY3JpcHQnKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNyYyA9ICQodGhpcykuYXR0cignc3JjJyk7XG5cdFx0XHRcdFx0aWYoc3JjKSBzZWxmLl9vbmRlbWFuZF9sb2FkZWRfbGlzdFtzcmNdID0gMTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdCQoJ2xpbmtbcmVsPVwic3R5bGVzaGVldFwiXScpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0c3JjID0gJCh0aGlzKS5hdHRyKCdocmVmJyk7XG5cdFx0XHRcdFx0aWYoc3JjKSBzZWxmLl9vbmRlbWFuZF9sb2FkZWRfbGlzdFtzcmNdID0gMTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHRoaXMuX29uZGVtYW5kX2xvYWRlZF9saXN0W2RlY29kZVBhdGgoc2NyaXB0VXJsKV0gIT09IHVuZGVmaW5lZCk7XG5cdFx0fSxcblxuXHRcdHJlcXVpcmVDc3MgOiBmdW5jdGlvbihzdHlsZVVybCwgbWVkaWEpe1xuXHRcdFx0aWYoIW1lZGlhKSBtZWRpYSA9ICdhbGwnO1xuXG5cdFx0XHQvLyBEb24ndCBkb3VibGUgdXAgb24gbG9hZGluZyBzY3JpcHRzXG5cdFx0XHRpZigkLmlzSXRlbUxvYWRlZChzdHlsZVVybCkpIHJldHVybjtcblxuXHRcdFx0aWYoZG9jdW1lbnQuY3JlYXRlU3R5bGVTaGVldCl7XG5cdFx0XHRcdHZhciBzcyA9IGRvY3VtZW50LmNyZWF0ZVN0eWxlU2hlZXQoc3R5bGVVcmwpO1xuXHRcdFx0XHRzcy5tZWRpYSA9IG1lZGlhO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgc3R5bGVUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG5cdFx0XHRcdCQoc3R5bGVUYWcpLmF0dHIoe1xuXHRcdFx0XHRcdGhyZWZcdDogc3R5bGVVcmwsXG5cdFx0XHRcdFx0dHlwZVx0OiAndGV4dC9jc3MnLFxuXHRcdFx0XHRcdG1lZGlhIFx0OiBtZWRpYSxcblx0XHRcdFx0XHRyZWxcdFx0OiAnc3R5bGVzaGVldCdcblx0XHRcdFx0fSkuYXBwZW5kVG8oJCgnaGVhZCcpLmdldCgwKSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX29uZGVtYW5kX2xvYWRlZF9saXN0W3N0eWxlVXJsXSA9IDE7XG5cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUHJvY2VzcyB0aGUgWC1JbmNsdWRlLUNTUyBhbmQgWC1JbmNsdWRlLUpTIGhlYWRlcnMgcHJvdmlkZWQgYnkgdGhlIFJlcXVpcmVtZW50cyBjbGFzc1xuXHRcdCAqL1xuXHRcdHByb2Nlc3NPbkRlbWFuZEhlYWRlcnM6IGZ1bmN0aW9uKHhtbCwgc3RhdHVzLCB4aHIpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcywgcHJvY2Vzc0RmZCA9IG5ldyAkLkRlZmVycmVkKCk7XG5cblx0XHRcdC8vIENTU1xuXHRcdFx0aWYoeGhyLmdldFJlc3BvbnNlSGVhZGVyICYmIHhoci5nZXRSZXNwb25zZUhlYWRlcignWC1JbmNsdWRlLUNTUycpKSB7XG5cdFx0XHRcdHZhciBjc3NJbmNsdWRlcyA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignWC1JbmNsdWRlLUNTUycpLnNwbGl0KCcsJyk7XG5cdFx0XHRcdGZvcih2YXIgaT0wO2k8Y3NzSW5jbHVkZXMubGVuZ3RoO2krKykge1xuXHRcdFx0XHRcdC8vIFN5bnRheDogXCJVUkw6IyM6bWVkaWFcIlxuXHRcdFx0XHRcdGlmKGNzc0luY2x1ZGVzW2ldLm1hdGNoKC9eKC4qKTojIzooLiopJC8pKSB7XG5cdFx0XHRcdFx0XHQkLnJlcXVpcmVDc3MoZGVjb2RlUGF0aChSZWdFeHAuJDEpLCBSZWdFeHAuJDIpO1xuXHRcdFx0XHRcdC8vIFN5bnRheDogXCJVUkxcIlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQkLnJlcXVpcmVDc3MoZGVjb2RlUGF0aChjc3NJbmNsdWRlc1tpXSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBKYXZhU2NyaXB0XG5cdFx0XHR2YXIgbmV3SnNJbmNsdWRlcyA9IFtdO1xuXHRcdFx0aWYoeGhyLmdldFJlc3BvbnNlSGVhZGVyICYmIHhoci5nZXRSZXNwb25zZUhlYWRlcignWC1JbmNsdWRlLUpTJykpIHtcblx0XHRcdFx0dmFyIGpzSW5jbHVkZXMgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1gtSW5jbHVkZS1KUycpLnNwbGl0KCcsJyk7XG5cdFx0XHRcdGZvcih2YXIgaT0wO2k8anNJbmNsdWRlcy5sZW5ndGg7aSsrKSB7XG5cdFx0XHRcdFx0dmFyIGpzSW5jbHVkZVBhdGggPSBkZWNvZGVQYXRoKGpzSW5jbHVkZXNbaV0pO1xuXHRcdFx0XHRcdGlmKCEkLmlzSXRlbUxvYWRlZChqc0luY2x1ZGVQYXRoKSkge1xuXHRcdFx0XHRcdFx0bmV3SnNJbmNsdWRlcy5wdXNoKGpzSW5jbHVkZVBhdGgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZSBtYWtlIGFuIGFycmF5IG9mIHRoZSBpbmNsdWRlcyB0aGF0IGFyZSBhY3R1YWxseSBuZXcsIGFuZCBhdHRhY2ggdGhlIGNhbGxiYWNrIHRvIHRoZSBsYXN0IG9uZVxuXHRcdFx0Ly8gVGhleSBhcmUgcGxhY2VkIGluIGEgcXVldWUgYW5kIHdpbGwgYmUgaW5jbHVkZWQgaW4gb3JkZXIuICBUaGlzIG1lYW5zIHRoYXQgdGhlIGNhbGxiYWNrIHdpbGxcblx0XHRcdC8vIGJlIGFibGUgdG8gZXhlY3V0ZSBzY3JpcHQgaW4gdGhlIG5ldyBpbmNsdWRlcyAoc3VjaCBhcyBhIGxpdmVxdWVyeSB1cGRhdGUpXG5cdFx0XHR2YXIgZ2V0U2NyaXB0UXVldWUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYobmV3SnNJbmNsdWRlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHR2YXIgbmV3SnNJbmNsdWRlID0gbmV3SnNJbmNsdWRlcy5zaGlmdCgpO1xuXHRcdFx0XHRcdC8vIGVtdWxhdGVzIGdldFNjcmlwdCgpIHdpdGggYWRkdGwuIHNldHRpbmdcblx0XHRcdFx0XHQkLmFqYXgoe1xuXHRcdFx0XHRcdFx0ZGF0YVR5cGU6ICdzY3JpcHQnLFxuXHRcdFx0XHRcdFx0dXJsOiBuZXdKc0luY2x1ZGUsXG5cdFx0XHRcdFx0XHRzdWNjZXNzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0c2VsZi5fb25kZW1hbmRfbG9hZGVkX2xpc3RbbmV3SnNJbmNsdWRlXSA9IDE7XG5cdFx0XHRcdFx0XHRcdGdldFNjcmlwdFF1ZXVlKCk7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0Y2FjaGU6IGZhbHNlLFxuXHRcdFx0XHRcdFx0Ly8galF1ZXJ5IHNlZW1zIHRvIG92ZXJyaWRlIHRoZSBYSFIgb2JqZWN0cyBpZiB1c2VkIGluIGFzeW5jIG1vZGVcblx0XHRcdFx0XHRcdGFzeW5jOiBmYWxzZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHByb2Nlc3NEZmQucmVzb2x2ZSh4bWwsIHN0YXR1cywgeGhyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZihuZXdKc0luY2x1ZGVzLmxlbmd0aCkge1xuXHRcdFx0XHRnZXRTY3JpcHRRdWV1ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSWYgdGhlcmUgYXJlbid0IGFueSBuZXcgaW5jbHVkZXMsIHRoZW4gd2UgY2FuIGp1c3QgY2FsbCB0aGUgY2FsbGJhY2tzIG91cnNlbHZlc1xuXHRcdFx0XHRwcm9jZXNzRGZkLnJlc29sdmUoeG1sLCBzdGF0dXMsIHhocik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9jZXNzRGZkLnByb21pc2UoKTtcblx0XHR9XG5cblx0fSk7XG5cblx0JC5hamF4U2V0dXAoe1xuXHRcdC8vIGJlZm9yZVNlbmQgaXMgdGhlIG9ubHkgcGxhY2UgdG8gYWNjZXNzIHRoZSBYSFIgb2JqZWN0IGJlZm9yZSBzdWNjZXNzIGhhbmRsZXJzIGFyZSBhZGRlZFxuXHRcdGJlZm9yZVNlbmQ6IGZ1bmN0aW9uKGpxWEhSLCBzKSB7XG5cdFx0XHQvLyBBdm9pZCByZWN1cnNpb24gaW4gYWpheCBjYWxsYmFja3MgY2F1c2VkIGJ5IGdldFNjcmlwdCgpLCBieSBub3QgcGFyc2luZ1xuXHRcdFx0Ly8gb25kZW1hbmQgaGVhZGVycyBmb3IgJ3NjcmlwdCcgZGF0YXR5cGVzXG5cdFx0XHRpZihzLmRhdGFUeXBlID09ICdzY3JpcHQnKSByZXR1cm47XG5cblx0XHRcdHZhciBkZmQgPSBuZXcgJC5EZWZlcnJlZCgpO1xuXG5cdFx0XHQvLyBSZWdpc3RlciBvdXIgb3duIHN1Y2Nlc3MgaGFuZGxlciAoYXNzdW1lcyBubyBoYW5kbGVycyBhcmUgYWxyZWFkeSByZWdpc3RlcmVkKVxuXHRcdFx0Ly8gJ3N1Y2Nlc3MnIGlzIGFuIGFsaWFzIGZvciAnZG9uZScsIHdoaWNoIGlzIGV4ZWN1dGVkIGJ5IHRoZSBidWlsdC1pbiBkZWZlcnJlZCBpbnN0YW5jZSBpbiAkLmFqYXgoKVxuXHRcdFx0anFYSFIuc3VjY2VzcyhmdW5jdGlvbihzdWNjZXNzLCBzdGF0dXNUZXh0LCBqWEhSKSB7XG5cdFx0XHRcdCQucHJvY2Vzc09uRGVtYW5kSGVhZGVycyhzdWNjZXNzLCBzdGF0dXNUZXh0LCBqWEhSKS5kb25lKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRmZC5yZXNvbHZlV2l0aChzLmNvbnRleHQgfHwgdGhpcywgW3N1Y2Nlc3MsIHN0YXR1c1RleHQsIGpYSFJdKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gUmVyb3V0ZSBhbGwgZXh0ZXJuYWwgc3VjY2VzcyBoYW5sZGVycyB0aHJvdWdoIG91ciBvd24gZGVmZXJyZWQuXG5cdFx0XHQvLyBOb3Qgb3ZlcmxvYWRpbmcgZmFpbCgpIGFzIG5vIGV2ZW50IGNhbiBjYXVzZSB0aGUgb3JpZ2luYWwgcmVxdWVzdCB0byBmYWlsLlxuXHRcdFx0anFYSFIuc3VjY2VzcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHRcdGRmZC5kb25lKGNhbGxiYWNrKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cbn0pKGpRdWVyeSk7XG4iLCIvKipcbiAqIGpRdWVyeS5xdWVyeSAtIFF1ZXJ5IFN0cmluZyBNb2RpZmljYXRpb24gYW5kIENyZWF0aW9uIGZvciBqUXVlcnlcbiAqIFdyaXR0ZW4gYnkgQmxhaXIgTWl0Y2hlbG1vcmUgKGJsYWlyIERPVCBtaXRjaGVsbW9yZSBBVCBnbWFpbCBET1QgY29tKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIFdURlBMIChodHRwOi8vc2FtLnpveS5vcmcvd3RmcGwvKS5cbiAqIERhdGU6IDIwMDkvOC8xM1xuICpcbiAqIEBhdXRob3IgQmxhaXIgTWl0Y2hlbG1vcmVcbiAqIEB2ZXJzaW9uIDIuMS43XG4gKlxuICoqL1xubmV3IGZ1bmN0aW9uKHNldHRpbmdzKSB7IFxuICAvLyBWYXJpb3VzIFNldHRpbmdzXG4gIHZhciAkc2VwYXJhdG9yID0gc2V0dGluZ3Muc2VwYXJhdG9yIHx8ICcmJztcbiAgdmFyICRzcGFjZXMgPSBzZXR0aW5ncy5zcGFjZXMgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xuICB2YXIgJHN1ZmZpeCA9IHNldHRpbmdzLnN1ZmZpeCA9PT0gZmFsc2UgPyAnJyA6ICdbXSc7XG4gIHZhciAkcHJlZml4ID0gc2V0dGluZ3MucHJlZml4ID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcbiAgdmFyICRoYXNoID0gJHByZWZpeCA/IHNldHRpbmdzLmhhc2ggPT09IHRydWUgPyBcIiNcIiA6IFwiP1wiIDogXCJcIjtcbiAgdmFyICRudW1iZXJzID0gc2V0dGluZ3MubnVtYmVycyA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7XG4gIFxuICBqUXVlcnkucXVlcnkgPSBuZXcgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlzID0gZnVuY3Rpb24obywgdCkge1xuICAgICAgcmV0dXJuIG8gIT0gdW5kZWZpbmVkICYmIG8gIT09IG51bGwgJiYgKCEhdCA/IG8uY29uc3RydWN0b3IgPT0gdCA6IHRydWUpO1xuICAgIH07XG4gICAgdmFyIHBhcnNlID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgdmFyIG0sIHJ4ID0gL1xcWyhbXltdKilcXF0vZywgbWF0Y2ggPSAvXihbXltdKykoXFxbLipcXF0pPyQvLmV4ZWMocGF0aCksIGJhc2UgPSBtYXRjaFsxXSwgdG9rZW5zID0gW107XG4gICAgICB3aGlsZSAobSA9IHJ4LmV4ZWMobWF0Y2hbMl0pKSB0b2tlbnMucHVzaChtWzFdKTtcbiAgICAgIHJldHVybiBbYmFzZSwgdG9rZW5zXTtcbiAgICB9O1xuICAgIHZhciBzZXQgPSBmdW5jdGlvbih0YXJnZXQsIHRva2VucywgdmFsdWUpIHtcbiAgICAgIHZhciBvLCB0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT0gJ29iamVjdCcpIHRhcmdldCA9IG51bGw7XG4gICAgICBpZiAodG9rZW4gPT09IFwiXCIpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHRhcmdldCA9IFtdO1xuICAgICAgICBpZiAoaXModGFyZ2V0LCBBcnJheSkpIHtcbiAgICAgICAgICB0YXJnZXQucHVzaCh0b2tlbnMubGVuZ3RoID09IDAgPyB2YWx1ZSA6IHNldChudWxsLCB0b2tlbnMuc2xpY2UoMCksIHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXModGFyZ2V0LCBPYmplY3QpKSB7XG4gICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgIHdoaWxlICh0YXJnZXRbaSsrXSAhPSBudWxsKTtcbiAgICAgICAgICB0YXJnZXRbLS1pXSA9IHRva2Vucy5sZW5ndGggPT0gMCA/IHZhbHVlIDogc2V0KHRhcmdldFtpXSwgdG9rZW5zLnNsaWNlKDApLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0ID0gW107XG4gICAgICAgICAgdGFyZ2V0LnB1c2godG9rZW5zLmxlbmd0aCA9PSAwID8gdmFsdWUgOiBzZXQobnVsbCwgdG9rZW5zLnNsaWNlKDApLCB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRva2VuICYmIHRva2VuLm1hdGNoKC9eXFxzKlswLTldK1xccyokLykpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQodG9rZW4sIDEwKTtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHRhcmdldCA9IFtdO1xuICAgICAgICB0YXJnZXRbaW5kZXhdID0gdG9rZW5zLmxlbmd0aCA9PSAwID8gdmFsdWUgOiBzZXQodGFyZ2V0W2luZGV4XSwgdG9rZW5zLnNsaWNlKDApLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHRva2VuKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRva2VuLnJlcGxhY2UoL15cXHMqfFxccyokL2csIFwiXCIpO1xuICAgICAgICBpZiAoIXRhcmdldCkgdGFyZ2V0ID0ge307XG4gICAgICAgIGlmIChpcyh0YXJnZXQsIEFycmF5KSkge1xuICAgICAgICAgIHZhciB0ZW1wID0ge307XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRlbXBbaV0gPSB0YXJnZXRbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldCA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0W2luZGV4XSA9IHRva2Vucy5sZW5ndGggPT0gMCA/IHZhbHVlIDogc2V0KHRhcmdldFtpbmRleF0sIHRva2Vucy5zbGljZSgwKSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuICAgIFxuICAgIHZhciBxdWVyeU9iamVjdCA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHNlbGYua2V5cyA9IHt9O1xuICAgICAgXG4gICAgICBpZiAoYS5xdWVyeU9iamVjdCkge1xuICAgICAgICBqUXVlcnkuZWFjaChhLmdldCgpLCBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgICAgICAgIHNlbGYuU0VUKGtleSwgdmFsKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqUXVlcnkuZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBxID0gXCJcIiArIHRoaXM7XG4gICAgICAgICAgcSA9IHEucmVwbGFjZSgvXls/I10vLCcnKTsgLy8gcmVtb3ZlIGFueSBsZWFkaW5nID8gfHwgI1xuICAgICAgICAgIHEgPSBxLnJlcGxhY2UoL1s7Jl0kLywnJyk7IC8vIHJlbW92ZSBhbnkgdHJhaWxpbmcgJiB8fCA7XG4gICAgICAgICAgaWYgKCRzcGFjZXMpIHEgPSBxLnJlcGxhY2UoL1srXS9nLCcgJyk7IC8vIHJlcGxhY2UgKydzIHdpdGggc3BhY2VzXG4gICAgICAgICAgXG4gICAgICAgICAgalF1ZXJ5LmVhY2gocS5zcGxpdCgvWyY7XS8pLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdmFyIGtleSA9IGRlY29kZVVSSUNvbXBvbmVudCh0aGlzLnNwbGl0KCc9JylbMF0gfHwgXCJcIik7XG4gICAgICAgICAgICB2YXIgdmFsID0gZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMuc3BsaXQoJz0nKVsxXSB8fCBcIlwiKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFrZXkpIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCRudW1iZXJzKSB7XG4gICAgICAgICAgICAgIGlmICgvXlsrLV0/WzAtOV0rXFwuWzAtOV0qJC8udGVzdCh2YWwpKSAvLyBzaW1wbGUgZmxvYXQgcmVnZXhcbiAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KHZhbCk7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKC9eWystXT9bMC05XSskLy50ZXN0KHZhbCkpIC8vIHNpbXBsZSBpbnQgcmVnZXhcbiAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUludCh2YWwsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFsID0gKCF2YWwgJiYgdmFsICE9PSAwKSA/IHRydWUgOiB2YWw7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh2YWwgIT09IGZhbHNlICYmIHZhbCAhPT0gdHJ1ZSAmJiB0eXBlb2YgdmFsICE9ICdudW1iZXInKVxuICAgICAgICAgICAgICB2YWwgPSB2YWw7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNlbGYuU0VUKGtleSwgdmFsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIFxuICAgIHF1ZXJ5T2JqZWN0LnByb3RvdHlwZSA9IHtcbiAgICAgIHF1ZXJ5T2JqZWN0OiB0cnVlLFxuICAgICAgaGFzOiBmdW5jdGlvbihrZXksIHR5cGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIGlzKHZhbHVlLCB0eXBlKTtcbiAgICAgIH0sXG4gICAgICBHRVQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoIWlzKGtleSkpIHJldHVybiB0aGlzLmtleXM7XG4gICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZShrZXkpLCBiYXNlID0gcGFyc2VkWzBdLCB0b2tlbnMgPSBwYXJzZWRbMV07XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmtleXNbYmFzZV07XG4gICAgICAgIHdoaWxlICh0YXJnZXQgIT0gbnVsbCAmJiB0b2tlbnMubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICB0YXJnZXQgPSB0YXJnZXRbdG9rZW5zLnNoaWZ0KCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGFyZ2V0ID09ICdudW1iZXInID8gdGFyZ2V0IDogdGFyZ2V0IHx8IFwiXCI7XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuR0VUKGtleSk7XG4gICAgICAgIGlmIChpcyh0YXJnZXQsIE9iamVjdCkpXG4gICAgICAgICAgcmV0dXJuIGpRdWVyeS5leHRlbmQodHJ1ZSwge30sIHRhcmdldCk7XG4gICAgICAgIGVsc2UgaWYgKGlzKHRhcmdldCwgQXJyYXkpKVxuICAgICAgICAgIHJldHVybiB0YXJnZXQuc2xpY2UoMCk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9LFxuICAgICAgU0VUOiBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgICAgICB2YXIgdmFsdWUgPSAhaXModmFsKSA/IG51bGwgOiB2YWw7XG4gICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZShrZXkpLCBiYXNlID0gcGFyc2VkWzBdLCB0b2tlbnMgPSBwYXJzZWRbMV07XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmtleXNbYmFzZV07XG4gICAgICAgIHRoaXMua2V5c1tiYXNlXSA9IHNldCh0YXJnZXQsIHRva2Vucy5zbGljZSgwKSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkoKS5TRVQoa2V5LCB2YWwpO1xuICAgICAgfSxcbiAgICAgIFJFTU9WRTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLlNFVChrZXksIG51bGwpLkNPTVBBQ1QoKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3B5KCkuUkVNT1ZFKGtleSk7XG4gICAgICB9LFxuICAgICAgRU1QVFk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGpRdWVyeS5lYWNoKHNlbGYua2V5cywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGRlbGV0ZSBzZWxmLmtleXNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfSxcbiAgICAgIGxvYWQ6IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICB2YXIgaGFzaCA9IHVybC5yZXBsYWNlKC9eLio/WyNdKC4rPykoPzpcXD8uKyk/JC8sIFwiJDFcIik7XG4gICAgICAgIHZhciBzZWFyY2ggPSB1cmwucmVwbGFjZSgvXi4qP1s/XSguKz8pKD86Iy4rKT8kLywgXCIkMVwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBxdWVyeU9iamVjdCh1cmwubGVuZ3RoID09IHNlYXJjaC5sZW5ndGggPyAnJyA6IHNlYXJjaCwgdXJsLmxlbmd0aCA9PSBoYXNoLmxlbmd0aCA/ICcnIDogaGFzaCk7XG4gICAgICB9LFxuICAgICAgZW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3B5KCkuRU1QVFkoKTtcbiAgICAgIH0sXG4gICAgICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBxdWVyeU9iamVjdCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBDT01QQUNUOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gYnVpbGQob3JpZykge1xuICAgICAgICAgIHZhciBvYmogPSB0eXBlb2Ygb3JpZyA9PSBcIm9iamVjdFwiID8gaXMob3JpZywgQXJyYXkpID8gW10gOiB7fSA6IG9yaWc7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvcmlnID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBhZGQobywga2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICBpZiAoaXMobywgQXJyYXkpKVxuICAgICAgICAgICAgICAgIG8ucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGpRdWVyeS5lYWNoKG9yaWcsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpcyh2YWx1ZSkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICBhZGQob2JqLCBrZXksIGJ1aWxkKHZhbHVlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmtleXMgPSBidWlsZCh0aGlzLmtleXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBjb21wYWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weSgpLkNPTVBBQ1QoKTtcbiAgICAgIH0sXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpID0gMCwgcXVlcnlTdHJpbmcgPSBbXSwgY2h1bmtzID0gW10sIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgc3RyID0gc3RyICsgXCJcIjtcbiAgICAgICAgICBpZiAoJHNwYWNlcykgc3RyID0gc3RyLnJlcGxhY2UoLyAvZywgXCIrXCIpO1xuICAgICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFkZEZpZWxkcyA9IGZ1bmN0aW9uKGFyciwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGlmICghaXModmFsdWUpIHx8IHZhbHVlID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICAgIHZhciBvID0gW2VuY29kZShrZXkpXTtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIG8ucHVzaChcIj1cIik7XG4gICAgICAgICAgICBvLnB1c2goZW5jb2RlKHZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFyci5wdXNoKG8uam9pbihcIlwiKSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBidWlsZCA9IGZ1bmN0aW9uKG9iaiwgYmFzZSkge1xuICAgICAgICAgIHZhciBuZXdLZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiAhYmFzZSB8fCBiYXNlID09IFwiXCIgPyBba2V5XS5qb2luKFwiXCIpIDogW2Jhc2UsIFwiW1wiLCBrZXksIFwiXVwiXS5qb2luKFwiXCIpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgalF1ZXJ5LmVhY2gob2JqLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSBcbiAgICAgICAgICAgICAgYnVpbGQodmFsdWUsIG5ld0tleShrZXkpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYWRkRmllbGRzKGNodW5rcywgbmV3S2V5KGtleSksIHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGJ1aWxkKHRoaXMua2V5cyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoY2h1bmtzLmxlbmd0aCA+IDApIHF1ZXJ5U3RyaW5nLnB1c2goJGhhc2gpO1xuICAgICAgICBxdWVyeVN0cmluZy5wdXNoKGNodW5rcy5qb2luKCRzZXBhcmF0b3IpKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBxdWVyeVN0cmluZy5qb2luKFwiXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIG5ldyBxdWVyeU9iamVjdChsb2NhdGlvbi5zZWFyY2gsIGxvY2F0aW9uLmhhc2gpO1xuICB9O1xufShqUXVlcnkucXVlcnkgfHwge30pOyAvLyBQYXNzIGluIGpRdWVyeS5xdWVyeSBhcyBzZXR0aW5ncyBvYmplY3QiLCIvKiEgalF1ZXJ5IFVJIC0gdjEuOS4yIC0gMjAxMi0xMS0yM1xuKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4qIEluY2x1ZGVzOiBqcXVlcnkudWkuY29yZS5qcywganF1ZXJ5LnVpLndpZGdldC5qcywganF1ZXJ5LnVpLm1vdXNlLmpzLCBqcXVlcnkudWkucG9zaXRpb24uanMsIGpxdWVyeS51aS5hY2NvcmRpb24uanMsIGpxdWVyeS51aS5hdXRvY29tcGxldGUuanMsIGpxdWVyeS51aS5idXR0b24uanMsIGpxdWVyeS51aS5kYXRlcGlja2VyLmpzLCBqcXVlcnkudWkuZGlhbG9nLmpzLCBqcXVlcnkudWkuZHJhZ2dhYmxlLmpzLCBqcXVlcnkudWkuZHJvcHBhYmxlLmpzLCBqcXVlcnkudWkuZWZmZWN0LmpzLCBqcXVlcnkudWkuZWZmZWN0LWJsaW5kLmpzLCBqcXVlcnkudWkuZWZmZWN0LWJvdW5jZS5qcywganF1ZXJ5LnVpLmVmZmVjdC1jbGlwLmpzLCBqcXVlcnkudWkuZWZmZWN0LWRyb3AuanMsIGpxdWVyeS51aS5lZmZlY3QtZXhwbG9kZS5qcywganF1ZXJ5LnVpLmVmZmVjdC1mYWRlLmpzLCBqcXVlcnkudWkuZWZmZWN0LWZvbGQuanMsIGpxdWVyeS51aS5lZmZlY3QtaGlnaGxpZ2h0LmpzLCBqcXVlcnkudWkuZWZmZWN0LXB1bHNhdGUuanMsIGpxdWVyeS51aS5lZmZlY3Qtc2NhbGUuanMsIGpxdWVyeS51aS5lZmZlY3Qtc2hha2UuanMsIGpxdWVyeS51aS5lZmZlY3Qtc2xpZGUuanMsIGpxdWVyeS51aS5lZmZlY3QtdHJhbnNmZXIuanMsIGpxdWVyeS51aS5tZW51LmpzLCBqcXVlcnkudWkucHJvZ3Jlc3NiYXIuanMsIGpxdWVyeS51aS5yZXNpemFibGUuanMsIGpxdWVyeS51aS5zZWxlY3RhYmxlLmpzLCBqcXVlcnkudWkuc2xpZGVyLmpzLCBqcXVlcnkudWkuc29ydGFibGUuanMsIGpxdWVyeS51aS5zcGlubmVyLmpzLCBqcXVlcnkudWkudGFicy5qcywganF1ZXJ5LnVpLnRvb2x0aXAuanNcbiogQ29weXJpZ2h0IChjKSAyMDEyIGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgTGljZW5zZWQgTUlUICovXG5cbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgdXVpZCA9IDAsXG5cdHJ1bmlxdWVJZCA9IC9edWktaWQtXFxkKyQvO1xuXG4vLyBwcmV2ZW50IGR1cGxpY2F0ZSBsb2FkaW5nXG4vLyB0aGlzIGlzIG9ubHkgYSBwcm9ibGVtIGJlY2F1c2Ugd2UgcHJveHkgZXhpc3RpbmcgZnVuY3Rpb25zXG4vLyBhbmQgd2UgZG9uJ3Qgd2FudCB0byBkb3VibGUgcHJveHkgdGhlbVxuJC51aSA9ICQudWkgfHwge307XG5pZiAoICQudWkudmVyc2lvbiApIHtcblx0cmV0dXJuO1xufVxuXG4kLmV4dGVuZCggJC51aSwge1xuXHR2ZXJzaW9uOiBcIjEuOS4yXCIsXG5cblx0a2V5Q29kZToge1xuXHRcdEJBQ0tTUEFDRTogOCxcblx0XHRDT01NQTogMTg4LFxuXHRcdERFTEVURTogNDYsXG5cdFx0RE9XTjogNDAsXG5cdFx0RU5EOiAzNSxcblx0XHRFTlRFUjogMTMsXG5cdFx0RVNDQVBFOiAyNyxcblx0XHRIT01FOiAzNixcblx0XHRMRUZUOiAzNyxcblx0XHROVU1QQURfQUREOiAxMDcsXG5cdFx0TlVNUEFEX0RFQ0lNQUw6IDExMCxcblx0XHROVU1QQURfRElWSURFOiAxMTEsXG5cdFx0TlVNUEFEX0VOVEVSOiAxMDgsXG5cdFx0TlVNUEFEX01VTFRJUExZOiAxMDYsXG5cdFx0TlVNUEFEX1NVQlRSQUNUOiAxMDksXG5cdFx0UEFHRV9ET1dOOiAzNCxcblx0XHRQQUdFX1VQOiAzMyxcblx0XHRQRVJJT0Q6IDE5MCxcblx0XHRSSUdIVDogMzksXG5cdFx0U1BBQ0U6IDMyLFxuXHRcdFRBQjogOSxcblx0XHRVUDogMzhcblx0fVxufSk7XG5cbi8vIHBsdWdpbnNcbiQuZm4uZXh0ZW5kKHtcblx0X2ZvY3VzOiAkLmZuLmZvY3VzLFxuXHRmb2N1czogZnVuY3Rpb24oIGRlbGF5LCBmbiApIHtcblx0XHRyZXR1cm4gdHlwZW9mIGRlbGF5ID09PSBcIm51bWJlclwiID9cblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdCQoIGVsZW0gKS5mb2N1cygpO1xuXHRcdFx0XHRcdGlmICggZm4gKSB7XG5cdFx0XHRcdFx0XHRmbi5jYWxsKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCBkZWxheSApO1xuXHRcdFx0fSkgOlxuXHRcdFx0dGhpcy5fZm9jdXMuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR9LFxuXG5cdHNjcm9sbFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNjcm9sbFBhcmVudDtcblx0XHRpZiAoKCQudWkuaWUgJiYgKC8oc3RhdGljfHJlbGF0aXZlKS8pLnRlc3QodGhpcy5jc3MoJ3Bvc2l0aW9uJykpKSB8fCAoL2Fic29sdXRlLykudGVzdCh0aGlzLmNzcygncG9zaXRpb24nKSkpIHtcblx0XHRcdHNjcm9sbFBhcmVudCA9IHRoaXMucGFyZW50cygpLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICgvKHJlbGF0aXZlfGFic29sdXRlfGZpeGVkKS8pLnRlc3QoJC5jc3ModGhpcywncG9zaXRpb24nKSkgJiYgKC8oYXV0b3xzY3JvbGwpLykudGVzdCgkLmNzcyh0aGlzLCdvdmVyZmxvdycpKyQuY3NzKHRoaXMsJ292ZXJmbG93LXknKSskLmNzcyh0aGlzLCdvdmVyZmxvdy14JykpO1xuXHRcdFx0fSkuZXEoMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNjcm9sbFBhcmVudCA9IHRoaXMucGFyZW50cygpLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICgvKGF1dG98c2Nyb2xsKS8pLnRlc3QoJC5jc3ModGhpcywnb3ZlcmZsb3cnKSskLmNzcyh0aGlzLCdvdmVyZmxvdy15JykrJC5jc3ModGhpcywnb3ZlcmZsb3cteCcpKTtcblx0XHRcdH0pLmVxKDApO1xuXHRcdH1cblxuXHRcdHJldHVybiAoL2ZpeGVkLykudGVzdCh0aGlzLmNzcygncG9zaXRpb24nKSkgfHwgIXNjcm9sbFBhcmVudC5sZW5ndGggPyAkKGRvY3VtZW50KSA6IHNjcm9sbFBhcmVudDtcblx0fSxcblxuXHR6SW5kZXg6IGZ1bmN0aW9uKCB6SW5kZXggKSB7XG5cdFx0aWYgKCB6SW5kZXggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiB0aGlzLmNzcyggXCJ6SW5kZXhcIiwgekluZGV4ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdHZhciBlbGVtID0gJCggdGhpc1sgMCBdICksIHBvc2l0aW9uLCB2YWx1ZTtcblx0XHRcdHdoaWxlICggZWxlbS5sZW5ndGggJiYgZWxlbVsgMCBdICE9PSBkb2N1bWVudCApIHtcblx0XHRcdFx0Ly8gSWdub3JlIHotaW5kZXggaWYgcG9zaXRpb24gaXMgc2V0IHRvIGEgdmFsdWUgd2hlcmUgei1pbmRleCBpcyBpZ25vcmVkIGJ5IHRoZSBicm93c2VyXG5cdFx0XHRcdC8vIFRoaXMgbWFrZXMgYmVoYXZpb3Igb2YgdGhpcyBmdW5jdGlvbiBjb25zaXN0ZW50IGFjcm9zcyBicm93c2Vyc1xuXHRcdFx0XHQvLyBXZWJLaXQgYWx3YXlzIHJldHVybnMgYXV0byBpZiB0aGUgZWxlbWVudCBpcyBwb3NpdGlvbmVkXG5cdFx0XHRcdHBvc2l0aW9uID0gZWxlbS5jc3MoIFwicG9zaXRpb25cIiApO1xuXHRcdFx0XHRpZiAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwicmVsYXRpdmVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkge1xuXHRcdFx0XHRcdC8vIElFIHJldHVybnMgMCB3aGVuIHpJbmRleCBpcyBub3Qgc3BlY2lmaWVkXG5cdFx0XHRcdFx0Ly8gb3RoZXIgYnJvd3NlcnMgcmV0dXJuIGEgc3RyaW5nXG5cdFx0XHRcdFx0Ly8gd2UgaWdub3JlIHRoZSBjYXNlIG9mIG5lc3RlZCBlbGVtZW50cyB3aXRoIGFuIGV4cGxpY2l0IHZhbHVlIG9mIDBcblx0XHRcdFx0XHQvLyA8ZGl2IHN0eWxlPVwiei1pbmRleDogLTEwO1wiPjxkaXYgc3R5bGU9XCJ6LWluZGV4OiAwO1wiPjwvZGl2PjwvZGl2PlxuXHRcdFx0XHRcdHZhbHVlID0gcGFyc2VJbnQoIGVsZW0uY3NzKCBcInpJbmRleFwiICksIDEwICk7XG5cdFx0XHRcdFx0aWYgKCAhaXNOYU4oIHZhbHVlICkgJiYgdmFsdWUgIT09IDAgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW0gPSBlbGVtLnBhcmVudCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdHVuaXF1ZUlkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhdGhpcy5pZCApIHtcblx0XHRcdFx0dGhpcy5pZCA9IFwidWktaWQtXCIgKyAoKyt1dWlkKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRyZW1vdmVVbmlxdWVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggcnVuaXF1ZUlkLnRlc3QoIHRoaXMuaWQgKSApIHtcblx0XHRcdFx0JCggdGhpcyApLnJlbW92ZUF0dHIoIFwiaWRcIiApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59KTtcblxuLy8gc2VsZWN0b3JzXG5mdW5jdGlvbiBmb2N1c2FibGUoIGVsZW1lbnQsIGlzVGFiSW5kZXhOb3ROYU4gKSB7XG5cdHZhciBtYXAsIG1hcE5hbWUsIGltZyxcblx0XHRub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0aWYgKCBcImFyZWFcIiA9PT0gbm9kZU5hbWUgKSB7XG5cdFx0bWFwID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXHRcdG1hcE5hbWUgPSBtYXAubmFtZTtcblx0XHRpZiAoICFlbGVtZW50LmhyZWYgfHwgIW1hcE5hbWUgfHwgbWFwLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwibWFwXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGltZyA9ICQoIFwiaW1nW3VzZW1hcD0jXCIgKyBtYXBOYW1lICsgXCJdXCIgKVswXTtcblx0XHRyZXR1cm4gISFpbWcgJiYgdmlzaWJsZSggaW1nICk7XG5cdH1cblx0cmV0dXJuICggL2lucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b258b2JqZWN0Ly50ZXN0KCBub2RlTmFtZSApID9cblx0XHQhZWxlbWVudC5kaXNhYmxlZCA6XG5cdFx0XCJhXCIgPT09IG5vZGVOYW1lID9cblx0XHRcdGVsZW1lbnQuaHJlZiB8fCBpc1RhYkluZGV4Tm90TmFOIDpcblx0XHRcdGlzVGFiSW5kZXhOb3ROYU4pICYmXG5cdFx0Ly8gdGhlIGVsZW1lbnQgYW5kIGFsbCBvZiBpdHMgYW5jZXN0b3JzIG11c3QgYmUgdmlzaWJsZVxuXHRcdHZpc2libGUoIGVsZW1lbnQgKTtcbn1cblxuZnVuY3Rpb24gdmlzaWJsZSggZWxlbWVudCApIHtcblx0cmV0dXJuICQuZXhwci5maWx0ZXJzLnZpc2libGUoIGVsZW1lbnQgKSAmJlxuXHRcdCEkKCBlbGVtZW50ICkucGFyZW50cygpLmFuZFNlbGYoKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gJC5jc3MoIHRoaXMsIFwidmlzaWJpbGl0eVwiICkgPT09IFwiaGlkZGVuXCI7XG5cdFx0fSkubGVuZ3RoO1xufVxuXG4kLmV4dGVuZCggJC5leHByWyBcIjpcIiBdLCB7XG5cdGRhdGE6ICQuZXhwci5jcmVhdGVQc2V1ZG8gP1xuXHRcdCQuZXhwci5jcmVhdGVQc2V1ZG8oZnVuY3Rpb24oIGRhdGFOYW1lICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIGRhdGFOYW1lICk7XG5cdFx0XHR9O1xuXHRcdH0pIDpcblx0XHQvLyBzdXBwb3J0OiBqUXVlcnkgPDEuOFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBpLCBtYXRjaCApIHtcblx0XHRcdHJldHVybiAhISQuZGF0YSggZWxlbSwgbWF0Y2hbIDMgXSApO1xuXHRcdH0sXG5cblx0Zm9jdXNhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRyZXR1cm4gZm9jdXNhYmxlKCBlbGVtZW50LCAhaXNOYU4oICQuYXR0ciggZWxlbWVudCwgXCJ0YWJpbmRleFwiICkgKSApO1xuXHR9LFxuXG5cdHRhYmJhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR2YXIgdGFiSW5kZXggPSAkLmF0dHIoIGVsZW1lbnQsIFwidGFiaW5kZXhcIiApLFxuXHRcdFx0aXNUYWJJbmRleE5hTiA9IGlzTmFOKCB0YWJJbmRleCApO1xuXHRcdHJldHVybiAoIGlzVGFiSW5kZXhOYU4gfHwgdGFiSW5kZXggPj0gMCApICYmIGZvY3VzYWJsZSggZWxlbWVudCwgIWlzVGFiSW5kZXhOYU4gKTtcblx0fVxufSk7XG5cbi8vIHN1cHBvcnRcbiQoZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSxcblx0XHRkaXYgPSBib2R5LmFwcGVuZENoaWxkKCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHQvLyBhY2Nlc3Mgb2Zmc2V0SGVpZ2h0IGJlZm9yZSBzZXR0aW5nIHRoZSBzdHlsZSB0byBwcmV2ZW50IGEgbGF5b3V0IGJ1Z1xuXHQvLyBpbiBJRSA5IHdoaWNoIGNhdXNlcyB0aGUgZWxlbWVudCB0byBjb250aW51ZSB0byB0YWtlIHVwIHNwYWNlIGV2ZW5cblx0Ly8gYWZ0ZXIgaXQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00gKCM4MDI2KVxuXHRkaXYub2Zmc2V0SGVpZ2h0O1xuXG5cdCQuZXh0ZW5kKCBkaXYuc3R5bGUsIHtcblx0XHRtaW5IZWlnaHQ6IFwiMTAwcHhcIixcblx0XHRoZWlnaHQ6IFwiYXV0b1wiLFxuXHRcdHBhZGRpbmc6IDAsXG5cdFx0Ym9yZGVyV2lkdGg6IDBcblx0fSk7XG5cblx0JC5zdXBwb3J0Lm1pbkhlaWdodCA9IGRpdi5vZmZzZXRIZWlnaHQgPT09IDEwMDtcblx0JC5zdXBwb3J0LnNlbGVjdHN0YXJ0ID0gXCJvbnNlbGVjdHN0YXJ0XCIgaW4gZGl2O1xuXG5cdC8vIHNldCBkaXNwbGF5IHRvIG5vbmUgdG8gYXZvaWQgYSBsYXlvdXQgYnVnIGluIElFXG5cdC8vIGh0dHA6Ly9kZXYuanF1ZXJ5LmNvbS90aWNrZXQvNDAxNFxuXHRib2R5LnJlbW92ZUNoaWxkKCBkaXYgKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG59KTtcblxuLy8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcbmlmICggISQoIFwiPGE+XCIgKS5vdXRlcldpZHRoKCAxICkuanF1ZXJ5ICkge1xuXHQkLmVhY2goIFsgXCJXaWR0aFwiLCBcIkhlaWdodFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRcdHZhciBzaWRlID0gbmFtZSA9PT0gXCJXaWR0aFwiID8gWyBcIkxlZnRcIiwgXCJSaWdodFwiIF0gOiBbIFwiVG9wXCIsIFwiQm90dG9tXCIgXSxcblx0XHRcdHR5cGUgPSBuYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRvcmlnID0ge1xuXHRcdFx0XHRpbm5lcldpZHRoOiAkLmZuLmlubmVyV2lkdGgsXG5cdFx0XHRcdGlubmVySGVpZ2h0OiAkLmZuLmlubmVySGVpZ2h0LFxuXHRcdFx0XHRvdXRlcldpZHRoOiAkLmZuLm91dGVyV2lkdGgsXG5cdFx0XHRcdG91dGVySGVpZ2h0OiAkLmZuLm91dGVySGVpZ2h0XG5cdFx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVkdWNlKCBlbGVtLCBzaXplLCBib3JkZXIsIG1hcmdpbiApIHtcblx0XHRcdCQuZWFjaCggc2lkZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNpemUgLT0gcGFyc2VGbG9hdCggJC5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgdGhpcyApICkgfHwgMDtcblx0XHRcdFx0aWYgKCBib3JkZXIgKSB7XG5cdFx0XHRcdFx0c2l6ZSAtPSBwYXJzZUZsb2F0KCAkLmNzcyggZWxlbSwgXCJib3JkZXJcIiArIHRoaXMgKyBcIldpZHRoXCIgKSApIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBtYXJnaW4gKSB7XG5cdFx0XHRcdFx0c2l6ZSAtPSBwYXJzZUZsb2F0KCAkLmNzcyggZWxlbSwgXCJtYXJnaW5cIiArIHRoaXMgKSApIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHNpemU7XG5cdFx0fVxuXG5cdFx0JC5mblsgXCJpbm5lclwiICsgbmFtZSBdID0gZnVuY3Rpb24oIHNpemUgKSB7XG5cdFx0XHRpZiAoIHNpemUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIG9yaWdbIFwiaW5uZXJcIiArIG5hbWUgXS5jYWxsKCB0aGlzICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5jc3MoIHR5cGUsIHJlZHVjZSggdGhpcywgc2l6ZSApICsgXCJweFwiICk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0JC5mblsgXCJvdXRlclwiICsgbmFtZV0gPSBmdW5jdGlvbiggc2l6ZSwgbWFyZ2luICkge1xuXHRcdFx0aWYgKCB0eXBlb2Ygc2l6ZSAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0cmV0dXJuIG9yaWdbIFwib3V0ZXJcIiArIG5hbWUgXS5jYWxsKCB0aGlzLCBzaXplICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQoIHRoaXMpLmNzcyggdHlwZSwgcmVkdWNlKCB0aGlzLCBzaXplLCB0cnVlLCBtYXJnaW4gKSArIFwicHhcIiApO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0fSk7XG59XG5cbi8vIHN1cHBvcnQ6IGpRdWVyeSAxLjYuMSwgMS42LjIgKGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0Lzk0MTMpXG5pZiAoICQoIFwiPGE+XCIgKS5kYXRhKCBcImEtYlwiLCBcImFcIiApLnJlbW92ZURhdGEoIFwiYS1iXCIgKS5kYXRhKCBcImEtYlwiICkgKSB7XG5cdCQuZm4ucmVtb3ZlRGF0YSA9IChmdW5jdGlvbiggcmVtb3ZlRGF0YSApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbW92ZURhdGEuY2FsbCggdGhpcywgJC5jYW1lbENhc2UoIGtleSApICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gcmVtb3ZlRGF0YS5jYWxsKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSkoICQuZm4ucmVtb3ZlRGF0YSApO1xufVxuXG5cblxuXG5cbi8vIGRlcHJlY2F0ZWRcblxuKGZ1bmN0aW9uKCkge1xuXHR2YXIgdWFNYXRjaCA9IC9tc2llIChbXFx3Ll0rKS8uZXhlYyggbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpICkgfHwgW107XG5cdCQudWkuaWUgPSB1YU1hdGNoLmxlbmd0aCA/IHRydWUgOiBmYWxzZTtcblx0JC51aS5pZTYgPSBwYXJzZUZsb2F0KCB1YU1hdGNoWyAxIF0sIDEwICkgPT09IDY7XG59KSgpO1xuXG4kLmZuLmV4dGVuZCh7XG5cdGRpc2FibGVTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmJpbmQoICggJC5zdXBwb3J0LnNlbGVjdHN0YXJ0ID8gXCJzZWxlY3RzdGFydFwiIDogXCJtb3VzZWRvd25cIiApICtcblx0XHRcdFwiLnVpLWRpc2FibGVTZWxlY3Rpb25cIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fSk7XG5cdH0sXG5cblx0ZW5hYmxlU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy51bmJpbmQoIFwiLnVpLWRpc2FibGVTZWxlY3Rpb25cIiApO1xuXHR9XG59KTtcblxuJC5leHRlbmQoICQudWksIHtcblx0Ly8gJC51aS5wbHVnaW4gaXMgZGVwcmVjYXRlZC4gIFVzZSB0aGUgcHJveHkgcGF0dGVybiBpbnN0ZWFkLlxuXHRwbHVnaW46IHtcblx0XHRhZGQ6IGZ1bmN0aW9uKCBtb2R1bGUsIG9wdGlvbiwgc2V0ICkge1xuXHRcdFx0dmFyIGksXG5cdFx0XHRcdHByb3RvID0gJC51aVsgbW9kdWxlIF0ucHJvdG90eXBlO1xuXHRcdFx0Zm9yICggaSBpbiBzZXQgKSB7XG5cdFx0XHRcdHByb3RvLnBsdWdpbnNbIGkgXSA9IHByb3RvLnBsdWdpbnNbIGkgXSB8fCBbXTtcblx0XHRcdFx0cHJvdG8ucGx1Z2luc1sgaSBdLnB1c2goIFsgb3B0aW9uLCBzZXRbIGkgXSBdICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRjYWxsOiBmdW5jdGlvbiggaW5zdGFuY2UsIG5hbWUsIGFyZ3MgKSB7XG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0c2V0ID0gaW5zdGFuY2UucGx1Z2luc1sgbmFtZSBdO1xuXHRcdFx0aWYgKCAhc2V0IHx8ICFpbnN0YW5jZS5lbGVtZW50WyAwIF0ucGFyZW50Tm9kZSB8fCBpbnN0YW5jZS5lbGVtZW50WyAwIF0ucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggaW5zdGFuY2Uub3B0aW9uc1sgc2V0WyBpIF1bIDAgXSBdICkge1xuXHRcdFx0XHRcdHNldFsgaSBdWyAxIF0uYXBwbHkoIGluc3RhbmNlLmVsZW1lbnQsIGFyZ3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRjb250YWluczogJC5jb250YWlucyxcblxuXHQvLyBvbmx5IHVzZWQgYnkgcmVzaXphYmxlXG5cdGhhc1Njcm9sbDogZnVuY3Rpb24oIGVsLCBhICkge1xuXG5cdFx0Ly9JZiBvdmVyZmxvdyBpcyBoaWRkZW4sIHRoZSBlbGVtZW50IG1pZ2h0IGhhdmUgZXh0cmEgY29udGVudCwgYnV0IHRoZSB1c2VyIHdhbnRzIHRvIGhpZGUgaXRcblx0XHRpZiAoICQoIGVsICkuY3NzKCBcIm92ZXJmbG93XCIgKSA9PT0gXCJoaWRkZW5cIikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciBzY3JvbGwgPSAoIGEgJiYgYSA9PT0gXCJsZWZ0XCIgKSA/IFwic2Nyb2xsTGVmdFwiIDogXCJzY3JvbGxUb3BcIixcblx0XHRcdGhhcyA9IGZhbHNlO1xuXG5cdFx0aWYgKCBlbFsgc2Nyb2xsIF0gPiAwICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogZGV0ZXJtaW5lIHdoaWNoIGNhc2VzIGFjdHVhbGx5IGNhdXNlIHRoaXMgdG8gaGFwcGVuXG5cdFx0Ly8gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIHRoZSBzY3JvbGwgc2V0LCBzZWUgaWYgaXQncyBwb3NzaWJsZSB0b1xuXHRcdC8vIHNldCB0aGUgc2Nyb2xsXG5cdFx0ZWxbIHNjcm9sbCBdID0gMTtcblx0XHRoYXMgPSAoIGVsWyBzY3JvbGwgXSA+IDAgKTtcblx0XHRlbFsgc2Nyb2xsIF0gPSAwO1xuXHRcdHJldHVybiBoYXM7XG5cdH0sXG5cblx0Ly8gdGhlc2UgYXJlIG9kZCBmdW5jdGlvbnMsIGZpeCB0aGUgQVBJIG9yIG1vdmUgaW50byBpbmRpdmlkdWFsIHBsdWdpbnNcblx0aXNPdmVyQXhpczogZnVuY3Rpb24oIHgsIHJlZmVyZW5jZSwgc2l6ZSApIHtcblx0XHQvL0RldGVybWluZXMgd2hlbiB4IGNvb3JkaW5hdGUgaXMgb3ZlciBcImJcIiBlbGVtZW50IGF4aXNcblx0XHRyZXR1cm4gKCB4ID4gcmVmZXJlbmNlICkgJiYgKCB4IDwgKCByZWZlcmVuY2UgKyBzaXplICkgKTtcblx0fSxcblx0aXNPdmVyOiBmdW5jdGlvbiggeSwgeCwgdG9wLCBsZWZ0LCBoZWlnaHQsIHdpZHRoICkge1xuXHRcdC8vRGV0ZXJtaW5lcyB3aGVuIHgsIHkgY29vcmRpbmF0ZXMgaXMgb3ZlciBcImJcIiBlbGVtZW50XG5cdFx0cmV0dXJuICQudWkuaXNPdmVyQXhpcyggeSwgdG9wLCBoZWlnaHQgKSAmJiAkLnVpLmlzT3ZlckF4aXMoIHgsIGxlZnQsIHdpZHRoICk7XG5cdH1cbn0pO1xuXG59KSggalF1ZXJ5ICk7XG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxudmFyIHV1aWQgPSAwLFxuXHRzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcblx0X2NsZWFuRGF0YSA9ICQuY2xlYW5EYXRhO1xuJC5jbGVhbkRhdGEgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdGZvciAoIHZhciBpID0gMCwgZWxlbTsgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdHRyeSB7XG5cdFx0XHQkKCBlbGVtICkudHJpZ2dlckhhbmRsZXIoIFwicmVtb3ZlXCIgKTtcblx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC84MjM1XG5cdFx0fSBjYXRjaCggZSApIHt9XG5cdH1cblx0X2NsZWFuRGF0YSggZWxlbXMgKTtcbn07XG5cbiQud2lkZ2V0ID0gZnVuY3Rpb24oIG5hbWUsIGJhc2UsIHByb3RvdHlwZSApIHtcblx0dmFyIGZ1bGxOYW1lLCBleGlzdGluZ0NvbnN0cnVjdG9yLCBjb25zdHJ1Y3RvciwgYmFzZVByb3RvdHlwZSxcblx0XHRuYW1lc3BhY2UgPSBuYW1lLnNwbGl0KCBcIi5cIiApWyAwIF07XG5cblx0bmFtZSA9IG5hbWUuc3BsaXQoIFwiLlwiIClbIDEgXTtcblx0ZnVsbE5hbWUgPSBuYW1lc3BhY2UgKyBcIi1cIiArIG5hbWU7XG5cblx0aWYgKCAhcHJvdG90eXBlICkge1xuXHRcdHByb3RvdHlwZSA9IGJhc2U7XG5cdFx0YmFzZSA9ICQuV2lkZ2V0O1xuXHR9XG5cblx0Ly8gY3JlYXRlIHNlbGVjdG9yIGZvciBwbHVnaW5cblx0JC5leHByWyBcIjpcIiBdWyBmdWxsTmFtZS50b0xvd2VyQ2FzZSgpIF0gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIGZ1bGxOYW1lICk7XG5cdH07XG5cblx0JFsgbmFtZXNwYWNlIF0gPSAkWyBuYW1lc3BhY2UgXSB8fCB7fTtcblx0ZXhpc3RpbmdDb25zdHJ1Y3RvciA9ICRbIG5hbWVzcGFjZSBdWyBuYW1lIF07XG5cdGNvbnN0cnVjdG9yID0gJFsgbmFtZXNwYWNlIF1bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zLCBlbGVtZW50ICkge1xuXHRcdC8vIGFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCBcIm5ld1wiIGtleXdvcmRcblx0XHRpZiAoICF0aGlzLl9jcmVhdGVXaWRnZXQgKSB7XG5cdFx0XHRyZXR1cm4gbmV3IGNvbnN0cnVjdG9yKCBvcHRpb25zLCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0Ly8gYWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IGluaXRpYWxpemluZyBmb3Igc2ltcGxlIGluaGVyaXRhbmNlXG5cdFx0Ly8gbXVzdCB1c2UgXCJuZXdcIiBrZXl3b3JkICh0aGUgY29kZSBhYm92ZSBhbHdheXMgcGFzc2VzIGFyZ3MpXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5fY3JlYXRlV2lkZ2V0KCBvcHRpb25zLCBlbGVtZW50ICk7XG5cdFx0fVxuXHR9O1xuXHQvLyBleHRlbmQgd2l0aCB0aGUgZXhpc3RpbmcgY29uc3RydWN0b3IgdG8gY2Fycnkgb3ZlciBhbnkgc3RhdGljIHByb3BlcnRpZXNcblx0JC5leHRlbmQoIGNvbnN0cnVjdG9yLCBleGlzdGluZ0NvbnN0cnVjdG9yLCB7XG5cdFx0dmVyc2lvbjogcHJvdG90eXBlLnZlcnNpb24sXG5cdFx0Ly8gY29weSB0aGUgb2JqZWN0IHVzZWQgdG8gY3JlYXRlIHRoZSBwcm90b3R5cGUgaW4gY2FzZSB3ZSBuZWVkIHRvXG5cdFx0Ly8gcmVkZWZpbmUgdGhlIHdpZGdldCBsYXRlclxuXHRcdF9wcm90bzogJC5leHRlbmQoIHt9LCBwcm90b3R5cGUgKSxcblx0XHQvLyB0cmFjayB3aWRnZXRzIHRoYXQgaW5oZXJpdCBmcm9tIHRoaXMgd2lkZ2V0IGluIGNhc2UgdGhpcyB3aWRnZXQgaXNcblx0XHQvLyByZWRlZmluZWQgYWZ0ZXIgYSB3aWRnZXQgaW5oZXJpdHMgZnJvbSBpdFxuXHRcdF9jaGlsZENvbnN0cnVjdG9yczogW11cblx0fSk7XG5cblx0YmFzZVByb3RvdHlwZSA9IG5ldyBiYXNlKCk7XG5cdC8vIHdlIG5lZWQgdG8gbWFrZSB0aGUgb3B0aW9ucyBoYXNoIGEgcHJvcGVydHkgZGlyZWN0bHkgb24gdGhlIG5ldyBpbnN0YW5jZVxuXHQvLyBvdGhlcndpc2Ugd2UnbGwgbW9kaWZ5IHRoZSBvcHRpb25zIGhhc2ggb24gdGhlIHByb3RvdHlwZSB0aGF0IHdlJ3JlXG5cdC8vIGluaGVyaXRpbmcgZnJvbVxuXHRiYXNlUHJvdG90eXBlLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LCBiYXNlUHJvdG90eXBlLm9wdGlvbnMgKTtcblx0JC5lYWNoKCBwcm90b3R5cGUsIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRpZiAoICQuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHByb3RvdHlwZVsgcHJvcCBdID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgX3N1cGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYmFzZS5wcm90b3R5cGVbIHByb3AgXS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRfc3VwZXJBcHBseSA9IGZ1bmN0aW9uKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGJhc2UucHJvdG90eXBlWyBwcm9wIF0uYXBwbHkoIHRoaXMsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIF9fc3VwZXIgPSB0aGlzLl9zdXBlcixcblx0XHRcdFx0XHRcdF9fc3VwZXJBcHBseSA9IHRoaXMuX3N1cGVyQXBwbHksXG5cdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZTtcblxuXHRcdFx0XHRcdHRoaXMuX3N1cGVyID0gX3N1cGVyO1xuXHRcdFx0XHRcdHRoaXMuX3N1cGVyQXBwbHkgPSBfc3VwZXJBcHBseTtcblxuXHRcdFx0XHRcdHJldHVyblZhbHVlID0gdmFsdWUuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfX3N1cGVyO1xuXHRcdFx0XHRcdHRoaXMuX3N1cGVyQXBwbHkgPSBfX3N1cGVyQXBwbHk7XG5cblx0XHRcdFx0XHRyZXR1cm4gcmV0dXJuVmFsdWU7XG5cdFx0XHRcdH07XG5cdFx0XHR9KSgpO1xuXHRcdH1cblx0fSk7XG5cdGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9ICQud2lkZ2V0LmV4dGVuZCggYmFzZVByb3RvdHlwZSwge1xuXHRcdC8vIFRPRE86IHJlbW92ZSBzdXBwb3J0IGZvciB3aWRnZXRFdmVudFByZWZpeFxuXHRcdC8vIGFsd2F5cyB1c2UgdGhlIG5hbWUgKyBhIGNvbG9uIGFzIHRoZSBwcmVmaXgsIGUuZy4sIGRyYWdnYWJsZTpzdGFydFxuXHRcdC8vIGRvbid0IHByZWZpeCBmb3Igd2lkZ2V0cyB0aGF0IGFyZW4ndCBET00tYmFzZWRcblx0XHR3aWRnZXRFdmVudFByZWZpeDogZXhpc3RpbmdDb25zdHJ1Y3RvciA/IGJhc2VQcm90b3R5cGUud2lkZ2V0RXZlbnRQcmVmaXggOiBuYW1lXG5cdH0sIHByb3RvdHlwZSwge1xuXHRcdGNvbnN0cnVjdG9yOiBjb25zdHJ1Y3Rvcixcblx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZSxcblx0XHR3aWRnZXROYW1lOiBuYW1lLFxuXHRcdC8vIFRPRE8gcmVtb3ZlIHdpZGdldEJhc2VDbGFzcywgc2VlICM4MTU1XG5cdFx0d2lkZ2V0QmFzZUNsYXNzOiBmdWxsTmFtZSxcblx0XHR3aWRnZXRGdWxsTmFtZTogZnVsbE5hbWVcblx0fSk7XG5cblx0Ly8gSWYgdGhpcyB3aWRnZXQgaXMgYmVpbmcgcmVkZWZpbmVkIHRoZW4gd2UgbmVlZCB0byBmaW5kIGFsbCB3aWRnZXRzIHRoYXRcblx0Ly8gYXJlIGluaGVyaXRpbmcgZnJvbSBpdCBhbmQgcmVkZWZpbmUgYWxsIG9mIHRoZW0gc28gdGhhdCB0aGV5IGluaGVyaXQgZnJvbVxuXHQvLyB0aGUgbmV3IHZlcnNpb24gb2YgdGhpcyB3aWRnZXQuIFdlJ3JlIGVzc2VudGlhbGx5IHRyeWluZyB0byByZXBsYWNlIG9uZVxuXHQvLyBsZXZlbCBpbiB0aGUgcHJvdG90eXBlIGNoYWluLlxuXHRpZiAoIGV4aXN0aW5nQ29uc3RydWN0b3IgKSB7XG5cdFx0JC5lYWNoKCBleGlzdGluZ0NvbnN0cnVjdG9yLl9jaGlsZENvbnN0cnVjdG9ycywgZnVuY3Rpb24oIGksIGNoaWxkICkge1xuXHRcdFx0dmFyIGNoaWxkUHJvdG90eXBlID0gY2hpbGQucHJvdG90eXBlO1xuXG5cdFx0XHQvLyByZWRlZmluZSB0aGUgY2hpbGQgd2lkZ2V0IHVzaW5nIHRoZSBzYW1lIHByb3RvdHlwZSB0aGF0IHdhc1xuXHRcdFx0Ly8gb3JpZ2luYWxseSB1c2VkLCBidXQgaW5oZXJpdCBmcm9tIHRoZSBuZXcgdmVyc2lvbiBvZiB0aGUgYmFzZVxuXHRcdFx0JC53aWRnZXQoIGNoaWxkUHJvdG90eXBlLm5hbWVzcGFjZSArIFwiLlwiICsgY2hpbGRQcm90b3R5cGUud2lkZ2V0TmFtZSwgY29uc3RydWN0b3IsIGNoaWxkLl9wcm90byApO1xuXHRcdH0pO1xuXHRcdC8vIHJlbW92ZSB0aGUgbGlzdCBvZiBleGlzdGluZyBjaGlsZCBjb25zdHJ1Y3RvcnMgZnJvbSB0aGUgb2xkIGNvbnN0cnVjdG9yXG5cdFx0Ly8gc28gdGhlIG9sZCBjaGlsZCBjb25zdHJ1Y3RvcnMgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG5cdFx0ZGVsZXRlIGV4aXN0aW5nQ29uc3RydWN0b3IuX2NoaWxkQ29uc3RydWN0b3JzO1xuXHR9IGVsc2Uge1xuXHRcdGJhc2UuX2NoaWxkQ29uc3RydWN0b3JzLnB1c2goIGNvbnN0cnVjdG9yICk7XG5cdH1cblxuXHQkLndpZGdldC5icmlkZ2UoIG5hbWUsIGNvbnN0cnVjdG9yICk7XG59O1xuXG4kLndpZGdldC5leHRlbmQgPSBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHR2YXIgaW5wdXQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKSxcblx0XHRpbnB1dEluZGV4ID0gMCxcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHRrZXksXG5cdFx0dmFsdWU7XG5cdGZvciAoIDsgaW5wdXRJbmRleCA8IGlucHV0TGVuZ3RoOyBpbnB1dEluZGV4KysgKSB7XG5cdFx0Zm9yICgga2V5IGluIGlucHV0WyBpbnB1dEluZGV4IF0gKSB7XG5cdFx0XHR2YWx1ZSA9IGlucHV0WyBpbnB1dEluZGV4IF1bIGtleSBdO1xuXHRcdFx0aWYgKCBpbnB1dFsgaW5wdXRJbmRleCBdLmhhc093blByb3BlcnR5KCBrZXkgKSAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQvLyBDbG9uZSBvYmplY3RzXG5cdFx0XHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCB2YWx1ZSApICkge1xuXHRcdFx0XHRcdHRhcmdldFsga2V5IF0gPSAkLmlzUGxhaW5PYmplY3QoIHRhcmdldFsga2V5IF0gKSA/XG5cdFx0XHRcdFx0XHQkLndpZGdldC5leHRlbmQoIHt9LCB0YXJnZXRbIGtleSBdLCB2YWx1ZSApIDpcblx0XHRcdFx0XHRcdC8vIERvbid0IGV4dGVuZCBzdHJpbmdzLCBhcnJheXMsIGV0Yy4gd2l0aCBvYmplY3RzXG5cdFx0XHRcdFx0XHQkLndpZGdldC5leHRlbmQoIHt9LCB2YWx1ZSApO1xuXHRcdFx0XHQvLyBDb3B5IGV2ZXJ5dGhpbmcgZWxzZSBieSByZWZlcmVuY2Vcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXRbIGtleSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbiQud2lkZ2V0LmJyaWRnZSA9IGZ1bmN0aW9uKCBuYW1lLCBvYmplY3QgKSB7XG5cdHZhciBmdWxsTmFtZSA9IG9iamVjdC5wcm90b3R5cGUud2lkZ2V0RnVsbE5hbWUgfHwgbmFtZTtcblx0JC5mblsgbmFtZSBdID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGlzTWV0aG9kQ2FsbCA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiLFxuXHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApLFxuXHRcdFx0cmV0dXJuVmFsdWUgPSB0aGlzO1xuXG5cdFx0Ly8gYWxsb3cgbXVsdGlwbGUgaGFzaGVzIHRvIGJlIHBhc3NlZCBvbiBpbml0XG5cdFx0b3B0aW9ucyA9ICFpc01ldGhvZENhbGwgJiYgYXJncy5sZW5ndGggP1xuXHRcdFx0JC53aWRnZXQuZXh0ZW5kLmFwcGx5KCBudWxsLCBbIG9wdGlvbnMgXS5jb25jYXQoYXJncykgKSA6XG5cdFx0XHRvcHRpb25zO1xuXG5cdFx0aWYgKCBpc01ldGhvZENhbGwgKSB7XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBtZXRob2RWYWx1ZSxcblx0XHRcdFx0XHRpbnN0YW5jZSA9ICQuZGF0YSggdGhpcywgZnVsbE5hbWUgKTtcblx0XHRcdFx0aWYgKCAhaW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuZXJyb3IoIFwiY2Fubm90IGNhbGwgbWV0aG9kcyBvbiBcIiArIG5hbWUgKyBcIiBwcmlvciB0byBpbml0aWFsaXphdGlvbjsgXCIgK1xuXHRcdFx0XHRcdFx0XCJhdHRlbXB0ZWQgdG8gY2FsbCBtZXRob2QgJ1wiICsgb3B0aW9ucyArIFwiJ1wiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhJC5pc0Z1bmN0aW9uKCBpbnN0YW5jZVtvcHRpb25zXSApIHx8IG9wdGlvbnMuY2hhckF0KCAwICkgPT09IFwiX1wiICkge1xuXHRcdFx0XHRcdHJldHVybiAkLmVycm9yKCBcIm5vIHN1Y2ggbWV0aG9kICdcIiArIG9wdGlvbnMgKyBcIicgZm9yIFwiICsgbmFtZSArIFwiIHdpZGdldCBpbnN0YW5jZVwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWV0aG9kVmFsdWUgPSBpbnN0YW5jZVsgb3B0aW9ucyBdLmFwcGx5KCBpbnN0YW5jZSwgYXJncyApO1xuXHRcdFx0XHRpZiAoIG1ldGhvZFZhbHVlICE9PSBpbnN0YW5jZSAmJiBtZXRob2RWYWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVyblZhbHVlID0gbWV0aG9kVmFsdWUgJiYgbWV0aG9kVmFsdWUuanF1ZXJ5ID9cblx0XHRcdFx0XHRcdHJldHVyblZhbHVlLnB1c2hTdGFjayggbWV0aG9kVmFsdWUuZ2V0KCkgKSA6XG5cdFx0XHRcdFx0XHRtZXRob2RWYWx1ZTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpbnN0YW5jZSA9ICQuZGF0YSggdGhpcywgZnVsbE5hbWUgKTtcblx0XHRcdFx0aWYgKCBpbnN0YW5jZSApIHtcblx0XHRcdFx0XHRpbnN0YW5jZS5vcHRpb24oIG9wdGlvbnMgfHwge30gKS5faW5pdCgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCQuZGF0YSggdGhpcywgZnVsbE5hbWUsIG5ldyBvYmplY3QoIG9wdGlvbnMsIHRoaXMgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0dXJuVmFsdWU7XG5cdH07XG59O1xuXG4kLldpZGdldCA9IGZ1bmN0aW9uKCAvKiBvcHRpb25zLCBlbGVtZW50ICovICkge307XG4kLldpZGdldC5fY2hpbGRDb25zdHJ1Y3RvcnMgPSBbXTtcblxuJC5XaWRnZXQucHJvdG90eXBlID0ge1xuXHR3aWRnZXROYW1lOiBcIndpZGdldFwiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJcIixcblx0ZGVmYXVsdEVsZW1lbnQ6IFwiPGRpdj5cIixcblx0b3B0aW9uczoge1xuXHRcdGRpc2FibGVkOiBmYWxzZSxcblxuXHRcdC8vIGNhbGxiYWNrc1xuXHRcdGNyZWF0ZTogbnVsbFxuXHR9LFxuXHRfY3JlYXRlV2lkZ2V0OiBmdW5jdGlvbiggb3B0aW9ucywgZWxlbWVudCApIHtcblx0XHRlbGVtZW50ID0gJCggZWxlbWVudCB8fCB0aGlzLmRlZmF1bHRFbGVtZW50IHx8IHRoaXMgKVsgMCBdO1xuXHRcdHRoaXMuZWxlbWVudCA9ICQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLnV1aWQgPSB1dWlkKys7XG5cdFx0dGhpcy5ldmVudE5hbWVzcGFjZSA9IFwiLlwiICsgdGhpcy53aWRnZXROYW1lICsgdGhpcy51dWlkO1xuXHRcdHRoaXMub3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZCgge30sXG5cdFx0XHR0aGlzLm9wdGlvbnMsXG5cdFx0XHR0aGlzLl9nZXRDcmVhdGVPcHRpb25zKCksXG5cdFx0XHRvcHRpb25zICk7XG5cblx0XHR0aGlzLmJpbmRpbmdzID0gJCgpO1xuXHRcdHRoaXMuaG92ZXJhYmxlID0gJCgpO1xuXHRcdHRoaXMuZm9jdXNhYmxlID0gJCgpO1xuXG5cdFx0aWYgKCBlbGVtZW50ICE9PSB0aGlzICkge1xuXHRcdFx0Ly8gMS45IEJDIGZvciAjNzgxMFxuXHRcdFx0Ly8gVE9ETyByZW1vdmUgZHVhbCBzdG9yYWdlXG5cdFx0XHQkLmRhdGEoIGVsZW1lbnQsIHRoaXMud2lkZ2V0TmFtZSwgdGhpcyApO1xuXHRcdFx0JC5kYXRhKCBlbGVtZW50LCB0aGlzLndpZGdldEZ1bGxOYW1lLCB0aGlzICk7XG5cdFx0XHR0aGlzLl9vbiggdHJ1ZSwgdGhpcy5lbGVtZW50LCB7XG5cdFx0XHRcdHJlbW92ZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdGlmICggZXZlbnQudGFyZ2V0ID09PSBlbGVtZW50ICkge1xuXHRcdFx0XHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuZG9jdW1lbnQgPSAkKCBlbGVtZW50LnN0eWxlID9cblx0XHRcdFx0Ly8gZWxlbWVudCB3aXRoaW4gdGhlIGRvY3VtZW50XG5cdFx0XHRcdGVsZW1lbnQub3duZXJEb2N1bWVudCA6XG5cdFx0XHRcdC8vIGVsZW1lbnQgaXMgd2luZG93IG9yIGRvY3VtZW50XG5cdFx0XHRcdGVsZW1lbnQuZG9jdW1lbnQgfHwgZWxlbWVudCApO1xuXHRcdFx0dGhpcy53aW5kb3cgPSAkKCB0aGlzLmRvY3VtZW50WzBdLmRlZmF1bHRWaWV3IHx8IHRoaXMuZG9jdW1lbnRbMF0ucGFyZW50V2luZG93ICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fY3JlYXRlKCk7XG5cdFx0dGhpcy5fdHJpZ2dlciggXCJjcmVhdGVcIiwgbnVsbCwgdGhpcy5fZ2V0Q3JlYXRlRXZlbnREYXRhKCkgKTtcblx0XHR0aGlzLl9pbml0KCk7XG5cdH0sXG5cdF9nZXRDcmVhdGVPcHRpb25zOiAkLm5vb3AsXG5cdF9nZXRDcmVhdGVFdmVudERhdGE6ICQubm9vcCxcblx0X2NyZWF0ZTogJC5ub29wLFxuXHRfaW5pdDogJC5ub29wLFxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2Rlc3Ryb3koKTtcblx0XHQvLyB3ZSBjYW4gcHJvYmFibHkgcmVtb3ZlIHRoZSB1bmJpbmQgY2FsbHMgaW4gMi4wXG5cdFx0Ly8gYWxsIGV2ZW50IGJpbmRpbmdzIHNob3VsZCBnbyB0aHJvdWdoIHRoaXMuX29uKClcblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC51bmJpbmQoIHRoaXMuZXZlbnROYW1lc3BhY2UgKVxuXHRcdFx0Ly8gMS45IEJDIGZvciAjNzgxMFxuXHRcdFx0Ly8gVE9ETyByZW1vdmUgZHVhbCBzdG9yYWdlXG5cdFx0XHQucmVtb3ZlRGF0YSggdGhpcy53aWRnZXROYW1lIClcblx0XHRcdC5yZW1vdmVEYXRhKCB0aGlzLndpZGdldEZ1bGxOYW1lIClcblx0XHRcdC8vIHN1cHBvcnQ6IGpxdWVyeSA8MS42LjNcblx0XHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0Lzk0MTNcblx0XHRcdC5yZW1vdmVEYXRhKCAkLmNhbWVsQ2FzZSggdGhpcy53aWRnZXRGdWxsTmFtZSApICk7XG5cdFx0dGhpcy53aWRnZXQoKVxuXHRcdFx0LnVuYmluZCggdGhpcy5ldmVudE5hbWVzcGFjZSApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWRpc2FibGVkXCIgKVxuXHRcdFx0LnJlbW92ZUNsYXNzKFxuXHRcdFx0XHR0aGlzLndpZGdldEZ1bGxOYW1lICsgXCItZGlzYWJsZWQgXCIgK1xuXHRcdFx0XHRcInVpLXN0YXRlLWRpc2FibGVkXCIgKTtcblxuXHRcdC8vIGNsZWFuIHVwIGV2ZW50cyBhbmQgc3RhdGVzXG5cdFx0dGhpcy5iaW5kaW5ncy51bmJpbmQoIHRoaXMuZXZlbnROYW1lc3BhY2UgKTtcblx0XHR0aGlzLmhvdmVyYWJsZS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0dGhpcy5mb2N1c2FibGUucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHR9LFxuXHRfZGVzdHJveTogJC5ub29wLFxuXG5cdHdpZGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWxlbWVudDtcblx0fSxcblxuXHRvcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBvcHRpb25zID0ga2V5LFxuXHRcdFx0cGFydHMsXG5cdFx0XHRjdXJPcHRpb24sXG5cdFx0XHRpO1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAwICkge1xuXHRcdFx0Ly8gZG9uJ3QgcmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnRlcm5hbCBoYXNoXG5cdFx0XHRyZXR1cm4gJC53aWRnZXQuZXh0ZW5kKCB7fSwgdGhpcy5vcHRpb25zICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Ly8gaGFuZGxlIG5lc3RlZCBrZXlzLCBlLmcuLCBcImZvby5iYXJcIiA9PiB7IGZvbzogeyBiYXI6IF9fXyB9IH1cblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRcdHBhcnRzID0ga2V5LnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0a2V5ID0gcGFydHMuc2hpZnQoKTtcblx0XHRcdGlmICggcGFydHMubGVuZ3RoICkge1xuXHRcdFx0XHRjdXJPcHRpb24gPSBvcHRpb25zWyBrZXkgXSA9ICQud2lkZ2V0LmV4dGVuZCgge30sIHRoaXMub3B0aW9uc1sga2V5IF0gKTtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKysgKSB7XG5cdFx0XHRcdFx0Y3VyT3B0aW9uWyBwYXJ0c1sgaSBdIF0gPSBjdXJPcHRpb25bIHBhcnRzWyBpIF0gXSB8fCB7fTtcblx0XHRcdFx0XHRjdXJPcHRpb24gPSBjdXJPcHRpb25bIHBhcnRzWyBpIF0gXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXkgPSBwYXJ0cy5wb3AoKTtcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBjdXJPcHRpb25bIGtleSBdID09PSB1bmRlZmluZWQgPyBudWxsIDogY3VyT3B0aW9uWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdXJPcHRpb25bIGtleSBdID0gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uc1sga2V5IF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiB0aGlzLm9wdGlvbnNbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9wdGlvbnNbIGtleSBdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2V0T3B0aW9ucyggb3B0aW9ucyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdF9zZXRPcHRpb25zOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIga2V5O1xuXG5cdFx0Zm9yICgga2V5IGluIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb24oIGtleSwgb3B0aW9uc1sga2V5IF0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dGhpcy5vcHRpb25zWyBrZXkgXSA9IHZhbHVlO1xuXG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdHRoaXMud2lkZ2V0KClcblx0XHRcdFx0LnRvZ2dsZUNsYXNzKCB0aGlzLndpZGdldEZ1bGxOYW1lICsgXCItZGlzYWJsZWQgdWktc3RhdGUtZGlzYWJsZWRcIiwgISF2YWx1ZSApXG5cdFx0XHRcdC5hdHRyKCBcImFyaWEtZGlzYWJsZWRcIiwgdmFsdWUgKTtcblx0XHRcdHRoaXMuaG92ZXJhYmxlLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdHRoaXMuZm9jdXNhYmxlLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRPcHRpb24oIFwiZGlzYWJsZWRcIiwgZmFsc2UgKTtcblx0fSxcblx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldE9wdGlvbiggXCJkaXNhYmxlZFwiLCB0cnVlICk7XG5cdH0sXG5cblx0X29uOiBmdW5jdGlvbiggc3VwcHJlc3NEaXNhYmxlZENoZWNrLCBlbGVtZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgZGVsZWdhdGVFbGVtZW50LFxuXHRcdFx0aW5zdGFuY2UgPSB0aGlzO1xuXG5cdFx0Ly8gbm8gc3VwcHJlc3NEaXNhYmxlZENoZWNrIGZsYWcsIHNodWZmbGUgYXJndW1lbnRzXG5cdFx0aWYgKCB0eXBlb2Ygc3VwcHJlc3NEaXNhYmxlZENoZWNrICE9PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdGhhbmRsZXJzID0gZWxlbWVudDtcblx0XHRcdGVsZW1lbnQgPSBzdXBwcmVzc0Rpc2FibGVkQ2hlY2s7XG5cdFx0XHRzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBubyBlbGVtZW50IGFyZ3VtZW50LCBzaHVmZmxlIGFuZCB1c2UgdGhpcy5lbGVtZW50XG5cdFx0aWYgKCAhaGFuZGxlcnMgKSB7XG5cdFx0XHRoYW5kbGVycyA9IGVsZW1lbnQ7XG5cdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXHRcdFx0ZGVsZWdhdGVFbGVtZW50ID0gdGhpcy53aWRnZXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gYWNjZXB0IHNlbGVjdG9ycywgRE9NIGVsZW1lbnRzXG5cdFx0XHRlbGVtZW50ID0gZGVsZWdhdGVFbGVtZW50ID0gJCggZWxlbWVudCApO1xuXHRcdFx0dGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuYWRkKCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0JC5lYWNoKCBoYW5kbGVycywgZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVyICkge1xuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xuXHRcdFx0XHQvLyBhbGxvdyB3aWRnZXRzIHRvIGN1c3RvbWl6ZSB0aGUgZGlzYWJsZWQgaGFuZGxpbmdcblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBhcyBhbiBhcnJheSBpbnN0ZWFkIG9mIGJvb2xlYW5cblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBjbGFzcyBhcyBtZXRob2QgZm9yIGRpc2FibGluZyBpbmRpdmlkdWFsIHBhcnRzXG5cdFx0XHRcdGlmICggIXN1cHByZXNzRGlzYWJsZWRDaGVjayAmJlxuXHRcdFx0XHRcdFx0KCBpbnN0YW5jZS5vcHRpb25zLmRpc2FibGVkID09PSB0cnVlIHx8XG5cdFx0XHRcdFx0XHRcdCQoIHRoaXMgKS5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXG5cdFx0XHRcdFx0LmFwcGx5KCBpbnN0YW5jZSwgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvcHkgdGhlIGd1aWQgc28gZGlyZWN0IHVuYmluZGluZyB3b3Jrc1xuXHRcdFx0aWYgKCB0eXBlb2YgaGFuZGxlciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0aGFuZGxlclByb3h5Lmd1aWQgPSBoYW5kbGVyLmd1aWQgPVxuXHRcdFx0XHRcdGhhbmRsZXIuZ3VpZCB8fCBoYW5kbGVyUHJveHkuZ3VpZCB8fCAkLmd1aWQrKztcblx0XHRcdH1cblxuXHRcdFx0dmFyIG1hdGNoID0gZXZlbnQubWF0Y2goIC9eKFxcdyspXFxzKiguKikkLyApLFxuXHRcdFx0XHRldmVudE5hbWUgPSBtYXRjaFsxXSArIGluc3RhbmNlLmV2ZW50TmFtZXNwYWNlLFxuXHRcdFx0XHRzZWxlY3RvciA9IG1hdGNoWzJdO1xuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0ZGVsZWdhdGVFbGVtZW50LmRlbGVnYXRlKCBzZWxlY3RvciwgZXZlbnROYW1lLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnQuYmluZCggZXZlbnROYW1lLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRfb2ZmOiBmdW5jdGlvbiggZWxlbWVudCwgZXZlbnROYW1lICkge1xuXHRcdGV2ZW50TmFtZSA9IChldmVudE5hbWUgfHwgXCJcIikuc3BsaXQoIFwiIFwiICkuam9pbiggdGhpcy5ldmVudE5hbWVzcGFjZSArIFwiIFwiICkgKyB0aGlzLmV2ZW50TmFtZXNwYWNlO1xuXHRcdGVsZW1lbnQudW5iaW5kKCBldmVudE5hbWUgKS51bmRlbGVnYXRlKCBldmVudE5hbWUgKTtcblx0fSxcblxuXHRfZGVsYXk6IGZ1bmN0aW9uKCBoYW5kbGVyLCBkZWxheSApIHtcblx0XHRmdW5jdGlvbiBoYW5kbGVyUHJveHkoKSB7XG5cdFx0XHRyZXR1cm4gKCB0eXBlb2YgaGFuZGxlciA9PT0gXCJzdHJpbmdcIiA/IGluc3RhbmNlWyBoYW5kbGVyIF0gOiBoYW5kbGVyIClcblx0XHRcdFx0LmFwcGx5KCBpbnN0YW5jZSwgYXJndW1lbnRzICk7XG5cdFx0fVxuXHRcdHZhciBpbnN0YW5jZSA9IHRoaXM7XG5cdFx0cmV0dXJuIHNldFRpbWVvdXQoIGhhbmRsZXJQcm94eSwgZGVsYXkgfHwgMCApO1xuXHR9LFxuXG5cdF9ob3ZlcmFibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHRoaXMuaG92ZXJhYmxlID0gdGhpcy5ob3ZlcmFibGUuYWRkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy5fb24oIGVsZW1lbnQsIHtcblx0XHRcdG1vdXNlZW50ZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0JCggZXZlbnQuY3VycmVudFRhcmdldCApLmFkZENsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdH0sXG5cdFx0XHRtb3VzZWxlYXZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X2ZvY3VzYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dGhpcy5mb2N1c2FibGUgPSB0aGlzLmZvY3VzYWJsZS5hZGQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLl9vbiggZWxlbWVudCwge1xuXHRcdFx0Zm9jdXNpbjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQkKCBldmVudC5jdXJyZW50VGFyZ2V0ICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fSxcblx0XHRcdGZvY3Vzb3V0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X3RyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBldmVudCwgZGF0YSApIHtcblx0XHR2YXIgcHJvcCwgb3JpZyxcblx0XHRcdGNhbGxiYWNrID0gdGhpcy5vcHRpb25zWyB0eXBlIF07XG5cblx0XHRkYXRhID0gZGF0YSB8fCB7fTtcblx0XHRldmVudCA9ICQuRXZlbnQoIGV2ZW50ICk7XG5cdFx0ZXZlbnQudHlwZSA9ICggdHlwZSA9PT0gdGhpcy53aWRnZXRFdmVudFByZWZpeCA/XG5cdFx0XHR0eXBlIDpcblx0XHRcdHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggKyB0eXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHQvLyB0aGUgb3JpZ2luYWwgZXZlbnQgbWF5IGNvbWUgZnJvbSBhbnkgZWxlbWVudFxuXHRcdC8vIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHRhcmdldCBvbiB0aGUgbmV3IGV2ZW50XG5cdFx0ZXZlbnQudGFyZ2V0ID0gdGhpcy5lbGVtZW50WyAwIF07XG5cblx0XHQvLyBjb3B5IG9yaWdpbmFsIGV2ZW50IHByb3BlcnRpZXMgb3ZlciB0byB0aGUgbmV3IGV2ZW50XG5cdFx0b3JpZyA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG5cdFx0aWYgKCBvcmlnICkge1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRpZiAoICEoIHByb3AgaW4gZXZlbnQgKSApIHtcblx0XHRcdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ1sgcHJvcCBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoIGV2ZW50LCBkYXRhICk7XG5cdFx0cmV0dXJuICEoICQuaXNGdW5jdGlvbiggY2FsbGJhY2sgKSAmJlxuXHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMuZWxlbWVudFswXSwgWyBldmVudCBdLmNvbmNhdCggZGF0YSApICkgPT09IGZhbHNlIHx8XG5cdFx0XHRldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApO1xuXHR9XG59O1xuXG4kLmVhY2goIHsgc2hvdzogXCJmYWRlSW5cIiwgaGlkZTogXCJmYWRlT3V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgZGVmYXVsdEVmZmVjdCApIHtcblx0JC5XaWRnZXQucHJvdG90eXBlWyBcIl9cIiArIG1ldGhvZCBdID0gZnVuY3Rpb24oIGVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvcHRpb25zID0geyBlZmZlY3Q6IG9wdGlvbnMgfTtcblx0XHR9XG5cdFx0dmFyIGhhc09wdGlvbnMsXG5cdFx0XHRlZmZlY3ROYW1lID0gIW9wdGlvbnMgP1xuXHRcdFx0XHRtZXRob2QgOlxuXHRcdFx0XHRvcHRpb25zID09PSB0cnVlIHx8IHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiID9cblx0XHRcdFx0XHRkZWZhdWx0RWZmZWN0IDpcblx0XHRcdFx0XHRvcHRpb25zLmVmZmVjdCB8fCBkZWZhdWx0RWZmZWN0O1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRvcHRpb25zID0geyBkdXJhdGlvbjogb3B0aW9ucyB9O1xuXHRcdH1cblx0XHRoYXNPcHRpb25zID0gISQuaXNFbXB0eU9iamVjdCggb3B0aW9ucyApO1xuXHRcdG9wdGlvbnMuY29tcGxldGUgPSBjYWxsYmFjaztcblx0XHRpZiAoIG9wdGlvbnMuZGVsYXkgKSB7XG5cdFx0XHRlbGVtZW50LmRlbGF5KCBvcHRpb25zLmRlbGF5ICk7XG5cdFx0fVxuXHRcdGlmICggaGFzT3B0aW9ucyAmJiAkLmVmZmVjdHMgJiYgKCAkLmVmZmVjdHMuZWZmZWN0WyBlZmZlY3ROYW1lIF0gfHwgJC51aUJhY2tDb21wYXQgIT09IGZhbHNlICYmICQuZWZmZWN0c1sgZWZmZWN0TmFtZSBdICkgKSB7XG5cdFx0XHRlbGVtZW50WyBtZXRob2QgXSggb3B0aW9ucyApO1xuXHRcdH0gZWxzZSBpZiAoIGVmZmVjdE5hbWUgIT09IG1ldGhvZCAmJiBlbGVtZW50WyBlZmZlY3ROYW1lIF0gKSB7XG5cdFx0XHRlbGVtZW50WyBlZmZlY3ROYW1lIF0oIG9wdGlvbnMuZHVyYXRpb24sIG9wdGlvbnMuZWFzaW5nLCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtZW50LnF1ZXVlKGZ1bmN0aW9uKCBuZXh0ICkge1xuXHRcdFx0XHQkKCB0aGlzIClbIG1ldGhvZCBdKCk7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCggZWxlbWVudFsgMCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmV4dCgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xufSk7XG5cbi8vIERFUFJFQ0FURURcbmlmICggJC51aUJhY2tDb21wYXQgIT09IGZhbHNlICkge1xuXHQkLldpZGdldC5wcm90b3R5cGUuX2dldENyZWF0ZU9wdGlvbnMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJC5tZXRhZGF0YSAmJiAkLm1ldGFkYXRhLmdldCggdGhpcy5lbGVtZW50WzBdIClbIHRoaXMud2lkZ2V0TmFtZSBdO1xuXHR9O1xufVxuXG59KSggalF1ZXJ5ICk7XG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxudmFyIG1vdXNlSGFuZGxlZCA9IGZhbHNlO1xuJCggZG9jdW1lbnQgKS5tb3VzZXVwKCBmdW5jdGlvbiggZSApIHtcblx0bW91c2VIYW5kbGVkID0gZmFsc2U7XG59KTtcblxuJC53aWRnZXQoXCJ1aS5tb3VzZVwiLCB7XG5cdHZlcnNpb246IFwiMS45LjJcIixcblx0b3B0aW9uczoge1xuXHRcdGNhbmNlbDogJ2lucHV0LHRleHRhcmVhLGJ1dHRvbixzZWxlY3Qsb3B0aW9uJyxcblx0XHRkaXN0YW5jZTogMSxcblx0XHRkZWxheTogMFxuXHR9LFxuXHRfbW91c2VJbml0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5iaW5kKCdtb3VzZWRvd24uJyt0aGlzLndpZGdldE5hbWUsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdHJldHVybiB0aGF0Ll9tb3VzZURvd24oZXZlbnQpO1xuXHRcdFx0fSlcblx0XHRcdC5iaW5kKCdjbGljay4nK3RoaXMud2lkZ2V0TmFtZSwgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0aWYgKHRydWUgPT09ICQuZGF0YShldmVudC50YXJnZXQsIHRoYXQud2lkZ2V0TmFtZSArICcucHJldmVudENsaWNrRXZlbnQnKSkge1xuXHRcdFx0XHRcdCQucmVtb3ZlRGF0YShldmVudC50YXJnZXQsIHRoYXQud2lkZ2V0TmFtZSArICcucHJldmVudENsaWNrRXZlbnQnKTtcblx0XHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0dGhpcy5zdGFydGVkID0gZmFsc2U7XG5cdH0sXG5cblx0Ly8gVE9ETzogbWFrZSBzdXJlIGRlc3Ryb3lpbmcgb25lIGluc3RhbmNlIG9mIG1vdXNlIGRvZXNuJ3QgbWVzcyB3aXRoXG5cdC8vIG90aGVyIGluc3RhbmNlcyBvZiBtb3VzZVxuXHRfbW91c2VEZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnQudW5iaW5kKCcuJyt0aGlzLndpZGdldE5hbWUpO1xuXHRcdGlmICggdGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUgKSB7XG5cdFx0XHQkKGRvY3VtZW50KVxuXHRcdFx0XHQudW5iaW5kKCdtb3VzZW1vdmUuJyt0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlKVxuXHRcdFx0XHQudW5iaW5kKCdtb3VzZXVwLicrdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZVVwRGVsZWdhdGUpO1xuXHRcdH1cblx0fSxcblxuXHRfbW91c2VEb3duOiBmdW5jdGlvbihldmVudCkge1xuXHRcdC8vIGRvbid0IGxldCBtb3JlIHRoYW4gb25lIHdpZGdldCBoYW5kbGUgbW91c2VTdGFydFxuXHRcdGlmKCBtb3VzZUhhbmRsZWQgKSB7IHJldHVybjsgfVxuXG5cdFx0Ly8gd2UgbWF5IGhhdmUgbWlzc2VkIG1vdXNldXAgKG91dCBvZiB3aW5kb3cpXG5cdFx0KHRoaXMuX21vdXNlU3RhcnRlZCAmJiB0aGlzLl9tb3VzZVVwKGV2ZW50KSk7XG5cblx0XHR0aGlzLl9tb3VzZURvd25FdmVudCA9IGV2ZW50O1xuXG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0YnRuSXNMZWZ0ID0gKGV2ZW50LndoaWNoID09PSAxKSxcblx0XHRcdC8vIGV2ZW50LnRhcmdldC5ub2RlTmFtZSB3b3JrcyBhcm91bmQgYSBidWcgaW4gSUUgOCB3aXRoXG5cdFx0XHQvLyBkaXNhYmxlZCBpbnB1dHMgKCM3NjIwKVxuXHRcdFx0ZWxJc0NhbmNlbCA9ICh0eXBlb2YgdGhpcy5vcHRpb25zLmNhbmNlbCA9PT0gXCJzdHJpbmdcIiAmJiBldmVudC50YXJnZXQubm9kZU5hbWUgPyAkKGV2ZW50LnRhcmdldCkuY2xvc2VzdCh0aGlzLm9wdGlvbnMuY2FuY2VsKS5sZW5ndGggOiBmYWxzZSk7XG5cdFx0aWYgKCFidG5Jc0xlZnQgfHwgZWxJc0NhbmNlbCB8fCAhdGhpcy5fbW91c2VDYXB0dXJlKGV2ZW50KSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0dGhpcy5tb3VzZURlbGF5TWV0ID0gIXRoaXMub3B0aW9ucy5kZWxheTtcblx0XHRpZiAoIXRoaXMubW91c2VEZWxheU1ldCkge1xuXHRcdFx0dGhpcy5fbW91c2VEZWxheVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhhdC5tb3VzZURlbGF5TWV0ID0gdHJ1ZTtcblx0XHRcdH0sIHRoaXMub3B0aW9ucy5kZWxheSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX21vdXNlRGlzdGFuY2VNZXQoZXZlbnQpICYmIHRoaXMuX21vdXNlRGVsYXlNZXQoZXZlbnQpKSB7XG5cdFx0XHR0aGlzLl9tb3VzZVN0YXJ0ZWQgPSAodGhpcy5fbW91c2VTdGFydChldmVudCkgIT09IGZhbHNlKTtcblx0XHRcdGlmICghdGhpcy5fbW91c2VTdGFydGVkKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENsaWNrIGV2ZW50IG1heSBuZXZlciBoYXZlIGZpcmVkIChHZWNrbyAmIE9wZXJhKVxuXHRcdGlmICh0cnVlID09PSAkLmRhdGEoZXZlbnQudGFyZ2V0LCB0aGlzLndpZGdldE5hbWUgKyAnLnByZXZlbnRDbGlja0V2ZW50JykpIHtcblx0XHRcdCQucmVtb3ZlRGF0YShldmVudC50YXJnZXQsIHRoaXMud2lkZ2V0TmFtZSArICcucHJldmVudENsaWNrRXZlbnQnKTtcblx0XHR9XG5cblx0XHQvLyB0aGVzZSBkZWxlZ2F0ZXMgYXJlIHJlcXVpcmVkIHRvIGtlZXAgY29udGV4dFxuXHRcdHRoaXMuX21vdXNlTW92ZURlbGVnYXRlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHJldHVybiB0aGF0Ll9tb3VzZU1vdmUoZXZlbnQpO1xuXHRcdH07XG5cdFx0dGhpcy5fbW91c2VVcERlbGVnYXRlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHJldHVybiB0aGF0Ll9tb3VzZVVwKGV2ZW50KTtcblx0XHR9O1xuXHRcdCQoZG9jdW1lbnQpXG5cdFx0XHQuYmluZCgnbW91c2Vtb3ZlLicrdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSlcblx0XHRcdC5iaW5kKCdtb3VzZXVwLicrdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZVVwRGVsZWdhdGUpO1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdG1vdXNlSGFuZGxlZCA9IHRydWU7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X21vdXNlTW92ZTogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHQvLyBJRSBtb3VzZXVwIGNoZWNrIC0gbW91c2V1cCBoYXBwZW5lZCB3aGVuIG1vdXNlIHdhcyBvdXQgb2Ygd2luZG93XG5cdFx0aWYgKCQudWkuaWUgJiYgIShkb2N1bWVudC5kb2N1bWVudE1vZGUgPj0gOSkgJiYgIWV2ZW50LmJ1dHRvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuX21vdXNlVXAoZXZlbnQpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9tb3VzZVN0YXJ0ZWQpIHtcblx0XHRcdHRoaXMuX21vdXNlRHJhZyhldmVudCk7XG5cdFx0XHRyZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbW91c2VEaXN0YW5jZU1ldChldmVudCkgJiYgdGhpcy5fbW91c2VEZWxheU1ldChldmVudCkpIHtcblx0XHRcdHRoaXMuX21vdXNlU3RhcnRlZCA9XG5cdFx0XHRcdCh0aGlzLl9tb3VzZVN0YXJ0KHRoaXMuX21vdXNlRG93bkV2ZW50LCBldmVudCkgIT09IGZhbHNlKTtcblx0XHRcdCh0aGlzLl9tb3VzZVN0YXJ0ZWQgPyB0aGlzLl9tb3VzZURyYWcoZXZlbnQpIDogdGhpcy5fbW91c2VVcChldmVudCkpO1xuXHRcdH1cblxuXHRcdHJldHVybiAhdGhpcy5fbW91c2VTdGFydGVkO1xuXHR9LFxuXG5cdF9tb3VzZVVwOiBmdW5jdGlvbihldmVudCkge1xuXHRcdCQoZG9jdW1lbnQpXG5cdFx0XHQudW5iaW5kKCdtb3VzZW1vdmUuJyt0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlKVxuXHRcdFx0LnVuYmluZCgnbW91c2V1cC4nK3RoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VVcERlbGVnYXRlKTtcblxuXHRcdGlmICh0aGlzLl9tb3VzZVN0YXJ0ZWQpIHtcblx0XHRcdHRoaXMuX21vdXNlU3RhcnRlZCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLl9tb3VzZURvd25FdmVudC50YXJnZXQpIHtcblx0XHRcdFx0JC5kYXRhKGV2ZW50LnRhcmdldCwgdGhpcy53aWRnZXROYW1lICsgJy5wcmV2ZW50Q2xpY2tFdmVudCcsIHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9tb3VzZVN0b3AoZXZlbnQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfbW91c2VEaXN0YW5jZU1ldDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gKE1hdGgubWF4KFxuXHRcdFx0XHRNYXRoLmFicyh0aGlzLl9tb3VzZURvd25FdmVudC5wYWdlWCAtIGV2ZW50LnBhZ2VYKSxcblx0XHRcdFx0TWF0aC5hYnModGhpcy5fbW91c2VEb3duRXZlbnQucGFnZVkgLSBldmVudC5wYWdlWSlcblx0XHRcdCkgPj0gdGhpcy5vcHRpb25zLmRpc3RhbmNlXG5cdFx0KTtcblx0fSxcblxuXHRfbW91c2VEZWxheU1ldDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZURlbGF5TWV0O1xuXHR9LFxuXG5cdC8vIFRoZXNlIGFyZSBwbGFjZWhvbGRlciBtZXRob2RzLCB0byBiZSBvdmVycmlkZW4gYnkgZXh0ZW5kaW5nIHBsdWdpblxuXHRfbW91c2VTdGFydDogZnVuY3Rpb24oZXZlbnQpIHt9LFxuXHRfbW91c2VEcmFnOiBmdW5jdGlvbihldmVudCkge30sXG5cdF9tb3VzZVN0b3A6IGZ1bmN0aW9uKGV2ZW50KSB7fSxcblx0X21vdXNlQ2FwdHVyZTogZnVuY3Rpb24oZXZlbnQpIHsgcmV0dXJuIHRydWU7IH1cbn0pO1xuXG59KShqUXVlcnkpO1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQudWkgPSAkLnVpIHx8IHt9O1xuXG52YXIgY2FjaGVkU2Nyb2xsYmFyV2lkdGgsXG5cdG1heCA9IE1hdGgubWF4LFxuXHRhYnMgPSBNYXRoLmFicyxcblx0cm91bmQgPSBNYXRoLnJvdW5kLFxuXHRyaG9yaXpvbnRhbCA9IC9sZWZ0fGNlbnRlcnxyaWdodC8sXG5cdHJ2ZXJ0aWNhbCA9IC90b3B8Y2VudGVyfGJvdHRvbS8sXG5cdHJvZmZzZXQgPSAvW1xcK1xcLV1cXGQrJT8vLFxuXHRycG9zaXRpb24gPSAvXlxcdysvLFxuXHRycGVyY2VudCA9IC8lJC8sXG5cdF9wb3NpdGlvbiA9ICQuZm4ucG9zaXRpb247XG5cbmZ1bmN0aW9uIGdldE9mZnNldHMoIG9mZnNldHMsIHdpZHRoLCBoZWlnaHQgKSB7XG5cdHJldHVybiBbXG5cdFx0cGFyc2VJbnQoIG9mZnNldHNbIDAgXSwgMTAgKSAqICggcnBlcmNlbnQudGVzdCggb2Zmc2V0c1sgMCBdICkgPyB3aWR0aCAvIDEwMCA6IDEgKSxcblx0XHRwYXJzZUludCggb2Zmc2V0c1sgMSBdLCAxMCApICogKCBycGVyY2VudC50ZXN0KCBvZmZzZXRzWyAxIF0gKSA/IGhlaWdodCAvIDEwMCA6IDEgKVxuXHRdO1xufVxuZnVuY3Rpb24gcGFyc2VDc3MoIGVsZW1lbnQsIHByb3BlcnR5ICkge1xuXHRyZXR1cm4gcGFyc2VJbnQoICQuY3NzKCBlbGVtZW50LCBwcm9wZXJ0eSApLCAxMCApIHx8IDA7XG59XG5cbiQucG9zaXRpb24gPSB7XG5cdHNjcm9sbGJhcldpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGNhY2hlZFNjcm9sbGJhcldpZHRoICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gY2FjaGVkU2Nyb2xsYmFyV2lkdGg7XG5cdFx0fVxuXHRcdHZhciB3MSwgdzIsXG5cdFx0XHRkaXYgPSAkKCBcIjxkaXYgc3R5bGU9J2Rpc3BsYXk6YmxvY2s7d2lkdGg6NTBweDtoZWlnaHQ6NTBweDtvdmVyZmxvdzpoaWRkZW47Jz48ZGl2IHN0eWxlPSdoZWlnaHQ6MTAwcHg7d2lkdGg6YXV0bzsnPjwvZGl2PjwvZGl2PlwiICksXG5cdFx0XHRpbm5lckRpdiA9IGRpdi5jaGlsZHJlbigpWzBdO1xuXG5cdFx0JCggXCJib2R5XCIgKS5hcHBlbmQoIGRpdiApO1xuXHRcdHcxID0gaW5uZXJEaXYub2Zmc2V0V2lkdGg7XG5cdFx0ZGl2LmNzcyggXCJvdmVyZmxvd1wiLCBcInNjcm9sbFwiICk7XG5cblx0XHR3MiA9IGlubmVyRGl2Lm9mZnNldFdpZHRoO1xuXG5cdFx0aWYgKCB3MSA9PT0gdzIgKSB7XG5cdFx0XHR3MiA9IGRpdlswXS5jbGllbnRXaWR0aDtcblx0XHR9XG5cblx0XHRkaXYucmVtb3ZlKCk7XG5cblx0XHRyZXR1cm4gKGNhY2hlZFNjcm9sbGJhcldpZHRoID0gdzEgLSB3Mik7XG5cdH0sXG5cdGdldFNjcm9sbEluZm86IGZ1bmN0aW9uKCB3aXRoaW4gKSB7XG5cdFx0dmFyIG92ZXJmbG93WCA9IHdpdGhpbi5pc1dpbmRvdyA/IFwiXCIgOiB3aXRoaW4uZWxlbWVudC5jc3MoIFwib3ZlcmZsb3cteFwiICksXG5cdFx0XHRvdmVyZmxvd1kgPSB3aXRoaW4uaXNXaW5kb3cgPyBcIlwiIDogd2l0aGluLmVsZW1lbnQuY3NzKCBcIm92ZXJmbG93LXlcIiApLFxuXHRcdFx0aGFzT3ZlcmZsb3dYID0gb3ZlcmZsb3dYID09PSBcInNjcm9sbFwiIHx8XG5cdFx0XHRcdCggb3ZlcmZsb3dYID09PSBcImF1dG9cIiAmJiB3aXRoaW4ud2lkdGggPCB3aXRoaW4uZWxlbWVudFswXS5zY3JvbGxXaWR0aCApLFxuXHRcdFx0aGFzT3ZlcmZsb3dZID0gb3ZlcmZsb3dZID09PSBcInNjcm9sbFwiIHx8XG5cdFx0XHRcdCggb3ZlcmZsb3dZID09PSBcImF1dG9cIiAmJiB3aXRoaW4uaGVpZ2h0IDwgd2l0aGluLmVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0ICk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpZHRoOiBoYXNPdmVyZmxvd1ggPyAkLnBvc2l0aW9uLnNjcm9sbGJhcldpZHRoKCkgOiAwLFxuXHRcdFx0aGVpZ2h0OiBoYXNPdmVyZmxvd1kgPyAkLnBvc2l0aW9uLnNjcm9sbGJhcldpZHRoKCkgOiAwXG5cdFx0fTtcblx0fSxcblx0Z2V0V2l0aGluSW5mbzogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dmFyIHdpdGhpbkVsZW1lbnQgPSAkKCBlbGVtZW50IHx8IHdpbmRvdyApLFxuXHRcdFx0aXNXaW5kb3cgPSAkLmlzV2luZG93KCB3aXRoaW5FbGVtZW50WzBdICk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGVsZW1lbnQ6IHdpdGhpbkVsZW1lbnQsXG5cdFx0XHRpc1dpbmRvdzogaXNXaW5kb3csXG5cdFx0XHRvZmZzZXQ6IHdpdGhpbkVsZW1lbnQub2Zmc2V0KCkgfHwgeyBsZWZ0OiAwLCB0b3A6IDAgfSxcblx0XHRcdHNjcm9sbExlZnQ6IHdpdGhpbkVsZW1lbnQuc2Nyb2xsTGVmdCgpLFxuXHRcdFx0c2Nyb2xsVG9wOiB3aXRoaW5FbGVtZW50LnNjcm9sbFRvcCgpLFxuXHRcdFx0d2lkdGg6IGlzV2luZG93ID8gd2l0aGluRWxlbWVudC53aWR0aCgpIDogd2l0aGluRWxlbWVudC5vdXRlcldpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IGlzV2luZG93ID8gd2l0aGluRWxlbWVudC5oZWlnaHQoKSA6IHdpdGhpbkVsZW1lbnQub3V0ZXJIZWlnaHQoKVxuXHRcdH07XG5cdH1cbn07XG5cbiQuZm4ucG9zaXRpb24gPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0aWYgKCAhb3B0aW9ucyB8fCAhb3B0aW9ucy5vZiApIHtcblx0XHRyZXR1cm4gX3Bvc2l0aW9uLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0fVxuXG5cdC8vIG1ha2UgYSBjb3B5LCB3ZSBkb24ndCB3YW50IHRvIG1vZGlmeSBhcmd1bWVudHNcblx0b3B0aW9ucyA9ICQuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciBhdE9mZnNldCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCwgdGFyZ2V0T2Zmc2V0LCBiYXNlUG9zaXRpb24sXG5cdFx0dGFyZ2V0ID0gJCggb3B0aW9ucy5vZiApLFxuXHRcdHdpdGhpbiA9ICQucG9zaXRpb24uZ2V0V2l0aGluSW5mbyggb3B0aW9ucy53aXRoaW4gKSxcblx0XHRzY3JvbGxJbmZvID0gJC5wb3NpdGlvbi5nZXRTY3JvbGxJbmZvKCB3aXRoaW4gKSxcblx0XHR0YXJnZXRFbGVtID0gdGFyZ2V0WzBdLFxuXHRcdGNvbGxpc2lvbiA9ICggb3B0aW9ucy5jb2xsaXNpb24gfHwgXCJmbGlwXCIgKS5zcGxpdCggXCIgXCIgKSxcblx0XHRvZmZzZXRzID0ge307XG5cblx0aWYgKCB0YXJnZXRFbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdHRhcmdldFdpZHRoID0gdGFyZ2V0LndpZHRoKCk7XG5cdFx0dGFyZ2V0SGVpZ2h0ID0gdGFyZ2V0LmhlaWdodCgpO1xuXHRcdHRhcmdldE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdH0gZWxzZSBpZiAoICQuaXNXaW5kb3coIHRhcmdldEVsZW0gKSApIHtcblx0XHR0YXJnZXRXaWR0aCA9IHRhcmdldC53aWR0aCgpO1xuXHRcdHRhcmdldEhlaWdodCA9IHRhcmdldC5oZWlnaHQoKTtcblx0XHR0YXJnZXRPZmZzZXQgPSB7IHRvcDogdGFyZ2V0LnNjcm9sbFRvcCgpLCBsZWZ0OiB0YXJnZXQuc2Nyb2xsTGVmdCgpIH07XG5cdH0gZWxzZSBpZiAoIHRhcmdldEVsZW0ucHJldmVudERlZmF1bHQgKSB7XG5cdFx0Ly8gZm9yY2UgbGVmdCB0b3AgdG8gYWxsb3cgZmxpcHBpbmdcblx0XHRvcHRpb25zLmF0ID0gXCJsZWZ0IHRvcFwiO1xuXHRcdHRhcmdldFdpZHRoID0gdGFyZ2V0SGVpZ2h0ID0gMDtcblx0XHR0YXJnZXRPZmZzZXQgPSB7IHRvcDogdGFyZ2V0RWxlbS5wYWdlWSwgbGVmdDogdGFyZ2V0RWxlbS5wYWdlWCB9O1xuXHR9IGVsc2Uge1xuXHRcdHRhcmdldFdpZHRoID0gdGFyZ2V0Lm91dGVyV2lkdGgoKTtcblx0XHR0YXJnZXRIZWlnaHQgPSB0YXJnZXQub3V0ZXJIZWlnaHQoKTtcblx0XHR0YXJnZXRPZmZzZXQgPSB0YXJnZXQub2Zmc2V0KCk7XG5cdH1cblx0Ly8gY2xvbmUgdG8gcmV1c2Ugb3JpZ2luYWwgdGFyZ2V0T2Zmc2V0IGxhdGVyXG5cdGJhc2VQb3NpdGlvbiA9ICQuZXh0ZW5kKCB7fSwgdGFyZ2V0T2Zmc2V0ICk7XG5cblx0Ly8gZm9yY2UgbXkgYW5kIGF0IHRvIGhhdmUgdmFsaWQgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgcG9zaXRpb25zXG5cdC8vIGlmIGEgdmFsdWUgaXMgbWlzc2luZyBvciBpbnZhbGlkLCBpdCB3aWxsIGJlIGNvbnZlcnRlZCB0byBjZW50ZXJcblx0JC5lYWNoKCBbIFwibXlcIiwgXCJhdFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb3MgPSAoIG9wdGlvbnNbIHRoaXMgXSB8fCBcIlwiICkuc3BsaXQoIFwiIFwiICksXG5cdFx0XHRob3Jpem9udGFsT2Zmc2V0LFxuXHRcdFx0dmVydGljYWxPZmZzZXQ7XG5cblx0XHRpZiAoIHBvcy5sZW5ndGggPT09IDEpIHtcblx0XHRcdHBvcyA9IHJob3Jpem9udGFsLnRlc3QoIHBvc1sgMCBdICkgP1xuXHRcdFx0XHRwb3MuY29uY2F0KCBbIFwiY2VudGVyXCIgXSApIDpcblx0XHRcdFx0cnZlcnRpY2FsLnRlc3QoIHBvc1sgMCBdICkgP1xuXHRcdFx0XHRcdFsgXCJjZW50ZXJcIiBdLmNvbmNhdCggcG9zICkgOlxuXHRcdFx0XHRcdFsgXCJjZW50ZXJcIiwgXCJjZW50ZXJcIiBdO1xuXHRcdH1cblx0XHRwb3NbIDAgXSA9IHJob3Jpem9udGFsLnRlc3QoIHBvc1sgMCBdICkgPyBwb3NbIDAgXSA6IFwiY2VudGVyXCI7XG5cdFx0cG9zWyAxIF0gPSBydmVydGljYWwudGVzdCggcG9zWyAxIF0gKSA/IHBvc1sgMSBdIDogXCJjZW50ZXJcIjtcblxuXHRcdC8vIGNhbGN1bGF0ZSBvZmZzZXRzXG5cdFx0aG9yaXpvbnRhbE9mZnNldCA9IHJvZmZzZXQuZXhlYyggcG9zWyAwIF0gKTtcblx0XHR2ZXJ0aWNhbE9mZnNldCA9IHJvZmZzZXQuZXhlYyggcG9zWyAxIF0gKTtcblx0XHRvZmZzZXRzWyB0aGlzIF0gPSBbXG5cdFx0XHRob3Jpem9udGFsT2Zmc2V0ID8gaG9yaXpvbnRhbE9mZnNldFsgMCBdIDogMCxcblx0XHRcdHZlcnRpY2FsT2Zmc2V0ID8gdmVydGljYWxPZmZzZXRbIDAgXSA6IDBcblx0XHRdO1xuXG5cdFx0Ly8gcmVkdWNlIHRvIGp1c3QgdGhlIHBvc2l0aW9ucyB3aXRob3V0IHRoZSBvZmZzZXRzXG5cdFx0b3B0aW9uc1sgdGhpcyBdID0gW1xuXHRcdFx0cnBvc2l0aW9uLmV4ZWMoIHBvc1sgMCBdIClbIDAgXSxcblx0XHRcdHJwb3NpdGlvbi5leGVjKCBwb3NbIDEgXSApWyAwIF1cblx0XHRdO1xuXHR9KTtcblxuXHQvLyBub3JtYWxpemUgY29sbGlzaW9uIG9wdGlvblxuXHRpZiAoIGNvbGxpc2lvbi5sZW5ndGggPT09IDEgKSB7XG5cdFx0Y29sbGlzaW9uWyAxIF0gPSBjb2xsaXNpb25bIDAgXTtcblx0fVxuXG5cdGlmICggb3B0aW9ucy5hdFsgMCBdID09PSBcInJpZ2h0XCIgKSB7XG5cdFx0YmFzZVBvc2l0aW9uLmxlZnQgKz0gdGFyZ2V0V2lkdGg7XG5cdH0gZWxzZSBpZiAoIG9wdGlvbnMuYXRbIDAgXSA9PT0gXCJjZW50ZXJcIiApIHtcblx0XHRiYXNlUG9zaXRpb24ubGVmdCArPSB0YXJnZXRXaWR0aCAvIDI7XG5cdH1cblxuXHRpZiAoIG9wdGlvbnMuYXRbIDEgXSA9PT0gXCJib3R0b21cIiApIHtcblx0XHRiYXNlUG9zaXRpb24udG9wICs9IHRhcmdldEhlaWdodDtcblx0fSBlbHNlIGlmICggb3B0aW9ucy5hdFsgMSBdID09PSBcImNlbnRlclwiICkge1xuXHRcdGJhc2VQb3NpdGlvbi50b3AgKz0gdGFyZ2V0SGVpZ2h0IC8gMjtcblx0fVxuXG5cdGF0T2Zmc2V0ID0gZ2V0T2Zmc2V0cyggb2Zmc2V0cy5hdCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCApO1xuXHRiYXNlUG9zaXRpb24ubGVmdCArPSBhdE9mZnNldFsgMCBdO1xuXHRiYXNlUG9zaXRpb24udG9wICs9IGF0T2Zmc2V0WyAxIF07XG5cblx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHR2YXIgY29sbGlzaW9uUG9zaXRpb24sIHVzaW5nLFxuXHRcdFx0ZWxlbSA9ICQoIHRoaXMgKSxcblx0XHRcdGVsZW1XaWR0aCA9IGVsZW0ub3V0ZXJXaWR0aCgpLFxuXHRcdFx0ZWxlbUhlaWdodCA9IGVsZW0ub3V0ZXJIZWlnaHQoKSxcblx0XHRcdG1hcmdpbkxlZnQgPSBwYXJzZUNzcyggdGhpcywgXCJtYXJnaW5MZWZ0XCIgKSxcblx0XHRcdG1hcmdpblRvcCA9IHBhcnNlQ3NzKCB0aGlzLCBcIm1hcmdpblRvcFwiICksXG5cdFx0XHRjb2xsaXNpb25XaWR0aCA9IGVsZW1XaWR0aCArIG1hcmdpbkxlZnQgKyBwYXJzZUNzcyggdGhpcywgXCJtYXJnaW5SaWdodFwiICkgKyBzY3JvbGxJbmZvLndpZHRoLFxuXHRcdFx0Y29sbGlzaW9uSGVpZ2h0ID0gZWxlbUhlaWdodCArIG1hcmdpblRvcCArIHBhcnNlQ3NzKCB0aGlzLCBcIm1hcmdpbkJvdHRvbVwiICkgKyBzY3JvbGxJbmZvLmhlaWdodCxcblx0XHRcdHBvc2l0aW9uID0gJC5leHRlbmQoIHt9LCBiYXNlUG9zaXRpb24gKSxcblx0XHRcdG15T2Zmc2V0ID0gZ2V0T2Zmc2V0cyggb2Zmc2V0cy5teSwgZWxlbS5vdXRlcldpZHRoKCksIGVsZW0ub3V0ZXJIZWlnaHQoKSApO1xuXG5cdFx0aWYgKCBvcHRpb25zLm15WyAwIF0gPT09IFwicmlnaHRcIiApIHtcblx0XHRcdHBvc2l0aW9uLmxlZnQgLT0gZWxlbVdpZHRoO1xuXHRcdH0gZWxzZSBpZiAoIG9wdGlvbnMubXlbIDAgXSA9PT0gXCJjZW50ZXJcIiApIHtcblx0XHRcdHBvc2l0aW9uLmxlZnQgLT0gZWxlbVdpZHRoIC8gMjtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMubXlbIDEgXSA9PT0gXCJib3R0b21cIiApIHtcblx0XHRcdHBvc2l0aW9uLnRvcCAtPSBlbGVtSGVpZ2h0O1xuXHRcdH0gZWxzZSBpZiAoIG9wdGlvbnMubXlbIDEgXSA9PT0gXCJjZW50ZXJcIiApIHtcblx0XHRcdHBvc2l0aW9uLnRvcCAtPSBlbGVtSGVpZ2h0IC8gMjtcblx0XHR9XG5cblx0XHRwb3NpdGlvbi5sZWZ0ICs9IG15T2Zmc2V0WyAwIF07XG5cdFx0cG9zaXRpb24udG9wICs9IG15T2Zmc2V0WyAxIF07XG5cblx0XHQvLyBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgZnJhY3Rpb25zLCB0aGVuIHJvdW5kIGZvciBjb25zaXN0ZW50IHJlc3VsdHNcblx0XHRpZiAoICEkLnN1cHBvcnQub2Zmc2V0RnJhY3Rpb25zICkge1xuXHRcdFx0cG9zaXRpb24ubGVmdCA9IHJvdW5kKCBwb3NpdGlvbi5sZWZ0ICk7XG5cdFx0XHRwb3NpdGlvbi50b3AgPSByb3VuZCggcG9zaXRpb24udG9wICk7XG5cdFx0fVxuXG5cdFx0Y29sbGlzaW9uUG9zaXRpb24gPSB7XG5cdFx0XHRtYXJnaW5MZWZ0OiBtYXJnaW5MZWZ0LFxuXHRcdFx0bWFyZ2luVG9wOiBtYXJnaW5Ub3Bcblx0XHR9O1xuXG5cdFx0JC5lYWNoKCBbIFwibGVmdFwiLCBcInRvcFwiIF0sIGZ1bmN0aW9uKCBpLCBkaXIgKSB7XG5cdFx0XHRpZiAoICQudWkucG9zaXRpb25bIGNvbGxpc2lvblsgaSBdIF0gKSB7XG5cdFx0XHRcdCQudWkucG9zaXRpb25bIGNvbGxpc2lvblsgaSBdIF1bIGRpciBdKCBwb3NpdGlvbiwge1xuXHRcdFx0XHRcdHRhcmdldFdpZHRoOiB0YXJnZXRXaWR0aCxcblx0XHRcdFx0XHR0YXJnZXRIZWlnaHQ6IHRhcmdldEhlaWdodCxcblx0XHRcdFx0XHRlbGVtV2lkdGg6IGVsZW1XaWR0aCxcblx0XHRcdFx0XHRlbGVtSGVpZ2h0OiBlbGVtSGVpZ2h0LFxuXHRcdFx0XHRcdGNvbGxpc2lvblBvc2l0aW9uOiBjb2xsaXNpb25Qb3NpdGlvbixcblx0XHRcdFx0XHRjb2xsaXNpb25XaWR0aDogY29sbGlzaW9uV2lkdGgsXG5cdFx0XHRcdFx0Y29sbGlzaW9uSGVpZ2h0OiBjb2xsaXNpb25IZWlnaHQsXG5cdFx0XHRcdFx0b2Zmc2V0OiBbIGF0T2Zmc2V0WyAwIF0gKyBteU9mZnNldFsgMCBdLCBhdE9mZnNldCBbIDEgXSArIG15T2Zmc2V0WyAxIF0gXSxcblx0XHRcdFx0XHRteTogb3B0aW9ucy5teSxcblx0XHRcdFx0XHRhdDogb3B0aW9ucy5hdCxcblx0XHRcdFx0XHR3aXRoaW46IHdpdGhpbixcblx0XHRcdFx0XHRlbGVtIDogZWxlbVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmICggJC5mbi5iZ2lmcmFtZSApIHtcblx0XHRcdGVsZW0uYmdpZnJhbWUoKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudXNpbmcgKSB7XG5cdFx0XHQvLyBhZGRzIGZlZWRiYWNrIGFzIHNlY29uZCBhcmd1bWVudCB0byB1c2luZyBjYWxsYmFjaywgaWYgcHJlc2VudFxuXHRcdFx0dXNpbmcgPSBmdW5jdGlvbiggcHJvcHMgKSB7XG5cdFx0XHRcdHZhciBsZWZ0ID0gdGFyZ2V0T2Zmc2V0LmxlZnQgLSBwb3NpdGlvbi5sZWZ0LFxuXHRcdFx0XHRcdHJpZ2h0ID0gbGVmdCArIHRhcmdldFdpZHRoIC0gZWxlbVdpZHRoLFxuXHRcdFx0XHRcdHRvcCA9IHRhcmdldE9mZnNldC50b3AgLSBwb3NpdGlvbi50b3AsXG5cdFx0XHRcdFx0Ym90dG9tID0gdG9wICsgdGFyZ2V0SGVpZ2h0IC0gZWxlbUhlaWdodCxcblx0XHRcdFx0XHRmZWVkYmFjayA9IHtcblx0XHRcdFx0XHRcdHRhcmdldDoge1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50OiB0YXJnZXQsXG5cdFx0XHRcdFx0XHRcdGxlZnQ6IHRhcmdldE9mZnNldC5sZWZ0LFxuXHRcdFx0XHRcdFx0XHR0b3A6IHRhcmdldE9mZnNldC50b3AsXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiB0YXJnZXRXaWR0aCxcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiB0YXJnZXRIZWlnaHRcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRlbGVtZW50OiB7XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQ6IGVsZW0sXG5cdFx0XHRcdFx0XHRcdGxlZnQ6IHBvc2l0aW9uLmxlZnQsXG5cdFx0XHRcdFx0XHRcdHRvcDogcG9zaXRpb24udG9wLFxuXHRcdFx0XHRcdFx0XHR3aWR0aDogZWxlbVdpZHRoLFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IGVsZW1IZWlnaHRcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRob3Jpem9udGFsOiByaWdodCA8IDAgPyBcImxlZnRcIiA6IGxlZnQgPiAwID8gXCJyaWdodFwiIDogXCJjZW50ZXJcIixcblx0XHRcdFx0XHRcdHZlcnRpY2FsOiBib3R0b20gPCAwID8gXCJ0b3BcIiA6IHRvcCA+IDAgPyBcImJvdHRvbVwiIDogXCJtaWRkbGVcIlxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdGlmICggdGFyZ2V0V2lkdGggPCBlbGVtV2lkdGggJiYgYWJzKCBsZWZ0ICsgcmlnaHQgKSA8IHRhcmdldFdpZHRoICkge1xuXHRcdFx0XHRcdGZlZWRiYWNrLmhvcml6b250YWwgPSBcImNlbnRlclwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdGFyZ2V0SGVpZ2h0IDwgZWxlbUhlaWdodCAmJiBhYnMoIHRvcCArIGJvdHRvbSApIDwgdGFyZ2V0SGVpZ2h0ICkge1xuXHRcdFx0XHRcdGZlZWRiYWNrLnZlcnRpY2FsID0gXCJtaWRkbGVcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG1heCggYWJzKCBsZWZ0ICksIGFicyggcmlnaHQgKSApID4gbWF4KCBhYnMoIHRvcCApLCBhYnMoIGJvdHRvbSApICkgKSB7XG5cdFx0XHRcdFx0ZmVlZGJhY2suaW1wb3J0YW50ID0gXCJob3Jpem9udGFsXCI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZmVlZGJhY2suaW1wb3J0YW50ID0gXCJ2ZXJ0aWNhbFwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggdGhpcywgcHJvcHMsIGZlZWRiYWNrICk7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGVsZW0ub2Zmc2V0KCAkLmV4dGVuZCggcG9zaXRpb24sIHsgdXNpbmc6IHVzaW5nIH0gKSApO1xuXHR9KTtcbn07XG5cbiQudWkucG9zaXRpb24gPSB7XG5cdGZpdDoge1xuXHRcdGxlZnQ6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZGF0YSApIHtcblx0XHRcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcblx0XHRcdFx0d2l0aGluT2Zmc2V0ID0gd2l0aGluLmlzV2luZG93ID8gd2l0aGluLnNjcm9sbExlZnQgOiB3aXRoaW4ub2Zmc2V0LmxlZnQsXG5cdFx0XHRcdG91dGVyV2lkdGggPSB3aXRoaW4ud2lkdGgsXG5cdFx0XHRcdGNvbGxpc2lvblBvc0xlZnQgPSBwb3NpdGlvbi5sZWZ0IC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5MZWZ0LFxuXHRcdFx0XHRvdmVyTGVmdCA9IHdpdGhpbk9mZnNldCAtIGNvbGxpc2lvblBvc0xlZnQsXG5cdFx0XHRcdG92ZXJSaWdodCA9IGNvbGxpc2lvblBvc0xlZnQgKyBkYXRhLmNvbGxpc2lvbldpZHRoIC0gb3V0ZXJXaWR0aCAtIHdpdGhpbk9mZnNldCxcblx0XHRcdFx0bmV3T3ZlclJpZ2h0O1xuXG5cdFx0XHQvLyBlbGVtZW50IGlzIHdpZGVyIHRoYW4gd2l0aGluXG5cdFx0XHRpZiAoIGRhdGEuY29sbGlzaW9uV2lkdGggPiBvdXRlcldpZHRoICkge1xuXHRcdFx0XHQvLyBlbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIHRoZSBsZWZ0IHNpZGUgb2Ygd2l0aGluXG5cdFx0XHRcdGlmICggb3ZlckxlZnQgPiAwICYmIG92ZXJSaWdodCA8PSAwICkge1xuXHRcdFx0XHRcdG5ld092ZXJSaWdodCA9IHBvc2l0aW9uLmxlZnQgKyBvdmVyTGVmdCArIGRhdGEuY29sbGlzaW9uV2lkdGggLSBvdXRlcldpZHRoIC0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRcdHBvc2l0aW9uLmxlZnQgKz0gb3ZlckxlZnQgLSBuZXdPdmVyUmlnaHQ7XG5cdFx0XHRcdC8vIGVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgcmlnaHQgc2lkZSBvZiB3aXRoaW5cblx0XHRcdFx0fSBlbHNlIGlmICggb3ZlclJpZ2h0ID4gMCAmJiBvdmVyTGVmdCA8PSAwICkge1xuXHRcdFx0XHRcdHBvc2l0aW9uLmxlZnQgPSB3aXRoaW5PZmZzZXQ7XG5cdFx0XHRcdC8vIGVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgYm90aCBsZWZ0IGFuZCByaWdodCBzaWRlcyBvZiB3aXRoaW5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIG92ZXJMZWZ0ID4gb3ZlclJpZ2h0ICkge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24ubGVmdCA9IHdpdGhpbk9mZnNldCArIG91dGVyV2lkdGggLSBkYXRhLmNvbGxpc2lvbldpZHRoO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ID0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0Ly8gdG9vIGZhciBsZWZ0IC0+IGFsaWduIHdpdGggbGVmdCBlZGdlXG5cdFx0XHR9IGVsc2UgaWYgKCBvdmVyTGVmdCA+IDAgKSB7XG5cdFx0XHRcdHBvc2l0aW9uLmxlZnQgKz0gb3ZlckxlZnQ7XG5cdFx0XHQvLyB0b28gZmFyIHJpZ2h0IC0+IGFsaWduIHdpdGggcmlnaHQgZWRnZVxuXHRcdFx0fSBlbHNlIGlmICggb3ZlclJpZ2h0ID4gMCApIHtcblx0XHRcdFx0cG9zaXRpb24ubGVmdCAtPSBvdmVyUmlnaHQ7XG5cdFx0XHQvLyBhZGp1c3QgYmFzZWQgb24gcG9zaXRpb24gYW5kIG1hcmdpblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9zaXRpb24ubGVmdCA9IG1heCggcG9zaXRpb24ubGVmdCAtIGNvbGxpc2lvblBvc0xlZnQsIHBvc2l0aW9uLmxlZnQgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHRvcDogZnVuY3Rpb24oIHBvc2l0aW9uLCBkYXRhICkge1xuXHRcdFx0dmFyIHdpdGhpbiA9IGRhdGEud2l0aGluLFxuXHRcdFx0XHR3aXRoaW5PZmZzZXQgPSB3aXRoaW4uaXNXaW5kb3cgPyB3aXRoaW4uc2Nyb2xsVG9wIDogd2l0aGluLm9mZnNldC50b3AsXG5cdFx0XHRcdG91dGVySGVpZ2h0ID0gZGF0YS53aXRoaW4uaGVpZ2h0LFxuXHRcdFx0XHRjb2xsaXNpb25Qb3NUb3AgPSBwb3NpdGlvbi50b3AgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpblRvcCxcblx0XHRcdFx0b3ZlclRvcCA9IHdpdGhpbk9mZnNldCAtIGNvbGxpc2lvblBvc1RvcCxcblx0XHRcdFx0b3ZlckJvdHRvbSA9IGNvbGxpc2lvblBvc1RvcCArIGRhdGEuY29sbGlzaW9uSGVpZ2h0IC0gb3V0ZXJIZWlnaHQgLSB3aXRoaW5PZmZzZXQsXG5cdFx0XHRcdG5ld092ZXJCb3R0b207XG5cblx0XHRcdC8vIGVsZW1lbnQgaXMgdGFsbGVyIHRoYW4gd2l0aGluXG5cdFx0XHRpZiAoIGRhdGEuY29sbGlzaW9uSGVpZ2h0ID4gb3V0ZXJIZWlnaHQgKSB7XG5cdFx0XHRcdC8vIGVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgdGhlIHRvcCBvZiB3aXRoaW5cblx0XHRcdFx0aWYgKCBvdmVyVG9wID4gMCAmJiBvdmVyQm90dG9tIDw9IDAgKSB7XG5cdFx0XHRcdFx0bmV3T3ZlckJvdHRvbSA9IHBvc2l0aW9uLnRvcCArIG92ZXJUb3AgKyBkYXRhLmNvbGxpc2lvbkhlaWdodCAtIG91dGVySGVpZ2h0IC0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRcdHBvc2l0aW9uLnRvcCArPSBvdmVyVG9wIC0gbmV3T3ZlckJvdHRvbTtcblx0XHRcdFx0Ly8gZWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciBib3R0b20gb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG92ZXJCb3R0b20gPiAwICYmIG92ZXJUb3AgPD0gMCApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi50b3AgPSB3aXRoaW5PZmZzZXQ7XG5cdFx0XHRcdC8vIGVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgYm90aCB0b3AgYW5kIGJvdHRvbSBvZiB3aXRoaW5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIG92ZXJUb3AgPiBvdmVyQm90dG9tICkge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24udG9wID0gd2l0aGluT2Zmc2V0ICsgb3V0ZXJIZWlnaHQgLSBkYXRhLmNvbGxpc2lvbkhlaWdodDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24udG9wID0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0Ly8gdG9vIGZhciB1cCAtPiBhbGlnbiB3aXRoIHRvcFxuXHRcdFx0fSBlbHNlIGlmICggb3ZlclRvcCA+IDAgKSB7XG5cdFx0XHRcdHBvc2l0aW9uLnRvcCArPSBvdmVyVG9wO1xuXHRcdFx0Ly8gdG9vIGZhciBkb3duIC0+IGFsaWduIHdpdGggYm90dG9tIGVkZ2Vcblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJCb3R0b20gPiAwICkge1xuXHRcdFx0XHRwb3NpdGlvbi50b3AgLT0gb3ZlckJvdHRvbTtcblx0XHRcdC8vIGFkanVzdCBiYXNlZCBvbiBwb3NpdGlvbiBhbmQgbWFyZ2luXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb3NpdGlvbi50b3AgPSBtYXgoIHBvc2l0aW9uLnRvcCAtIGNvbGxpc2lvblBvc1RvcCwgcG9zaXRpb24udG9wICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRmbGlwOiB7XG5cdFx0bGVmdDogZnVuY3Rpb24oIHBvc2l0aW9uLCBkYXRhICkge1xuXHRcdFx0dmFyIHdpdGhpbiA9IGRhdGEud2l0aGluLFxuXHRcdFx0XHR3aXRoaW5PZmZzZXQgPSB3aXRoaW4ub2Zmc2V0LmxlZnQgKyB3aXRoaW4uc2Nyb2xsTGVmdCxcblx0XHRcdFx0b3V0ZXJXaWR0aCA9IHdpdGhpbi53aWR0aCxcblx0XHRcdFx0b2Zmc2V0TGVmdCA9IHdpdGhpbi5pc1dpbmRvdyA/IHdpdGhpbi5zY3JvbGxMZWZ0IDogd2l0aGluLm9mZnNldC5sZWZ0LFxuXHRcdFx0XHRjb2xsaXNpb25Qb3NMZWZ0ID0gcG9zaXRpb24ubGVmdCAtIGRhdGEuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luTGVmdCxcblx0XHRcdFx0b3ZlckxlZnQgPSBjb2xsaXNpb25Qb3NMZWZ0IC0gb2Zmc2V0TGVmdCxcblx0XHRcdFx0b3ZlclJpZ2h0ID0gY29sbGlzaW9uUG9zTGVmdCArIGRhdGEuY29sbGlzaW9uV2lkdGggLSBvdXRlcldpZHRoIC0gb2Zmc2V0TGVmdCxcblx0XHRcdFx0bXlPZmZzZXQgPSBkYXRhLm15WyAwIF0gPT09IFwibGVmdFwiID9cblx0XHRcdFx0XHQtZGF0YS5lbGVtV2lkdGggOlxuXHRcdFx0XHRcdGRhdGEubXlbIDAgXSA9PT0gXCJyaWdodFwiID9cblx0XHRcdFx0XHRcdGRhdGEuZWxlbVdpZHRoIDpcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdGF0T2Zmc2V0ID0gZGF0YS5hdFsgMCBdID09PSBcImxlZnRcIiA/XG5cdFx0XHRcdFx0ZGF0YS50YXJnZXRXaWR0aCA6XG5cdFx0XHRcdFx0ZGF0YS5hdFsgMCBdID09PSBcInJpZ2h0XCIgP1xuXHRcdFx0XHRcdFx0LWRhdGEudGFyZ2V0V2lkdGggOlxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0b2Zmc2V0ID0gLTIgKiBkYXRhLm9mZnNldFsgMCBdLFxuXHRcdFx0XHRuZXdPdmVyUmlnaHQsXG5cdFx0XHRcdG5ld092ZXJMZWZ0O1xuXG5cdFx0XHRpZiAoIG92ZXJMZWZ0IDwgMCApIHtcblx0XHRcdFx0bmV3T3ZlclJpZ2h0ID0gcG9zaXRpb24ubGVmdCArIG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQgKyBkYXRhLmNvbGxpc2lvbldpZHRoIC0gb3V0ZXJXaWR0aCAtIHdpdGhpbk9mZnNldDtcblx0XHRcdFx0aWYgKCBuZXdPdmVyUmlnaHQgPCAwIHx8IG5ld092ZXJSaWdodCA8IGFicyggb3ZlckxlZnQgKSApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ICs9IG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBvdmVyUmlnaHQgPiAwICkge1xuXHRcdFx0XHRuZXdPdmVyTGVmdCA9IHBvc2l0aW9uLmxlZnQgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpbkxlZnQgKyBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0IC0gb2Zmc2V0TGVmdDtcblx0XHRcdFx0aWYgKCBuZXdPdmVyTGVmdCA+IDAgfHwgYWJzKCBuZXdPdmVyTGVmdCApIDwgb3ZlclJpZ2h0ICkge1xuXHRcdFx0XHRcdHBvc2l0aW9uLmxlZnQgKz0gbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dG9wOiBmdW5jdGlvbiggcG9zaXRpb24sIGRhdGEgKSB7XG5cdFx0XHR2YXIgd2l0aGluID0gZGF0YS53aXRoaW4sXG5cdFx0XHRcdHdpdGhpbk9mZnNldCA9IHdpdGhpbi5vZmZzZXQudG9wICsgd2l0aGluLnNjcm9sbFRvcCxcblx0XHRcdFx0b3V0ZXJIZWlnaHQgPSB3aXRoaW4uaGVpZ2h0LFxuXHRcdFx0XHRvZmZzZXRUb3AgPSB3aXRoaW4uaXNXaW5kb3cgPyB3aXRoaW4uc2Nyb2xsVG9wIDogd2l0aGluLm9mZnNldC50b3AsXG5cdFx0XHRcdGNvbGxpc2lvblBvc1RvcCA9IHBvc2l0aW9uLnRvcCAtIGRhdGEuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luVG9wLFxuXHRcdFx0XHRvdmVyVG9wID0gY29sbGlzaW9uUG9zVG9wIC0gb2Zmc2V0VG9wLFxuXHRcdFx0XHRvdmVyQm90dG9tID0gY29sbGlzaW9uUG9zVG9wICsgZGF0YS5jb2xsaXNpb25IZWlnaHQgLSBvdXRlckhlaWdodCAtIG9mZnNldFRvcCxcblx0XHRcdFx0dG9wID0gZGF0YS5teVsgMSBdID09PSBcInRvcFwiLFxuXHRcdFx0XHRteU9mZnNldCA9IHRvcCA/XG5cdFx0XHRcdFx0LWRhdGEuZWxlbUhlaWdodCA6XG5cdFx0XHRcdFx0ZGF0YS5teVsgMSBdID09PSBcImJvdHRvbVwiID9cblx0XHRcdFx0XHRcdGRhdGEuZWxlbUhlaWdodCA6XG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRhdE9mZnNldCA9IGRhdGEuYXRbIDEgXSA9PT0gXCJ0b3BcIiA/XG5cdFx0XHRcdFx0ZGF0YS50YXJnZXRIZWlnaHQgOlxuXHRcdFx0XHRcdGRhdGEuYXRbIDEgXSA9PT0gXCJib3R0b21cIiA/XG5cdFx0XHRcdFx0XHQtZGF0YS50YXJnZXRIZWlnaHQgOlxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0b2Zmc2V0ID0gLTIgKiBkYXRhLm9mZnNldFsgMSBdLFxuXHRcdFx0XHRuZXdPdmVyVG9wLFxuXHRcdFx0XHRuZXdPdmVyQm90dG9tO1xuXHRcdFx0aWYgKCBvdmVyVG9wIDwgMCApIHtcblx0XHRcdFx0bmV3T3ZlckJvdHRvbSA9IHBvc2l0aW9uLnRvcCArIG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQgKyBkYXRhLmNvbGxpc2lvbkhlaWdodCAtIG91dGVySGVpZ2h0IC0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRpZiAoICggcG9zaXRpb24udG9wICsgbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldCkgPiBvdmVyVG9wICYmICggbmV3T3ZlckJvdHRvbSA8IDAgfHwgbmV3T3ZlckJvdHRvbSA8IGFicyggb3ZlclRvcCApICkgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24udG9wICs9IG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBvdmVyQm90dG9tID4gMCApIHtcblx0XHRcdFx0bmV3T3ZlclRvcCA9IHBvc2l0aW9uLnRvcCAtICBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpblRvcCArIG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQgLSBvZmZzZXRUb3A7XG5cdFx0XHRcdGlmICggKCBwb3NpdGlvbi50b3AgKyBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0KSA+IG92ZXJCb3R0b20gJiYgKCBuZXdPdmVyVG9wID4gMCB8fCBhYnMoIG5ld092ZXJUb3AgKSA8IG92ZXJCb3R0b20gKSApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi50b3AgKz0gbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0ZmxpcGZpdDoge1xuXHRcdGxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0JC51aS5wb3NpdGlvbi5mbGlwLmxlZnQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0JC51aS5wb3NpdGlvbi5maXQubGVmdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fSxcblx0XHR0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdFx0JC51aS5wb3NpdGlvbi5mbGlwLnRvcC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHQkLnVpLnBvc2l0aW9uLmZpdC50b3AuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fVxufTtcblxuLy8gZnJhY3Rpb24gc3VwcG9ydCB0ZXN0XG4oZnVuY3Rpb24gKCkge1xuXHR2YXIgdGVzdEVsZW1lbnQsIHRlc3RFbGVtZW50UGFyZW50LCB0ZXN0RWxlbWVudFN0eWxlLCBvZmZzZXRMZWZ0LCBpLFxuXHRcdGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJib2R5XCIgKVsgMCBdLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvL0NyZWF0ZSBhIFwiZmFrZSBib2R5XCIgZm9yIHRlc3RpbmcgYmFzZWQgb24gbWV0aG9kIHVzZWQgaW4galF1ZXJ5LnN1cHBvcnRcblx0dGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBib2R5ID8gXCJkaXZcIiA6IFwiYm9keVwiICk7XG5cdHRlc3RFbGVtZW50U3R5bGUgPSB7XG5cdFx0dmlzaWJpbGl0eTogXCJoaWRkZW5cIixcblx0XHR3aWR0aDogMCxcblx0XHRoZWlnaHQ6IDAsXG5cdFx0Ym9yZGVyOiAwLFxuXHRcdG1hcmdpbjogMCxcblx0XHRiYWNrZ3JvdW5kOiBcIm5vbmVcIlxuXHR9O1xuXHRpZiAoIGJvZHkgKSB7XG5cdFx0JC5leHRlbmQoIHRlc3RFbGVtZW50U3R5bGUsIHtcblx0XHRcdHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG5cdFx0XHRsZWZ0OiBcIi0xMDAwcHhcIixcblx0XHRcdHRvcDogXCItMTAwMHB4XCJcblx0XHR9KTtcblx0fVxuXHRmb3IgKCBpIGluIHRlc3RFbGVtZW50U3R5bGUgKSB7XG5cdFx0dGVzdEVsZW1lbnQuc3R5bGVbIGkgXSA9IHRlc3RFbGVtZW50U3R5bGVbIGkgXTtcblx0fVxuXHR0ZXN0RWxlbWVudC5hcHBlbmRDaGlsZCggZGl2ICk7XG5cdHRlc3RFbGVtZW50UGFyZW50ID0gYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdHRlc3RFbGVtZW50UGFyZW50Lmluc2VydEJlZm9yZSggdGVzdEVsZW1lbnQsIHRlc3RFbGVtZW50UGFyZW50LmZpcnN0Q2hpbGQgKTtcblxuXHRkaXYuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAxMC43NDMyMjIycHg7XCI7XG5cblx0b2Zmc2V0TGVmdCA9ICQoIGRpdiApLm9mZnNldCgpLmxlZnQ7XG5cdCQuc3VwcG9ydC5vZmZzZXRGcmFjdGlvbnMgPSBvZmZzZXRMZWZ0ID4gMTAgJiYgb2Zmc2V0TGVmdCA8IDExO1xuXG5cdHRlc3RFbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG5cdHRlc3RFbGVtZW50UGFyZW50LnJlbW92ZUNoaWxkKCB0ZXN0RWxlbWVudCApO1xufSkoKTtcblxuLy8gREVQUkVDQVRFRFxuaWYgKCAkLnVpQmFja0NvbXBhdCAhPT0gZmFsc2UgKSB7XG5cdC8vIG9mZnNldCBvcHRpb25cblx0KGZ1bmN0aW9uKCAkICkge1xuXHRcdHZhciBfcG9zaXRpb24gPSAkLmZuLnBvc2l0aW9uO1xuXHRcdCQuZm4ucG9zaXRpb24gPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdGlmICggIW9wdGlvbnMgfHwgIW9wdGlvbnMub2Zmc2V0ICkge1xuXHRcdFx0XHRyZXR1cm4gX3Bvc2l0aW9uLmNhbGwoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHRcdH1cblx0XHRcdHZhciBvZmZzZXQgPSBvcHRpb25zLm9mZnNldC5zcGxpdCggXCIgXCIgKSxcblx0XHRcdFx0YXQgPSBvcHRpb25zLmF0LnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0aWYgKCBvZmZzZXQubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRvZmZzZXRbIDEgXSA9IG9mZnNldFsgMCBdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAvXlxcZC8udGVzdCggb2Zmc2V0WyAwIF0gKSApIHtcblx0XHRcdFx0b2Zmc2V0WyAwIF0gPSBcIitcIiArIG9mZnNldFsgMCBdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAvXlxcZC8udGVzdCggb2Zmc2V0WyAxIF0gKSApIHtcblx0XHRcdFx0b2Zmc2V0WyAxIF0gPSBcIitcIiArIG9mZnNldFsgMSBdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBhdC5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdGlmICggL2xlZnR8Y2VudGVyfHJpZ2h0Ly50ZXN0KCBhdFsgMCBdICkgKSB7XG5cdFx0XHRcdFx0YXRbIDEgXSA9IFwiY2VudGVyXCI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YXRbIDEgXSA9IGF0WyAwIF07XG5cdFx0XHRcdFx0YXRbIDAgXSA9IFwiY2VudGVyXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBfcG9zaXRpb24uY2FsbCggdGhpcywgJC5leHRlbmQoIG9wdGlvbnMsIHtcblx0XHRcdFx0YXQ6IGF0WyAwIF0gKyBvZmZzZXRbIDAgXSArIFwiIFwiICsgYXRbIDEgXSArIG9mZnNldFsgMSBdLFxuXHRcdFx0XHRvZmZzZXQ6IHVuZGVmaW5lZFxuXHRcdFx0fSApICk7XG5cdFx0fTtcblx0fSggalF1ZXJ5ICkgKTtcbn1cblxufSggalF1ZXJ5ICkgKTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG52YXIgdWlkID0gMCxcblx0aGlkZVByb3BzID0ge30sXG5cdHNob3dQcm9wcyA9IHt9O1xuXG5oaWRlUHJvcHMuaGVpZ2h0ID0gaGlkZVByb3BzLnBhZGRpbmdUb3AgPSBoaWRlUHJvcHMucGFkZGluZ0JvdHRvbSA9XG5cdGhpZGVQcm9wcy5ib3JkZXJUb3BXaWR0aCA9IGhpZGVQcm9wcy5ib3JkZXJCb3R0b21XaWR0aCA9IFwiaGlkZVwiO1xuc2hvd1Byb3BzLmhlaWdodCA9IHNob3dQcm9wcy5wYWRkaW5nVG9wID0gc2hvd1Byb3BzLnBhZGRpbmdCb3R0b20gPVxuXHRzaG93UHJvcHMuYm9yZGVyVG9wV2lkdGggPSBzaG93UHJvcHMuYm9yZGVyQm90dG9tV2lkdGggPSBcInNob3dcIjtcblxuJC53aWRnZXQoIFwidWkuYWNjb3JkaW9uXCIsIHtcblx0dmVyc2lvbjogXCIxLjkuMlwiLFxuXHRvcHRpb25zOiB7XG5cdFx0YWN0aXZlOiAwLFxuXHRcdGFuaW1hdGU6IHt9LFxuXHRcdGNvbGxhcHNpYmxlOiBmYWxzZSxcblx0XHRldmVudDogXCJjbGlja1wiLFxuXHRcdGhlYWRlcjogXCI+IGxpID4gOmZpcnN0LWNoaWxkLD4gOm5vdChsaSk6ZXZlblwiLFxuXHRcdGhlaWdodFN0eWxlOiBcImF1dG9cIixcblx0XHRpY29uczoge1xuXHRcdFx0YWN0aXZlSGVhZGVyOiBcInVpLWljb24tdHJpYW5nbGUtMS1zXCIsXG5cdFx0XHRoZWFkZXI6IFwidWktaWNvbi10cmlhbmdsZS0xLWVcIlxuXHRcdH0sXG5cblx0XHQvLyBjYWxsYmFja3Ncblx0XHRhY3RpdmF0ZTogbnVsbCxcblx0XHRiZWZvcmVBY3RpdmF0ZTogbnVsbFxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhY2NvcmRpb25JZCA9IHRoaXMuYWNjb3JkaW9uSWQgPSBcInVpLWFjY29yZGlvbi1cIiArXG5cdFx0XHRcdCh0aGlzLmVsZW1lbnQuYXR0ciggXCJpZFwiICkgfHwgKyt1aWQpLFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdHRoaXMucHJldlNob3cgPSB0aGlzLnByZXZIaWRlID0gJCgpO1xuXHRcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyggXCJ1aS1hY2NvcmRpb24gdWktd2lkZ2V0IHVpLWhlbHBlci1yZXNldFwiICk7XG5cblx0XHR0aGlzLmhlYWRlcnMgPSB0aGlzLmVsZW1lbnQuZmluZCggb3B0aW9ucy5oZWFkZXIgKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLWFjY29yZGlvbi1oZWFkZXIgdWktaGVscGVyLXJlc2V0IHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbFwiICk7XG5cdFx0dGhpcy5faG92ZXJhYmxlKCB0aGlzLmhlYWRlcnMgKTtcblx0XHR0aGlzLl9mb2N1c2FibGUoIHRoaXMuaGVhZGVycyApO1xuXG5cdFx0dGhpcy5oZWFkZXJzLm5leHQoKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLWFjY29yZGlvbi1jb250ZW50IHVpLWhlbHBlci1yZXNldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYm90dG9tXCIgKVxuXHRcdFx0LmhpZGUoKTtcblxuXHRcdC8vIGRvbid0IGFsbG93IGNvbGxhcHNpYmxlOiBmYWxzZSBhbmQgYWN0aXZlOiBmYWxzZSAvIG51bGxcblx0XHRpZiAoICFvcHRpb25zLmNvbGxhcHNpYmxlICYmIChvcHRpb25zLmFjdGl2ZSA9PT0gZmFsc2UgfHwgb3B0aW9ucy5hY3RpdmUgPT0gbnVsbCkgKSB7XG5cdFx0XHRvcHRpb25zLmFjdGl2ZSA9IDA7XG5cdFx0fVxuXHRcdC8vIGhhbmRsZSBuZWdhdGl2ZSB2YWx1ZXNcblx0XHRpZiAoIG9wdGlvbnMuYWN0aXZlIDwgMCApIHtcblx0XHRcdG9wdGlvbnMuYWN0aXZlICs9IHRoaXMuaGVhZGVycy5sZW5ndGg7XG5cdFx0fVxuXHRcdHRoaXMuYWN0aXZlID0gdGhpcy5fZmluZEFjdGl2ZSggb3B0aW9ucy5hY3RpdmUgKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLWFjY29yZGlvbi1oZWFkZXItYWN0aXZlIHVpLXN0YXRlLWFjdGl2ZVwiIClcblx0XHRcdC50b2dnbGVDbGFzcyggXCJ1aS1jb3JuZXItYWxsIHVpLWNvcm5lci10b3BcIiApO1xuXHRcdHRoaXMuYWN0aXZlLm5leHQoKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLWFjY29yZGlvbi1jb250ZW50LWFjdGl2ZVwiIClcblx0XHRcdC5zaG93KCk7XG5cblx0XHR0aGlzLl9jcmVhdGVJY29ucygpO1xuXHRcdHRoaXMucmVmcmVzaCgpO1xuXG5cdFx0Ly8gQVJJQVxuXHRcdHRoaXMuZWxlbWVudC5hdHRyKCBcInJvbGVcIiwgXCJ0YWJsaXN0XCIgKTtcblxuXHRcdHRoaXMuaGVhZGVyc1xuXHRcdFx0LmF0dHIoIFwicm9sZVwiLCBcInRhYlwiIClcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHR2YXIgaGVhZGVyID0gJCggdGhpcyApLFxuXHRcdFx0XHRcdGhlYWRlcklkID0gaGVhZGVyLmF0dHIoIFwiaWRcIiApLFxuXHRcdFx0XHRcdHBhbmVsID0gaGVhZGVyLm5leHQoKSxcblx0XHRcdFx0XHRwYW5lbElkID0gcGFuZWwuYXR0ciggXCJpZFwiICk7XG5cdFx0XHRcdGlmICggIWhlYWRlcklkICkge1xuXHRcdFx0XHRcdGhlYWRlcklkID0gYWNjb3JkaW9uSWQgKyBcIi1oZWFkZXItXCIgKyBpO1xuXHRcdFx0XHRcdGhlYWRlci5hdHRyKCBcImlkXCIsIGhlYWRlcklkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhcGFuZWxJZCApIHtcblx0XHRcdFx0XHRwYW5lbElkID0gYWNjb3JkaW9uSWQgKyBcIi1wYW5lbC1cIiArIGk7XG5cdFx0XHRcdFx0cGFuZWwuYXR0ciggXCJpZFwiLCBwYW5lbElkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aGVhZGVyLmF0dHIoIFwiYXJpYS1jb250cm9sc1wiLCBwYW5lbElkICk7XG5cdFx0XHRcdHBhbmVsLmF0dHIoIFwiYXJpYS1sYWJlbGxlZGJ5XCIsIGhlYWRlcklkICk7XG5cdFx0XHR9KVxuXHRcdFx0Lm5leHQoKVxuXHRcdFx0XHQuYXR0ciggXCJyb2xlXCIsIFwidGFicGFuZWxcIiApO1xuXG5cdFx0dGhpcy5oZWFkZXJzXG5cdFx0XHQubm90KCB0aGlzLmFjdGl2ZSApXG5cdFx0XHQuYXR0cih7XG5cdFx0XHRcdFwiYXJpYS1zZWxlY3RlZFwiOiBcImZhbHNlXCIsXG5cdFx0XHRcdHRhYkluZGV4OiAtMVxuXHRcdFx0fSlcblx0XHRcdC5uZXh0KClcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFwiYXJpYS1leHBhbmRlZFwiOiBcImZhbHNlXCIsXG5cdFx0XHRcdFx0XCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuaGlkZSgpO1xuXG5cdFx0Ly8gbWFrZSBzdXJlIGF0IGxlYXN0IG9uZSBoZWFkZXIgaXMgaW4gdGhlIHRhYiBvcmRlclxuXHRcdGlmICggIXRoaXMuYWN0aXZlLmxlbmd0aCApIHtcblx0XHRcdHRoaXMuaGVhZGVycy5lcSggMCApLmF0dHIoIFwidGFiSW5kZXhcIiwgMCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFjdGl2ZS5hdHRyKHtcblx0XHRcdFx0XCJhcmlhLXNlbGVjdGVkXCI6IFwidHJ1ZVwiLFxuXHRcdFx0XHR0YWJJbmRleDogMFxuXHRcdFx0fSlcblx0XHRcdC5uZXh0KClcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdFwiYXJpYS1leHBhbmRlZFwiOiBcInRydWVcIixcblx0XHRcdFx0XHRcImFyaWEtaGlkZGVuXCI6IFwiZmFsc2VcIlxuXHRcdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0aGlzLl9vbiggdGhpcy5oZWFkZXJzLCB7IGtleWRvd246IFwiX2tleWRvd25cIiB9KTtcblx0XHR0aGlzLl9vbiggdGhpcy5oZWFkZXJzLm5leHQoKSwgeyBrZXlkb3duOiBcIl9wYW5lbEtleURvd25cIiB9KTtcblx0XHR0aGlzLl9zZXR1cEV2ZW50cyggb3B0aW9ucy5ldmVudCApO1xuXHR9LFxuXG5cdF9nZXRDcmVhdGVFdmVudERhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRoZWFkZXI6IHRoaXMuYWN0aXZlLFxuXHRcdFx0Y29udGVudDogIXRoaXMuYWN0aXZlLmxlbmd0aCA/ICQoKSA6IHRoaXMuYWN0aXZlLm5leHQoKVxuXHRcdH07XG5cdH0sXG5cblx0X2NyZWF0ZUljb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWNvbnMgPSB0aGlzLm9wdGlvbnMuaWNvbnM7XG5cdFx0aWYgKCBpY29ucyApIHtcblx0XHRcdCQoIFwiPHNwYW4+XCIgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktYWNjb3JkaW9uLWhlYWRlci1pY29uIHVpLWljb24gXCIgKyBpY29ucy5oZWFkZXIgKVxuXHRcdFx0XHQucHJlcGVuZFRvKCB0aGlzLmhlYWRlcnMgKTtcblx0XHRcdHRoaXMuYWN0aXZlLmNoaWxkcmVuKCBcIi51aS1hY2NvcmRpb24taGVhZGVyLWljb25cIiApXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggaWNvbnMuaGVhZGVyIClcblx0XHRcdFx0LmFkZENsYXNzKCBpY29ucy5hY3RpdmVIZWFkZXIgKTtcblx0XHRcdHRoaXMuaGVhZGVycy5hZGRDbGFzcyggXCJ1aS1hY2NvcmRpb24taWNvbnNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRfZGVzdHJveUljb25zOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmhlYWRlcnNcblx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1hY2NvcmRpb24taWNvbnNcIiApXG5cdFx0XHQuY2hpbGRyZW4oIFwiLnVpLWFjY29yZGlvbi1oZWFkZXItaWNvblwiIClcblx0XHRcdFx0LnJlbW92ZSgpO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY29udGVudHM7XG5cblx0XHQvLyBjbGVhbiB1cCBtYWluIGVsZW1lbnRcblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1hY2NvcmRpb24gdWktd2lkZ2V0IHVpLWhlbHBlci1yZXNldFwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcInJvbGVcIiApO1xuXG5cdFx0Ly8gY2xlYW4gdXAgaGVhZGVyc1xuXHRcdHRoaXMuaGVhZGVyc1xuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWFjY29yZGlvbi1oZWFkZXIgdWktYWNjb3JkaW9uLWhlYWRlci1hY3RpdmUgdWktaGVscGVyLXJlc2V0IHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbCB1aS1zdGF0ZS1hY3RpdmUgdWktc3RhdGUtZGlzYWJsZWQgdWktY29ybmVyLXRvcFwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcInJvbGVcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLXNlbGVjdGVkXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1jb250cm9sc1wiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcInRhYkluZGV4XCIgKVxuXHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggL151aS1hY2NvcmRpb24vLnRlc3QoIHRoaXMuaWQgKSApIHtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdHRoaXMuX2Rlc3Ryb3lJY29ucygpO1xuXG5cdFx0Ly8gY2xlYW4gdXAgY29udGVudCBwYW5lbHNcblx0XHRjb250ZW50cyA9IHRoaXMuaGVhZGVycy5uZXh0KClcblx0XHRcdC5jc3MoIFwiZGlzcGxheVwiLCBcIlwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcInJvbGVcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWV4cGFuZGVkXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1oaWRkZW5cIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWxhYmVsbGVkYnlcIiApXG5cdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktaGVscGVyLXJlc2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1ib3R0b20gdWktYWNjb3JkaW9uLWNvbnRlbnQgdWktYWNjb3JkaW9uLWNvbnRlbnQtYWN0aXZlIHVpLXN0YXRlLWRpc2FibGVkXCIgKVxuXHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggL151aS1hY2NvcmRpb24vLnRlc3QoIHRoaXMuaWQgKSApIHtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdGlmICggdGhpcy5vcHRpb25zLmhlaWdodFN0eWxlICE9PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdGNvbnRlbnRzLmNzcyggXCJoZWlnaHRcIiwgXCJcIiApO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRpZiAoIGtleSA9PT0gXCJhY3RpdmVcIiApIHtcblx0XHRcdC8vIF9hY3RpdmF0ZSgpIHdpbGwgaGFuZGxlIGludmFsaWQgdmFsdWVzIGFuZCB1cGRhdGUgdGhpcy5vcHRpb25zXG5cdFx0XHR0aGlzLl9hY3RpdmF0ZSggdmFsdWUgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gXCJldmVudFwiICkge1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX29mZiggdGhpcy5oZWFkZXJzLCB0aGlzLm9wdGlvbnMuZXZlbnQgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NldHVwRXZlbnRzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N1cGVyKCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBzZXR0aW5nIGNvbGxhcHNpYmxlOiBmYWxzZSB3aGlsZSBjb2xsYXBzZWQ7IG9wZW4gZmlyc3QgcGFuZWxcblx0XHRpZiAoIGtleSA9PT0gXCJjb2xsYXBzaWJsZVwiICYmICF2YWx1ZSAmJiB0aGlzLm9wdGlvbnMuYWN0aXZlID09PSBmYWxzZSApIHtcblx0XHRcdHRoaXMuX2FjdGl2YXRlKCAwICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IFwiaWNvbnNcIiApIHtcblx0XHRcdHRoaXMuX2Rlc3Ryb3lJY29ucygpO1xuXHRcdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdFx0dGhpcy5fY3JlYXRlSWNvbnMoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyAjNTMzMiAtIG9wYWNpdHkgZG9lc24ndCBjYXNjYWRlIHRvIHBvc2l0aW9uZWQgZWxlbWVudHMgaW4gSUVcblx0XHQvLyBzbyB3ZSBuZWVkIHRvIGFkZCB0aGUgZGlzYWJsZWQgY2xhc3MgdG8gdGhlIGhlYWRlcnMgYW5kIHBhbmVsc1xuXHRcdGlmICgga2V5ID09PSBcImRpc2FibGVkXCIgKSB7XG5cdFx0XHR0aGlzLmhlYWRlcnMuYWRkKCB0aGlzLmhlYWRlcnMubmV4dCgpIClcblx0XHRcdFx0LnRvZ2dsZUNsYXNzKCBcInVpLXN0YXRlLWRpc2FibGVkXCIsICEhdmFsdWUgKTtcblx0XHR9XG5cdH0sXG5cblx0X2tleWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoIGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBrZXlDb2RlID0gJC51aS5rZXlDb2RlLFxuXHRcdFx0bGVuZ3RoID0gdGhpcy5oZWFkZXJzLmxlbmd0aCxcblx0XHRcdGN1cnJlbnRJbmRleCA9IHRoaXMuaGVhZGVycy5pbmRleCggZXZlbnQudGFyZ2V0ICksXG5cdFx0XHR0b0ZvY3VzID0gZmFsc2U7XG5cblx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXHRcdFx0Y2FzZSBrZXlDb2RlLlJJR0hUOlxuXHRcdFx0Y2FzZSBrZXlDb2RlLkRPV046XG5cdFx0XHRcdHRvRm9jdXMgPSB0aGlzLmhlYWRlcnNbICggY3VycmVudEluZGV4ICsgMSApICUgbGVuZ3RoIF07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBrZXlDb2RlLkxFRlQ6XG5cdFx0XHRjYXNlIGtleUNvZGUuVVA6XG5cdFx0XHRcdHRvRm9jdXMgPSB0aGlzLmhlYWRlcnNbICggY3VycmVudEluZGV4IC0gMSArIGxlbmd0aCApICUgbGVuZ3RoIF07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBrZXlDb2RlLlNQQUNFOlxuXHRcdFx0Y2FzZSBrZXlDb2RlLkVOVEVSOlxuXHRcdFx0XHR0aGlzLl9ldmVudEhhbmRsZXIoIGV2ZW50ICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBrZXlDb2RlLkhPTUU6XG5cdFx0XHRcdHRvRm9jdXMgPSB0aGlzLmhlYWRlcnNbIDAgXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIGtleUNvZGUuRU5EOlxuXHRcdFx0XHR0b0ZvY3VzID0gdGhpcy5oZWFkZXJzWyBsZW5ndGggLSAxIF07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGlmICggdG9Gb2N1cyApIHtcblx0XHRcdCQoIGV2ZW50LnRhcmdldCApLmF0dHIoIFwidGFiSW5kZXhcIiwgLTEgKTtcblx0XHRcdCQoIHRvRm9jdXMgKS5hdHRyKCBcInRhYkluZGV4XCIsIDAgKTtcblx0XHRcdHRvRm9jdXMuZm9jdXMoKTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9wYW5lbEtleURvd24gOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuVVAgJiYgZXZlbnQuY3RybEtleSApIHtcblx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5wcmV2KCkuZm9jdXMoKTtcblx0XHR9XG5cdH0sXG5cblx0cmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1heEhlaWdodCwgb3ZlcmZsb3csXG5cdFx0XHRoZWlnaHRTdHlsZSA9IHRoaXMub3B0aW9ucy5oZWlnaHRTdHlsZSxcblx0XHRcdHBhcmVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnQoKTtcblxuXG5cdFx0aWYgKCBoZWlnaHRTdHlsZSA9PT0gXCJmaWxsXCIgKSB7XG5cdFx0XHQvLyBJRSA2IHRyZWF0cyBoZWlnaHQgbGlrZSBtaW5IZWlnaHQsIHNvIHdlIG5lZWQgdG8gdHVybiBvZmYgb3ZlcmZsb3dcblx0XHRcdC8vIGluIG9yZGVyIHRvIGdldCBhIHJlbGlhYmxlIGhlaWdodFxuXHRcdFx0Ly8gd2UgdXNlIHRoZSBtaW5IZWlnaHQgc3VwcG9ydCB0ZXN0IGJlY2F1c2Ugd2UgYXNzdW1lIHRoYXQgb25seVxuXHRcdFx0Ly8gYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IG1pbkhlaWdodCB3aWxsIHRyZWF0IGhlaWdodCBhcyBtaW5IZWlnaHRcblx0XHRcdGlmICggISQuc3VwcG9ydC5taW5IZWlnaHQgKSB7XG5cdFx0XHRcdG92ZXJmbG93ID0gcGFyZW50LmNzcyggXCJvdmVyZmxvd1wiICk7XG5cdFx0XHRcdHBhcmVudC5jc3MoIFwib3ZlcmZsb3dcIiwgXCJoaWRkZW5cIik7XG5cdFx0XHR9XG5cdFx0XHRtYXhIZWlnaHQgPSBwYXJlbnQuaGVpZ2h0KCk7XG5cdFx0XHR0aGlzLmVsZW1lbnQuc2libGluZ3MoIFwiOnZpc2libGVcIiApLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gJCggdGhpcyApLFxuXHRcdFx0XHRcdHBvc2l0aW9uID0gZWxlbS5jc3MoIFwicG9zaXRpb25cIiApO1xuXG5cdFx0XHRcdGlmICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRtYXhIZWlnaHQgLT0gZWxlbS5vdXRlckhlaWdodCggdHJ1ZSApO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAoIG92ZXJmbG93ICkge1xuXHRcdFx0XHRwYXJlbnQuY3NzKCBcIm92ZXJmbG93XCIsIG92ZXJmbG93ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuaGVhZGVycy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRtYXhIZWlnaHQgLT0gJCggdGhpcyApLm91dGVySGVpZ2h0KCB0cnVlICk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5oZWFkZXJzLm5leHQoKVxuXHRcdFx0XHQuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkKCB0aGlzICkuaGVpZ2h0KCBNYXRoLm1heCggMCwgbWF4SGVpZ2h0IC1cblx0XHRcdFx0XHRcdCQoIHRoaXMgKS5pbm5lckhlaWdodCgpICsgJCggdGhpcyApLmhlaWdodCgpICkgKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LmNzcyggXCJvdmVyZmxvd1wiLCBcImF1dG9cIiApO1xuXHRcdH0gZWxzZSBpZiAoIGhlaWdodFN0eWxlID09PSBcImF1dG9cIiApIHtcblx0XHRcdG1heEhlaWdodCA9IDA7XG5cdFx0XHR0aGlzLmhlYWRlcnMubmV4dCgpXG5cdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdG1heEhlaWdodCA9IE1hdGgubWF4KCBtYXhIZWlnaHQsICQoIHRoaXMgKS5jc3MoIFwiaGVpZ2h0XCIsIFwiXCIgKS5oZWlnaHQoKSApO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuaGVpZ2h0KCBtYXhIZWlnaHQgKTtcblx0XHR9XG5cdH0sXG5cblx0X2FjdGl2YXRlOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0dmFyIGFjdGl2ZSA9IHRoaXMuX2ZpbmRBY3RpdmUoIGluZGV4IClbIDAgXTtcblxuXHRcdC8vIHRyeWluZyB0byBhY3RpdmF0ZSB0aGUgYWxyZWFkeSBhY3RpdmUgcGFuZWxcblx0XHRpZiAoIGFjdGl2ZSA9PT0gdGhpcy5hY3RpdmVbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyB0cnlpbmcgdG8gY29sbGFwc2UsIHNpbXVsYXRlIGEgY2xpY2sgb24gdGhlIGN1cnJlbnRseSBhY3RpdmUgaGVhZGVyXG5cdFx0YWN0aXZlID0gYWN0aXZlIHx8IHRoaXMuYWN0aXZlWyAwIF07XG5cblx0XHR0aGlzLl9ldmVudEhhbmRsZXIoe1xuXHRcdFx0dGFyZ2V0OiBhY3RpdmUsXG5cdFx0XHRjdXJyZW50VGFyZ2V0OiBhY3RpdmUsXG5cdFx0XHRwcmV2ZW50RGVmYXVsdDogJC5ub29wXG5cdFx0fSk7XG5cdH0sXG5cblx0X2ZpbmRBY3RpdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcIm51bWJlclwiID8gdGhpcy5oZWFkZXJzLmVxKCBzZWxlY3RvciApIDogJCgpO1xuXHR9LFxuXG5cdF9zZXR1cEV2ZW50czogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBldmVudHMgPSB7fTtcblx0XHRpZiAoICFldmVudCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0JC5lYWNoKCBldmVudC5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKCBpbmRleCwgZXZlbnROYW1lICkge1xuXHRcdFx0ZXZlbnRzWyBldmVudE5hbWUgXSA9IFwiX2V2ZW50SGFuZGxlclwiO1xuXHRcdH0pO1xuXHRcdHRoaXMuX29uKCB0aGlzLmhlYWRlcnMsIGV2ZW50cyApO1xuXHR9LFxuXG5cdF9ldmVudEhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGFjdGl2ZSA9IHRoaXMuYWN0aXZlLFxuXHRcdFx0Y2xpY2tlZCA9ICQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKSxcblx0XHRcdGNsaWNrZWRJc0FjdGl2ZSA9IGNsaWNrZWRbIDAgXSA9PT0gYWN0aXZlWyAwIF0sXG5cdFx0XHRjb2xsYXBzaW5nID0gY2xpY2tlZElzQWN0aXZlICYmIG9wdGlvbnMuY29sbGFwc2libGUsXG5cdFx0XHR0b1Nob3cgPSBjb2xsYXBzaW5nID8gJCgpIDogY2xpY2tlZC5uZXh0KCksXG5cdFx0XHR0b0hpZGUgPSBhY3RpdmUubmV4dCgpLFxuXHRcdFx0ZXZlbnREYXRhID0ge1xuXHRcdFx0XHRvbGRIZWFkZXI6IGFjdGl2ZSxcblx0XHRcdFx0b2xkUGFuZWw6IHRvSGlkZSxcblx0XHRcdFx0bmV3SGVhZGVyOiBjb2xsYXBzaW5nID8gJCgpIDogY2xpY2tlZCxcblx0XHRcdFx0bmV3UGFuZWw6IHRvU2hvd1xuXHRcdFx0fTtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRpZiAoXG5cdFx0XHRcdC8vIGNsaWNrIG9uIGFjdGl2ZSBoZWFkZXIsIGJ1dCBub3QgY29sbGFwc2libGVcblx0XHRcdFx0KCBjbGlja2VkSXNBY3RpdmUgJiYgIW9wdGlvbnMuY29sbGFwc2libGUgKSB8fFxuXHRcdFx0XHQvLyBhbGxvdyBjYW5jZWxpbmcgYWN0aXZhdGlvblxuXHRcdFx0XHQoIHRoaXMuX3RyaWdnZXIoIFwiYmVmb3JlQWN0aXZhdGVcIiwgZXZlbnQsIGV2ZW50RGF0YSApID09PSBmYWxzZSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG9wdGlvbnMuYWN0aXZlID0gY29sbGFwc2luZyA/IGZhbHNlIDogdGhpcy5oZWFkZXJzLmluZGV4KCBjbGlja2VkICk7XG5cblx0XHQvLyB3aGVuIHRoZSBjYWxsIHRvIC5fdG9nZ2xlKCkgY29tZXMgYWZ0ZXIgdGhlIGNsYXNzIGNoYW5nZXNcblx0XHQvLyBpdCBjYXVzZXMgYSB2ZXJ5IG9kZCBidWcgaW4gSUUgOCAoc2VlICM2NzIwKVxuXHRcdHRoaXMuYWN0aXZlID0gY2xpY2tlZElzQWN0aXZlID8gJCgpIDogY2xpY2tlZDtcblx0XHR0aGlzLl90b2dnbGUoIGV2ZW50RGF0YSApO1xuXG5cdFx0Ly8gc3dpdGNoIGNsYXNzZXNcblx0XHQvLyBjb3JuZXIgY2xhc3NlcyBvbiB0aGUgcHJldmlvdXNseSBhY3RpdmUgaGVhZGVyIHN0YXkgYWZ0ZXIgdGhlIGFuaW1hdGlvblxuXHRcdGFjdGl2ZS5yZW1vdmVDbGFzcyggXCJ1aS1hY2NvcmRpb24taGVhZGVyLWFjdGl2ZSB1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdGlmICggb3B0aW9ucy5pY29ucyApIHtcblx0XHRcdGFjdGl2ZS5jaGlsZHJlbiggXCIudWktYWNjb3JkaW9uLWhlYWRlci1pY29uXCIgKVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoIG9wdGlvbnMuaWNvbnMuYWN0aXZlSGVhZGVyIClcblx0XHRcdFx0LmFkZENsYXNzKCBvcHRpb25zLmljb25zLmhlYWRlciApO1xuXHRcdH1cblxuXHRcdGlmICggIWNsaWNrZWRJc0FjdGl2ZSApIHtcblx0XHRcdGNsaWNrZWRcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWNvcm5lci1hbGxcIiApXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1hY2NvcmRpb24taGVhZGVyLWFjdGl2ZSB1aS1zdGF0ZS1hY3RpdmUgdWktY29ybmVyLXRvcFwiICk7XG5cdFx0XHRpZiAoIG9wdGlvbnMuaWNvbnMgKSB7XG5cdFx0XHRcdGNsaWNrZWQuY2hpbGRyZW4oIFwiLnVpLWFjY29yZGlvbi1oZWFkZXItaWNvblwiIClcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIG9wdGlvbnMuaWNvbnMuaGVhZGVyIClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIG9wdGlvbnMuaWNvbnMuYWN0aXZlSGVhZGVyICk7XG5cdFx0XHR9XG5cblx0XHRcdGNsaWNrZWRcblx0XHRcdFx0Lm5leHQoKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktYWNjb3JkaW9uLWNvbnRlbnQtYWN0aXZlXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0X3RvZ2dsZTogZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0dmFyIHRvU2hvdyA9IGRhdGEubmV3UGFuZWwsXG5cdFx0XHR0b0hpZGUgPSB0aGlzLnByZXZTaG93Lmxlbmd0aCA/IHRoaXMucHJldlNob3cgOiBkYXRhLm9sZFBhbmVsO1xuXG5cdFx0Ly8gaGFuZGxlIGFjdGl2YXRpbmcgYSBwYW5lbCBkdXJpbmcgdGhlIGFuaW1hdGlvbiBmb3IgYW5vdGhlciBhY3RpdmF0aW9uXG5cdFx0dGhpcy5wcmV2U2hvdy5hZGQoIHRoaXMucHJldkhpZGUgKS5zdG9wKCB0cnVlLCB0cnVlICk7XG5cdFx0dGhpcy5wcmV2U2hvdyA9IHRvU2hvdztcblx0XHR0aGlzLnByZXZIaWRlID0gdG9IaWRlO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuYW5pbWF0ZSApIHtcblx0XHRcdHRoaXMuX2FuaW1hdGUoIHRvU2hvdywgdG9IaWRlLCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRvSGlkZS5oaWRlKCk7XG5cdFx0XHR0b1Nob3cuc2hvdygpO1xuXHRcdFx0dGhpcy5fdG9nZ2xlQ29tcGxldGUoIGRhdGEgKTtcblx0XHR9XG5cblx0XHR0b0hpZGUuYXR0cih7XG5cdFx0XHRcImFyaWEtZXhwYW5kZWRcIjogXCJmYWxzZVwiLFxuXHRcdFx0XCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuXHRcdH0pO1xuXHRcdHRvSGlkZS5wcmV2KCkuYXR0ciggXCJhcmlhLXNlbGVjdGVkXCIsIFwiZmFsc2VcIiApO1xuXHRcdC8vIGlmIHdlJ3JlIHN3aXRjaGluZyBwYW5lbHMsIHJlbW92ZSB0aGUgb2xkIGhlYWRlciBmcm9tIHRoZSB0YWIgb3JkZXJcblx0XHQvLyBpZiB3ZSdyZSBvcGVuaW5nIGZyb20gY29sbGFwc2VkIHN0YXRlLCByZW1vdmUgdGhlIHByZXZpb3VzIGhlYWRlciBmcm9tIHRoZSB0YWIgb3JkZXJcblx0XHQvLyBpZiB3ZSdyZSBjb2xsYXBzaW5nLCB0aGVuIGtlZXAgdGhlIGNvbGxhcHNpbmcgaGVhZGVyIGluIHRoZSB0YWIgb3JkZXJcblx0XHRpZiAoIHRvU2hvdy5sZW5ndGggJiYgdG9IaWRlLmxlbmd0aCApIHtcblx0XHRcdHRvSGlkZS5wcmV2KCkuYXR0ciggXCJ0YWJJbmRleFwiLCAtMSApO1xuXHRcdH0gZWxzZSBpZiAoIHRvU2hvdy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLmhlYWRlcnMuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJCggdGhpcyApLmF0dHIoIFwidGFiSW5kZXhcIiApID09PSAwO1xuXHRcdFx0fSlcblx0XHRcdC5hdHRyKCBcInRhYkluZGV4XCIsIC0xICk7XG5cdFx0fVxuXG5cdFx0dG9TaG93XG5cdFx0XHQuYXR0cih7XG5cdFx0XHRcdFwiYXJpYS1leHBhbmRlZFwiOiBcInRydWVcIixcblx0XHRcdFx0XCJhcmlhLWhpZGRlblwiOiBcImZhbHNlXCJcblx0XHRcdH0pXG5cdFx0XHQucHJldigpXG5cdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcImFyaWEtc2VsZWN0ZWRcIjogXCJ0cnVlXCIsXG5cdFx0XHRcdFx0dGFiSW5kZXg6IDBcblx0XHRcdFx0fSk7XG5cdH0sXG5cblx0X2FuaW1hdGU6IGZ1bmN0aW9uKCB0b1Nob3csIHRvSGlkZSwgZGF0YSApIHtcblx0XHR2YXIgdG90YWwsIGVhc2luZywgZHVyYXRpb24sXG5cdFx0XHR0aGF0ID0gdGhpcyxcblx0XHRcdGFkanVzdCA9IDAsXG5cdFx0XHRkb3duID0gdG9TaG93Lmxlbmd0aCAmJlxuXHRcdFx0XHQoICF0b0hpZGUubGVuZ3RoIHx8ICggdG9TaG93LmluZGV4KCkgPCB0b0hpZGUuaW5kZXgoKSApICksXG5cdFx0XHRhbmltYXRlID0gdGhpcy5vcHRpb25zLmFuaW1hdGUgfHwge30sXG5cdFx0XHRvcHRpb25zID0gZG93biAmJiBhbmltYXRlLmRvd24gfHwgYW5pbWF0ZSxcblx0XHRcdGNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoYXQuX3RvZ2dsZUNvbXBsZXRlKCBkYXRhICk7XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGR1cmF0aW9uID0gb3B0aW9ucztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGVhc2luZyA9IG9wdGlvbnM7XG5cdFx0fVxuXHRcdC8vIGZhbGwgYmFjayBmcm9tIG9wdGlvbnMgdG8gYW5pbWF0aW9uIGluIGNhc2Ugb2YgcGFydGlhbCBkb3duIHNldHRpbmdzXG5cdFx0ZWFzaW5nID0gZWFzaW5nIHx8IG9wdGlvbnMuZWFzaW5nIHx8IGFuaW1hdGUuZWFzaW5nO1xuXHRcdGR1cmF0aW9uID0gZHVyYXRpb24gfHwgb3B0aW9ucy5kdXJhdGlvbiB8fCBhbmltYXRlLmR1cmF0aW9uO1xuXG5cdFx0aWYgKCAhdG9IaWRlLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0b1Nob3cuYW5pbWF0ZSggc2hvd1Byb3BzLCBkdXJhdGlvbiwgZWFzaW5nLCBjb21wbGV0ZSApO1xuXHRcdH1cblx0XHRpZiAoICF0b1Nob3cubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRvSGlkZS5hbmltYXRlKCBoaWRlUHJvcHMsIGR1cmF0aW9uLCBlYXNpbmcsIGNvbXBsZXRlICk7XG5cdFx0fVxuXG5cdFx0dG90YWwgPSB0b1Nob3cuc2hvdygpLm91dGVySGVpZ2h0KCk7XG5cdFx0dG9IaWRlLmFuaW1hdGUoIGhpZGVQcm9wcywge1xuXHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uLFxuXHRcdFx0ZWFzaW5nOiBlYXNpbmcsXG5cdFx0XHRzdGVwOiBmdW5jdGlvbiggbm93LCBmeCApIHtcblx0XHRcdFx0Zngubm93ID0gTWF0aC5yb3VuZCggbm93ICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0dG9TaG93XG5cdFx0XHQuaGlkZSgpXG5cdFx0XHQuYW5pbWF0ZSggc2hvd1Byb3BzLCB7XG5cdFx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvbixcblx0XHRcdFx0ZWFzaW5nOiBlYXNpbmcsXG5cdFx0XHRcdGNvbXBsZXRlOiBjb21wbGV0ZSxcblx0XHRcdFx0c3RlcDogZnVuY3Rpb24oIG5vdywgZnggKSB7XG5cdFx0XHRcdFx0Zngubm93ID0gTWF0aC5yb3VuZCggbm93ICk7XG5cdFx0XHRcdFx0aWYgKCBmeC5wcm9wICE9PSBcImhlaWdodFwiICkge1xuXHRcdFx0XHRcdFx0YWRqdXN0ICs9IGZ4Lm5vdztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0aGF0Lm9wdGlvbnMuaGVpZ2h0U3R5bGUgIT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRcdFx0Zngubm93ID0gTWF0aC5yb3VuZCggdG90YWwgLSB0b0hpZGUub3V0ZXJIZWlnaHQoKSAtIGFkanVzdCApO1xuXHRcdFx0XHRcdFx0YWRqdXN0ID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9LFxuXG5cdF90b2dnbGVDb21wbGV0ZTogZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0dmFyIHRvSGlkZSA9IGRhdGEub2xkUGFuZWw7XG5cblx0XHR0b0hpZGVcblx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1hY2NvcmRpb24tY29udGVudC1hY3RpdmVcIiApXG5cdFx0XHQucHJldigpXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1jb3JuZXItdG9wXCIgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktY29ybmVyLWFsbFwiICk7XG5cblx0XHQvLyBXb3JrIGFyb3VuZCBmb3IgcmVuZGVyaW5nIGJ1ZyBpbiBJRSAoIzU0MjEpXG5cdFx0aWYgKCB0b0hpZGUubGVuZ3RoICkge1xuXHRcdFx0dG9IaWRlLnBhcmVudCgpWzBdLmNsYXNzTmFtZSA9IHRvSGlkZS5wYXJlbnQoKVswXS5jbGFzc05hbWU7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdHJpZ2dlciggXCJhY3RpdmF0ZVwiLCBudWxsLCBkYXRhICk7XG5cdH1cbn0pO1xuXG5cblxuLy8gREVQUkVDQVRFRFxuaWYgKCAkLnVpQmFja0NvbXBhdCAhPT0gZmFsc2UgKSB7XG5cdC8vIG5hdmlnYXRpb24gb3B0aW9uc1xuXHQoZnVuY3Rpb24oICQsIHByb3RvdHlwZSApIHtcblx0XHQkLmV4dGVuZCggcHJvdG90eXBlLm9wdGlvbnMsIHtcblx0XHRcdG5hdmlnYXRpb246IGZhbHNlLFxuXHRcdFx0bmF2aWdhdGlvbkZpbHRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmhyZWYudG9Mb3dlckNhc2UoKSA9PT0gbG9jYXRpb24uaHJlZi50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dmFyIF9jcmVhdGUgPSBwcm90b3R5cGUuX2NyZWF0ZTtcblx0XHRwcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMubmF2aWdhdGlvbiApIHtcblx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdGhlYWRlcnMgPSB0aGlzLmVsZW1lbnQuZmluZCggdGhpcy5vcHRpb25zLmhlYWRlciApLFxuXHRcdFx0XHRcdGNvbnRlbnQgPSBoZWFkZXJzLm5leHQoKSxcblx0XHRcdFx0XHRjdXJyZW50ID0gaGVhZGVycy5hZGQoIGNvbnRlbnQgKVxuXHRcdFx0XHRcdFx0LmZpbmQoIFwiYVwiIClcblx0XHRcdFx0XHRcdC5maWx0ZXIoIHRoaXMub3B0aW9ucy5uYXZpZ2F0aW9uRmlsdGVyIClcblx0XHRcdFx0XHRcdFsgMCBdO1xuXHRcdFx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cdFx0XHRcdFx0aGVhZGVycy5hZGQoIGNvbnRlbnQgKS5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHRcdFx0XHRpZiAoICQuY29udGFpbnMoIHRoaXMsIGN1cnJlbnQgKSApIHtcblx0XHRcdFx0XHRcdFx0dGhhdC5vcHRpb25zLmFjdGl2ZSA9IE1hdGguZmxvb3IoIGluZGV4IC8gMiApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdF9jcmVhdGUuY2FsbCggdGhpcyApO1xuXHRcdH07XG5cdH0oIGpRdWVyeSwgalF1ZXJ5LnVpLmFjY29yZGlvbi5wcm90b3R5cGUgKSApO1xuXG5cdC8vIGhlaWdodCBvcHRpb25zXG5cdChmdW5jdGlvbiggJCwgcHJvdG90eXBlICkge1xuXHRcdCQuZXh0ZW5kKCBwcm90b3R5cGUub3B0aW9ucywge1xuXHRcdFx0aGVpZ2h0U3R5bGU6IG51bGwsIC8vIHJlbW92ZSBkZWZhdWx0IHNvIHdlIGZhbGwgYmFjayB0byBvbGQgdmFsdWVzXG5cdFx0XHRhdXRvSGVpZ2h0OiB0cnVlLCAvLyB1c2UgaGVpZ2h0U3R5bGU6IFwiYXV0b1wiXG5cdFx0XHRjbGVhclN0eWxlOiBmYWxzZSwgLy8gdXNlIGhlaWdodFN0eWxlOiBcImNvbnRlbnRcIlxuXHRcdFx0ZmlsbFNwYWNlOiBmYWxzZSAvLyB1c2UgaGVpZ2h0U3R5bGU6IFwiZmlsbFwiXG5cdFx0fSk7XG5cblx0XHR2YXIgX2NyZWF0ZSA9IHByb3RvdHlwZS5fY3JlYXRlLFxuXHRcdFx0X3NldE9wdGlvbiA9IHByb3RvdHlwZS5fc2V0T3B0aW9uO1xuXG5cdFx0JC5leHRlbmQoIHByb3RvdHlwZSwge1xuXHRcdFx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5oZWlnaHRTdHlsZSA9IHRoaXMub3B0aW9ucy5oZWlnaHRTdHlsZSB8fFxuXHRcdFx0XHRcdHRoaXMuX21lcmdlSGVpZ2h0U3R5bGUoKTtcblxuXHRcdFx0XHRfY3JlYXRlLmNhbGwoIHRoaXMgKTtcblx0XHRcdH0sXG5cblx0XHRcdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdGlmICgga2V5ID09PSBcImF1dG9IZWlnaHRcIiB8fCBrZXkgPT09IFwiY2xlYXJTdHlsZVwiIHx8IGtleSA9PT0gXCJmaWxsU3BhY2VcIiApIHtcblx0XHRcdFx0XHR0aGlzLm9wdGlvbnMuaGVpZ2h0U3R5bGUgPSB0aGlzLl9tZXJnZUhlaWdodFN0eWxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3NldE9wdGlvbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHR9LFxuXG5cdFx0XHRfbWVyZ2VIZWlnaHRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0XHRcdGlmICggb3B0aW9ucy5maWxsU3BhY2UgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFwiZmlsbFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBvcHRpb25zLmNsZWFyU3R5bGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFwiY29udGVudFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBvcHRpb25zLmF1dG9IZWlnaHQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFwiYXV0b1wiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0oIGpRdWVyeSwgalF1ZXJ5LnVpLmFjY29yZGlvbi5wcm90b3R5cGUgKSApO1xuXG5cdC8vIGljb24gb3B0aW9uc1xuXHQoZnVuY3Rpb24oICQsIHByb3RvdHlwZSApIHtcblx0XHQkLmV4dGVuZCggcHJvdG90eXBlLm9wdGlvbnMuaWNvbnMsIHtcblx0XHRcdGFjdGl2ZUhlYWRlcjogbnVsbCwgLy8gcmVtb3ZlIGRlZmF1bHQgc28gd2UgZmFsbCBiYWNrIHRvIG9sZCB2YWx1ZXNcblx0XHRcdGhlYWRlclNlbGVjdGVkOiBcInVpLWljb24tdHJpYW5nbGUtMS1zXCJcblx0XHR9KTtcblxuXHRcdHZhciBfY3JlYXRlSWNvbnMgPSBwcm90b3R5cGUuX2NyZWF0ZUljb25zO1xuXHRcdHByb3RvdHlwZS5fY3JlYXRlSWNvbnMgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmljb25zICkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMuaWNvbnMuYWN0aXZlSGVhZGVyID0gdGhpcy5vcHRpb25zLmljb25zLmFjdGl2ZUhlYWRlciB8fFxuXHRcdFx0XHRcdHRoaXMub3B0aW9ucy5pY29ucy5oZWFkZXJTZWxlY3RlZDtcblx0XHRcdH1cblx0XHRcdF9jcmVhdGVJY29ucy5jYWxsKCB0aGlzICk7XG5cdFx0fTtcblx0fSggalF1ZXJ5LCBqUXVlcnkudWkuYWNjb3JkaW9uLnByb3RvdHlwZSApICk7XG5cblx0Ly8gZXhwYW5kZWQgYWN0aXZlIG9wdGlvbiwgYWN0aXZhdGUgbWV0aG9kXG5cdChmdW5jdGlvbiggJCwgcHJvdG90eXBlICkge1xuXHRcdHByb3RvdHlwZS5hY3RpdmF0ZSA9IHByb3RvdHlwZS5fYWN0aXZhdGU7XG5cblx0XHR2YXIgX2ZpbmRBY3RpdmUgPSBwcm90b3R5cGUuX2ZpbmRBY3RpdmU7XG5cdFx0cHJvdG90eXBlLl9maW5kQWN0aXZlID0gZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdGluZGV4ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGluZGV4ICYmIHR5cGVvZiBpbmRleCAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0aW5kZXggPSB0aGlzLmhlYWRlcnMuaW5kZXgoIHRoaXMuaGVhZGVycy5maWx0ZXIoIGluZGV4ICkgKTtcblx0XHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0aW5kZXggPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIF9maW5kQWN0aXZlLmNhbGwoIHRoaXMsIGluZGV4ICk7XG5cdFx0fTtcblx0fSggalF1ZXJ5LCBqUXVlcnkudWkuYWNjb3JkaW9uLnByb3RvdHlwZSApICk7XG5cblx0Ly8gcmVzaXplIG1ldGhvZFxuXHRqUXVlcnkudWkuYWNjb3JkaW9uLnByb3RvdHlwZS5yZXNpemUgPSBqUXVlcnkudWkuYWNjb3JkaW9uLnByb3RvdHlwZS5yZWZyZXNoO1xuXG5cdC8vIGNoYW5nZSBldmVudHNcblx0KGZ1bmN0aW9uKCAkLCBwcm90b3R5cGUgKSB7XG5cdFx0JC5leHRlbmQoIHByb3RvdHlwZS5vcHRpb25zLCB7XG5cdFx0XHRjaGFuZ2U6IG51bGwsXG5cdFx0XHRjaGFuZ2VzdGFydDogbnVsbFxuXHRcdH0pO1xuXG5cdFx0dmFyIF90cmlnZ2VyID0gcHJvdG90eXBlLl90cmlnZ2VyO1xuXHRcdHByb3RvdHlwZS5fdHJpZ2dlciA9IGZ1bmN0aW9uKCB0eXBlLCBldmVudCwgZGF0YSApIHtcblx0XHRcdHZhciByZXQgPSBfdHJpZ2dlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRpZiAoICFyZXQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0eXBlID09PSBcImJlZm9yZUFjdGl2YXRlXCIgKSB7XG5cdFx0XHRcdHJldCA9IF90cmlnZ2VyLmNhbGwoIHRoaXMsIFwiY2hhbmdlc3RhcnRcIiwgZXZlbnQsIHtcblx0XHRcdFx0XHRvbGRIZWFkZXI6IGRhdGEub2xkSGVhZGVyLFxuXHRcdFx0XHRcdG9sZENvbnRlbnQ6IGRhdGEub2xkUGFuZWwsXG5cdFx0XHRcdFx0bmV3SGVhZGVyOiBkYXRhLm5ld0hlYWRlcixcblx0XHRcdFx0XHRuZXdDb250ZW50OiBkYXRhLm5ld1BhbmVsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJhY3RpdmF0ZVwiICkge1xuXHRcdFx0XHRyZXQgPSBfdHJpZ2dlci5jYWxsKCB0aGlzLCBcImNoYW5nZVwiLCBldmVudCwge1xuXHRcdFx0XHRcdG9sZEhlYWRlcjogZGF0YS5vbGRIZWFkZXIsXG5cdFx0XHRcdFx0b2xkQ29udGVudDogZGF0YS5vbGRQYW5lbCxcblx0XHRcdFx0XHRuZXdIZWFkZXI6IGRhdGEubmV3SGVhZGVyLFxuXHRcdFx0XHRcdG5ld0NvbnRlbnQ6IGRhdGEubmV3UGFuZWxcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH07XG5cdH0oIGpRdWVyeSwgalF1ZXJ5LnVpLmFjY29yZGlvbi5wcm90b3R5cGUgKSApO1xuXG5cdC8vIGFuaW1hdGVkIG9wdGlvblxuXHQvLyBOT1RFOiB0aGlzIG9ubHkgcHJvdmlkZXMgc3VwcG9ydCBmb3IgXCJzbGlkZVwiLCBcImJvdW5jZXNsaWRlXCIsIGFuZCBlYXNpbmdzXG5cdC8vIG5vdCB0aGUgZnVsbCAkLnVpLmFjY29yZGlvbi5hbmltYXRpb25zIEFQSVxuXHQoZnVuY3Rpb24oICQsIHByb3RvdHlwZSApIHtcblx0XHQkLmV4dGVuZCggcHJvdG90eXBlLm9wdGlvbnMsIHtcblx0XHRcdGFuaW1hdGU6IG51bGwsXG5cdFx0XHRhbmltYXRlZDogXCJzbGlkZVwiXG5cdFx0fSk7XG5cblx0XHR2YXIgX2NyZWF0ZSA9IHByb3RvdHlwZS5fY3JlYXRlO1xuXHRcdHByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0XHRcdGlmICggb3B0aW9ucy5hbmltYXRlID09PSBudWxsICkge1xuXHRcdFx0XHRpZiAoICFvcHRpb25zLmFuaW1hdGVkICkge1xuXHRcdFx0XHRcdG9wdGlvbnMuYW5pbWF0ZSA9IGZhbHNlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBvcHRpb25zLmFuaW1hdGVkID09PSBcInNsaWRlXCIgKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5hbmltYXRlID0gMzAwO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBvcHRpb25zLmFuaW1hdGVkID09PSBcImJvdW5jZXNsaWRlXCIgKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5hbmltYXRlID0ge1xuXHRcdFx0XHRcdFx0ZHVyYXRpb246IDIwMCxcblx0XHRcdFx0XHRcdGRvd246IHtcblx0XHRcdFx0XHRcdFx0ZWFzaW5nOiBcImVhc2VPdXRCb3VuY2VcIixcblx0XHRcdFx0XHRcdFx0ZHVyYXRpb246IDEwMDBcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG9wdGlvbnMuYW5pbWF0ZSA9IG9wdGlvbnMuYW5pbWF0ZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0X2NyZWF0ZS5jYWxsKCB0aGlzICk7XG5cdFx0fTtcblx0fSggalF1ZXJ5LCBqUXVlcnkudWkuYWNjb3JkaW9uLnByb3RvdHlwZSApICk7XG59XG5cbn0pKCBqUXVlcnkgKTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4vLyB1c2VkIHRvIHByZXZlbnQgcmFjZSBjb25kaXRpb25zIHdpdGggcmVtb3RlIGRhdGEgc291cmNlc1xudmFyIHJlcXVlc3RJbmRleCA9IDA7XG5cbiQud2lkZ2V0KCBcInVpLmF1dG9jb21wbGV0ZVwiLCB7XG5cdHZlcnNpb246IFwiMS45LjJcIixcblx0ZGVmYXVsdEVsZW1lbnQ6IFwiPGlucHV0PlwiLFxuXHRvcHRpb25zOiB7XG5cdFx0YXBwZW5kVG86IFwiYm9keVwiLFxuXHRcdGF1dG9Gb2N1czogZmFsc2UsXG5cdFx0ZGVsYXk6IDMwMCxcblx0XHRtaW5MZW5ndGg6IDEsXG5cdFx0cG9zaXRpb246IHtcblx0XHRcdG15OiBcImxlZnQgdG9wXCIsXG5cdFx0XHRhdDogXCJsZWZ0IGJvdHRvbVwiLFxuXHRcdFx0Y29sbGlzaW9uOiBcIm5vbmVcIlxuXHRcdH0sXG5cdFx0c291cmNlOiBudWxsLFxuXG5cdFx0Ly8gY2FsbGJhY2tzXG5cdFx0Y2hhbmdlOiBudWxsLFxuXHRcdGNsb3NlOiBudWxsLFxuXHRcdGZvY3VzOiBudWxsLFxuXHRcdG9wZW46IG51bGwsXG5cdFx0cmVzcG9uc2U6IG51bGwsXG5cdFx0c2VhcmNoOiBudWxsLFxuXHRcdHNlbGVjdDogbnVsbFxuXHR9LFxuXG5cdHBlbmRpbmc6IDAsXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gU29tZSBicm93c2VycyBvbmx5IHJlcGVhdCBrZXlkb3duIGV2ZW50cywgbm90IGtleXByZXNzIGV2ZW50cyxcblx0XHQvLyBzbyB3ZSB1c2UgdGhlIHN1cHByZXNzS2V5UHJlc3MgZmxhZyB0byBkZXRlcm1pbmUgaWYgd2UndmUgYWxyZWFkeVxuXHRcdC8vIGhhbmRsZWQgdGhlIGtleWRvd24gZXZlbnQuICM3MjY5XG5cdFx0Ly8gVW5mb3J0dW5hdGVseSB0aGUgY29kZSBmb3IgJiBpbiBrZXlwcmVzcyBpcyB0aGUgc2FtZSBhcyB0aGUgdXAgYXJyb3csXG5cdFx0Ly8gc28gd2UgdXNlIHRoZSBzdXBwcmVzc0tleVByZXNzUmVwZWF0IGZsYWcgdG8gYXZvaWQgaGFuZGxpbmcga2V5cHJlc3Ncblx0XHQvLyBldmVudHMgd2hlbiB3ZSBrbm93IHRoZSBrZXlkb3duIGV2ZW50IHdhcyB1c2VkIHRvIG1vZGlmeSB0aGVcblx0XHQvLyBzZWFyY2ggdGVybS4gIzc3OTlcblx0XHR2YXIgc3VwcHJlc3NLZXlQcmVzcywgc3VwcHJlc3NLZXlQcmVzc1JlcGVhdCwgc3VwcHJlc3NJbnB1dDtcblxuXHRcdHRoaXMuaXNNdWx0aUxpbmUgPSB0aGlzLl9pc011bHRpTGluZSgpO1xuXHRcdHRoaXMudmFsdWVNZXRob2QgPSB0aGlzLmVsZW1lbnRbIHRoaXMuZWxlbWVudC5pcyggXCJpbnB1dCx0ZXh0YXJlYVwiICkgPyBcInZhbFwiIDogXCJ0ZXh0XCIgXTtcblx0XHR0aGlzLmlzTmV3TWVudSA9IHRydWU7XG5cblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1hdXRvY29tcGxldGUtaW5wdXRcIiApXG5cdFx0XHQuYXR0ciggXCJhdXRvY29tcGxldGVcIiwgXCJvZmZcIiApO1xuXG5cdFx0dGhpcy5fb24oIHRoaXMuZWxlbWVudCwge1xuXHRcdFx0a2V5ZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuZWxlbWVudC5wcm9wKCBcInJlYWRPbmx5XCIgKSApIHtcblx0XHRcdFx0XHRzdXBwcmVzc0tleVByZXNzID0gdHJ1ZTtcblx0XHRcdFx0XHRzdXBwcmVzc0lucHV0ID0gdHJ1ZTtcblx0XHRcdFx0XHRzdXBwcmVzc0tleVByZXNzUmVwZWF0ID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdXBwcmVzc0tleVByZXNzID0gZmFsc2U7XG5cdFx0XHRcdHN1cHByZXNzSW5wdXQgPSBmYWxzZTtcblx0XHRcdFx0c3VwcHJlc3NLZXlQcmVzc1JlcGVhdCA9IGZhbHNlO1xuXHRcdFx0XHR2YXIga2V5Q29kZSA9ICQudWkua2V5Q29kZTtcblx0XHRcdFx0c3dpdGNoKCBldmVudC5rZXlDb2RlICkge1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuUEFHRV9VUDpcblx0XHRcdFx0XHRzdXBwcmVzc0tleVByZXNzID0gdHJ1ZTtcblx0XHRcdFx0XHR0aGlzLl9tb3ZlKCBcInByZXZpb3VzUGFnZVwiLCBldmVudCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuUEFHRV9ET1dOOlxuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMuX21vdmUoIFwibmV4dFBhZ2VcIiwgZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLlVQOlxuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMuX2tleUV2ZW50KCBcInByZXZpb3VzXCIsIGV2ZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2Uga2V5Q29kZS5ET1dOOlxuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMuX2tleUV2ZW50KCBcIm5leHRcIiwgZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLkVOVEVSOlxuXHRcdFx0XHRjYXNlIGtleUNvZGUuTlVNUEFEX0VOVEVSOlxuXHRcdFx0XHRcdC8vIHdoZW4gbWVudSBpcyBvcGVuIGFuZCBoYXMgZm9jdXNcblx0XHRcdFx0XHRpZiAoIHRoaXMubWVudS5hY3RpdmUgKSB7XG5cdFx0XHRcdFx0XHQvLyAjNjA1NSAtIE9wZXJhIHN0aWxsIGFsbG93cyB0aGUga2V5cHJlc3MgdG8gb2NjdXJcblx0XHRcdFx0XHRcdC8vIHdoaWNoIGNhdXNlcyBmb3JtcyB0byBzdWJtaXRcblx0XHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdHRoaXMubWVudS5zZWxlY3QoIGV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuVEFCOlxuXHRcdFx0XHRcdGlmICggdGhpcy5tZW51LmFjdGl2ZSApIHtcblx0XHRcdFx0XHRcdHRoaXMubWVudS5zZWxlY3QoIGV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuRVNDQVBFOlxuXHRcdFx0XHRcdGlmICggdGhpcy5tZW51LmVsZW1lbnQuaXMoIFwiOnZpc2libGVcIiApICkge1xuXHRcdFx0XHRcdFx0dGhpcy5fdmFsdWUoIHRoaXMudGVybSApO1xuXHRcdFx0XHRcdFx0dGhpcy5jbG9zZSggZXZlbnQgKTtcblx0XHRcdFx0XHRcdC8vIERpZmZlcmVudCBicm93c2VycyBoYXZlIGRpZmZlcmVudCBkZWZhdWx0IGJlaGF2aW9yIGZvciBlc2NhcGVcblx0XHRcdFx0XHRcdC8vIFNpbmdsZSBwcmVzcyBjYW4gbWVhbiB1bmRvIG9yIGNsZWFyXG5cdFx0XHRcdFx0XHQvLyBEb3VibGUgcHJlc3MgaW4gSUUgbWVhbnMgY2xlYXIgdGhlIHdob2xlIGZvcm1cblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHN1cHByZXNzS2V5UHJlc3NSZXBlYXQgPSB0cnVlO1xuXHRcdFx0XHRcdC8vIHNlYXJjaCB0aW1lb3V0IHNob3VsZCBiZSB0cmlnZ2VyZWQgYmVmb3JlIHRoZSBpbnB1dCB2YWx1ZSBpcyBjaGFuZ2VkXG5cdFx0XHRcdFx0dGhpcy5fc2VhcmNoVGltZW91dCggZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGtleXByZXNzOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggc3VwcHJlc3NLZXlQcmVzcyApIHtcblx0XHRcdFx0XHRzdXBwcmVzc0tleVByZXNzID0gZmFsc2U7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBzdXBwcmVzc0tleVByZXNzUmVwZWF0ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlcGxpY2F0ZSBzb21lIGtleSBoYW5kbGVycyB0byBhbGxvdyB0aGVtIHRvIHJlcGVhdCBpbiBGaXJlZm94IGFuZCBPcGVyYVxuXHRcdFx0XHR2YXIga2V5Q29kZSA9ICQudWkua2V5Q29kZTtcblx0XHRcdFx0c3dpdGNoKCBldmVudC5rZXlDb2RlICkge1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuUEFHRV9VUDpcblx0XHRcdFx0XHR0aGlzLl9tb3ZlKCBcInByZXZpb3VzUGFnZVwiLCBldmVudCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIGtleUNvZGUuUEFHRV9ET1dOOlxuXHRcdFx0XHRcdHRoaXMuX21vdmUoIFwibmV4dFBhZ2VcIiwgZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBrZXlDb2RlLlVQOlxuXHRcdFx0XHRcdHRoaXMuX2tleUV2ZW50KCBcInByZXZpb3VzXCIsIGV2ZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2Uga2V5Q29kZS5ET1dOOlxuXHRcdFx0XHRcdHRoaXMuX2tleUV2ZW50KCBcIm5leHRcIiwgZXZlbnQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGlucHV0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggc3VwcHJlc3NJbnB1dCApIHtcblx0XHRcdFx0XHRzdXBwcmVzc0lucHV0ID0gZmFsc2U7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fc2VhcmNoVGltZW91dCggZXZlbnQgKTtcblx0XHRcdH0sXG5cdFx0XHRmb2N1czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuc2VsZWN0ZWRJdGVtID0gbnVsbDtcblx0XHRcdFx0dGhpcy5wcmV2aW91cyA9IHRoaXMuX3ZhbHVlKCk7XG5cdFx0XHR9LFxuXHRcdFx0Ymx1cjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuY2FuY2VsQmx1ciApIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5jYW5jZWxCbHVyO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNsZWFyVGltZW91dCggdGhpcy5zZWFyY2hpbmcgKTtcblx0XHRcdFx0dGhpcy5jbG9zZSggZXZlbnQgKTtcblx0XHRcdFx0dGhpcy5fY2hhbmdlKCBldmVudCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5faW5pdFNvdXJjZSgpO1xuXHRcdHRoaXMubWVudSA9ICQoIFwiPHVsPlwiIClcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1hdXRvY29tcGxldGVcIiApXG5cdFx0XHQuYXBwZW5kVG8oIHRoaXMuZG9jdW1lbnQuZmluZCggdGhpcy5vcHRpb25zLmFwcGVuZFRvIHx8IFwiYm9keVwiIClbIDAgXSApXG5cdFx0XHQubWVudSh7XG5cdFx0XHRcdC8vIGN1c3RvbSBrZXkgaGFuZGxpbmcgZm9yIG5vd1xuXHRcdFx0XHRpbnB1dDogJCgpLFxuXHRcdFx0XHQvLyBkaXNhYmxlIEFSSUEgc3VwcG9ydCwgdGhlIGxpdmUgcmVnaW9uIHRha2VzIGNhcmUgb2YgdGhhdFxuXHRcdFx0XHRyb2xlOiBudWxsXG5cdFx0XHR9KVxuXHRcdFx0LnpJbmRleCggdGhpcy5lbGVtZW50LnpJbmRleCgpICsgMSApXG5cdFx0XHQuaGlkZSgpXG5cdFx0XHQuZGF0YSggXCJtZW51XCIgKTtcblxuXHRcdHRoaXMuX29uKCB0aGlzLm1lbnUuZWxlbWVudCwge1xuXHRcdFx0bW91c2Vkb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdC8vIHByZXZlbnQgbW92aW5nIGZvY3VzIG91dCBvZiB0aGUgdGV4dCBmaWVsZFxuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRcdC8vIElFIGRvZXNuJ3QgcHJldmVudCBtb3ZpbmcgZm9jdXMgZXZlbiB3aXRoIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblx0XHRcdFx0Ly8gc28gd2Ugc2V0IGEgZmxhZyB0byBrbm93IHdoZW4gd2Ugc2hvdWxkIGlnbm9yZSB0aGUgYmx1ciBldmVudFxuXHRcdFx0XHR0aGlzLmNhbmNlbEJsdXIgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5jYW5jZWxCbHVyO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBjbGlja2luZyBvbiB0aGUgc2Nyb2xsYmFyIGNhdXNlcyBmb2N1cyB0byBzaGlmdCB0byB0aGUgYm9keVxuXHRcdFx0XHQvLyBidXQgd2UgY2FuJ3QgZGV0ZWN0IGEgbW91c2V1cCBvciBhIGNsaWNrIGltbWVkaWF0ZWx5IGFmdGVyd2FyZFxuXHRcdFx0XHQvLyBzbyB3ZSBoYXZlIHRvIHRyYWNrIHRoZSBuZXh0IG1vdXNlZG93biBhbmQgY2xvc2UgdGhlIG1lbnUgaWZcblx0XHRcdFx0Ly8gdGhlIHVzZXIgY2xpY2tzIHNvbWV3aGVyZSBvdXRzaWRlIG9mIHRoZSBhdXRvY29tcGxldGVcblx0XHRcdFx0dmFyIG1lbnVFbGVtZW50ID0gdGhpcy5tZW51LmVsZW1lbnRbIDAgXTtcblx0XHRcdFx0aWYgKCAhJCggZXZlbnQudGFyZ2V0ICkuY2xvc2VzdCggXCIudWktbWVudS1pdGVtXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0dGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHRcdFx0XHR0aGlzLmRvY3VtZW50Lm9uZSggXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGV2ZW50LnRhcmdldCAhPT0gdGhhdC5lbGVtZW50WyAwIF0gJiZcblx0XHRcdFx0XHRcdFx0XHRcdGV2ZW50LnRhcmdldCAhPT0gbWVudUVsZW1lbnQgJiZcblx0XHRcdFx0XHRcdFx0XHRcdCEkLmNvbnRhaW5zKCBtZW51RWxlbWVudCwgZXZlbnQudGFyZ2V0ICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhhdC5jbG9zZSgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdG1lbnVmb2N1czogZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcblx0XHRcdFx0Ly8gIzcwMjQgLSBQcmV2ZW50IGFjY2lkZW50YWwgYWN0aXZhdGlvbiBvZiBtZW51IGl0ZW1zIGluIEZpcmVmb3hcblx0XHRcdFx0aWYgKCB0aGlzLmlzTmV3TWVudSApIHtcblx0XHRcdFx0XHR0aGlzLmlzTmV3TWVudSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmICggZXZlbnQub3JpZ2luYWxFdmVudCAmJiAvXm1vdXNlLy50ZXN0KCBldmVudC5vcmlnaW5hbEV2ZW50LnR5cGUgKSApIHtcblx0XHRcdFx0XHRcdHRoaXMubWVudS5ibHVyKCk7XG5cblx0XHRcdFx0XHRcdHRoaXMuZG9jdW1lbnQub25lKCBcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0JCggZXZlbnQudGFyZ2V0ICkudHJpZ2dlciggZXZlbnQub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBiYWNrIGNvbXBhdCBmb3IgX3JlbmRlckl0ZW0gdXNpbmcgaXRlbS5hdXRvY29tcGxldGUsIHZpYSAjNzgxMFxuXHRcdFx0XHQvLyBUT0RPIHJlbW92ZSB0aGUgZmFsbGJhY2ssIHNlZSAjODE1NlxuXHRcdFx0XHR2YXIgaXRlbSA9IHVpLml0ZW0uZGF0YSggXCJ1aS1hdXRvY29tcGxldGUtaXRlbVwiICkgfHwgdWkuaXRlbS5kYXRhKCBcIml0ZW0uYXV0b2NvbXBsZXRlXCIgKTtcblx0XHRcdFx0aWYgKCBmYWxzZSAhPT0gdGhpcy5fdHJpZ2dlciggXCJmb2N1c1wiLCBldmVudCwgeyBpdGVtOiBpdGVtIH0gKSApIHtcblx0XHRcdFx0XHQvLyB1c2UgdmFsdWUgdG8gbWF0Y2ggd2hhdCB3aWxsIGVuZCB1cCBpbiB0aGUgaW5wdXQsIGlmIGl0IHdhcyBhIGtleSBldmVudFxuXHRcdFx0XHRcdGlmICggZXZlbnQub3JpZ2luYWxFdmVudCAmJiAvXmtleS8udGVzdCggZXZlbnQub3JpZ2luYWxFdmVudC50eXBlICkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl92YWx1ZSggaXRlbS52YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBOb3JtYWxseSB0aGUgaW5wdXQgaXMgcG9wdWxhdGVkIHdpdGggdGhlIGl0ZW0ncyB2YWx1ZSBhcyB0aGVcblx0XHRcdFx0XHQvLyBtZW51IGlzIG5hdmlnYXRlZCwgY2F1c2luZyBzY3JlZW4gcmVhZGVycyB0byBub3RpY2UgYSBjaGFuZ2UgYW5kXG5cdFx0XHRcdFx0Ly8gYW5ub3VuY2UgdGhlIGl0ZW0uIFNpbmNlIHRoZSBmb2N1cyBldmVudCB3YXMgY2FuY2VsZWQsIHRoaXMgZG9lc24ndFxuXHRcdFx0XHRcdC8vIGhhcHBlbiwgc28gd2UgdXBkYXRlIHRoZSBsaXZlIHJlZ2lvbiBzbyB0aGF0IHNjcmVlbiByZWFkZXJzIGNhblxuXHRcdFx0XHRcdC8vIHN0aWxsIG5vdGljZSB0aGUgY2hhbmdlIGFuZCBhbm5vdW5jZSBpdC5cblx0XHRcdFx0XHR0aGlzLmxpdmVSZWdpb24udGV4dCggaXRlbS52YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0bWVudXNlbGVjdDogZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcblx0XHRcdFx0Ly8gYmFjayBjb21wYXQgZm9yIF9yZW5kZXJJdGVtIHVzaW5nIGl0ZW0uYXV0b2NvbXBsZXRlLCB2aWEgIzc4MTBcblx0XHRcdFx0Ly8gVE9ETyByZW1vdmUgdGhlIGZhbGxiYWNrLCBzZWUgIzgxNTZcblx0XHRcdFx0dmFyIGl0ZW0gPSB1aS5pdGVtLmRhdGEoIFwidWktYXV0b2NvbXBsZXRlLWl0ZW1cIiApIHx8IHVpLml0ZW0uZGF0YSggXCJpdGVtLmF1dG9jb21wbGV0ZVwiICksXG5cdFx0XHRcdFx0cHJldmlvdXMgPSB0aGlzLnByZXZpb3VzO1xuXG5cdFx0XHRcdC8vIG9ubHkgdHJpZ2dlciB3aGVuIGZvY3VzIHdhcyBsb3N0IChjbGljayBvbiBtZW51KVxuXHRcdFx0XHRpZiAoIHRoaXMuZWxlbWVudFswXSAhPT0gdGhpcy5kb2N1bWVudFswXS5hY3RpdmVFbGVtZW50ICkge1xuXHRcdFx0XHRcdHRoaXMuZWxlbWVudC5mb2N1cygpO1xuXHRcdFx0XHRcdHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcblx0XHRcdFx0XHQvLyAjNjEwOSAtIElFIHRyaWdnZXJzIHR3byBmb2N1cyBldmVudHMgYW5kIHRoZSBzZWNvbmRcblx0XHRcdFx0XHQvLyBpcyBhc3luY2hyb25vdXMsIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHByZXZpb3VzXG5cdFx0XHRcdFx0Ly8gdGVybSBzeW5jaHJvbm91c2x5IGFuZCBhc3luY2hyb25vdXNseSA6LShcblx0XHRcdFx0XHR0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcblx0XHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWRJdGVtID0gaXRlbTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZmFsc2UgIT09IHRoaXMuX3RyaWdnZXIoIFwic2VsZWN0XCIsIGV2ZW50LCB7IGl0ZW06IGl0ZW0gfSApICkge1xuXHRcdFx0XHRcdHRoaXMuX3ZhbHVlKCBpdGVtLnZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gcmVzZXQgdGhlIHRlcm0gYWZ0ZXIgdGhlIHNlbGVjdCBldmVudFxuXHRcdFx0XHQvLyB0aGlzIGFsbG93cyBjdXN0b20gc2VsZWN0IGhhbmRsaW5nIHRvIHdvcmsgcHJvcGVybHlcblx0XHRcdFx0dGhpcy50ZXJtID0gdGhpcy5fdmFsdWUoKTtcblxuXHRcdFx0XHR0aGlzLmNsb3NlKCBldmVudCApO1xuXHRcdFx0XHR0aGlzLnNlbGVjdGVkSXRlbSA9IGl0ZW07XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLmxpdmVSZWdpb24gPSAkKCBcIjxzcGFuPlwiLCB7XG5cdFx0XHRcdHJvbGU6IFwic3RhdHVzXCIsXG5cdFx0XHRcdFwiYXJpYS1saXZlXCI6IFwicG9saXRlXCJcblx0XHRcdH0pXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktaGVscGVyLWhpZGRlbi1hY2Nlc3NpYmxlXCIgKVxuXHRcdFx0Lmluc2VydEFmdGVyKCB0aGlzLmVsZW1lbnQgKTtcblxuXHRcdGlmICggJC5mbi5iZ2lmcmFtZSApIHtcblx0XHRcdHRoaXMubWVudS5lbGVtZW50LmJnaWZyYW1lKCk7XG5cdFx0fVxuXG5cdFx0Ly8gdHVybmluZyBvZmYgYXV0b2NvbXBsZXRlIHByZXZlbnRzIHRoZSBicm93c2VyIGZyb20gcmVtZW1iZXJpbmcgdGhlXG5cdFx0Ly8gdmFsdWUgd2hlbiBuYXZpZ2F0aW5nIHRocm91Z2ggaGlzdG9yeSwgc28gd2UgcmUtZW5hYmxlIGF1dG9jb21wbGV0ZVxuXHRcdC8vIGlmIHRoZSBwYWdlIGlzIHVubG9hZGVkIGJlZm9yZSB0aGUgd2lkZ2V0IGlzIGRlc3Ryb3llZC4gIzc3OTBcblx0XHR0aGlzLl9vbiggdGhpcy53aW5kb3csIHtcblx0XHRcdGJlZm9yZXVubG9hZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyKCBcImF1dG9jb21wbGV0ZVwiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdGNsZWFyVGltZW91dCggdGhpcy5zZWFyY2hpbmcgKTtcblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1hdXRvY29tcGxldGUtaW5wdXRcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhdXRvY29tcGxldGVcIiApO1xuXHRcdHRoaXMubWVudS5lbGVtZW50LnJlbW92ZSgpO1xuXHRcdHRoaXMubGl2ZVJlZ2lvbi5yZW1vdmUoKTtcblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXHRcdGlmICgga2V5ID09PSBcInNvdXJjZVwiICkge1xuXHRcdFx0dGhpcy5faW5pdFNvdXJjZSgpO1xuXHRcdH1cblx0XHRpZiAoIGtleSA9PT0gXCJhcHBlbmRUb1wiICkge1xuXHRcdFx0dGhpcy5tZW51LmVsZW1lbnQuYXBwZW5kVG8oIHRoaXMuZG9jdW1lbnQuZmluZCggdmFsdWUgfHwgXCJib2R5XCIgKVswXSApO1xuXHRcdH1cblx0XHRpZiAoIGtleSA9PT0gXCJkaXNhYmxlZFwiICYmIHZhbHVlICYmIHRoaXMueGhyICkge1xuXHRcdFx0dGhpcy54aHIuYWJvcnQoKTtcblx0XHR9XG5cdH0sXG5cblx0X2lzTXVsdGlMaW5lOiBmdW5jdGlvbigpIHtcblx0XHQvLyBUZXh0YXJlYXMgYXJlIGFsd2F5cyBtdWx0aS1saW5lXG5cdFx0aWYgKCB0aGlzLmVsZW1lbnQuaXMoIFwidGV4dGFyZWFcIiApICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdC8vIElucHV0cyBhcmUgYWx3YXlzIHNpbmdsZS1saW5lLCBldmVuIGlmIGluc2lkZSBhIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50XG5cdFx0Ly8gSUUgYWxzbyB0cmVhdHMgaW5wdXRzIGFzIGNvbnRlbnRFZGl0YWJsZVxuXHRcdGlmICggdGhpcy5lbGVtZW50LmlzKCBcImlucHV0XCIgKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0Ly8gQWxsIG90aGVyIGVsZW1lbnQgdHlwZXMgYXJlIGRldGVybWluZWQgYnkgd2hldGhlciBvciBub3QgdGhleSdyZSBjb250ZW50RWRpdGFibGVcblx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LnByb3AoIFwiaXNDb250ZW50RWRpdGFibGVcIiApO1xuXHR9LFxuXG5cdF9pbml0U291cmNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJyYXksIHVybCxcblx0XHRcdHRoYXQgPSB0aGlzO1xuXHRcdGlmICggJC5pc0FycmF5KHRoaXMub3B0aW9ucy5zb3VyY2UpICkge1xuXHRcdFx0YXJyYXkgPSB0aGlzLm9wdGlvbnMuc291cmNlO1xuXHRcdFx0dGhpcy5zb3VyY2UgPSBmdW5jdGlvbiggcmVxdWVzdCwgcmVzcG9uc2UgKSB7XG5cdFx0XHRcdHJlc3BvbnNlKCAkLnVpLmF1dG9jb21wbGV0ZS5maWx0ZXIoIGFycmF5LCByZXF1ZXN0LnRlcm0gKSApO1xuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdGhpcy5vcHRpb25zLnNvdXJjZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHVybCA9IHRoaXMub3B0aW9ucy5zb3VyY2U7XG5cdFx0XHR0aGlzLnNvdXJjZSA9IGZ1bmN0aW9uKCByZXF1ZXN0LCByZXNwb25zZSApIHtcblx0XHRcdFx0aWYgKCB0aGF0LnhociApIHtcblx0XHRcdFx0XHR0aGF0Lnhoci5hYm9ydCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoYXQueGhyID0gJC5hamF4KHtcblx0XHRcdFx0XHR1cmw6IHVybCxcblx0XHRcdFx0XHRkYXRhOiByZXF1ZXN0LFxuXHRcdFx0XHRcdGRhdGFUeXBlOiBcImpzb25cIixcblx0XHRcdFx0XHRzdWNjZXNzOiBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlKCBkYXRhICk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRlcnJvcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSggW10gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zb3VyY2UgPSB0aGlzLm9wdGlvbnMuc291cmNlO1xuXHRcdH1cblx0fSxcblxuXHRfc2VhcmNoVGltZW91dDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGNsZWFyVGltZW91dCggdGhpcy5zZWFyY2hpbmcgKTtcblx0XHR0aGlzLnNlYXJjaGluZyA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gb25seSBzZWFyY2ggaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkXG5cdFx0XHRpZiAoIHRoaXMudGVybSAhPT0gdGhpcy5fdmFsdWUoKSApIHtcblx0XHRcdFx0dGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuXHRcdFx0XHR0aGlzLnNlYXJjaCggbnVsbCwgZXZlbnQgKTtcblx0XHRcdH1cblx0XHR9LCB0aGlzLm9wdGlvbnMuZGVsYXkgKTtcblx0fSxcblxuXHRzZWFyY2g6IGZ1bmN0aW9uKCB2YWx1ZSwgZXZlbnQgKSB7XG5cdFx0dmFsdWUgPSB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiB0aGlzLl92YWx1ZSgpO1xuXG5cdFx0Ly8gYWx3YXlzIHNhdmUgdGhlIGFjdHVhbCB2YWx1ZSwgbm90IHRoZSBvbmUgcGFzc2VkIGFzIGFuIGFyZ3VtZW50XG5cdFx0dGhpcy50ZXJtID0gdGhpcy5fdmFsdWUoKTtcblxuXHRcdGlmICggdmFsdWUubGVuZ3RoIDwgdGhpcy5vcHRpb25zLm1pbkxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmNsb3NlKCBldmVudCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5fdHJpZ2dlciggXCJzZWFyY2hcIiwgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX3NlYXJjaCggdmFsdWUgKTtcblx0fSxcblxuXHRfc2VhcmNoOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dGhpcy5wZW5kaW5nKys7XG5cdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKCBcInVpLWF1dG9jb21wbGV0ZS1sb2FkaW5nXCIgKTtcblx0XHR0aGlzLmNhbmNlbFNlYXJjaCA9IGZhbHNlO1xuXG5cdFx0dGhpcy5zb3VyY2UoIHsgdGVybTogdmFsdWUgfSwgdGhpcy5fcmVzcG9uc2UoKSApO1xuXHR9LFxuXG5cdF9yZXNwb25zZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0aW5kZXggPSArK3JlcXVlc3RJbmRleDtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggY29udGVudCApIHtcblx0XHRcdGlmICggaW5kZXggPT09IHJlcXVlc3RJbmRleCApIHtcblx0XHRcdFx0dGhhdC5fX3Jlc3BvbnNlKCBjb250ZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRoYXQucGVuZGluZy0tO1xuXHRcdFx0aWYgKCAhdGhhdC5wZW5kaW5nICkge1xuXHRcdFx0XHR0aGF0LmVsZW1lbnQucmVtb3ZlQ2xhc3MoIFwidWktYXV0b2NvbXBsZXRlLWxvYWRpbmdcIiApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0sXG5cblx0X19yZXNwb25zZTogZnVuY3Rpb24oIGNvbnRlbnQgKSB7XG5cdFx0aWYgKCBjb250ZW50ICkge1xuXHRcdFx0Y29udGVudCA9IHRoaXMuX25vcm1hbGl6ZSggY29udGVudCApO1xuXHRcdH1cblx0XHR0aGlzLl90cmlnZ2VyKCBcInJlc3BvbnNlXCIsIG51bGwsIHsgY29udGVudDogY29udGVudCB9ICk7XG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVkICYmIGNvbnRlbnQgJiYgY29udGVudC5sZW5ndGggJiYgIXRoaXMuY2FuY2VsU2VhcmNoICkge1xuXHRcdFx0dGhpcy5fc3VnZ2VzdCggY29udGVudCApO1xuXHRcdFx0dGhpcy5fdHJpZ2dlciggXCJvcGVuXCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gdXNlIC5fY2xvc2UoKSBpbnN0ZWFkIG9mIC5jbG9zZSgpIHNvIHdlIGRvbid0IGNhbmNlbCBmdXR1cmUgc2VhcmNoZXNcblx0XHRcdHRoaXMuX2Nsb3NlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdGNsb3NlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dGhpcy5jYW5jZWxTZWFyY2ggPSB0cnVlO1xuXHRcdHRoaXMuX2Nsb3NlKCBldmVudCApO1xuXHR9LFxuXG5cdF9jbG9zZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggdGhpcy5tZW51LmVsZW1lbnQuaXMoIFwiOnZpc2libGVcIiApICkge1xuXHRcdFx0dGhpcy5tZW51LmVsZW1lbnQuaGlkZSgpO1xuXHRcdFx0dGhpcy5tZW51LmJsdXIoKTtcblx0XHRcdHRoaXMuaXNOZXdNZW51ID0gdHJ1ZTtcblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiY2xvc2VcIiwgZXZlbnQgKTtcblx0XHR9XG5cdH0sXG5cblx0X2NoYW5nZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggdGhpcy5wcmV2aW91cyAhPT0gdGhpcy5fdmFsdWUoKSApIHtcblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiY2hhbmdlXCIsIGV2ZW50LCB7IGl0ZW06IHRoaXMuc2VsZWN0ZWRJdGVtIH0gKTtcblx0XHR9XG5cdH0sXG5cblx0X25vcm1hbGl6ZTogZnVuY3Rpb24oIGl0ZW1zICkge1xuXHRcdC8vIGFzc3VtZSBhbGwgaXRlbXMgaGF2ZSB0aGUgcmlnaHQgZm9ybWF0IHdoZW4gdGhlIGZpcnN0IGl0ZW0gaXMgY29tcGxldGVcblx0XHRpZiAoIGl0ZW1zLmxlbmd0aCAmJiBpdGVtc1swXS5sYWJlbCAmJiBpdGVtc1swXS52YWx1ZSApIHtcblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9XG5cdFx0cmV0dXJuICQubWFwKCBpdGVtcywgZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGxhYmVsOiBpdGVtLFxuXHRcdFx0XHRcdHZhbHVlOiBpdGVtXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJC5leHRlbmQoe1xuXHRcdFx0XHRsYWJlbDogaXRlbS5sYWJlbCB8fCBpdGVtLnZhbHVlLFxuXHRcdFx0XHR2YWx1ZTogaXRlbS52YWx1ZSB8fCBpdGVtLmxhYmVsXG5cdFx0XHR9LCBpdGVtICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X3N1Z2dlc3Q6IGZ1bmN0aW9uKCBpdGVtcyApIHtcblx0XHR2YXIgdWwgPSB0aGlzLm1lbnUuZWxlbWVudFxuXHRcdFx0LmVtcHR5KClcblx0XHRcdC56SW5kZXgoIHRoaXMuZWxlbWVudC56SW5kZXgoKSArIDEgKTtcblx0XHR0aGlzLl9yZW5kZXJNZW51KCB1bCwgaXRlbXMgKTtcblx0XHR0aGlzLm1lbnUucmVmcmVzaCgpO1xuXG5cdFx0Ly8gc2l6ZSBhbmQgcG9zaXRpb24gbWVudVxuXHRcdHVsLnNob3coKTtcblx0XHR0aGlzLl9yZXNpemVNZW51KCk7XG5cdFx0dWwucG9zaXRpb24oICQuZXh0ZW5kKHtcblx0XHRcdG9mOiB0aGlzLmVsZW1lbnRcblx0XHR9LCB0aGlzLm9wdGlvbnMucG9zaXRpb24gKSk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5hdXRvRm9jdXMgKSB7XG5cdFx0XHR0aGlzLm1lbnUubmV4dCgpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVzaXplTWVudTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHVsID0gdGhpcy5tZW51LmVsZW1lbnQ7XG5cdFx0dWwub3V0ZXJXaWR0aCggTWF0aC5tYXgoXG5cdFx0XHQvLyBGaXJlZm94IHdyYXBzIGxvbmcgdGV4dCAocG9zc2libHkgYSByb3VuZGluZyBidWcpXG5cdFx0XHQvLyBzbyB3ZSBhZGQgMXB4IHRvIGF2b2lkIHRoZSB3cmFwcGluZyAoIzc1MTMpXG5cdFx0XHR1bC53aWR0aCggXCJcIiApLm91dGVyV2lkdGgoKSArIDEsXG5cdFx0XHR0aGlzLmVsZW1lbnQub3V0ZXJXaWR0aCgpXG5cdFx0KSApO1xuXHR9LFxuXG5cdF9yZW5kZXJNZW51OiBmdW5jdGlvbiggdWwsIGl0ZW1zICkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHQkLmVhY2goIGl0ZW1zLCBmdW5jdGlvbiggaW5kZXgsIGl0ZW0gKSB7XG5cdFx0XHR0aGF0Ll9yZW5kZXJJdGVtRGF0YSggdWwsIGl0ZW0gKTtcblx0XHR9KTtcblx0fSxcblxuXHRfcmVuZGVySXRlbURhdGE6IGZ1bmN0aW9uKCB1bCwgaXRlbSApIHtcblx0XHRyZXR1cm4gdGhpcy5fcmVuZGVySXRlbSggdWwsIGl0ZW0gKS5kYXRhKCBcInVpLWF1dG9jb21wbGV0ZS1pdGVtXCIsIGl0ZW0gKTtcblx0fSxcblxuXHRfcmVuZGVySXRlbTogZnVuY3Rpb24oIHVsLCBpdGVtICkge1xuXHRcdHJldHVybiAkKCBcIjxsaT5cIiApXG5cdFx0XHQuYXBwZW5kKCAkKCBcIjxhPlwiICkudGV4dCggaXRlbS5sYWJlbCApIClcblx0XHRcdC5hcHBlbmRUbyggdWwgKTtcblx0fSxcblxuXHRfbW92ZTogZnVuY3Rpb24oIGRpcmVjdGlvbiwgZXZlbnQgKSB7XG5cdFx0aWYgKCAhdGhpcy5tZW51LmVsZW1lbnQuaXMoIFwiOnZpc2libGVcIiApICkge1xuXHRcdFx0dGhpcy5zZWFyY2goIG51bGwsIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggdGhpcy5tZW51LmlzRmlyc3RJdGVtKCkgJiYgL15wcmV2aW91cy8udGVzdCggZGlyZWN0aW9uICkgfHxcblx0XHRcdFx0dGhpcy5tZW51LmlzTGFzdEl0ZW0oKSAmJiAvXm5leHQvLnRlc3QoIGRpcmVjdGlvbiApICkge1xuXHRcdFx0dGhpcy5fdmFsdWUoIHRoaXMudGVybSApO1xuXHRcdFx0dGhpcy5tZW51LmJsdXIoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5tZW51WyBkaXJlY3Rpb24gXSggZXZlbnQgKTtcblx0fSxcblxuXHR3aWRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1lbnUuZWxlbWVudDtcblx0fSxcblxuXHRfdmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlTWV0aG9kLmFwcGx5KCB0aGlzLmVsZW1lbnQsIGFyZ3VtZW50cyApO1xuXHR9LFxuXG5cdF9rZXlFdmVudDogZnVuY3Rpb24oIGtleUV2ZW50LCBldmVudCApIHtcblx0XHRpZiAoICF0aGlzLmlzTXVsdGlMaW5lIHx8IHRoaXMubWVudS5lbGVtZW50LmlzKCBcIjp2aXNpYmxlXCIgKSApIHtcblx0XHRcdHRoaXMuX21vdmUoIGtleUV2ZW50LCBldmVudCApO1xuXG5cdFx0XHQvLyBwcmV2ZW50cyBtb3ZpbmcgY3Vyc29yIHRvIGJlZ2lubmluZy9lbmQgb2YgdGhlIHRleHQgZmllbGQgaW4gc29tZSBicm93c2Vyc1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4kLmV4dGVuZCggJC51aS5hdXRvY29tcGxldGUsIHtcblx0ZXNjYXBlUmVnZXg6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gdmFsdWUucmVwbGFjZSgvW1xcLVxcW1xcXXt9KCkqKz8uLFxcXFxcXF4kfCNcXHNdL2csIFwiXFxcXCQmXCIpO1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKGFycmF5LCB0ZXJtKSB7XG5cdFx0dmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKCAkLnVpLmF1dG9jb21wbGV0ZS5lc2NhcGVSZWdleCh0ZXJtKSwgXCJpXCIgKTtcblx0XHRyZXR1cm4gJC5ncmVwKCBhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHJldHVybiBtYXRjaGVyLnRlc3QoIHZhbHVlLmxhYmVsIHx8IHZhbHVlLnZhbHVlIHx8IHZhbHVlICk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5cbi8vIGxpdmUgcmVnaW9uIGV4dGVuc2lvbiwgYWRkaW5nIGEgYG1lc3NhZ2VzYCBvcHRpb25cbi8vIE5PVEU6IFRoaXMgaXMgYW4gZXhwZXJpbWVudGFsIEFQSS4gV2UgYXJlIHN0aWxsIGludmVzdGlnYXRpbmdcbi8vIGEgZnVsbCBzb2x1dGlvbiBmb3Igc3RyaW5nIG1hbmlwdWxhdGlvbiBhbmQgaW50ZXJuYXRpb25hbGl6YXRpb24uXG4kLndpZGdldCggXCJ1aS5hdXRvY29tcGxldGVcIiwgJC51aS5hdXRvY29tcGxldGUsIHtcblx0b3B0aW9uczoge1xuXHRcdG1lc3NhZ2VzOiB7XG5cdFx0XHRub1Jlc3VsdHM6IFwiTm8gc2VhcmNoIHJlc3VsdHMuXCIsXG5cdFx0XHRyZXN1bHRzOiBmdW5jdGlvbiggYW1vdW50ICkge1xuXHRcdFx0XHRyZXR1cm4gYW1vdW50ICsgKCBhbW91bnQgPiAxID8gXCIgcmVzdWx0cyBhcmVcIiA6IFwiIHJlc3VsdCBpc1wiICkgK1xuXHRcdFx0XHRcdFwiIGF2YWlsYWJsZSwgdXNlIHVwIGFuZCBkb3duIGFycm93IGtleXMgdG8gbmF2aWdhdGUuXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9fcmVzcG9uc2U6IGZ1bmN0aW9uKCBjb250ZW50ICkge1xuXHRcdHZhciBtZXNzYWdlO1xuXHRcdHRoaXMuX3N1cGVyQXBwbHkoIGFyZ3VtZW50cyApO1xuXHRcdGlmICggdGhpcy5vcHRpb25zLmRpc2FibGVkIHx8IHRoaXMuY2FuY2VsU2VhcmNoICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIGNvbnRlbnQgJiYgY29udGVudC5sZW5ndGggKSB7XG5cdFx0XHRtZXNzYWdlID0gdGhpcy5vcHRpb25zLm1lc3NhZ2VzLnJlc3VsdHMoIGNvbnRlbnQubGVuZ3RoICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lc3NhZ2UgPSB0aGlzLm9wdGlvbnMubWVzc2FnZXMubm9SZXN1bHRzO1xuXHRcdH1cblx0XHR0aGlzLmxpdmVSZWdpb24udGV4dCggbWVzc2FnZSApO1xuXHR9XG59KTtcblxuXG59KCBqUXVlcnkgKSk7XG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxudmFyIGxhc3RBY3RpdmUsIHN0YXJ0WFBvcywgc3RhcnRZUG9zLCBjbGlja0RyYWdnZWQsXG5cdGJhc2VDbGFzc2VzID0gXCJ1aS1idXR0b24gdWktd2lkZ2V0IHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbFwiLFxuXHRzdGF0ZUNsYXNzZXMgPSBcInVpLXN0YXRlLWhvdmVyIHVpLXN0YXRlLWFjdGl2ZSBcIixcblx0dHlwZUNsYXNzZXMgPSBcInVpLWJ1dHRvbi1pY29ucy1vbmx5IHVpLWJ1dHRvbi1pY29uLW9ubHkgdWktYnV0dG9uLXRleHQtaWNvbnMgdWktYnV0dG9uLXRleHQtaWNvbi1wcmltYXJ5IHVpLWJ1dHRvbi10ZXh0LWljb24tc2Vjb25kYXJ5IHVpLWJ1dHRvbi10ZXh0LW9ubHlcIixcblx0Zm9ybVJlc2V0SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBidXR0b25zID0gJCggdGhpcyApLmZpbmQoIFwiOnVpLWJ1dHRvblwiICk7XG5cdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdGJ1dHRvbnMuYnV0dG9uKCBcInJlZnJlc2hcIiApO1xuXHRcdH0sIDEgKTtcblx0fSxcblx0cmFkaW9Hcm91cCA9IGZ1bmN0aW9uKCByYWRpbyApIHtcblx0XHR2YXIgbmFtZSA9IHJhZGlvLm5hbWUsXG5cdFx0XHRmb3JtID0gcmFkaW8uZm9ybSxcblx0XHRcdHJhZGlvcyA9ICQoIFtdICk7XG5cdFx0aWYgKCBuYW1lICkge1xuXHRcdFx0aWYgKCBmb3JtICkge1xuXHRcdFx0XHRyYWRpb3MgPSAkKCBmb3JtICkuZmluZCggXCJbbmFtZT0nXCIgKyBuYW1lICsgXCInXVwiICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyYWRpb3MgPSAkKCBcIltuYW1lPSdcIiArIG5hbWUgKyBcIiddXCIsIHJhZGlvLm93bmVyRG9jdW1lbnQgKVxuXHRcdFx0XHRcdC5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gIXRoaXMuZm9ybTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJhZGlvcztcblx0fTtcblxuJC53aWRnZXQoIFwidWkuYnV0dG9uXCIsIHtcblx0dmVyc2lvbjogXCIxLjkuMlwiLFxuXHRkZWZhdWx0RWxlbWVudDogXCI8YnV0dG9uPlwiLFxuXHRvcHRpb25zOiB7XG5cdFx0ZGlzYWJsZWQ6IG51bGwsXG5cdFx0dGV4dDogdHJ1ZSxcblx0XHRsYWJlbDogbnVsbCxcblx0XHRpY29uczoge1xuXHRcdFx0cHJpbWFyeTogbnVsbCxcblx0XHRcdHNlY29uZGFyeTogbnVsbFxuXHRcdH1cblx0fSxcblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbGVtZW50LmNsb3Nlc3QoIFwiZm9ybVwiIClcblx0XHRcdC51bmJpbmQoIFwicmVzZXRcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UgKVxuXHRcdFx0LmJpbmQoIFwicmVzZXRcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZvcm1SZXNldEhhbmRsZXIgKTtcblxuXHRcdGlmICggdHlwZW9mIHRoaXMub3B0aW9ucy5kaXNhYmxlZCAhPT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuZGlzYWJsZWQgPSAhIXRoaXMuZWxlbWVudC5wcm9wKCBcImRpc2FibGVkXCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5lbGVtZW50LnByb3AoIFwiZGlzYWJsZWRcIiwgdGhpcy5vcHRpb25zLmRpc2FibGVkICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZGV0ZXJtaW5lQnV0dG9uVHlwZSgpO1xuXHRcdHRoaXMuaGFzVGl0bGUgPSAhIXRoaXMuYnV0dG9uRWxlbWVudC5hdHRyKCBcInRpdGxlXCIgKTtcblxuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHR0b2dnbGVCdXR0b24gPSB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiB8fCB0aGlzLnR5cGUgPT09IFwicmFkaW9cIixcblx0XHRcdGFjdGl2ZUNsYXNzID0gIXRvZ2dsZUJ1dHRvbiA/IFwidWktc3RhdGUtYWN0aXZlXCIgOiBcIlwiLFxuXHRcdFx0Zm9jdXNDbGFzcyA9IFwidWktc3RhdGUtZm9jdXNcIjtcblxuXHRcdGlmICggb3B0aW9ucy5sYWJlbCA9PT0gbnVsbCApIHtcblx0XHRcdG9wdGlvbnMubGFiZWwgPSAodGhpcy50eXBlID09PSBcImlucHV0XCIgPyB0aGlzLmJ1dHRvbkVsZW1lbnQudmFsKCkgOiB0aGlzLmJ1dHRvbkVsZW1lbnQuaHRtbCgpKTtcblx0XHR9XG5cblx0XHR0aGlzLl9ob3ZlcmFibGUoIHRoaXMuYnV0dG9uRWxlbWVudCApO1xuXG5cdFx0dGhpcy5idXR0b25FbGVtZW50XG5cdFx0XHQuYWRkQ2xhc3MoIGJhc2VDbGFzc2VzIClcblx0XHRcdC5hdHRyKCBcInJvbGVcIiwgXCJidXR0b25cIiApXG5cdFx0XHQuYmluZCggXCJtb3VzZWVudGVyXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRoaXMgPT09IGxhc3RBY3RpdmUgKSB7XG5cdFx0XHRcdFx0JCggdGhpcyApLmFkZENsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQuYmluZCggXCJtb3VzZWxlYXZlXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQkKCB0aGlzICkucmVtb3ZlQ2xhc3MoIGFjdGl2ZUNsYXNzICk7XG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoIFwiY2xpY2tcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQuYmluZCggXCJmb2N1c1wiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIG5vIG5lZWQgdG8gY2hlY2sgZGlzYWJsZWQsIGZvY3VzIHdvbid0IGJlIHRyaWdnZXJlZCBhbnl3YXlcblx0XHRcdFx0dGhhdC5idXR0b25FbGVtZW50LmFkZENsYXNzKCBmb2N1c0NsYXNzICk7XG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoIFwiYmx1clwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoYXQuYnV0dG9uRWxlbWVudC5yZW1vdmVDbGFzcyggZm9jdXNDbGFzcyApO1xuXHRcdFx0fSk7XG5cblx0XHRpZiAoIHRvZ2dsZUJ1dHRvbiApIHtcblx0XHRcdHRoaXMuZWxlbWVudC5iaW5kKCBcImNoYW5nZVwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2xpY2tEcmFnZ2VkICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGF0LnJlZnJlc2goKTtcblx0XHRcdH0pO1xuXHRcdFx0Ly8gaWYgbW91c2UgbW92ZXMgYmV0d2VlbiBtb3VzZWRvd24gYW5kIG1vdXNldXAgKGRyYWcpIHNldCBjbGlja0RyYWdnZWQgZmxhZ1xuXHRcdFx0Ly8gcHJldmVudHMgaXNzdWUgd2hlcmUgYnV0dG9uIHN0YXRlIGNoYW5nZXMgYnV0IGNoZWNrYm94L3JhZGlvIGNoZWNrZWQgc3RhdGVcblx0XHRcdC8vIGRvZXMgbm90IGluIEZpcmVmb3ggKHNlZSB0aWNrZXQgIzY5NzApXG5cdFx0XHR0aGlzLmJ1dHRvbkVsZW1lbnRcblx0XHRcdFx0LmJpbmQoIFwibW91c2Vkb3duXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjbGlja0RyYWdnZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRzdGFydFhQb3MgPSBldmVudC5wYWdlWDtcblx0XHRcdFx0XHRzdGFydFlQb3MgPSBldmVudC5wYWdlWTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LmJpbmQoIFwibW91c2V1cFwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdGlmICggb3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzdGFydFhQb3MgIT09IGV2ZW50LnBhZ2VYIHx8IHN0YXJ0WVBvcyAhPT0gZXZlbnQucGFnZVkgKSB7XG5cdFx0XHRcdFx0XHRjbGlja0RyYWdnZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgKSB7XG5cdFx0XHR0aGlzLmJ1dHRvbkVsZW1lbnQuYmluZCggXCJjbGlja1wiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5kaXNhYmxlZCB8fCBjbGlja0RyYWdnZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCQoIHRoaXMgKS50b2dnbGVDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdFx0XHR0aGF0LmJ1dHRvbkVsZW1lbnQuYXR0ciggXCJhcmlhLXByZXNzZWRcIiwgdGhhdC5lbGVtZW50WzBdLmNoZWNrZWQgKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMudHlwZSA9PT0gXCJyYWRpb1wiICkge1xuXHRcdFx0dGhpcy5idXR0b25FbGVtZW50LmJpbmQoIFwiY2xpY2tcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuZGlzYWJsZWQgfHwgY2xpY2tEcmFnZ2VkICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkKCB0aGlzICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdFx0dGhhdC5idXR0b25FbGVtZW50LmF0dHIoIFwiYXJpYS1wcmVzc2VkXCIsIFwidHJ1ZVwiICk7XG5cblx0XHRcdFx0dmFyIHJhZGlvID0gdGhhdC5lbGVtZW50WyAwIF07XG5cdFx0XHRcdHJhZGlvR3JvdXAoIHJhZGlvIClcblx0XHRcdFx0XHQubm90KCByYWRpbyApXG5cdFx0XHRcdFx0Lm1hcChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiAkKCB0aGlzICkuYnV0dG9uKCBcIndpZGdldFwiIClbIDAgXTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApXG5cdFx0XHRcdFx0LmF0dHIoIFwiYXJpYS1wcmVzc2VkXCIsIFwiZmFsc2VcIiApO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudFxuXHRcdFx0XHQuYmluZCggXCJtb3VzZWRvd25cIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggb3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0JCggdGhpcyApLmFkZENsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHRcdFx0bGFzdEFjdGl2ZSA9IHRoaXM7XG5cdFx0XHRcdFx0dGhhdC5kb2N1bWVudC5vbmUoIFwibW91c2V1cFwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGxhc3RBY3RpdmUgPSBudWxsO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYmluZCggXCJtb3VzZXVwXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIG9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYmluZCggXCJrZXlkb3duXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdGlmICggb3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuU1BBQ0UgfHwgZXZlbnQua2V5Q29kZSA9PT0gJC51aS5rZXlDb2RlLkVOVEVSICkge1xuXHRcdFx0XHRcdFx0JCggdGhpcyApLmFkZENsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYmluZCggXCJrZXl1cFwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0JCggdGhpcyApLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoIHRoaXMuYnV0dG9uRWxlbWVudC5pcyhcImFcIikgKSB7XG5cdFx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudC5rZXl1cChmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdGlmICggZXZlbnQua2V5Q29kZSA9PT0gJC51aS5rZXlDb2RlLlNQQUNFICkge1xuXHRcdFx0XHRcdFx0Ly8gVE9ETyBwYXNzIHRocm91Z2ggb3JpZ2luYWwgZXZlbnQgY29ycmVjdGx5IChqdXN0IGFzIDJuZCBhcmd1bWVudCBkb2Vzbid0IHdvcmspXG5cdFx0XHRcdFx0XHQkKCB0aGlzICkuY2xpY2soKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFRPRE86IHB1bGwgb3V0ICQuV2lkZ2V0J3MgaGFuZGxpbmcgZm9yIHRoZSBkaXNhYmxlZCBvcHRpb24gaW50b1xuXHRcdC8vICQuV2lkZ2V0LnByb3RvdHlwZS5fc2V0T3B0aW9uRGlzYWJsZWQgc28gaXQncyBlYXN5IHRvIHByb3h5IGFuZCBjYW5cblx0XHQvLyBiZSBvdmVycmlkZGVuIGJ5IGluZGl2aWR1YWwgcGx1Z2luc1xuXHRcdHRoaXMuX3NldE9wdGlvbiggXCJkaXNhYmxlZFwiLCBvcHRpb25zLmRpc2FibGVkICk7XG5cdFx0dGhpcy5fcmVzZXRCdXR0b24oKTtcblx0fSxcblxuXHRfZGV0ZXJtaW5lQnV0dG9uVHlwZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFuY2VzdG9yLCBsYWJlbFNlbGVjdG9yLCBjaGVja2VkO1xuXG5cdFx0aWYgKCB0aGlzLmVsZW1lbnQuaXMoXCJbdHlwZT1jaGVja2JveF1cIikgKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSBcImNoZWNrYm94XCI7XG5cdFx0fSBlbHNlIGlmICggdGhpcy5lbGVtZW50LmlzKFwiW3R5cGU9cmFkaW9dXCIpICkge1xuXHRcdFx0dGhpcy50eXBlID0gXCJyYWRpb1wiO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMuZWxlbWVudC5pcyhcImlucHV0XCIpICkge1xuXHRcdFx0dGhpcy50eXBlID0gXCJpbnB1dFwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnR5cGUgPSBcImJ1dHRvblwiO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgfHwgdGhpcy50eXBlID09PSBcInJhZGlvXCIgKSB7XG5cdFx0XHQvLyB3ZSBkb24ndCBzZWFyY2ggYWdhaW5zdCB0aGUgZG9jdW1lbnQgaW4gY2FzZSB0aGUgZWxlbWVudFxuXHRcdFx0Ly8gaXMgZGlzY29ubmVjdGVkIGZyb20gdGhlIERPTVxuXHRcdFx0YW5jZXN0b3IgPSB0aGlzLmVsZW1lbnQucGFyZW50cygpLmxhc3QoKTtcblx0XHRcdGxhYmVsU2VsZWN0b3IgPSBcImxhYmVsW2Zvcj0nXCIgKyB0aGlzLmVsZW1lbnQuYXR0cihcImlkXCIpICsgXCInXVwiO1xuXHRcdFx0dGhpcy5idXR0b25FbGVtZW50ID0gYW5jZXN0b3IuZmluZCggbGFiZWxTZWxlY3RvciApO1xuXHRcdFx0aWYgKCAhdGhpcy5idXR0b25FbGVtZW50Lmxlbmd0aCApIHtcblx0XHRcdFx0YW5jZXN0b3IgPSBhbmNlc3Rvci5sZW5ndGggPyBhbmNlc3Rvci5zaWJsaW5ncygpIDogdGhpcy5lbGVtZW50LnNpYmxpbmdzKCk7XG5cdFx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudCA9IGFuY2VzdG9yLmZpbHRlciggbGFiZWxTZWxlY3RvciApO1xuXHRcdFx0XHRpZiAoICF0aGlzLmJ1dHRvbkVsZW1lbnQubGVuZ3RoICkge1xuXHRcdFx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudCA9IGFuY2VzdG9yLmZpbmQoIGxhYmVsU2VsZWN0b3IgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKCBcInVpLWhlbHBlci1oaWRkZW4tYWNjZXNzaWJsZVwiICk7XG5cblx0XHRcdGNoZWNrZWQgPSB0aGlzLmVsZW1lbnQuaXMoIFwiOmNoZWNrZWRcIiApO1xuXHRcdFx0aWYgKCBjaGVja2VkICkge1xuXHRcdFx0XHR0aGlzLmJ1dHRvbkVsZW1lbnQuYWRkQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudC5wcm9wKCBcImFyaWEtcHJlc3NlZFwiLCBjaGVja2VkICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblx0XHR9XG5cdH0sXG5cblx0d2lkZ2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5idXR0b25FbGVtZW50O1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1oZWxwZXItaGlkZGVuLWFjY2Vzc2libGVcIiApO1xuXHRcdHRoaXMuYnV0dG9uRWxlbWVudFxuXHRcdFx0LnJlbW92ZUNsYXNzKCBiYXNlQ2xhc3NlcyArIFwiIFwiICsgc3RhdGVDbGFzc2VzICsgXCIgXCIgKyB0eXBlQ2xhc3NlcyApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJyb2xlXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1wcmVzc2VkXCIgKVxuXHRcdFx0Lmh0bWwoIHRoaXMuYnV0dG9uRWxlbWVudC5maW5kKFwiLnVpLWJ1dHRvbi10ZXh0XCIpLmh0bWwoKSApO1xuXG5cdFx0aWYgKCAhdGhpcy5oYXNUaXRsZSApIHtcblx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudC5yZW1vdmVBdHRyKCBcInRpdGxlXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dGhpcy5fc3VwZXIoIGtleSwgdmFsdWUgKTtcblx0XHRpZiAoIGtleSA9PT0gXCJkaXNhYmxlZFwiICkge1xuXHRcdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnByb3AoIFwiZGlzYWJsZWRcIiwgdHJ1ZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnByb3AoIFwiZGlzYWJsZWRcIiwgZmFsc2UgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fcmVzZXRCdXR0b24oKTtcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHQvL1NlZSAjODIzNyAmICM4ODI4XG5cdFx0dmFyIGlzRGlzYWJsZWQgPSB0aGlzLmVsZW1lbnQuaXMoIFwiaW5wdXQsIGJ1dHRvblwiICkgPyB0aGlzLmVsZW1lbnQuaXMoIFwiOmRpc2FibGVkXCIgKSA6IHRoaXMuZWxlbWVudC5oYXNDbGFzcyggXCJ1aS1idXR0b24tZGlzYWJsZWRcIiApO1xuXG5cdFx0aWYgKCBpc0Rpc2FibGVkICE9PSB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb24oIFwiZGlzYWJsZWRcIiwgaXNEaXNhYmxlZCApO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJyYWRpb1wiICkge1xuXHRcdFx0cmFkaW9Hcm91cCggdGhpcy5lbGVtZW50WzBdICkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAkKCB0aGlzICkuaXMoIFwiOmNoZWNrZWRcIiApICkge1xuXHRcdFx0XHRcdCQoIHRoaXMgKS5idXR0b24oIFwid2lkZ2V0XCIgKVxuXHRcdFx0XHRcdFx0LmFkZENsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiIClcblx0XHRcdFx0XHRcdC5hdHRyKCBcImFyaWEtcHJlc3NlZFwiLCBcInRydWVcIiApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCQoIHRoaXMgKS5idXR0b24oIFwid2lkZ2V0XCIgKVxuXHRcdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiIClcblx0XHRcdFx0XHRcdC5hdHRyKCBcImFyaWEtcHJlc3NlZFwiLCBcImZhbHNlXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgKSB7XG5cdFx0XHRpZiAoIHRoaXMuZWxlbWVudC5pcyggXCI6Y2hlY2tlZFwiICkgKSB7XG5cdFx0XHRcdHRoaXMuYnV0dG9uRWxlbWVudFxuXHRcdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApXG5cdFx0XHRcdFx0LmF0dHIoIFwiYXJpYS1wcmVzc2VkXCIsIFwidHJ1ZVwiICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmJ1dHRvbkVsZW1lbnRcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKVxuXHRcdFx0XHRcdC5hdHRyKCBcImFyaWEtcHJlc3NlZFwiLCBcImZhbHNlXCIgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0QnV0dG9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMubGFiZWwgKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC52YWwoIHRoaXMub3B0aW9ucy5sYWJlbCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgYnV0dG9uRWxlbWVudCA9IHRoaXMuYnV0dG9uRWxlbWVudC5yZW1vdmVDbGFzcyggdHlwZUNsYXNzZXMgKSxcblx0XHRcdGJ1dHRvblRleHQgPSAkKCBcIjxzcGFuPjwvc3Bhbj5cIiwgdGhpcy5kb2N1bWVudFswXSApXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1idXR0b24tdGV4dFwiIClcblx0XHRcdFx0Lmh0bWwoIHRoaXMub3B0aW9ucy5sYWJlbCApXG5cdFx0XHRcdC5hcHBlbmRUbyggYnV0dG9uRWxlbWVudC5lbXB0eSgpIClcblx0XHRcdFx0LnRleHQoKSxcblx0XHRcdGljb25zID0gdGhpcy5vcHRpb25zLmljb25zLFxuXHRcdFx0bXVsdGlwbGVJY29ucyA9IGljb25zLnByaW1hcnkgJiYgaWNvbnMuc2Vjb25kYXJ5LFxuXHRcdFx0YnV0dG9uQ2xhc3NlcyA9IFtdO1xuXG5cdFx0aWYgKCBpY29ucy5wcmltYXJ5IHx8IGljb25zLnNlY29uZGFyeSApIHtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnRleHQgKSB7XG5cdFx0XHRcdGJ1dHRvbkNsYXNzZXMucHVzaCggXCJ1aS1idXR0b24tdGV4dC1pY29uXCIgKyAoIG11bHRpcGxlSWNvbnMgPyBcInNcIiA6ICggaWNvbnMucHJpbWFyeSA/IFwiLXByaW1hcnlcIiA6IFwiLXNlY29uZGFyeVwiICkgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGljb25zLnByaW1hcnkgKSB7XG5cdFx0XHRcdGJ1dHRvbkVsZW1lbnQucHJlcGVuZCggXCI8c3BhbiBjbGFzcz0ndWktYnV0dG9uLWljb24tcHJpbWFyeSB1aS1pY29uIFwiICsgaWNvbnMucHJpbWFyeSArIFwiJz48L3NwYW4+XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpY29ucy5zZWNvbmRhcnkgKSB7XG5cdFx0XHRcdGJ1dHRvbkVsZW1lbnQuYXBwZW5kKCBcIjxzcGFuIGNsYXNzPSd1aS1idXR0b24taWNvbi1zZWNvbmRhcnkgdWktaWNvbiBcIiArIGljb25zLnNlY29uZGFyeSArIFwiJz48L3NwYW4+XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhdGhpcy5vcHRpb25zLnRleHQgKSB7XG5cdFx0XHRcdGJ1dHRvbkNsYXNzZXMucHVzaCggbXVsdGlwbGVJY29ucyA/IFwidWktYnV0dG9uLWljb25zLW9ubHlcIiA6IFwidWktYnV0dG9uLWljb24tb25seVwiICk7XG5cblx0XHRcdFx0aWYgKCAhdGhpcy5oYXNUaXRsZSApIHtcblx0XHRcdFx0XHRidXR0b25FbGVtZW50LmF0dHIoIFwidGl0bGVcIiwgJC50cmltKCBidXR0b25UZXh0ICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRidXR0b25DbGFzc2VzLnB1c2goIFwidWktYnV0dG9uLXRleHQtb25seVwiICk7XG5cdFx0fVxuXHRcdGJ1dHRvbkVsZW1lbnQuYWRkQ2xhc3MoIGJ1dHRvbkNsYXNzZXMuam9pbiggXCIgXCIgKSApO1xuXHR9XG59KTtcblxuJC53aWRnZXQoIFwidWkuYnV0dG9uc2V0XCIsIHtcblx0dmVyc2lvbjogXCIxLjkuMlwiLFxuXHRvcHRpb25zOiB7XG5cdFx0aXRlbXM6IFwiYnV0dG9uLCBpbnB1dFt0eXBlPWJ1dHRvbl0sIGlucHV0W3R5cGU9c3VibWl0XSwgaW5wdXRbdHlwZT1yZXNldF0sIGlucHV0W3R5cGU9Y2hlY2tib3hdLCBpbnB1dFt0eXBlPXJhZGlvXSwgYSwgOmRhdGEoYnV0dG9uKVwiXG5cdH0sXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKCBcInVpLWJ1dHRvbnNldFwiICk7XG5cdH0sXG5cblx0X2luaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVmcmVzaCgpO1xuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdGlmICgga2V5ID09PSBcImRpc2FibGVkXCIgKSB7XG5cdFx0XHR0aGlzLmJ1dHRvbnMuYnV0dG9uKCBcIm9wdGlvblwiLCBrZXksIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3VwZXIoIGtleSwgdmFsdWUgKTtcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcnRsID0gdGhpcy5lbGVtZW50LmNzcyggXCJkaXJlY3Rpb25cIiApID09PSBcInJ0bFwiO1xuXG5cdFx0dGhpcy5idXR0b25zID0gdGhpcy5lbGVtZW50LmZpbmQoIHRoaXMub3B0aW9ucy5pdGVtcyApXG5cdFx0XHQuZmlsdGVyKCBcIjp1aS1idXR0b25cIiApXG5cdFx0XHRcdC5idXR0b24oIFwicmVmcmVzaFwiIClcblx0XHRcdC5lbmQoKVxuXHRcdFx0Lm5vdCggXCI6dWktYnV0dG9uXCIgKVxuXHRcdFx0XHQuYnV0dG9uKClcblx0XHRcdC5lbmQoKVxuXHRcdFx0Lm1hcChmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICQoIHRoaXMgKS5idXR0b24oIFwid2lkZ2V0XCIgKVsgMCBdO1xuXHRcdFx0fSlcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWNvcm5lci1hbGwgdWktY29ybmVyLWxlZnQgdWktY29ybmVyLXJpZ2h0XCIgKVxuXHRcdFx0XHQuZmlsdGVyKCBcIjpmaXJzdFwiIClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIHJ0bCA/IFwidWktY29ybmVyLXJpZ2h0XCIgOiBcInVpLWNvcm5lci1sZWZ0XCIgKVxuXHRcdFx0XHQuZW5kKClcblx0XHRcdFx0LmZpbHRlciggXCI6bGFzdFwiIClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIHJ0bCA/IFwidWktY29ybmVyLWxlZnRcIiA6IFwidWktY29ybmVyLXJpZ2h0XCIgKVxuXHRcdFx0XHQuZW5kKClcblx0XHRcdC5lbmQoKTtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKCBcInVpLWJ1dHRvbnNldFwiICk7XG5cdFx0dGhpcy5idXR0b25zXG5cdFx0XHQubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJCggdGhpcyApLmJ1dHRvbiggXCJ3aWRnZXRcIiApWyAwIF07XG5cdFx0XHR9KVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktY29ybmVyLWxlZnQgdWktY29ybmVyLXJpZ2h0XCIgKVxuXHRcdFx0LmVuZCgpXG5cdFx0XHQuYnV0dG9uKCBcImRlc3Ryb3lcIiApO1xuXHR9XG59KTtcblxufSggalF1ZXJ5ICkgKTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLmV4dGVuZCgkLnVpLCB7IGRhdGVwaWNrZXI6IHsgdmVyc2lvbjogXCIxLjkuMlwiIH0gfSk7XG5cbnZhciBQUk9QX05BTUUgPSAnZGF0ZXBpY2tlcic7XG52YXIgZHB1dWlkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG52YXIgaW5zdEFjdGl2ZTtcblxuLyogRGF0ZSBwaWNrZXIgbWFuYWdlci5cbiAgIFVzZSB0aGUgc2luZ2xldG9uIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MsICQuZGF0ZXBpY2tlciwgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgZGF0ZSBwaWNrZXIuXG4gICBTZXR0aW5ncyBmb3IgKGdyb3VwcyBvZikgZGF0ZSBwaWNrZXJzIGFyZSBtYWludGFpbmVkIGluIGFuIGluc3RhbmNlIG9iamVjdCxcbiAgIGFsbG93aW5nIG11bHRpcGxlIGRpZmZlcmVudCBzZXR0aW5ncyBvbiB0aGUgc2FtZSBwYWdlLiAqL1xuXG5mdW5jdGlvbiBEYXRlcGlja2VyKCkge1xuXHR0aGlzLmRlYnVnID0gZmFsc2U7IC8vIENoYW5nZSB0aGlzIHRvIHRydWUgdG8gc3RhcnQgZGVidWdnaW5nXG5cdHRoaXMuX2N1ckluc3QgPSBudWxsOyAvLyBUaGUgY3VycmVudCBpbnN0YW5jZSBpbiB1c2Vcblx0dGhpcy5fa2V5RXZlbnQgPSBmYWxzZTsgLy8gSWYgdGhlIGxhc3QgZXZlbnQgd2FzIGEga2V5IGV2ZW50XG5cdHRoaXMuX2Rpc2FibGVkSW5wdXRzID0gW107IC8vIExpc3Qgb2YgZGF0ZSBwaWNrZXIgaW5wdXRzIHRoYXQgaGF2ZSBiZWVuIGRpc2FibGVkXG5cdHRoaXMuX2RhdGVwaWNrZXJTaG93aW5nID0gZmFsc2U7IC8vIFRydWUgaWYgdGhlIHBvcHVwIHBpY2tlciBpcyBzaG93aW5nICwgZmFsc2UgaWYgbm90XG5cdHRoaXMuX2luRGlhbG9nID0gZmFsc2U7IC8vIFRydWUgaWYgc2hvd2luZyB3aXRoaW4gYSBcImRpYWxvZ1wiLCBmYWxzZSBpZiBub3Rcblx0dGhpcy5fbWFpbkRpdklkID0gJ3VpLWRhdGVwaWNrZXItZGl2JzsgLy8gVGhlIElEIG9mIHRoZSBtYWluIGRhdGVwaWNrZXIgZGl2aXNpb25cblx0dGhpcy5faW5saW5lQ2xhc3MgPSAndWktZGF0ZXBpY2tlci1pbmxpbmUnOyAvLyBUaGUgbmFtZSBvZiB0aGUgaW5saW5lIG1hcmtlciBjbGFzc1xuXHR0aGlzLl9hcHBlbmRDbGFzcyA9ICd1aS1kYXRlcGlja2VyLWFwcGVuZCc7IC8vIFRoZSBuYW1lIG9mIHRoZSBhcHBlbmQgbWFya2VyIGNsYXNzXG5cdHRoaXMuX3RyaWdnZXJDbGFzcyA9ICd1aS1kYXRlcGlja2VyLXRyaWdnZXInOyAvLyBUaGUgbmFtZSBvZiB0aGUgdHJpZ2dlciBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fZGlhbG9nQ2xhc3MgPSAndWktZGF0ZXBpY2tlci1kaWFsb2cnOyAvLyBUaGUgbmFtZSBvZiB0aGUgZGlhbG9nIG1hcmtlciBjbGFzc1xuXHR0aGlzLl9kaXNhYmxlQ2xhc3MgPSAndWktZGF0ZXBpY2tlci1kaXNhYmxlZCc7IC8vIFRoZSBuYW1lIG9mIHRoZSBkaXNhYmxlZCBjb3ZlcmluZyBtYXJrZXIgY2xhc3Ncblx0dGhpcy5fdW5zZWxlY3RhYmxlQ2xhc3MgPSAndWktZGF0ZXBpY2tlci11bnNlbGVjdGFibGUnOyAvLyBUaGUgbmFtZSBvZiB0aGUgdW5zZWxlY3RhYmxlIGNlbGwgbWFya2VyIGNsYXNzXG5cdHRoaXMuX2N1cnJlbnRDbGFzcyA9ICd1aS1kYXRlcGlja2VyLWN1cnJlbnQtZGF5JzsgLy8gVGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgZGF5IG1hcmtlciBjbGFzc1xuXHR0aGlzLl9kYXlPdmVyQ2xhc3MgPSAndWktZGF0ZXBpY2tlci1kYXlzLWNlbGwtb3Zlcic7IC8vIFRoZSBuYW1lIG9mIHRoZSBkYXkgaG92ZXIgbWFya2VyIGNsYXNzXG5cdHRoaXMucmVnaW9uYWwgPSBbXTsgLy8gQXZhaWxhYmxlIHJlZ2lvbmFsIHNldHRpbmdzLCBpbmRleGVkIGJ5IGxhbmd1YWdlIGNvZGVcblx0dGhpcy5yZWdpb25hbFsnJ10gPSB7IC8vIERlZmF1bHQgcmVnaW9uYWwgc2V0dGluZ3Ncblx0XHRjbG9zZVRleHQ6ICdEb25lJywgLy8gRGlzcGxheSB0ZXh0IGZvciBjbG9zZSBsaW5rXG5cdFx0cHJldlRleHQ6ICdQcmV2JywgLy8gRGlzcGxheSB0ZXh0IGZvciBwcmV2aW91cyBtb250aCBsaW5rXG5cdFx0bmV4dFRleHQ6ICdOZXh0JywgLy8gRGlzcGxheSB0ZXh0IGZvciBuZXh0IG1vbnRoIGxpbmtcblx0XHRjdXJyZW50VGV4dDogJ1RvZGF5JywgLy8gRGlzcGxheSB0ZXh0IGZvciBjdXJyZW50IG1vbnRoIGxpbmtcblx0XHRtb250aE5hbWVzOiBbJ0phbnVhcnknLCdGZWJydWFyeScsJ01hcmNoJywnQXByaWwnLCdNYXknLCdKdW5lJyxcblx0XHRcdCdKdWx5JywnQXVndXN0JywnU2VwdGVtYmVyJywnT2N0b2JlcicsJ05vdmVtYmVyJywnRGVjZW1iZXInXSwgLy8gTmFtZXMgb2YgbW9udGhzIGZvciBkcm9wLWRvd24gYW5kIGZvcm1hdHRpbmdcblx0XHRtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXSwgLy8gRm9yIGZvcm1hdHRpbmdcblx0XHRkYXlOYW1lczogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddLCAvLyBGb3IgZm9ybWF0dGluZ1xuXHRcdGRheU5hbWVzU2hvcnQ6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sIC8vIEZvciBmb3JtYXR0aW5nXG5cdFx0ZGF5TmFtZXNNaW46IFsnU3UnLCdNbycsJ1R1JywnV2UnLCdUaCcsJ0ZyJywnU2EnXSwgLy8gQ29sdW1uIGhlYWRpbmdzIGZvciBkYXlzIHN0YXJ0aW5nIGF0IFN1bmRheVxuXHRcdHdlZWtIZWFkZXI6ICdXaycsIC8vIENvbHVtbiBoZWFkZXIgZm9yIHdlZWsgb2YgdGhlIHllYXJcblx0XHRkYXRlRm9ybWF0OiAnbW0vZGQveXknLCAvLyBTZWUgZm9ybWF0IG9wdGlvbnMgb24gcGFyc2VEYXRlXG5cdFx0Zmlyc3REYXk6IDAsIC8vIFRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWssIFN1biA9IDAsIE1vbiA9IDEsIC4uLlxuXHRcdGlzUlRMOiBmYWxzZSwgLy8gVHJ1ZSBpZiByaWdodC10by1sZWZ0IGxhbmd1YWdlLCBmYWxzZSBpZiBsZWZ0LXRvLXJpZ2h0XG5cdFx0c2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSwgLy8gVHJ1ZSBpZiB0aGUgeWVhciBzZWxlY3QgcHJlY2VkZXMgbW9udGgsIGZhbHNlIGZvciBtb250aCB0aGVuIHllYXJcblx0XHR5ZWFyU3VmZml4OiAnJyAvLyBBZGRpdGlvbmFsIHRleHQgdG8gYXBwZW5kIHRvIHRoZSB5ZWFyIGluIHRoZSBtb250aCBoZWFkZXJzXG5cdH07XG5cdHRoaXMuX2RlZmF1bHRzID0geyAvLyBHbG9iYWwgZGVmYXVsdHMgZm9yIGFsbCB0aGUgZGF0ZSBwaWNrZXIgaW5zdGFuY2VzXG5cdFx0c2hvd09uOiAnZm9jdXMnLCAvLyAnZm9jdXMnIGZvciBwb3B1cCBvbiBmb2N1cyxcblx0XHRcdC8vICdidXR0b24nIGZvciB0cmlnZ2VyIGJ1dHRvbiwgb3IgJ2JvdGgnIGZvciBlaXRoZXJcblx0XHRzaG93QW5pbTogJ2ZhZGVJbicsIC8vIE5hbWUgb2YgalF1ZXJ5IGFuaW1hdGlvbiBmb3IgcG9wdXBcblx0XHRzaG93T3B0aW9uczoge30sIC8vIE9wdGlvbnMgZm9yIGVuaGFuY2VkIGFuaW1hdGlvbnNcblx0XHRkZWZhdWx0RGF0ZTogbnVsbCwgLy8gVXNlZCB3aGVuIGZpZWxkIGlzIGJsYW5rOiBhY3R1YWwgZGF0ZSxcblx0XHRcdC8vICsvLW51bWJlciBmb3Igb2Zmc2V0IGZyb20gdG9kYXksIG51bGwgZm9yIHRvZGF5XG5cdFx0YXBwZW5kVGV4dDogJycsIC8vIERpc3BsYXkgdGV4dCBmb2xsb3dpbmcgdGhlIGlucHV0IGJveCwgZS5nLiBzaG93aW5nIHRoZSBmb3JtYXRcblx0XHRidXR0b25UZXh0OiAnLi4uJywgLy8gVGV4dCBmb3IgdHJpZ2dlciBidXR0b25cblx0XHRidXR0b25JbWFnZTogJycsIC8vIFVSTCBmb3IgdHJpZ2dlciBidXR0b24gaW1hZ2Vcblx0XHRidXR0b25JbWFnZU9ubHk6IGZhbHNlLCAvLyBUcnVlIGlmIHRoZSBpbWFnZSBhcHBlYXJzIGFsb25lLCBmYWxzZSBpZiBpdCBhcHBlYXJzIG9uIGEgYnV0dG9uXG5cdFx0aGlkZUlmTm9QcmV2TmV4dDogZmFsc2UsIC8vIFRydWUgdG8gaGlkZSBuZXh0L3ByZXZpb3VzIG1vbnRoIGxpbmtzXG5cdFx0XHQvLyBpZiBub3QgYXBwbGljYWJsZSwgZmFsc2UgdG8ganVzdCBkaXNhYmxlIHRoZW1cblx0XHRuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0OiBmYWxzZSwgLy8gVHJ1ZSBpZiBkYXRlIGZvcm1hdHRpbmcgYXBwbGllZCB0byBwcmV2L3RvZGF5L25leHQgbGlua3Ncblx0XHRnb3RvQ3VycmVudDogZmFsc2UsIC8vIFRydWUgaWYgdG9kYXkgbGluayBnb2VzIGJhY2sgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5zdGVhZFxuXHRcdGNoYW5nZU1vbnRoOiBmYWxzZSwgLy8gVHJ1ZSBpZiBtb250aCBjYW4gYmUgc2VsZWN0ZWQgZGlyZWN0bHksIGZhbHNlIGlmIG9ubHkgcHJldi9uZXh0XG5cdFx0Y2hhbmdlWWVhcjogZmFsc2UsIC8vIFRydWUgaWYgeWVhciBjYW4gYmUgc2VsZWN0ZWQgZGlyZWN0bHksIGZhbHNlIGlmIG9ubHkgcHJldi9uZXh0XG5cdFx0eWVhclJhbmdlOiAnYy0xMDpjKzEwJywgLy8gUmFuZ2Ugb2YgeWVhcnMgdG8gZGlzcGxheSBpbiBkcm9wLWRvd24sXG5cdFx0XHQvLyBlaXRoZXIgcmVsYXRpdmUgdG8gdG9kYXkncyB5ZWFyICgtbm46K25uKSwgcmVsYXRpdmUgdG8gY3VycmVudGx5IGRpc3BsYXllZCB5ZWFyXG5cdFx0XHQvLyAoYy1ubjpjK25uKSwgYWJzb2x1dGUgKG5ubm46bm5ubiksIG9yIGEgY29tYmluYXRpb24gb2YgdGhlIGFib3ZlIChubm5uOi1uKVxuXHRcdHNob3dPdGhlck1vbnRoczogZmFsc2UsIC8vIFRydWUgdG8gc2hvdyBkYXRlcyBpbiBvdGhlciBtb250aHMsIGZhbHNlIHRvIGxlYXZlIGJsYW5rXG5cdFx0c2VsZWN0T3RoZXJNb250aHM6IGZhbHNlLCAvLyBUcnVlIHRvIGFsbG93IHNlbGVjdGlvbiBvZiBkYXRlcyBpbiBvdGhlciBtb250aHMsIGZhbHNlIGZvciB1bnNlbGVjdGFibGVcblx0XHRzaG93V2VlazogZmFsc2UsIC8vIFRydWUgdG8gc2hvdyB3ZWVrIG9mIHRoZSB5ZWFyLCBmYWxzZSB0byBub3Qgc2hvdyBpdFxuXHRcdGNhbGN1bGF0ZVdlZWs6IHRoaXMuaXNvODYwMVdlZWssIC8vIEhvdyB0byBjYWxjdWxhdGUgdGhlIHdlZWsgb2YgdGhlIHllYXIsXG5cdFx0XHQvLyB0YWtlcyBhIERhdGUgYW5kIHJldHVybnMgdGhlIG51bWJlciBvZiB0aGUgd2VlayBmb3IgaXRcblx0XHRzaG9ydFllYXJDdXRvZmY6ICcrMTAnLCAvLyBTaG9ydCB5ZWFyIHZhbHVlcyA8IHRoaXMgYXJlIGluIHRoZSBjdXJyZW50IGNlbnR1cnksXG5cdFx0XHQvLyA+IHRoaXMgYXJlIGluIHRoZSBwcmV2aW91cyBjZW50dXJ5LFxuXHRcdFx0Ly8gc3RyaW5nIHZhbHVlIHN0YXJ0aW5nIHdpdGggJysnIGZvciBjdXJyZW50IHllYXIgKyB2YWx1ZVxuXHRcdG1pbkRhdGU6IG51bGwsIC8vIFRoZSBlYXJsaWVzdCBzZWxlY3RhYmxlIGRhdGUsIG9yIG51bGwgZm9yIG5vIGxpbWl0XG5cdFx0bWF4RGF0ZTogbnVsbCwgLy8gVGhlIGxhdGVzdCBzZWxlY3RhYmxlIGRhdGUsIG9yIG51bGwgZm9yIG5vIGxpbWl0XG5cdFx0ZHVyYXRpb246ICdmYXN0JywgLy8gRHVyYXRpb24gb2YgZGlzcGxheS9jbG9zdXJlXG5cdFx0YmVmb3JlU2hvd0RheTogbnVsbCwgLy8gRnVuY3Rpb24gdGhhdCB0YWtlcyBhIGRhdGUgYW5kIHJldHVybnMgYW4gYXJyYXkgd2l0aFxuXHRcdFx0Ly8gWzBdID0gdHJ1ZSBpZiBzZWxlY3RhYmxlLCBmYWxzZSBpZiBub3QsIFsxXSA9IGN1c3RvbSBDU1MgY2xhc3MgbmFtZShzKSBvciAnJyxcblx0XHRcdC8vIFsyXSA9IGNlbGwgdGl0bGUgKG9wdGlvbmFsKSwgZS5nLiAkLmRhdGVwaWNrZXIubm9XZWVrZW5kc1xuXHRcdGJlZm9yZVNob3c6IG51bGwsIC8vIEZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gaW5wdXQgZmllbGQgYW5kXG5cdFx0XHQvLyByZXR1cm5zIGEgc2V0IG9mIGN1c3RvbSBzZXR0aW5ncyBmb3IgdGhlIGRhdGUgcGlja2VyXG5cdFx0b25TZWxlY3Q6IG51bGwsIC8vIERlZmluZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gYSBkYXRlIGlzIHNlbGVjdGVkXG5cdFx0b25DaGFuZ2VNb250aFllYXI6IG51bGwsIC8vIERlZmluZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIG1vbnRoIG9yIHllYXIgaXMgY2hhbmdlZFxuXHRcdG9uQ2xvc2U6IG51bGwsIC8vIERlZmluZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIGRhdGVwaWNrZXIgaXMgY2xvc2VkXG5cdFx0bnVtYmVyT2ZNb250aHM6IDEsIC8vIE51bWJlciBvZiBtb250aHMgdG8gc2hvdyBhdCBhIHRpbWVcblx0XHRzaG93Q3VycmVudEF0UG9zOiAwLCAvLyBUaGUgcG9zaXRpb24gaW4gbXVsdGlwZSBtb250aHMgYXQgd2hpY2ggdG8gc2hvdyB0aGUgY3VycmVudCBtb250aCAoc3RhcnRpbmcgYXQgMClcblx0XHRzdGVwTW9udGhzOiAxLCAvLyBOdW1iZXIgb2YgbW9udGhzIHRvIHN0ZXAgYmFjay9mb3J3YXJkXG5cdFx0c3RlcEJpZ01vbnRoczogMTIsIC8vIE51bWJlciBvZiBtb250aHMgdG8gc3RlcCBiYWNrL2ZvcndhcmQgZm9yIHRoZSBiaWcgbGlua3Ncblx0XHRhbHRGaWVsZDogJycsIC8vIFNlbGVjdG9yIGZvciBhbiBhbHRlcm5hdGUgZmllbGQgdG8gc3RvcmUgc2VsZWN0ZWQgZGF0ZXMgaW50b1xuXHRcdGFsdEZvcm1hdDogJycsIC8vIFRoZSBkYXRlIGZvcm1hdCB0byB1c2UgZm9yIHRoZSBhbHRlcm5hdGUgZmllbGRcblx0XHRjb25zdHJhaW5JbnB1dDogdHJ1ZSwgLy8gVGhlIGlucHV0IGlzIGNvbnN0cmFpbmVkIGJ5IHRoZSBjdXJyZW50IGRhdGUgZm9ybWF0XG5cdFx0c2hvd0J1dHRvblBhbmVsOiBmYWxzZSwgLy8gVHJ1ZSB0byBzaG93IGJ1dHRvbiBwYW5lbCwgZmFsc2UgdG8gbm90IHNob3cgaXRcblx0XHRhdXRvU2l6ZTogZmFsc2UsIC8vIFRydWUgdG8gc2l6ZSB0aGUgaW5wdXQgZm9yIHRoZSBkYXRlIGZvcm1hdCwgZmFsc2UgdG8gbGVhdmUgYXMgaXNcblx0XHRkaXNhYmxlZDogZmFsc2UgLy8gVGhlIGluaXRpYWwgZGlzYWJsZWQgc3RhdGVcblx0fTtcblx0JC5leHRlbmQodGhpcy5fZGVmYXVsdHMsIHRoaXMucmVnaW9uYWxbJyddKTtcblx0dGhpcy5kcERpdiA9IGJpbmRIb3ZlcigkKCc8ZGl2IGlkPVwiJyArIHRoaXMuX21haW5EaXZJZCArICdcIiBjbGFzcz1cInVpLWRhdGVwaWNrZXIgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWhlbHBlci1jbGVhcmZpeCB1aS1jb3JuZXItYWxsXCI+PC9kaXY+JykpO1xufVxuXG4kLmV4dGVuZChEYXRlcGlja2VyLnByb3RvdHlwZSwge1xuXHQvKiBDbGFzcyBuYW1lIGFkZGVkIHRvIGVsZW1lbnRzIHRvIGluZGljYXRlIGFscmVhZHkgY29uZmlndXJlZCB3aXRoIGEgZGF0ZSBwaWNrZXIuICovXG5cdG1hcmtlckNsYXNzTmFtZTogJ2hhc0RhdGVwaWNrZXInLFxuXG5cdC8vS2VlcCB0cmFjayBvZiB0aGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyBkaXNwbGF5ZWQgKHNlZSAjNzA0Mylcblx0bWF4Um93czogNCxcblxuXHQvKiBEZWJ1ZyBsb2dnaW5nIChpZiBlbmFibGVkKS4gKi9cblx0bG9nOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuZGVidWcpXG5cdFx0XHRjb25zb2xlLmxvZy5hcHBseSgnJywgYXJndW1lbnRzKTtcblx0fSxcblxuXHQvLyBUT0RPIHJlbmFtZSB0byBcIndpZGdldFwiIHdoZW4gc3dpdGNoaW5nIHRvIHdpZGdldCBmYWN0b3J5XG5cdF93aWRnZXREYXRlcGlja2VyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kcERpdjtcblx0fSxcblxuXHQvKiBPdmVycmlkZSB0aGUgZGVmYXVsdCBzZXR0aW5ncyBmb3IgYWxsIGluc3RhbmNlcyBvZiB0aGUgZGF0ZSBwaWNrZXIuXG5cdCAgIEBwYXJhbSAgc2V0dGluZ3MgIG9iamVjdCAtIHRoZSBuZXcgc2V0dGluZ3MgdG8gdXNlIGFzIGRlZmF1bHRzIChhbm9ueW1vdXMgb2JqZWN0KVxuXHQgICBAcmV0dXJuIHRoZSBtYW5hZ2VyIG9iamVjdCAqL1xuXHRzZXREZWZhdWx0czogZnVuY3Rpb24oc2V0dGluZ3MpIHtcblx0XHRleHRlbmRSZW1vdmUodGhpcy5fZGVmYXVsdHMsIHNldHRpbmdzIHx8IHt9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKiBBdHRhY2ggdGhlIGRhdGUgcGlja2VyIHRvIGEgalF1ZXJ5IHNlbGVjdGlvbi5cblx0ICAgQHBhcmFtICB0YXJnZXQgICAgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxuXHQgICBAcGFyYW0gIHNldHRpbmdzICBvYmplY3QgLSB0aGUgbmV3IHNldHRpbmdzIHRvIHVzZSBmb3IgdGhpcyBkYXRlIHBpY2tlciBpbnN0YW5jZSAoYW5vbnltb3VzKSAqL1xuXHRfYXR0YWNoRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBzZXR0aW5ncykge1xuXHRcdC8vIGNoZWNrIGZvciBzZXR0aW5ncyBvbiB0aGUgY29udHJvbCBpdHNlbGYgLSBpbiBuYW1lc3BhY2UgJ2RhdGU6J1xuXHRcdHZhciBpbmxpbmVTZXR0aW5ncyA9IG51bGw7XG5cdFx0Zm9yICh2YXIgYXR0ck5hbWUgaW4gdGhpcy5fZGVmYXVsdHMpIHtcblx0XHRcdHZhciBhdHRyVmFsdWUgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRlOicgKyBhdHRyTmFtZSk7XG5cdFx0XHRpZiAoYXR0clZhbHVlKSB7XG5cdFx0XHRcdGlubGluZVNldHRpbmdzID0gaW5saW5lU2V0dGluZ3MgfHwge307XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aW5saW5lU2V0dGluZ3NbYXR0ck5hbWVdID0gZXZhbChhdHRyVmFsdWUpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRpbmxpbmVTZXR0aW5nc1thdHRyTmFtZV0gPSBhdHRyVmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0dmFyIGlubGluZSA9IChub2RlTmFtZSA9PSAnZGl2JyB8fCBub2RlTmFtZSA9PSAnc3BhbicpO1xuXHRcdGlmICghdGFyZ2V0LmlkKSB7XG5cdFx0XHR0aGlzLnV1aWQgKz0gMTtcblx0XHRcdHRhcmdldC5pZCA9ICdkcCcgKyB0aGlzLnV1aWQ7XG5cdFx0fVxuXHRcdHZhciBpbnN0ID0gdGhpcy5fbmV3SW5zdCgkKHRhcmdldCksIGlubGluZSk7XG5cdFx0aW5zdC5zZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBzZXR0aW5ncyB8fCB7fSwgaW5saW5lU2V0dGluZ3MgfHwge30pO1xuXHRcdGlmIChub2RlTmFtZSA9PSAnaW5wdXQnKSB7XG5cdFx0XHR0aGlzLl9jb25uZWN0RGF0ZXBpY2tlcih0YXJnZXQsIGluc3QpO1xuXHRcdH0gZWxzZSBpZiAoaW5saW5lKSB7XG5cdFx0XHR0aGlzLl9pbmxpbmVEYXRlcGlja2VyKHRhcmdldCwgaW5zdCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvYmplY3QuICovXG5cdF9uZXdJbnN0OiBmdW5jdGlvbih0YXJnZXQsIGlubGluZSkge1xuXHRcdHZhciBpZCA9IHRhcmdldFswXS5pZC5yZXBsYWNlKC8oW15BLVphLXowLTlfLV0pL2csICdcXFxcXFxcXCQxJyk7IC8vIGVzY2FwZSBqUXVlcnkgbWV0YSBjaGFyc1xuXHRcdHJldHVybiB7aWQ6IGlkLCBpbnB1dDogdGFyZ2V0LCAvLyBhc3NvY2lhdGVkIHRhcmdldFxuXHRcdFx0c2VsZWN0ZWREYXk6IDAsIHNlbGVjdGVkTW9udGg6IDAsIHNlbGVjdGVkWWVhcjogMCwgLy8gY3VycmVudCBzZWxlY3Rpb25cblx0XHRcdGRyYXdNb250aDogMCwgZHJhd1llYXI6IDAsIC8vIG1vbnRoIGJlaW5nIGRyYXduXG5cdFx0XHRpbmxpbmU6IGlubGluZSwgLy8gaXMgZGF0ZXBpY2tlciBpbmxpbmUgb3Igbm90XG5cdFx0XHRkcERpdjogKCFpbmxpbmUgPyB0aGlzLmRwRGl2IDogLy8gcHJlc2VudGF0aW9uIGRpdlxuXHRcdFx0YmluZEhvdmVyKCQoJzxkaXYgY2xhc3M9XCInICsgdGhpcy5faW5saW5lQ2xhc3MgKyAnIHVpLWRhdGVwaWNrZXIgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWhlbHBlci1jbGVhcmZpeCB1aS1jb3JuZXItYWxsXCI+PC9kaXY+JykpKX07XG5cdH0sXG5cblx0LyogQXR0YWNoIHRoZSBkYXRlIHBpY2tlciB0byBhbiBpbnB1dCBmaWVsZC4gKi9cblx0X2Nvbm5lY3REYXRlcGlja2VyOiBmdW5jdGlvbih0YXJnZXQsIGluc3QpIHtcblx0XHR2YXIgaW5wdXQgPSAkKHRhcmdldCk7XG5cdFx0aW5zdC5hcHBlbmQgPSAkKFtdKTtcblx0XHRpbnN0LnRyaWdnZXIgPSAkKFtdKTtcblx0XHRpZiAoaW5wdXQuaGFzQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHRoaXMuX2F0dGFjaG1lbnRzKGlucHV0LCBpbnN0KTtcblx0XHRpbnB1dC5hZGRDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkua2V5ZG93bih0aGlzLl9kb0tleURvd24pLlxuXHRcdFx0a2V5cHJlc3ModGhpcy5fZG9LZXlQcmVzcykua2V5dXAodGhpcy5fZG9LZXlVcCkuXG5cdFx0XHRiaW5kKFwic2V0RGF0YS5kYXRlcGlja2VyXCIsIGZ1bmN0aW9uKGV2ZW50LCBrZXksIHZhbHVlKSB7XG5cdFx0XHRcdGluc3Quc2V0dGluZ3Nba2V5XSA9IHZhbHVlO1xuXHRcdFx0fSkuYmluZChcImdldERhdGEuZGF0ZXBpY2tlclwiLCBmdW5jdGlvbihldmVudCwga2V5KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9nZXQoaW5zdCwga2V5KTtcblx0XHRcdH0pO1xuXHRcdHRoaXMuX2F1dG9TaXplKGluc3QpO1xuXHRcdCQuZGF0YSh0YXJnZXQsIFBST1BfTkFNRSwgaW5zdCk7XG5cdFx0Ly9JZiBkaXNhYmxlZCBvcHRpb24gaXMgdHJ1ZSwgZGlzYWJsZSB0aGUgZGF0ZXBpY2tlciBvbmNlIGl0IGhhcyBiZWVuIGF0dGFjaGVkIHRvIHRoZSBpbnB1dCAoc2VlIHRpY2tldCAjNTY2NSlcblx0XHRpZiggaW5zdC5zZXR0aW5ncy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuX2Rpc2FibGVEYXRlcGlja2VyKCB0YXJnZXQgKTtcblx0XHR9XG5cdH0sXG5cblx0LyogTWFrZSBhdHRhY2htZW50cyBiYXNlZCBvbiBzZXR0aW5ncy4gKi9cblx0X2F0dGFjaG1lbnRzOiBmdW5jdGlvbihpbnB1dCwgaW5zdCkge1xuXHRcdHZhciBhcHBlbmRUZXh0ID0gdGhpcy5fZ2V0KGluc3QsICdhcHBlbmRUZXh0Jyk7XG5cdFx0dmFyIGlzUlRMID0gdGhpcy5fZ2V0KGluc3QsICdpc1JUTCcpO1xuXHRcdGlmIChpbnN0LmFwcGVuZClcblx0XHRcdGluc3QuYXBwZW5kLnJlbW92ZSgpO1xuXHRcdGlmIChhcHBlbmRUZXh0KSB7XG5cdFx0XHRpbnN0LmFwcGVuZCA9ICQoJzxzcGFuIGNsYXNzPVwiJyArIHRoaXMuX2FwcGVuZENsYXNzICsgJ1wiPicgKyBhcHBlbmRUZXh0ICsgJzwvc3Bhbj4nKTtcblx0XHRcdGlucHV0W2lzUlRMID8gJ2JlZm9yZScgOiAnYWZ0ZXInXShpbnN0LmFwcGVuZCk7XG5cdFx0fVxuXHRcdGlucHV0LnVuYmluZCgnZm9jdXMnLCB0aGlzLl9zaG93RGF0ZXBpY2tlcik7XG5cdFx0aWYgKGluc3QudHJpZ2dlcilcblx0XHRcdGluc3QudHJpZ2dlci5yZW1vdmUoKTtcblx0XHR2YXIgc2hvd09uID0gdGhpcy5fZ2V0KGluc3QsICdzaG93T24nKTtcblx0XHRpZiAoc2hvd09uID09ICdmb2N1cycgfHwgc2hvd09uID09ICdib3RoJykgLy8gcG9wLXVwIGRhdGUgcGlja2VyIHdoZW4gaW4gdGhlIG1hcmtlZCBmaWVsZFxuXHRcdFx0aW5wdXQuZm9jdXModGhpcy5fc2hvd0RhdGVwaWNrZXIpO1xuXHRcdGlmIChzaG93T24gPT0gJ2J1dHRvbicgfHwgc2hvd09uID09ICdib3RoJykgeyAvLyBwb3AtdXAgZGF0ZSBwaWNrZXIgd2hlbiBidXR0b24gY2xpY2tlZFxuXHRcdFx0dmFyIGJ1dHRvblRleHQgPSB0aGlzLl9nZXQoaW5zdCwgJ2J1dHRvblRleHQnKTtcblx0XHRcdHZhciBidXR0b25JbWFnZSA9IHRoaXMuX2dldChpbnN0LCAnYnV0dG9uSW1hZ2UnKTtcblx0XHRcdGluc3QudHJpZ2dlciA9ICQodGhpcy5fZ2V0KGluc3QsICdidXR0b25JbWFnZU9ubHknKSA/XG5cdFx0XHRcdCQoJzxpbWcvPicpLmFkZENsYXNzKHRoaXMuX3RyaWdnZXJDbGFzcykuXG5cdFx0XHRcdFx0YXR0cih7IHNyYzogYnV0dG9uSW1hZ2UsIGFsdDogYnV0dG9uVGV4dCwgdGl0bGU6IGJ1dHRvblRleHQgfSkgOlxuXHRcdFx0XHQkKCc8YnV0dG9uIHR5cGU9XCJidXR0b25cIj48L2J1dHRvbj4nKS5hZGRDbGFzcyh0aGlzLl90cmlnZ2VyQ2xhc3MpLlxuXHRcdFx0XHRcdGh0bWwoYnV0dG9uSW1hZ2UgPT0gJycgPyBidXR0b25UZXh0IDogJCgnPGltZy8+JykuYXR0cihcblx0XHRcdFx0XHR7IHNyYzpidXR0b25JbWFnZSwgYWx0OmJ1dHRvblRleHQsIHRpdGxlOmJ1dHRvblRleHQgfSkpKTtcblx0XHRcdGlucHV0W2lzUlRMID8gJ2JlZm9yZScgOiAnYWZ0ZXInXShpbnN0LnRyaWdnZXIpO1xuXHRcdFx0aW5zdC50cmlnZ2VyLmNsaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiAkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCA9PSBpbnB1dFswXSlcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdGVsc2UgaWYgKCQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgJiYgJC5kYXRlcGlja2VyLl9sYXN0SW5wdXQgIT0gaW5wdXRbMF0pIHtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zaG93RGF0ZXBpY2tlcihpbnB1dFswXSk7XG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fc2hvd0RhdGVwaWNrZXIoaW5wdXRbMF0pO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0LyogQXBwbHkgdGhlIG1heGltdW0gbGVuZ3RoIGZvciB0aGUgZGF0ZSBmb3JtYXQuICovXG5cdF9hdXRvU2l6ZTogZnVuY3Rpb24oaW5zdCkge1xuXHRcdGlmICh0aGlzLl9nZXQoaW5zdCwgJ2F1dG9TaXplJykgJiYgIWluc3QuaW5saW5lKSB7XG5cdFx0XHR2YXIgZGF0ZSA9IG5ldyBEYXRlKDIwMDksIDEyIC0gMSwgMjApOyAvLyBFbnN1cmUgZG91YmxlIGRpZ2l0c1xuXHRcdFx0dmFyIGRhdGVGb3JtYXQgPSB0aGlzLl9nZXQoaW5zdCwgJ2RhdGVGb3JtYXQnKTtcblx0XHRcdGlmIChkYXRlRm9ybWF0Lm1hdGNoKC9bRE1dLykpIHtcblx0XHRcdFx0dmFyIGZpbmRNYXggPSBmdW5jdGlvbihuYW1lcykge1xuXHRcdFx0XHRcdHZhciBtYXggPSAwO1xuXHRcdFx0XHRcdHZhciBtYXhJID0gMDtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAobmFtZXNbaV0ubGVuZ3RoID4gbWF4KSB7XG5cdFx0XHRcdFx0XHRcdG1heCA9IG5hbWVzW2ldLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0bWF4SSA9IGk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXhJO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRkYXRlLnNldE1vbnRoKGZpbmRNYXgodGhpcy5fZ2V0KGluc3QsIChkYXRlRm9ybWF0Lm1hdGNoKC9NTS8pID9cblx0XHRcdFx0XHQnbW9udGhOYW1lcycgOiAnbW9udGhOYW1lc1Nob3J0JykpKSk7XG5cdFx0XHRcdGRhdGUuc2V0RGF0ZShmaW5kTWF4KHRoaXMuX2dldChpbnN0LCAoZGF0ZUZvcm1hdC5tYXRjaCgvREQvKSA/XG5cdFx0XHRcdFx0J2RheU5hbWVzJyA6ICdkYXlOYW1lc1Nob3J0JykpKSArIDIwIC0gZGF0ZS5nZXREYXkoKSk7XG5cdFx0XHR9XG5cdFx0XHRpbnN0LmlucHV0LmF0dHIoJ3NpemUnLCB0aGlzLl9mb3JtYXREYXRlKGluc3QsIGRhdGUpLmxlbmd0aCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIEF0dGFjaCBhbiBpbmxpbmUgZGF0ZSBwaWNrZXIgdG8gYSBkaXYuICovXG5cdF9pbmxpbmVEYXRlcGlja2VyOiBmdW5jdGlvbih0YXJnZXQsIGluc3QpIHtcblx0XHR2YXIgZGl2U3BhbiA9ICQodGFyZ2V0KTtcblx0XHRpZiAoZGl2U3Bhbi5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpXG5cdFx0XHRyZXR1cm47XG5cdFx0ZGl2U3Bhbi5hZGRDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkuYXBwZW5kKGluc3QuZHBEaXYpLlxuXHRcdFx0YmluZChcInNldERhdGEuZGF0ZXBpY2tlclwiLCBmdW5jdGlvbihldmVudCwga2V5LCB2YWx1ZSl7XG5cdFx0XHRcdGluc3Quc2V0dGluZ3Nba2V5XSA9IHZhbHVlO1xuXHRcdFx0fSkuYmluZChcImdldERhdGEuZGF0ZXBpY2tlclwiLCBmdW5jdGlvbihldmVudCwga2V5KXtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2dldChpbnN0LCBrZXkpO1xuXHRcdFx0fSk7XG5cdFx0JC5kYXRhKHRhcmdldCwgUFJPUF9OQU1FLCBpbnN0KTtcblx0XHR0aGlzLl9zZXREYXRlKGluc3QsIHRoaXMuX2dldERlZmF1bHREYXRlKGluc3QpLCB0cnVlKTtcblx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHRcdHRoaXMuX3VwZGF0ZUFsdGVybmF0ZShpbnN0KTtcblx0XHQvL0lmIGRpc2FibGVkIG9wdGlvbiBpcyB0cnVlLCBkaXNhYmxlIHRoZSBkYXRlcGlja2VyIGJlZm9yZSBzaG93aW5nIGl0IChzZWUgdGlja2V0ICM1NjY1KVxuXHRcdGlmKCBpbnN0LnNldHRpbmdzLmRpc2FibGVkICkge1xuXHRcdFx0dGhpcy5fZGlzYWJsZURhdGVwaWNrZXIoIHRhcmdldCApO1xuXHRcdH1cblx0XHQvLyBTZXQgZGlzcGxheTpibG9jayBpbiBwbGFjZSBvZiBpbnN0LmRwRGl2LnNob3coKSB3aGljaCB3b24ndCB3b3JrIG9uIGRpc2Nvbm5lY3RlZCBlbGVtZW50c1xuXHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeXVpLmNvbS90aWNrZXQvNzU1MiAtIEEgRGF0ZXBpY2tlciBjcmVhdGVkIG9uIGEgZGV0YWNoZWQgZGl2IGhhcyB6ZXJvIGhlaWdodFxuXHRcdGluc3QuZHBEaXYuY3NzKCBcImRpc3BsYXlcIiwgXCJibG9ja1wiICk7XG5cdH0sXG5cblx0LyogUG9wLXVwIHRoZSBkYXRlIHBpY2tlciBpbiBhIFwiZGlhbG9nXCIgYm94LlxuXHQgICBAcGFyYW0gIGlucHV0ICAgICBlbGVtZW50IC0gaWdub3JlZFxuXHQgICBAcGFyYW0gIGRhdGUgICAgICBzdHJpbmcgb3IgRGF0ZSAtIHRoZSBpbml0aWFsIGRhdGUgdG8gZGlzcGxheVxuXHQgICBAcGFyYW0gIG9uU2VsZWN0ICBmdW5jdGlvbiAtIHRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYSBkYXRlIGlzIHNlbGVjdGVkXG5cdCAgIEBwYXJhbSAgc2V0dGluZ3MgIG9iamVjdCAtIHVwZGF0ZSB0aGUgZGlhbG9nIGRhdGUgcGlja2VyIGluc3RhbmNlJ3Mgc2V0dGluZ3MgKGFub255bW91cyBvYmplY3QpXG5cdCAgIEBwYXJhbSAgcG9zICAgICAgIGludFsyXSAtIGNvb3JkaW5hdGVzIGZvciB0aGUgZGlhbG9nJ3MgcG9zaXRpb24gd2l0aGluIHRoZSBzY3JlZW4gb3Jcblx0ICAgICAgICAgICAgICAgICAgICAgZXZlbnQgLSB3aXRoIHgveSBjb29yZGluYXRlcyBvclxuXHQgICAgICAgICAgICAgICAgICAgICBsZWF2ZSBlbXB0eSBmb3IgZGVmYXVsdCAoc2NyZWVuIGNlbnRyZSlcblx0ICAgQHJldHVybiB0aGUgbWFuYWdlciBvYmplY3QgKi9cblx0X2RpYWxvZ0RhdGVwaWNrZXI6IGZ1bmN0aW9uKGlucHV0LCBkYXRlLCBvblNlbGVjdCwgc2V0dGluZ3MsIHBvcykge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZGlhbG9nSW5zdDsgLy8gaW50ZXJuYWwgaW5zdGFuY2Vcblx0XHRpZiAoIWluc3QpIHtcblx0XHRcdHRoaXMudXVpZCArPSAxO1xuXHRcdFx0dmFyIGlkID0gJ2RwJyArIHRoaXMudXVpZDtcblx0XHRcdHRoaXMuX2RpYWxvZ0lucHV0ID0gJCgnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCInICsgaWQgK1xuXHRcdFx0XHQnXCIgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogLTEwMHB4OyB3aWR0aDogMHB4O1wiLz4nKTtcblx0XHRcdHRoaXMuX2RpYWxvZ0lucHV0LmtleWRvd24odGhpcy5fZG9LZXlEb3duKTtcblx0XHRcdCQoJ2JvZHknKS5hcHBlbmQodGhpcy5fZGlhbG9nSW5wdXQpO1xuXHRcdFx0aW5zdCA9IHRoaXMuX2RpYWxvZ0luc3QgPSB0aGlzLl9uZXdJbnN0KHRoaXMuX2RpYWxvZ0lucHV0LCBmYWxzZSk7XG5cdFx0XHRpbnN0LnNldHRpbmdzID0ge307XG5cdFx0XHQkLmRhdGEodGhpcy5fZGlhbG9nSW5wdXRbMF0sIFBST1BfTkFNRSwgaW5zdCk7XG5cdFx0fVxuXHRcdGV4dGVuZFJlbW92ZShpbnN0LnNldHRpbmdzLCBzZXR0aW5ncyB8fCB7fSk7XG5cdFx0ZGF0ZSA9IChkYXRlICYmIGRhdGUuY29uc3RydWN0b3IgPT0gRGF0ZSA/IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCwgZGF0ZSkgOiBkYXRlKTtcblx0XHR0aGlzLl9kaWFsb2dJbnB1dC52YWwoZGF0ZSk7XG5cblx0XHR0aGlzLl9wb3MgPSAocG9zID8gKHBvcy5sZW5ndGggPyBwb3MgOiBbcG9zLnBhZ2VYLCBwb3MucGFnZVldKSA6IG51bGwpO1xuXHRcdGlmICghdGhpcy5fcG9zKSB7XG5cdFx0XHR2YXIgYnJvd3NlcldpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuXHRcdFx0dmFyIGJyb3dzZXJIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuXHRcdFx0dmFyIHNjcm9sbFggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQ7XG5cdFx0XHR2YXIgc2Nyb2xsWSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XG5cdFx0XHR0aGlzLl9wb3MgPSAvLyBzaG91bGQgdXNlIGFjdHVhbCB3aWR0aC9oZWlnaHQgYmVsb3dcblx0XHRcdFx0Wyhicm93c2VyV2lkdGggLyAyKSAtIDEwMCArIHNjcm9sbFgsIChicm93c2VySGVpZ2h0IC8gMikgLSAxNTAgKyBzY3JvbGxZXTtcblx0XHR9XG5cblx0XHQvLyBtb3ZlIGlucHV0IG9uIHNjcmVlbiBmb3IgZm9jdXMsIGJ1dCBoaWRkZW4gYmVoaW5kIGRpYWxvZ1xuXHRcdHRoaXMuX2RpYWxvZ0lucHV0LmNzcygnbGVmdCcsICh0aGlzLl9wb3NbMF0gKyAyMCkgKyAncHgnKS5jc3MoJ3RvcCcsIHRoaXMuX3Bvc1sxXSArICdweCcpO1xuXHRcdGluc3Quc2V0dGluZ3Mub25TZWxlY3QgPSBvblNlbGVjdDtcblx0XHR0aGlzLl9pbkRpYWxvZyA9IHRydWU7XG5cdFx0dGhpcy5kcERpdi5hZGRDbGFzcyh0aGlzLl9kaWFsb2dDbGFzcyk7XG5cdFx0dGhpcy5fc2hvd0RhdGVwaWNrZXIodGhpcy5fZGlhbG9nSW5wdXRbMF0pO1xuXHRcdGlmICgkLmJsb2NrVUkpXG5cdFx0XHQkLmJsb2NrVUkodGhpcy5kcERpdik7XG5cdFx0JC5kYXRhKHRoaXMuX2RpYWxvZ0lucHV0WzBdLCBQUk9QX05BTUUsIGluc3QpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qIERldGFjaCBhIGRhdGVwaWNrZXIgZnJvbSBpdHMgY29udHJvbC5cblx0ICAgQHBhcmFtICB0YXJnZXQgICAgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhbiAqL1xuXHRfZGVzdHJveURhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHZhciAkdGFyZ2V0ID0gJCh0YXJnZXQpO1xuXHRcdHZhciBpbnN0ID0gJC5kYXRhKHRhcmdldCwgUFJPUF9OQU1FKTtcblx0XHRpZiAoISR0YXJnZXQuaGFzQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBub2RlTmFtZSA9IHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdCQucmVtb3ZlRGF0YSh0YXJnZXQsIFBST1BfTkFNRSk7XG5cdFx0aWYgKG5vZGVOYW1lID09ICdpbnB1dCcpIHtcblx0XHRcdGluc3QuYXBwZW5kLnJlbW92ZSgpO1xuXHRcdFx0aW5zdC50cmlnZ2VyLnJlbW92ZSgpO1xuXHRcdFx0JHRhcmdldC5yZW1vdmVDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkuXG5cdFx0XHRcdHVuYmluZCgnZm9jdXMnLCB0aGlzLl9zaG93RGF0ZXBpY2tlcikuXG5cdFx0XHRcdHVuYmluZCgna2V5ZG93bicsIHRoaXMuX2RvS2V5RG93bikuXG5cdFx0XHRcdHVuYmluZCgna2V5cHJlc3MnLCB0aGlzLl9kb0tleVByZXNzKS5cblx0XHRcdFx0dW5iaW5kKCdrZXl1cCcsIHRoaXMuX2RvS2V5VXApO1xuXHRcdH0gZWxzZSBpZiAobm9kZU5hbWUgPT0gJ2RpdicgfHwgbm9kZU5hbWUgPT0gJ3NwYW4nKVxuXHRcdFx0JHRhcmdldC5yZW1vdmVDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkuZW1wdHkoKTtcblx0fSxcblxuXHQvKiBFbmFibGUgdGhlIGRhdGUgcGlja2VyIHRvIGEgalF1ZXJ5IHNlbGVjdGlvbi5cblx0ICAgQHBhcmFtICB0YXJnZXQgICAgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhbiAqL1xuXHRfZW5hYmxlRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0dmFyICR0YXJnZXQgPSAkKHRhcmdldCk7XG5cdFx0dmFyIGluc3QgPSAkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUpO1xuXHRcdGlmICghJHRhcmdldC5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0aWYgKG5vZGVOYW1lID09ICdpbnB1dCcpIHtcblx0XHRcdHRhcmdldC5kaXNhYmxlZCA9IGZhbHNlO1xuXHRcdFx0aW5zdC50cmlnZ2VyLmZpbHRlcignYnV0dG9uJykuXG5cdFx0XHRcdGVhY2goZnVuY3Rpb24oKSB7IHRoaXMuZGlzYWJsZWQgPSBmYWxzZTsgfSkuZW5kKCkuXG5cdFx0XHRcdGZpbHRlcignaW1nJykuY3NzKHtvcGFjaXR5OiAnMS4wJywgY3Vyc29yOiAnJ30pO1xuXHRcdH1cblx0XHRlbHNlIGlmIChub2RlTmFtZSA9PSAnZGl2JyB8fCBub2RlTmFtZSA9PSAnc3BhbicpIHtcblx0XHRcdHZhciBpbmxpbmUgPSAkdGFyZ2V0LmNoaWxkcmVuKCcuJyArIHRoaXMuX2lubGluZUNsYXNzKTtcblx0XHRcdGlubGluZS5jaGlsZHJlbigpLnJlbW92ZUNsYXNzKCd1aS1zdGF0ZS1kaXNhYmxlZCcpO1xuXHRcdFx0aW5saW5lLmZpbmQoXCJzZWxlY3QudWktZGF0ZXBpY2tlci1tb250aCwgc2VsZWN0LnVpLWRhdGVwaWNrZXIteWVhclwiKS5cblx0XHRcdFx0cHJvcChcImRpc2FibGVkXCIsIGZhbHNlKTtcblx0XHR9XG5cdFx0dGhpcy5fZGlzYWJsZWRJbnB1dHMgPSAkLm1hcCh0aGlzLl9kaXNhYmxlZElucHV0cyxcblx0XHRcdGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiAodmFsdWUgPT0gdGFyZ2V0ID8gbnVsbCA6IHZhbHVlKTsgfSk7IC8vIGRlbGV0ZSBlbnRyeVxuXHR9LFxuXG5cdC8qIERpc2FibGUgdGhlIGRhdGUgcGlja2VyIHRvIGEgalF1ZXJ5IHNlbGVjdGlvbi5cblx0ICAgQHBhcmFtICB0YXJnZXQgICAgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhbiAqL1xuXHRfZGlzYWJsZURhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHZhciAkdGFyZ2V0ID0gJCh0YXJnZXQpO1xuXHRcdHZhciBpbnN0ID0gJC5kYXRhKHRhcmdldCwgUFJPUF9OQU1FKTtcblx0XHRpZiAoISR0YXJnZXQuaGFzQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBub2RlTmFtZSA9IHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdGlmIChub2RlTmFtZSA9PSAnaW5wdXQnKSB7XG5cdFx0XHR0YXJnZXQuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aW5zdC50cmlnZ2VyLmZpbHRlcignYnV0dG9uJykuXG5cdFx0XHRcdGVhY2goZnVuY3Rpb24oKSB7IHRoaXMuZGlzYWJsZWQgPSB0cnVlOyB9KS5lbmQoKS5cblx0XHRcdFx0ZmlsdGVyKCdpbWcnKS5jc3Moe29wYWNpdHk6ICcwLjUnLCBjdXJzb3I6ICdkZWZhdWx0J30pO1xuXHRcdH1cblx0XHRlbHNlIGlmIChub2RlTmFtZSA9PSAnZGl2JyB8fCBub2RlTmFtZSA9PSAnc3BhbicpIHtcblx0XHRcdHZhciBpbmxpbmUgPSAkdGFyZ2V0LmNoaWxkcmVuKCcuJyArIHRoaXMuX2lubGluZUNsYXNzKTtcblx0XHRcdGlubGluZS5jaGlsZHJlbigpLmFkZENsYXNzKCd1aS1zdGF0ZS1kaXNhYmxlZCcpO1xuXHRcdFx0aW5saW5lLmZpbmQoXCJzZWxlY3QudWktZGF0ZXBpY2tlci1tb250aCwgc2VsZWN0LnVpLWRhdGVwaWNrZXIteWVhclwiKS5cblx0XHRcdFx0cHJvcChcImRpc2FibGVkXCIsIHRydWUpO1xuXHRcdH1cblx0XHR0aGlzLl9kaXNhYmxlZElucHV0cyA9ICQubWFwKHRoaXMuX2Rpc2FibGVkSW5wdXRzLFxuXHRcdFx0ZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuICh2YWx1ZSA9PSB0YXJnZXQgPyBudWxsIDogdmFsdWUpOyB9KTsgLy8gZGVsZXRlIGVudHJ5XG5cdFx0dGhpcy5fZGlzYWJsZWRJbnB1dHNbdGhpcy5fZGlzYWJsZWRJbnB1dHMubGVuZ3RoXSA9IHRhcmdldDtcblx0fSxcblxuXHQvKiBJcyB0aGUgZmlyc3QgZmllbGQgaW4gYSBqUXVlcnkgY29sbGVjdGlvbiBkaXNhYmxlZCBhcyBhIGRhdGVwaWNrZXI/XG5cdCAgIEBwYXJhbSAgdGFyZ2V0ICAgIGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICAgQHJldHVybiBib29sZWFuIC0gdHJ1ZSBpZiBkaXNhYmxlZCwgZmFsc2UgaWYgZW5hYmxlZCAqL1xuXHRfaXNEaXNhYmxlZERhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdGlmICghdGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZGlzYWJsZWRJbnB1dHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLl9kaXNhYmxlZElucHV0c1tpXSA9PSB0YXJnZXQpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0LyogUmV0cmlldmUgdGhlIGluc3RhbmNlIGRhdGEgZm9yIHRoZSB0YXJnZXQgY29udHJvbC5cblx0ICAgQHBhcmFtICB0YXJnZXQgIGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICAgQHJldHVybiAgb2JqZWN0IC0gdGhlIGFzc29jaWF0ZWQgaW5zdGFuY2UgZGF0YVxuXHQgICBAdGhyb3dzICBlcnJvciBpZiBhIGpRdWVyeSBwcm9ibGVtIGdldHRpbmcgZGF0YSAqL1xuXHRfZ2V0SW5zdDogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiAkLmRhdGEodGFyZ2V0LCBQUk9QX05BTUUpO1xuXHRcdH1cblx0XHRjYXRjaCAoZXJyKSB7XG5cdFx0XHR0aHJvdyAnTWlzc2luZyBpbnN0YW5jZSBkYXRhIGZvciB0aGlzIGRhdGVwaWNrZXInO1xuXHRcdH1cblx0fSxcblxuXHQvKiBVcGRhdGUgb3IgcmV0cmlldmUgdGhlIHNldHRpbmdzIGZvciBhIGRhdGUgcGlja2VyIGF0dGFjaGVkIHRvIGFuIGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uLlxuXHQgICBAcGFyYW0gIHRhcmdldCAgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxuXHQgICBAcGFyYW0gIG5hbWUgICAgb2JqZWN0IC0gdGhlIG5ldyBzZXR0aW5ncyB0byB1cGRhdGUgb3Jcblx0ICAgICAgICAgICAgICAgICAgIHN0cmluZyAtIHRoZSBuYW1lIG9mIHRoZSBzZXR0aW5nIHRvIGNoYW5nZSBvciByZXRyaWV2ZSxcblx0ICAgICAgICAgICAgICAgICAgIHdoZW4gcmV0cmlldmluZyBhbHNvICdhbGwnIGZvciBhbGwgaW5zdGFuY2Ugc2V0dGluZ3Mgb3Jcblx0ICAgICAgICAgICAgICAgICAgICdkZWZhdWx0cycgZm9yIGFsbCBnbG9iYWwgZGVmYXVsdHNcblx0ICAgQHBhcmFtICB2YWx1ZSAgIGFueSAtIHRoZSBuZXcgdmFsdWUgZm9yIHRoZSBzZXR0aW5nXG5cdCAgICAgICAgICAgICAgICAgICAob21pdCBpZiBhYm92ZSBpcyBhbiBvYmplY3Qgb3IgdG8gcmV0cmlldmUgYSB2YWx1ZSkgKi9cblx0X29wdGlvbkRhdGVwaWNrZXI6IGZ1bmN0aW9uKHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0KTtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyICYmIHR5cGVvZiBuYW1lID09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gKG5hbWUgPT0gJ2RlZmF1bHRzJyA/ICQuZXh0ZW5kKHt9LCAkLmRhdGVwaWNrZXIuX2RlZmF1bHRzKSA6XG5cdFx0XHRcdChpbnN0ID8gKG5hbWUgPT0gJ2FsbCcgPyAkLmV4dGVuZCh7fSwgaW5zdC5zZXR0aW5ncykgOlxuXHRcdFx0XHR0aGlzLl9nZXQoaW5zdCwgbmFtZSkpIDogbnVsbCkpO1xuXHRcdH1cblx0XHR2YXIgc2V0dGluZ3MgPSBuYW1lIHx8IHt9O1xuXHRcdGlmICh0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJykge1xuXHRcdFx0c2V0dGluZ3MgPSB7fTtcblx0XHRcdHNldHRpbmdzW25hbWVdID0gdmFsdWU7XG5cdFx0fVxuXHRcdGlmIChpbnN0KSB7XG5cdFx0XHRpZiAodGhpcy5fY3VySW5zdCA9PSBpbnN0KSB7XG5cdFx0XHRcdHRoaXMuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZGF0ZSA9IHRoaXMuX2dldERhdGVEYXRlcGlja2VyKHRhcmdldCwgdHJ1ZSk7XG5cdFx0XHR2YXIgbWluRGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgJ21pbicpO1xuXHRcdFx0dmFyIG1heERhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsICdtYXgnKTtcblx0XHRcdGV4dGVuZFJlbW92ZShpbnN0LnNldHRpbmdzLCBzZXR0aW5ncyk7XG5cdFx0XHQvLyByZWZvcm1hdCB0aGUgb2xkIG1pbkRhdGUvbWF4RGF0ZSB2YWx1ZXMgaWYgZGF0ZUZvcm1hdCBjaGFuZ2VzIGFuZCBhIG5ldyBtaW5EYXRlL21heERhdGUgaXNuJ3QgcHJvdmlkZWRcblx0XHRcdGlmIChtaW5EYXRlICE9PSBudWxsICYmIHNldHRpbmdzWydkYXRlRm9ybWF0J10gIT09IHVuZGVmaW5lZCAmJiBzZXR0aW5nc1snbWluRGF0ZSddID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdGluc3Quc2V0dGluZ3MubWluRGF0ZSA9IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCwgbWluRGF0ZSk7XG5cdFx0XHRpZiAobWF4RGF0ZSAhPT0gbnVsbCAmJiBzZXR0aW5nc1snZGF0ZUZvcm1hdCddICE9PSB1bmRlZmluZWQgJiYgc2V0dGluZ3NbJ21heERhdGUnXSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRpbnN0LnNldHRpbmdzLm1heERhdGUgPSB0aGlzLl9mb3JtYXREYXRlKGluc3QsIG1heERhdGUpO1xuXHRcdFx0dGhpcy5fYXR0YWNobWVudHMoJCh0YXJnZXQpLCBpbnN0KTtcblx0XHRcdHRoaXMuX2F1dG9TaXplKGluc3QpO1xuXHRcdFx0dGhpcy5fc2V0RGF0ZShpbnN0LCBkYXRlKTtcblx0XHRcdHRoaXMuX3VwZGF0ZUFsdGVybmF0ZShpbnN0KTtcblx0XHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGNoYW5nZSBtZXRob2QgZGVwcmVjYXRlZFxuXHRfY2hhbmdlRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXMuX29wdGlvbkRhdGVwaWNrZXIodGFyZ2V0LCBuYW1lLCB2YWx1ZSk7XG5cdH0sXG5cblx0LyogUmVkcmF3IHRoZSBkYXRlIHBpY2tlciBhdHRhY2hlZCB0byBhbiBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbi5cblx0ICAgQHBhcmFtICB0YXJnZXQgIGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW4gKi9cblx0X3JlZnJlc2hEYXRlcGlja2VyOiBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0KTtcblx0XHRpZiAoaW5zdCkge1xuXHRcdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHR9XG5cdH0sXG5cblx0LyogU2V0IHRoZSBkYXRlcyBmb3IgYSBqUXVlcnkgc2VsZWN0aW9uLlxuXHQgICBAcGFyYW0gIHRhcmdldCAgIGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cblx0ICAgQHBhcmFtICBkYXRlICAgICBEYXRlIC0gdGhlIG5ldyBkYXRlICovXG5cdF9zZXREYXRlRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBkYXRlKSB7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XG5cdFx0aWYgKGluc3QpIHtcblx0XHRcdHRoaXMuX3NldERhdGUoaW5zdCwgZGF0ZSk7XG5cdFx0XHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xuXHRcdFx0dGhpcy5fdXBkYXRlQWx0ZXJuYXRlKGluc3QpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBHZXQgdGhlIGRhdGUocykgZm9yIHRoZSBmaXJzdCBlbnRyeSBpbiBhIGpRdWVyeSBzZWxlY3Rpb24uXG5cdCAgIEBwYXJhbSAgdGFyZ2V0ICAgICBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXG5cdCAgIEBwYXJhbSAgbm9EZWZhdWx0ICBib29sZWFuIC0gdHJ1ZSBpZiBubyBkZWZhdWx0IGRhdGUgaXMgdG8gYmUgdXNlZFxuXHQgICBAcmV0dXJuIERhdGUgLSB0aGUgY3VycmVudCBkYXRlICovXG5cdF9nZXREYXRlRGF0ZXBpY2tlcjogZnVuY3Rpb24odGFyZ2V0LCBub0RlZmF1bHQpIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0KTtcblx0XHRpZiAoaW5zdCAmJiAhaW5zdC5pbmxpbmUpXG5cdFx0XHR0aGlzLl9zZXREYXRlRnJvbUZpZWxkKGluc3QsIG5vRGVmYXVsdCk7XG5cdFx0cmV0dXJuIChpbnN0ID8gdGhpcy5fZ2V0RGF0ZShpbnN0KSA6IG51bGwpO1xuXHR9LFxuXG5cdC8qIEhhbmRsZSBrZXlzdHJva2VzLiAqL1xuXHRfZG9LZXlEb3duOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KGV2ZW50LnRhcmdldCk7XG5cdFx0dmFyIGhhbmRsZWQgPSB0cnVlO1xuXHRcdHZhciBpc1JUTCA9IGluc3QuZHBEaXYuaXMoJy51aS1kYXRlcGlja2VyLXJ0bCcpO1xuXHRcdGluc3QuX2tleUV2ZW50ID0gdHJ1ZTtcblx0XHRpZiAoJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZylcblx0XHRcdHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuXHRcdFx0XHRjYXNlIDk6ICQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBoaWRlIG9uIHRhYiBvdXRcblx0XHRcdFx0Y2FzZSAxMzogdmFyIHNlbCA9ICQoJ3RkLicgKyAkLmRhdGVwaWNrZXIuX2RheU92ZXJDbGFzcyArICc6bm90KC4nICtcblx0XHRcdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fY3VycmVudENsYXNzICsgJyknLCBpbnN0LmRwRGl2KTtcblx0XHRcdFx0XHRcdGlmIChzZWxbMF0pXG5cdFx0XHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fc2VsZWN0RGF5KGV2ZW50LnRhcmdldCwgaW5zdC5zZWxlY3RlZE1vbnRoLCBpbnN0LnNlbGVjdGVkWWVhciwgc2VsWzBdKTtcblx0XHRcdFx0XHRcdFx0dmFyIG9uU2VsZWN0ID0gJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ29uU2VsZWN0Jyk7XG5cdFx0XHRcdFx0XHRcdGlmIChvblNlbGVjdCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBkYXRlU3RyID0gJC5kYXRlcGlja2VyLl9mb3JtYXREYXRlKGluc3QpO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gdHJpZ2dlciBjdXN0b20gY2FsbGJhY2tcblx0XHRcdFx0XHRcdFx0XHRvblNlbGVjdC5hcHBseSgoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXRbMF0gOiBudWxsKSwgW2RhdGVTdHIsIGluc3RdKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIGRvbid0IHN1Ym1pdCB0aGUgZm9ybVxuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIHNlbGVjdCB0aGUgdmFsdWUgb24gZW50ZXJcblx0XHRcdFx0Y2FzZSAyNzogJC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIGhpZGUgb24gZXNjYXBlXG5cdFx0XHRcdGNhc2UgMzM6ICQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShldmVudC50YXJnZXQsIChldmVudC5jdHJsS2V5ID9cblx0XHRcdFx0XHRcdFx0LSQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsICdzdGVwQmlnTW9udGhzJykgOlxuXHRcdFx0XHRcdFx0XHQtJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ3N0ZXBNb250aHMnKSksICdNJyk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gcHJldmlvdXMgbW9udGgveWVhciBvbiBwYWdlIHVwLysgY3RybFxuXHRcdFx0XHRjYXNlIDM0OiAkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoZXZlbnQudGFyZ2V0LCAoZXZlbnQuY3RybEtleSA/XG5cdFx0XHRcdFx0XHRcdCskLmRhdGVwaWNrZXIuX2dldChpbnN0LCAnc3RlcEJpZ01vbnRocycpIDpcblx0XHRcdFx0XHRcdFx0KyQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsICdzdGVwTW9udGhzJykpLCAnTScpO1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIG5leHQgbW9udGgveWVhciBvbiBwYWdlIGRvd24vKyBjdHJsXG5cdFx0XHRcdGNhc2UgMzU6IGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpICQuZGF0ZXBpY2tlci5fY2xlYXJEYXRlKGV2ZW50LnRhcmdldCk7XG5cdFx0XHRcdFx0XHRoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIGNsZWFyIG9uIGN0cmwgb3IgY29tbWFuZCArZW5kXG5cdFx0XHRcdGNhc2UgMzY6IGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpICQuZGF0ZXBpY2tlci5fZ290b1RvZGF5KGV2ZW50LnRhcmdldCk7XG5cdFx0XHRcdFx0XHRoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIGN1cnJlbnQgb24gY3RybCBvciBjb21tYW5kICtob21lXG5cdFx0XHRcdGNhc2UgMzc6IGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpICQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShldmVudC50YXJnZXQsIChpc1JUTCA/ICsxIDogLTEpLCAnRCcpO1xuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcblx0XHRcdFx0XHRcdC8vIC0xIGRheSBvbiBjdHJsIG9yIGNvbW1hbmQgK2xlZnRcblx0XHRcdFx0XHRcdGlmIChldmVudC5vcmlnaW5hbEV2ZW50LmFsdEtleSkgJC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKGV2ZW50LmN0cmxLZXkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0LSQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsICdzdGVwQmlnTW9udGhzJykgOlxuXHRcdFx0XHRcdFx0XHRcdFx0LSQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsICdzdGVwTW9udGhzJykpLCAnTScpO1xuXHRcdFx0XHRcdFx0Ly8gbmV4dCBtb250aC95ZWFyIG9uIGFsdCArbGVmdCBvbiBNYWNcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDM4OiBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSAkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoZXZlbnQudGFyZ2V0LCAtNywgJ0QnKTtcblx0XHRcdFx0XHRcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gLTEgd2VlayBvbiBjdHJsIG9yIGNvbW1hbmQgK3VwXG5cdFx0XHRcdGNhc2UgMzk6IGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpICQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShldmVudC50YXJnZXQsIChpc1JUTCA/IC0xIDogKzEpLCAnRCcpO1xuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcblx0XHRcdFx0XHRcdC8vICsxIGRheSBvbiBjdHJsIG9yIGNvbW1hbmQgK3JpZ2h0XG5cdFx0XHRcdFx0XHRpZiAoZXZlbnQub3JpZ2luYWxFdmVudC5hbHRLZXkpICQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShldmVudC50YXJnZXQsIChldmVudC5jdHJsS2V5ID9cblx0XHRcdFx0XHRcdFx0XHRcdCskLmRhdGVwaWNrZXIuX2dldChpbnN0LCAnc3RlcEJpZ01vbnRocycpIDpcblx0XHRcdFx0XHRcdFx0XHRcdCskLmRhdGVwaWNrZXIuX2dldChpbnN0LCAnc3RlcE1vbnRocycpKSwgJ00nKTtcblx0XHRcdFx0XHRcdC8vIG5leHQgbW9udGgveWVhciBvbiBhbHQgK3JpZ2h0XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSA0MDogaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkgJC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKzcsICdEJyk7XG5cdFx0XHRcdFx0XHRoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vICsxIHdlZWsgb24gY3RybCBvciBjb21tYW5kICtkb3duXG5cdFx0XHRcdGRlZmF1bHQ6IGhhbmRsZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDM2ICYmIGV2ZW50LmN0cmxLZXkpIC8vIGRpc3BsYXkgdGhlIGRhdGUgcGlja2VyIG9uIGN0cmwraG9tZVxuXHRcdFx0JC5kYXRlcGlja2VyLl9zaG93RGF0ZXBpY2tlcih0aGlzKTtcblx0XHRlbHNlIHtcblx0XHRcdGhhbmRsZWQgPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKGhhbmRsZWQpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cblx0LyogRmlsdGVyIGVudGVyZWQgY2hhcmFjdGVycyAtIGJhc2VkIG9uIGRhdGUgZm9ybWF0LiAqL1xuXHRfZG9LZXlQcmVzczogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgaW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdChldmVudC50YXJnZXQpO1xuXHRcdGlmICgkLmRhdGVwaWNrZXIuX2dldChpbnN0LCAnY29uc3RyYWluSW5wdXQnKSkge1xuXHRcdFx0dmFyIGNoYXJzID0gJC5kYXRlcGlja2VyLl9wb3NzaWJsZUNoYXJzKCQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsICdkYXRlRm9ybWF0JykpO1xuXHRcdFx0dmFyIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQuY2hhckNvZGUgPT0gdW5kZWZpbmVkID8gZXZlbnQua2V5Q29kZSA6IGV2ZW50LmNoYXJDb2RlKTtcblx0XHRcdHJldHVybiBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgKGNociA8ICcgJyB8fCAhY2hhcnMgfHwgY2hhcnMuaW5kZXhPZihjaHIpID4gLTEpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBTeW5jaHJvbmlzZSBtYW51YWwgZW50cnkgYW5kIGZpZWxkL2FsdGVybmF0ZSBmaWVsZC4gKi9cblx0X2RvS2V5VXA6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIGluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QoZXZlbnQudGFyZ2V0KTtcblx0XHRpZiAoaW5zdC5pbnB1dC52YWwoKSAhPSBpbnN0Lmxhc3RWYWwpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBkYXRlID0gJC5kYXRlcGlja2VyLnBhcnNlRGF0ZSgkLmRhdGVwaWNrZXIuX2dldChpbnN0LCAnZGF0ZUZvcm1hdCcpLFxuXHRcdFx0XHRcdChpbnN0LmlucHV0ID8gaW5zdC5pbnB1dC52YWwoKSA6IG51bGwpLFxuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpKTtcblx0XHRcdFx0aWYgKGRhdGUpIHsgLy8gb25seSBpZiB2YWxpZFxuXHRcdFx0XHRcdCQuZGF0ZXBpY2tlci5fc2V0RGF0ZUZyb21GaWVsZChpbnN0KTtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3VwZGF0ZUFsdGVybmF0ZShpbnN0KTtcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdFx0JC5kYXRlcGlja2VyLmxvZyhlcnIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKiBQb3AtdXAgdGhlIGRhdGUgcGlja2VyIGZvciBhIGdpdmVuIGlucHV0IGZpZWxkLlxuXHQgICBJZiBmYWxzZSByZXR1cm5lZCBmcm9tIGJlZm9yZVNob3cgZXZlbnQgaGFuZGxlciBkbyBub3Qgc2hvdy5cblx0ICAgQHBhcmFtICBpbnB1dCAgZWxlbWVudCAtIHRoZSBpbnB1dCBmaWVsZCBhdHRhY2hlZCB0byB0aGUgZGF0ZSBwaWNrZXIgb3Jcblx0ICAgICAgICAgICAgICAgICAgZXZlbnQgLSBpZiB0cmlnZ2VyZWQgYnkgZm9jdXMgKi9cblx0X3Nob3dEYXRlcGlja2VyOiBmdW5jdGlvbihpbnB1dCkge1xuXHRcdGlucHV0ID0gaW5wdXQudGFyZ2V0IHx8IGlucHV0O1xuXHRcdGlmIChpbnB1dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9ICdpbnB1dCcpIC8vIGZpbmQgZnJvbSBidXR0b24vaW1hZ2UgdHJpZ2dlclxuXHRcdFx0aW5wdXQgPSAkKCdpbnB1dCcsIGlucHV0LnBhcmVudE5vZGUpWzBdO1xuXHRcdGlmICgkLmRhdGVwaWNrZXIuX2lzRGlzYWJsZWREYXRlcGlja2VyKGlucHV0KSB8fCAkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCA9PSBpbnB1dCkgLy8gYWxyZWFkeSBoZXJlXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIGluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QoaW5wdXQpO1xuXHRcdGlmICgkLmRhdGVwaWNrZXIuX2N1ckluc3QgJiYgJC5kYXRlcGlja2VyLl9jdXJJbnN0ICE9IGluc3QpIHtcblx0XHRcdCQuZGF0ZXBpY2tlci5fY3VySW5zdC5kcERpdi5zdG9wKHRydWUsIHRydWUpO1xuXHRcdFx0aWYgKCBpbnN0ICYmICQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgKSB7XG5cdFx0XHRcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoICQuZGF0ZXBpY2tlci5fY3VySW5zdC5pbnB1dFswXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgYmVmb3JlU2hvdyA9ICQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsICdiZWZvcmVTaG93Jyk7XG5cdFx0dmFyIGJlZm9yZVNob3dTZXR0aW5ncyA9IGJlZm9yZVNob3cgPyBiZWZvcmVTaG93LmFwcGx5KGlucHV0LCBbaW5wdXQsIGluc3RdKSA6IHt9O1xuXHRcdGlmKGJlZm9yZVNob3dTZXR0aW5ncyA9PT0gZmFsc2Upe1xuXHRcdFx0Ly9mYWxzZVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRleHRlbmRSZW1vdmUoaW5zdC5zZXR0aW5ncywgYmVmb3JlU2hvd1NldHRpbmdzKTtcblx0XHRpbnN0Lmxhc3RWYWwgPSBudWxsO1xuXHRcdCQuZGF0ZXBpY2tlci5fbGFzdElucHV0ID0gaW5wdXQ7XG5cdFx0JC5kYXRlcGlja2VyLl9zZXREYXRlRnJvbUZpZWxkKGluc3QpO1xuXHRcdGlmICgkLmRhdGVwaWNrZXIuX2luRGlhbG9nKSAvLyBoaWRlIGN1cnNvclxuXHRcdFx0aW5wdXQudmFsdWUgPSAnJztcblx0XHRpZiAoISQuZGF0ZXBpY2tlci5fcG9zKSB7IC8vIHBvc2l0aW9uIGJlbG93IGlucHV0XG5cdFx0XHQkLmRhdGVwaWNrZXIuX3BvcyA9ICQuZGF0ZXBpY2tlci5fZmluZFBvcyhpbnB1dCk7XG5cdFx0XHQkLmRhdGVwaWNrZXIuX3Bvc1sxXSArPSBpbnB1dC5vZmZzZXRIZWlnaHQ7IC8vIGFkZCB0aGUgaGVpZ2h0XG5cdFx0fVxuXHRcdHZhciBpc0ZpeGVkID0gZmFsc2U7XG5cdFx0JChpbnB1dCkucGFyZW50cygpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpc0ZpeGVkIHw9ICQodGhpcykuY3NzKCdwb3NpdGlvbicpID09ICdmaXhlZCc7XG5cdFx0XHRyZXR1cm4gIWlzRml4ZWQ7XG5cdFx0fSk7XG5cdFx0dmFyIG9mZnNldCA9IHtsZWZ0OiAkLmRhdGVwaWNrZXIuX3Bvc1swXSwgdG9wOiAkLmRhdGVwaWNrZXIuX3Bvc1sxXX07XG5cdFx0JC5kYXRlcGlja2VyLl9wb3MgPSBudWxsO1xuXHRcdC8vdG8gYXZvaWQgZmxhc2hlcyBvbiBGaXJlZm94XG5cdFx0aW5zdC5kcERpdi5lbXB0eSgpO1xuXHRcdC8vIGRldGVybWluZSBzaXppbmcgb2Zmc2NyZWVuXG5cdFx0aW5zdC5kcERpdi5jc3Moe3Bvc2l0aW9uOiAnYWJzb2x1dGUnLCBkaXNwbGF5OiAnYmxvY2snLCB0b3A6ICctMTAwMHB4J30pO1xuXHRcdCQuZGF0ZXBpY2tlci5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0XHQvLyBmaXggd2lkdGggZm9yIGR5bmFtaWMgbnVtYmVyIG9mIGRhdGUgcGlja2Vyc1xuXHRcdC8vIGFuZCBhZGp1c3QgcG9zaXRpb24gYmVmb3JlIHNob3dpbmdcblx0XHRvZmZzZXQgPSAkLmRhdGVwaWNrZXIuX2NoZWNrT2Zmc2V0KGluc3QsIG9mZnNldCwgaXNGaXhlZCk7XG5cdFx0aW5zdC5kcERpdi5jc3Moe3Bvc2l0aW9uOiAoJC5kYXRlcGlja2VyLl9pbkRpYWxvZyAmJiAkLmJsb2NrVUkgP1xuXHRcdFx0J3N0YXRpYycgOiAoaXNGaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnKSksIGRpc3BsYXk6ICdub25lJyxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0ICsgJ3B4JywgdG9wOiBvZmZzZXQudG9wICsgJ3B4J30pO1xuXHRcdGlmICghaW5zdC5pbmxpbmUpIHtcblx0XHRcdHZhciBzaG93QW5pbSA9ICQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsICdzaG93QW5pbScpO1xuXHRcdFx0dmFyIGR1cmF0aW9uID0gJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ2R1cmF0aW9uJyk7XG5cdFx0XHR2YXIgcG9zdFByb2Nlc3MgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGNvdmVyID0gaW5zdC5kcERpdi5maW5kKCdpZnJhbWUudWktZGF0ZXBpY2tlci1jb3ZlcicpOyAvLyBJRTYtIG9ubHlcblx0XHRcdFx0aWYoICEhIGNvdmVyLmxlbmd0aCApe1xuXHRcdFx0XHRcdHZhciBib3JkZXJzID0gJC5kYXRlcGlja2VyLl9nZXRCb3JkZXJzKGluc3QuZHBEaXYpO1xuXHRcdFx0XHRcdGNvdmVyLmNzcyh7bGVmdDogLWJvcmRlcnNbMF0sIHRvcDogLWJvcmRlcnNbMV0sXG5cdFx0XHRcdFx0XHR3aWR0aDogaW5zdC5kcERpdi5vdXRlcldpZHRoKCksIGhlaWdodDogaW5zdC5kcERpdi5vdXRlckhlaWdodCgpfSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRpbnN0LmRwRGl2LnpJbmRleCgkKGlucHV0KS56SW5kZXgoKSsxKTtcblx0XHRcdCQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgPSB0cnVlO1xuXG5cdFx0XHQvLyBERVBSRUNBVEVEOiBhZnRlciBCQyBmb3IgMS44LnggJC5lZmZlY3RzWyBzaG93QW5pbSBdIGlzIG5vdCBuZWVkZWRcblx0XHRcdGlmICggJC5lZmZlY3RzICYmICggJC5lZmZlY3RzLmVmZmVjdFsgc2hvd0FuaW0gXSB8fCAkLmVmZmVjdHNbIHNob3dBbmltIF0gKSApXG5cdFx0XHRcdGluc3QuZHBEaXYuc2hvdyhzaG93QW5pbSwgJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ3Nob3dPcHRpb25zJyksIGR1cmF0aW9uLCBwb3N0UHJvY2Vzcyk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGluc3QuZHBEaXZbc2hvd0FuaW0gfHwgJ3Nob3cnXSgoc2hvd0FuaW0gPyBkdXJhdGlvbiA6IG51bGwpLCBwb3N0UHJvY2Vzcyk7XG5cdFx0XHRpZiAoIXNob3dBbmltIHx8ICFkdXJhdGlvbilcblx0XHRcdFx0cG9zdFByb2Nlc3MoKTtcblx0XHRcdGlmIChpbnN0LmlucHV0LmlzKCc6dmlzaWJsZScpICYmICFpbnN0LmlucHV0LmlzKCc6ZGlzYWJsZWQnKSlcblx0XHRcdFx0aW5zdC5pbnB1dC5mb2N1cygpO1xuXHRcdFx0JC5kYXRlcGlja2VyLl9jdXJJbnN0ID0gaW5zdDtcblx0XHR9XG5cdH0sXG5cblx0LyogR2VuZXJhdGUgdGhlIGRhdGUgcGlja2VyIGNvbnRlbnQuICovXG5cdF91cGRhdGVEYXRlcGlja2VyOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0dGhpcy5tYXhSb3dzID0gNDsgLy9SZXNldCB0aGUgbWF4IG51bWJlciBvZiByb3dzIGJlaW5nIGRpc3BsYXllZCAoc2VlICM3MDQzKVxuXHRcdHZhciBib3JkZXJzID0gJC5kYXRlcGlja2VyLl9nZXRCb3JkZXJzKGluc3QuZHBEaXYpO1xuXHRcdGluc3RBY3RpdmUgPSBpbnN0OyAvLyBmb3IgZGVsZWdhdGUgaG92ZXIgZXZlbnRzXG5cdFx0aW5zdC5kcERpdi5lbXB0eSgpLmFwcGVuZCh0aGlzLl9nZW5lcmF0ZUhUTUwoaW5zdCkpO1xuXHRcdHRoaXMuX2F0dGFjaEhhbmRsZXJzKGluc3QpO1xuXHRcdHZhciBjb3ZlciA9IGluc3QuZHBEaXYuZmluZCgnaWZyYW1lLnVpLWRhdGVwaWNrZXItY292ZXInKTsgLy8gSUU2LSBvbmx5XG5cdFx0aWYoICEhY292ZXIubGVuZ3RoICl7IC8vYXZvaWQgY2FsbCB0byBvdXRlclhYWFgoKSB3aGVuIG5vdCBpbiBJRTZcblx0XHRcdGNvdmVyLmNzcyh7bGVmdDogLWJvcmRlcnNbMF0sIHRvcDogLWJvcmRlcnNbMV0sIHdpZHRoOiBpbnN0LmRwRGl2Lm91dGVyV2lkdGgoKSwgaGVpZ2h0OiBpbnN0LmRwRGl2Lm91dGVySGVpZ2h0KCl9KVxuXHRcdH1cblx0XHRpbnN0LmRwRGl2LmZpbmQoJy4nICsgdGhpcy5fZGF5T3ZlckNsYXNzICsgJyBhJykubW91c2VvdmVyKCk7XG5cdFx0dmFyIG51bU1vbnRocyA9IHRoaXMuX2dldE51bWJlck9mTW9udGhzKGluc3QpO1xuXHRcdHZhciBjb2xzID0gbnVtTW9udGhzWzFdO1xuXHRcdHZhciB3aWR0aCA9IDE3O1xuXHRcdGluc3QuZHBEaXYucmVtb3ZlQ2xhc3MoJ3VpLWRhdGVwaWNrZXItbXVsdGktMiB1aS1kYXRlcGlja2VyLW11bHRpLTMgdWktZGF0ZXBpY2tlci1tdWx0aS00Jykud2lkdGgoJycpO1xuXHRcdGlmIChjb2xzID4gMSlcblx0XHRcdGluc3QuZHBEaXYuYWRkQ2xhc3MoJ3VpLWRhdGVwaWNrZXItbXVsdGktJyArIGNvbHMpLmNzcygnd2lkdGgnLCAod2lkdGggKiBjb2xzKSArICdlbScpO1xuXHRcdGluc3QuZHBEaXZbKG51bU1vbnRoc1swXSAhPSAxIHx8IG51bU1vbnRoc1sxXSAhPSAxID8gJ2FkZCcgOiAncmVtb3ZlJykgK1xuXHRcdFx0J0NsYXNzJ10oJ3VpLWRhdGVwaWNrZXItbXVsdGknKTtcblx0XHRpbnN0LmRwRGl2Wyh0aGlzLl9nZXQoaW5zdCwgJ2lzUlRMJykgPyAnYWRkJyA6ICdyZW1vdmUnKSArXG5cdFx0XHQnQ2xhc3MnXSgndWktZGF0ZXBpY2tlci1ydGwnKTtcblx0XHRpZiAoaW5zdCA9PSAkLmRhdGVwaWNrZXIuX2N1ckluc3QgJiYgJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiBpbnN0LmlucHV0ICYmXG5cdFx0XHRcdC8vICM2Njk0IC0gZG9uJ3QgZm9jdXMgdGhlIGlucHV0IGlmIGl0J3MgYWxyZWFkeSBmb2N1c2VkXG5cdFx0XHRcdC8vIHRoaXMgYnJlYWtzIHRoZSBjaGFuZ2UgZXZlbnQgaW4gSUVcblx0XHRcdFx0aW5zdC5pbnB1dC5pcygnOnZpc2libGUnKSAmJiAhaW5zdC5pbnB1dC5pcygnOmRpc2FibGVkJykgJiYgaW5zdC5pbnB1dFswXSAhPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuXHRcdFx0aW5zdC5pbnB1dC5mb2N1cygpO1xuXHRcdC8vIGRlZmZlcmVkIHJlbmRlciBvZiB0aGUgeWVhcnMgc2VsZWN0ICh0byBhdm9pZCBmbGFzaGVzIG9uIEZpcmVmb3gpXG5cdFx0aWYoIGluc3QueWVhcnNodG1sICl7XG5cdFx0XHR2YXIgb3JpZ3llYXJzaHRtbCA9IGluc3QueWVhcnNodG1sO1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0XHQvL2Fzc3VyZSB0aGF0IGluc3QueWVhcnNodG1sIGRpZG4ndCBjaGFuZ2UuXG5cdFx0XHRcdGlmKCBvcmlneWVhcnNodG1sID09PSBpbnN0LnllYXJzaHRtbCAmJiBpbnN0LnllYXJzaHRtbCApe1xuXHRcdFx0XHRcdGluc3QuZHBEaXYuZmluZCgnc2VsZWN0LnVpLWRhdGVwaWNrZXIteWVhcjpmaXJzdCcpLnJlcGxhY2VXaXRoKGluc3QueWVhcnNodG1sKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcmlneWVhcnNodG1sID0gaW5zdC55ZWFyc2h0bWwgPSBudWxsO1xuXHRcdFx0fSwgMCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qIFJldHJpZXZlIHRoZSBzaXplIG9mIGxlZnQgYW5kIHRvcCBib3JkZXJzIGZvciBhbiBlbGVtZW50LlxuXHQgICBAcGFyYW0gIGVsZW0gIChqUXVlcnkgb2JqZWN0KSB0aGUgZWxlbWVudCBvZiBpbnRlcmVzdFxuXHQgICBAcmV0dXJuICAobnVtYmVyWzJdKSB0aGUgbGVmdCBhbmQgdG9wIGJvcmRlcnMgKi9cblx0X2dldEJvcmRlcnM6IGZ1bmN0aW9uKGVsZW0pIHtcblx0XHR2YXIgY29udmVydCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4ge3RoaW46IDEsIG1lZGl1bTogMiwgdGhpY2s6IDN9W3ZhbHVlXSB8fCB2YWx1ZTtcblx0XHR9O1xuXHRcdHJldHVybiBbcGFyc2VGbG9hdChjb252ZXJ0KGVsZW0uY3NzKCdib3JkZXItbGVmdC13aWR0aCcpKSksXG5cdFx0XHRwYXJzZUZsb2F0KGNvbnZlcnQoZWxlbS5jc3MoJ2JvcmRlci10b3Atd2lkdGgnKSkpXTtcblx0fSxcblxuXHQvKiBDaGVjayBwb3NpdGlvbmluZyB0byByZW1haW4gb24gc2NyZWVuLiAqL1xuXHRfY2hlY2tPZmZzZXQ6IGZ1bmN0aW9uKGluc3QsIG9mZnNldCwgaXNGaXhlZCkge1xuXHRcdHZhciBkcFdpZHRoID0gaW5zdC5kcERpdi5vdXRlcldpZHRoKCk7XG5cdFx0dmFyIGRwSGVpZ2h0ID0gaW5zdC5kcERpdi5vdXRlckhlaWdodCgpO1xuXHRcdHZhciBpbnB1dFdpZHRoID0gaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQub3V0ZXJXaWR0aCgpIDogMDtcblx0XHR2YXIgaW5wdXRIZWlnaHQgPSBpbnN0LmlucHV0ID8gaW5zdC5pbnB1dC5vdXRlckhlaWdodCgpIDogMDtcblx0XHR2YXIgdmlld1dpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoICsgKGlzRml4ZWQgPyAwIDogJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpKTtcblx0XHR2YXIgdmlld0hlaWdodCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgKyAoaXNGaXhlZCA/IDAgOiAkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSk7XG5cblx0XHRvZmZzZXQubGVmdCAtPSAodGhpcy5fZ2V0KGluc3QsICdpc1JUTCcpID8gKGRwV2lkdGggLSBpbnB1dFdpZHRoKSA6IDApO1xuXHRcdG9mZnNldC5sZWZ0IC09IChpc0ZpeGVkICYmIG9mZnNldC5sZWZ0ID09IGluc3QuaW5wdXQub2Zmc2V0KCkubGVmdCkgPyAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgOiAwO1xuXHRcdG9mZnNldC50b3AgLT0gKGlzRml4ZWQgJiYgb2Zmc2V0LnRvcCA9PSAoaW5zdC5pbnB1dC5vZmZzZXQoKS50b3AgKyBpbnB1dEhlaWdodCkpID8gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgOiAwO1xuXG5cdFx0Ly8gbm93IGNoZWNrIGlmIGRhdGVwaWNrZXIgaXMgc2hvd2luZyBvdXRzaWRlIHdpbmRvdyB2aWV3cG9ydCAtIG1vdmUgdG8gYSBiZXR0ZXIgcGxhY2UgaWYgc28uXG5cdFx0b2Zmc2V0LmxlZnQgLT0gTWF0aC5taW4ob2Zmc2V0LmxlZnQsIChvZmZzZXQubGVmdCArIGRwV2lkdGggPiB2aWV3V2lkdGggJiYgdmlld1dpZHRoID4gZHBXaWR0aCkgP1xuXHRcdFx0TWF0aC5hYnMob2Zmc2V0LmxlZnQgKyBkcFdpZHRoIC0gdmlld1dpZHRoKSA6IDApO1xuXHRcdG9mZnNldC50b3AgLT0gTWF0aC5taW4ob2Zmc2V0LnRvcCwgKG9mZnNldC50b3AgKyBkcEhlaWdodCA+IHZpZXdIZWlnaHQgJiYgdmlld0hlaWdodCA+IGRwSGVpZ2h0KSA/XG5cdFx0XHRNYXRoLmFicyhkcEhlaWdodCArIGlucHV0SGVpZ2h0KSA6IDApO1xuXG5cdFx0cmV0dXJuIG9mZnNldDtcblx0fSxcblxuXHQvKiBGaW5kIGFuIG9iamVjdCdzIHBvc2l0aW9uIG9uIHRoZSBzY3JlZW4uICovXG5cdF9maW5kUG9zOiBmdW5jdGlvbihvYmopIHtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3Qob2JqKTtcblx0XHR2YXIgaXNSVEwgPSB0aGlzLl9nZXQoaW5zdCwgJ2lzUlRMJyk7XG5cdFx0d2hpbGUgKG9iaiAmJiAob2JqLnR5cGUgPT0gJ2hpZGRlbicgfHwgb2JqLm5vZGVUeXBlICE9IDEgfHwgJC5leHByLmZpbHRlcnMuaGlkZGVuKG9iaikpKSB7XG5cdFx0XHRvYmogPSBvYmpbaXNSVEwgPyAncHJldmlvdXNTaWJsaW5nJyA6ICduZXh0U2libGluZyddO1xuXHRcdH1cblx0XHR2YXIgcG9zaXRpb24gPSAkKG9iaikub2Zmc2V0KCk7XG5cdFx0cmV0dXJuIFtwb3NpdGlvbi5sZWZ0LCBwb3NpdGlvbi50b3BdO1xuXHR9LFxuXG5cdC8qIEhpZGUgdGhlIGRhdGUgcGlja2VyIGZyb20gdmlldy5cblx0ICAgQHBhcmFtICBpbnB1dCAgZWxlbWVudCAtIHRoZSBpbnB1dCBmaWVsZCBhdHRhY2hlZCB0byB0aGUgZGF0ZSBwaWNrZXIgKi9cblx0X2hpZGVEYXRlcGlja2VyOiBmdW5jdGlvbihpbnB1dCkge1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fY3VySW5zdDtcblx0XHRpZiAoIWluc3QgfHwgKGlucHV0ICYmIGluc3QgIT0gJC5kYXRhKGlucHV0LCBQUk9QX05BTUUpKSlcblx0XHRcdHJldHVybjtcblx0XHRpZiAodGhpcy5fZGF0ZXBpY2tlclNob3dpbmcpIHtcblx0XHRcdHZhciBzaG93QW5pbSA9IHRoaXMuX2dldChpbnN0LCAnc2hvd0FuaW0nKTtcblx0XHRcdHZhciBkdXJhdGlvbiA9IHRoaXMuX2dldChpbnN0LCAnZHVyYXRpb24nKTtcblx0XHRcdHZhciBwb3N0UHJvY2VzcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkLmRhdGVwaWNrZXIuX3RpZHlEaWFsb2coaW5zdCk7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBERVBSRUNBVEVEOiBhZnRlciBCQyBmb3IgMS44LnggJC5lZmZlY3RzWyBzaG93QW5pbSBdIGlzIG5vdCBuZWVkZWRcblx0XHRcdGlmICggJC5lZmZlY3RzICYmICggJC5lZmZlY3RzLmVmZmVjdFsgc2hvd0FuaW0gXSB8fCAkLmVmZmVjdHNbIHNob3dBbmltIF0gKSApXG5cdFx0XHRcdGluc3QuZHBEaXYuaGlkZShzaG93QW5pbSwgJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ3Nob3dPcHRpb25zJyksIGR1cmF0aW9uLCBwb3N0UHJvY2Vzcyk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGluc3QuZHBEaXZbKHNob3dBbmltID09ICdzbGlkZURvd24nID8gJ3NsaWRlVXAnIDpcblx0XHRcdFx0XHQoc2hvd0FuaW0gPT0gJ2ZhZGVJbicgPyAnZmFkZU91dCcgOiAnaGlkZScpKV0oKHNob3dBbmltID8gZHVyYXRpb24gOiBudWxsKSwgcG9zdFByb2Nlc3MpO1xuXHRcdFx0aWYgKCFzaG93QW5pbSlcblx0XHRcdFx0cG9zdFByb2Nlc3MoKTtcblx0XHRcdHRoaXMuX2RhdGVwaWNrZXJTaG93aW5nID0gZmFsc2U7XG5cdFx0XHR2YXIgb25DbG9zZSA9IHRoaXMuX2dldChpbnN0LCAnb25DbG9zZScpO1xuXHRcdFx0aWYgKG9uQ2xvc2UpXG5cdFx0XHRcdG9uQ2xvc2UuYXBwbHkoKGluc3QuaW5wdXQgPyBpbnN0LmlucHV0WzBdIDogbnVsbCksXG5cdFx0XHRcdFx0WyhpbnN0LmlucHV0ID8gaW5zdC5pbnB1dC52YWwoKSA6ICcnKSwgaW5zdF0pO1xuXHRcdFx0dGhpcy5fbGFzdElucHV0ID0gbnVsbDtcblx0XHRcdGlmICh0aGlzLl9pbkRpYWxvZykge1xuXHRcdFx0XHR0aGlzLl9kaWFsb2dJbnB1dC5jc3MoeyBwb3NpdGlvbjogJ2Fic29sdXRlJywgbGVmdDogJzAnLCB0b3A6ICctMTAwcHgnIH0pO1xuXHRcdFx0XHRpZiAoJC5ibG9ja1VJKSB7XG5cdFx0XHRcdFx0JC51bmJsb2NrVUkoKTtcblx0XHRcdFx0XHQkKCdib2R5JykuYXBwZW5kKHRoaXMuZHBEaXYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9pbkRpYWxvZyA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHQvKiBUaWR5IHVwIGFmdGVyIGEgZGlhbG9nIGRpc3BsYXkuICovXG5cdF90aWR5RGlhbG9nOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0aW5zdC5kcERpdi5yZW1vdmVDbGFzcyh0aGlzLl9kaWFsb2dDbGFzcykudW5iaW5kKCcudWktZGF0ZXBpY2tlci1jYWxlbmRhcicpO1xuXHR9LFxuXG5cdC8qIENsb3NlIGRhdGUgcGlja2VyIGlmIGNsaWNrZWQgZWxzZXdoZXJlLiAqL1xuXHRfY2hlY2tFeHRlcm5hbENsaWNrOiBmdW5jdGlvbihldmVudCkge1xuXHRcdGlmICghJC5kYXRlcGlja2VyLl9jdXJJbnN0KVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dmFyICR0YXJnZXQgPSAkKGV2ZW50LnRhcmdldCksXG5cdFx0XHRpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KCR0YXJnZXRbMF0pO1xuXG5cdFx0aWYgKCAoICggJHRhcmdldFswXS5pZCAhPSAkLmRhdGVwaWNrZXIuX21haW5EaXZJZCAmJlxuXHRcdFx0XHQkdGFyZ2V0LnBhcmVudHMoJyMnICsgJC5kYXRlcGlja2VyLl9tYWluRGl2SWQpLmxlbmd0aCA9PSAwICYmXG5cdFx0XHRcdCEkdGFyZ2V0Lmhhc0NsYXNzKCQuZGF0ZXBpY2tlci5tYXJrZXJDbGFzc05hbWUpICYmXG5cdFx0XHRcdCEkdGFyZ2V0LmNsb3Nlc3QoXCIuXCIgKyAkLmRhdGVwaWNrZXIuX3RyaWdnZXJDbGFzcykubGVuZ3RoICYmXG5cdFx0XHRcdCQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgJiYgISgkLmRhdGVwaWNrZXIuX2luRGlhbG9nICYmICQuYmxvY2tVSSkgKSApIHx8XG5cdFx0XHQoICR0YXJnZXQuaGFzQ2xhc3MoJC5kYXRlcGlja2VyLm1hcmtlckNsYXNzTmFtZSkgJiYgJC5kYXRlcGlja2VyLl9jdXJJbnN0ICE9IGluc3QgKSApXG5cdFx0XHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XG5cdH0sXG5cblx0LyogQWRqdXN0IG9uZSBvZiB0aGUgZGF0ZSBzdWItZmllbGRzLiAqL1xuXHRfYWRqdXN0RGF0ZTogZnVuY3Rpb24oaWQsIG9mZnNldCwgcGVyaW9kKSB7XG5cdFx0dmFyIHRhcmdldCA9ICQoaWQpO1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXRbMF0pO1xuXHRcdGlmICh0aGlzLl9pc0Rpc2FibGVkRGF0ZXBpY2tlcih0YXJnZXRbMF0pKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuX2FkanVzdEluc3REYXRlKGluc3QsIG9mZnNldCArXG5cdFx0XHQocGVyaW9kID09ICdNJyA/IHRoaXMuX2dldChpbnN0LCAnc2hvd0N1cnJlbnRBdFBvcycpIDogMCksIC8vIHVuZG8gcG9zaXRpb25pbmdcblx0XHRcdHBlcmlvZCk7XG5cdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcblx0fSxcblxuXHQvKiBBY3Rpb24gZm9yIGN1cnJlbnQgbGluay4gKi9cblx0X2dvdG9Ub2RheTogZnVuY3Rpb24oaWQpIHtcblx0XHR2YXIgdGFyZ2V0ID0gJChpZCk7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldFswXSk7XG5cdFx0aWYgKHRoaXMuX2dldChpbnN0LCAnZ290b0N1cnJlbnQnKSAmJiBpbnN0LmN1cnJlbnREYXkpIHtcblx0XHRcdGluc3Quc2VsZWN0ZWREYXkgPSBpbnN0LmN1cnJlbnREYXk7XG5cdFx0XHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGluc3QuY3VycmVudE1vbnRoO1xuXHRcdFx0aW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gaW5zdC5jdXJyZW50WWVhcjtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0XHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcblx0XHRcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHR9XG5cdFx0dGhpcy5fbm90aWZ5Q2hhbmdlKGluc3QpO1xuXHRcdHRoaXMuX2FkanVzdERhdGUodGFyZ2V0KTtcblx0fSxcblxuXHQvKiBBY3Rpb24gZm9yIHNlbGVjdGluZyBhIG5ldyBtb250aC95ZWFyLiAqL1xuXHRfc2VsZWN0TW9udGhZZWFyOiBmdW5jdGlvbihpZCwgc2VsZWN0LCBwZXJpb2QpIHtcblx0XHR2YXIgdGFyZ2V0ID0gJChpZCk7XG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldFswXSk7XG5cdFx0aW5zdFsnc2VsZWN0ZWQnICsgKHBlcmlvZCA9PSAnTScgPyAnTW9udGgnIDogJ1llYXInKV0gPVxuXHRcdGluc3RbJ2RyYXcnICsgKHBlcmlvZCA9PSAnTScgPyAnTW9udGgnIDogJ1llYXInKV0gPVxuXHRcdFx0cGFyc2VJbnQoc2VsZWN0Lm9wdGlvbnNbc2VsZWN0LnNlbGVjdGVkSW5kZXhdLnZhbHVlLDEwKTtcblx0XHR0aGlzLl9ub3RpZnlDaGFuZ2UoaW5zdCk7XG5cdFx0dGhpcy5fYWRqdXN0RGF0ZSh0YXJnZXQpO1xuXHR9LFxuXG5cdC8qIEFjdGlvbiBmb3Igc2VsZWN0aW5nIGEgZGF5LiAqL1xuXHRfc2VsZWN0RGF5OiBmdW5jdGlvbihpZCwgbW9udGgsIHllYXIsIHRkKSB7XG5cdFx0dmFyIHRhcmdldCA9ICQoaWQpO1xuXHRcdGlmICgkKHRkKS5oYXNDbGFzcyh0aGlzLl91bnNlbGVjdGFibGVDbGFzcykgfHwgdGhpcy5faXNEaXNhYmxlZERhdGVwaWNrZXIodGFyZ2V0WzBdKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0WzBdKTtcblx0XHRpbnN0LnNlbGVjdGVkRGF5ID0gaW5zdC5jdXJyZW50RGF5ID0gJCgnYScsIHRkKS5odG1sKCk7XG5cdFx0aW5zdC5zZWxlY3RlZE1vbnRoID0gaW5zdC5jdXJyZW50TW9udGggPSBtb250aDtcblx0XHRpbnN0LnNlbGVjdGVkWWVhciA9IGluc3QuY3VycmVudFllYXIgPSB5ZWFyO1xuXHRcdHRoaXMuX3NlbGVjdERhdGUoaWQsIHRoaXMuX2Zvcm1hdERhdGUoaW5zdCxcblx0XHRcdGluc3QuY3VycmVudERheSwgaW5zdC5jdXJyZW50TW9udGgsIGluc3QuY3VycmVudFllYXIpKTtcblx0fSxcblxuXHQvKiBFcmFzZSB0aGUgaW5wdXQgZmllbGQgYW5kIGhpZGUgdGhlIGRhdGUgcGlja2VyLiAqL1xuXHRfY2xlYXJEYXRlOiBmdW5jdGlvbihpZCkge1xuXHRcdHZhciB0YXJnZXQgPSAkKGlkKTtcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0WzBdKTtcblx0XHR0aGlzLl9zZWxlY3REYXRlKHRhcmdldCwgJycpO1xuXHR9LFxuXG5cdC8qIFVwZGF0ZSB0aGUgaW5wdXQgZmllbGQgd2l0aCB0aGUgc2VsZWN0ZWQgZGF0ZS4gKi9cblx0X3NlbGVjdERhdGU6IGZ1bmN0aW9uKGlkLCBkYXRlU3RyKSB7XG5cdFx0dmFyIHRhcmdldCA9ICQoaWQpO1xuXHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXRbMF0pO1xuXHRcdGRhdGVTdHIgPSAoZGF0ZVN0ciAhPSBudWxsID8gZGF0ZVN0ciA6IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCkpO1xuXHRcdGlmIChpbnN0LmlucHV0KVxuXHRcdFx0aW5zdC5pbnB1dC52YWwoZGF0ZVN0cik7XG5cdFx0dGhpcy5fdXBkYXRlQWx0ZXJuYXRlKGluc3QpO1xuXHRcdHZhciBvblNlbGVjdCA9IHRoaXMuX2dldChpbnN0LCAnb25TZWxlY3QnKTtcblx0XHRpZiAob25TZWxlY3QpXG5cdFx0XHRvblNlbGVjdC5hcHBseSgoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXRbMF0gOiBudWxsKSwgW2RhdGVTdHIsIGluc3RdKTsgIC8vIHRyaWdnZXIgY3VzdG9tIGNhbGxiYWNrXG5cdFx0ZWxzZSBpZiAoaW5zdC5pbnB1dClcblx0XHRcdGluc3QuaW5wdXQudHJpZ2dlcignY2hhbmdlJyk7IC8vIGZpcmUgdGhlIGNoYW5nZSBldmVudFxuXHRcdGlmIChpbnN0LmlubGluZSlcblx0XHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aGlzLl9oaWRlRGF0ZXBpY2tlcigpO1xuXHRcdFx0dGhpcy5fbGFzdElucHV0ID0gaW5zdC5pbnB1dFswXTtcblx0XHRcdGlmICh0eXBlb2YoaW5zdC5pbnB1dFswXSkgIT0gJ29iamVjdCcpXG5cdFx0XHRcdGluc3QuaW5wdXQuZm9jdXMoKTsgLy8gcmVzdG9yZSBmb2N1c1xuXHRcdFx0dGhpcy5fbGFzdElucHV0ID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0LyogVXBkYXRlIGFueSBhbHRlcm5hdGUgZmllbGQgdG8gc3luY2hyb25pc2Ugd2l0aCB0aGUgbWFpbiBmaWVsZC4gKi9cblx0X3VwZGF0ZUFsdGVybmF0ZTogZnVuY3Rpb24oaW5zdCkge1xuXHRcdHZhciBhbHRGaWVsZCA9IHRoaXMuX2dldChpbnN0LCAnYWx0RmllbGQnKTtcblx0XHRpZiAoYWx0RmllbGQpIHsgLy8gdXBkYXRlIGFsdGVybmF0ZSBmaWVsZCB0b29cblx0XHRcdHZhciBhbHRGb3JtYXQgPSB0aGlzLl9nZXQoaW5zdCwgJ2FsdEZvcm1hdCcpIHx8IHRoaXMuX2dldChpbnN0LCAnZGF0ZUZvcm1hdCcpO1xuXHRcdFx0dmFyIGRhdGUgPSB0aGlzLl9nZXREYXRlKGluc3QpO1xuXHRcdFx0dmFyIGRhdGVTdHIgPSB0aGlzLmZvcm1hdERhdGUoYWx0Rm9ybWF0LCBkYXRlLCB0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpO1xuXHRcdFx0JChhbHRGaWVsZCkuZWFjaChmdW5jdGlvbigpIHsgJCh0aGlzKS52YWwoZGF0ZVN0cik7IH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKiBTZXQgYXMgYmVmb3JlU2hvd0RheSBmdW5jdGlvbiB0byBwcmV2ZW50IHNlbGVjdGlvbiBvZiB3ZWVrZW5kcy5cblx0ICAgQHBhcmFtICBkYXRlICBEYXRlIC0gdGhlIGRhdGUgdG8gY3VzdG9taXNlXG5cdCAgIEByZXR1cm4gW2Jvb2xlYW4sIHN0cmluZ10gLSBpcyB0aGlzIGRhdGUgc2VsZWN0YWJsZT8sIHdoYXQgaXMgaXRzIENTUyBjbGFzcz8gKi9cblx0bm9XZWVrZW5kczogZnVuY3Rpb24oZGF0ZSkge1xuXHRcdHZhciBkYXkgPSBkYXRlLmdldERheSgpO1xuXHRcdHJldHVybiBbKGRheSA+IDAgJiYgZGF5IDwgNiksICcnXTtcblx0fSxcblxuXHQvKiBTZXQgYXMgY2FsY3VsYXRlV2VlayB0byBkZXRlcm1pbmUgdGhlIHdlZWsgb2YgdGhlIHllYXIgYmFzZWQgb24gdGhlIElTTyA4NjAxIGRlZmluaXRpb24uXG5cdCAgIEBwYXJhbSAgZGF0ZSAgRGF0ZSAtIHRoZSBkYXRlIHRvIGdldCB0aGUgd2VlayBmb3Jcblx0ICAgQHJldHVybiAgbnVtYmVyIC0gdGhlIG51bWJlciBvZiB0aGUgd2VlayB3aXRoaW4gdGhlIHllYXIgdGhhdCBjb250YWlucyB0aGlzIGRhdGUgKi9cblx0aXNvODYwMVdlZWs6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHR2YXIgY2hlY2tEYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpO1xuXHRcdC8vIEZpbmQgVGh1cnNkYXkgb2YgdGhpcyB3ZWVrIHN0YXJ0aW5nIG9uIE1vbmRheVxuXHRcdGNoZWNrRGF0ZS5zZXREYXRlKGNoZWNrRGF0ZS5nZXREYXRlKCkgKyA0IC0gKGNoZWNrRGF0ZS5nZXREYXkoKSB8fCA3KSk7XG5cdFx0dmFyIHRpbWUgPSBjaGVja0RhdGUuZ2V0VGltZSgpO1xuXHRcdGNoZWNrRGF0ZS5zZXRNb250aCgwKTsgLy8gQ29tcGFyZSB3aXRoIEphbiAxXG5cdFx0Y2hlY2tEYXRlLnNldERhdGUoMSk7XG5cdFx0cmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yb3VuZCgodGltZSAtIGNoZWNrRGF0ZSkgLyA4NjQwMDAwMCkgLyA3KSArIDE7XG5cdH0sXG5cblx0LyogUGFyc2UgYSBzdHJpbmcgdmFsdWUgaW50byBhIGRhdGUgb2JqZWN0LlxuXHQgICBTZWUgZm9ybWF0RGF0ZSBiZWxvdyBmb3IgdGhlIHBvc3NpYmxlIGZvcm1hdHMuXG5cblx0ICAgQHBhcmFtICBmb3JtYXQgICAgc3RyaW5nIC0gdGhlIGV4cGVjdGVkIGZvcm1hdCBvZiB0aGUgZGF0ZVxuXHQgICBAcGFyYW0gIHZhbHVlICAgICBzdHJpbmcgLSB0aGUgZGF0ZSBpbiB0aGUgYWJvdmUgZm9ybWF0XG5cdCAgIEBwYXJhbSAgc2V0dGluZ3MgIE9iamVjdCAtIGF0dHJpYnV0ZXMgaW5jbHVkZTpcblx0ICAgICAgICAgICAgICAgICAgICAgc2hvcnRZZWFyQ3V0b2ZmICBudW1iZXIgLSB0aGUgY3V0b2ZmIHllYXIgZm9yIGRldGVybWluaW5nIHRoZSBjZW50dXJ5IChvcHRpb25hbClcblx0ICAgICAgICAgICAgICAgICAgICAgZGF5TmFtZXNTaG9ydCAgICBzdHJpbmdbN10gLSBhYmJyZXZpYXRlZCBuYW1lcyBvZiB0aGUgZGF5cyBmcm9tIFN1bmRheSAob3B0aW9uYWwpXG5cdCAgICAgICAgICAgICAgICAgICAgIGRheU5hbWVzICAgICAgICAgc3RyaW5nWzddIC0gbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkgKG9wdGlvbmFsKVxuXHQgICAgICAgICAgICAgICAgICAgICBtb250aE5hbWVzU2hvcnQgIHN0cmluZ1sxMl0gLSBhYmJyZXZpYXRlZCBuYW1lcyBvZiB0aGUgbW9udGhzIChvcHRpb25hbClcblx0ICAgICAgICAgICAgICAgICAgICAgbW9udGhOYW1lcyAgICAgICBzdHJpbmdbMTJdIC0gbmFtZXMgb2YgdGhlIG1vbnRocyAob3B0aW9uYWwpXG5cdCAgIEByZXR1cm4gIERhdGUgLSB0aGUgZXh0cmFjdGVkIGRhdGUgdmFsdWUgb3IgbnVsbCBpZiB2YWx1ZSBpcyBibGFuayAqL1xuXHRwYXJzZURhdGU6IGZ1bmN0aW9uIChmb3JtYXQsIHZhbHVlLCBzZXR0aW5ncykge1xuXHRcdGlmIChmb3JtYXQgPT0gbnVsbCB8fCB2YWx1ZSA9PSBudWxsKVxuXHRcdFx0dGhyb3cgJ0ludmFsaWQgYXJndW1lbnRzJztcblx0XHR2YWx1ZSA9ICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgPyB2YWx1ZS50b1N0cmluZygpIDogdmFsdWUgKyAnJyk7XG5cdFx0aWYgKHZhbHVlID09ICcnKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0dmFyIHNob3J0WWVhckN1dG9mZiA9IChzZXR0aW5ncyA/IHNldHRpbmdzLnNob3J0WWVhckN1dG9mZiA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLnNob3J0WWVhckN1dG9mZjtcblx0XHRzaG9ydFllYXJDdXRvZmYgPSAodHlwZW9mIHNob3J0WWVhckN1dG9mZiAhPSAnc3RyaW5nJyA/IHNob3J0WWVhckN1dG9mZiA6XG5cdFx0XHRcdG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAlIDEwMCArIHBhcnNlSW50KHNob3J0WWVhckN1dG9mZiwgMTApKTtcblx0XHR2YXIgZGF5TmFtZXNTaG9ydCA9IChzZXR0aW5ncyA/IHNldHRpbmdzLmRheU5hbWVzU2hvcnQgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5kYXlOYW1lc1Nob3J0O1xuXHRcdHZhciBkYXlOYW1lcyA9IChzZXR0aW5ncyA/IHNldHRpbmdzLmRheU5hbWVzIDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMuZGF5TmFtZXM7XG5cdFx0dmFyIG1vbnRoTmFtZXNTaG9ydCA9IChzZXR0aW5ncyA/IHNldHRpbmdzLm1vbnRoTmFtZXNTaG9ydCA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLm1vbnRoTmFtZXNTaG9ydDtcblx0XHR2YXIgbW9udGhOYW1lcyA9IChzZXR0aW5ncyA/IHNldHRpbmdzLm1vbnRoTmFtZXMgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5tb250aE5hbWVzO1xuXHRcdHZhciB5ZWFyID0gLTE7XG5cdFx0dmFyIG1vbnRoID0gLTE7XG5cdFx0dmFyIGRheSA9IC0xO1xuXHRcdHZhciBkb3kgPSAtMTtcblx0XHR2YXIgbGl0ZXJhbCA9IGZhbHNlO1xuXHRcdC8vIENoZWNrIHdoZXRoZXIgYSBmb3JtYXQgY2hhcmFjdGVyIGlzIGRvdWJsZWRcblx0XHR2YXIgbG9va0FoZWFkID0gZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdHZhciBtYXRjaGVzID0gKGlGb3JtYXQgKyAxIDwgZm9ybWF0Lmxlbmd0aCAmJiBmb3JtYXQuY2hhckF0KGlGb3JtYXQgKyAxKSA9PSBtYXRjaCk7XG5cdFx0XHRpZiAobWF0Y2hlcylcblx0XHRcdFx0aUZvcm1hdCsrO1xuXHRcdFx0cmV0dXJuIG1hdGNoZXM7XG5cdFx0fTtcblx0XHQvLyBFeHRyYWN0IGEgbnVtYmVyIGZyb20gdGhlIHN0cmluZyB2YWx1ZVxuXHRcdHZhciBnZXROdW1iZXIgPSBmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0dmFyIGlzRG91YmxlZCA9IGxvb2tBaGVhZChtYXRjaCk7XG5cdFx0XHR2YXIgc2l6ZSA9IChtYXRjaCA9PSAnQCcgPyAxNCA6IChtYXRjaCA9PSAnIScgPyAyMCA6XG5cdFx0XHRcdChtYXRjaCA9PSAneScgJiYgaXNEb3VibGVkID8gNCA6IChtYXRjaCA9PSAnbycgPyAzIDogMikpKSk7XG5cdFx0XHR2YXIgZGlnaXRzID0gbmV3IFJlZ0V4cCgnXlxcXFxkezEsJyArIHNpemUgKyAnfScpO1xuXHRcdFx0dmFyIG51bSA9IHZhbHVlLnN1YnN0cmluZyhpVmFsdWUpLm1hdGNoKGRpZ2l0cyk7XG5cdFx0XHRpZiAoIW51bSlcblx0XHRcdFx0dGhyb3cgJ01pc3NpbmcgbnVtYmVyIGF0IHBvc2l0aW9uICcgKyBpVmFsdWU7XG5cdFx0XHRpVmFsdWUgKz0gbnVtWzBdLmxlbmd0aDtcblx0XHRcdHJldHVybiBwYXJzZUludChudW1bMF0sIDEwKTtcblx0XHR9O1xuXHRcdC8vIEV4dHJhY3QgYSBuYW1lIGZyb20gdGhlIHN0cmluZyB2YWx1ZSBhbmQgY29udmVydCB0byBhbiBpbmRleFxuXHRcdHZhciBnZXROYW1lID0gZnVuY3Rpb24obWF0Y2gsIHNob3J0TmFtZXMsIGxvbmdOYW1lcykge1xuXHRcdFx0dmFyIG5hbWVzID0gJC5tYXAobG9va0FoZWFkKG1hdGNoKSA/IGxvbmdOYW1lcyA6IHNob3J0TmFtZXMsIGZ1bmN0aW9uICh2LCBrKSB7XG5cdFx0XHRcdHJldHVybiBbIFtrLCB2XSBdO1xuXHRcdFx0fSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gLShhWzFdLmxlbmd0aCAtIGJbMV0ubGVuZ3RoKTtcblx0XHRcdH0pO1xuXHRcdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0XHQkLmVhY2gobmFtZXMsIGZ1bmN0aW9uIChpLCBwYWlyKSB7XG5cdFx0XHRcdHZhciBuYW1lID0gcGFpclsxXTtcblx0XHRcdFx0aWYgKHZhbHVlLnN1YnN0cihpVmFsdWUsIG5hbWUubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09IG5hbWUudG9Mb3dlckNhc2UoKSkge1xuXHRcdFx0XHRcdGluZGV4ID0gcGFpclswXTtcblx0XHRcdFx0XHRpVmFsdWUgKz0gbmFtZS5sZW5ndGg7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdGlmIChpbmRleCAhPSAtMSlcblx0XHRcdFx0cmV0dXJuIGluZGV4ICsgMTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhyb3cgJ1Vua25vd24gbmFtZSBhdCBwb3NpdGlvbiAnICsgaVZhbHVlO1xuXHRcdH07XG5cdFx0Ly8gQ29uZmlybSB0aGF0IGEgbGl0ZXJhbCBjaGFyYWN0ZXIgbWF0Y2hlcyB0aGUgc3RyaW5nIHZhbHVlXG5cdFx0dmFyIGNoZWNrTGl0ZXJhbCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHZhbHVlLmNoYXJBdChpVmFsdWUpICE9IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkpXG5cdFx0XHRcdHRocm93ICdVbmV4cGVjdGVkIGxpdGVyYWwgYXQgcG9zaXRpb24gJyArIGlWYWx1ZTtcblx0XHRcdGlWYWx1ZSsrO1xuXHRcdH07XG5cdFx0dmFyIGlWYWx1ZSA9IDA7XG5cdFx0Zm9yICh2YXIgaUZvcm1hdCA9IDA7IGlGb3JtYXQgPCBmb3JtYXQubGVuZ3RoOyBpRm9ybWF0KyspIHtcblx0XHRcdGlmIChsaXRlcmFsKVxuXHRcdFx0XHRpZiAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSA9PSBcIidcIiAmJiAhbG9va0FoZWFkKFwiJ1wiKSlcblx0XHRcdFx0XHRsaXRlcmFsID0gZmFsc2U7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRjaGVja0xpdGVyYWwoKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0c3dpdGNoIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpKSB7XG5cdFx0XHRcdFx0Y2FzZSAnZCc6XG5cdFx0XHRcdFx0XHRkYXkgPSBnZXROdW1iZXIoJ2QnKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ0QnOlxuXHRcdFx0XHRcdFx0Z2V0TmFtZSgnRCcsIGRheU5hbWVzU2hvcnQsIGRheU5hbWVzKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ28nOlxuXHRcdFx0XHRcdFx0ZG95ID0gZ2V0TnVtYmVyKCdvJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdtJzpcblx0XHRcdFx0XHRcdG1vbnRoID0gZ2V0TnVtYmVyKCdtJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdNJzpcblx0XHRcdFx0XHRcdG1vbnRoID0gZ2V0TmFtZSgnTScsIG1vbnRoTmFtZXNTaG9ydCwgbW9udGhOYW1lcyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICd5Jzpcblx0XHRcdFx0XHRcdHllYXIgPSBnZXROdW1iZXIoJ3knKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ0AnOlxuXHRcdFx0XHRcdFx0dmFyIGRhdGUgPSBuZXcgRGF0ZShnZXROdW1iZXIoJ0AnKSk7XG5cdFx0XHRcdFx0XHR5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdFx0XHRcdFx0bW9udGggPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xuXHRcdFx0XHRcdFx0ZGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICchJzpcblx0XHRcdFx0XHRcdHZhciBkYXRlID0gbmV3IERhdGUoKGdldE51bWJlcignIScpIC0gdGhpcy5fdGlja3NUbzE5NzApIC8gMTAwMDApO1xuXHRcdFx0XHRcdFx0eWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRcdFx0XHRcdG1vbnRoID0gZGF0ZS5nZXRNb250aCgpICsgMTtcblx0XHRcdFx0XHRcdGRheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcIidcIjpcblx0XHRcdFx0XHRcdGlmIChsb29rQWhlYWQoXCInXCIpKVxuXHRcdFx0XHRcdFx0XHRjaGVja0xpdGVyYWwoKTtcblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0bGl0ZXJhbCA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y2hlY2tMaXRlcmFsKCk7XG5cdFx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGlWYWx1ZSA8IHZhbHVlLmxlbmd0aCl7XG5cdFx0XHR2YXIgZXh0cmEgPSB2YWx1ZS5zdWJzdHIoaVZhbHVlKTtcblx0XHRcdGlmICghL15cXHMrLy50ZXN0KGV4dHJhKSkge1xuXHRcdFx0XHR0aHJvdyBcIkV4dHJhL3VucGFyc2VkIGNoYXJhY3RlcnMgZm91bmQgaW4gZGF0ZTogXCIgKyBleHRyYTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHllYXIgPT0gLTEpXG5cdFx0XHR5ZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXHRcdGVsc2UgaWYgKHllYXIgPCAxMDApXG5cdFx0XHR5ZWFyICs9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAtIG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAlIDEwMCArXG5cdFx0XHRcdCh5ZWFyIDw9IHNob3J0WWVhckN1dG9mZiA/IDAgOiAtMTAwKTtcblx0XHRpZiAoZG95ID4gLTEpIHtcblx0XHRcdG1vbnRoID0gMTtcblx0XHRcdGRheSA9IGRveTtcblx0XHRcdGRvIHtcblx0XHRcdFx0dmFyIGRpbSA9IHRoaXMuX2dldERheXNJbk1vbnRoKHllYXIsIG1vbnRoIC0gMSk7XG5cdFx0XHRcdGlmIChkYXkgPD0gZGltKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRtb250aCsrO1xuXHRcdFx0XHRkYXkgLT0gZGltO1xuXHRcdFx0fSB3aGlsZSAodHJ1ZSk7XG5cdFx0fVxuXHRcdHZhciBkYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXkpKTtcblx0XHRpZiAoZGF0ZS5nZXRGdWxsWWVhcigpICE9IHllYXIgfHwgZGF0ZS5nZXRNb250aCgpICsgMSAhPSBtb250aCB8fCBkYXRlLmdldERhdGUoKSAhPSBkYXkpXG5cdFx0XHR0aHJvdyAnSW52YWxpZCBkYXRlJzsgLy8gRS5nLiAzMS8wMi8wMFxuXHRcdHJldHVybiBkYXRlO1xuXHR9LFxuXG5cdC8qIFN0YW5kYXJkIGRhdGUgZm9ybWF0cy4gKi9cblx0QVRPTTogJ3l5LW1tLWRkJywgLy8gUkZDIDMzMzkgKElTTyA4NjAxKVxuXHRDT09LSUU6ICdELCBkZCBNIHl5Jyxcblx0SVNPXzg2MDE6ICd5eS1tbS1kZCcsXG5cdFJGQ184MjI6ICdELCBkIE0geScsXG5cdFJGQ184NTA6ICdERCwgZGQtTS15Jyxcblx0UkZDXzEwMzY6ICdELCBkIE0geScsXG5cdFJGQ18xMTIzOiAnRCwgZCBNIHl5Jyxcblx0UkZDXzI4MjI6ICdELCBkIE0geXknLFxuXHRSU1M6ICdELCBkIE0geScsIC8vIFJGQyA4MjJcblx0VElDS1M6ICchJyxcblx0VElNRVNUQU1QOiAnQCcsXG5cdFczQzogJ3l5LW1tLWRkJywgLy8gSVNPIDg2MDFcblxuXHRfdGlja3NUbzE5NzA6ICgoKDE5NzAgLSAxKSAqIDM2NSArIE1hdGguZmxvb3IoMTk3MCAvIDQpIC0gTWF0aC5mbG9vcigxOTcwIC8gMTAwKSArXG5cdFx0TWF0aC5mbG9vcigxOTcwIC8gNDAwKSkgKiAyNCAqIDYwICogNjAgKiAxMDAwMDAwMCksXG5cblx0LyogRm9ybWF0IGEgZGF0ZSBvYmplY3QgaW50byBhIHN0cmluZyB2YWx1ZS5cblx0ICAgVGhlIGZvcm1hdCBjYW4gYmUgY29tYmluYXRpb25zIG9mIHRoZSBmb2xsb3dpbmc6XG5cdCAgIGQgIC0gZGF5IG9mIG1vbnRoIChubyBsZWFkaW5nIHplcm8pXG5cdCAgIGRkIC0gZGF5IG9mIG1vbnRoICh0d28gZGlnaXQpXG5cdCAgIG8gIC0gZGF5IG9mIHllYXIgKG5vIGxlYWRpbmcgemVyb3MpXG5cdCAgIG9vIC0gZGF5IG9mIHllYXIgKHRocmVlIGRpZ2l0KVxuXHQgICBEICAtIGRheSBuYW1lIHNob3J0XG5cdCAgIEREIC0gZGF5IG5hbWUgbG9uZ1xuXHQgICBtICAtIG1vbnRoIG9mIHllYXIgKG5vIGxlYWRpbmcgemVybylcblx0ICAgbW0gLSBtb250aCBvZiB5ZWFyICh0d28gZGlnaXQpXG5cdCAgIE0gIC0gbW9udGggbmFtZSBzaG9ydFxuXHQgICBNTSAtIG1vbnRoIG5hbWUgbG9uZ1xuXHQgICB5ICAtIHllYXIgKHR3byBkaWdpdClcblx0ICAgeXkgLSB5ZWFyIChmb3VyIGRpZ2l0KVxuXHQgICBAIC0gVW5peCB0aW1lc3RhbXAgKG1zIHNpbmNlIDAxLzAxLzE5NzApXG5cdCAgICEgLSBXaW5kb3dzIHRpY2tzICgxMDBucyBzaW5jZSAwMS8wMS8wMDAxKVxuXHQgICAnLi4uJyAtIGxpdGVyYWwgdGV4dFxuXHQgICAnJyAtIHNpbmdsZSBxdW90ZVxuXG5cdCAgIEBwYXJhbSAgZm9ybWF0ICAgIHN0cmluZyAtIHRoZSBkZXNpcmVkIGZvcm1hdCBvZiB0aGUgZGF0ZVxuXHQgICBAcGFyYW0gIGRhdGUgICAgICBEYXRlIC0gdGhlIGRhdGUgdmFsdWUgdG8gZm9ybWF0XG5cdCAgIEBwYXJhbSAgc2V0dGluZ3MgIE9iamVjdCAtIGF0dHJpYnV0ZXMgaW5jbHVkZTpcblx0ICAgICAgICAgICAgICAgICAgICAgZGF5TmFtZXNTaG9ydCAgICBzdHJpbmdbN10gLSBhYmJyZXZpYXRlZCBuYW1lcyBvZiB0aGUgZGF5cyBmcm9tIFN1bmRheSAob3B0aW9uYWwpXG5cdCAgICAgICAgICAgICAgICAgICAgIGRheU5hbWVzICAgICAgICAgc3RyaW5nWzddIC0gbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkgKG9wdGlvbmFsKVxuXHQgICAgICAgICAgICAgICAgICAgICBtb250aE5hbWVzU2hvcnQgIHN0cmluZ1sxMl0gLSBhYmJyZXZpYXRlZCBuYW1lcyBvZiB0aGUgbW9udGhzIChvcHRpb25hbClcblx0ICAgICAgICAgICAgICAgICAgICAgbW9udGhOYW1lcyAgICAgICBzdHJpbmdbMTJdIC0gbmFtZXMgb2YgdGhlIG1vbnRocyAob3B0aW9uYWwpXG5cdCAgIEByZXR1cm4gIHN0cmluZyAtIHRoZSBkYXRlIGluIHRoZSBhYm92ZSBmb3JtYXQgKi9cblx0Zm9ybWF0RGF0ZTogZnVuY3Rpb24gKGZvcm1hdCwgZGF0ZSwgc2V0dGluZ3MpIHtcblx0XHRpZiAoIWRhdGUpXG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0dmFyIGRheU5hbWVzU2hvcnQgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5kYXlOYW1lc1Nob3J0IDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMuZGF5TmFtZXNTaG9ydDtcblx0XHR2YXIgZGF5TmFtZXMgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5kYXlOYW1lcyA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLmRheU5hbWVzO1xuXHRcdHZhciBtb250aE5hbWVzU2hvcnQgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5tb250aE5hbWVzU2hvcnQgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5tb250aE5hbWVzU2hvcnQ7XG5cdFx0dmFyIG1vbnRoTmFtZXMgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5tb250aE5hbWVzIDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMubW9udGhOYW1lcztcblx0XHQvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXG5cdFx0dmFyIGxvb2tBaGVhZCA9IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyA9IChpRm9ybWF0ICsgMSA8IGZvcm1hdC5sZW5ndGggJiYgZm9ybWF0LmNoYXJBdChpRm9ybWF0ICsgMSkgPT0gbWF0Y2gpO1xuXHRcdFx0aWYgKG1hdGNoZXMpXG5cdFx0XHRcdGlGb3JtYXQrKztcblx0XHRcdHJldHVybiBtYXRjaGVzO1xuXHRcdH07XG5cdFx0Ly8gRm9ybWF0IGEgbnVtYmVyLCB3aXRoIGxlYWRpbmcgemVybyBpZiBuZWNlc3Nhcnlcblx0XHR2YXIgZm9ybWF0TnVtYmVyID0gZnVuY3Rpb24obWF0Y2gsIHZhbHVlLCBsZW4pIHtcblx0XHRcdHZhciBudW0gPSAnJyArIHZhbHVlO1xuXHRcdFx0aWYgKGxvb2tBaGVhZChtYXRjaCkpXG5cdFx0XHRcdHdoaWxlIChudW0ubGVuZ3RoIDwgbGVuKVxuXHRcdFx0XHRcdG51bSA9ICcwJyArIG51bTtcblx0XHRcdHJldHVybiBudW07XG5cdFx0fTtcblx0XHQvLyBGb3JtYXQgYSBuYW1lLCBzaG9ydCBvciBsb25nIGFzIHJlcXVlc3RlZFxuXHRcdHZhciBmb3JtYXROYW1lID0gZnVuY3Rpb24obWF0Y2gsIHZhbHVlLCBzaG9ydE5hbWVzLCBsb25nTmFtZXMpIHtcblx0XHRcdHJldHVybiAobG9va0FoZWFkKG1hdGNoKSA/IGxvbmdOYW1lc1t2YWx1ZV0gOiBzaG9ydE5hbWVzW3ZhbHVlXSk7XG5cdFx0fTtcblx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0dmFyIGxpdGVyYWwgPSBmYWxzZTtcblx0XHRpZiAoZGF0ZSlcblx0XHRcdGZvciAodmFyIGlGb3JtYXQgPSAwOyBpRm9ybWF0IDwgZm9ybWF0Lmxlbmd0aDsgaUZvcm1hdCsrKSB7XG5cdFx0XHRcdGlmIChsaXRlcmFsKVxuXHRcdFx0XHRcdGlmIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpID09IFwiJ1wiICYmICFsb29rQWhlYWQoXCInXCIpKVxuXHRcdFx0XHRcdFx0bGl0ZXJhbCA9IGZhbHNlO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0c3dpdGNoIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpKSB7XG5cdFx0XHRcdFx0XHRjYXNlICdkJzpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdE51bWJlcignZCcsIGRhdGUuZ2V0RGF0ZSgpLCAyKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdEJzpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdE5hbWUoJ0QnLCBkYXRlLmdldERheSgpLCBkYXlOYW1lc1Nob3J0LCBkYXlOYW1lcyk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnbyc6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBmb3JtYXROdW1iZXIoJ28nLFxuXHRcdFx0XHRcdFx0XHRcdE1hdGgucm91bmQoKG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAwKS5nZXRUaW1lKCkpIC8gODY0MDAwMDApLCAzKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdtJzpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGZvcm1hdE51bWJlcignbScsIGRhdGUuZ2V0TW9udGgoKSArIDEsIDIpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ00nOlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZm9ybWF0TmFtZSgnTScsIGRhdGUuZ2V0TW9udGgoKSwgbW9udGhOYW1lc1Nob3J0LCBtb250aE5hbWVzKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICd5Jzpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IChsb29rQWhlYWQoJ3knKSA/IGRhdGUuZ2V0RnVsbFllYXIoKSA6XG5cdFx0XHRcdFx0XHRcdFx0KGRhdGUuZ2V0WWVhcigpICUgMTAwIDwgMTAgPyAnMCcgOiAnJykgKyBkYXRlLmdldFllYXIoKSAlIDEwMCk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnQCc6XG5cdFx0XHRcdFx0XHRcdG91dHB1dCArPSBkYXRlLmdldFRpbWUoKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICchJzpcblx0XHRcdFx0XHRcdFx0b3V0cHV0ICs9IGRhdGUuZ2V0VGltZSgpICogMTAwMDAgKyB0aGlzLl90aWNrc1RvMTk3MDtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiJ1wiOlxuXHRcdFx0XHRcdFx0XHRpZiAobG9va0FoZWFkKFwiJ1wiKSlcblx0XHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gXCInXCI7XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRsaXRlcmFsID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRvdXRwdXQgKz0gZm9ybWF0LmNoYXJBdChpRm9ybWF0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fSxcblxuXHQvKiBFeHRyYWN0IGFsbCBwb3NzaWJsZSBjaGFyYWN0ZXJzIGZyb20gdGhlIGRhdGUgZm9ybWF0LiAqL1xuXHRfcG9zc2libGVDaGFyczogZnVuY3Rpb24gKGZvcm1hdCkge1xuXHRcdHZhciBjaGFycyA9ICcnO1xuXHRcdHZhciBsaXRlcmFsID0gZmFsc2U7XG5cdFx0Ly8gQ2hlY2sgd2hldGhlciBhIGZvcm1hdCBjaGFyYWN0ZXIgaXMgZG91YmxlZFxuXHRcdHZhciBsb29rQWhlYWQgPSBmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0dmFyIG1hdGNoZXMgPSAoaUZvcm1hdCArIDEgPCBmb3JtYXQubGVuZ3RoICYmIGZvcm1hdC5jaGFyQXQoaUZvcm1hdCArIDEpID09IG1hdGNoKTtcblx0XHRcdGlmIChtYXRjaGVzKVxuXHRcdFx0XHRpRm9ybWF0Kys7XG5cdFx0XHRyZXR1cm4gbWF0Y2hlcztcblx0XHR9O1xuXHRcdGZvciAodmFyIGlGb3JtYXQgPSAwOyBpRm9ybWF0IDwgZm9ybWF0Lmxlbmd0aDsgaUZvcm1hdCsrKVxuXHRcdFx0aWYgKGxpdGVyYWwpXG5cdFx0XHRcdGlmIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpID09IFwiJ1wiICYmICFsb29rQWhlYWQoXCInXCIpKVxuXHRcdFx0XHRcdGxpdGVyYWwgPSBmYWxzZTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGNoYXJzICs9IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xuXHRcdFx0XHRcdGNhc2UgJ2QnOiBjYXNlICdtJzogY2FzZSAneSc6IGNhc2UgJ0AnOlxuXHRcdFx0XHRcdFx0Y2hhcnMgKz0gJzAxMjM0NTY3ODknO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnRCc6IGNhc2UgJ00nOlxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7IC8vIEFjY2VwdCBhbnl0aGluZ1xuXHRcdFx0XHRcdGNhc2UgXCInXCI6XG5cdFx0XHRcdFx0XHRpZiAobG9va0FoZWFkKFwiJ1wiKSlcblx0XHRcdFx0XHRcdFx0Y2hhcnMgKz0gXCInXCI7XG5cdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdGxpdGVyYWwgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNoYXJzICs9IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCk7XG5cdFx0XHRcdH1cblx0XHRyZXR1cm4gY2hhcnM7XG5cdH0sXG5cblx0LyogR2V0IGEgc2V0dGluZyB2YWx1ZSwgZGVmYXVsdGluZyBpZiBuZWNlc3NhcnkuICovXG5cdF9nZXQ6IGZ1bmN0aW9uKGluc3QsIG5hbWUpIHtcblx0XHRyZXR1cm4gaW5zdC5zZXR0aW5nc1tuYW1lXSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdGluc3Quc2V0dGluZ3NbbmFtZV0gOiB0aGlzLl9kZWZhdWx0c1tuYW1lXTtcblx0fSxcblxuXHQvKiBQYXJzZSBleGlzdGluZyBkYXRlIGFuZCBpbml0aWFsaXNlIGRhdGUgcGlja2VyLiAqL1xuXHRfc2V0RGF0ZUZyb21GaWVsZDogZnVuY3Rpb24oaW5zdCwgbm9EZWZhdWx0KSB7XG5cdFx0aWYgKGluc3QuaW5wdXQudmFsKCkgPT0gaW5zdC5sYXN0VmFsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBkYXRlRm9ybWF0ID0gdGhpcy5fZ2V0KGluc3QsICdkYXRlRm9ybWF0Jyk7XG5cdFx0dmFyIGRhdGVzID0gaW5zdC5sYXN0VmFsID0gaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQudmFsKCkgOiBudWxsO1xuXHRcdHZhciBkYXRlLCBkZWZhdWx0RGF0ZTtcblx0XHRkYXRlID0gZGVmYXVsdERhdGUgPSB0aGlzLl9nZXREZWZhdWx0RGF0ZShpbnN0KTtcblx0XHR2YXIgc2V0dGluZ3MgPSB0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCk7XG5cdFx0dHJ5IHtcblx0XHRcdGRhdGUgPSB0aGlzLnBhcnNlRGF0ZShkYXRlRm9ybWF0LCBkYXRlcywgc2V0dGluZ3MpIHx8IGRlZmF1bHREYXRlO1xuXHRcdH0gY2F0Y2ggKGV2ZW50KSB7XG5cdFx0XHR0aGlzLmxvZyhldmVudCk7XG5cdFx0XHRkYXRlcyA9IChub0RlZmF1bHQgPyAnJyA6IGRhdGVzKTtcblx0XHR9XG5cdFx0aW5zdC5zZWxlY3RlZERheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHRcdGluc3QuZHJhd01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuXHRcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRpbnN0LmN1cnJlbnREYXkgPSAoZGF0ZXMgPyBkYXRlLmdldERhdGUoKSA6IDApO1xuXHRcdGluc3QuY3VycmVudE1vbnRoID0gKGRhdGVzID8gZGF0ZS5nZXRNb250aCgpIDogMCk7XG5cdFx0aW5zdC5jdXJyZW50WWVhciA9IChkYXRlcyA/IGRhdGUuZ2V0RnVsbFllYXIoKSA6IDApO1xuXHRcdHRoaXMuX2FkanVzdEluc3REYXRlKGluc3QpO1xuXHR9LFxuXG5cdC8qIFJldHJpZXZlIHRoZSBkZWZhdWx0IGRhdGUgc2hvd24gb24gb3BlbmluZy4gKi9cblx0X2dldERlZmF1bHREYXRlOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Jlc3RyaWN0TWluTWF4KGluc3QsXG5cdFx0XHR0aGlzLl9kZXRlcm1pbmVEYXRlKGluc3QsIHRoaXMuX2dldChpbnN0LCAnZGVmYXVsdERhdGUnKSwgbmV3IERhdGUoKSkpO1xuXHR9LFxuXG5cdC8qIEEgZGF0ZSBtYXkgYmUgc3BlY2lmaWVkIGFzIGFuIGV4YWN0IHZhbHVlIG9yIGEgcmVsYXRpdmUgb25lLiAqL1xuXHRfZGV0ZXJtaW5lRGF0ZTogZnVuY3Rpb24oaW5zdCwgZGF0ZSwgZGVmYXVsdERhdGUpIHtcblx0XHR2YXIgb2Zmc2V0TnVtZXJpYyA9IGZ1bmN0aW9uKG9mZnNldCkge1xuXHRcdFx0dmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0ZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgb2Zmc2V0KTtcblx0XHRcdHJldHVybiBkYXRlO1xuXHRcdH07XG5cdFx0dmFyIG9mZnNldFN0cmluZyA9IGZ1bmN0aW9uKG9mZnNldCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmV0dXJuICQuZGF0ZXBpY2tlci5wYXJzZURhdGUoJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ2RhdGVGb3JtYXQnKSxcblx0XHRcdFx0XHRvZmZzZXQsICQuZGF0ZXBpY2tlci5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpKTtcblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdC8vIElnbm9yZVxuXHRcdFx0fVxuXHRcdFx0dmFyIGRhdGUgPSAob2Zmc2V0LnRvTG93ZXJDYXNlKCkubWF0Y2goL15jLykgP1xuXHRcdFx0XHQkLmRhdGVwaWNrZXIuX2dldERhdGUoaW5zdCkgOiBudWxsKSB8fCBuZXcgRGF0ZSgpO1xuXHRcdFx0dmFyIHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHR2YXIgbW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG5cdFx0XHR2YXIgZGF5ID0gZGF0ZS5nZXREYXRlKCk7XG5cdFx0XHR2YXIgcGF0dGVybiA9IC8oWystXT9bMC05XSspXFxzKihkfER8d3xXfG18TXx5fFkpPy9nO1xuXHRcdFx0dmFyIG1hdGNoZXMgPSBwYXR0ZXJuLmV4ZWMob2Zmc2V0KTtcblx0XHRcdHdoaWxlIChtYXRjaGVzKSB7XG5cdFx0XHRcdHN3aXRjaCAobWF0Y2hlc1syXSB8fCAnZCcpIHtcblx0XHRcdFx0XHRjYXNlICdkJyA6IGNhc2UgJ0QnIDpcblx0XHRcdFx0XHRcdGRheSArPSBwYXJzZUludChtYXRjaGVzWzFdLDEwKTsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAndycgOiBjYXNlICdXJyA6XG5cdFx0XHRcdFx0XHRkYXkgKz0gcGFyc2VJbnQobWF0Y2hlc1sxXSwxMCkgKiA3OyBicmVhaztcblx0XHRcdFx0XHRjYXNlICdtJyA6IGNhc2UgJ00nIDpcblx0XHRcdFx0XHRcdG1vbnRoICs9IHBhcnNlSW50KG1hdGNoZXNbMV0sMTApO1xuXHRcdFx0XHRcdFx0ZGF5ID0gTWF0aC5taW4oZGF5LCAkLmRhdGVwaWNrZXIuX2dldERheXNJbk1vbnRoKHllYXIsIG1vbnRoKSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICd5JzogY2FzZSAnWScgOlxuXHRcdFx0XHRcdFx0eWVhciArPSBwYXJzZUludChtYXRjaGVzWzFdLDEwKTtcblx0XHRcdFx0XHRcdGRheSA9IE1hdGgubWluKGRheSwgJC5kYXRlcGlja2VyLl9nZXREYXlzSW5Nb250aCh5ZWFyLCBtb250aCkpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWF0Y2hlcyA9IHBhdHRlcm4uZXhlYyhvZmZzZXQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXkpO1xuXHRcdH07XG5cdFx0dmFyIG5ld0RhdGUgPSAoZGF0ZSA9PSBudWxsIHx8IGRhdGUgPT09ICcnID8gZGVmYXVsdERhdGUgOiAodHlwZW9mIGRhdGUgPT0gJ3N0cmluZycgPyBvZmZzZXRTdHJpbmcoZGF0ZSkgOlxuXHRcdFx0KHR5cGVvZiBkYXRlID09ICdudW1iZXInID8gKGlzTmFOKGRhdGUpID8gZGVmYXVsdERhdGUgOiBvZmZzZXROdW1lcmljKGRhdGUpKSA6IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKSkpKTtcblx0XHRuZXdEYXRlID0gKG5ld0RhdGUgJiYgbmV3RGF0ZS50b1N0cmluZygpID09ICdJbnZhbGlkIERhdGUnID8gZGVmYXVsdERhdGUgOiBuZXdEYXRlKTtcblx0XHRpZiAobmV3RGF0ZSkge1xuXHRcdFx0bmV3RGF0ZS5zZXRIb3VycygwKTtcblx0XHRcdG5ld0RhdGUuc2V0TWludXRlcygwKTtcblx0XHRcdG5ld0RhdGUuc2V0U2Vjb25kcygwKTtcblx0XHRcdG5ld0RhdGUuc2V0TWlsbGlzZWNvbmRzKDApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3RGF0ZSk7XG5cdH0sXG5cblx0LyogSGFuZGxlIHN3aXRjaCB0by9mcm9tIGRheWxpZ2h0IHNhdmluZy5cblx0ICAgSG91cnMgbWF5IGJlIG5vbi16ZXJvIG9uIGRheWxpZ2h0IHNhdmluZyBjdXQtb3Zlcjpcblx0ICAgPiAxMiB3aGVuIG1pZG5pZ2h0IGNoYW5nZW92ZXIsIGJ1dCB0aGVuIGNhbm5vdCBnZW5lcmF0ZVxuXHQgICBtaWRuaWdodCBkYXRldGltZSwgc28ganVtcCB0byAxQU0sIG90aGVyd2lzZSByZXNldC5cblx0ICAgQHBhcmFtICBkYXRlICAoRGF0ZSkgdGhlIGRhdGUgdG8gY2hlY2tcblx0ICAgQHJldHVybiAgKERhdGUpIHRoZSBjb3JyZWN0ZWQgZGF0ZSAqL1xuXHRfZGF5bGlnaHRTYXZpbmdBZGp1c3Q6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHRpZiAoIWRhdGUpIHJldHVybiBudWxsO1xuXHRcdGRhdGUuc2V0SG91cnMoZGF0ZS5nZXRIb3VycygpID4gMTIgPyBkYXRlLmdldEhvdXJzKCkgKyAyIDogMCk7XG5cdFx0cmV0dXJuIGRhdGU7XG5cdH0sXG5cblx0LyogU2V0IHRoZSBkYXRlKHMpIGRpcmVjdGx5LiAqL1xuXHRfc2V0RGF0ZTogZnVuY3Rpb24oaW5zdCwgZGF0ZSwgbm9DaGFuZ2UpIHtcblx0XHR2YXIgY2xlYXIgPSAhZGF0ZTtcblx0XHR2YXIgb3JpZ01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoO1xuXHRcdHZhciBvcmlnWWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyO1xuXHRcdHZhciBuZXdEYXRlID0gdGhpcy5fcmVzdHJpY3RNaW5NYXgoaW5zdCwgdGhpcy5fZGV0ZXJtaW5lRGF0ZShpbnN0LCBkYXRlLCBuZXcgRGF0ZSgpKSk7XG5cdFx0aW5zdC5zZWxlY3RlZERheSA9IGluc3QuY3VycmVudERheSA9IG5ld0RhdGUuZ2V0RGF0ZSgpO1xuXHRcdGluc3QuZHJhd01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoID0gaW5zdC5jdXJyZW50TW9udGggPSBuZXdEYXRlLmdldE1vbnRoKCk7XG5cdFx0aW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gaW5zdC5jdXJyZW50WWVhciA9IG5ld0RhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRpZiAoKG9yaWdNb250aCAhPSBpbnN0LnNlbGVjdGVkTW9udGggfHwgb3JpZ1llYXIgIT0gaW5zdC5zZWxlY3RlZFllYXIpICYmICFub0NoYW5nZSlcblx0XHRcdHRoaXMuX25vdGlmeUNoYW5nZShpbnN0KTtcblx0XHR0aGlzLl9hZGp1c3RJbnN0RGF0ZShpbnN0KTtcblx0XHRpZiAoaW5zdC5pbnB1dCkge1xuXHRcdFx0aW5zdC5pbnB1dC52YWwoY2xlYXIgPyAnJyA6IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCkpO1xuXHRcdH1cblx0fSxcblxuXHQvKiBSZXRyaWV2ZSB0aGUgZGF0ZShzKSBkaXJlY3RseS4gKi9cblx0X2dldERhdGU6IGZ1bmN0aW9uKGluc3QpIHtcblx0XHR2YXIgc3RhcnREYXRlID0gKCFpbnN0LmN1cnJlbnRZZWFyIHx8IChpbnN0LmlucHV0ICYmIGluc3QuaW5wdXQudmFsKCkgPT0gJycpID8gbnVsbCA6XG5cdFx0XHR0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShcblx0XHRcdGluc3QuY3VycmVudFllYXIsIGluc3QuY3VycmVudE1vbnRoLCBpbnN0LmN1cnJlbnREYXkpKSk7XG5cdFx0XHRyZXR1cm4gc3RhcnREYXRlO1xuXHR9LFxuXG5cdC8qIEF0dGFjaCB0aGUgb254eHggaGFuZGxlcnMuICBUaGVzZSBhcmUgZGVjbGFyZWQgc3RhdGljYWxseSBzb1xuXHQgKiB0aGV5IHdvcmsgd2l0aCBzdGF0aWMgY29kZSB0cmFuc2Zvcm1lcnMgbGlrZSBDYWphLlxuXHQgKi9cblx0X2F0dGFjaEhhbmRsZXJzOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0dmFyIHN0ZXBNb250aHMgPSB0aGlzLl9nZXQoaW5zdCwgJ3N0ZXBNb250aHMnKTtcblx0XHR2YXIgaWQgPSAnIycgKyBpbnN0LmlkLnJlcGxhY2UoIC9cXFxcXFxcXC9nLCBcIlxcXFxcIiApO1xuXHRcdGluc3QuZHBEaXYuZmluZCgnW2RhdGEtaGFuZGxlcl0nKS5tYXAoZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGhhbmRsZXIgPSB7XG5cdFx0XHRcdHByZXY6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR3aW5kb3dbJ0RQX2pRdWVyeV8nICsgZHB1dWlkXS5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGlkLCAtc3RlcE1vbnRocywgJ00nKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0bmV4dDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHdpbmRvd1snRFBfalF1ZXJ5XycgKyBkcHV1aWRdLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoaWQsICtzdGVwTW9udGhzLCAnTScpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRoaWRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0d2luZG93WydEUF9qUXVlcnlfJyArIGRwdXVpZF0uZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dG9kYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR3aW5kb3dbJ0RQX2pRdWVyeV8nICsgZHB1dWlkXS5kYXRlcGlja2VyLl9nb3RvVG9kYXkoaWQpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZWxlY3REYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR3aW5kb3dbJ0RQX2pRdWVyeV8nICsgZHB1dWlkXS5kYXRlcGlja2VyLl9zZWxlY3REYXkoaWQsICt0aGlzLmdldEF0dHJpYnV0ZSgnZGF0YS1tb250aCcpLCArdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEteWVhcicpLCB0aGlzKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNlbGVjdE1vbnRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0d2luZG93WydEUF9qUXVlcnlfJyArIGRwdXVpZF0uZGF0ZXBpY2tlci5fc2VsZWN0TW9udGhZZWFyKGlkLCB0aGlzLCAnTScpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2VsZWN0WWVhcjogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHdpbmRvd1snRFBfalF1ZXJ5XycgKyBkcHV1aWRdLmRhdGVwaWNrZXIuX3NlbGVjdE1vbnRoWWVhcihpZCwgdGhpcywgJ1knKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHQkKHRoaXMpLmJpbmQodGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtZXZlbnQnKSwgaGFuZGxlclt0aGlzLmdldEF0dHJpYnV0ZSgnZGF0YS1oYW5kbGVyJyldKTtcblx0XHR9KTtcblx0fSxcblxuXHQvKiBHZW5lcmF0ZSB0aGUgSFRNTCBmb3IgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGRhdGUgcGlja2VyLiAqL1xuXHRfZ2VuZXJhdGVIVE1MOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0dmFyIHRvZGF5ID0gbmV3IERhdGUoKTtcblx0XHR0b2RheSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KFxuXHRcdFx0bmV3IERhdGUodG9kYXkuZ2V0RnVsbFllYXIoKSwgdG9kYXkuZ2V0TW9udGgoKSwgdG9kYXkuZ2V0RGF0ZSgpKSk7IC8vIGNsZWFyIHRpbWVcblx0XHR2YXIgaXNSVEwgPSB0aGlzLl9nZXQoaW5zdCwgJ2lzUlRMJyk7XG5cdFx0dmFyIHNob3dCdXR0b25QYW5lbCA9IHRoaXMuX2dldChpbnN0LCAnc2hvd0J1dHRvblBhbmVsJyk7XG5cdFx0dmFyIGhpZGVJZk5vUHJldk5leHQgPSB0aGlzLl9nZXQoaW5zdCwgJ2hpZGVJZk5vUHJldk5leHQnKTtcblx0XHR2YXIgbmF2aWdhdGlvbkFzRGF0ZUZvcm1hdCA9IHRoaXMuX2dldChpbnN0LCAnbmF2aWdhdGlvbkFzRGF0ZUZvcm1hdCcpO1xuXHRcdHZhciBudW1Nb250aHMgPSB0aGlzLl9nZXROdW1iZXJPZk1vbnRocyhpbnN0KTtcblx0XHR2YXIgc2hvd0N1cnJlbnRBdFBvcyA9IHRoaXMuX2dldChpbnN0LCAnc2hvd0N1cnJlbnRBdFBvcycpO1xuXHRcdHZhciBzdGVwTW9udGhzID0gdGhpcy5fZ2V0KGluc3QsICdzdGVwTW9udGhzJyk7XG5cdFx0dmFyIGlzTXVsdGlNb250aCA9IChudW1Nb250aHNbMF0gIT0gMSB8fCBudW1Nb250aHNbMV0gIT0gMSk7XG5cdFx0dmFyIGN1cnJlbnREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoKCFpbnN0LmN1cnJlbnREYXkgPyBuZXcgRGF0ZSg5OTk5LCA5LCA5KSA6XG5cdFx0XHRuZXcgRGF0ZShpbnN0LmN1cnJlbnRZZWFyLCBpbnN0LmN1cnJlbnRNb250aCwgaW5zdC5jdXJyZW50RGF5KSkpO1xuXHRcdHZhciBtaW5EYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCAnbWluJyk7XG5cdFx0dmFyIG1heERhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsICdtYXgnKTtcblx0XHR2YXIgZHJhd01vbnRoID0gaW5zdC5kcmF3TW9udGggLSBzaG93Q3VycmVudEF0UG9zO1xuXHRcdHZhciBkcmF3WWVhciA9IGluc3QuZHJhd1llYXI7XG5cdFx0aWYgKGRyYXdNb250aCA8IDApIHtcblx0XHRcdGRyYXdNb250aCArPSAxMjtcblx0XHRcdGRyYXdZZWFyLS07XG5cdFx0fVxuXHRcdGlmIChtYXhEYXRlKSB7XG5cdFx0XHR2YXIgbWF4RHJhdyA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKG1heERhdGUuZ2V0RnVsbFllYXIoKSxcblx0XHRcdFx0bWF4RGF0ZS5nZXRNb250aCgpIC0gKG51bU1vbnRoc1swXSAqIG51bU1vbnRoc1sxXSkgKyAxLCBtYXhEYXRlLmdldERhdGUoKSkpO1xuXHRcdFx0bWF4RHJhdyA9IChtaW5EYXRlICYmIG1heERyYXcgPCBtaW5EYXRlID8gbWluRGF0ZSA6IG1heERyYXcpO1xuXHRcdFx0d2hpbGUgKHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRyYXdZZWFyLCBkcmF3TW9udGgsIDEpKSA+IG1heERyYXcpIHtcblx0XHRcdFx0ZHJhd01vbnRoLS07XG5cdFx0XHRcdGlmIChkcmF3TW9udGggPCAwKSB7XG5cdFx0XHRcdFx0ZHJhd01vbnRoID0gMTE7XG5cdFx0XHRcdFx0ZHJhd1llYXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpbnN0LmRyYXdNb250aCA9IGRyYXdNb250aDtcblx0XHRpbnN0LmRyYXdZZWFyID0gZHJhd1llYXI7XG5cdFx0dmFyIHByZXZUZXh0ID0gdGhpcy5fZ2V0KGluc3QsICdwcmV2VGV4dCcpO1xuXHRcdHByZXZUZXh0ID0gKCFuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0ID8gcHJldlRleHQgOiB0aGlzLmZvcm1hdERhdGUocHJldlRleHQsXG5cdFx0XHR0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShkcmF3WWVhciwgZHJhd01vbnRoIC0gc3RlcE1vbnRocywgMSkpLFxuXHRcdFx0dGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpKSk7XG5cdFx0dmFyIHByZXYgPSAodGhpcy5fY2FuQWRqdXN0TW9udGgoaW5zdCwgLTEsIGRyYXdZZWFyLCBkcmF3TW9udGgpID9cblx0XHRcdCc8YSBjbGFzcz1cInVpLWRhdGVwaWNrZXItcHJldiB1aS1jb3JuZXItYWxsXCIgZGF0YS1oYW5kbGVyPVwicHJldlwiIGRhdGEtZXZlbnQ9XCJjbGlja1wiJyArXG5cdFx0XHQnIHRpdGxlPVwiJyArIHByZXZUZXh0ICsgJ1wiPjxzcGFuIGNsYXNzPVwidWktaWNvbiB1aS1pY29uLWNpcmNsZS10cmlhbmdsZS0nICsgKCBpc1JUTCA/ICdlJyA6ICd3JykgKyAnXCI+JyArIHByZXZUZXh0ICsgJzwvc3Bhbj48L2E+JyA6XG5cdFx0XHQoaGlkZUlmTm9QcmV2TmV4dCA/ICcnIDogJzxhIGNsYXNzPVwidWktZGF0ZXBpY2tlci1wcmV2IHVpLWNvcm5lci1hbGwgdWktc3RhdGUtZGlzYWJsZWRcIiB0aXRsZT1cIicrIHByZXZUZXh0ICsnXCI+PHNwYW4gY2xhc3M9XCJ1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLScgKyAoIGlzUlRMID8gJ2UnIDogJ3cnKSArICdcIj4nICsgcHJldlRleHQgKyAnPC9zcGFuPjwvYT4nKSk7XG5cdFx0dmFyIG5leHRUZXh0ID0gdGhpcy5fZ2V0KGluc3QsICduZXh0VGV4dCcpO1xuXHRcdG5leHRUZXh0ID0gKCFuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0ID8gbmV4dFRleHQgOiB0aGlzLmZvcm1hdERhdGUobmV4dFRleHQsXG5cdFx0XHR0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShkcmF3WWVhciwgZHJhd01vbnRoICsgc3RlcE1vbnRocywgMSkpLFxuXHRcdFx0dGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpKSk7XG5cdFx0dmFyIG5leHQgPSAodGhpcy5fY2FuQWRqdXN0TW9udGgoaW5zdCwgKzEsIGRyYXdZZWFyLCBkcmF3TW9udGgpID9cblx0XHRcdCc8YSBjbGFzcz1cInVpLWRhdGVwaWNrZXItbmV4dCB1aS1jb3JuZXItYWxsXCIgZGF0YS1oYW5kbGVyPVwibmV4dFwiIGRhdGEtZXZlbnQ9XCJjbGlja1wiJyArXG5cdFx0XHQnIHRpdGxlPVwiJyArIG5leHRUZXh0ICsgJ1wiPjxzcGFuIGNsYXNzPVwidWktaWNvbiB1aS1pY29uLWNpcmNsZS10cmlhbmdsZS0nICsgKCBpc1JUTCA/ICd3JyA6ICdlJykgKyAnXCI+JyArIG5leHRUZXh0ICsgJzwvc3Bhbj48L2E+JyA6XG5cdFx0XHQoaGlkZUlmTm9QcmV2TmV4dCA/ICcnIDogJzxhIGNsYXNzPVwidWktZGF0ZXBpY2tlci1uZXh0IHVpLWNvcm5lci1hbGwgdWktc3RhdGUtZGlzYWJsZWRcIiB0aXRsZT1cIicrIG5leHRUZXh0ICsgJ1wiPjxzcGFuIGNsYXNzPVwidWktaWNvbiB1aS1pY29uLWNpcmNsZS10cmlhbmdsZS0nICsgKCBpc1JUTCA/ICd3JyA6ICdlJykgKyAnXCI+JyArIG5leHRUZXh0ICsgJzwvc3Bhbj48L2E+JykpO1xuXHRcdHZhciBjdXJyZW50VGV4dCA9IHRoaXMuX2dldChpbnN0LCAnY3VycmVudFRleHQnKTtcblx0XHR2YXIgZ290b0RhdGUgPSAodGhpcy5fZ2V0KGluc3QsICdnb3RvQ3VycmVudCcpICYmIGluc3QuY3VycmVudERheSA/IGN1cnJlbnREYXRlIDogdG9kYXkpO1xuXHRcdGN1cnJlbnRUZXh0ID0gKCFuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0ID8gY3VycmVudFRleHQgOlxuXHRcdFx0dGhpcy5mb3JtYXREYXRlKGN1cnJlbnRUZXh0LCBnb3RvRGF0ZSwgdGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpKSk7XG5cdFx0dmFyIGNvbnRyb2xzID0gKCFpbnN0LmlubGluZSA/ICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cInVpLWRhdGVwaWNrZXItY2xvc2UgdWktc3RhdGUtZGVmYXVsdCB1aS1wcmlvcml0eS1wcmltYXJ5IHVpLWNvcm5lci1hbGxcIiBkYXRhLWhhbmRsZXI9XCJoaWRlXCIgZGF0YS1ldmVudD1cImNsaWNrXCI+JyArXG5cdFx0XHR0aGlzLl9nZXQoaW5zdCwgJ2Nsb3NlVGV4dCcpICsgJzwvYnV0dG9uPicgOiAnJyk7XG5cdFx0dmFyIGJ1dHRvblBhbmVsID0gKHNob3dCdXR0b25QYW5lbCkgPyAnPGRpdiBjbGFzcz1cInVpLWRhdGVwaWNrZXItYnV0dG9ucGFuZSB1aS13aWRnZXQtY29udGVudFwiPicgKyAoaXNSVEwgPyBjb250cm9scyA6ICcnKSArXG5cdFx0XHQodGhpcy5faXNJblJhbmdlKGluc3QsIGdvdG9EYXRlKSA/ICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cInVpLWRhdGVwaWNrZXItY3VycmVudCB1aS1zdGF0ZS1kZWZhdWx0IHVpLXByaW9yaXR5LXNlY29uZGFyeSB1aS1jb3JuZXItYWxsXCIgZGF0YS1oYW5kbGVyPVwidG9kYXlcIiBkYXRhLWV2ZW50PVwiY2xpY2tcIicgK1xuXHRcdFx0Jz4nICsgY3VycmVudFRleHQgKyAnPC9idXR0b24+JyA6ICcnKSArIChpc1JUTCA/ICcnIDogY29udHJvbHMpICsgJzwvZGl2PicgOiAnJztcblx0XHR2YXIgZmlyc3REYXkgPSBwYXJzZUludCh0aGlzLl9nZXQoaW5zdCwgJ2ZpcnN0RGF5JyksMTApO1xuXHRcdGZpcnN0RGF5ID0gKGlzTmFOKGZpcnN0RGF5KSA/IDAgOiBmaXJzdERheSk7XG5cdFx0dmFyIHNob3dXZWVrID0gdGhpcy5fZ2V0KGluc3QsICdzaG93V2VlaycpO1xuXHRcdHZhciBkYXlOYW1lcyA9IHRoaXMuX2dldChpbnN0LCAnZGF5TmFtZXMnKTtcblx0XHR2YXIgZGF5TmFtZXNTaG9ydCA9IHRoaXMuX2dldChpbnN0LCAnZGF5TmFtZXNTaG9ydCcpO1xuXHRcdHZhciBkYXlOYW1lc01pbiA9IHRoaXMuX2dldChpbnN0LCAnZGF5TmFtZXNNaW4nKTtcblx0XHR2YXIgbW9udGhOYW1lcyA9IHRoaXMuX2dldChpbnN0LCAnbW9udGhOYW1lcycpO1xuXHRcdHZhciBtb250aE5hbWVzU2hvcnQgPSB0aGlzLl9nZXQoaW5zdCwgJ21vbnRoTmFtZXNTaG9ydCcpO1xuXHRcdHZhciBiZWZvcmVTaG93RGF5ID0gdGhpcy5fZ2V0KGluc3QsICdiZWZvcmVTaG93RGF5Jyk7XG5cdFx0dmFyIHNob3dPdGhlck1vbnRocyA9IHRoaXMuX2dldChpbnN0LCAnc2hvd090aGVyTW9udGhzJyk7XG5cdFx0dmFyIHNlbGVjdE90aGVyTW9udGhzID0gdGhpcy5fZ2V0KGluc3QsICdzZWxlY3RPdGhlck1vbnRocycpO1xuXHRcdHZhciBjYWxjdWxhdGVXZWVrID0gdGhpcy5fZ2V0KGluc3QsICdjYWxjdWxhdGVXZWVrJykgfHwgdGhpcy5pc284NjAxV2Vlaztcblx0XHR2YXIgZGVmYXVsdERhdGUgPSB0aGlzLl9nZXREZWZhdWx0RGF0ZShpbnN0KTtcblx0XHR2YXIgaHRtbCA9ICcnO1xuXHRcdGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG51bU1vbnRoc1swXTsgcm93KyspIHtcblx0XHRcdHZhciBncm91cCA9ICcnO1xuXHRcdFx0dGhpcy5tYXhSb3dzID0gNDtcblx0XHRcdGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG51bU1vbnRoc1sxXTsgY29sKyspIHtcblx0XHRcdFx0dmFyIHNlbGVjdGVkRGF0ZSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRyYXdZZWFyLCBkcmF3TW9udGgsIGluc3Quc2VsZWN0ZWREYXkpKTtcblx0XHRcdFx0dmFyIGNvcm5lckNsYXNzID0gJyB1aS1jb3JuZXItYWxsJztcblx0XHRcdFx0dmFyIGNhbGVuZGVyID0gJyc7XG5cdFx0XHRcdGlmIChpc011bHRpTW9udGgpIHtcblx0XHRcdFx0XHRjYWxlbmRlciArPSAnPGRpdiBjbGFzcz1cInVpLWRhdGVwaWNrZXItZ3JvdXAnO1xuXHRcdFx0XHRcdGlmIChudW1Nb250aHNbMV0gPiAxKVxuXHRcdFx0XHRcdFx0c3dpdGNoIChjb2wpIHtcblx0XHRcdFx0XHRcdFx0Y2FzZSAwOiBjYWxlbmRlciArPSAnIHVpLWRhdGVwaWNrZXItZ3JvdXAtZmlyc3QnO1xuXHRcdFx0XHRcdFx0XHRcdGNvcm5lckNsYXNzID0gJyB1aS1jb3JuZXItJyArIChpc1JUTCA/ICdyaWdodCcgOiAnbGVmdCcpOyBicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSBudW1Nb250aHNbMV0tMTogY2FsZW5kZXIgKz0gJyB1aS1kYXRlcGlja2VyLWdyb3VwLWxhc3QnO1xuXHRcdFx0XHRcdFx0XHRcdGNvcm5lckNsYXNzID0gJyB1aS1jb3JuZXItJyArIChpc1JUTCA/ICdsZWZ0JyA6ICdyaWdodCcpOyBicmVhaztcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDogY2FsZW5kZXIgKz0gJyB1aS1kYXRlcGlja2VyLWdyb3VwLW1pZGRsZSc7IGNvcm5lckNsYXNzID0gJyc7IGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhbGVuZGVyICs9ICdcIj4nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGVuZGVyICs9ICc8ZGl2IGNsYXNzPVwidWktZGF0ZXBpY2tlci1oZWFkZXIgdWktd2lkZ2V0LWhlYWRlciB1aS1oZWxwZXItY2xlYXJmaXgnICsgY29ybmVyQ2xhc3MgKyAnXCI+JyArXG5cdFx0XHRcdFx0KC9hbGx8bGVmdC8udGVzdChjb3JuZXJDbGFzcykgJiYgcm93ID09IDAgPyAoaXNSVEwgPyBuZXh0IDogcHJldikgOiAnJykgK1xuXHRcdFx0XHRcdCgvYWxsfHJpZ2h0Ly50ZXN0KGNvcm5lckNsYXNzKSAmJiByb3cgPT0gMCA/IChpc1JUTCA/IHByZXYgOiBuZXh0KSA6ICcnKSArXG5cdFx0XHRcdFx0dGhpcy5fZ2VuZXJhdGVNb250aFllYXJIZWFkZXIoaW5zdCwgZHJhd01vbnRoLCBkcmF3WWVhciwgbWluRGF0ZSwgbWF4RGF0ZSxcblx0XHRcdFx0XHRyb3cgPiAwIHx8IGNvbCA+IDAsIG1vbnRoTmFtZXMsIG1vbnRoTmFtZXNTaG9ydCkgKyAvLyBkcmF3IG1vbnRoIGhlYWRlcnNcblx0XHRcdFx0XHQnPC9kaXY+PHRhYmxlIGNsYXNzPVwidWktZGF0ZXBpY2tlci1jYWxlbmRhclwiPjx0aGVhZD4nICtcblx0XHRcdFx0XHQnPHRyPic7XG5cdFx0XHRcdHZhciB0aGVhZCA9IChzaG93V2VlayA/ICc8dGggY2xhc3M9XCJ1aS1kYXRlcGlja2VyLXdlZWstY29sXCI+JyArIHRoaXMuX2dldChpbnN0LCAnd2Vla0hlYWRlcicpICsgJzwvdGg+JyA6ICcnKTtcblx0XHRcdFx0Zm9yICh2YXIgZG93ID0gMDsgZG93IDwgNzsgZG93KyspIHsgLy8gZGF5cyBvZiB0aGUgd2Vla1xuXHRcdFx0XHRcdHZhciBkYXkgPSAoZG93ICsgZmlyc3REYXkpICUgNztcblx0XHRcdFx0XHR0aGVhZCArPSAnPHRoJyArICgoZG93ICsgZmlyc3REYXkgKyA2KSAlIDcgPj0gNSA/ICcgY2xhc3M9XCJ1aS1kYXRlcGlja2VyLXdlZWstZW5kXCInIDogJycpICsgJz4nICtcblx0XHRcdFx0XHRcdCc8c3BhbiB0aXRsZT1cIicgKyBkYXlOYW1lc1tkYXldICsgJ1wiPicgKyBkYXlOYW1lc01pbltkYXldICsgJzwvc3Bhbj48L3RoPic7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsZW5kZXIgKz0gdGhlYWQgKyAnPC90cj48L3RoZWFkPjx0Ym9keT4nO1xuXHRcdFx0XHR2YXIgZGF5c0luTW9udGggPSB0aGlzLl9nZXREYXlzSW5Nb250aChkcmF3WWVhciwgZHJhd01vbnRoKTtcblx0XHRcdFx0aWYgKGRyYXdZZWFyID09IGluc3Quc2VsZWN0ZWRZZWFyICYmIGRyYXdNb250aCA9PSBpbnN0LnNlbGVjdGVkTW9udGgpXG5cdFx0XHRcdFx0aW5zdC5zZWxlY3RlZERheSA9IE1hdGgubWluKGluc3Quc2VsZWN0ZWREYXksIGRheXNJbk1vbnRoKTtcblx0XHRcdFx0dmFyIGxlYWREYXlzID0gKHRoaXMuX2dldEZpcnN0RGF5T2ZNb250aChkcmF3WWVhciwgZHJhd01vbnRoKSAtIGZpcnN0RGF5ICsgNykgJSA3O1xuXHRcdFx0XHR2YXIgY3VyUm93cyA9IE1hdGguY2VpbCgobGVhZERheXMgKyBkYXlzSW5Nb250aCkgLyA3KTsgLy8gY2FsY3VsYXRlIHRoZSBudW1iZXIgb2Ygcm93cyB0byBnZW5lcmF0ZVxuXHRcdFx0XHR2YXIgbnVtUm93cyA9IChpc011bHRpTW9udGggPyB0aGlzLm1heFJvd3MgPiBjdXJSb3dzID8gdGhpcy5tYXhSb3dzIDogY3VyUm93cyA6IGN1clJvd3MpOyAvL0lmIG11bHRpcGxlIG1vbnRocywgdXNlIHRoZSBoaWdoZXIgbnVtYmVyIG9mIHJvd3MgKHNlZSAjNzA0Mylcblx0XHRcdFx0dGhpcy5tYXhSb3dzID0gbnVtUm93cztcblx0XHRcdFx0dmFyIHByaW50RGF0ZSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRyYXdZZWFyLCBkcmF3TW9udGgsIDEgLSBsZWFkRGF5cykpO1xuXHRcdFx0XHRmb3IgKHZhciBkUm93ID0gMDsgZFJvdyA8IG51bVJvd3M7IGRSb3crKykgeyAvLyBjcmVhdGUgZGF0ZSBwaWNrZXIgcm93c1xuXHRcdFx0XHRcdGNhbGVuZGVyICs9ICc8dHI+Jztcblx0XHRcdFx0XHR2YXIgdGJvZHkgPSAoIXNob3dXZWVrID8gJycgOiAnPHRkIGNsYXNzPVwidWktZGF0ZXBpY2tlci13ZWVrLWNvbFwiPicgK1xuXHRcdFx0XHRcdFx0dGhpcy5fZ2V0KGluc3QsICdjYWxjdWxhdGVXZWVrJykocHJpbnREYXRlKSArICc8L3RkPicpO1xuXHRcdFx0XHRcdGZvciAodmFyIGRvdyA9IDA7IGRvdyA8IDc7IGRvdysrKSB7IC8vIGNyZWF0ZSBkYXRlIHBpY2tlciBkYXlzXG5cdFx0XHRcdFx0XHR2YXIgZGF5U2V0dGluZ3MgPSAoYmVmb3JlU2hvd0RheSA/XG5cdFx0XHRcdFx0XHRcdGJlZm9yZVNob3dEYXkuYXBwbHkoKGluc3QuaW5wdXQgPyBpbnN0LmlucHV0WzBdIDogbnVsbCksIFtwcmludERhdGVdKSA6IFt0cnVlLCAnJ10pO1xuXHRcdFx0XHRcdFx0dmFyIG90aGVyTW9udGggPSAocHJpbnREYXRlLmdldE1vbnRoKCkgIT0gZHJhd01vbnRoKTtcblx0XHRcdFx0XHRcdHZhciB1bnNlbGVjdGFibGUgPSAob3RoZXJNb250aCAmJiAhc2VsZWN0T3RoZXJNb250aHMpIHx8ICFkYXlTZXR0aW5nc1swXSB8fFxuXHRcdFx0XHRcdFx0XHQobWluRGF0ZSAmJiBwcmludERhdGUgPCBtaW5EYXRlKSB8fCAobWF4RGF0ZSAmJiBwcmludERhdGUgPiBtYXhEYXRlKTtcblx0XHRcdFx0XHRcdHRib2R5ICs9ICc8dGQgY2xhc3M9XCInICtcblx0XHRcdFx0XHRcdFx0KChkb3cgKyBmaXJzdERheSArIDYpICUgNyA+PSA1ID8gJyB1aS1kYXRlcGlja2VyLXdlZWstZW5kJyA6ICcnKSArIC8vIGhpZ2hsaWdodCB3ZWVrZW5kc1xuXHRcdFx0XHRcdFx0XHQob3RoZXJNb250aCA/ICcgdWktZGF0ZXBpY2tlci1vdGhlci1tb250aCcgOiAnJykgKyAvLyBoaWdobGlnaHQgZGF5cyBmcm9tIG90aGVyIG1vbnRoc1xuXHRcdFx0XHRcdFx0XHQoKHByaW50RGF0ZS5nZXRUaW1lKCkgPT0gc2VsZWN0ZWREYXRlLmdldFRpbWUoKSAmJiBkcmF3TW9udGggPT0gaW5zdC5zZWxlY3RlZE1vbnRoICYmIGluc3QuX2tleUV2ZW50KSB8fCAvLyB1c2VyIHByZXNzZWQga2V5XG5cdFx0XHRcdFx0XHRcdChkZWZhdWx0RGF0ZS5nZXRUaW1lKCkgPT0gcHJpbnREYXRlLmdldFRpbWUoKSAmJiBkZWZhdWx0RGF0ZS5nZXRUaW1lKCkgPT0gc2VsZWN0ZWREYXRlLmdldFRpbWUoKSkgP1xuXHRcdFx0XHRcdFx0XHQvLyBvciBkZWZhdWx0RGF0ZSBpcyBjdXJyZW50IHByaW50ZWREYXRlIGFuZCBkZWZhdWx0RGF0ZSBpcyBzZWxlY3RlZERhdGVcblx0XHRcdFx0XHRcdFx0JyAnICsgdGhpcy5fZGF5T3ZlckNsYXNzIDogJycpICsgLy8gaGlnaGxpZ2h0IHNlbGVjdGVkIGRheVxuXHRcdFx0XHRcdFx0XHQodW5zZWxlY3RhYmxlID8gJyAnICsgdGhpcy5fdW5zZWxlY3RhYmxlQ2xhc3MgKyAnIHVpLXN0YXRlLWRpc2FibGVkJzogJycpICsgIC8vIGhpZ2hsaWdodCB1bnNlbGVjdGFibGUgZGF5c1xuXHRcdFx0XHRcdFx0XHQob3RoZXJNb250aCAmJiAhc2hvd090aGVyTW9udGhzID8gJycgOiAnICcgKyBkYXlTZXR0aW5nc1sxXSArIC8vIGhpZ2hsaWdodCBjdXN0b20gZGF0ZXNcblx0XHRcdFx0XHRcdFx0KHByaW50RGF0ZS5nZXRUaW1lKCkgPT0gY3VycmVudERhdGUuZ2V0VGltZSgpID8gJyAnICsgdGhpcy5fY3VycmVudENsYXNzIDogJycpICsgLy8gaGlnaGxpZ2h0IHNlbGVjdGVkIGRheVxuXHRcdFx0XHRcdFx0XHQocHJpbnREYXRlLmdldFRpbWUoKSA9PSB0b2RheS5nZXRUaW1lKCkgPyAnIHVpLWRhdGVwaWNrZXItdG9kYXknIDogJycpKSArICdcIicgKyAvLyBoaWdobGlnaHQgdG9kYXkgKGlmIGRpZmZlcmVudClcblx0XHRcdFx0XHRcdFx0KCghb3RoZXJNb250aCB8fCBzaG93T3RoZXJNb250aHMpICYmIGRheVNldHRpbmdzWzJdID8gJyB0aXRsZT1cIicgKyBkYXlTZXR0aW5nc1syXSArICdcIicgOiAnJykgKyAvLyBjZWxsIHRpdGxlXG5cdFx0XHRcdFx0XHRcdCh1bnNlbGVjdGFibGUgPyAnJyA6ICcgZGF0YS1oYW5kbGVyPVwic2VsZWN0RGF5XCIgZGF0YS1ldmVudD1cImNsaWNrXCIgZGF0YS1tb250aD1cIicgKyBwcmludERhdGUuZ2V0TW9udGgoKSArICdcIiBkYXRhLXllYXI9XCInICsgcHJpbnREYXRlLmdldEZ1bGxZZWFyKCkgKyAnXCInKSArICc+JyArIC8vIGFjdGlvbnNcblx0XHRcdFx0XHRcdFx0KG90aGVyTW9udGggJiYgIXNob3dPdGhlck1vbnRocyA/ICcmI3hhMDsnIDogLy8gZGlzcGxheSBmb3Igb3RoZXIgbW9udGhzXG5cdFx0XHRcdFx0XHRcdCh1bnNlbGVjdGFibGUgPyAnPHNwYW4gY2xhc3M9XCJ1aS1zdGF0ZS1kZWZhdWx0XCI+JyArIHByaW50RGF0ZS5nZXREYXRlKCkgKyAnPC9zcGFuPicgOiAnPGEgY2xhc3M9XCJ1aS1zdGF0ZS1kZWZhdWx0JyArXG5cdFx0XHRcdFx0XHRcdChwcmludERhdGUuZ2V0VGltZSgpID09IHRvZGF5LmdldFRpbWUoKSA/ICcgdWktc3RhdGUtaGlnaGxpZ2h0JyA6ICcnKSArXG5cdFx0XHRcdFx0XHRcdChwcmludERhdGUuZ2V0VGltZSgpID09IGN1cnJlbnREYXRlLmdldFRpbWUoKSA/ICcgdWktc3RhdGUtYWN0aXZlJyA6ICcnKSArIC8vIGhpZ2hsaWdodCBzZWxlY3RlZCBkYXlcblx0XHRcdFx0XHRcdFx0KG90aGVyTW9udGggPyAnIHVpLXByaW9yaXR5LXNlY29uZGFyeScgOiAnJykgKyAvLyBkaXN0aW5ndWlzaCBkYXRlcyBmcm9tIG90aGVyIG1vbnRoc1xuXHRcdFx0XHRcdFx0XHQnXCIgaHJlZj1cIiNcIj4nICsgcHJpbnREYXRlLmdldERhdGUoKSArICc8L2E+JykpICsgJzwvdGQ+JzsgLy8gZGlzcGxheSBzZWxlY3RhYmxlIGRhdGVcblx0XHRcdFx0XHRcdHByaW50RGF0ZS5zZXREYXRlKHByaW50RGF0ZS5nZXREYXRlKCkgKyAxKTtcblx0XHRcdFx0XHRcdHByaW50RGF0ZSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KHByaW50RGF0ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhbGVuZGVyICs9IHRib2R5ICsgJzwvdHI+Jztcblx0XHRcdFx0fVxuXHRcdFx0XHRkcmF3TW9udGgrKztcblx0XHRcdFx0aWYgKGRyYXdNb250aCA+IDExKSB7XG5cdFx0XHRcdFx0ZHJhd01vbnRoID0gMDtcblx0XHRcdFx0XHRkcmF3WWVhcisrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGVuZGVyICs9ICc8L3Rib2R5PjwvdGFibGU+JyArIChpc011bHRpTW9udGggPyAnPC9kaXY+JyArXG5cdFx0XHRcdFx0XHRcdCgobnVtTW9udGhzWzBdID4gMCAmJiBjb2wgPT0gbnVtTW9udGhzWzFdLTEpID8gJzxkaXYgY2xhc3M9XCJ1aS1kYXRlcGlja2VyLXJvdy1icmVha1wiPjwvZGl2PicgOiAnJykgOiAnJyk7XG5cdFx0XHRcdGdyb3VwICs9IGNhbGVuZGVyO1xuXHRcdFx0fVxuXHRcdFx0aHRtbCArPSBncm91cDtcblx0XHR9XG5cdFx0aHRtbCArPSBidXR0b25QYW5lbCArICgkLnVpLmllNiAmJiAhaW5zdC5pbmxpbmUgP1xuXHRcdFx0JzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDpmYWxzZTtcIiBjbGFzcz1cInVpLWRhdGVwaWNrZXItY292ZXJcIiBmcmFtZWJvcmRlcj1cIjBcIj48L2lmcmFtZT4nIDogJycpO1xuXHRcdGluc3QuX2tleUV2ZW50ID0gZmFsc2U7XG5cdFx0cmV0dXJuIGh0bWw7XG5cdH0sXG5cblx0LyogR2VuZXJhdGUgdGhlIG1vbnRoIGFuZCB5ZWFyIGhlYWRlci4gKi9cblx0X2dlbmVyYXRlTW9udGhZZWFySGVhZGVyOiBmdW5jdGlvbihpbnN0LCBkcmF3TW9udGgsIGRyYXdZZWFyLCBtaW5EYXRlLCBtYXhEYXRlLFxuXHRcdFx0c2Vjb25kYXJ5LCBtb250aE5hbWVzLCBtb250aE5hbWVzU2hvcnQpIHtcblx0XHR2YXIgY2hhbmdlTW9udGggPSB0aGlzLl9nZXQoaW5zdCwgJ2NoYW5nZU1vbnRoJyk7XG5cdFx0dmFyIGNoYW5nZVllYXIgPSB0aGlzLl9nZXQoaW5zdCwgJ2NoYW5nZVllYXInKTtcblx0XHR2YXIgc2hvd01vbnRoQWZ0ZXJZZWFyID0gdGhpcy5fZ2V0KGluc3QsICdzaG93TW9udGhBZnRlclllYXInKTtcblx0XHR2YXIgaHRtbCA9ICc8ZGl2IGNsYXNzPVwidWktZGF0ZXBpY2tlci10aXRsZVwiPic7XG5cdFx0dmFyIG1vbnRoSHRtbCA9ICcnO1xuXHRcdC8vIG1vbnRoIHNlbGVjdGlvblxuXHRcdGlmIChzZWNvbmRhcnkgfHwgIWNoYW5nZU1vbnRoKVxuXHRcdFx0bW9udGhIdG1sICs9ICc8c3BhbiBjbGFzcz1cInVpLWRhdGVwaWNrZXItbW9udGhcIj4nICsgbW9udGhOYW1lc1tkcmF3TW9udGhdICsgJzwvc3Bhbj4nO1xuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIGluTWluWWVhciA9IChtaW5EYXRlICYmIG1pbkRhdGUuZ2V0RnVsbFllYXIoKSA9PSBkcmF3WWVhcik7XG5cdFx0XHR2YXIgaW5NYXhZZWFyID0gKG1heERhdGUgJiYgbWF4RGF0ZS5nZXRGdWxsWWVhcigpID09IGRyYXdZZWFyKTtcblx0XHRcdG1vbnRoSHRtbCArPSAnPHNlbGVjdCBjbGFzcz1cInVpLWRhdGVwaWNrZXItbW9udGhcIiBkYXRhLWhhbmRsZXI9XCJzZWxlY3RNb250aFwiIGRhdGEtZXZlbnQ9XCJjaGFuZ2VcIj4nO1xuXHRcdFx0Zm9yICh2YXIgbW9udGggPSAwOyBtb250aCA8IDEyOyBtb250aCsrKSB7XG5cdFx0XHRcdGlmICgoIWluTWluWWVhciB8fCBtb250aCA+PSBtaW5EYXRlLmdldE1vbnRoKCkpICYmXG5cdFx0XHRcdFx0XHQoIWluTWF4WWVhciB8fCBtb250aCA8PSBtYXhEYXRlLmdldE1vbnRoKCkpKVxuXHRcdFx0XHRcdG1vbnRoSHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIicgKyBtb250aCArICdcIicgK1xuXHRcdFx0XHRcdFx0KG1vbnRoID09IGRyYXdNb250aCA/ICcgc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiJyA6ICcnKSArXG5cdFx0XHRcdFx0XHQnPicgKyBtb250aE5hbWVzU2hvcnRbbW9udGhdICsgJzwvb3B0aW9uPic7XG5cdFx0XHR9XG5cdFx0XHRtb250aEh0bWwgKz0gJzwvc2VsZWN0Pic7XG5cdFx0fVxuXHRcdGlmICghc2hvd01vbnRoQWZ0ZXJZZWFyKVxuXHRcdFx0aHRtbCArPSBtb250aEh0bWwgKyAoc2Vjb25kYXJ5IHx8ICEoY2hhbmdlTW9udGggJiYgY2hhbmdlWWVhcikgPyAnJiN4YTA7JyA6ICcnKTtcblx0XHQvLyB5ZWFyIHNlbGVjdGlvblxuXHRcdGlmICggIWluc3QueWVhcnNodG1sICkge1xuXHRcdFx0aW5zdC55ZWFyc2h0bWwgPSAnJztcblx0XHRcdGlmIChzZWNvbmRhcnkgfHwgIWNoYW5nZVllYXIpXG5cdFx0XHRcdGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwidWktZGF0ZXBpY2tlci15ZWFyXCI+JyArIGRyYXdZZWFyICsgJzwvc3Bhbj4nO1xuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIGRldGVybWluZSByYW5nZSBvZiB5ZWFycyB0byBkaXNwbGF5XG5cdFx0XHRcdHZhciB5ZWFycyA9IHRoaXMuX2dldChpbnN0LCAneWVhclJhbmdlJykuc3BsaXQoJzonKTtcblx0XHRcdFx0dmFyIHRoaXNZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXHRcdFx0XHR2YXIgZGV0ZXJtaW5lWWVhciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdFx0dmFyIHllYXIgPSAodmFsdWUubWF0Y2goL2NbKy1dLiovKSA/IGRyYXdZZWFyICsgcGFyc2VJbnQodmFsdWUuc3Vic3RyaW5nKDEpLCAxMCkgOlxuXHRcdFx0XHRcdFx0KHZhbHVlLm1hdGNoKC9bKy1dLiovKSA/IHRoaXNZZWFyICsgcGFyc2VJbnQodmFsdWUsIDEwKSA6XG5cdFx0XHRcdFx0XHRwYXJzZUludCh2YWx1ZSwgMTApKSk7XG5cdFx0XHRcdFx0cmV0dXJuIChpc05hTih5ZWFyKSA/IHRoaXNZZWFyIDogeWVhcik7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHZhciB5ZWFyID0gZGV0ZXJtaW5lWWVhcih5ZWFyc1swXSk7XG5cdFx0XHRcdHZhciBlbmRZZWFyID0gTWF0aC5tYXgoeWVhciwgZGV0ZXJtaW5lWWVhcih5ZWFyc1sxXSB8fCAnJykpO1xuXHRcdFx0XHR5ZWFyID0gKG1pbkRhdGUgPyBNYXRoLm1heCh5ZWFyLCBtaW5EYXRlLmdldEZ1bGxZZWFyKCkpIDogeWVhcik7XG5cdFx0XHRcdGVuZFllYXIgPSAobWF4RGF0ZSA/IE1hdGgubWluKGVuZFllYXIsIG1heERhdGUuZ2V0RnVsbFllYXIoKSkgOiBlbmRZZWFyKTtcblx0XHRcdFx0aW5zdC55ZWFyc2h0bWwgKz0gJzxzZWxlY3QgY2xhc3M9XCJ1aS1kYXRlcGlja2VyLXllYXJcIiBkYXRhLWhhbmRsZXI9XCJzZWxlY3RZZWFyXCIgZGF0YS1ldmVudD1cImNoYW5nZVwiPic7XG5cdFx0XHRcdGZvciAoOyB5ZWFyIDw9IGVuZFllYXI7IHllYXIrKykge1xuXHRcdFx0XHRcdGluc3QueWVhcnNodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArIHllYXIgKyAnXCInICtcblx0XHRcdFx0XHRcdCh5ZWFyID09IGRyYXdZZWFyID8gJyBzZWxlY3RlZD1cInNlbGVjdGVkXCInIDogJycpICtcblx0XHRcdFx0XHRcdCc+JyArIHllYXIgKyAnPC9vcHRpb24+Jztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbnN0LnllYXJzaHRtbCArPSAnPC9zZWxlY3Q+JztcblxuXHRcdFx0XHRodG1sICs9IGluc3QueWVhcnNodG1sO1xuXHRcdFx0XHRpbnN0LnllYXJzaHRtbCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGh0bWwgKz0gdGhpcy5fZ2V0KGluc3QsICd5ZWFyU3VmZml4Jyk7XG5cdFx0aWYgKHNob3dNb250aEFmdGVyWWVhcilcblx0XHRcdGh0bWwgKz0gKHNlY29uZGFyeSB8fCAhKGNoYW5nZU1vbnRoICYmIGNoYW5nZVllYXIpID8gJyYjeGEwOycgOiAnJykgKyBtb250aEh0bWw7XG5cdFx0aHRtbCArPSAnPC9kaXY+JzsgLy8gQ2xvc2UgZGF0ZXBpY2tlcl9oZWFkZXJcblx0XHRyZXR1cm4gaHRtbDtcblx0fSxcblxuXHQvKiBBZGp1c3Qgb25lIG9mIHRoZSBkYXRlIHN1Yi1maWVsZHMuICovXG5cdF9hZGp1c3RJbnN0RGF0ZTogZnVuY3Rpb24oaW5zdCwgb2Zmc2V0LCBwZXJpb2QpIHtcblx0XHR2YXIgeWVhciA9IGluc3QuZHJhd1llYXIgKyAocGVyaW9kID09ICdZJyA/IG9mZnNldCA6IDApO1xuXHRcdHZhciBtb250aCA9IGluc3QuZHJhd01vbnRoICsgKHBlcmlvZCA9PSAnTScgPyBvZmZzZXQgOiAwKTtcblx0XHR2YXIgZGF5ID0gTWF0aC5taW4oaW5zdC5zZWxlY3RlZERheSwgdGhpcy5fZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGgpKSArXG5cdFx0XHQocGVyaW9kID09ICdEJyA/IG9mZnNldCA6IDApO1xuXHRcdHZhciBkYXRlID0gdGhpcy5fcmVzdHJpY3RNaW5NYXgoaW5zdCxcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXkpKSk7XG5cdFx0aW5zdC5zZWxlY3RlZERheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHRcdGluc3QuZHJhd01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuXHRcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRpZiAocGVyaW9kID09ICdNJyB8fCBwZXJpb2QgPT0gJ1knKVxuXHRcdFx0dGhpcy5fbm90aWZ5Q2hhbmdlKGluc3QpO1xuXHR9LFxuXG5cdC8qIEVuc3VyZSBhIGRhdGUgaXMgd2l0aGluIGFueSBtaW4vbWF4IGJvdW5kcy4gKi9cblx0X3Jlc3RyaWN0TWluTWF4OiBmdW5jdGlvbihpbnN0LCBkYXRlKSB7XG5cdFx0dmFyIG1pbkRhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsICdtaW4nKTtcblx0XHR2YXIgbWF4RGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgJ21heCcpO1xuXHRcdHZhciBuZXdEYXRlID0gKG1pbkRhdGUgJiYgZGF0ZSA8IG1pbkRhdGUgPyBtaW5EYXRlIDogZGF0ZSk7XG5cdFx0bmV3RGF0ZSA9IChtYXhEYXRlICYmIG5ld0RhdGUgPiBtYXhEYXRlID8gbWF4RGF0ZSA6IG5ld0RhdGUpO1xuXHRcdHJldHVybiBuZXdEYXRlO1xuXHR9LFxuXG5cdC8qIE5vdGlmeSBjaGFuZ2Ugb2YgbW9udGgveWVhci4gKi9cblx0X25vdGlmeUNoYW5nZTogZnVuY3Rpb24oaW5zdCkge1xuXHRcdHZhciBvbkNoYW5nZSA9IHRoaXMuX2dldChpbnN0LCAnb25DaGFuZ2VNb250aFllYXInKTtcblx0XHRpZiAob25DaGFuZ2UpXG5cdFx0XHRvbkNoYW5nZS5hcHBseSgoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXRbMF0gOiBudWxsKSxcblx0XHRcdFx0W2luc3Quc2VsZWN0ZWRZZWFyLCBpbnN0LnNlbGVjdGVkTW9udGggKyAxLCBpbnN0XSk7XG5cdH0sXG5cblx0LyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgbW9udGhzIHRvIHNob3cuICovXG5cdF9nZXROdW1iZXJPZk1vbnRoczogZnVuY3Rpb24oaW5zdCkge1xuXHRcdHZhciBudW1Nb250aHMgPSB0aGlzLl9nZXQoaW5zdCwgJ251bWJlck9mTW9udGhzJyk7XG5cdFx0cmV0dXJuIChudW1Nb250aHMgPT0gbnVsbCA/IFsxLCAxXSA6ICh0eXBlb2YgbnVtTW9udGhzID09ICdudW1iZXInID8gWzEsIG51bU1vbnRoc10gOiBudW1Nb250aHMpKTtcblx0fSxcblxuXHQvKiBEZXRlcm1pbmUgdGhlIGN1cnJlbnQgbWF4aW11bSBkYXRlIC0gZW5zdXJlIG5vIHRpbWUgY29tcG9uZW50cyBhcmUgc2V0LiAqL1xuXHRfZ2V0TWluTWF4RGF0ZTogZnVuY3Rpb24oaW5zdCwgbWluTWF4KSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RldGVybWluZURhdGUoaW5zdCwgdGhpcy5fZ2V0KGluc3QsIG1pbk1heCArICdEYXRlJyksIG51bGwpO1xuXHR9LFxuXG5cdC8qIEZpbmQgdGhlIG51bWJlciBvZiBkYXlzIGluIGEgZ2l2ZW4gbW9udGguICovXG5cdF9nZXREYXlzSW5Nb250aDogZnVuY3Rpb24oeWVhciwgbW9udGgpIHtcblx0XHRyZXR1cm4gMzIgLSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMzIpKS5nZXREYXRlKCk7XG5cdH0sXG5cblx0LyogRmluZCB0aGUgZGF5IG9mIHRoZSB3ZWVrIG9mIHRoZSBmaXJzdCBvZiBhIG1vbnRoLiAqL1xuXHRfZ2V0Rmlyc3REYXlPZk1vbnRoOiBmdW5jdGlvbih5ZWFyLCBtb250aCkge1xuXHRcdHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMSkuZ2V0RGF5KCk7XG5cdH0sXG5cblx0LyogRGV0ZXJtaW5lcyBpZiB3ZSBzaG91bGQgYWxsb3cgYSBcIm5leHQvcHJldlwiIG1vbnRoIGRpc3BsYXkgY2hhbmdlLiAqL1xuXHRfY2FuQWRqdXN0TW9udGg6IGZ1bmN0aW9uKGluc3QsIG9mZnNldCwgY3VyWWVhciwgY3VyTW9udGgpIHtcblx0XHR2YXIgbnVtTW9udGhzID0gdGhpcy5fZ2V0TnVtYmVyT2ZNb250aHMoaW5zdCk7XG5cdFx0dmFyIGRhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShjdXJZZWFyLFxuXHRcdFx0Y3VyTW9udGggKyAob2Zmc2V0IDwgMCA/IG9mZnNldCA6IG51bU1vbnRoc1swXSAqIG51bU1vbnRoc1sxXSksIDEpKTtcblx0XHRpZiAob2Zmc2V0IDwgMClcblx0XHRcdGRhdGUuc2V0RGF0ZSh0aGlzLl9nZXREYXlzSW5Nb250aChkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSkpO1xuXHRcdHJldHVybiB0aGlzLl9pc0luUmFuZ2UoaW5zdCwgZGF0ZSk7XG5cdH0sXG5cblx0LyogSXMgdGhlIGdpdmVuIGRhdGUgaW4gdGhlIGFjY2VwdGVkIHJhbmdlPyAqL1xuXHRfaXNJblJhbmdlOiBmdW5jdGlvbihpbnN0LCBkYXRlKSB7XG5cdFx0dmFyIG1pbkRhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsICdtaW4nKTtcblx0XHR2YXIgbWF4RGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgJ21heCcpO1xuXHRcdHJldHVybiAoKCFtaW5EYXRlIHx8IGRhdGUuZ2V0VGltZSgpID49IG1pbkRhdGUuZ2V0VGltZSgpKSAmJlxuXHRcdFx0KCFtYXhEYXRlIHx8IGRhdGUuZ2V0VGltZSgpIDw9IG1heERhdGUuZ2V0VGltZSgpKSk7XG5cdH0sXG5cblx0LyogUHJvdmlkZSB0aGUgY29uZmlndXJhdGlvbiBzZXR0aW5ncyBmb3IgZm9ybWF0dGluZy9wYXJzaW5nLiAqL1xuXHRfZ2V0Rm9ybWF0Q29uZmlnOiBmdW5jdGlvbihpbnN0KSB7XG5cdFx0dmFyIHNob3J0WWVhckN1dG9mZiA9IHRoaXMuX2dldChpbnN0LCAnc2hvcnRZZWFyQ3V0b2ZmJyk7XG5cdFx0c2hvcnRZZWFyQ3V0b2ZmID0gKHR5cGVvZiBzaG9ydFllYXJDdXRvZmYgIT0gJ3N0cmluZycgPyBzaG9ydFllYXJDdXRvZmYgOlxuXHRcdFx0bmV3IERhdGUoKS5nZXRGdWxsWWVhcigpICUgMTAwICsgcGFyc2VJbnQoc2hvcnRZZWFyQ3V0b2ZmLCAxMCkpO1xuXHRcdHJldHVybiB7c2hvcnRZZWFyQ3V0b2ZmOiBzaG9ydFllYXJDdXRvZmYsXG5cdFx0XHRkYXlOYW1lc1Nob3J0OiB0aGlzLl9nZXQoaW5zdCwgJ2RheU5hbWVzU2hvcnQnKSwgZGF5TmFtZXM6IHRoaXMuX2dldChpbnN0LCAnZGF5TmFtZXMnKSxcblx0XHRcdG1vbnRoTmFtZXNTaG9ydDogdGhpcy5fZ2V0KGluc3QsICdtb250aE5hbWVzU2hvcnQnKSwgbW9udGhOYW1lczogdGhpcy5fZ2V0KGluc3QsICdtb250aE5hbWVzJyl9O1xuXHR9LFxuXG5cdC8qIEZvcm1hdCB0aGUgZ2l2ZW4gZGF0ZSBmb3IgZGlzcGxheS4gKi9cblx0X2Zvcm1hdERhdGU6IGZ1bmN0aW9uKGluc3QsIGRheSwgbW9udGgsIHllYXIpIHtcblx0XHRpZiAoIWRheSkge1xuXHRcdFx0aW5zdC5jdXJyZW50RGF5ID0gaW5zdC5zZWxlY3RlZERheTtcblx0XHRcdGluc3QuY3VycmVudE1vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoO1xuXHRcdFx0aW5zdC5jdXJyZW50WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyO1xuXHRcdH1cblx0XHR2YXIgZGF0ZSA9IChkYXkgPyAodHlwZW9mIGRheSA9PSAnb2JqZWN0JyA/IGRheSA6XG5cdFx0XHR0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5KSkpIDpcblx0XHRcdHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGluc3QuY3VycmVudFllYXIsIGluc3QuY3VycmVudE1vbnRoLCBpbnN0LmN1cnJlbnREYXkpKSk7XG5cdFx0cmV0dXJuIHRoaXMuZm9ybWF0RGF0ZSh0aGlzLl9nZXQoaW5zdCwgJ2RhdGVGb3JtYXQnKSwgZGF0ZSwgdGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpKTtcblx0fVxufSk7XG5cbi8qXG4gKiBCaW5kIGhvdmVyIGV2ZW50cyBmb3IgZGF0ZXBpY2tlciBlbGVtZW50cy5cbiAqIERvbmUgdmlhIGRlbGVnYXRlIHNvIHRoZSBiaW5kaW5nIG9ubHkgb2NjdXJzIG9uY2UgaW4gdGhlIGxpZmV0aW1lIG9mIHRoZSBwYXJlbnQgZGl2LlxuICogR2xvYmFsIGluc3RBY3RpdmUsIHNldCBieSBfdXBkYXRlRGF0ZXBpY2tlciBhbGxvd3MgdGhlIGhhbmRsZXJzIHRvIGZpbmQgdGhlaXIgd2F5IGJhY2sgdG8gdGhlIGFjdGl2ZSBwaWNrZXIuXG4gKi9cbmZ1bmN0aW9uIGJpbmRIb3ZlcihkcERpdikge1xuXHR2YXIgc2VsZWN0b3IgPSAnYnV0dG9uLCAudWktZGF0ZXBpY2tlci1wcmV2LCAudWktZGF0ZXBpY2tlci1uZXh0LCAudWktZGF0ZXBpY2tlci1jYWxlbmRhciB0ZCBhJztcblx0cmV0dXJuIGRwRGl2LmRlbGVnYXRlKHNlbGVjdG9yLCAnbW91c2VvdXQnLCBmdW5jdGlvbigpIHtcblx0XHRcdCQodGhpcykucmVtb3ZlQ2xhc3MoJ3VpLXN0YXRlLWhvdmVyJyk7XG5cdFx0XHRpZiAodGhpcy5jbGFzc05hbWUuaW5kZXhPZigndWktZGF0ZXBpY2tlci1wcmV2JykgIT0gLTEpICQodGhpcykucmVtb3ZlQ2xhc3MoJ3VpLWRhdGVwaWNrZXItcHJldi1ob3ZlcicpO1xuXHRcdFx0aWYgKHRoaXMuY2xhc3NOYW1lLmluZGV4T2YoJ3VpLWRhdGVwaWNrZXItbmV4dCcpICE9IC0xKSAkKHRoaXMpLnJlbW92ZUNsYXNzKCd1aS1kYXRlcGlja2VyLW5leHQtaG92ZXInKTtcblx0XHR9KVxuXHRcdC5kZWxlZ2F0ZShzZWxlY3RvciwgJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKCl7XG5cdFx0XHRpZiAoISQuZGF0ZXBpY2tlci5faXNEaXNhYmxlZERhdGVwaWNrZXIoIGluc3RBY3RpdmUuaW5saW5lID8gZHBEaXYucGFyZW50KClbMF0gOiBpbnN0QWN0aXZlLmlucHV0WzBdKSkge1xuXHRcdFx0XHQkKHRoaXMpLnBhcmVudHMoJy51aS1kYXRlcGlja2VyLWNhbGVuZGFyJykuZmluZCgnYScpLnJlbW92ZUNsYXNzKCd1aS1zdGF0ZS1ob3ZlcicpO1xuXHRcdFx0XHQkKHRoaXMpLmFkZENsYXNzKCd1aS1zdGF0ZS1ob3ZlcicpO1xuXHRcdFx0XHRpZiAodGhpcy5jbGFzc05hbWUuaW5kZXhPZigndWktZGF0ZXBpY2tlci1wcmV2JykgIT0gLTEpICQodGhpcykuYWRkQ2xhc3MoJ3VpLWRhdGVwaWNrZXItcHJldi1ob3ZlcicpO1xuXHRcdFx0XHRpZiAodGhpcy5jbGFzc05hbWUuaW5kZXhPZigndWktZGF0ZXBpY2tlci1uZXh0JykgIT0gLTEpICQodGhpcykuYWRkQ2xhc3MoJ3VpLWRhdGVwaWNrZXItbmV4dC1ob3ZlcicpO1xuXHRcdFx0fVxuXHRcdH0pO1xufVxuXG4vKiBqUXVlcnkgZXh0ZW5kIG5vdyBpZ25vcmVzIG51bGxzISAqL1xuZnVuY3Rpb24gZXh0ZW5kUmVtb3ZlKHRhcmdldCwgcHJvcHMpIHtcblx0JC5leHRlbmQodGFyZ2V0LCBwcm9wcyk7XG5cdGZvciAodmFyIG5hbWUgaW4gcHJvcHMpXG5cdFx0aWYgKHByb3BzW25hbWVdID09IG51bGwgfHwgcHJvcHNbbmFtZV0gPT0gdW5kZWZpbmVkKVxuXHRcdFx0dGFyZ2V0W25hbWVdID0gcHJvcHNbbmFtZV07XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKiBJbnZva2UgdGhlIGRhdGVwaWNrZXIgZnVuY3Rpb25hbGl0eS5cbiAgIEBwYXJhbSAgb3B0aW9ucyAgc3RyaW5nIC0gYSBjb21tYW5kLCBvcHRpb25hbGx5IGZvbGxvd2VkIGJ5IGFkZGl0aW9uYWwgcGFyYW1ldGVycyBvclxuXHQgICAgICAgICAgICAgICAgT2JqZWN0IC0gc2V0dGluZ3MgZm9yIGF0dGFjaGluZyBuZXcgZGF0ZXBpY2tlciBmdW5jdGlvbmFsaXR5XG4gICBAcmV0dXJuICBqUXVlcnkgb2JqZWN0ICovXG4kLmZuLmRhdGVwaWNrZXIgPSBmdW5jdGlvbihvcHRpb25zKXtcblxuXHQvKiBWZXJpZnkgYW4gZW1wdHkgY29sbGVjdGlvbiB3YXNuJ3QgcGFzc2VkIC0gRml4ZXMgIzY5NzYgKi9cblx0aWYgKCAhdGhpcy5sZW5ndGggKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKiBJbml0aWFsaXNlIHRoZSBkYXRlIHBpY2tlci4gKi9cblx0aWYgKCEkLmRhdGVwaWNrZXIuaW5pdGlhbGl6ZWQpIHtcblx0XHQkKGRvY3VtZW50KS5tb3VzZWRvd24oJC5kYXRlcGlja2VyLl9jaGVja0V4dGVybmFsQ2xpY2spLlxuXHRcdFx0ZmluZChkb2N1bWVudC5ib2R5KS5hcHBlbmQoJC5kYXRlcGlja2VyLmRwRGl2KTtcblx0XHQkLmRhdGVwaWNrZXIuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXHR9XG5cblx0dmFyIG90aGVyQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnc3RyaW5nJyAmJiAob3B0aW9ucyA9PSAnaXNEaXNhYmxlZCcgfHwgb3B0aW9ucyA9PSAnZ2V0RGF0ZScgfHwgb3B0aW9ucyA9PSAnd2lkZ2V0JykpXG5cdFx0cmV0dXJuICQuZGF0ZXBpY2tlclsnXycgKyBvcHRpb25zICsgJ0RhdGVwaWNrZXInXS5cblx0XHRcdGFwcGx5KCQuZGF0ZXBpY2tlciwgW3RoaXNbMF1dLmNvbmNhdChvdGhlckFyZ3MpKTtcblx0aWYgKG9wdGlvbnMgPT0gJ29wdGlvbicgJiYgYXJndW1lbnRzLmxlbmd0aCA9PSAyICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT0gJ3N0cmluZycpXG5cdFx0cmV0dXJuICQuZGF0ZXBpY2tlclsnXycgKyBvcHRpb25zICsgJ0RhdGVwaWNrZXInXS5cblx0XHRcdGFwcGx5KCQuZGF0ZXBpY2tlciwgW3RoaXNbMF1dLmNvbmNhdChvdGhlckFyZ3MpKTtcblx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHR0eXBlb2Ygb3B0aW9ucyA9PSAnc3RyaW5nJyA/XG5cdFx0XHQkLmRhdGVwaWNrZXJbJ18nICsgb3B0aW9ucyArICdEYXRlcGlja2VyJ10uXG5cdFx0XHRcdGFwcGx5KCQuZGF0ZXBpY2tlciwgW3RoaXNdLmNvbmNhdChvdGhlckFyZ3MpKSA6XG5cdFx0XHQkLmRhdGVwaWNrZXIuX2F0dGFjaERhdGVwaWNrZXIodGhpcywgb3B0aW9ucyk7XG5cdH0pO1xufTtcblxuJC5kYXRlcGlja2VyID0gbmV3IERhdGVwaWNrZXIoKTsgLy8gc2luZ2xldG9uIGluc3RhbmNlXG4kLmRhdGVwaWNrZXIuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiQuZGF0ZXBpY2tlci51dWlkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4kLmRhdGVwaWNrZXIudmVyc2lvbiA9IFwiMS45LjJcIjtcblxuLy8gV29ya2Fyb3VuZCBmb3IgIzQwNTVcbi8vIEFkZCBhbm90aGVyIGdsb2JhbCB0byBhdm9pZCBub0NvbmZsaWN0IGlzc3VlcyB3aXRoIGlubGluZSBldmVudCBoYW5kbGVyc1xud2luZG93WydEUF9qUXVlcnlfJyArIGRwdXVpZF0gPSAkO1xuXG59KShqUXVlcnkpO1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbnZhciB1aURpYWxvZ0NsYXNzZXMgPSBcInVpLWRpYWxvZyB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCBcIixcblx0c2l6ZVJlbGF0ZWRPcHRpb25zID0ge1xuXHRcdGJ1dHRvbnM6IHRydWUsXG5cdFx0aGVpZ2h0OiB0cnVlLFxuXHRcdG1heEhlaWdodDogdHJ1ZSxcblx0XHRtYXhXaWR0aDogdHJ1ZSxcblx0XHRtaW5IZWlnaHQ6IHRydWUsXG5cdFx0bWluV2lkdGg6IHRydWUsXG5cdFx0d2lkdGg6IHRydWVcblx0fSxcblx0cmVzaXphYmxlUmVsYXRlZE9wdGlvbnMgPSB7XG5cdFx0bWF4SGVpZ2h0OiB0cnVlLFxuXHRcdG1heFdpZHRoOiB0cnVlLFxuXHRcdG1pbkhlaWdodDogdHJ1ZSxcblx0XHRtaW5XaWR0aDogdHJ1ZVxuXHR9O1xuXG4kLndpZGdldChcInVpLmRpYWxvZ1wiLCB7XG5cdHZlcnNpb246IFwiMS45LjJcIixcblx0b3B0aW9uczoge1xuXHRcdGF1dG9PcGVuOiB0cnVlLFxuXHRcdGJ1dHRvbnM6IHt9LFxuXHRcdGNsb3NlT25Fc2NhcGU6IHRydWUsXG5cdFx0Y2xvc2VUZXh0OiBcImNsb3NlXCIsXG5cdFx0ZGlhbG9nQ2xhc3M6IFwiXCIsXG5cdFx0ZHJhZ2dhYmxlOiB0cnVlLFxuXHRcdGhpZGU6IG51bGwsXG5cdFx0aGVpZ2h0OiBcImF1dG9cIixcblx0XHRtYXhIZWlnaHQ6IGZhbHNlLFxuXHRcdG1heFdpZHRoOiBmYWxzZSxcblx0XHRtaW5IZWlnaHQ6IDE1MCxcblx0XHRtaW5XaWR0aDogMTUwLFxuXHRcdG1vZGFsOiBmYWxzZSxcblx0XHRwb3NpdGlvbjoge1xuXHRcdFx0bXk6IFwiY2VudGVyXCIsXG5cdFx0XHRhdDogXCJjZW50ZXJcIixcblx0XHRcdG9mOiB3aW5kb3csXG5cdFx0XHRjb2xsaXNpb246IFwiZml0XCIsXG5cdFx0XHQvLyBlbnN1cmUgdGhhdCB0aGUgdGl0bGViYXIgaXMgbmV2ZXIgb3V0c2lkZSB0aGUgZG9jdW1lbnRcblx0XHRcdHVzaW5nOiBmdW5jdGlvbiggcG9zICkge1xuXHRcdFx0XHR2YXIgdG9wT2Zmc2V0ID0gJCggdGhpcyApLmNzcyggcG9zICkub2Zmc2V0KCkudG9wO1xuXHRcdFx0XHRpZiAoIHRvcE9mZnNldCA8IDAgKSB7XG5cdFx0XHRcdFx0JCggdGhpcyApLmNzcyggXCJ0b3BcIiwgcG9zLnRvcCAtIHRvcE9mZnNldCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZXNpemFibGU6IHRydWUsXG5cdFx0c2hvdzogbnVsbCxcblx0XHRzdGFjazogdHJ1ZSxcblx0XHR0aXRsZTogXCJcIixcblx0XHR3aWR0aDogMzAwLFxuXHRcdHpJbmRleDogMTAwMFxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMub3JpZ2luYWxUaXRsZSA9IHRoaXMuZWxlbWVudC5hdHRyKCBcInRpdGxlXCIgKTtcblx0XHQvLyAjNTc0MiAtIC5hdHRyKCkgbWlnaHQgcmV0dXJuIGEgRE9NRWxlbWVudFxuXHRcdGlmICggdHlwZW9mIHRoaXMub3JpZ2luYWxUaXRsZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRoaXMub3JpZ2luYWxUaXRsZSA9IFwiXCI7XG5cdFx0fVxuXHRcdHRoaXMub2xkUG9zaXRpb24gPSB7XG5cdFx0XHRwYXJlbnQ6IHRoaXMuZWxlbWVudC5wYXJlbnQoKSxcblx0XHRcdGluZGV4OiB0aGlzLmVsZW1lbnQucGFyZW50KCkuY2hpbGRyZW4oKS5pbmRleCggdGhpcy5lbGVtZW50IClcblx0XHR9O1xuXHRcdHRoaXMub3B0aW9ucy50aXRsZSA9IHRoaXMub3B0aW9ucy50aXRsZSB8fCB0aGlzLm9yaWdpbmFsVGl0bGU7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblxuXHRcdFx0dGl0bGUgPSBvcHRpb25zLnRpdGxlIHx8IFwiJiMxNjA7XCIsXG5cdFx0XHR1aURpYWxvZyxcblx0XHRcdHVpRGlhbG9nVGl0bGViYXIsXG5cdFx0XHR1aURpYWxvZ1RpdGxlYmFyQ2xvc2UsXG5cdFx0XHR1aURpYWxvZ1RpdGxlLFxuXHRcdFx0dWlEaWFsb2dCdXR0b25QYW5lO1xuXG5cdFx0XHR1aURpYWxvZyA9ICggdGhpcy51aURpYWxvZyA9ICQoIFwiPGRpdj5cIiApIClcblx0XHRcdFx0LmFkZENsYXNzKCB1aURpYWxvZ0NsYXNzZXMgKyBvcHRpb25zLmRpYWxvZ0NsYXNzIClcblx0XHRcdFx0LmNzcyh7XG5cdFx0XHRcdFx0ZGlzcGxheTogXCJub25lXCIsXG5cdFx0XHRcdFx0b3V0bGluZTogMCwgLy8gVE9ETzogbW92ZSB0byBzdHlsZXNoZWV0XG5cdFx0XHRcdFx0ekluZGV4OiBvcHRpb25zLnpJbmRleFxuXHRcdFx0XHR9KVxuXHRcdFx0XHQvLyBzZXR0aW5nIHRhYkluZGV4IG1ha2VzIHRoZSBkaXYgZm9jdXNhYmxlXG5cdFx0XHRcdC5hdHRyKCBcInRhYkluZGV4XCIsIC0xKVxuXHRcdFx0XHQua2V5ZG93bihmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zLmNsb3NlT25Fc2NhcGUgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICYmIGV2ZW50LmtleUNvZGUgJiZcblx0XHRcdFx0XHRcdFx0ZXZlbnQua2V5Q29kZSA9PT0gJC51aS5rZXlDb2RlLkVTQ0FQRSApIHtcblx0XHRcdFx0XHRcdHRoYXQuY2xvc2UoIGV2ZW50ICk7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0Lm1vdXNlZG93bihmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0dGhhdC5tb3ZlVG9Ub3AoIGZhbHNlLCBldmVudCApO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYXBwZW5kVG8oIFwiYm9keVwiICk7XG5cblx0XHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0XHQuc2hvdygpXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCBcInRpdGxlXCIgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktZGlhbG9nLWNvbnRlbnQgdWktd2lkZ2V0LWNvbnRlbnRcIiApXG5cdFx0XHRcdC5hcHBlbmRUbyggdWlEaWFsb2cgKTtcblxuXHRcdFx0dWlEaWFsb2dUaXRsZWJhciA9ICggdGhpcy51aURpYWxvZ1RpdGxlYmFyID0gJCggXCI8ZGl2PlwiICkgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktZGlhbG9nLXRpdGxlYmFyICB1aS13aWRnZXQtaGVhZGVyICBcIiArXG5cdFx0XHRcdFx0XCJ1aS1jb3JuZXItYWxsICB1aS1oZWxwZXItY2xlYXJmaXhcIiApXG5cdFx0XHRcdC5iaW5kKCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvLyBEaWFsb2cgaXNuJ3QgZ2V0dGluZyBmb2N1cyB3aGVuIGRyYWdnaW5nICgjODA2Mylcblx0XHRcdFx0XHR1aURpYWxvZy5mb2N1cygpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQucHJlcGVuZFRvKCB1aURpYWxvZyApO1xuXG5cdFx0XHR1aURpYWxvZ1RpdGxlYmFyQ2xvc2UgPSAkKCBcIjxhIGhyZWY9JyMnPjwvYT5cIiApXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1kaWFsb2ctdGl0bGViYXItY2xvc2UgIHVpLWNvcm5lci1hbGxcIiApXG5cdFx0XHRcdC5hdHRyKCBcInJvbGVcIiwgXCJidXR0b25cIiApXG5cdFx0XHRcdC5jbGljayhmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHR0aGF0LmNsb3NlKCBldmVudCApO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYXBwZW5kVG8oIHVpRGlhbG9nVGl0bGViYXIgKTtcblxuXHRcdFx0KCB0aGlzLnVpRGlhbG9nVGl0bGViYXJDbG9zZVRleHQgPSAkKCBcIjxzcGFuPlwiICkgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktaWNvbiB1aS1pY29uLWNsb3NldGhpY2tcIiApXG5cdFx0XHRcdC50ZXh0KCBvcHRpb25zLmNsb3NlVGV4dCApXG5cdFx0XHRcdC5hcHBlbmRUbyggdWlEaWFsb2dUaXRsZWJhckNsb3NlICk7XG5cblx0XHRcdHVpRGlhbG9nVGl0bGUgPSAkKCBcIjxzcGFuPlwiIClcblx0XHRcdFx0LnVuaXF1ZUlkKClcblx0XHRcdFx0LmFkZENsYXNzKCBcInVpLWRpYWxvZy10aXRsZVwiIClcblx0XHRcdFx0Lmh0bWwoIHRpdGxlIClcblx0XHRcdFx0LnByZXBlbmRUbyggdWlEaWFsb2dUaXRsZWJhciApO1xuXG5cdFx0XHR1aURpYWxvZ0J1dHRvblBhbmUgPSAoIHRoaXMudWlEaWFsb2dCdXR0b25QYW5lID0gJCggXCI8ZGl2PlwiICkgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktZGlhbG9nLWJ1dHRvbnBhbmUgdWktd2lkZ2V0LWNvbnRlbnQgdWktaGVscGVyLWNsZWFyZml4XCIgKTtcblxuXHRcdFx0KCB0aGlzLnVpQnV0dG9uU2V0ID0gJCggXCI8ZGl2PlwiICkgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktZGlhbG9nLWJ1dHRvbnNldFwiIClcblx0XHRcdFx0LmFwcGVuZFRvKCB1aURpYWxvZ0J1dHRvblBhbmUgKTtcblxuXHRcdHVpRGlhbG9nLmF0dHIoe1xuXHRcdFx0cm9sZTogXCJkaWFsb2dcIixcblx0XHRcdFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHVpRGlhbG9nVGl0bGUuYXR0ciggXCJpZFwiIClcblx0XHR9KTtcblxuXHRcdHVpRGlhbG9nVGl0bGViYXIuZmluZCggXCIqXCIgKS5hZGQoIHVpRGlhbG9nVGl0bGViYXIgKS5kaXNhYmxlU2VsZWN0aW9uKCk7XG5cdFx0dGhpcy5faG92ZXJhYmxlKCB1aURpYWxvZ1RpdGxlYmFyQ2xvc2UgKTtcblx0XHR0aGlzLl9mb2N1c2FibGUoIHVpRGlhbG9nVGl0bGViYXJDbG9zZSApO1xuXG5cdFx0aWYgKCBvcHRpb25zLmRyYWdnYWJsZSAmJiAkLmZuLmRyYWdnYWJsZSApIHtcblx0XHRcdHRoaXMuX21ha2VEcmFnZ2FibGUoKTtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLnJlc2l6YWJsZSAmJiAkLmZuLnJlc2l6YWJsZSApIHtcblx0XHRcdHRoaXMuX21ha2VSZXNpemFibGUoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9jcmVhdGVCdXR0b25zKCBvcHRpb25zLmJ1dHRvbnMgKTtcblx0XHR0aGlzLl9pc09wZW4gPSBmYWxzZTtcblxuXHRcdGlmICggJC5mbi5iZ2lmcmFtZSApIHtcblx0XHRcdHVpRGlhbG9nLmJnaWZyYW1lKCk7XG5cdFx0fVxuXG5cdFx0Ly8gcHJldmVudCB0YWJiaW5nIG91dCBvZiBtb2RhbCBkaWFsb2dzXG5cdFx0dGhpcy5fb24oIHVpRGlhbG9nLCB7IGtleWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGlmICggIW9wdGlvbnMubW9kYWwgfHwgZXZlbnQua2V5Q29kZSAhPT0gJC51aS5rZXlDb2RlLlRBQiApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdGFiYmFibGVzID0gJCggXCI6dGFiYmFibGVcIiwgdWlEaWFsb2cgKSxcblx0XHRcdFx0Zmlyc3QgPSB0YWJiYWJsZXMuZmlsdGVyKCBcIjpmaXJzdFwiICksXG5cdFx0XHRcdGxhc3QgID0gdGFiYmFibGVzLmZpbHRlciggXCI6bGFzdFwiICk7XG5cblx0XHRcdGlmICggZXZlbnQudGFyZ2V0ID09PSBsYXN0WzBdICYmICFldmVudC5zaGlmdEtleSApIHtcblx0XHRcdFx0Zmlyc3QuZm9jdXMoIDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggZXZlbnQudGFyZ2V0ID09PSBmaXJzdFswXSAmJiBldmVudC5zaGlmdEtleSApIHtcblx0XHRcdFx0bGFzdC5mb2N1cyggMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fX0pO1xuXHR9LFxuXG5cdF9pbml0OiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5hdXRvT3BlbiApIHtcblx0XHRcdHRoaXMub3BlbigpO1xuXHRcdH1cblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5leHQsXG5cdFx0XHRvbGRQb3NpdGlvbiA9IHRoaXMub2xkUG9zaXRpb247XG5cblx0XHRpZiAoIHRoaXMub3ZlcmxheSApIHtcblx0XHRcdHRoaXMub3ZlcmxheS5kZXN0cm95KCk7XG5cdFx0fVxuXHRcdHRoaXMudWlEaWFsb2cuaGlkZSgpO1xuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWRpYWxvZy1jb250ZW50IHVpLXdpZGdldC1jb250ZW50XCIgKVxuXHRcdFx0LmhpZGUoKVxuXHRcdFx0LmFwcGVuZFRvKCBcImJvZHlcIiApO1xuXHRcdHRoaXMudWlEaWFsb2cucmVtb3ZlKCk7XG5cblx0XHRpZiAoIHRoaXMub3JpZ2luYWxUaXRsZSApIHtcblx0XHRcdHRoaXMuZWxlbWVudC5hdHRyKCBcInRpdGxlXCIsIHRoaXMub3JpZ2luYWxUaXRsZSApO1xuXHRcdH1cblxuXHRcdG5leHQgPSBvbGRQb3NpdGlvbi5wYXJlbnQuY2hpbGRyZW4oKS5lcSggb2xkUG9zaXRpb24uaW5kZXggKTtcblx0XHQvLyBEb24ndCB0cnkgdG8gcGxhY2UgdGhlIGRpYWxvZyBuZXh0IHRvIGl0c2VsZiAoIzg2MTMpXG5cdFx0aWYgKCBuZXh0Lmxlbmd0aCAmJiBuZXh0WyAwIF0gIT09IHRoaXMuZWxlbWVudFsgMCBdICkge1xuXHRcdFx0bmV4dC5iZWZvcmUoIHRoaXMuZWxlbWVudCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvbGRQb3NpdGlvbi5wYXJlbnQuYXBwZW5kKCB0aGlzLmVsZW1lbnQgKTtcblx0XHR9XG5cdH0sXG5cblx0d2lkZ2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy51aURpYWxvZztcblx0fSxcblxuXHRjbG9zZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdG1heFosIHRoaXNaO1xuXG5cdFx0aWYgKCAhdGhpcy5faXNPcGVuICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggZmFsc2UgPT09IHRoaXMuX3RyaWdnZXIoIFwiYmVmb3JlQ2xvc2VcIiwgZXZlbnQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9pc09wZW4gPSBmYWxzZTtcblxuXHRcdGlmICggdGhpcy5vdmVybGF5ICkge1xuXHRcdFx0dGhpcy5vdmVybGF5LmRlc3Ryb3koKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5oaWRlICkge1xuXHRcdFx0dGhpcy5faGlkZSggdGhpcy51aURpYWxvZywgdGhpcy5vcHRpb25zLmhpZGUsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGF0Ll90cmlnZ2VyKCBcImNsb3NlXCIsIGV2ZW50ICk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy51aURpYWxvZy5oaWRlKCk7XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCBcImNsb3NlXCIsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0JC51aS5kaWFsb2cub3ZlcmxheS5yZXNpemUoKTtcblxuXHRcdC8vIGFkanVzdCB0aGUgbWF4WiB0byBhbGxvdyBvdGhlciBtb2RhbCBkaWFsb2dzIHRvIGNvbnRpbnVlIHRvIHdvcmsgKHNlZSAjNDMwOSlcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5tb2RhbCApIHtcblx0XHRcdG1heFogPSAwO1xuXHRcdFx0JCggXCIudWktZGlhbG9nXCIgKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgIT09IHRoYXQudWlEaWFsb2dbMF0gKSB7XG5cdFx0XHRcdFx0dGhpc1ogPSAkKCB0aGlzICkuY3NzKCBcInotaW5kZXhcIiApO1xuXHRcdFx0XHRcdGlmICggIWlzTmFOKCB0aGlzWiApICkge1xuXHRcdFx0XHRcdFx0bWF4WiA9IE1hdGgubWF4KCBtYXhaLCB0aGlzWiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHQkLnVpLmRpYWxvZy5tYXhaID0gbWF4Wjtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRpc09wZW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pc09wZW47XG5cdH0sXG5cblx0Ly8gdGhlIGZvcmNlIHBhcmFtZXRlciBhbGxvd3MgdXMgdG8gbW92ZSBtb2RhbCBkaWFsb2dzIHRvIHRoZWlyIGNvcnJlY3Rcblx0Ly8gcG9zaXRpb24gb24gb3BlblxuXHRtb3ZlVG9Ub3A6IGZ1bmN0aW9uKCBmb3JjZSwgZXZlbnQgKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRzYXZlU2Nyb2xsO1xuXG5cdFx0aWYgKCAoIG9wdGlvbnMubW9kYWwgJiYgIWZvcmNlICkgfHxcblx0XHRcdFx0KCAhb3B0aW9ucy5zdGFjayAmJiAhb3B0aW9ucy5tb2RhbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3RyaWdnZXIoIFwiZm9jdXNcIiwgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMuekluZGV4ID4gJC51aS5kaWFsb2cubWF4WiApIHtcblx0XHRcdCQudWkuZGlhbG9nLm1heFogPSBvcHRpb25zLnpJbmRleDtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLm92ZXJsYXkgKSB7XG5cdFx0XHQkLnVpLmRpYWxvZy5tYXhaICs9IDE7XG5cdFx0XHQkLnVpLmRpYWxvZy5vdmVybGF5Lm1heFogPSAkLnVpLmRpYWxvZy5tYXhaO1xuXHRcdFx0dGhpcy5vdmVybGF5LiRlbC5jc3MoIFwiei1pbmRleFwiLCAkLnVpLmRpYWxvZy5vdmVybGF5Lm1heFogKTtcblx0XHR9XG5cblx0XHQvLyBTYXZlIGFuZCB0aGVuIHJlc3RvcmUgc2Nyb2xsXG5cdFx0Ly8gT3BlcmEgOS41KyByZXNldHMgd2hlbiBwYXJlbnQgei1pbmRleCBpcyBjaGFuZ2VkLlxuXHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeXVpLmNvbS90aWNrZXQvMzE5M1xuXHRcdHNhdmVTY3JvbGwgPSB7XG5cdFx0XHRzY3JvbGxUb3A6IHRoaXMuZWxlbWVudC5zY3JvbGxUb3AoKSxcblx0XHRcdHNjcm9sbExlZnQ6IHRoaXMuZWxlbWVudC5zY3JvbGxMZWZ0KClcblx0XHR9O1xuXHRcdCQudWkuZGlhbG9nLm1heFogKz0gMTtcblx0XHR0aGlzLnVpRGlhbG9nLmNzcyggXCJ6LWluZGV4XCIsICQudWkuZGlhbG9nLm1heFogKTtcblx0XHR0aGlzLmVsZW1lbnQuYXR0ciggc2F2ZVNjcm9sbCApO1xuXHRcdHRoaXMuX3RyaWdnZXIoIFwiZm9jdXNcIiwgZXZlbnQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdG9wZW46IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggdGhpcy5faXNPcGVuICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBoYXNGb2N1cyxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHR1aURpYWxvZyA9IHRoaXMudWlEaWFsb2c7XG5cblx0XHR0aGlzLl9zaXplKCk7XG5cdFx0dGhpcy5fcG9zaXRpb24oIG9wdGlvbnMucG9zaXRpb24gKTtcblx0XHR1aURpYWxvZy5zaG93KCBvcHRpb25zLnNob3cgKTtcblx0XHR0aGlzLm92ZXJsYXkgPSBvcHRpb25zLm1vZGFsID8gbmV3ICQudWkuZGlhbG9nLm92ZXJsYXkoIHRoaXMgKSA6IG51bGw7XG5cdFx0dGhpcy5tb3ZlVG9Ub3AoIHRydWUgKTtcblxuXHRcdC8vIHNldCBmb2N1cyB0byB0aGUgZmlyc3QgdGFiYmFibGUgZWxlbWVudCBpbiB0aGUgY29udGVudCBhcmVhIG9yIHRoZSBmaXJzdCBidXR0b25cblx0XHQvLyBpZiB0aGVyZSBhcmUgbm8gdGFiYmFibGUgZWxlbWVudHMsIHNldCBmb2N1cyBvbiB0aGUgZGlhbG9nIGl0c2VsZlxuXHRcdGhhc0ZvY3VzID0gdGhpcy5lbGVtZW50LmZpbmQoIFwiOnRhYmJhYmxlXCIgKTtcblx0XHRpZiAoICFoYXNGb2N1cy5sZW5ndGggKSB7XG5cdFx0XHRoYXNGb2N1cyA9IHRoaXMudWlEaWFsb2dCdXR0b25QYW5lLmZpbmQoIFwiOnRhYmJhYmxlXCIgKTtcblx0XHRcdGlmICggIWhhc0ZvY3VzLmxlbmd0aCApIHtcblx0XHRcdFx0aGFzRm9jdXMgPSB1aURpYWxvZztcblx0XHRcdH1cblx0XHR9XG5cdFx0aGFzRm9jdXMuZXEoIDAgKS5mb2N1cygpO1xuXG5cdFx0dGhpcy5faXNPcGVuID0gdHJ1ZTtcblx0XHR0aGlzLl90cmlnZ2VyKCBcIm9wZW5cIiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2NyZWF0ZUJ1dHRvbnM6IGZ1bmN0aW9uKCBidXR0b25zICkge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdGhhc0J1dHRvbnMgPSBmYWxzZTtcblxuXHRcdC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGJ1dHRvbiBwYW5lLCByZW1vdmUgaXRcblx0XHR0aGlzLnVpRGlhbG9nQnV0dG9uUGFuZS5yZW1vdmUoKTtcblx0XHR0aGlzLnVpQnV0dG9uU2V0LmVtcHR5KCk7XG5cblx0XHRpZiAoIHR5cGVvZiBidXR0b25zID09PSBcIm9iamVjdFwiICYmIGJ1dHRvbnMgIT09IG51bGwgKSB7XG5cdFx0XHQkLmVhY2goIGJ1dHRvbnMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIShoYXNCdXR0b25zID0gdHJ1ZSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0aWYgKCBoYXNCdXR0b25zICkge1xuXHRcdFx0JC5lYWNoKCBidXR0b25zLCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdFx0XHRcdHZhciBidXR0b24sIGNsaWNrO1xuXHRcdFx0XHRwcm9wcyA9ICQuaXNGdW5jdGlvbiggcHJvcHMgKSA/XG5cdFx0XHRcdFx0eyBjbGljazogcHJvcHMsIHRleHQ6IG5hbWUgfSA6XG5cdFx0XHRcdFx0cHJvcHM7XG5cdFx0XHRcdC8vIERlZmF1bHQgdG8gYSBub24tc3VibWl0dGluZyBidXR0b25cblx0XHRcdFx0cHJvcHMgPSAkLmV4dGVuZCggeyB0eXBlOiBcImJ1dHRvblwiIH0sIHByb3BzICk7XG5cdFx0XHRcdC8vIENoYW5nZSB0aGUgY29udGV4dCBmb3IgdGhlIGNsaWNrIGNhbGxiYWNrIHRvIGJlIHRoZSBtYWluIGVsZW1lbnRcblx0XHRcdFx0Y2xpY2sgPSBwcm9wcy5jbGljaztcblx0XHRcdFx0cHJvcHMuY2xpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRjbGljay5hcHBseSggdGhhdC5lbGVtZW50WzBdLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0YnV0dG9uID0gJCggXCI8YnV0dG9uPjwvYnV0dG9uPlwiLCBwcm9wcyApXG5cdFx0XHRcdFx0LmFwcGVuZFRvKCB0aGF0LnVpQnV0dG9uU2V0ICk7XG5cdFx0XHRcdGlmICggJC5mbi5idXR0b24gKSB7XG5cdFx0XHRcdFx0YnV0dG9uLmJ1dHRvbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMudWlEaWFsb2cuYWRkQ2xhc3MoIFwidWktZGlhbG9nLWJ1dHRvbnNcIiApO1xuXHRcdFx0dGhpcy51aURpYWxvZ0J1dHRvblBhbmUuYXBwZW5kVG8oIHRoaXMudWlEaWFsb2cgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy51aURpYWxvZy5yZW1vdmVDbGFzcyggXCJ1aS1kaWFsb2ctYnV0dG9uc1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9tYWtlRHJhZ2dhYmxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0ZnVuY3Rpb24gZmlsdGVyZWRVaSggdWkgKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRwb3NpdGlvbjogdWkucG9zaXRpb24sXG5cdFx0XHRcdG9mZnNldDogdWkub2Zmc2V0XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHRoaXMudWlEaWFsb2cuZHJhZ2dhYmxlKHtcblx0XHRcdGNhbmNlbDogXCIudWktZGlhbG9nLWNvbnRlbnQsIC51aS1kaWFsb2ctdGl0bGViYXItY2xvc2VcIixcblx0XHRcdGhhbmRsZTogXCIudWktZGlhbG9nLXRpdGxlYmFyXCIsXG5cdFx0XHRjb250YWlubWVudDogXCJkb2N1bWVudFwiLFxuXHRcdFx0c3RhcnQ6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1kaWFsb2ctZHJhZ2dpbmdcIiApO1xuXHRcdFx0XHR0aGF0Ll90cmlnZ2VyKCBcImRyYWdTdGFydFwiLCBldmVudCwgZmlsdGVyZWRVaSggdWkgKSApO1xuXHRcdFx0fSxcblx0XHRcdGRyYWc6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XG5cdFx0XHRcdHRoYXQuX3RyaWdnZXIoIFwiZHJhZ1wiLCBldmVudCwgZmlsdGVyZWRVaSggdWkgKSApO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XG5cdFx0XHRcdG9wdGlvbnMucG9zaXRpb24gPSBbXG5cdFx0XHRcdFx0dWkucG9zaXRpb24ubGVmdCAtIHRoYXQuZG9jdW1lbnQuc2Nyb2xsTGVmdCgpLFxuXHRcdFx0XHRcdHVpLnBvc2l0aW9uLnRvcCAtIHRoYXQuZG9jdW1lbnQuc2Nyb2xsVG9wKClcblx0XHRcdFx0XTtcblx0XHRcdFx0JCggdGhpcyApXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWRpYWxvZy1kcmFnZ2luZ1wiICk7XG5cdFx0XHRcdHRoYXQuX3RyaWdnZXIoIFwiZHJhZ1N0b3BcIiwgZXZlbnQsIGZpbHRlcmVkVWkoIHVpICkgKTtcblx0XHRcdFx0JC51aS5kaWFsb2cub3ZlcmxheS5yZXNpemUoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRfbWFrZVJlc2l6YWJsZTogZnVuY3Rpb24oIGhhbmRsZXMgKSB7XG5cdFx0aGFuZGxlcyA9IChoYW5kbGVzID09PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMucmVzaXphYmxlIDogaGFuZGxlcyk7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdC8vIC51aS1yZXNpemFibGUgaGFzIHBvc2l0aW9uOiByZWxhdGl2ZSBkZWZpbmVkIGluIHRoZSBzdHlsZXNoZWV0XG5cdFx0XHQvLyBidXQgZGlhbG9ncyBoYXZlIHRvIHVzZSBhYnNvbHV0ZSBvciBmaXhlZCBwb3NpdGlvbmluZ1xuXHRcdFx0cG9zaXRpb24gPSB0aGlzLnVpRGlhbG9nLmNzcyggXCJwb3NpdGlvblwiICksXG5cdFx0XHRyZXNpemVIYW5kbGVzID0gdHlwZW9mIGhhbmRsZXMgPT09ICdzdHJpbmcnID9cblx0XHRcdFx0aGFuZGxlc1x0OlxuXHRcdFx0XHRcIm4sZSxzLHcsc2Usc3csbmUsbndcIjtcblxuXHRcdGZ1bmN0aW9uIGZpbHRlcmVkVWkoIHVpICkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0b3JpZ2luYWxQb3NpdGlvbjogdWkub3JpZ2luYWxQb3NpdGlvbixcblx0XHRcdFx0b3JpZ2luYWxTaXplOiB1aS5vcmlnaW5hbFNpemUsXG5cdFx0XHRcdHBvc2l0aW9uOiB1aS5wb3NpdGlvbixcblx0XHRcdFx0c2l6ZTogdWkuc2l6ZVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHR0aGlzLnVpRGlhbG9nLnJlc2l6YWJsZSh7XG5cdFx0XHRjYW5jZWw6IFwiLnVpLWRpYWxvZy1jb250ZW50XCIsXG5cdFx0XHRjb250YWlubWVudDogXCJkb2N1bWVudFwiLFxuXHRcdFx0YWxzb1Jlc2l6ZTogdGhpcy5lbGVtZW50LFxuXHRcdFx0bWF4V2lkdGg6IG9wdGlvbnMubWF4V2lkdGgsXG5cdFx0XHRtYXhIZWlnaHQ6IG9wdGlvbnMubWF4SGVpZ2h0LFxuXHRcdFx0bWluV2lkdGg6IG9wdGlvbnMubWluV2lkdGgsXG5cdFx0XHRtaW5IZWlnaHQ6IHRoaXMuX21pbkhlaWdodCgpLFxuXHRcdFx0aGFuZGxlczogcmVzaXplSGFuZGxlcyxcblx0XHRcdHN0YXJ0OiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xuXHRcdFx0XHQkKCB0aGlzICkuYWRkQ2xhc3MoIFwidWktZGlhbG9nLXJlc2l6aW5nXCIgKTtcblx0XHRcdFx0dGhhdC5fdHJpZ2dlciggXCJyZXNpemVTdGFydFwiLCBldmVudCwgZmlsdGVyZWRVaSggdWkgKSApO1xuXHRcdFx0fSxcblx0XHRcdHJlc2l6ZTogZnVuY3Rpb24oIGV2ZW50LCB1aSApIHtcblx0XHRcdFx0dGhhdC5fdHJpZ2dlciggXCJyZXNpemVcIiwgZXZlbnQsIGZpbHRlcmVkVWkoIHVpICkgKTtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xuXHRcdFx0XHQkKCB0aGlzICkucmVtb3ZlQ2xhc3MoIFwidWktZGlhbG9nLXJlc2l6aW5nXCIgKTtcblx0XHRcdFx0b3B0aW9ucy5oZWlnaHQgPSAkKCB0aGlzICkuaGVpZ2h0KCk7XG5cdFx0XHRcdG9wdGlvbnMud2lkdGggPSAkKCB0aGlzICkud2lkdGgoKTtcblx0XHRcdFx0dGhhdC5fdHJpZ2dlciggXCJyZXNpemVTdG9wXCIsIGV2ZW50LCBmaWx0ZXJlZFVpKCB1aSApICk7XG5cdFx0XHRcdCQudWkuZGlhbG9nLm92ZXJsYXkucmVzaXplKCk7XG5cdFx0XHR9XG5cdFx0fSlcblx0XHQuY3NzKCBcInBvc2l0aW9uXCIsIHBvc2l0aW9uIClcblx0XHQuZmluZCggXCIudWktcmVzaXphYmxlLXNlXCIgKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLWljb24gdWktaWNvbi1ncmlwLWRpYWdvbmFsLXNlXCIgKTtcblx0fSxcblxuXHRfbWluSGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdGlmICggb3B0aW9ucy5oZWlnaHQgPT09IFwiYXV0b1wiICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMubWluSGVpZ2h0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5taW4oIG9wdGlvbnMubWluSGVpZ2h0LCBvcHRpb25zLmhlaWdodCApO1xuXHRcdH1cblx0fSxcblxuXHRfcG9zaXRpb246IGZ1bmN0aW9uKCBwb3NpdGlvbiApIHtcblx0XHR2YXIgbXlBdCA9IFtdLFxuXHRcdFx0b2Zmc2V0ID0gWyAwLCAwIF0sXG5cdFx0XHRpc1Zpc2libGU7XG5cblx0XHRpZiAoIHBvc2l0aW9uICkge1xuXHRcdFx0Ly8gZGVlcCBleHRlbmRpbmcgY29udmVydHMgYXJyYXlzIHRvIG9iamVjdHMgaW4galF1ZXJ5IDw9IDEuMy4yIDotKFxuXHQvL1x0XHRpZiAodHlwZW9mIHBvc2l0aW9uID09ICdzdHJpbmcnIHx8ICQuaXNBcnJheShwb3NpdGlvbikpIHtcblx0Ly9cdFx0XHRteUF0ID0gJC5pc0FycmF5KHBvc2l0aW9uKSA/IHBvc2l0aW9uIDogcG9zaXRpb24uc3BsaXQoJyAnKTtcblxuXHRcdFx0aWYgKCB0eXBlb2YgcG9zaXRpb24gPT09IFwic3RyaW5nXCIgfHwgKHR5cGVvZiBwb3NpdGlvbiA9PT0gXCJvYmplY3RcIiAmJiBcIjBcIiBpbiBwb3NpdGlvbiApICkge1xuXHRcdFx0XHRteUF0ID0gcG9zaXRpb24uc3BsaXQgPyBwb3NpdGlvbi5zcGxpdCggXCIgXCIgKSA6IFsgcG9zaXRpb25bIDAgXSwgcG9zaXRpb25bIDEgXSBdO1xuXHRcdFx0XHRpZiAoIG15QXQubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRcdG15QXRbIDEgXSA9IG15QXRbIDAgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdCQuZWFjaCggWyBcImxlZnRcIiwgXCJ0b3BcIiBdLCBmdW5jdGlvbiggaSwgb2Zmc2V0UG9zaXRpb24gKSB7XG5cdFx0XHRcdFx0aWYgKCArbXlBdFsgaSBdID09PSBteUF0WyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRvZmZzZXRbIGkgXSA9IG15QXRbIGkgXTtcblx0XHRcdFx0XHRcdG15QXRbIGkgXSA9IG9mZnNldFBvc2l0aW9uO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cG9zaXRpb24gPSB7XG5cdFx0XHRcdFx0bXk6IG15QXRbMF0gKyAob2Zmc2V0WzBdIDwgMCA/IG9mZnNldFswXSA6IFwiK1wiICsgb2Zmc2V0WzBdKSArIFwiIFwiICtcblx0XHRcdFx0XHRcdG15QXRbMV0gKyAob2Zmc2V0WzFdIDwgMCA/IG9mZnNldFsxXSA6IFwiK1wiICsgb2Zmc2V0WzFdKSxcblx0XHRcdFx0XHRhdDogbXlBdC5qb2luKCBcIiBcIiApXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHBvc2l0aW9uID0gJC5leHRlbmQoIHt9LCAkLnVpLmRpYWxvZy5wcm90b3R5cGUub3B0aW9ucy5wb3NpdGlvbiwgcG9zaXRpb24gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cG9zaXRpb24gPSAkLnVpLmRpYWxvZy5wcm90b3R5cGUub3B0aW9ucy5wb3NpdGlvbjtcblx0XHR9XG5cblx0XHQvLyBuZWVkIHRvIHNob3cgdGhlIGRpYWxvZyB0byBnZXQgdGhlIGFjdHVhbCBvZmZzZXQgaW4gdGhlIHBvc2l0aW9uIHBsdWdpblxuXHRcdGlzVmlzaWJsZSA9IHRoaXMudWlEaWFsb2cuaXMoIFwiOnZpc2libGVcIiApO1xuXHRcdGlmICggIWlzVmlzaWJsZSApIHtcblx0XHRcdHRoaXMudWlEaWFsb2cuc2hvdygpO1xuXHRcdH1cblx0XHR0aGlzLnVpRGlhbG9nLnBvc2l0aW9uKCBwb3NpdGlvbiApO1xuXHRcdGlmICggIWlzVmlzaWJsZSApIHtcblx0XHRcdHRoaXMudWlEaWFsb2cuaGlkZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0T3B0aW9uczogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0cmVzaXphYmxlT3B0aW9ucyA9IHt9LFxuXHRcdFx0cmVzaXplID0gZmFsc2U7XG5cblx0XHQkLmVhY2goIG9wdGlvbnMsIGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdFx0dGhhdC5fc2V0T3B0aW9uKCBrZXksIHZhbHVlICk7XG5cblx0XHRcdGlmICgga2V5IGluIHNpemVSZWxhdGVkT3B0aW9ucyApIHtcblx0XHRcdFx0cmVzaXplID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICgga2V5IGluIHJlc2l6YWJsZVJlbGF0ZWRPcHRpb25zICkge1xuXHRcdFx0XHRyZXNpemFibGVPcHRpb25zWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKCByZXNpemUgKSB7XG5cdFx0XHR0aGlzLl9zaXplKCk7XG5cdFx0fVxuXHRcdGlmICggdGhpcy51aURpYWxvZy5pcyggXCI6ZGF0YShyZXNpemFibGUpXCIgKSApIHtcblx0XHRcdHRoaXMudWlEaWFsb2cucmVzaXphYmxlKCBcIm9wdGlvblwiLCByZXNpemFibGVPcHRpb25zICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpc0RyYWdnYWJsZSwgaXNSZXNpemFibGUsXG5cdFx0XHR1aURpYWxvZyA9IHRoaXMudWlEaWFsb2c7XG5cblx0XHRzd2l0Y2ggKCBrZXkgKSB7XG5cdFx0XHRjYXNlIFwiYnV0dG9uc1wiOlxuXHRcdFx0XHR0aGlzLl9jcmVhdGVCdXR0b25zKCB2YWx1ZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJjbG9zZVRleHRcIjpcblx0XHRcdFx0Ly8gZW5zdXJlIHRoYXQgd2UgYWx3YXlzIHBhc3MgYSBzdHJpbmdcblx0XHRcdFx0dGhpcy51aURpYWxvZ1RpdGxlYmFyQ2xvc2VUZXh0LnRleHQoIFwiXCIgKyB2YWx1ZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJkaWFsb2dDbGFzc1wiOlxuXHRcdFx0XHR1aURpYWxvZ1xuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggdGhpcy5vcHRpb25zLmRpYWxvZ0NsYXNzIClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIHVpRGlhbG9nQ2xhc3NlcyArIHZhbHVlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImRpc2FibGVkXCI6XG5cdFx0XHRcdGlmICggdmFsdWUgKSB7XG5cdFx0XHRcdFx0dWlEaWFsb2cuYWRkQ2xhc3MoIFwidWktZGlhbG9nLWRpc2FibGVkXCIgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR1aURpYWxvZy5yZW1vdmVDbGFzcyggXCJ1aS1kaWFsb2ctZGlzYWJsZWRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImRyYWdnYWJsZVwiOlxuXHRcdFx0XHRpc0RyYWdnYWJsZSA9IHVpRGlhbG9nLmlzKCBcIjpkYXRhKGRyYWdnYWJsZSlcIiApO1xuXHRcdFx0XHRpZiAoIGlzRHJhZ2dhYmxlICYmICF2YWx1ZSApIHtcblx0XHRcdFx0XHR1aURpYWxvZy5kcmFnZ2FibGUoIFwiZGVzdHJveVwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoICFpc0RyYWdnYWJsZSAmJiB2YWx1ZSApIHtcblx0XHRcdFx0XHR0aGlzLl9tYWtlRHJhZ2dhYmxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwicG9zaXRpb25cIjpcblx0XHRcdFx0dGhpcy5fcG9zaXRpb24oIHZhbHVlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInJlc2l6YWJsZVwiOlxuXHRcdFx0XHQvLyBjdXJyZW50bHkgcmVzaXphYmxlLCBiZWNvbWluZyBub24tcmVzaXphYmxlXG5cdFx0XHRcdGlzUmVzaXphYmxlID0gdWlEaWFsb2cuaXMoIFwiOmRhdGEocmVzaXphYmxlKVwiICk7XG5cdFx0XHRcdGlmICggaXNSZXNpemFibGUgJiYgIXZhbHVlICkge1xuXHRcdFx0XHRcdHVpRGlhbG9nLnJlc2l6YWJsZSggXCJkZXN0cm95XCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGN1cnJlbnRseSByZXNpemFibGUsIGNoYW5naW5nIGhhbmRsZXNcblx0XHRcdFx0aWYgKCBpc1Jlc2l6YWJsZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0dWlEaWFsb2cucmVzaXphYmxlKCBcIm9wdGlvblwiLCBcImhhbmRsZXNcIiwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGN1cnJlbnRseSBub24tcmVzaXphYmxlLCBiZWNvbWluZyByZXNpemFibGVcblx0XHRcdFx0aWYgKCAhaXNSZXNpemFibGUgJiYgdmFsdWUgIT09IGZhbHNlICkge1xuXHRcdFx0XHRcdHRoaXMuX21ha2VSZXNpemFibGUoIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwidGl0bGVcIjpcblx0XHRcdFx0Ly8gY29udmVydCB3aGF0ZXZlciB3YXMgcGFzc2VkIGluIG8gYSBzdHJpbmcsIGZvciBodG1sKCkgdG8gbm90IHRocm93IHVwXG5cdFx0XHRcdCQoIFwiLnVpLWRpYWxvZy10aXRsZVwiLCB0aGlzLnVpRGlhbG9nVGl0bGViYXIgKVxuXHRcdFx0XHRcdC5odG1sKCBcIlwiICsgKCB2YWx1ZSB8fCBcIiYjMTYwO1wiICkgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3VwZXIoIGtleSwgdmFsdWUgKTtcblx0fSxcblxuXHRfc2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0LyogSWYgdGhlIHVzZXIgaGFzIHJlc2l6ZWQgdGhlIGRpYWxvZywgdGhlIC51aS1kaWFsb2cgYW5kIC51aS1kaWFsb2ctY29udGVudFxuXHRcdCAqIGRpdnMgd2lsbCBib3RoIGhhdmUgd2lkdGggYW5kIGhlaWdodCBzZXQsIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlbVxuXHRcdCAqL1xuXHRcdHZhciBub25Db250ZW50SGVpZ2h0LCBtaW5Db250ZW50SGVpZ2h0LCBhdXRvSGVpZ2h0LFxuXHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGlzVmlzaWJsZSA9IHRoaXMudWlEaWFsb2cuaXMoIFwiOnZpc2libGVcIiApO1xuXG5cdFx0Ly8gcmVzZXQgY29udGVudCBzaXppbmdcblx0XHR0aGlzLmVsZW1lbnQuc2hvdygpLmNzcyh7XG5cdFx0XHR3aWR0aDogXCJhdXRvXCIsXG5cdFx0XHRtaW5IZWlnaHQ6IDAsXG5cdFx0XHRoZWlnaHQ6IDBcblx0XHR9KTtcblxuXHRcdGlmICggb3B0aW9ucy5taW5XaWR0aCA+IG9wdGlvbnMud2lkdGggKSB7XG5cdFx0XHRvcHRpb25zLndpZHRoID0gb3B0aW9ucy5taW5XaWR0aDtcblx0XHR9XG5cblx0XHQvLyByZXNldCB3cmFwcGVyIHNpemluZ1xuXHRcdC8vIGRldGVybWluZSB0aGUgaGVpZ2h0IG9mIGFsbCB0aGUgbm9uLWNvbnRlbnQgZWxlbWVudHNcblx0XHRub25Db250ZW50SGVpZ2h0ID0gdGhpcy51aURpYWxvZy5jc3Moe1xuXHRcdFx0XHRoZWlnaHQ6IFwiYXV0b1wiLFxuXHRcdFx0XHR3aWR0aDogb3B0aW9ucy53aWR0aFxuXHRcdFx0fSlcblx0XHRcdC5vdXRlckhlaWdodCgpO1xuXHRcdG1pbkNvbnRlbnRIZWlnaHQgPSBNYXRoLm1heCggMCwgb3B0aW9ucy5taW5IZWlnaHQgLSBub25Db250ZW50SGVpZ2h0ICk7XG5cblx0XHRpZiAoIG9wdGlvbnMuaGVpZ2h0ID09PSBcImF1dG9cIiApIHtcblx0XHRcdC8vIG9ubHkgbmVlZGVkIGZvciBJRTYgc3VwcG9ydFxuXHRcdFx0aWYgKCAkLnN1cHBvcnQubWluSGVpZ2h0ICkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuY3NzKHtcblx0XHRcdFx0XHRtaW5IZWlnaHQ6IG1pbkNvbnRlbnRIZWlnaHQsXG5cdFx0XHRcdFx0aGVpZ2h0OiBcImF1dG9cIlxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudWlEaWFsb2cuc2hvdygpO1xuXHRcdFx0XHRhdXRvSGVpZ2h0ID0gdGhpcy5lbGVtZW50LmNzcyggXCJoZWlnaHRcIiwgXCJhdXRvXCIgKS5oZWlnaHQoKTtcblx0XHRcdFx0aWYgKCAhaXNWaXNpYmxlICkge1xuXHRcdFx0XHRcdHRoaXMudWlEaWFsb2cuaGlkZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5oZWlnaHQoIE1hdGgubWF4KCBhdXRvSGVpZ2h0LCBtaW5Db250ZW50SGVpZ2h0ICkgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5lbGVtZW50LmhlaWdodCggTWF0aC5tYXgoIG9wdGlvbnMuaGVpZ2h0IC0gbm9uQ29udGVudEhlaWdodCwgMCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMudWlEaWFsb2cuaXMoIFwiOmRhdGEocmVzaXphYmxlKVwiICkgKSB7XG5cdFx0XHR0aGlzLnVpRGlhbG9nLnJlc2l6YWJsZSggXCJvcHRpb25cIiwgXCJtaW5IZWlnaHRcIiwgdGhpcy5fbWluSGVpZ2h0KCkgKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4kLmV4dGVuZCgkLnVpLmRpYWxvZywge1xuXHR1dWlkOiAwLFxuXHRtYXhaOiAwLFxuXG5cdGdldFRpdGxlSWQ6IGZ1bmN0aW9uKCRlbCkge1xuXHRcdHZhciBpZCA9ICRlbC5hdHRyKCBcImlkXCIgKTtcblx0XHRpZiAoICFpZCApIHtcblx0XHRcdHRoaXMudXVpZCArPSAxO1xuXHRcdFx0aWQgPSB0aGlzLnV1aWQ7XG5cdFx0fVxuXHRcdHJldHVybiBcInVpLWRpYWxvZy10aXRsZS1cIiArIGlkO1xuXHR9LFxuXG5cdG92ZXJsYXk6IGZ1bmN0aW9uKCBkaWFsb2cgKSB7XG5cdFx0dGhpcy4kZWwgPSAkLnVpLmRpYWxvZy5vdmVybGF5LmNyZWF0ZSggZGlhbG9nICk7XG5cdH1cbn0pO1xuXG4kLmV4dGVuZCggJC51aS5kaWFsb2cub3ZlcmxheSwge1xuXHRpbnN0YW5jZXM6IFtdLFxuXHQvLyByZXVzZSBvbGQgaW5zdGFuY2VzIGR1ZSB0byBJRSBtZW1vcnkgbGVhayB3aXRoIGFscGhhIHRyYW5zcGFyZW5jeSAoc2VlICM1MTg1KVxuXHRvbGRJbnN0YW5jZXM6IFtdLFxuXHRtYXhaOiAwLFxuXHRldmVudHM6ICQubWFwKFxuXHRcdFwiZm9jdXMsbW91c2Vkb3duLG1vdXNldXAsa2V5ZG93bixrZXlwcmVzcyxjbGlja1wiLnNwbGl0KCBcIixcIiApLFxuXHRcdGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHJldHVybiBldmVudCArIFwiLmRpYWxvZy1vdmVybGF5XCI7XG5cdFx0fVxuXHQpLmpvaW4oIFwiIFwiICksXG5cdGNyZWF0ZTogZnVuY3Rpb24oIGRpYWxvZyApIHtcblx0XHRpZiAoIHRoaXMuaW5zdGFuY2VzLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdC8vIHByZXZlbnQgdXNlIG9mIGFuY2hvcnMgYW5kIGlucHV0c1xuXHRcdFx0Ly8gd2UgdXNlIGEgc2V0VGltZW91dCBpbiBjYXNlIHRoZSBvdmVybGF5IGlzIGNyZWF0ZWQgZnJvbSBhblxuXHRcdFx0Ly8gZXZlbnQgdGhhdCB3ZSdyZSBnb2luZyB0byBiZSBjYW5jZWxsaW5nIChzZWUgIzI4MDQpXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBoYW5kbGUgJChlbCkuZGlhbG9nKCkuZGlhbG9nKCdjbG9zZScpIChzZWUgIzQwNjUpXG5cdFx0XHRcdGlmICggJC51aS5kaWFsb2cub3ZlcmxheS5pbnN0YW5jZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdCQoIGRvY3VtZW50ICkuYmluZCggJC51aS5kaWFsb2cub3ZlcmxheS5ldmVudHMsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRcdC8vIHN0b3AgZXZlbnRzIGlmIHRoZSB6LWluZGV4IG9mIHRoZSB0YXJnZXQgaXMgPCB0aGUgei1pbmRleCBvZiB0aGUgb3ZlcmxheVxuXHRcdFx0XHRcdFx0Ly8gd2UgY2Fubm90IHJldHVybiB0cnVlIHdoZW4gd2UgZG9uJ3Qgd2FudCB0byBjYW5jZWwgdGhlIGV2ZW50ICgjMzUyMylcblx0XHRcdFx0XHRcdGlmICggJCggZXZlbnQudGFyZ2V0ICkuekluZGV4KCkgPCAkLnVpLmRpYWxvZy5vdmVybGF5Lm1heFogKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgMSApO1xuXG5cdFx0XHQvLyBoYW5kbGUgd2luZG93IHJlc2l6ZVxuXHRcdFx0JCggd2luZG93ICkuYmluZCggXCJyZXNpemUuZGlhbG9nLW92ZXJsYXlcIiwgJC51aS5kaWFsb2cub3ZlcmxheS5yZXNpemUgKTtcblx0XHR9XG5cblx0XHR2YXIgJGVsID0gKCB0aGlzLm9sZEluc3RhbmNlcy5wb3AoKSB8fCAkKCBcIjxkaXY+XCIgKS5hZGRDbGFzcyggXCJ1aS13aWRnZXQtb3ZlcmxheVwiICkgKTtcblxuXHRcdC8vIGFsbG93IGNsb3NpbmcgYnkgcHJlc3NpbmcgdGhlIGVzY2FwZSBrZXlcblx0XHQkKCBkb2N1bWVudCApLmJpbmQoIFwia2V5ZG93bi5kaWFsb2ctb3ZlcmxheVwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgaW5zdGFuY2VzID0gJC51aS5kaWFsb2cub3ZlcmxheS5pbnN0YW5jZXM7XG5cdFx0XHQvLyBvbmx5IHJlYWN0IHRvIHRoZSBldmVudCBpZiB3ZSdyZSB0aGUgdG9wIG92ZXJsYXlcblx0XHRcdGlmICggaW5zdGFuY2VzLmxlbmd0aCAhPT0gMCAmJiBpbnN0YW5jZXNbIGluc3RhbmNlcy5sZW5ndGggLSAxIF0gPT09ICRlbCAmJlxuXHRcdFx0XHRkaWFsb2cub3B0aW9ucy5jbG9zZU9uRXNjYXBlICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSAmJiBldmVudC5rZXlDb2RlICYmXG5cdFx0XHRcdGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5FU0NBUEUgKSB7XG5cblx0XHRcdFx0ZGlhbG9nLmNsb3NlKCBldmVudCApO1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0JGVsLmFwcGVuZFRvKCBkb2N1bWVudC5ib2R5ICkuY3NzKHtcblx0XHRcdHdpZHRoOiB0aGlzLndpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IHRoaXMuaGVpZ2h0KClcblx0XHR9KTtcblxuXHRcdGlmICggJC5mbi5iZ2lmcmFtZSApIHtcblx0XHRcdCRlbC5iZ2lmcmFtZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuaW5zdGFuY2VzLnB1c2goICRlbCApO1xuXHRcdHJldHVybiAkZWw7XG5cdH0sXG5cblx0ZGVzdHJveTogZnVuY3Rpb24oICRlbCApIHtcblx0XHR2YXIgaW5kZXhPZiA9ICQuaW5BcnJheSggJGVsLCB0aGlzLmluc3RhbmNlcyApLFxuXHRcdFx0bWF4WiA9IDA7XG5cblx0XHRpZiAoIGluZGV4T2YgIT09IC0xICkge1xuXHRcdFx0dGhpcy5vbGRJbnN0YW5jZXMucHVzaCggdGhpcy5pbnN0YW5jZXMuc3BsaWNlKCBpbmRleE9mLCAxIClbIDAgXSApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5pbnN0YW5jZXMubGVuZ3RoID09PSAwICkge1xuXHRcdFx0JCggWyBkb2N1bWVudCwgd2luZG93IF0gKS51bmJpbmQoIFwiLmRpYWxvZy1vdmVybGF5XCIgKTtcblx0XHR9XG5cblx0XHQkZWwuaGVpZ2h0KCAwICkud2lkdGgoIDAgKS5yZW1vdmUoKTtcblxuXHRcdC8vIGFkanVzdCB0aGUgbWF4WiB0byBhbGxvdyBvdGhlciBtb2RhbCBkaWFsb2dzIHRvIGNvbnRpbnVlIHRvIHdvcmsgKHNlZSAjNDMwOSlcblx0XHQkLmVhY2goIHRoaXMuaW5zdGFuY2VzLCBmdW5jdGlvbigpIHtcblx0XHRcdG1heFogPSBNYXRoLm1heCggbWF4WiwgdGhpcy5jc3MoIFwiei1pbmRleFwiICkgKTtcblx0XHR9KTtcblx0XHR0aGlzLm1heFogPSBtYXhaO1xuXHR9LFxuXG5cdGhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNjcm9sbEhlaWdodCxcblx0XHRcdG9mZnNldEhlaWdodDtcblx0XHQvLyBoYW5kbGUgSUVcblx0XHRpZiAoICQudWkuaWUgKSB7XG5cdFx0XHRzY3JvbGxIZWlnaHQgPSBNYXRoLm1heChcblx0XHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCxcblx0XHRcdFx0ZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHRcblx0XHRcdCk7XG5cdFx0XHRvZmZzZXRIZWlnaHQgPSBNYXRoLm1heChcblx0XHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodCxcblx0XHRcdFx0ZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHRcblx0XHRcdCk7XG5cblx0XHRcdGlmICggc2Nyb2xsSGVpZ2h0IDwgb2Zmc2V0SGVpZ2h0ICkge1xuXHRcdFx0XHRyZXR1cm4gJCggd2luZG93ICkuaGVpZ2h0KCkgKyBcInB4XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gc2Nyb2xsSGVpZ2h0ICsgXCJweFwiO1xuXHRcdFx0fVxuXHRcdC8vIGhhbmRsZSBcImdvb2RcIiBicm93c2Vyc1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gJCggZG9jdW1lbnQgKS5oZWlnaHQoKSArIFwicHhcIjtcblx0XHR9XG5cdH0sXG5cblx0d2lkdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzY3JvbGxXaWR0aCxcblx0XHRcdG9mZnNldFdpZHRoO1xuXHRcdC8vIGhhbmRsZSBJRVxuXHRcdGlmICggJC51aS5pZSApIHtcblx0XHRcdHNjcm9sbFdpZHRoID0gTWF0aC5tYXgoXG5cdFx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCxcblx0XHRcdFx0ZG9jdW1lbnQuYm9keS5zY3JvbGxXaWR0aFxuXHRcdFx0KTtcblx0XHRcdG9mZnNldFdpZHRoID0gTWF0aC5tYXgoXG5cdFx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRXaWR0aCxcblx0XHRcdFx0ZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aFxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKCBzY3JvbGxXaWR0aCA8IG9mZnNldFdpZHRoICkge1xuXHRcdFx0XHRyZXR1cm4gJCggd2luZG93ICkud2lkdGgoKSArIFwicHhcIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBzY3JvbGxXaWR0aCArIFwicHhcIjtcblx0XHRcdH1cblx0XHQvLyBoYW5kbGUgXCJnb29kXCIgYnJvd3NlcnNcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuICQoIGRvY3VtZW50ICkud2lkdGgoKSArIFwicHhcIjtcblx0XHR9XG5cdH0sXG5cblx0cmVzaXplOiBmdW5jdGlvbigpIHtcblx0XHQvKiBJZiB0aGUgZGlhbG9nIGlzIGRyYWdnYWJsZSBhbmQgdGhlIHVzZXIgZHJhZ3MgaXQgcGFzdCB0aGVcblx0XHQgKiByaWdodCBlZGdlIG9mIHRoZSB3aW5kb3csIHRoZSBkb2N1bWVudCBiZWNvbWVzIHdpZGVyIHNvIHdlXG5cdFx0ICogbmVlZCB0byBzdHJldGNoIHRoZSBvdmVybGF5LiBJZiB0aGUgdXNlciB0aGVuIGRyYWdzIHRoZVxuXHRcdCAqIGRpYWxvZyBiYWNrIHRvIHRoZSBsZWZ0LCB0aGUgZG9jdW1lbnQgd2lsbCBiZWNvbWUgbmFycm93ZXIsXG5cdFx0ICogc28gd2UgbmVlZCB0byBzaHJpbmsgdGhlIG92ZXJsYXkgdG8gdGhlIGFwcHJvcHJpYXRlIHNpemUuXG5cdFx0ICogVGhpcyBpcyBoYW5kbGVkIGJ5IHNocmlua2luZyB0aGUgb3ZlcmxheSBiZWZvcmUgc2V0dGluZyBpdFxuXHRcdCAqIHRvIHRoZSBmdWxsIGRvY3VtZW50IHNpemUuXG5cdFx0ICovXG5cdFx0dmFyICRvdmVybGF5cyA9ICQoIFtdICk7XG5cdFx0JC5lYWNoKCAkLnVpLmRpYWxvZy5vdmVybGF5Lmluc3RhbmNlcywgZnVuY3Rpb24oKSB7XG5cdFx0XHQkb3ZlcmxheXMgPSAkb3ZlcmxheXMuYWRkKCB0aGlzICk7XG5cdFx0fSk7XG5cblx0XHQkb3ZlcmxheXMuY3NzKHtcblx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0aGVpZ2h0OiAwXG5cdFx0fSkuY3NzKHtcblx0XHRcdHdpZHRoOiAkLnVpLmRpYWxvZy5vdmVybGF5LndpZHRoKCksXG5cdFx0XHRoZWlnaHQ6ICQudWkuZGlhbG9nLm92ZXJsYXkuaGVpZ2h0KClcblx0XHR9KTtcblx0fVxufSk7XG5cbiQuZXh0ZW5kKCAkLnVpLmRpYWxvZy5vdmVybGF5LnByb3RvdHlwZSwge1xuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHQkLnVpLmRpYWxvZy5vdmVybGF5LmRlc3Ryb3koIHRoaXMuJGVsICk7XG5cdH1cbn0pO1xuXG59KCBqUXVlcnkgKSApO1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQud2lkZ2V0KFwidWkuZHJhZ2dhYmxlXCIsICQudWkubW91c2UsIHtcblx0dmVyc2lvbjogXCIxLjkuMlwiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJkcmFnXCIsXG5cdG9wdGlvbnM6IHtcblx0XHRhZGRDbGFzc2VzOiB0cnVlLFxuXHRcdGFwcGVuZFRvOiBcInBhcmVudFwiLFxuXHRcdGF4aXM6IGZhbHNlLFxuXHRcdGNvbm5lY3RUb1NvcnRhYmxlOiBmYWxzZSxcblx0XHRjb250YWlubWVudDogZmFsc2UsXG5cdFx0Y3Vyc29yOiBcImF1dG9cIixcblx0XHRjdXJzb3JBdDogZmFsc2UsXG5cdFx0Z3JpZDogZmFsc2UsXG5cdFx0aGFuZGxlOiBmYWxzZSxcblx0XHRoZWxwZXI6IFwib3JpZ2luYWxcIixcblx0XHRpZnJhbWVGaXg6IGZhbHNlLFxuXHRcdG9wYWNpdHk6IGZhbHNlLFxuXHRcdHJlZnJlc2hQb3NpdGlvbnM6IGZhbHNlLFxuXHRcdHJldmVydDogZmFsc2UsXG5cdFx0cmV2ZXJ0RHVyYXRpb246IDUwMCxcblx0XHRzY29wZTogXCJkZWZhdWx0XCIsXG5cdFx0c2Nyb2xsOiB0cnVlLFxuXHRcdHNjcm9sbFNlbnNpdGl2aXR5OiAyMCxcblx0XHRzY3JvbGxTcGVlZDogMjAsXG5cdFx0c25hcDogZmFsc2UsXG5cdFx0c25hcE1vZGU6IFwiYm90aFwiLFxuXHRcdHNuYXBUb2xlcmFuY2U6IDIwLFxuXHRcdHN0YWNrOiBmYWxzZSxcblx0XHR6SW5kZXg6IGZhbHNlXG5cdH0sXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5oZWxwZXIgPT0gJ29yaWdpbmFsJyAmJiAhKC9eKD86cnxhfGYpLykudGVzdCh0aGlzLmVsZW1lbnQuY3NzKFwicG9zaXRpb25cIikpKVxuXHRcdFx0dGhpcy5lbGVtZW50WzBdLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcblxuXHRcdCh0aGlzLm9wdGlvbnMuYWRkQ2xhc3NlcyAmJiB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXCJ1aS1kcmFnZ2FibGVcIikpO1xuXHRcdCh0aGlzLm9wdGlvbnMuZGlzYWJsZWQgJiYgdGhpcy5lbGVtZW50LmFkZENsYXNzKFwidWktZHJhZ2dhYmxlLWRpc2FibGVkXCIpKTtcblxuXHRcdHRoaXMuX21vdXNlSW5pdCgpO1xuXG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyggXCJ1aS1kcmFnZ2FibGUgdWktZHJhZ2dhYmxlLWRyYWdnaW5nIHVpLWRyYWdnYWJsZS1kaXNhYmxlZFwiICk7XG5cdFx0dGhpcy5fbW91c2VEZXN0cm95KCk7XG5cdH0sXG5cblx0X21vdXNlQ2FwdHVyZTogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0Ly8gYW1vbmcgb3RoZXJzLCBwcmV2ZW50IGEgZHJhZyBvbiBhIHJlc2l6YWJsZS1oYW5kbGVcblx0XHRpZiAodGhpcy5oZWxwZXIgfHwgby5kaXNhYmxlZCB8fCAkKGV2ZW50LnRhcmdldCkuaXMoJy51aS1yZXNpemFibGUtaGFuZGxlJykpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHQvL1F1aXQgaWYgd2UncmUgbm90IG9uIGEgdmFsaWQgaGFuZGxlXG5cdFx0dGhpcy5oYW5kbGUgPSB0aGlzLl9nZXRIYW5kbGUoZXZlbnQpO1xuXHRcdGlmICghdGhpcy5oYW5kbGUpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHQkKG8uaWZyYW1lRml4ID09PSB0cnVlID8gXCJpZnJhbWVcIiA6IG8uaWZyYW1lRml4KS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0JCgnPGRpdiBjbGFzcz1cInVpLWRyYWdnYWJsZS1pZnJhbWVGaXhcIiBzdHlsZT1cImJhY2tncm91bmQ6ICNmZmY7XCI+PC9kaXY+Jylcblx0XHRcdC5jc3Moe1xuXHRcdFx0XHR3aWR0aDogdGhpcy5vZmZzZXRXaWR0aCtcInB4XCIsIGhlaWdodDogdGhpcy5vZmZzZXRIZWlnaHQrXCJweFwiLFxuXHRcdFx0XHRwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCBvcGFjaXR5OiBcIjAuMDAxXCIsIHpJbmRleDogMTAwMFxuXHRcdFx0fSlcblx0XHRcdC5jc3MoJCh0aGlzKS5vZmZzZXQoKSlcblx0XHRcdC5hcHBlbmRUbyhcImJvZHlcIik7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9LFxuXG5cdF9tb3VzZVN0YXJ0OiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnM7XG5cblx0XHQvL0NyZWF0ZSBhbmQgYXBwZW5kIHRoZSB2aXNpYmxlIGhlbHBlclxuXHRcdHRoaXMuaGVscGVyID0gdGhpcy5fY3JlYXRlSGVscGVyKGV2ZW50KTtcblxuXHRcdHRoaXMuaGVscGVyLmFkZENsYXNzKFwidWktZHJhZ2dhYmxlLWRyYWdnaW5nXCIpO1xuXG5cdFx0Ly9DYWNoZSB0aGUgaGVscGVyIHNpemVcblx0XHR0aGlzLl9jYWNoZUhlbHBlclByb3BvcnRpb25zKCk7XG5cblx0XHQvL0lmIGRkbWFuYWdlciBpcyB1c2VkIGZvciBkcm9wcGFibGVzLCBzZXQgdGhlIGdsb2JhbCBkcmFnZ2FibGVcblx0XHRpZigkLnVpLmRkbWFuYWdlcilcblx0XHRcdCQudWkuZGRtYW5hZ2VyLmN1cnJlbnQgPSB0aGlzO1xuXG5cdFx0Lypcblx0XHQgKiAtIFBvc2l0aW9uIGdlbmVyYXRpb24gLVxuXHRcdCAqIFRoaXMgYmxvY2sgZ2VuZXJhdGVzIGV2ZXJ5dGhpbmcgcG9zaXRpb24gcmVsYXRlZCAtIGl0J3MgdGhlIGNvcmUgb2YgZHJhZ2dhYmxlcy5cblx0XHQgKi9cblxuXHRcdC8vQ2FjaGUgdGhlIG1hcmdpbnMgb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnRcblx0XHR0aGlzLl9jYWNoZU1hcmdpbnMoKTtcblxuXHRcdC8vU3RvcmUgdGhlIGhlbHBlcidzIGNzcyBwb3NpdGlvblxuXHRcdHRoaXMuY3NzUG9zaXRpb24gPSB0aGlzLmhlbHBlci5jc3MoXCJwb3NpdGlvblwiKTtcblx0XHR0aGlzLnNjcm9sbFBhcmVudCA9IHRoaXMuaGVscGVyLnNjcm9sbFBhcmVudCgpO1xuXG5cdFx0Ly9UaGUgZWxlbWVudCdzIGFic29sdXRlIHBvc2l0aW9uIG9uIHRoZSBwYWdlIG1pbnVzIG1hcmdpbnNcblx0XHR0aGlzLm9mZnNldCA9IHRoaXMucG9zaXRpb25BYnMgPSB0aGlzLmVsZW1lbnQub2Zmc2V0KCk7XG5cdFx0dGhpcy5vZmZzZXQgPSB7XG5cdFx0XHR0b3A6IHRoaXMub2Zmc2V0LnRvcCAtIHRoaXMubWFyZ2lucy50b3AsXG5cdFx0XHRsZWZ0OiB0aGlzLm9mZnNldC5sZWZ0IC0gdGhpcy5tYXJnaW5zLmxlZnRcblx0XHR9O1xuXG5cdFx0JC5leHRlbmQodGhpcy5vZmZzZXQsIHtcblx0XHRcdGNsaWNrOiB7IC8vV2hlcmUgdGhlIGNsaWNrIGhhcHBlbmVkLCByZWxhdGl2ZSB0byB0aGUgZWxlbWVudFxuXHRcdFx0XHRsZWZ0OiBldmVudC5wYWdlWCAtIHRoaXMub2Zmc2V0LmxlZnQsXG5cdFx0XHRcdHRvcDogZXZlbnQucGFnZVkgLSB0aGlzLm9mZnNldC50b3Bcblx0XHRcdH0sXG5cdFx0XHRwYXJlbnQ6IHRoaXMuX2dldFBhcmVudE9mZnNldCgpLFxuXHRcdFx0cmVsYXRpdmU6IHRoaXMuX2dldFJlbGF0aXZlT2Zmc2V0KCkgLy9UaGlzIGlzIGEgcmVsYXRpdmUgdG8gYWJzb2x1dGUgcG9zaXRpb24gbWludXMgdGhlIGFjdHVhbCBwb3NpdGlvbiBjYWxjdWxhdGlvbiAtIG9ubHkgdXNlZCBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBoZWxwZXJcblx0XHR9KTtcblxuXHRcdC8vR2VuZXJhdGUgdGhlIG9yaWdpbmFsIHBvc2l0aW9uXG5cdFx0dGhpcy5vcmlnaW5hbFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiA9IHRoaXMuX2dlbmVyYXRlUG9zaXRpb24oZXZlbnQpO1xuXHRcdHRoaXMub3JpZ2luYWxQYWdlWCA9IGV2ZW50LnBhZ2VYO1xuXHRcdHRoaXMub3JpZ2luYWxQYWdlWSA9IGV2ZW50LnBhZ2VZO1xuXG5cdFx0Ly9BZGp1c3QgdGhlIG1vdXNlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgaGVscGVyIGlmICdjdXJzb3JBdCcgaXMgc3VwcGxpZWRcblx0XHQoby5jdXJzb3JBdCAmJiB0aGlzLl9hZGp1c3RPZmZzZXRGcm9tSGVscGVyKG8uY3Vyc29yQXQpKTtcblxuXHRcdC8vU2V0IGEgY29udGFpbm1lbnQgaWYgZ2l2ZW4gaW4gdGhlIG9wdGlvbnNcblx0XHRpZihvLmNvbnRhaW5tZW50KVxuXHRcdFx0dGhpcy5fc2V0Q29udGFpbm1lbnQoKTtcblxuXHRcdC8vVHJpZ2dlciBldmVudCArIGNhbGxiYWNrc1xuXHRcdGlmKHRoaXMuX3RyaWdnZXIoXCJzdGFydFwiLCBldmVudCkgPT09IGZhbHNlKSB7XG5cdFx0XHR0aGlzLl9jbGVhcigpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vUmVjYWNoZSB0aGUgaGVscGVyIHNpemVcblx0XHR0aGlzLl9jYWNoZUhlbHBlclByb3BvcnRpb25zKCk7XG5cblx0XHQvL1ByZXBhcmUgdGhlIGRyb3BwYWJsZSBvZmZzZXRzXG5cdFx0aWYgKCQudWkuZGRtYW5hZ2VyICYmICFvLmRyb3BCZWhhdmlvdXIpXG5cdFx0XHQkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyh0aGlzLCBldmVudCk7XG5cblxuXHRcdHRoaXMuX21vdXNlRHJhZyhldmVudCwgdHJ1ZSk7IC8vRXhlY3V0ZSB0aGUgZHJhZyBvbmNlIC0gdGhpcyBjYXVzZXMgdGhlIGhlbHBlciBub3QgdG8gYmUgdmlzaWJsZSBiZWZvcmUgZ2V0dGluZyBpdHMgY29ycmVjdCBwb3NpdGlvblxuXG5cdFx0Ly9JZiB0aGUgZGRtYW5hZ2VyIGlzIHVzZWQgZm9yIGRyb3BwYWJsZXMsIGluZm9ybSB0aGUgbWFuYWdlciB0aGF0IGRyYWdnaW5nIGhhcyBzdGFydGVkIChzZWUgIzUwMDMpXG5cdFx0aWYgKCAkLnVpLmRkbWFuYWdlciApICQudWkuZGRtYW5hZ2VyLmRyYWdTdGFydCh0aGlzLCBldmVudCk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfbW91c2VEcmFnOiBmdW5jdGlvbihldmVudCwgbm9Qcm9wYWdhdGlvbikge1xuXG5cdFx0Ly9Db21wdXRlIHRoZSBoZWxwZXJzIHBvc2l0aW9uXG5cdFx0dGhpcy5wb3NpdGlvbiA9IHRoaXMuX2dlbmVyYXRlUG9zaXRpb24oZXZlbnQpO1xuXHRcdHRoaXMucG9zaXRpb25BYnMgPSB0aGlzLl9jb252ZXJ0UG9zaXRpb25UbyhcImFic29sdXRlXCIpO1xuXG5cdFx0Ly9DYWxsIHBsdWdpbnMgYW5kIGNhbGxiYWNrcyBhbmQgdXNlIHRoZSByZXN1bHRpbmcgcG9zaXRpb24gaWYgc29tZXRoaW5nIGlzIHJldHVybmVkXG5cdFx0aWYgKCFub1Byb3BhZ2F0aW9uKSB7XG5cdFx0XHR2YXIgdWkgPSB0aGlzLl91aUhhc2goKTtcblx0XHRcdGlmKHRoaXMuX3RyaWdnZXIoJ2RyYWcnLCBldmVudCwgdWkpID09PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLl9tb3VzZVVwKHt9KTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5wb3NpdGlvbiA9IHVpLnBvc2l0aW9uO1xuXHRcdH1cblxuXHRcdGlmKCF0aGlzLm9wdGlvbnMuYXhpcyB8fCB0aGlzLm9wdGlvbnMuYXhpcyAhPSBcInlcIikgdGhpcy5oZWxwZXJbMF0uc3R5bGUubGVmdCA9IHRoaXMucG9zaXRpb24ubGVmdCsncHgnO1xuXHRcdGlmKCF0aGlzLm9wdGlvbnMuYXhpcyB8fCB0aGlzLm9wdGlvbnMuYXhpcyAhPSBcInhcIikgdGhpcy5oZWxwZXJbMF0uc3R5bGUudG9wID0gdGhpcy5wb3NpdGlvbi50b3ArJ3B4Jztcblx0XHRpZigkLnVpLmRkbWFuYWdlcikgJC51aS5kZG1hbmFnZXIuZHJhZyh0aGlzLCBldmVudCk7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X21vdXNlU3RvcDogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdC8vSWYgd2UgYXJlIHVzaW5nIGRyb3BwYWJsZXMsIGluZm9ybSB0aGUgbWFuYWdlciBhYm91dCB0aGUgZHJvcFxuXHRcdHZhciBkcm9wcGVkID0gZmFsc2U7XG5cdFx0aWYgKCQudWkuZGRtYW5hZ2VyICYmICF0aGlzLm9wdGlvbnMuZHJvcEJlaGF2aW91cilcblx0XHRcdGRyb3BwZWQgPSAkLnVpLmRkbWFuYWdlci5kcm9wKHRoaXMsIGV2ZW50KTtcblxuXHRcdC8vaWYgYSBkcm9wIGNvbWVzIGZyb20gb3V0c2lkZSAoYSBzb3J0YWJsZSlcblx0XHRpZih0aGlzLmRyb3BwZWQpIHtcblx0XHRcdGRyb3BwZWQgPSB0aGlzLmRyb3BwZWQ7XG5cdFx0XHR0aGlzLmRyb3BwZWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvL2lmIHRoZSBvcmlnaW5hbCBlbGVtZW50IGlzIG5vIGxvbmdlciBpbiB0aGUgRE9NIGRvbid0IGJvdGhlciB0byBjb250aW51ZSAoc2VlICM4MjY5KVxuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50WzBdLCBlbGVtZW50SW5Eb20gPSBmYWxzZTtcblx0XHR3aGlsZSAoIGVsZW1lbnQgJiYgKGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGUpICkge1xuXHRcdFx0aWYgKGVsZW1lbnQgPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdGVsZW1lbnRJbkRvbSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggIWVsZW1lbnRJbkRvbSAmJiB0aGlzLm9wdGlvbnMuaGVscGVyID09PSBcIm9yaWdpbmFsXCIgKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0aWYoKHRoaXMub3B0aW9ucy5yZXZlcnQgPT0gXCJpbnZhbGlkXCIgJiYgIWRyb3BwZWQpIHx8ICh0aGlzLm9wdGlvbnMucmV2ZXJ0ID09IFwidmFsaWRcIiAmJiBkcm9wcGVkKSB8fCB0aGlzLm9wdGlvbnMucmV2ZXJ0ID09PSB0cnVlIHx8ICgkLmlzRnVuY3Rpb24odGhpcy5vcHRpb25zLnJldmVydCkgJiYgdGhpcy5vcHRpb25zLnJldmVydC5jYWxsKHRoaXMuZWxlbWVudCwgZHJvcHBlZCkpKSB7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHQkKHRoaXMuaGVscGVyKS5hbmltYXRlKHRoaXMub3JpZ2luYWxQb3NpdGlvbiwgcGFyc2VJbnQodGhpcy5vcHRpb25zLnJldmVydER1cmF0aW9uLCAxMCksIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZih0aGF0Ll90cmlnZ2VyKFwic3RvcFwiLCBldmVudCkgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0dGhhdC5fY2xlYXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmKHRoaXMuX3RyaWdnZXIoXCJzdG9wXCIsIGV2ZW50KSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5fY2xlYXIoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X21vdXNlVXA6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0Ly9SZW1vdmUgZnJhbWUgaGVscGVyc1xuXHRcdCQoXCJkaXYudWktZHJhZ2dhYmxlLWlmcmFtZUZpeFwiKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpO1xuXHRcdH0pO1xuXG5cdFx0Ly9JZiB0aGUgZGRtYW5hZ2VyIGlzIHVzZWQgZm9yIGRyb3BwYWJsZXMsIGluZm9ybSB0aGUgbWFuYWdlciB0aGF0IGRyYWdnaW5nIGhhcyBzdG9wcGVkIChzZWUgIzUwMDMpXG5cdFx0aWYoICQudWkuZGRtYW5hZ2VyICkgJC51aS5kZG1hbmFnZXIuZHJhZ1N0b3AodGhpcywgZXZlbnQpO1xuXG5cdFx0cmV0dXJuICQudWkubW91c2UucHJvdG90eXBlLl9tb3VzZVVwLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9LFxuXG5cdGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cblx0XHRpZih0aGlzLmhlbHBlci5pcyhcIi51aS1kcmFnZ2FibGUtZHJhZ2dpbmdcIikpIHtcblx0XHRcdHRoaXMuX21vdXNlVXAoe30pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jbGVhcigpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0X2dldEhhbmRsZTogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdHZhciBoYW5kbGUgPSAhdGhpcy5vcHRpb25zLmhhbmRsZSB8fCAhJCh0aGlzLm9wdGlvbnMuaGFuZGxlLCB0aGlzLmVsZW1lbnQpLmxlbmd0aCA/IHRydWUgOiBmYWxzZTtcblx0XHQkKHRoaXMub3B0aW9ucy5oYW5kbGUsIHRoaXMuZWxlbWVudClcblx0XHRcdC5maW5kKFwiKlwiKVxuXHRcdFx0LmFuZFNlbGYoKVxuXHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmKHRoaXMgPT0gZXZlbnQudGFyZ2V0KSBoYW5kbGUgPSB0cnVlO1xuXHRcdFx0fSk7XG5cblx0XHRyZXR1cm4gaGFuZGxlO1xuXG5cdH0sXG5cblx0X2NyZWF0ZUhlbHBlcjogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zO1xuXHRcdHZhciBoZWxwZXIgPSAkLmlzRnVuY3Rpb24oby5oZWxwZXIpID8gJChvLmhlbHBlci5hcHBseSh0aGlzLmVsZW1lbnRbMF0sIFtldmVudF0pKSA6IChvLmhlbHBlciA9PSAnY2xvbmUnID8gdGhpcy5lbGVtZW50LmNsb25lKCkucmVtb3ZlQXR0cignaWQnKSA6IHRoaXMuZWxlbWVudCk7XG5cblx0XHRpZighaGVscGVyLnBhcmVudHMoJ2JvZHknKS5sZW5ndGgpXG5cdFx0XHRoZWxwZXIuYXBwZW5kVG8oKG8uYXBwZW5kVG8gPT0gJ3BhcmVudCcgPyB0aGlzLmVsZW1lbnRbMF0ucGFyZW50Tm9kZSA6IG8uYXBwZW5kVG8pKTtcblxuXHRcdGlmKGhlbHBlclswXSAhPSB0aGlzLmVsZW1lbnRbMF0gJiYgISgvKGZpeGVkfGFic29sdXRlKS8pLnRlc3QoaGVscGVyLmNzcyhcInBvc2l0aW9uXCIpKSlcblx0XHRcdGhlbHBlci5jc3MoXCJwb3NpdGlvblwiLCBcImFic29sdXRlXCIpO1xuXG5cdFx0cmV0dXJuIGhlbHBlcjtcblxuXHR9LFxuXG5cdF9hZGp1c3RPZmZzZXRGcm9tSGVscGVyOiBmdW5jdGlvbihvYmopIHtcblx0XHRpZiAodHlwZW9mIG9iaiA9PSAnc3RyaW5nJykge1xuXHRcdFx0b2JqID0gb2JqLnNwbGl0KCcgJyk7XG5cdFx0fVxuXHRcdGlmICgkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0b2JqID0ge2xlZnQ6ICtvYmpbMF0sIHRvcDogK29ialsxXSB8fCAwfTtcblx0XHR9XG5cdFx0aWYgKCdsZWZ0JyBpbiBvYmopIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPSBvYmoubGVmdCArIHRoaXMubWFyZ2lucy5sZWZ0O1xuXHRcdH1cblx0XHRpZiAoJ3JpZ2h0JyBpbiBvYmopIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPSB0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC0gb2JqLnJpZ2h0ICsgdGhpcy5tYXJnaW5zLmxlZnQ7XG5cdFx0fVxuXHRcdGlmICgndG9wJyBpbiBvYmopIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA9IG9iai50b3AgKyB0aGlzLm1hcmdpbnMudG9wO1xuXHRcdH1cblx0XHRpZiAoJ2JvdHRvbScgaW4gb2JqKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5jbGljay50b3AgPSB0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAtIG9iai5ib3R0b20gKyB0aGlzLm1hcmdpbnMudG9wO1xuXHRcdH1cblx0fSxcblxuXHRfZ2V0UGFyZW50T2Zmc2V0OiBmdW5jdGlvbigpIHtcblxuXHRcdC8vR2V0IHRoZSBvZmZzZXRQYXJlbnQgYW5kIGNhY2hlIGl0cyBwb3NpdGlvblxuXHRcdHRoaXMub2Zmc2V0UGFyZW50ID0gdGhpcy5oZWxwZXIub2Zmc2V0UGFyZW50KCk7XG5cdFx0dmFyIHBvID0gdGhpcy5vZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG5cblx0XHQvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIHdoZXJlIHdlIG5lZWQgdG8gbW9kaWZ5IGEgb2Zmc2V0IGNhbGN1bGF0ZWQgb24gc3RhcnQsIHNpbmNlIHRoZSBmb2xsb3dpbmcgaGFwcGVuZWQ6XG5cdFx0Ly8gMS4gVGhlIHBvc2l0aW9uIG9mIHRoZSBoZWxwZXIgaXMgYWJzb2x1dGUsIHNvIGl0J3MgcG9zaXRpb24gaXMgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgbmV4dCBwb3NpdGlvbmVkIHBhcmVudFxuXHRcdC8vIDIuIFRoZSBhY3R1YWwgb2Zmc2V0IHBhcmVudCBpcyBhIGNoaWxkIG9mIHRoZSBzY3JvbGwgcGFyZW50LCBhbmQgdGhlIHNjcm9sbCBwYXJlbnQgaXNuJ3QgdGhlIGRvY3VtZW50LCB3aGljaCBtZWFucyB0aGF0XG5cdFx0Ly8gICAgdGhlIHNjcm9sbCBpcyBpbmNsdWRlZCBpbiB0aGUgaW5pdGlhbCBjYWxjdWxhdGlvbiBvZiB0aGUgb2Zmc2V0IG9mIHRoZSBwYXJlbnQsIGFuZCBuZXZlciByZWNhbGN1bGF0ZWQgdXBvbiBkcmFnXG5cdFx0aWYodGhpcy5jc3NQb3NpdGlvbiA9PSAnYWJzb2x1dGUnICYmIHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9IGRvY3VtZW50ICYmICQuY29udGFpbnModGhpcy5zY3JvbGxQYXJlbnRbMF0sIHRoaXMub2Zmc2V0UGFyZW50WzBdKSkge1xuXHRcdFx0cG8ubGVmdCArPSB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCk7XG5cdFx0XHRwby50b3AgKz0gdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCk7XG5cdFx0fVxuXG5cdFx0aWYoKHRoaXMub2Zmc2V0UGFyZW50WzBdID09IGRvY3VtZW50LmJvZHkpIC8vVGhpcyBuZWVkcyB0byBiZSBhY3R1YWxseSBkb25lIGZvciBhbGwgYnJvd3NlcnMsIHNpbmNlIHBhZ2VYL3BhZ2VZIGluY2x1ZGVzIHRoaXMgaW5mb3JtYXRpb25cblx0XHR8fCAodGhpcy5vZmZzZXRQYXJlbnRbMF0udGFnTmFtZSAmJiB0aGlzLm9mZnNldFBhcmVudFswXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ2h0bWwnICYmICQudWkuaWUpKSAvL1VnbHkgSUUgZml4XG5cdFx0XHRwbyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBwby50b3AgKyAocGFyc2VJbnQodGhpcy5vZmZzZXRQYXJlbnQuY3NzKFwiYm9yZGVyVG9wV2lkdGhcIiksMTApIHx8IDApLFxuXHRcdFx0bGVmdDogcG8ubGVmdCArIChwYXJzZUludCh0aGlzLm9mZnNldFBhcmVudC5jc3MoXCJib3JkZXJMZWZ0V2lkdGhcIiksMTApIHx8IDApXG5cdFx0fTtcblxuXHR9LFxuXG5cdF9nZXRSZWxhdGl2ZU9mZnNldDogZnVuY3Rpb24oKSB7XG5cblx0XHRpZih0aGlzLmNzc1Bvc2l0aW9uID09IFwicmVsYXRpdmVcIikge1xuXHRcdFx0dmFyIHAgPSB0aGlzLmVsZW1lbnQucG9zaXRpb24oKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHRvcDogcC50b3AgLSAocGFyc2VJbnQodGhpcy5oZWxwZXIuY3NzKFwidG9wXCIpLDEwKSB8fCAwKSArIHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpLFxuXHRcdFx0XHRsZWZ0OiBwLmxlZnQgLSAocGFyc2VJbnQodGhpcy5oZWxwZXIuY3NzKFwibGVmdFwiKSwxMCkgfHwgMCkgKyB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KClcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHR9LFxuXG5cdF9jYWNoZU1hcmdpbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMubWFyZ2lucyA9IHtcblx0XHRcdGxlZnQ6IChwYXJzZUludCh0aGlzLmVsZW1lbnQuY3NzKFwibWFyZ2luTGVmdFwiKSwxMCkgfHwgMCksXG5cdFx0XHR0b3A6IChwYXJzZUludCh0aGlzLmVsZW1lbnQuY3NzKFwibWFyZ2luVG9wXCIpLDEwKSB8fCAwKSxcblx0XHRcdHJpZ2h0OiAocGFyc2VJbnQodGhpcy5lbGVtZW50LmNzcyhcIm1hcmdpblJpZ2h0XCIpLDEwKSB8fCAwKSxcblx0XHRcdGJvdHRvbTogKHBhcnNlSW50KHRoaXMuZWxlbWVudC5jc3MoXCJtYXJnaW5Cb3R0b21cIiksMTApIHx8IDApXG5cdFx0fTtcblx0fSxcblxuXHRfY2FjaGVIZWxwZXJQcm9wb3J0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oZWxwZXJQcm9wb3J0aW9ucyA9IHtcblx0XHRcdHdpZHRoOiB0aGlzLmhlbHBlci5vdXRlcldpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IHRoaXMuaGVscGVyLm91dGVySGVpZ2h0KClcblx0XHR9O1xuXHR9LFxuXG5cdF9zZXRDb250YWlubWVudDogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucztcblx0XHRpZihvLmNvbnRhaW5tZW50ID09ICdwYXJlbnQnKSBvLmNvbnRhaW5tZW50ID0gdGhpcy5oZWxwZXJbMF0ucGFyZW50Tm9kZTtcblx0XHRpZihvLmNvbnRhaW5tZW50ID09ICdkb2N1bWVudCcgfHwgby5jb250YWlubWVudCA9PSAnd2luZG93JykgdGhpcy5jb250YWlubWVudCA9IFtcblx0XHRcdG8uY29udGFpbm1lbnQgPT0gJ2RvY3VtZW50JyA/IDAgOiAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpIC0gdGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdCAtIHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0LFxuXHRcdFx0by5jb250YWlubWVudCA9PSAnZG9jdW1lbnQnID8gMCA6ICQod2luZG93KS5zY3JvbGxUb3AoKSAtIHRoaXMub2Zmc2V0LnJlbGF0aXZlLnRvcCAtIHRoaXMub2Zmc2V0LnBhcmVudC50b3AsXG5cdFx0XHQoby5jb250YWlubWVudCA9PSAnZG9jdW1lbnQnID8gMCA6ICQod2luZG93KS5zY3JvbGxMZWZ0KCkpICsgJChvLmNvbnRhaW5tZW50ID09ICdkb2N1bWVudCcgPyBkb2N1bWVudCA6IHdpbmRvdykud2lkdGgoKSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLSB0aGlzLm1hcmdpbnMubGVmdCxcblx0XHRcdChvLmNvbnRhaW5tZW50ID09ICdkb2N1bWVudCcgPyAwIDogJCh3aW5kb3cpLnNjcm9sbFRvcCgpKSArICgkKG8uY29udGFpbm1lbnQgPT0gJ2RvY3VtZW50JyA/IGRvY3VtZW50IDogd2luZG93KS5oZWlnaHQoKSB8fCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUuc2Nyb2xsSGVpZ2h0KSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC0gdGhpcy5tYXJnaW5zLnRvcFxuXHRcdF07XG5cblx0XHRpZighKC9eKGRvY3VtZW50fHdpbmRvd3xwYXJlbnQpJC8pLnRlc3Qoby5jb250YWlubWVudCkgJiYgby5jb250YWlubWVudC5jb25zdHJ1Y3RvciAhPSBBcnJheSkge1xuXHRcdFx0dmFyIGMgPSAkKG8uY29udGFpbm1lbnQpO1xuXHRcdFx0dmFyIGNlID0gY1swXTsgaWYoIWNlKSByZXR1cm47XG5cdFx0XHR2YXIgY28gPSBjLm9mZnNldCgpO1xuXHRcdFx0dmFyIG92ZXIgPSAoJChjZSkuY3NzKFwib3ZlcmZsb3dcIikgIT0gJ2hpZGRlbicpO1xuXG5cdFx0XHR0aGlzLmNvbnRhaW5tZW50ID0gW1xuXHRcdFx0XHQocGFyc2VJbnQoJChjZSkuY3NzKFwiYm9yZGVyTGVmdFdpZHRoXCIpLDEwKSB8fCAwKSArIChwYXJzZUludCgkKGNlKS5jc3MoXCJwYWRkaW5nTGVmdFwiKSwxMCkgfHwgMCksXG5cdFx0XHRcdChwYXJzZUludCgkKGNlKS5jc3MoXCJib3JkZXJUb3BXaWR0aFwiKSwxMCkgfHwgMCkgKyAocGFyc2VJbnQoJChjZSkuY3NzKFwicGFkZGluZ1RvcFwiKSwxMCkgfHwgMCksXG5cdFx0XHRcdChvdmVyID8gTWF0aC5tYXgoY2Uuc2Nyb2xsV2lkdGgsY2Uub2Zmc2V0V2lkdGgpIDogY2Uub2Zmc2V0V2lkdGgpIC0gKHBhcnNlSW50KCQoY2UpLmNzcyhcImJvcmRlckxlZnRXaWR0aFwiKSwxMCkgfHwgMCkgLSAocGFyc2VJbnQoJChjZSkuY3NzKFwicGFkZGluZ1JpZ2h0XCIpLDEwKSB8fCAwKSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLSB0aGlzLm1hcmdpbnMubGVmdCAtIHRoaXMubWFyZ2lucy5yaWdodCxcblx0XHRcdFx0KG92ZXIgPyBNYXRoLm1heChjZS5zY3JvbGxIZWlnaHQsY2Uub2Zmc2V0SGVpZ2h0KSA6IGNlLm9mZnNldEhlaWdodCkgLSAocGFyc2VJbnQoJChjZSkuY3NzKFwiYm9yZGVyVG9wV2lkdGhcIiksMTApIHx8IDApIC0gKHBhcnNlSW50KCQoY2UpLmNzcyhcInBhZGRpbmdCb3R0b21cIiksMTApIHx8IDApIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wICAtIHRoaXMubWFyZ2lucy5ib3R0b21cblx0XHRcdF07XG5cdFx0XHR0aGlzLnJlbGF0aXZlX2NvbnRhaW5lciA9IGM7XG5cblx0XHR9IGVsc2UgaWYoby5jb250YWlubWVudC5jb25zdHJ1Y3RvciA9PSBBcnJheSkge1xuXHRcdFx0dGhpcy5jb250YWlubWVudCA9IG8uY29udGFpbm1lbnQ7XG5cdFx0fVxuXG5cdH0sXG5cblx0X2NvbnZlcnRQb3NpdGlvblRvOiBmdW5jdGlvbihkLCBwb3MpIHtcblxuXHRcdGlmKCFwb3MpIHBvcyA9IHRoaXMucG9zaXRpb247XG5cdFx0dmFyIG1vZCA9IGQgPT0gXCJhYnNvbHV0ZVwiID8gMSA6IC0xO1xuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zLCBzY3JvbGwgPSB0aGlzLmNzc1Bvc2l0aW9uID09ICdhYnNvbHV0ZScgJiYgISh0aGlzLnNjcm9sbFBhcmVudFswXSAhPSBkb2N1bWVudCAmJiAkLmNvbnRhaW5zKHRoaXMuc2Nyb2xsUGFyZW50WzBdLCB0aGlzLm9mZnNldFBhcmVudFswXSkpID8gdGhpcy5vZmZzZXRQYXJlbnQgOiB0aGlzLnNjcm9sbFBhcmVudCwgc2Nyb2xsSXNSb290Tm9kZSA9ICgvKGh0bWx8Ym9keSkvaSkudGVzdChzY3JvbGxbMF0udGFnTmFtZSk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiAoXG5cdFx0XHRcdHBvcy50b3BcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdCsgdGhpcy5vZmZzZXQucmVsYXRpdmUudG9wICogbW9kXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcblx0XHRcdFx0KyB0aGlzLm9mZnNldC5wYXJlbnQudG9wICogbW9kXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXG5cdFx0XHRcdC0gKCAoIHRoaXMuY3NzUG9zaXRpb24gPT0gJ2ZpeGVkJyA/IC10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKSA6ICggc2Nyb2xsSXNSb290Tm9kZSA/IDAgOiBzY3JvbGwuc2Nyb2xsVG9wKCkgKSApICogbW9kKVxuXHRcdFx0KSxcblx0XHRcdGxlZnQ6IChcblx0XHRcdFx0cG9zLmxlZnRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxuXHRcdFx0XHQrIHRoaXMub2Zmc2V0LnJlbGF0aXZlLmxlZnQgKiBtb2RcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHQrIHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0ICogbW9kXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXG5cdFx0XHRcdC0gKCAoIHRoaXMuY3NzUG9zaXRpb24gPT0gJ2ZpeGVkJyA/IC10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCkgOiBzY3JvbGxJc1Jvb3ROb2RlID8gMCA6IHNjcm9sbC5zY3JvbGxMZWZ0KCkgKSAqIG1vZClcblx0XHRcdClcblx0XHR9O1xuXG5cdH0sXG5cblx0X2dlbmVyYXRlUG9zaXRpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucywgc2Nyb2xsID0gdGhpcy5jc3NQb3NpdGlvbiA9PSAnYWJzb2x1dGUnICYmICEodGhpcy5zY3JvbGxQYXJlbnRbMF0gIT0gZG9jdW1lbnQgJiYgJC5jb250YWlucyh0aGlzLnNjcm9sbFBhcmVudFswXSwgdGhpcy5vZmZzZXRQYXJlbnRbMF0pKSA/IHRoaXMub2Zmc2V0UGFyZW50IDogdGhpcy5zY3JvbGxQYXJlbnQsIHNjcm9sbElzUm9vdE5vZGUgPSAoLyhodG1sfGJvZHkpL2kpLnRlc3Qoc2Nyb2xsWzBdLnRhZ05hbWUpO1xuXHRcdHZhciBwYWdlWCA9IGV2ZW50LnBhZ2VYO1xuXHRcdHZhciBwYWdlWSA9IGV2ZW50LnBhZ2VZO1xuXG5cdFx0Lypcblx0XHQgKiAtIFBvc2l0aW9uIGNvbnN0cmFpbmluZyAtXG5cdFx0ICogQ29uc3RyYWluIHRoZSBwb3NpdGlvbiB0byBhIG1peCBvZiBncmlkLCBjb250YWlubWVudC5cblx0XHQgKi9cblxuXHRcdGlmKHRoaXMub3JpZ2luYWxQb3NpdGlvbikgeyAvL0lmIHdlIGFyZSBub3QgZHJhZ2dpbmcgeWV0LCB3ZSB3b24ndCBjaGVjayBmb3Igb3B0aW9uc1xuXHRcdFx0dmFyIGNvbnRhaW5tZW50O1xuXHRcdFx0aWYodGhpcy5jb250YWlubWVudCkge1xuXHRcdFx0aWYgKHRoaXMucmVsYXRpdmVfY29udGFpbmVyKXtcblx0XHRcdFx0dmFyIGNvID0gdGhpcy5yZWxhdGl2ZV9jb250YWluZXIub2Zmc2V0KCk7XG5cdFx0XHRcdGNvbnRhaW5tZW50ID0gWyB0aGlzLmNvbnRhaW5tZW50WzBdICsgY28ubGVmdCxcblx0XHRcdFx0XHR0aGlzLmNvbnRhaW5tZW50WzFdICsgY28udG9wLFxuXHRcdFx0XHRcdHRoaXMuY29udGFpbm1lbnRbMl0gKyBjby5sZWZ0LFxuXHRcdFx0XHRcdHRoaXMuY29udGFpbm1lbnRbM10gKyBjby50b3AgXTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRjb250YWlubWVudCA9IHRoaXMuY29udGFpbm1lbnQ7XG5cdFx0XHR9XG5cblx0XHRcdFx0aWYoZXZlbnQucGFnZVggLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0IDwgY29udGFpbm1lbnRbMF0pIHBhZ2VYID0gY29udGFpbm1lbnRbMF0gKyB0aGlzLm9mZnNldC5jbGljay5sZWZ0O1xuXHRcdFx0XHRpZihldmVudC5wYWdlWSAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA8IGNvbnRhaW5tZW50WzFdKSBwYWdlWSA9IGNvbnRhaW5tZW50WzFdICsgdGhpcy5vZmZzZXQuY2xpY2sudG9wO1xuXHRcdFx0XHRpZihldmVudC5wYWdlWCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPiBjb250YWlubWVudFsyXSkgcGFnZVggPSBjb250YWlubWVudFsyXSArIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQ7XG5cdFx0XHRcdGlmKGV2ZW50LnBhZ2VZIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wID4gY29udGFpbm1lbnRbM10pIHBhZ2VZID0gY29udGFpbm1lbnRbM10gKyB0aGlzLm9mZnNldC5jbGljay50b3A7XG5cdFx0XHR9XG5cblx0XHRcdGlmKG8uZ3JpZCkge1xuXHRcdFx0XHQvL0NoZWNrIGZvciBncmlkIGVsZW1lbnRzIHNldCB0byAwIHRvIHByZXZlbnQgZGl2aWRlIGJ5IDAgZXJyb3IgY2F1c2luZyBpbnZhbGlkIGFyZ3VtZW50IGVycm9ycyBpbiBJRSAoc2VlIHRpY2tldCAjNjk1MClcblx0XHRcdFx0dmFyIHRvcCA9IG8uZ3JpZFsxXSA/IHRoaXMub3JpZ2luYWxQYWdlWSArIE1hdGgucm91bmQoKHBhZ2VZIC0gdGhpcy5vcmlnaW5hbFBhZ2VZKSAvIG8uZ3JpZFsxXSkgKiBvLmdyaWRbMV0gOiB0aGlzLm9yaWdpbmFsUGFnZVk7XG5cdFx0XHRcdHBhZ2VZID0gY29udGFpbm1lbnQgPyAoISh0b3AgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPCBjb250YWlubWVudFsxXSB8fCB0b3AgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPiBjb250YWlubWVudFszXSkgPyB0b3AgOiAoISh0b3AgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPCBjb250YWlubWVudFsxXSkgPyB0b3AgLSBvLmdyaWRbMV0gOiB0b3AgKyBvLmdyaWRbMV0pKSA6IHRvcDtcblxuXHRcdFx0XHR2YXIgbGVmdCA9IG8uZ3JpZFswXSA/IHRoaXMub3JpZ2luYWxQYWdlWCArIE1hdGgucm91bmQoKHBhZ2VYIC0gdGhpcy5vcmlnaW5hbFBhZ2VYKSAvIG8uZ3JpZFswXSkgKiBvLmdyaWRbMF0gOiB0aGlzLm9yaWdpbmFsUGFnZVg7XG5cdFx0XHRcdHBhZ2VYID0gY29udGFpbm1lbnQgPyAoIShsZWZ0IC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA8IGNvbnRhaW5tZW50WzBdIHx8IGxlZnQgLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0ID4gY29udGFpbm1lbnRbMl0pID8gbGVmdCA6ICghKGxlZnQgLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0IDwgY29udGFpbm1lbnRbMF0pID8gbGVmdCAtIG8uZ3JpZFswXSA6IGxlZnQgKyBvLmdyaWRbMF0pKSA6IGxlZnQ7XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiAoXG5cdFx0XHRcdHBhZ2VZXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cblx0XHRcdFx0LSB0aGlzLm9mZnNldC5jbGljay50b3BcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENsaWNrIG9mZnNldCAocmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQpXG5cdFx0XHRcdC0gdGhpcy5vZmZzZXQucmVsYXRpdmUudG9wXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBub2RlczogUmVsYXRpdmUgb2Zmc2V0IGZyb20gZWxlbWVudCB0byBvZmZzZXQgcGFyZW50XG5cdFx0XHRcdC0gdGhpcy5vZmZzZXQucGFyZW50LnRvcFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXG5cdFx0XHRcdCsgKCAoIHRoaXMuY3NzUG9zaXRpb24gPT0gJ2ZpeGVkJyA/IC10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKSA6ICggc2Nyb2xsSXNSb290Tm9kZSA/IDAgOiBzY3JvbGwuc2Nyb2xsVG9wKCkgKSApKVxuXHRcdFx0KSxcblx0XHRcdGxlZnQ6IChcblx0XHRcdFx0cGFnZVhcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxuXHRcdFx0XHQtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDbGljayBvZmZzZXQgKHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50KVxuXHRcdFx0XHQtIHRoaXMub2Zmc2V0LnJlbGF0aXZlLmxlZnRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcblx0XHRcdFx0LSB0aGlzLm9mZnNldC5wYXJlbnQubGVmdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXG5cdFx0XHRcdCsgKCAoIHRoaXMuY3NzUG9zaXRpb24gPT0gJ2ZpeGVkJyA/IC10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCkgOiBzY3JvbGxJc1Jvb3ROb2RlID8gMCA6IHNjcm9sbC5zY3JvbGxMZWZ0KCkgKSlcblx0XHRcdClcblx0XHR9O1xuXG5cdH0sXG5cblx0X2NsZWFyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmhlbHBlci5yZW1vdmVDbGFzcyhcInVpLWRyYWdnYWJsZS1kcmFnZ2luZ1wiKTtcblx0XHRpZih0aGlzLmhlbHBlclswXSAhPSB0aGlzLmVsZW1lbnRbMF0gJiYgIXRoaXMuY2FuY2VsSGVscGVyUmVtb3ZhbCkgdGhpcy5oZWxwZXIucmVtb3ZlKCk7XG5cdFx0Ly9pZigkLnVpLmRkbWFuYWdlcikgJC51aS5kZG1hbmFnZXIuY3VycmVudCA9IG51bGw7XG5cdFx0dGhpcy5oZWxwZXIgPSBudWxsO1xuXHRcdHRoaXMuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IGZhbHNlO1xuXHR9LFxuXG5cdC8vIEZyb20gbm93IG9uIGJ1bGsgc3R1ZmYgLSBtYWlubHkgaGVscGVyc1xuXG5cdF90cmlnZ2VyOiBmdW5jdGlvbih0eXBlLCBldmVudCwgdWkpIHtcblx0XHR1aSA9IHVpIHx8IHRoaXMuX3VpSGFzaCgpO1xuXHRcdCQudWkucGx1Z2luLmNhbGwodGhpcywgdHlwZSwgW2V2ZW50LCB1aV0pO1xuXHRcdGlmKHR5cGUgPT0gXCJkcmFnXCIpIHRoaXMucG9zaXRpb25BYnMgPSB0aGlzLl9jb252ZXJ0UG9zaXRpb25UbyhcImFic29sdXRlXCIpOyAvL1RoZSBhYnNvbHV0ZSBwb3NpdGlvbiBoYXMgdG8gYmUgcmVjYWxjdWxhdGVkIGFmdGVyIHBsdWdpbnNcblx0XHRyZXR1cm4gJC5XaWRnZXQucHJvdG90eXBlLl90cmlnZ2VyLmNhbGwodGhpcywgdHlwZSwgZXZlbnQsIHVpKTtcblx0fSxcblxuXHRwbHVnaW5zOiB7fSxcblxuXHRfdWlIYXNoOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRoZWxwZXI6IHRoaXMuaGVscGVyLFxuXHRcdFx0cG9zaXRpb246IHRoaXMucG9zaXRpb24sXG5cdFx0XHRvcmlnaW5hbFBvc2l0aW9uOiB0aGlzLm9yaWdpbmFsUG9zaXRpb24sXG5cdFx0XHRvZmZzZXQ6IHRoaXMucG9zaXRpb25BYnNcblx0XHR9O1xuXHR9XG5cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIiwgXCJjb25uZWN0VG9Tb3J0YWJsZVwiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbihldmVudCwgdWkpIHtcblxuXHRcdHZhciBpbnN0ID0gJCh0aGlzKS5kYXRhKFwiZHJhZ2dhYmxlXCIpLCBvID0gaW5zdC5vcHRpb25zLFxuXHRcdFx0dWlTb3J0YWJsZSA9ICQuZXh0ZW5kKHt9LCB1aSwgeyBpdGVtOiBpbnN0LmVsZW1lbnQgfSk7XG5cdFx0aW5zdC5zb3J0YWJsZXMgPSBbXTtcblx0XHQkKG8uY29ubmVjdFRvU29ydGFibGUpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc29ydGFibGUgPSAkLmRhdGEodGhpcywgJ3NvcnRhYmxlJyk7XG5cdFx0XHRpZiAoc29ydGFibGUgJiYgIXNvcnRhYmxlLm9wdGlvbnMuZGlzYWJsZWQpIHtcblx0XHRcdFx0aW5zdC5zb3J0YWJsZXMucHVzaCh7XG5cdFx0XHRcdFx0aW5zdGFuY2U6IHNvcnRhYmxlLFxuXHRcdFx0XHRcdHNob3VsZFJldmVydDogc29ydGFibGUub3B0aW9ucy5yZXZlcnRcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvcnRhYmxlLnJlZnJlc2hQb3NpdGlvbnMoKTtcdC8vIENhbGwgdGhlIHNvcnRhYmxlJ3MgcmVmcmVzaFBvc2l0aW9ucyBhdCBkcmFnIHN0YXJ0IHRvIHJlZnJlc2ggdGhlIGNvbnRhaW5lckNhY2hlIHNpbmNlIHRoZSBzb3J0YWJsZSBjb250YWluZXIgY2FjaGUgaXMgdXNlZCBpbiBkcmFnIGFuZCBuZWVkcyB0byBiZSB1cCB0byBkYXRlICh0aGlzIHdpbGwgZW5zdXJlIGl0J3MgaW5pdGlhbGlzZWQgYXMgd2VsbCBhcyBiZWluZyBrZXB0IGluIHN0ZXAgd2l0aCBhbnkgY2hhbmdlcyB0aGF0IG1pZ2h0IGhhdmUgaGFwcGVuZWQgb24gdGhlIHBhZ2UpLlxuXHRcdFx0XHRzb3J0YWJsZS5fdHJpZ2dlcihcImFjdGl2YXRlXCIsIGV2ZW50LCB1aVNvcnRhYmxlKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbihldmVudCwgdWkpIHtcblxuXHRcdC8vSWYgd2UgYXJlIHN0aWxsIG92ZXIgdGhlIHNvcnRhYmxlLCB3ZSBmYWtlIHRoZSBzdG9wIGV2ZW50IG9mIHRoZSBzb3J0YWJsZSwgYnV0IGFsc28gcmVtb3ZlIGhlbHBlclxuXHRcdHZhciBpbnN0ID0gJCh0aGlzKS5kYXRhKFwiZHJhZ2dhYmxlXCIpLFxuXHRcdFx0dWlTb3J0YWJsZSA9ICQuZXh0ZW5kKHt9LCB1aSwgeyBpdGVtOiBpbnN0LmVsZW1lbnQgfSk7XG5cblx0XHQkLmVhY2goaW5zdC5zb3J0YWJsZXMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYodGhpcy5pbnN0YW5jZS5pc092ZXIpIHtcblxuXHRcdFx0XHR0aGlzLmluc3RhbmNlLmlzT3ZlciA9IDA7XG5cblx0XHRcdFx0aW5zdC5jYW5jZWxIZWxwZXJSZW1vdmFsID0gdHJ1ZTsgLy9Eb24ndCByZW1vdmUgdGhlIGhlbHBlciBpbiB0aGUgZHJhZ2dhYmxlIGluc3RhbmNlXG5cdFx0XHRcdHRoaXMuaW5zdGFuY2UuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IGZhbHNlOyAvL1JlbW92ZSBpdCBpbiB0aGUgc29ydGFibGUgaW5zdGFuY2UgKHNvIHNvcnRhYmxlIHBsdWdpbnMgbGlrZSByZXZlcnQgc3RpbGwgd29yaylcblxuXHRcdFx0XHQvL1RoZSBzb3J0YWJsZSByZXZlcnQgaXMgc3VwcG9ydGVkLCBhbmQgd2UgaGF2ZSB0byBzZXQgYSB0ZW1wb3JhcnkgZHJvcHBlZCB2YXJpYWJsZSBvbiB0aGUgZHJhZ2dhYmxlIHRvIHN1cHBvcnQgcmV2ZXJ0OiAndmFsaWQvaW52YWxpZCdcblx0XHRcdFx0aWYodGhpcy5zaG91bGRSZXZlcnQpIHRoaXMuaW5zdGFuY2Uub3B0aW9ucy5yZXZlcnQgPSB0cnVlO1xuXG5cdFx0XHRcdC8vVHJpZ2dlciB0aGUgc3RvcCBvZiB0aGUgc29ydGFibGVcblx0XHRcdFx0dGhpcy5pbnN0YW5jZS5fbW91c2VTdG9wKGV2ZW50KTtcblxuXHRcdFx0XHR0aGlzLmluc3RhbmNlLm9wdGlvbnMuaGVscGVyID0gdGhpcy5pbnN0YW5jZS5vcHRpb25zLl9oZWxwZXI7XG5cblx0XHRcdFx0Ly9JZiB0aGUgaGVscGVyIGhhcyBiZWVuIHRoZSBvcmlnaW5hbCBpdGVtLCByZXN0b3JlIHByb3BlcnRpZXMgaW4gdGhlIHNvcnRhYmxlXG5cdFx0XHRcdGlmKGluc3Qub3B0aW9ucy5oZWxwZXIgPT0gJ29yaWdpbmFsJylcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLmN1cnJlbnRJdGVtLmNzcyh7IHRvcDogJ2F1dG8nLCBsZWZ0OiAnYXV0bycgfSk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuaW5zdGFuY2UuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IGZhbHNlOyAvL1JlbW92ZSB0aGUgaGVscGVyIGluIHRoZSBzb3J0YWJsZSBpbnN0YW5jZVxuXHRcdFx0XHR0aGlzLmluc3RhbmNlLl90cmlnZ2VyKFwiZGVhY3RpdmF0ZVwiLCBldmVudCwgdWlTb3J0YWJsZSk7XG5cdFx0XHR9XG5cblx0XHR9KTtcblxuXHR9LFxuXHRkcmFnOiBmdW5jdGlvbihldmVudCwgdWkpIHtcblxuXHRcdHZhciBpbnN0ID0gJCh0aGlzKS5kYXRhKFwiZHJhZ2dhYmxlXCIpLCB0aGF0ID0gdGhpcztcblxuXHRcdHZhciBjaGVja1BvcyA9IGZ1bmN0aW9uKG8pIHtcblx0XHRcdHZhciBkeUNsaWNrID0gdGhpcy5vZmZzZXQuY2xpY2sudG9wLCBkeENsaWNrID0gdGhpcy5vZmZzZXQuY2xpY2subGVmdDtcblx0XHRcdHZhciBoZWxwZXJUb3AgPSB0aGlzLnBvc2l0aW9uQWJzLnRvcCwgaGVscGVyTGVmdCA9IHRoaXMucG9zaXRpb25BYnMubGVmdDtcblx0XHRcdHZhciBpdGVtSGVpZ2h0ID0gby5oZWlnaHQsIGl0ZW1XaWR0aCA9IG8ud2lkdGg7XG5cdFx0XHR2YXIgaXRlbVRvcCA9IG8udG9wLCBpdGVtTGVmdCA9IG8ubGVmdDtcblxuXHRcdFx0cmV0dXJuICQudWkuaXNPdmVyKGhlbHBlclRvcCArIGR5Q2xpY2ssIGhlbHBlckxlZnQgKyBkeENsaWNrLCBpdGVtVG9wLCBpdGVtTGVmdCwgaXRlbUhlaWdodCwgaXRlbVdpZHRoKTtcblx0XHR9O1xuXG5cdFx0JC5lYWNoKGluc3Quc29ydGFibGVzLCBmdW5jdGlvbihpKSB7XG5cblx0XHRcdHZhciBpbm5lcm1vc3RJbnRlcnNlY3RpbmcgPSBmYWxzZTtcblx0XHRcdHZhciB0aGlzU29ydGFibGUgPSB0aGlzO1xuXHRcdFx0Ly9Db3B5IG92ZXIgc29tZSB2YXJpYWJsZXMgdG8gYWxsb3cgY2FsbGluZyB0aGUgc29ydGFibGUncyBuYXRpdmUgX2ludGVyc2VjdHNXaXRoXG5cdFx0XHR0aGlzLmluc3RhbmNlLnBvc2l0aW9uQWJzID0gaW5zdC5wb3NpdGlvbkFicztcblx0XHRcdHRoaXMuaW5zdGFuY2UuaGVscGVyUHJvcG9ydGlvbnMgPSBpbnN0LmhlbHBlclByb3BvcnRpb25zO1xuXHRcdFx0dGhpcy5pbnN0YW5jZS5vZmZzZXQuY2xpY2sgPSBpbnN0Lm9mZnNldC5jbGljaztcblxuXHRcdFx0aWYodGhpcy5pbnN0YW5jZS5faW50ZXJzZWN0c1dpdGgodGhpcy5pbnN0YW5jZS5jb250YWluZXJDYWNoZSkpIHtcblx0XHRcdFx0aW5uZXJtb3N0SW50ZXJzZWN0aW5nID0gdHJ1ZTtcblx0XHRcdFx0JC5lYWNoKGluc3Quc29ydGFibGVzLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5wb3NpdGlvbkFicyA9IGluc3QucG9zaXRpb25BYnM7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5oZWxwZXJQcm9wb3J0aW9ucyA9IGluc3QuaGVscGVyUHJvcG9ydGlvbnM7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vZmZzZXQuY2xpY2sgPSBpbnN0Lm9mZnNldC5jbGljaztcblx0XHRcdFx0XHRpZiAgKHRoaXMgIT0gdGhpc1NvcnRhYmxlXG5cdFx0XHRcdFx0XHQmJiB0aGlzLmluc3RhbmNlLl9pbnRlcnNlY3RzV2l0aCh0aGlzLmluc3RhbmNlLmNvbnRhaW5lckNhY2hlKVxuXHRcdFx0XHRcdFx0JiYgJC51aS5jb250YWlucyh0aGlzU29ydGFibGUuaW5zdGFuY2UuZWxlbWVudFswXSwgdGhpcy5pbnN0YW5jZS5lbGVtZW50WzBdKSlcblx0XHRcdFx0XHRcdGlubmVybW9zdEludGVyc2VjdGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGlubmVybW9zdEludGVyc2VjdGluZztcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblxuXHRcdFx0aWYoaW5uZXJtb3N0SW50ZXJzZWN0aW5nKSB7XG5cdFx0XHRcdC8vSWYgaXQgaW50ZXJzZWN0cywgd2UgdXNlIGEgbGl0dGxlIGlzT3ZlciB2YXJpYWJsZSBhbmQgc2V0IGl0IG9uY2UsIHNvIG91ciBtb3ZlLWluIHN0dWZmIGdldHMgZmlyZWQgb25seSBvbmNlXG5cdFx0XHRcdGlmKCF0aGlzLmluc3RhbmNlLmlzT3Zlcikge1xuXG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5pc092ZXIgPSAxO1xuXHRcdFx0XHRcdC8vTm93IHdlIGZha2UgdGhlIHN0YXJ0IG9mIGRyYWdnaW5nIGZvciB0aGUgc29ydGFibGUgaW5zdGFuY2UsXG5cdFx0XHRcdFx0Ly9ieSBjbG9uaW5nIHRoZSBsaXN0IGdyb3VwIGl0ZW0sIGFwcGVuZGluZyBpdCB0byB0aGUgc29ydGFibGUgYW5kIHVzaW5nIGl0IGFzIGluc3QuY3VycmVudEl0ZW1cblx0XHRcdFx0XHQvL1dlIGNhbiB0aGVuIGZpcmUgdGhlIHN0YXJ0IGV2ZW50IG9mIHRoZSBzb3J0YWJsZSB3aXRoIG91ciBwYXNzZWQgYnJvd3NlciBldmVudCwgYW5kIG91ciBvd24gaGVscGVyIChzbyBpdCBkb2Vzbid0IGNyZWF0ZSBhIG5ldyBvbmUpXG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5jdXJyZW50SXRlbSA9ICQodGhhdCkuY2xvbmUoKS5yZW1vdmVBdHRyKCdpZCcpLmFwcGVuZFRvKHRoaXMuaW5zdGFuY2UuZWxlbWVudCkuZGF0YShcInNvcnRhYmxlLWl0ZW1cIiwgdHJ1ZSk7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vcHRpb25zLl9oZWxwZXIgPSB0aGlzLmluc3RhbmNlLm9wdGlvbnMuaGVscGVyOyAvL1N0b3JlIGhlbHBlciBvcHRpb24gdG8gbGF0ZXIgcmVzdG9yZSBpdFxuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2Uub3B0aW9ucy5oZWxwZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHVpLmhlbHBlclswXTsgfTtcblxuXHRcdFx0XHRcdGV2ZW50LnRhcmdldCA9IHRoaXMuaW5zdGFuY2UuY3VycmVudEl0ZW1bMF07XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5fbW91c2VDYXB0dXJlKGV2ZW50LCB0cnVlKTtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLl9tb3VzZVN0YXJ0KGV2ZW50LCB0cnVlLCB0cnVlKTtcblxuXHRcdFx0XHRcdC8vQmVjYXVzZSB0aGUgYnJvd3NlciBldmVudCBpcyB3YXkgb2ZmIHRoZSBuZXcgYXBwZW5kZWQgcG9ydGxldCwgd2UgbW9kaWZ5IGEgY291cGxlIG9mIHZhcmlhYmxlcyB0byByZWZsZWN0IHRoZSBjaGFuZ2VzXG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vZmZzZXQuY2xpY2sudG9wID0gaW5zdC5vZmZzZXQuY2xpY2sudG9wO1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2Uub2Zmc2V0LmNsaWNrLmxlZnQgPSBpbnN0Lm9mZnNldC5jbGljay5sZWZ0O1xuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2Uub2Zmc2V0LnBhcmVudC5sZWZ0IC09IGluc3Qub2Zmc2V0LnBhcmVudC5sZWZ0IC0gdGhpcy5pbnN0YW5jZS5vZmZzZXQucGFyZW50LmxlZnQ7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vZmZzZXQucGFyZW50LnRvcCAtPSBpbnN0Lm9mZnNldC5wYXJlbnQudG9wIC0gdGhpcy5pbnN0YW5jZS5vZmZzZXQucGFyZW50LnRvcDtcblxuXHRcdFx0XHRcdGluc3QuX3RyaWdnZXIoXCJ0b1NvcnRhYmxlXCIsIGV2ZW50KTtcblx0XHRcdFx0XHRpbnN0LmRyb3BwZWQgPSB0aGlzLmluc3RhbmNlLmVsZW1lbnQ7IC8vZHJhZ2dhYmxlIHJldmVydCBuZWVkcyB0aGF0XG5cdFx0XHRcdFx0Ly9oYWNrIHNvIHJlY2VpdmUvdXBkYXRlIGNhbGxiYWNrcyB3b3JrIChtb3N0bHkpXG5cdFx0XHRcdFx0aW5zdC5jdXJyZW50SXRlbSA9IGluc3QuZWxlbWVudDtcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLmZyb21PdXRzaWRlID0gaW5zdDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9Qcm92aWRlZCB3ZSBkaWQgYWxsIHRoZSBwcmV2aW91cyBzdGVwcywgd2UgY2FuIGZpcmUgdGhlIGRyYWcgZXZlbnQgb2YgdGhlIHNvcnRhYmxlIG9uIGV2ZXJ5IGRyYWdnYWJsZSBkcmFnLCB3aGVuIGl0IGludGVyc2VjdHMgd2l0aCB0aGUgc29ydGFibGVcblx0XHRcdFx0aWYodGhpcy5pbnN0YW5jZS5jdXJyZW50SXRlbSkgdGhpcy5pbnN0YW5jZS5fbW91c2VEcmFnKGV2ZW50KTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvL0lmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHdpdGggdGhlIHNvcnRhYmxlLCBhbmQgaXQgaW50ZXJzZWN0ZWQgYmVmb3JlLFxuXHRcdFx0XHQvL3dlIGZha2UgdGhlIGRyYWcgc3RvcCBvZiB0aGUgc29ydGFibGUsIGJ1dCBtYWtlIHN1cmUgaXQgZG9lc24ndCByZW1vdmUgdGhlIGhlbHBlciBieSB1c2luZyBjYW5jZWxIZWxwZXJSZW1vdmFsXG5cdFx0XHRcdGlmKHRoaXMuaW5zdGFuY2UuaXNPdmVyKSB7XG5cblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLmlzT3ZlciA9IDA7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5jYW5jZWxIZWxwZXJSZW1vdmFsID0gdHJ1ZTtcblxuXHRcdFx0XHRcdC8vUHJldmVudCByZXZlcnRpbmcgb24gdGhpcyBmb3JjZWQgc3RvcFxuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2Uub3B0aW9ucy5yZXZlcnQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdC8vIFRoZSBvdXQgZXZlbnQgbmVlZHMgdG8gYmUgdHJpZ2dlcmVkIGluZGVwZW5kZW50bHlcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLl90cmlnZ2VyKCdvdXQnLCBldmVudCwgdGhpcy5pbnN0YW5jZS5fdWlIYXNoKHRoaXMuaW5zdGFuY2UpKTtcblxuXHRcdFx0XHRcdHRoaXMuaW5zdGFuY2UuX21vdXNlU3RvcChldmVudCwgdHJ1ZSk7XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZS5vcHRpb25zLmhlbHBlciA9IHRoaXMuaW5zdGFuY2Uub3B0aW9ucy5faGVscGVyO1xuXG5cdFx0XHRcdFx0Ly9Ob3cgd2UgcmVtb3ZlIG91ciBjdXJyZW50SXRlbSwgdGhlIGxpc3QgZ3JvdXAgY2xvbmUgYWdhaW4sIGFuZCB0aGUgcGxhY2Vob2xkZXIsIGFuZCBhbmltYXRlIHRoZSBoZWxwZXIgYmFjayB0byBpdCdzIG9yaWdpbmFsIHNpemVcblx0XHRcdFx0XHR0aGlzLmluc3RhbmNlLmN1cnJlbnRJdGVtLnJlbW92ZSgpO1xuXHRcdFx0XHRcdGlmKHRoaXMuaW5zdGFuY2UucGxhY2Vob2xkZXIpIHRoaXMuaW5zdGFuY2UucGxhY2Vob2xkZXIucmVtb3ZlKCk7XG5cblx0XHRcdFx0XHRpbnN0Ll90cmlnZ2VyKFwiZnJvbVNvcnRhYmxlXCIsIGV2ZW50KTtcblx0XHRcdFx0XHRpbnN0LmRyb3BwZWQgPSBmYWxzZTsgLy9kcmFnZ2FibGUgcmV2ZXJ0IG5lZWRzIHRoYXRcblx0XHRcdFx0fVxuXG5cdFx0XHR9O1xuXG5cdFx0fSk7XG5cblx0fVxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLCBcImN1cnNvclwiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbihldmVudCwgdWkpIHtcblx0XHR2YXIgdCA9ICQoJ2JvZHknKSwgbyA9ICQodGhpcykuZGF0YSgnZHJhZ2dhYmxlJykub3B0aW9ucztcblx0XHRpZiAodC5jc3MoXCJjdXJzb3JcIikpIG8uX2N1cnNvciA9IHQuY3NzKFwiY3Vyc29yXCIpO1xuXHRcdHQuY3NzKFwiY3Vyc29yXCIsIG8uY3Vyc29yKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cdFx0dmFyIG8gPSAkKHRoaXMpLmRhdGEoJ2RyYWdnYWJsZScpLm9wdGlvbnM7XG5cdFx0aWYgKG8uX2N1cnNvcikgJCgnYm9keScpLmNzcyhcImN1cnNvclwiLCBvLl9jdXJzb3IpO1xuXHR9XG59KTtcblxuJC51aS5wbHVnaW4uYWRkKFwiZHJhZ2dhYmxlXCIsIFwib3BhY2l0eVwiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbihldmVudCwgdWkpIHtcblx0XHR2YXIgdCA9ICQodWkuaGVscGVyKSwgbyA9ICQodGhpcykuZGF0YSgnZHJhZ2dhYmxlJykub3B0aW9ucztcblx0XHRpZih0LmNzcyhcIm9wYWNpdHlcIikpIG8uX29wYWNpdHkgPSB0LmNzcyhcIm9wYWNpdHlcIik7XG5cdFx0dC5jc3MoJ29wYWNpdHknLCBvLm9wYWNpdHkpO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbihldmVudCwgdWkpIHtcblx0XHR2YXIgbyA9ICQodGhpcykuZGF0YSgnZHJhZ2dhYmxlJykub3B0aW9ucztcblx0XHRpZihvLl9vcGFjaXR5KSAkKHVpLmhlbHBlcikuY3NzKCdvcGFjaXR5Jywgby5fb3BhY2l0eSk7XG5cdH1cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIiwgXCJzY3JvbGxcIiwge1xuXHRzdGFydDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cdFx0dmFyIGkgPSAkKHRoaXMpLmRhdGEoXCJkcmFnZ2FibGVcIik7XG5cdFx0aWYoaS5zY3JvbGxQYXJlbnRbMF0gIT0gZG9jdW1lbnQgJiYgaS5zY3JvbGxQYXJlbnRbMF0udGFnTmFtZSAhPSAnSFRNTCcpIGkub3ZlcmZsb3dPZmZzZXQgPSBpLnNjcm9sbFBhcmVudC5vZmZzZXQoKTtcblx0fSxcblx0ZHJhZzogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cblx0XHR2YXIgaSA9ICQodGhpcykuZGF0YShcImRyYWdnYWJsZVwiKSwgbyA9IGkub3B0aW9ucywgc2Nyb2xsZWQgPSBmYWxzZTtcblxuXHRcdGlmKGkuc2Nyb2xsUGFyZW50WzBdICE9IGRvY3VtZW50ICYmIGkuc2Nyb2xsUGFyZW50WzBdLnRhZ05hbWUgIT0gJ0hUTUwnKSB7XG5cblx0XHRcdGlmKCFvLmF4aXMgfHwgby5heGlzICE9ICd4Jykge1xuXHRcdFx0XHRpZigoaS5vdmVyZmxvd09mZnNldC50b3AgKyBpLnNjcm9sbFBhcmVudFswXS5vZmZzZXRIZWlnaHQpIC0gZXZlbnQucGFnZVkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KVxuXHRcdFx0XHRcdGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbFRvcCA9IHNjcm9sbGVkID0gaS5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsVG9wICsgby5zY3JvbGxTcGVlZDtcblx0XHRcdFx0ZWxzZSBpZihldmVudC5wYWdlWSAtIGkub3ZlcmZsb3dPZmZzZXQudG9wIDwgby5zY3JvbGxTZW5zaXRpdml0eSlcblx0XHRcdFx0XHRpLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3AgPSBzY3JvbGxlZCA9IGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbFRvcCAtIG8uc2Nyb2xsU3BlZWQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCFvLmF4aXMgfHwgby5heGlzICE9ICd5Jykge1xuXHRcdFx0XHRpZigoaS5vdmVyZmxvd09mZnNldC5sZWZ0ICsgaS5zY3JvbGxQYXJlbnRbMF0ub2Zmc2V0V2lkdGgpIC0gZXZlbnQucGFnZVggPCBvLnNjcm9sbFNlbnNpdGl2aXR5KVxuXHRcdFx0XHRcdGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQgPSBzY3JvbGxlZCA9IGkuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQgKyBvLnNjcm9sbFNwZWVkO1xuXHRcdFx0XHRlbHNlIGlmKGV2ZW50LnBhZ2VYIC0gaS5vdmVyZmxvd09mZnNldC5sZWZ0IDwgby5zY3JvbGxTZW5zaXRpdml0eSlcblx0XHRcdFx0XHRpLnNjcm9sbFBhcmVudFswXS5zY3JvbGxMZWZ0ID0gc2Nyb2xsZWQgPSBpLnNjcm9sbFBhcmVudFswXS5zY3JvbGxMZWZ0IC0gby5zY3JvbGxTcGVlZDtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmKCFvLmF4aXMgfHwgby5heGlzICE9ICd4Jykge1xuXHRcdFx0XHRpZihldmVudC5wYWdlWSAtICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIDwgby5zY3JvbGxTZW5zaXRpdml0eSlcblx0XHRcdFx0XHRzY3JvbGxlZCA9ICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSAtIG8uc2Nyb2xsU3BlZWQpO1xuXHRcdFx0XHRlbHNlIGlmKCQod2luZG93KS5oZWlnaHQoKSAtIChldmVudC5wYWdlWSAtICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpKSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpXG5cdFx0XHRcdFx0c2Nyb2xsZWQgPSAkKGRvY3VtZW50KS5zY3JvbGxUb3AoJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgKyBvLnNjcm9sbFNwZWVkKTtcblx0XHRcdH1cblxuXHRcdFx0aWYoIW8uYXhpcyB8fCBvLmF4aXMgIT0gJ3knKSB7XG5cdFx0XHRcdGlmKGV2ZW50LnBhZ2VYIC0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpIDwgby5zY3JvbGxTZW5zaXRpdml0eSlcblx0XHRcdFx0XHRzY3JvbGxlZCA9ICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpIC0gby5zY3JvbGxTcGVlZCk7XG5cdFx0XHRcdGVsc2UgaWYoJCh3aW5kb3cpLndpZHRoKCkgLSAoZXZlbnQucGFnZVggLSAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkpIDwgby5zY3JvbGxTZW5zaXRpdml0eSlcblx0XHRcdFx0XHRzY3JvbGxlZCA9ICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpICsgby5zY3JvbGxTcGVlZCk7XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZihzY3JvbGxlZCAhPT0gZmFsc2UgJiYgJC51aS5kZG1hbmFnZXIgJiYgIW8uZHJvcEJlaGF2aW91cilcblx0XHRcdCQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKGksIGV2ZW50KTtcblxuXHR9XG59KTtcblxuJC51aS5wbHVnaW4uYWRkKFwiZHJhZ2dhYmxlXCIsIFwic25hcFwiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbihldmVudCwgdWkpIHtcblxuXHRcdHZhciBpID0gJCh0aGlzKS5kYXRhKFwiZHJhZ2dhYmxlXCIpLCBvID0gaS5vcHRpb25zO1xuXHRcdGkuc25hcEVsZW1lbnRzID0gW107XG5cblx0XHQkKG8uc25hcC5jb25zdHJ1Y3RvciAhPSBTdHJpbmcgPyAoIG8uc25hcC5pdGVtcyB8fCAnOmRhdGEoZHJhZ2dhYmxlKScgKSA6IG8uc25hcCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciAkdCA9ICQodGhpcyk7IHZhciAkbyA9ICR0Lm9mZnNldCgpO1xuXHRcdFx0aWYodGhpcyAhPSBpLmVsZW1lbnRbMF0pIGkuc25hcEVsZW1lbnRzLnB1c2goe1xuXHRcdFx0XHRpdGVtOiB0aGlzLFxuXHRcdFx0XHR3aWR0aDogJHQub3V0ZXJXaWR0aCgpLCBoZWlnaHQ6ICR0Lm91dGVySGVpZ2h0KCksXG5cdFx0XHRcdHRvcDogJG8udG9wLCBsZWZ0OiAkby5sZWZ0XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHR9LFxuXHRkcmFnOiBmdW5jdGlvbihldmVudCwgdWkpIHtcblxuXHRcdHZhciBpbnN0ID0gJCh0aGlzKS5kYXRhKFwiZHJhZ2dhYmxlXCIpLCBvID0gaW5zdC5vcHRpb25zO1xuXHRcdHZhciBkID0gby5zbmFwVG9sZXJhbmNlO1xuXG5cdFx0dmFyIHgxID0gdWkub2Zmc2V0LmxlZnQsIHgyID0geDEgKyBpbnN0LmhlbHBlclByb3BvcnRpb25zLndpZHRoLFxuXHRcdFx0eTEgPSB1aS5vZmZzZXQudG9wLCB5MiA9IHkxICsgaW5zdC5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQ7XG5cblx0XHRmb3IgKHZhciBpID0gaW5zdC5zbmFwRWxlbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuXG5cdFx0XHR2YXIgbCA9IGluc3Quc25hcEVsZW1lbnRzW2ldLmxlZnQsIHIgPSBsICsgaW5zdC5zbmFwRWxlbWVudHNbaV0ud2lkdGgsXG5cdFx0XHRcdHQgPSBpbnN0LnNuYXBFbGVtZW50c1tpXS50b3AsIGIgPSB0ICsgaW5zdC5zbmFwRWxlbWVudHNbaV0uaGVpZ2h0O1xuXG5cdFx0XHQvL1llcywgSSBrbm93LCB0aGlzIGlzIGluc2FuZSA7KVxuXHRcdFx0aWYoISgobC1kIDwgeDEgJiYgeDEgPCByK2QgJiYgdC1kIDwgeTEgJiYgeTEgPCBiK2QpIHx8IChsLWQgPCB4MSAmJiB4MSA8IHIrZCAmJiB0LWQgPCB5MiAmJiB5MiA8IGIrZCkgfHwgKGwtZCA8IHgyICYmIHgyIDwgcitkICYmIHQtZCA8IHkxICYmIHkxIDwgYitkKSB8fCAobC1kIDwgeDIgJiYgeDIgPCByK2QgJiYgdC1kIDwgeTIgJiYgeTIgPCBiK2QpKSkge1xuXHRcdFx0XHRpZihpbnN0LnNuYXBFbGVtZW50c1tpXS5zbmFwcGluZykgKGluc3Qub3B0aW9ucy5zbmFwLnJlbGVhc2UgJiYgaW5zdC5vcHRpb25zLnNuYXAucmVsZWFzZS5jYWxsKGluc3QuZWxlbWVudCwgZXZlbnQsICQuZXh0ZW5kKGluc3QuX3VpSGFzaCgpLCB7IHNuYXBJdGVtOiBpbnN0LnNuYXBFbGVtZW50c1tpXS5pdGVtIH0pKSk7XG5cdFx0XHRcdGluc3Quc25hcEVsZW1lbnRzW2ldLnNuYXBwaW5nID0gZmFsc2U7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihvLnNuYXBNb2RlICE9ICdpbm5lcicpIHtcblx0XHRcdFx0dmFyIHRzID0gTWF0aC5hYnModCAtIHkyKSA8PSBkO1xuXHRcdFx0XHR2YXIgYnMgPSBNYXRoLmFicyhiIC0geTEpIDw9IGQ7XG5cdFx0XHRcdHZhciBscyA9IE1hdGguYWJzKGwgLSB4MikgPD0gZDtcblx0XHRcdFx0dmFyIHJzID0gTWF0aC5hYnMociAtIHgxKSA8PSBkO1xuXHRcdFx0XHRpZih0cykgdWkucG9zaXRpb24udG9wID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogdCAtIGluc3QuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0LCBsZWZ0OiAwIH0pLnRvcCAtIGluc3QubWFyZ2lucy50b3A7XG5cdFx0XHRcdGlmKGJzKSB1aS5wb3NpdGlvbi50b3AgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyhcInJlbGF0aXZlXCIsIHsgdG9wOiBiLCBsZWZ0OiAwIH0pLnRvcCAtIGluc3QubWFyZ2lucy50b3A7XG5cdFx0XHRcdGlmKGxzKSB1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogMCwgbGVmdDogbCAtIGluc3QuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggfSkubGVmdCAtIGluc3QubWFyZ2lucy5sZWZ0O1xuXHRcdFx0XHRpZihycykgdWkucG9zaXRpb24ubGVmdCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIiwgeyB0b3A6IDAsIGxlZnQ6IHIgfSkubGVmdCAtIGluc3QubWFyZ2lucy5sZWZ0O1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZmlyc3QgPSAodHMgfHwgYnMgfHwgbHMgfHwgcnMpO1xuXG5cdFx0XHRpZihvLnNuYXBNb2RlICE9ICdvdXRlcicpIHtcblx0XHRcdFx0dmFyIHRzID0gTWF0aC5hYnModCAtIHkxKSA8PSBkO1xuXHRcdFx0XHR2YXIgYnMgPSBNYXRoLmFicyhiIC0geTIpIDw9IGQ7XG5cdFx0XHRcdHZhciBscyA9IE1hdGguYWJzKGwgLSB4MSkgPD0gZDtcblx0XHRcdFx0dmFyIHJzID0gTWF0aC5hYnMociAtIHgyKSA8PSBkO1xuXHRcdFx0XHRpZih0cykgdWkucG9zaXRpb24udG9wID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogdCwgbGVmdDogMCB9KS50b3AgLSBpbnN0Lm1hcmdpbnMudG9wO1xuXHRcdFx0XHRpZihicykgdWkucG9zaXRpb24udG9wID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogYiAtIGluc3QuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0LCBsZWZ0OiAwIH0pLnRvcCAtIGluc3QubWFyZ2lucy50b3A7XG5cdFx0XHRcdGlmKGxzKSB1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogMCwgbGVmdDogbCB9KS5sZWZ0IC0gaW5zdC5tYXJnaW5zLmxlZnQ7XG5cdFx0XHRcdGlmKHJzKSB1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogMCwgbGVmdDogciAtIGluc3QuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggfSkubGVmdCAtIGluc3QubWFyZ2lucy5sZWZ0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZighaW5zdC5zbmFwRWxlbWVudHNbaV0uc25hcHBpbmcgJiYgKHRzIHx8IGJzIHx8IGxzIHx8IHJzIHx8IGZpcnN0KSlcblx0XHRcdFx0KGluc3Qub3B0aW9ucy5zbmFwLnNuYXAgJiYgaW5zdC5vcHRpb25zLnNuYXAuc25hcC5jYWxsKGluc3QuZWxlbWVudCwgZXZlbnQsICQuZXh0ZW5kKGluc3QuX3VpSGFzaCgpLCB7IHNuYXBJdGVtOiBpbnN0LnNuYXBFbGVtZW50c1tpXS5pdGVtIH0pKSk7XG5cdFx0XHRpbnN0LnNuYXBFbGVtZW50c1tpXS5zbmFwcGluZyA9ICh0cyB8fCBicyB8fCBscyB8fCBycyB8fCBmaXJzdCk7XG5cblx0XHR9O1xuXG5cdH1cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIiwgXCJzdGFja1wiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbihldmVudCwgdWkpIHtcblxuXHRcdHZhciBvID0gJCh0aGlzKS5kYXRhKFwiZHJhZ2dhYmxlXCIpLm9wdGlvbnM7XG5cblx0XHR2YXIgZ3JvdXAgPSAkLm1ha2VBcnJheSgkKG8uc3RhY2spKS5zb3J0KGZ1bmN0aW9uKGEsYikge1xuXHRcdFx0cmV0dXJuIChwYXJzZUludCgkKGEpLmNzcyhcInpJbmRleFwiKSwxMCkgfHwgMCkgLSAocGFyc2VJbnQoJChiKS5jc3MoXCJ6SW5kZXhcIiksMTApIHx8IDApO1xuXHRcdH0pO1xuXHRcdGlmICghZ3JvdXAubGVuZ3RoKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG1pbiA9IHBhcnNlSW50KGdyb3VwWzBdLnN0eWxlLnpJbmRleCkgfHwgMDtcblx0XHQkKGdyb3VwKS5lYWNoKGZ1bmN0aW9uKGkpIHtcblx0XHRcdHRoaXMuc3R5bGUuekluZGV4ID0gbWluICsgaTtcblx0XHR9KTtcblxuXHRcdHRoaXNbMF0uc3R5bGUuekluZGV4ID0gbWluICsgZ3JvdXAubGVuZ3RoO1xuXG5cdH1cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIiwgXCJ6SW5kZXhcIiwge1xuXHRzdGFydDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cdFx0dmFyIHQgPSAkKHVpLmhlbHBlciksIG8gPSAkKHRoaXMpLmRhdGEoXCJkcmFnZ2FibGVcIikub3B0aW9ucztcblx0XHRpZih0LmNzcyhcInpJbmRleFwiKSkgby5fekluZGV4ID0gdC5jc3MoXCJ6SW5kZXhcIik7XG5cdFx0dC5jc3MoJ3pJbmRleCcsIG8uekluZGV4KTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cdFx0dmFyIG8gPSAkKHRoaXMpLmRhdGEoXCJkcmFnZ2FibGVcIikub3B0aW9ucztcblx0XHRpZihvLl96SW5kZXgpICQodWkuaGVscGVyKS5jc3MoJ3pJbmRleCcsIG8uX3pJbmRleCk7XG5cdH1cbn0pO1xuXG59KShqUXVlcnkpO1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQud2lkZ2V0KFwidWkuZHJvcHBhYmxlXCIsIHtcblx0dmVyc2lvbjogXCIxLjkuMlwiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJkcm9wXCIsXG5cdG9wdGlvbnM6IHtcblx0XHRhY2NlcHQ6ICcqJyxcblx0XHRhY3RpdmVDbGFzczogZmFsc2UsXG5cdFx0YWRkQ2xhc3NlczogdHJ1ZSxcblx0XHRncmVlZHk6IGZhbHNlLFxuXHRcdGhvdmVyQ2xhc3M6IGZhbHNlLFxuXHRcdHNjb3BlOiAnZGVmYXVsdCcsXG5cdFx0dG9sZXJhbmNlOiAnaW50ZXJzZWN0J1xuXHR9LFxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zLCBhY2NlcHQgPSBvLmFjY2VwdDtcblx0XHR0aGlzLmlzb3ZlciA9IDA7IHRoaXMuaXNvdXQgPSAxO1xuXG5cdFx0dGhpcy5hY2NlcHQgPSAkLmlzRnVuY3Rpb24oYWNjZXB0KSA/IGFjY2VwdCA6IGZ1bmN0aW9uKGQpIHtcblx0XHRcdHJldHVybiBkLmlzKGFjY2VwdCk7XG5cdFx0fTtcblxuXHRcdC8vU3RvcmUgdGhlIGRyb3BwYWJsZSdzIHByb3BvcnRpb25zXG5cdFx0dGhpcy5wcm9wb3J0aW9ucyA9IHsgd2lkdGg6IHRoaXMuZWxlbWVudFswXS5vZmZzZXRXaWR0aCwgaGVpZ2h0OiB0aGlzLmVsZW1lbnRbMF0ub2Zmc2V0SGVpZ2h0IH07XG5cblx0XHQvLyBBZGQgdGhlIHJlZmVyZW5jZSBhbmQgcG9zaXRpb25zIHRvIHRoZSBtYW5hZ2VyXG5cdFx0JC51aS5kZG1hbmFnZXIuZHJvcHBhYmxlc1tvLnNjb3BlXSA9ICQudWkuZGRtYW5hZ2VyLmRyb3BwYWJsZXNbby5zY29wZV0gfHwgW107XG5cdFx0JC51aS5kZG1hbmFnZXIuZHJvcHBhYmxlc1tvLnNjb3BlXS5wdXNoKHRoaXMpO1xuXG5cdFx0KG8uYWRkQ2xhc3NlcyAmJiB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXCJ1aS1kcm9wcGFibGVcIikpO1xuXG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkcm9wID0gJC51aS5kZG1hbmFnZXIuZHJvcHBhYmxlc1t0aGlzLm9wdGlvbnMuc2NvcGVdO1xuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGRyb3AubGVuZ3RoOyBpKysgKVxuXHRcdFx0aWYgKCBkcm9wW2ldID09IHRoaXMgKVxuXHRcdFx0XHRkcm9wLnNwbGljZShpLCAxKTtcblxuXHRcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcInVpLWRyb3BwYWJsZSB1aS1kcm9wcGFibGUtZGlzYWJsZWRcIik7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXG5cdFx0aWYoa2V5ID09ICdhY2NlcHQnKSB7XG5cdFx0XHR0aGlzLmFjY2VwdCA9ICQuaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0cmV0dXJuIGQuaXModmFsdWUpO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0JC5XaWRnZXQucHJvdG90eXBlLl9zZXRPcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSxcblxuXHRfYWN0aXZhdGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIGRyYWdnYWJsZSA9ICQudWkuZGRtYW5hZ2VyLmN1cnJlbnQ7XG5cdFx0aWYodGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSB0aGlzLmVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblx0XHQoZHJhZ2dhYmxlICYmIHRoaXMuX3RyaWdnZXIoJ2FjdGl2YXRlJywgZXZlbnQsIHRoaXMudWkoZHJhZ2dhYmxlKSkpO1xuXHR9LFxuXG5cdF9kZWFjdGl2YXRlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBkcmFnZ2FibGUgPSAkLnVpLmRkbWFuYWdlci5jdXJyZW50O1xuXHRcdGlmKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcykgdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7XG5cdFx0KGRyYWdnYWJsZSAmJiB0aGlzLl90cmlnZ2VyKCdkZWFjdGl2YXRlJywgZXZlbnQsIHRoaXMudWkoZHJhZ2dhYmxlKSkpO1xuXHR9LFxuXG5cdF9vdmVyOiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0dmFyIGRyYWdnYWJsZSA9ICQudWkuZGRtYW5hZ2VyLmN1cnJlbnQ7XG5cdFx0aWYgKCFkcmFnZ2FibGUgfHwgKGRyYWdnYWJsZS5jdXJyZW50SXRlbSB8fCBkcmFnZ2FibGUuZWxlbWVudClbMF0gPT0gdGhpcy5lbGVtZW50WzBdKSByZXR1cm47IC8vIEJhaWwgaWYgZHJhZ2dhYmxlIGFuZCBkcm9wcGFibGUgYXJlIHNhbWUgZWxlbWVudFxuXG5cdFx0aWYgKHRoaXMuYWNjZXB0LmNhbGwodGhpcy5lbGVtZW50WzBdLChkcmFnZ2FibGUuY3VycmVudEl0ZW0gfHwgZHJhZ2dhYmxlLmVsZW1lbnQpKSkge1xuXHRcdFx0aWYodGhpcy5vcHRpb25zLmhvdmVyQ2xhc3MpIHRoaXMuZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuaG92ZXJDbGFzcyk7XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCdvdmVyJywgZXZlbnQsIHRoaXMudWkoZHJhZ2dhYmxlKSk7XG5cdFx0fVxuXG5cdH0sXG5cblx0X291dDogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdHZhciBkcmFnZ2FibGUgPSAkLnVpLmRkbWFuYWdlci5jdXJyZW50O1xuXHRcdGlmICghZHJhZ2dhYmxlIHx8IChkcmFnZ2FibGUuY3VycmVudEl0ZW0gfHwgZHJhZ2dhYmxlLmVsZW1lbnQpWzBdID09IHRoaXMuZWxlbWVudFswXSkgcmV0dXJuOyAvLyBCYWlsIGlmIGRyYWdnYWJsZSBhbmQgZHJvcHBhYmxlIGFyZSBzYW1lIGVsZW1lbnRcblxuXHRcdGlmICh0aGlzLmFjY2VwdC5jYWxsKHRoaXMuZWxlbWVudFswXSwoZHJhZ2dhYmxlLmN1cnJlbnRJdGVtIHx8IGRyYWdnYWJsZS5lbGVtZW50KSkpIHtcblx0XHRcdGlmKHRoaXMub3B0aW9ucy5ob3ZlckNsYXNzKSB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmhvdmVyQ2xhc3MpO1xuXHRcdFx0dGhpcy5fdHJpZ2dlcignb3V0JywgZXZlbnQsIHRoaXMudWkoZHJhZ2dhYmxlKSk7XG5cdFx0fVxuXG5cdH0sXG5cblx0X2Ryb3A6IGZ1bmN0aW9uKGV2ZW50LGN1c3RvbSkge1xuXG5cdFx0dmFyIGRyYWdnYWJsZSA9IGN1c3RvbSB8fCAkLnVpLmRkbWFuYWdlci5jdXJyZW50O1xuXHRcdGlmICghZHJhZ2dhYmxlIHx8IChkcmFnZ2FibGUuY3VycmVudEl0ZW0gfHwgZHJhZ2dhYmxlLmVsZW1lbnQpWzBdID09IHRoaXMuZWxlbWVudFswXSkgcmV0dXJuIGZhbHNlOyAvLyBCYWlsIGlmIGRyYWdnYWJsZSBhbmQgZHJvcHBhYmxlIGFyZSBzYW1lIGVsZW1lbnRcblxuXHRcdHZhciBjaGlsZHJlbkludGVyc2VjdGlvbiA9IGZhbHNlO1xuXHRcdHRoaXMuZWxlbWVudC5maW5kKFwiOmRhdGEoZHJvcHBhYmxlKVwiKS5ub3QoXCIudWktZHJhZ2dhYmxlLWRyYWdnaW5nXCIpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5zdCA9ICQuZGF0YSh0aGlzLCAnZHJvcHBhYmxlJyk7XG5cdFx0XHRpZihcblx0XHRcdFx0aW5zdC5vcHRpb25zLmdyZWVkeVxuXHRcdFx0XHQmJiAhaW5zdC5vcHRpb25zLmRpc2FibGVkXG5cdFx0XHRcdCYmIGluc3Qub3B0aW9ucy5zY29wZSA9PSBkcmFnZ2FibGUub3B0aW9ucy5zY29wZVxuXHRcdFx0XHQmJiBpbnN0LmFjY2VwdC5jYWxsKGluc3QuZWxlbWVudFswXSwgKGRyYWdnYWJsZS5jdXJyZW50SXRlbSB8fCBkcmFnZ2FibGUuZWxlbWVudCkpXG5cdFx0XHRcdCYmICQudWkuaW50ZXJzZWN0KGRyYWdnYWJsZSwgJC5leHRlbmQoaW5zdCwgeyBvZmZzZXQ6IGluc3QuZWxlbWVudC5vZmZzZXQoKSB9KSwgaW5zdC5vcHRpb25zLnRvbGVyYW5jZSlcblx0XHRcdCkgeyBjaGlsZHJlbkludGVyc2VjdGlvbiA9IHRydWU7IHJldHVybiBmYWxzZTsgfVxuXHRcdH0pO1xuXHRcdGlmKGNoaWxkcmVuSW50ZXJzZWN0aW9uKSByZXR1cm4gZmFsc2U7XG5cblx0XHRpZih0aGlzLmFjY2VwdC5jYWxsKHRoaXMuZWxlbWVudFswXSwoZHJhZ2dhYmxlLmN1cnJlbnRJdGVtIHx8IGRyYWdnYWJsZS5lbGVtZW50KSkpIHtcblx0XHRcdGlmKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcykgdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7XG5cdFx0XHRpZih0aGlzLm9wdGlvbnMuaG92ZXJDbGFzcykgdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5ob3ZlckNsYXNzKTtcblx0XHRcdHRoaXMuX3RyaWdnZXIoJ2Ryb3AnLCBldmVudCwgdGhpcy51aShkcmFnZ2FibGUpKTtcblx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH0sXG5cblx0dWk6IGZ1bmN0aW9uKGMpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZHJhZ2dhYmxlOiAoYy5jdXJyZW50SXRlbSB8fCBjLmVsZW1lbnQpLFxuXHRcdFx0aGVscGVyOiBjLmhlbHBlcixcblx0XHRcdHBvc2l0aW9uOiBjLnBvc2l0aW9uLFxuXHRcdFx0b2Zmc2V0OiBjLnBvc2l0aW9uQWJzXG5cdFx0fTtcblx0fVxuXG59KTtcblxuJC51aS5pbnRlcnNlY3QgPSBmdW5jdGlvbihkcmFnZ2FibGUsIGRyb3BwYWJsZSwgdG9sZXJhbmNlTW9kZSkge1xuXG5cdGlmICghZHJvcHBhYmxlLm9mZnNldCkgcmV0dXJuIGZhbHNlO1xuXG5cdHZhciB4MSA9IChkcmFnZ2FibGUucG9zaXRpb25BYnMgfHwgZHJhZ2dhYmxlLnBvc2l0aW9uLmFic29sdXRlKS5sZWZ0LCB4MiA9IHgxICsgZHJhZ2dhYmxlLmhlbHBlclByb3BvcnRpb25zLndpZHRoLFxuXHRcdHkxID0gKGRyYWdnYWJsZS5wb3NpdGlvbkFicyB8fCBkcmFnZ2FibGUucG9zaXRpb24uYWJzb2x1dGUpLnRvcCwgeTIgPSB5MSArIGRyYWdnYWJsZS5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQ7XG5cdHZhciBsID0gZHJvcHBhYmxlLm9mZnNldC5sZWZ0LCByID0gbCArIGRyb3BwYWJsZS5wcm9wb3J0aW9ucy53aWR0aCxcblx0XHR0ID0gZHJvcHBhYmxlLm9mZnNldC50b3AsIGIgPSB0ICsgZHJvcHBhYmxlLnByb3BvcnRpb25zLmhlaWdodDtcblxuXHRzd2l0Y2ggKHRvbGVyYW5jZU1vZGUpIHtcblx0XHRjYXNlICdmaXQnOlxuXHRcdFx0cmV0dXJuIChsIDw9IHgxICYmIHgyIDw9IHJcblx0XHRcdFx0JiYgdCA8PSB5MSAmJiB5MiA8PSBiKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2ludGVyc2VjdCc6XG5cdFx0XHRyZXR1cm4gKGwgPCB4MSArIChkcmFnZ2FibGUuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLyAyKSAvLyBSaWdodCBIYWxmXG5cdFx0XHRcdCYmIHgyIC0gKGRyYWdnYWJsZS5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAvIDIpIDwgciAvLyBMZWZ0IEhhbGZcblx0XHRcdFx0JiYgdCA8IHkxICsgKGRyYWdnYWJsZS5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLyAyKSAvLyBCb3R0b20gSGFsZlxuXHRcdFx0XHQmJiB5MiAtIChkcmFnZ2FibGUuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC8gMikgPCBiICk7IC8vIFRvcCBIYWxmXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdwb2ludGVyJzpcblx0XHRcdHZhciBkcmFnZ2FibGVMZWZ0ID0gKChkcmFnZ2FibGUucG9zaXRpb25BYnMgfHwgZHJhZ2dhYmxlLnBvc2l0aW9uLmFic29sdXRlKS5sZWZ0ICsgKGRyYWdnYWJsZS5jbGlja09mZnNldCB8fCBkcmFnZ2FibGUub2Zmc2V0LmNsaWNrKS5sZWZ0KSxcblx0XHRcdFx0ZHJhZ2dhYmxlVG9wID0gKChkcmFnZ2FibGUucG9zaXRpb25BYnMgfHwgZHJhZ2dhYmxlLnBvc2l0aW9uLmFic29sdXRlKS50b3AgKyAoZHJhZ2dhYmxlLmNsaWNrT2Zmc2V0IHx8IGRyYWdnYWJsZS5vZmZzZXQuY2xpY2spLnRvcCksXG5cdFx0XHRcdGlzT3ZlciA9ICQudWkuaXNPdmVyKGRyYWdnYWJsZVRvcCwgZHJhZ2dhYmxlTGVmdCwgdCwgbCwgZHJvcHBhYmxlLnByb3BvcnRpb25zLmhlaWdodCwgZHJvcHBhYmxlLnByb3BvcnRpb25zLndpZHRoKTtcblx0XHRcdHJldHVybiBpc092ZXI7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICd0b3VjaCc6XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdCh5MSA+PSB0ICYmIHkxIDw9IGIpIHx8XHQvLyBUb3AgZWRnZSB0b3VjaGluZ1xuXHRcdFx0XHRcdCh5MiA+PSB0ICYmIHkyIDw9IGIpIHx8XHQvLyBCb3R0b20gZWRnZSB0b3VjaGluZ1xuXHRcdFx0XHRcdCh5MSA8IHQgJiYgeTIgPiBiKVx0XHQvLyBTdXJyb3VuZGVkIHZlcnRpY2FsbHlcblx0XHRcdFx0KSAmJiAoXG5cdFx0XHRcdFx0KHgxID49IGwgJiYgeDEgPD0gcikgfHxcdC8vIExlZnQgZWRnZSB0b3VjaGluZ1xuXHRcdFx0XHRcdCh4MiA+PSBsICYmIHgyIDw9IHIpIHx8XHQvLyBSaWdodCBlZGdlIHRvdWNoaW5nXG5cdFx0XHRcdFx0KHgxIDwgbCAmJiB4MiA+IHIpXHRcdC8vIFN1cnJvdW5kZWQgaG9yaXpvbnRhbGx5XG5cdFx0XHRcdCk7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG59O1xuXG4vKlxuXHRUaGlzIG1hbmFnZXIgdHJhY2tzIG9mZnNldHMgb2YgZHJhZ2dhYmxlcyBhbmQgZHJvcHBhYmxlc1xuKi9cbiQudWkuZGRtYW5hZ2VyID0ge1xuXHRjdXJyZW50OiBudWxsLFxuXHRkcm9wcGFibGVzOiB7ICdkZWZhdWx0JzogW10gfSxcblx0cHJlcGFyZU9mZnNldHM6IGZ1bmN0aW9uKHQsIGV2ZW50KSB7XG5cblx0XHR2YXIgbSA9ICQudWkuZGRtYW5hZ2VyLmRyb3BwYWJsZXNbdC5vcHRpb25zLnNjb3BlXSB8fCBbXTtcblx0XHR2YXIgdHlwZSA9IGV2ZW50ID8gZXZlbnQudHlwZSA6IG51bGw7IC8vIHdvcmthcm91bmQgZm9yICMyMzE3XG5cdFx0dmFyIGxpc3QgPSAodC5jdXJyZW50SXRlbSB8fCB0LmVsZW1lbnQpLmZpbmQoXCI6ZGF0YShkcm9wcGFibGUpXCIpLmFuZFNlbGYoKTtcblxuXHRcdGRyb3BwYWJsZXNMb29wOiBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIHtcblxuXHRcdFx0aWYobVtpXS5vcHRpb25zLmRpc2FibGVkIHx8ICh0ICYmICFtW2ldLmFjY2VwdC5jYWxsKG1baV0uZWxlbWVudFswXSwodC5jdXJyZW50SXRlbSB8fCB0LmVsZW1lbnQpKSkpIGNvbnRpbnVlO1x0Ly9ObyBkaXNhYmxlZCBhbmQgbm9uLWFjY2VwdGVkXG5cdFx0XHRmb3IgKHZhciBqPTA7IGogPCBsaXN0Lmxlbmd0aDsgaisrKSB7IGlmKGxpc3Rbal0gPT0gbVtpXS5lbGVtZW50WzBdKSB7IG1baV0ucHJvcG9ydGlvbnMuaGVpZ2h0ID0gMDsgY29udGludWUgZHJvcHBhYmxlc0xvb3A7IH0gfTsgLy9GaWx0ZXIgb3V0IGVsZW1lbnRzIGluIHRoZSBjdXJyZW50IGRyYWdnZWQgaXRlbVxuXHRcdFx0bVtpXS52aXNpYmxlID0gbVtpXS5lbGVtZW50LmNzcyhcImRpc3BsYXlcIikgIT0gXCJub25lXCI7IGlmKCFtW2ldLnZpc2libGUpIGNvbnRpbnVlOyBcdFx0XHRcdFx0XHRcdFx0XHQvL0lmIHRoZSBlbGVtZW50IGlzIG5vdCB2aXNpYmxlLCBjb250aW51ZVxuXG5cdFx0XHRpZih0eXBlID09IFwibW91c2Vkb3duXCIpIG1baV0uX2FjdGl2YXRlLmNhbGwobVtpXSwgZXZlbnQpOyAvL0FjdGl2YXRlIHRoZSBkcm9wcGFibGUgaWYgdXNlZCBkaXJlY3RseSBmcm9tIGRyYWdnYWJsZXNcblxuXHRcdFx0bVtpXS5vZmZzZXQgPSBtW2ldLmVsZW1lbnQub2Zmc2V0KCk7XG5cdFx0XHRtW2ldLnByb3BvcnRpb25zID0geyB3aWR0aDogbVtpXS5lbGVtZW50WzBdLm9mZnNldFdpZHRoLCBoZWlnaHQ6IG1baV0uZWxlbWVudFswXS5vZmZzZXRIZWlnaHQgfTtcblxuXHRcdH1cblxuXHR9LFxuXHRkcm9wOiBmdW5jdGlvbihkcmFnZ2FibGUsIGV2ZW50KSB7XG5cblx0XHR2YXIgZHJvcHBlZCA9IGZhbHNlO1xuXHRcdCQuZWFjaCgkLnVpLmRkbWFuYWdlci5kcm9wcGFibGVzW2RyYWdnYWJsZS5vcHRpb25zLnNjb3BlXSB8fCBbXSwgZnVuY3Rpb24oKSB7XG5cblx0XHRcdGlmKCF0aGlzLm9wdGlvbnMpIHJldHVybjtcblx0XHRcdGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVkICYmIHRoaXMudmlzaWJsZSAmJiAkLnVpLmludGVyc2VjdChkcmFnZ2FibGUsIHRoaXMsIHRoaXMub3B0aW9ucy50b2xlcmFuY2UpKVxuXHRcdFx0XHRkcm9wcGVkID0gdGhpcy5fZHJvcC5jYWxsKHRoaXMsIGV2ZW50KSB8fCBkcm9wcGVkO1xuXG5cdFx0XHRpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlZCAmJiB0aGlzLnZpc2libGUgJiYgdGhpcy5hY2NlcHQuY2FsbCh0aGlzLmVsZW1lbnRbMF0sKGRyYWdnYWJsZS5jdXJyZW50SXRlbSB8fCBkcmFnZ2FibGUuZWxlbWVudCkpKSB7XG5cdFx0XHRcdHRoaXMuaXNvdXQgPSAxOyB0aGlzLmlzb3ZlciA9IDA7XG5cdFx0XHRcdHRoaXMuX2RlYWN0aXZhdGUuY2FsbCh0aGlzLCBldmVudCk7XG5cdFx0XHR9XG5cblx0XHR9KTtcblx0XHRyZXR1cm4gZHJvcHBlZDtcblxuXHR9LFxuXHRkcmFnU3RhcnQ6IGZ1bmN0aW9uKCBkcmFnZ2FibGUsIGV2ZW50ICkge1xuXHRcdC8vTGlzdGVuIGZvciBzY3JvbGxpbmcgc28gdGhhdCBpZiB0aGUgZHJhZ2dpbmcgY2F1c2VzIHNjcm9sbGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIGRyb3BwYWJsZXMgY2FuIGJlIHJlY2FsY3VsYXRlZCAoc2VlICM1MDAzKVxuXHRcdGRyYWdnYWJsZS5lbGVtZW50LnBhcmVudHNVbnRpbCggXCJib2R5XCIgKS5iaW5kKCBcInNjcm9sbC5kcm9wcGFibGVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiggIWRyYWdnYWJsZS5vcHRpb25zLnJlZnJlc2hQb3NpdGlvbnMgKSAkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyggZHJhZ2dhYmxlLCBldmVudCApO1xuXHRcdH0pO1xuXHR9LFxuXHRkcmFnOiBmdW5jdGlvbihkcmFnZ2FibGUsIGV2ZW50KSB7XG5cblx0XHQvL0lmIHlvdSBoYXZlIGEgaGlnaGx5IGR5bmFtaWMgcGFnZSwgeW91IG1pZ2h0IHRyeSB0aGlzIG9wdGlvbi4gSXQgcmVuZGVycyBwb3NpdGlvbnMgZXZlcnkgdGltZSB5b3UgbW92ZSB0aGUgbW91c2UuXG5cdFx0aWYoZHJhZ2dhYmxlLm9wdGlvbnMucmVmcmVzaFBvc2l0aW9ucykgJC51aS5kZG1hbmFnZXIucHJlcGFyZU9mZnNldHMoZHJhZ2dhYmxlLCBldmVudCk7XG5cblx0XHQvL1J1biB0aHJvdWdoIGFsbCBkcm9wcGFibGVzIGFuZCBjaGVjayB0aGVpciBwb3NpdGlvbnMgYmFzZWQgb24gc3BlY2lmaWMgdG9sZXJhbmNlIG9wdGlvbnNcblx0XHQkLmVhY2goJC51aS5kZG1hbmFnZXIuZHJvcHBhYmxlc1tkcmFnZ2FibGUub3B0aW9ucy5zY29wZV0gfHwgW10sIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRpZih0aGlzLm9wdGlvbnMuZGlzYWJsZWQgfHwgdGhpcy5ncmVlZHlDaGlsZCB8fCAhdGhpcy52aXNpYmxlKSByZXR1cm47XG5cdFx0XHR2YXIgaW50ZXJzZWN0cyA9ICQudWkuaW50ZXJzZWN0KGRyYWdnYWJsZSwgdGhpcywgdGhpcy5vcHRpb25zLnRvbGVyYW5jZSk7XG5cblx0XHRcdHZhciBjID0gIWludGVyc2VjdHMgJiYgdGhpcy5pc292ZXIgPT0gMSA/ICdpc291dCcgOiAoaW50ZXJzZWN0cyAmJiB0aGlzLmlzb3ZlciA9PSAwID8gJ2lzb3ZlcicgOiBudWxsKTtcblx0XHRcdGlmKCFjKSByZXR1cm47XG5cblx0XHRcdHZhciBwYXJlbnRJbnN0YW5jZTtcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuZ3JlZWR5KSB7XG5cdFx0XHRcdC8vIGZpbmQgZHJvcHBhYmxlIHBhcmVudHMgd2l0aCBzYW1lIHNjb3BlXG5cdFx0XHRcdHZhciBzY29wZSA9IHRoaXMub3B0aW9ucy5zY29wZTtcblx0XHRcdFx0dmFyIHBhcmVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnRzKCc6ZGF0YShkcm9wcGFibGUpJykuZmlsdGVyKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gJC5kYXRhKHRoaXMsICdkcm9wcGFibGUnKS5vcHRpb25zLnNjb3BlID09PSBzY29wZTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKHBhcmVudC5sZW5ndGgpIHtcblx0XHRcdFx0XHRwYXJlbnRJbnN0YW5jZSA9ICQuZGF0YShwYXJlbnRbMF0sICdkcm9wcGFibGUnKTtcblx0XHRcdFx0XHRwYXJlbnRJbnN0YW5jZS5ncmVlZHlDaGlsZCA9IChjID09ICdpc292ZXInID8gMSA6IDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHdlIGp1c3QgbW92ZWQgaW50byBhIGdyZWVkeSBjaGlsZFxuXHRcdFx0aWYgKHBhcmVudEluc3RhbmNlICYmIGMgPT0gJ2lzb3ZlcicpIHtcblx0XHRcdFx0cGFyZW50SW5zdGFuY2VbJ2lzb3ZlciddID0gMDtcblx0XHRcdFx0cGFyZW50SW5zdGFuY2VbJ2lzb3V0J10gPSAxO1xuXHRcdFx0XHRwYXJlbnRJbnN0YW5jZS5fb3V0LmNhbGwocGFyZW50SW5zdGFuY2UsIGV2ZW50KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpc1tjXSA9IDE7IHRoaXNbYyA9PSAnaXNvdXQnID8gJ2lzb3ZlcicgOiAnaXNvdXQnXSA9IDA7XG5cdFx0XHR0aGlzW2MgPT0gXCJpc292ZXJcIiA/IFwiX292ZXJcIiA6IFwiX291dFwiXS5jYWxsKHRoaXMsIGV2ZW50KTtcblxuXHRcdFx0Ly8gd2UganVzdCBtb3ZlZCBvdXQgb2YgYSBncmVlZHkgY2hpbGRcblx0XHRcdGlmIChwYXJlbnRJbnN0YW5jZSAmJiBjID09ICdpc291dCcpIHtcblx0XHRcdFx0cGFyZW50SW5zdGFuY2VbJ2lzb3V0J10gPSAwO1xuXHRcdFx0XHRwYXJlbnRJbnN0YW5jZVsnaXNvdmVyJ10gPSAxO1xuXHRcdFx0XHRwYXJlbnRJbnN0YW5jZS5fb3Zlci5jYWxsKHBhcmVudEluc3RhbmNlLCBldmVudCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSxcblx0ZHJhZ1N0b3A6IGZ1bmN0aW9uKCBkcmFnZ2FibGUsIGV2ZW50ICkge1xuXHRcdGRyYWdnYWJsZS5lbGVtZW50LnBhcmVudHNVbnRpbCggXCJib2R5XCIgKS51bmJpbmQoIFwic2Nyb2xsLmRyb3BwYWJsZVwiICk7XG5cdFx0Ly9DYWxsIHByZXBhcmVPZmZzZXRzIG9uZSBmaW5hbCB0aW1lIHNpbmNlIElFIGRvZXMgbm90IGZpcmUgcmV0dXJuIHNjcm9sbCBldmVudHMgd2hlbiBvdmVyZmxvdyB3YXMgY2F1c2VkIGJ5IGRyYWcgKHNlZSAjNTAwMylcblx0XHRpZiggIWRyYWdnYWJsZS5vcHRpb25zLnJlZnJlc2hQb3NpdGlvbnMgKSAkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyggZHJhZ2dhYmxlLCBldmVudCApO1xuXHR9XG59O1xuXG59KShqUXVlcnkpO1xuOyhqUXVlcnkuZWZmZWN0cyB8fCAoZnVuY3Rpb24oJCwgdW5kZWZpbmVkKSB7XG5cbnZhciBiYWNrQ29tcGF0ID0gJC51aUJhY2tDb21wYXQgIT09IGZhbHNlLFxuXHQvLyBwcmVmaXggdXNlZCBmb3Igc3RvcmluZyBkYXRhIG9uIC5kYXRhKClcblx0ZGF0YVNwYWNlID0gXCJ1aS1lZmZlY3RzLVwiO1xuXG4kLmVmZmVjdHMgPSB7XG5cdGVmZmVjdDoge31cbn07XG5cbi8qIVxuICogalF1ZXJ5IENvbG9yIEFuaW1hdGlvbnMgdjIuMC4wXG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAxMiBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogTW9uIEF1ZyAxMyAxMzo0MTowMiAyMDEyIC0wNTAwXG4gKi9cbihmdW5jdGlvbiggalF1ZXJ5LCB1bmRlZmluZWQgKSB7XG5cblx0dmFyIHN0ZXBIb29rcyA9IFwiYmFja2dyb3VuZENvbG9yIGJvcmRlckJvdHRvbUNvbG9yIGJvcmRlckxlZnRDb2xvciBib3JkZXJSaWdodENvbG9yIGJvcmRlclRvcENvbG9yIGNvbG9yIGNvbHVtblJ1bGVDb2xvciBvdXRsaW5lQ29sb3IgdGV4dERlY29yYXRpb25Db2xvciB0ZXh0RW1waGFzaXNDb2xvclwiLnNwbGl0KFwiIFwiKSxcblxuXHQvLyBwbHVzZXF1YWxzIHRlc3QgZm9yICs9IDEwMCAtPSAxMDBcblx0cnBsdXNlcXVhbHMgPSAvXihbXFwtK10pPVxccyooXFxkK1xcLj9cXGQqKS8sXG5cdC8vIGEgc2V0IG9mIFJFJ3MgdGhhdCBjYW4gbWF0Y2ggc3RyaW5ncyBhbmQgZ2VuZXJhdGUgY29sb3IgdHVwbGVzLlxuXHRzdHJpbmdQYXJzZXJzID0gW3tcblx0XHRcdHJlOiAvcmdiYT9cXChcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKig/OixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFxzKik/XFwpLyxcblx0XHRcdHBhcnNlOiBmdW5jdGlvbiggZXhlY1Jlc3VsdCApIHtcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRleGVjUmVzdWx0WyAxIF0sXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgMiBdLFxuXHRcdFx0XHRcdGV4ZWNSZXN1bHRbIDMgXSxcblx0XHRcdFx0XHRleGVjUmVzdWx0WyA0IF1cblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHR9LCB7XG5cdFx0XHRyZTogL3JnYmE/XFwoXFxzKihcXGQrKD86XFwuXFxkKyk/KVxcJVxccyosXFxzKihcXGQrKD86XFwuXFxkKyk/KVxcJVxccyosXFxzKihcXGQrKD86XFwuXFxkKyk/KVxcJVxccyooPzosXFxzKihcXGQrKD86XFwuXFxkKyk/KVxccyopP1xcKS8sXG5cdFx0XHRwYXJzZTogZnVuY3Rpb24oIGV4ZWNSZXN1bHQgKSB7XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgMSBdICogMi41NSxcblx0XHRcdFx0XHRleGVjUmVzdWx0WyAyIF0gKiAyLjU1LFxuXHRcdFx0XHRcdGV4ZWNSZXN1bHRbIDMgXSAqIDIuNTUsXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgNCBdXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0fSwge1xuXHRcdFx0Ly8gdGhpcyByZWdleCBpZ25vcmVzIEEtRiBiZWNhdXNlIGl0J3MgY29tcGFyZWQgYWdhaW5zdCBhbiBhbHJlYWR5IGxvd2VyY2FzZWQgc3RyaW5nXG5cdFx0XHRyZTogLyMoW2EtZjAtOV17Mn0pKFthLWYwLTldezJ9KShbYS1mMC05XXsyfSkvLFxuXHRcdFx0cGFyc2U6IGZ1bmN0aW9uKCBleGVjUmVzdWx0ICkge1xuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdHBhcnNlSW50KCBleGVjUmVzdWx0WyAxIF0sIDE2ICksXG5cdFx0XHRcdFx0cGFyc2VJbnQoIGV4ZWNSZXN1bHRbIDIgXSwgMTYgKSxcblx0XHRcdFx0XHRwYXJzZUludCggZXhlY1Jlc3VsdFsgMyBdLCAxNiApXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0fSwge1xuXHRcdFx0Ly8gdGhpcyByZWdleCBpZ25vcmVzIEEtRiBiZWNhdXNlIGl0J3MgY29tcGFyZWQgYWdhaW5zdCBhbiBhbHJlYWR5IGxvd2VyY2FzZWQgc3RyaW5nXG5cdFx0XHRyZTogLyMoW2EtZjAtOV0pKFthLWYwLTldKShbYS1mMC05XSkvLFxuXHRcdFx0cGFyc2U6IGZ1bmN0aW9uKCBleGVjUmVzdWx0ICkge1xuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdHBhcnNlSW50KCBleGVjUmVzdWx0WyAxIF0gKyBleGVjUmVzdWx0WyAxIF0sIDE2ICksXG5cdFx0XHRcdFx0cGFyc2VJbnQoIGV4ZWNSZXN1bHRbIDIgXSArIGV4ZWNSZXN1bHRbIDIgXSwgMTYgKSxcblx0XHRcdFx0XHRwYXJzZUludCggZXhlY1Jlc3VsdFsgMyBdICsgZXhlY1Jlc3VsdFsgMyBdLCAxNiApXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0fSwge1xuXHRcdFx0cmU6IC9oc2xhP1xcKFxccyooXFxkKyg/OlxcLlxcZCspPylcXHMqLFxccyooXFxkKyg/OlxcLlxcZCspPylcXCVcXHMqLFxccyooXFxkKyg/OlxcLlxcZCspPylcXCVcXHMqKD86LFxccyooXFxkKyg/OlxcLlxcZCspPylcXHMqKT9cXCkvLFxuXHRcdFx0c3BhY2U6IFwiaHNsYVwiLFxuXHRcdFx0cGFyc2U6IGZ1bmN0aW9uKCBleGVjUmVzdWx0ICkge1xuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdGV4ZWNSZXN1bHRbIDEgXSxcblx0XHRcdFx0XHRleGVjUmVzdWx0WyAyIF0gLyAxMDAsXG5cdFx0XHRcdFx0ZXhlY1Jlc3VsdFsgMyBdIC8gMTAwLFxuXHRcdFx0XHRcdGV4ZWNSZXN1bHRbIDQgXVxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdH1dLFxuXG5cdC8vIGpRdWVyeS5Db2xvciggKVxuXHRjb2xvciA9IGpRdWVyeS5Db2xvciA9IGZ1bmN0aW9uKCBjb2xvciwgZ3JlZW4sIGJsdWUsIGFscGhhICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkNvbG9yLmZuLnBhcnNlKCBjb2xvciwgZ3JlZW4sIGJsdWUsIGFscGhhICk7XG5cdH0sXG5cdHNwYWNlcyA9IHtcblx0XHRyZ2JhOiB7XG5cdFx0XHRwcm9wczoge1xuXHRcdFx0XHRyZWQ6IHtcblx0XHRcdFx0XHRpZHg6IDAsXG5cdFx0XHRcdFx0dHlwZTogXCJieXRlXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0Z3JlZW46IHtcblx0XHRcdFx0XHRpZHg6IDEsXG5cdFx0XHRcdFx0dHlwZTogXCJieXRlXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0Ymx1ZToge1xuXHRcdFx0XHRcdGlkeDogMixcblx0XHRcdFx0XHR0eXBlOiBcImJ5dGVcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGhzbGE6IHtcblx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdGh1ZToge1xuXHRcdFx0XHRcdGlkeDogMCxcblx0XHRcdFx0XHR0eXBlOiBcImRlZ3JlZXNcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzYXR1cmF0aW9uOiB7XG5cdFx0XHRcdFx0aWR4OiAxLFxuXHRcdFx0XHRcdHR5cGU6IFwicGVyY2VudFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGxpZ2h0bmVzczoge1xuXHRcdFx0XHRcdGlkeDogMixcblx0XHRcdFx0XHR0eXBlOiBcInBlcmNlbnRcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRwcm9wVHlwZXMgPSB7XG5cdFx0XCJieXRlXCI6IHtcblx0XHRcdGZsb29yOiB0cnVlLFxuXHRcdFx0bWF4OiAyNTVcblx0XHR9LFxuXHRcdFwicGVyY2VudFwiOiB7XG5cdFx0XHRtYXg6IDFcblx0XHR9LFxuXHRcdFwiZGVncmVlc1wiOiB7XG5cdFx0XHRtb2Q6IDM2MCxcblx0XHRcdGZsb29yOiB0cnVlXG5cdFx0fVxuXHR9LFxuXHRzdXBwb3J0ID0gY29sb3Iuc3VwcG9ydCA9IHt9LFxuXG5cdC8vIGVsZW1lbnQgZm9yIHN1cHBvcnQgdGVzdHNcblx0c3VwcG9ydEVsZW0gPSBqUXVlcnkoIFwiPHA+XCIgKVsgMCBdLFxuXG5cdC8vIGNvbG9ycyA9IGpRdWVyeS5Db2xvci5uYW1lc1xuXHRjb2xvcnMsXG5cblx0Ly8gbG9jYWwgYWxpYXNlcyBvZiBmdW5jdGlvbnMgY2FsbGVkIG9mdGVuXG5cdGVhY2ggPSBqUXVlcnkuZWFjaDtcblxuLy8gZGV0ZXJtaW5lIHJnYmEgc3VwcG9ydCBpbW1lZGlhdGVseVxuc3VwcG9ydEVsZW0uc3R5bGUuY3NzVGV4dCA9IFwiYmFja2dyb3VuZC1jb2xvcjpyZ2JhKDEsMSwxLC41KVwiO1xuc3VwcG9ydC5yZ2JhID0gc3VwcG9ydEVsZW0uc3R5bGUuYmFja2dyb3VuZENvbG9yLmluZGV4T2YoIFwicmdiYVwiICkgPiAtMTtcblxuLy8gZGVmaW5lIGNhY2hlIG5hbWUgYW5kIGFscGhhIHByb3BlcnRpZXNcbi8vIGZvciByZ2JhIGFuZCBoc2xhIHNwYWNlc1xuZWFjaCggc3BhY2VzLCBmdW5jdGlvbiggc3BhY2VOYW1lLCBzcGFjZSApIHtcblx0c3BhY2UuY2FjaGUgPSBcIl9cIiArIHNwYWNlTmFtZTtcblx0c3BhY2UucHJvcHMuYWxwaGEgPSB7XG5cdFx0aWR4OiAzLFxuXHRcdHR5cGU6IFwicGVyY2VudFwiLFxuXHRcdGRlZjogMVxuXHR9O1xufSk7XG5cbmZ1bmN0aW9uIGNsYW1wKCB2YWx1ZSwgcHJvcCwgYWxsb3dFbXB0eSApIHtcblx0dmFyIHR5cGUgPSBwcm9wVHlwZXNbIHByb3AudHlwZSBdIHx8IHt9O1xuXG5cdGlmICggdmFsdWUgPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gKGFsbG93RW1wdHkgfHwgIXByb3AuZGVmKSA/IG51bGwgOiBwcm9wLmRlZjtcblx0fVxuXG5cdC8vIH5+IGlzIGFuIHNob3J0IHdheSBvZiBkb2luZyBmbG9vciBmb3IgcG9zaXRpdmUgbnVtYmVyc1xuXHR2YWx1ZSA9IHR5cGUuZmxvb3IgPyB+fnZhbHVlIDogcGFyc2VGbG9hdCggdmFsdWUgKTtcblxuXHQvLyBJRSB3aWxsIHBhc3MgaW4gZW1wdHkgc3RyaW5ncyBhcyB2YWx1ZSBmb3IgYWxwaGEsXG5cdC8vIHdoaWNoIHdpbGwgaGl0IHRoaXMgY2FzZVxuXHRpZiAoIGlzTmFOKCB2YWx1ZSApICkge1xuXHRcdHJldHVybiBwcm9wLmRlZjtcblx0fVxuXG5cdGlmICggdHlwZS5tb2QgKSB7XG5cdFx0Ly8gd2UgYWRkIG1vZCBiZWZvcmUgbW9kZGluZyB0byBtYWtlIHN1cmUgdGhhdCBuZWdhdGl2ZXMgdmFsdWVzXG5cdFx0Ly8gZ2V0IGNvbnZlcnRlZCBwcm9wZXJseTogLTEwIC0+IDM1MFxuXHRcdHJldHVybiAodmFsdWUgKyB0eXBlLm1vZCkgJSB0eXBlLm1vZDtcblx0fVxuXG5cdC8vIGZvciBub3cgYWxsIHByb3BlcnR5IHR5cGVzIHdpdGhvdXQgbW9kIGhhdmUgbWluIGFuZCBtYXhcblx0cmV0dXJuIDAgPiB2YWx1ZSA/IDAgOiB0eXBlLm1heCA8IHZhbHVlID8gdHlwZS5tYXggOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nUGFyc2UoIHN0cmluZyApIHtcblx0dmFyIGluc3QgPSBjb2xvcigpLFxuXHRcdHJnYmEgPSBpbnN0Ll9yZ2JhID0gW107XG5cblx0c3RyaW5nID0gc3RyaW5nLnRvTG93ZXJDYXNlKCk7XG5cblx0ZWFjaCggc3RyaW5nUGFyc2VycywgZnVuY3Rpb24oIGksIHBhcnNlciApIHtcblx0XHR2YXIgcGFyc2VkLFxuXHRcdFx0bWF0Y2ggPSBwYXJzZXIucmUuZXhlYyggc3RyaW5nICksXG5cdFx0XHR2YWx1ZXMgPSBtYXRjaCAmJiBwYXJzZXIucGFyc2UoIG1hdGNoICksXG5cdFx0XHRzcGFjZU5hbWUgPSBwYXJzZXIuc3BhY2UgfHwgXCJyZ2JhXCI7XG5cblx0XHRpZiAoIHZhbHVlcyApIHtcblx0XHRcdHBhcnNlZCA9IGluc3RbIHNwYWNlTmFtZSBdKCB2YWx1ZXMgKTtcblxuXHRcdFx0Ly8gaWYgdGhpcyB3YXMgYW4gcmdiYSBwYXJzZSB0aGUgYXNzaWdubWVudCBtaWdodCBoYXBwZW4gdHdpY2Vcblx0XHRcdC8vIG9oIHdlbGwuLi4uXG5cdFx0XHRpbnN0WyBzcGFjZXNbIHNwYWNlTmFtZSBdLmNhY2hlIF0gPSBwYXJzZWRbIHNwYWNlc1sgc3BhY2VOYW1lIF0uY2FjaGUgXTtcblx0XHRcdHJnYmEgPSBpbnN0Ll9yZ2JhID0gcGFyc2VkLl9yZ2JhO1xuXG5cdFx0XHQvLyBleGl0IGVhY2goIHN0cmluZ1BhcnNlcnMgKSBoZXJlIGJlY2F1c2Ugd2UgbWF0Y2hlZFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gRm91bmQgYSBzdHJpbmdQYXJzZXIgdGhhdCBoYW5kbGVkIGl0XG5cdGlmICggcmdiYS5sZW5ndGggKSB7XG5cblx0XHQvLyBpZiB0aGlzIGNhbWUgZnJvbSBhIHBhcnNlZCBzdHJpbmcsIGZvcmNlIFwidHJhbnNwYXJlbnRcIiB3aGVuIGFscGhhIGlzIDBcblx0XHQvLyBjaHJvbWUsIChhbmQgbWF5YmUgb3RoZXJzKSByZXR1cm4gXCJ0cmFuc3BhcmVudFwiIGFzIHJnYmEoMCwwLDAsMClcblx0XHRpZiAoIHJnYmEuam9pbigpID09PSBcIjAsMCwwLDBcIiApIHtcblx0XHRcdGpRdWVyeS5leHRlbmQoIHJnYmEsIGNvbG9ycy50cmFuc3BhcmVudCApO1xuXHRcdH1cblx0XHRyZXR1cm4gaW5zdDtcblx0fVxuXG5cdC8vIG5hbWVkIGNvbG9yc1xuXHRyZXR1cm4gY29sb3JzWyBzdHJpbmcgXTtcbn1cblxuY29sb3IuZm4gPSBqUXVlcnkuZXh0ZW5kKCBjb2xvci5wcm90b3R5cGUsIHtcblx0cGFyc2U6IGZ1bmN0aW9uKCByZWQsIGdyZWVuLCBibHVlLCBhbHBoYSApIHtcblx0XHRpZiAoIHJlZCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5fcmdiYSA9IFsgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCBdO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggcmVkLmpxdWVyeSB8fCByZWQubm9kZVR5cGUgKSB7XG5cdFx0XHRyZWQgPSBqUXVlcnkoIHJlZCApLmNzcyggZ3JlZW4gKTtcblx0XHRcdGdyZWVuID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdHZhciBpbnN0ID0gdGhpcyxcblx0XHRcdHR5cGUgPSBqUXVlcnkudHlwZSggcmVkICksXG5cdFx0XHRyZ2JhID0gdGhpcy5fcmdiYSA9IFtdO1xuXG5cdFx0Ly8gbW9yZSB0aGFuIDEgYXJndW1lbnQgc3BlY2lmaWVkIC0gYXNzdW1lICggcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEgKVxuXHRcdGlmICggZ3JlZW4gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJlZCA9IFsgcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEgXTtcblx0XHRcdHR5cGUgPSBcImFycmF5XCI7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucGFyc2UoIHN0cmluZ1BhcnNlKCByZWQgKSB8fCBjb2xvcnMuX2RlZmF1bHQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUgPT09IFwiYXJyYXlcIiApIHtcblx0XHRcdGVhY2goIHNwYWNlcy5yZ2JhLnByb3BzLCBmdW5jdGlvbigga2V5LCBwcm9wICkge1xuXHRcdFx0XHRyZ2JhWyBwcm9wLmlkeCBdID0gY2xhbXAoIHJlZFsgcHJvcC5pZHggXSwgcHJvcCApO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRpZiAoIHJlZCBpbnN0YW5jZW9mIGNvbG9yICkge1xuXHRcdFx0XHRlYWNoKCBzcGFjZXMsIGZ1bmN0aW9uKCBzcGFjZU5hbWUsIHNwYWNlICkge1xuXHRcdFx0XHRcdGlmICggcmVkWyBzcGFjZS5jYWNoZSBdICkge1xuXHRcdFx0XHRcdFx0aW5zdFsgc3BhY2UuY2FjaGUgXSA9IHJlZFsgc3BhY2UuY2FjaGUgXS5zbGljZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlYWNoKCBzcGFjZXMsIGZ1bmN0aW9uKCBzcGFjZU5hbWUsIHNwYWNlICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSA9IHNwYWNlLmNhY2hlO1xuXHRcdFx0XHRcdGVhY2goIHNwYWNlLnByb3BzLCBmdW5jdGlvbigga2V5LCBwcm9wICkge1xuXG5cdFx0XHRcdFx0XHQvLyBpZiB0aGUgY2FjaGUgZG9lc24ndCBleGlzdCwgYW5kIHdlIGtub3cgaG93IHRvIGNvbnZlcnRcblx0XHRcdFx0XHRcdGlmICggIWluc3RbIGNhY2hlIF0gJiYgc3BhY2UudG8gKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIHZhbHVlIHdhcyBudWxsLCB3ZSBkb24ndCBuZWVkIHRvIGNvcHkgaXRcblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGtleSB3YXMgYWxwaGEsIHdlIGRvbid0IG5lZWQgdG8gY29weSBpdCBlaXRoZXJcblx0XHRcdFx0XHRcdFx0aWYgKCBrZXkgPT09IFwiYWxwaGFcIiB8fCByZWRbIGtleSBdID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGluc3RbIGNhY2hlIF0gPSBzcGFjZS50byggaW5zdC5fcmdiYSApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyB0aGlzIGlzIHRoZSBvbmx5IGNhc2Ugd2hlcmUgd2UgYWxsb3cgbnVsbHMgZm9yIEFMTCBwcm9wZXJ0aWVzLlxuXHRcdFx0XHRcdFx0Ly8gY2FsbCBjbGFtcCB3aXRoIGFsd2F5c0FsbG93RW1wdHlcblx0XHRcdFx0XHRcdGluc3RbIGNhY2hlIF1bIHByb3AuaWR4IF0gPSBjbGFtcCggcmVkWyBrZXkgXSwgcHJvcCwgdHJ1ZSApO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0Ly8gZXZlcnl0aGluZyBkZWZpbmVkIGJ1dCBhbHBoYT9cblx0XHRcdFx0XHRpZiAoIGluc3RbIGNhY2hlIF0gJiYgJC5pbkFycmF5KCBudWxsLCBpbnN0WyBjYWNoZSBdLnNsaWNlKCAwLCAzICkgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHQvLyB1c2UgdGhlIGRlZmF1bHQgb2YgMVxuXHRcdFx0XHRcdFx0aW5zdFsgY2FjaGUgXVsgMyBdID0gMTtcblx0XHRcdFx0XHRcdGlmICggc3BhY2UuZnJvbSApIHtcblx0XHRcdFx0XHRcdFx0aW5zdC5fcmdiYSA9IHNwYWNlLmZyb20oIGluc3RbIGNhY2hlIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHR9LFxuXHRpczogZnVuY3Rpb24oIGNvbXBhcmUgKSB7XG5cdFx0dmFyIGlzID0gY29sb3IoIGNvbXBhcmUgKSxcblx0XHRcdHNhbWUgPSB0cnVlLFxuXHRcdFx0aW5zdCA9IHRoaXM7XG5cblx0XHRlYWNoKCBzcGFjZXMsIGZ1bmN0aW9uKCBfLCBzcGFjZSApIHtcblx0XHRcdHZhciBsb2NhbENhY2hlLFxuXHRcdFx0XHRpc0NhY2hlID0gaXNbIHNwYWNlLmNhY2hlIF07XG5cdFx0XHRpZiAoaXNDYWNoZSkge1xuXHRcdFx0XHRsb2NhbENhY2hlID0gaW5zdFsgc3BhY2UuY2FjaGUgXSB8fCBzcGFjZS50byAmJiBzcGFjZS50byggaW5zdC5fcmdiYSApIHx8IFtdO1xuXHRcdFx0XHRlYWNoKCBzcGFjZS5wcm9wcywgZnVuY3Rpb24oIF8sIHByb3AgKSB7XG5cdFx0XHRcdFx0aWYgKCBpc0NhY2hlWyBwcm9wLmlkeCBdICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzYW1lID0gKCBpc0NhY2hlWyBwcm9wLmlkeCBdID09PSBsb2NhbENhY2hlWyBwcm9wLmlkeCBdICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc2FtZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNhbWU7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHNhbWU7XG5cdH0sXG5cdF9zcGFjZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHVzZWQgPSBbXSxcblx0XHRcdGluc3QgPSB0aGlzO1xuXHRcdGVhY2goIHNwYWNlcywgZnVuY3Rpb24oIHNwYWNlTmFtZSwgc3BhY2UgKSB7XG5cdFx0XHRpZiAoIGluc3RbIHNwYWNlLmNhY2hlIF0gKSB7XG5cdFx0XHRcdHVzZWQucHVzaCggc3BhY2VOYW1lICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHVzZWQucG9wKCk7XG5cdH0sXG5cdHRyYW5zaXRpb246IGZ1bmN0aW9uKCBvdGhlciwgZGlzdGFuY2UgKSB7XG5cdFx0dmFyIGVuZCA9IGNvbG9yKCBvdGhlciApLFxuXHRcdFx0c3BhY2VOYW1lID0gZW5kLl9zcGFjZSgpLFxuXHRcdFx0c3BhY2UgPSBzcGFjZXNbIHNwYWNlTmFtZSBdLFxuXHRcdFx0c3RhcnRDb2xvciA9IHRoaXMuYWxwaGEoKSA9PT0gMCA/IGNvbG9yKCBcInRyYW5zcGFyZW50XCIgKSA6IHRoaXMsXG5cdFx0XHRzdGFydCA9IHN0YXJ0Q29sb3JbIHNwYWNlLmNhY2hlIF0gfHwgc3BhY2UudG8oIHN0YXJ0Q29sb3IuX3JnYmEgKSxcblx0XHRcdHJlc3VsdCA9IHN0YXJ0LnNsaWNlKCk7XG5cblx0XHRlbmQgPSBlbmRbIHNwYWNlLmNhY2hlIF07XG5cdFx0ZWFjaCggc3BhY2UucHJvcHMsIGZ1bmN0aW9uKCBrZXksIHByb3AgKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBwcm9wLmlkeCxcblx0XHRcdFx0c3RhcnRWYWx1ZSA9IHN0YXJ0WyBpbmRleCBdLFxuXHRcdFx0XHRlbmRWYWx1ZSA9IGVuZFsgaW5kZXggXSxcblx0XHRcdFx0dHlwZSA9IHByb3BUeXBlc1sgcHJvcC50eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGlmIG51bGwsIGRvbid0IG92ZXJyaWRlIHN0YXJ0IHZhbHVlXG5cdFx0XHRpZiAoIGVuZFZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiBudWxsIC0gdXNlIGVuZFxuXHRcdFx0aWYgKCBzdGFydFZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRyZXN1bHRbIGluZGV4IF0gPSBlbmRWYWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggdHlwZS5tb2QgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUgPiB0eXBlLm1vZCAvIDIgKSB7XG5cdFx0XHRcdFx0XHRzdGFydFZhbHVlICs9IHR5cGUubW9kO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXJ0VmFsdWUgLSBlbmRWYWx1ZSA+IHR5cGUubW9kIC8gMiApIHtcblx0XHRcdFx0XHRcdHN0YXJ0VmFsdWUgLT0gdHlwZS5tb2Q7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJlc3VsdFsgaW5kZXggXSA9IGNsYW1wKCAoIGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSApICogZGlzdGFuY2UgKyBzdGFydFZhbHVlLCBwcm9wICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRoaXNbIHNwYWNlTmFtZSBdKCByZXN1bHQgKTtcblx0fSxcblx0YmxlbmQ6IGZ1bmN0aW9uKCBvcGFxdWUgKSB7XG5cdFx0Ly8gaWYgd2UgYXJlIGFscmVhZHkgb3BhcXVlIC0gcmV0dXJuIG91cnNlbGZcblx0XHRpZiAoIHRoaXMuX3JnYmFbIDMgXSA9PT0gMSApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHZhciByZ2IgPSB0aGlzLl9yZ2JhLnNsaWNlKCksXG5cdFx0XHRhID0gcmdiLnBvcCgpLFxuXHRcdFx0YmxlbmQgPSBjb2xvciggb3BhcXVlICkuX3JnYmE7XG5cblx0XHRyZXR1cm4gY29sb3IoIGpRdWVyeS5tYXAoIHJnYiwgZnVuY3Rpb24oIHYsIGkgKSB7XG5cdFx0XHRyZXR1cm4gKCAxIC0gYSApICogYmxlbmRbIGkgXSArIGEgKiB2O1xuXHRcdH0pKTtcblx0fSxcblx0dG9SZ2JhU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcHJlZml4ID0gXCJyZ2JhKFwiLFxuXHRcdFx0cmdiYSA9IGpRdWVyeS5tYXAoIHRoaXMuX3JnYmEsIGZ1bmN0aW9uKCB2LCBpICkge1xuXHRcdFx0XHRyZXR1cm4gdiA9PSBudWxsID8gKCBpID4gMiA/IDEgOiAwICkgOiB2O1xuXHRcdFx0fSk7XG5cblx0XHRpZiAoIHJnYmFbIDMgXSA9PT0gMSApIHtcblx0XHRcdHJnYmEucG9wKCk7XG5cdFx0XHRwcmVmaXggPSBcInJnYihcIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gcHJlZml4ICsgcmdiYS5qb2luKCkgKyBcIilcIjtcblx0fSxcblx0dG9Ic2xhU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcHJlZml4ID0gXCJoc2xhKFwiLFxuXHRcdFx0aHNsYSA9IGpRdWVyeS5tYXAoIHRoaXMuaHNsYSgpLCBmdW5jdGlvbiggdiwgaSApIHtcblx0XHRcdFx0aWYgKCB2ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0diA9IGkgPiAyID8gMSA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjYXRjaCAxIGFuZCAyXG5cdFx0XHRcdGlmICggaSAmJiBpIDwgMyApIHtcblx0XHRcdFx0XHR2ID0gTWF0aC5yb3VuZCggdiAqIDEwMCApICsgXCIlXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHY7XG5cdFx0XHR9KTtcblxuXHRcdGlmICggaHNsYVsgMyBdID09PSAxICkge1xuXHRcdFx0aHNsYS5wb3AoKTtcblx0XHRcdHByZWZpeCA9IFwiaHNsKFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gcHJlZml4ICsgaHNsYS5qb2luKCkgKyBcIilcIjtcblx0fSxcblx0dG9IZXhTdHJpbmc6IGZ1bmN0aW9uKCBpbmNsdWRlQWxwaGEgKSB7XG5cdFx0dmFyIHJnYmEgPSB0aGlzLl9yZ2JhLnNsaWNlKCksXG5cdFx0XHRhbHBoYSA9IHJnYmEucG9wKCk7XG5cblx0XHRpZiAoIGluY2x1ZGVBbHBoYSApIHtcblx0XHRcdHJnYmEucHVzaCggfn4oIGFscGhhICogMjU1ICkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gXCIjXCIgKyBqUXVlcnkubWFwKCByZ2JhLCBmdW5jdGlvbiggdiApIHtcblxuXHRcdFx0Ly8gZGVmYXVsdCB0byAwIHdoZW4gbnVsbHMgZXhpc3Rcblx0XHRcdHYgPSAoIHYgfHwgMCApLnRvU3RyaW5nKCAxNiApO1xuXHRcdFx0cmV0dXJuIHYubGVuZ3RoID09PSAxID8gXCIwXCIgKyB2IDogdjtcblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9LFxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JnYmFbIDMgXSA9PT0gMCA/IFwidHJhbnNwYXJlbnRcIiA6IHRoaXMudG9SZ2JhU3RyaW5nKCk7XG5cdH1cbn0pO1xuY29sb3IuZm4ucGFyc2UucHJvdG90eXBlID0gY29sb3IuZm47XG5cbi8vIGhzbGEgY29udmVyc2lvbnMgYWRhcHRlZCBmcm9tOlxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9tYWFzaGFhY2svc291cmNlL2Jyb3dzZS9wYWNrYWdlcy9ncmFwaGljcy90cnVuay9zcmMvZ3JhcGhpY3MvY29sb3JzL0hVRTJSR0IuYXM/cj01MDIxXG5cbmZ1bmN0aW9uIGh1ZTJyZ2IoIHAsIHEsIGggKSB7XG5cdGggPSAoIGggKyAxICkgJSAxO1xuXHRpZiAoIGggKiA2IDwgMSApIHtcblx0XHRyZXR1cm4gcCArIChxIC0gcCkgKiBoICogNjtcblx0fVxuXHRpZiAoIGggKiAyIDwgMSkge1xuXHRcdHJldHVybiBxO1xuXHR9XG5cdGlmICggaCAqIDMgPCAyICkge1xuXHRcdHJldHVybiBwICsgKHEgLSBwKSAqICgoMi8zKSAtIGgpICogNjtcblx0fVxuXHRyZXR1cm4gcDtcbn1cblxuc3BhY2VzLmhzbGEudG8gPSBmdW5jdGlvbiAoIHJnYmEgKSB7XG5cdGlmICggcmdiYVsgMCBdID09IG51bGwgfHwgcmdiYVsgMSBdID09IG51bGwgfHwgcmdiYVsgMiBdID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIFsgbnVsbCwgbnVsbCwgbnVsbCwgcmdiYVsgMyBdIF07XG5cdH1cblx0dmFyIHIgPSByZ2JhWyAwIF0gLyAyNTUsXG5cdFx0ZyA9IHJnYmFbIDEgXSAvIDI1NSxcblx0XHRiID0gcmdiYVsgMiBdIC8gMjU1LFxuXHRcdGEgPSByZ2JhWyAzIF0sXG5cdFx0bWF4ID0gTWF0aC5tYXgoIHIsIGcsIGIgKSxcblx0XHRtaW4gPSBNYXRoLm1pbiggciwgZywgYiApLFxuXHRcdGRpZmYgPSBtYXggLSBtaW4sXG5cdFx0YWRkID0gbWF4ICsgbWluLFxuXHRcdGwgPSBhZGQgKiAwLjUsXG5cdFx0aCwgcztcblxuXHRpZiAoIG1pbiA9PT0gbWF4ICkge1xuXHRcdGggPSAwO1xuXHR9IGVsc2UgaWYgKCByID09PSBtYXggKSB7XG5cdFx0aCA9ICggNjAgKiAoIGcgLSBiICkgLyBkaWZmICkgKyAzNjA7XG5cdH0gZWxzZSBpZiAoIGcgPT09IG1heCApIHtcblx0XHRoID0gKCA2MCAqICggYiAtIHIgKSAvIGRpZmYgKSArIDEyMDtcblx0fSBlbHNlIHtcblx0XHRoID0gKCA2MCAqICggciAtIGcgKSAvIGRpZmYgKSArIDI0MDtcblx0fVxuXG5cdGlmICggbCA9PT0gMCB8fCBsID09PSAxICkge1xuXHRcdHMgPSBsO1xuXHR9IGVsc2UgaWYgKCBsIDw9IDAuNSApIHtcblx0XHRzID0gZGlmZiAvIGFkZDtcblx0fSBlbHNlIHtcblx0XHRzID0gZGlmZiAvICggMiAtIGFkZCApO1xuXHR9XG5cdHJldHVybiBbIE1hdGgucm91bmQoaCkgJSAzNjAsIHMsIGwsIGEgPT0gbnVsbCA/IDEgOiBhIF07XG59O1xuXG5zcGFjZXMuaHNsYS5mcm9tID0gZnVuY3Rpb24gKCBoc2xhICkge1xuXHRpZiAoIGhzbGFbIDAgXSA9PSBudWxsIHx8IGhzbGFbIDEgXSA9PSBudWxsIHx8IGhzbGFbIDIgXSA9PSBudWxsICkge1xuXHRcdHJldHVybiBbIG51bGwsIG51bGwsIG51bGwsIGhzbGFbIDMgXSBdO1xuXHR9XG5cdHZhciBoID0gaHNsYVsgMCBdIC8gMzYwLFxuXHRcdHMgPSBoc2xhWyAxIF0sXG5cdFx0bCA9IGhzbGFbIDIgXSxcblx0XHRhID0gaHNsYVsgMyBdLFxuXHRcdHEgPSBsIDw9IDAuNSA/IGwgKiAoIDEgKyBzICkgOiBsICsgcyAtIGwgKiBzLFxuXHRcdHAgPSAyICogbCAtIHE7XG5cblx0cmV0dXJuIFtcblx0XHRNYXRoLnJvdW5kKCBodWUycmdiKCBwLCBxLCBoICsgKCAxIC8gMyApICkgKiAyNTUgKSxcblx0XHRNYXRoLnJvdW5kKCBodWUycmdiKCBwLCBxLCBoICkgKiAyNTUgKSxcblx0XHRNYXRoLnJvdW5kKCBodWUycmdiKCBwLCBxLCBoIC0gKCAxIC8gMyApICkgKiAyNTUgKSxcblx0XHRhXG5cdF07XG59O1xuXG5cbmVhY2goIHNwYWNlcywgZnVuY3Rpb24oIHNwYWNlTmFtZSwgc3BhY2UgKSB7XG5cdHZhciBwcm9wcyA9IHNwYWNlLnByb3BzLFxuXHRcdGNhY2hlID0gc3BhY2UuY2FjaGUsXG5cdFx0dG8gPSBzcGFjZS50byxcblx0XHRmcm9tID0gc3BhY2UuZnJvbTtcblxuXHQvLyBtYWtlcyByZ2JhKCkgYW5kIGhzbGEoKVxuXHRjb2xvci5mblsgc3BhY2VOYW1lIF0gPSBmdW5jdGlvbiggdmFsdWUgKSB7XG5cblx0XHQvLyBnZW5lcmF0ZSBhIGNhY2hlIGZvciB0aGlzIHNwYWNlIGlmIGl0IGRvZXNuJ3QgZXhpc3Rcblx0XHRpZiAoIHRvICYmICF0aGlzWyBjYWNoZSBdICkge1xuXHRcdFx0dGhpc1sgY2FjaGUgXSA9IHRvKCB0aGlzLl9yZ2JhICk7XG5cdFx0fVxuXHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiB0aGlzWyBjYWNoZSBdLnNsaWNlKCk7XG5cdFx0fVxuXG5cdFx0dmFyIHJldCxcblx0XHRcdHR5cGUgPSBqUXVlcnkudHlwZSggdmFsdWUgKSxcblx0XHRcdGFyciA9ICggdHlwZSA9PT0gXCJhcnJheVwiIHx8IHR5cGUgPT09IFwib2JqZWN0XCIgKSA/IHZhbHVlIDogYXJndW1lbnRzLFxuXHRcdFx0bG9jYWwgPSB0aGlzWyBjYWNoZSBdLnNsaWNlKCk7XG5cblx0XHRlYWNoKCBwcm9wcywgZnVuY3Rpb24oIGtleSwgcHJvcCApIHtcblx0XHRcdHZhciB2YWwgPSBhcnJbIHR5cGUgPT09IFwib2JqZWN0XCIgPyBrZXkgOiBwcm9wLmlkeCBdO1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gbG9jYWxbIHByb3AuaWR4IF07XG5cdFx0XHR9XG5cdFx0XHRsb2NhbFsgcHJvcC5pZHggXSA9IGNsYW1wKCB2YWwsIHByb3AgKTtcblx0XHR9KTtcblxuXHRcdGlmICggZnJvbSApIHtcblx0XHRcdHJldCA9IGNvbG9yKCBmcm9tKCBsb2NhbCApICk7XG5cdFx0XHRyZXRbIGNhY2hlIF0gPSBsb2NhbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBjb2xvciggbG9jYWwgKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gbWFrZXMgcmVkKCkgZ3JlZW4oKSBibHVlKCkgYWxwaGEoKSBodWUoKSBzYXR1cmF0aW9uKCkgbGlnaHRuZXNzKClcblx0ZWFjaCggcHJvcHMsIGZ1bmN0aW9uKCBrZXksIHByb3AgKSB7XG5cdFx0Ly8gYWxwaGEgaXMgaW5jbHVkZWQgaW4gbW9yZSB0aGFuIG9uZSBzcGFjZVxuXHRcdGlmICggY29sb3IuZm5bIGtleSBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRjb2xvci5mblsga2V5IF0gPSBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgdnR5cGUgPSBqUXVlcnkudHlwZSggdmFsdWUgKSxcblx0XHRcdFx0Zm4gPSAoIGtleSA9PT0gXCJhbHBoYVwiID8gKCB0aGlzLl9oc2xhID8gXCJoc2xhXCIgOiBcInJnYmFcIiApIDogc3BhY2VOYW1lICksXG5cdFx0XHRcdGxvY2FsID0gdGhpc1sgZm4gXSgpLFxuXHRcdFx0XHRjdXIgPSBsb2NhbFsgcHJvcC5pZHggXSxcblx0XHRcdFx0bWF0Y2g7XG5cblx0XHRcdGlmICggdnR5cGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdnR5cGUgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5jYWxsKCB0aGlzLCBjdXIgKTtcblx0XHRcdFx0dnR5cGUgPSBqUXVlcnkudHlwZSggdmFsdWUgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCAmJiBwcm9wLmVtcHR5ICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHRcdGlmICggdnR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdG1hdGNoID0gcnBsdXNlcXVhbHMuZXhlYyggdmFsdWUgKTtcblx0XHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGN1ciArIHBhcnNlRmxvYXQoIG1hdGNoWyAyIF0gKSAqICggbWF0Y2hbIDEgXSA9PT0gXCIrXCIgPyAxIDogLTEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bG9jYWxbIHByb3AuaWR4IF0gPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzWyBmbiBdKCBsb2NhbCApO1xuXHRcdH07XG5cdH0pO1xufSk7XG5cbi8vIGFkZCAuZnguc3RlcCBmdW5jdGlvbnNcbmVhY2goIHN0ZXBIb29rcywgZnVuY3Rpb24oIGksIGhvb2sgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgaG9vayBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0dmFyIHBhcnNlZCwgY3VyRWxlbSxcblx0XHRcdFx0YmFja2dyb3VuZENvbG9yID0gXCJcIjtcblxuXHRcdFx0aWYgKCBqUXVlcnkudHlwZSggdmFsdWUgKSAhPT0gXCJzdHJpbmdcIiB8fCAoIHBhcnNlZCA9IHN0cmluZ1BhcnNlKCB2YWx1ZSApICkgKSB7XG5cdFx0XHRcdHZhbHVlID0gY29sb3IoIHBhcnNlZCB8fCB2YWx1ZSApO1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJnYmEgJiYgdmFsdWUuX3JnYmFbIDMgXSAhPT0gMSApIHtcblx0XHRcdFx0XHRjdXJFbGVtID0gaG9vayA9PT0gXCJiYWNrZ3JvdW5kQ29sb3JcIiA/IGVsZW0ucGFyZW50Tm9kZSA6IGVsZW07XG5cdFx0XHRcdFx0d2hpbGUgKFxuXHRcdFx0XHRcdFx0KGJhY2tncm91bmRDb2xvciA9PT0gXCJcIiB8fCBiYWNrZ3JvdW5kQ29sb3IgPT09IFwidHJhbnNwYXJlbnRcIikgJiZcblx0XHRcdFx0XHRcdGN1ckVsZW0gJiYgY3VyRWxlbS5zdHlsZVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yID0galF1ZXJ5LmNzcyggY3VyRWxlbSwgXCJiYWNrZ3JvdW5kQ29sb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRjdXJFbGVtID0gY3VyRWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5ibGVuZCggYmFja2dyb3VuZENvbG9yICYmIGJhY2tncm91bmRDb2xvciAhPT0gXCJ0cmFuc3BhcmVudFwiID9cblx0XHRcdFx0XHRcdGJhY2tncm91bmRDb2xvciA6XG5cdFx0XHRcdFx0XHRcIl9kZWZhdWx0XCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhbHVlID0gdmFsdWUudG9SZ2JhU3RyaW5nKCk7XG5cdFx0XHR9XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRlbGVtLnN0eWxlWyBob29rIF0gPSB2YWx1ZTtcblx0XHRcdH0gY2F0Y2goIGVycm9yICkge1xuXHRcdFx0XHQvLyB3cmFwcGVkIHRvIHByZXZlbnQgSUUgZnJvbSB0aHJvd2luZyBlcnJvcnMgb24gXCJpbnZhbGlkXCIgdmFsdWVzIGxpa2UgJ2F1dG8nIG9yICdpbmhlcml0J1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0alF1ZXJ5LmZ4LnN0ZXBbIGhvb2sgXSA9IGZ1bmN0aW9uKCBmeCApIHtcblx0XHRpZiAoICFmeC5jb2xvckluaXQgKSB7XG5cdFx0XHRmeC5zdGFydCA9IGNvbG9yKCBmeC5lbGVtLCBob29rICk7XG5cdFx0XHRmeC5lbmQgPSBjb2xvciggZnguZW5kICk7XG5cdFx0XHRmeC5jb2xvckluaXQgPSB0cnVlO1xuXHRcdH1cblx0XHRqUXVlcnkuY3NzSG9va3NbIGhvb2sgXS5zZXQoIGZ4LmVsZW0sIGZ4LnN0YXJ0LnRyYW5zaXRpb24oIGZ4LmVuZCwgZngucG9zICkgKTtcblx0fTtcbn0pO1xuXG5qUXVlcnkuY3NzSG9va3MuYm9yZGVyQ29sb3IgPSB7XG5cdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBleHBhbmRlZCA9IHt9O1xuXG5cdFx0ZWFjaCggWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwYXJ0ICkge1xuXHRcdFx0ZXhwYW5kZWRbIFwiYm9yZGVyXCIgKyBwYXJ0ICsgXCJDb2xvclwiIF0gPSB2YWx1ZTtcblx0XHR9KTtcblx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdH1cbn07XG5cbi8vIEJhc2ljIGNvbG9yIG5hbWVzIG9ubHkuXG4vLyBVc2FnZSBvZiBhbnkgb2YgdGhlIG90aGVyIGNvbG9yIG5hbWVzIHJlcXVpcmVzIGFkZGluZyB5b3Vyc2VsZiBvciBpbmNsdWRpbmdcbi8vIGpxdWVyeS5jb2xvci5zdmctbmFtZXMuanMuXG5jb2xvcnMgPSBqUXVlcnkuQ29sb3IubmFtZXMgPSB7XG5cdC8vIDQuMS4gQmFzaWMgY29sb3Iga2V5d29yZHNcblx0YXF1YTogXCIjMDBmZmZmXCIsXG5cdGJsYWNrOiBcIiMwMDAwMDBcIixcblx0Ymx1ZTogXCIjMDAwMGZmXCIsXG5cdGZ1Y2hzaWE6IFwiI2ZmMDBmZlwiLFxuXHRncmF5OiBcIiM4MDgwODBcIixcblx0Z3JlZW46IFwiIzAwODAwMFwiLFxuXHRsaW1lOiBcIiMwMGZmMDBcIixcblx0bWFyb29uOiBcIiM4MDAwMDBcIixcblx0bmF2eTogXCIjMDAwMDgwXCIsXG5cdG9saXZlOiBcIiM4MDgwMDBcIixcblx0cHVycGxlOiBcIiM4MDAwODBcIixcblx0cmVkOiBcIiNmZjAwMDBcIixcblx0c2lsdmVyOiBcIiNjMGMwYzBcIixcblx0dGVhbDogXCIjMDA4MDgwXCIsXG5cdHdoaXRlOiBcIiNmZmZmZmZcIixcblx0eWVsbG93OiBcIiNmZmZmMDBcIixcblxuXHQvLyA0LjIuMy4gXCJ0cmFuc3BhcmVudFwiIGNvbG9yIGtleXdvcmRcblx0dHJhbnNwYXJlbnQ6IFsgbnVsbCwgbnVsbCwgbnVsbCwgMCBdLFxuXG5cdF9kZWZhdWx0OiBcIiNmZmZmZmZcIlxufTtcblxufSkoIGpRdWVyeSApO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogQ0xBU1MgQU5JTUFUSU9OUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuKGZ1bmN0aW9uKCkge1xuXG52YXIgY2xhc3NBbmltYXRpb25BY3Rpb25zID0gWyBcImFkZFwiLCBcInJlbW92ZVwiLCBcInRvZ2dsZVwiIF0sXG5cdHNob3J0aGFuZFN0eWxlcyA9IHtcblx0XHRib3JkZXI6IDEsXG5cdFx0Ym9yZGVyQm90dG9tOiAxLFxuXHRcdGJvcmRlckNvbG9yOiAxLFxuXHRcdGJvcmRlckxlZnQ6IDEsXG5cdFx0Ym9yZGVyUmlnaHQ6IDEsXG5cdFx0Ym9yZGVyVG9wOiAxLFxuXHRcdGJvcmRlcldpZHRoOiAxLFxuXHRcdG1hcmdpbjogMSxcblx0XHRwYWRkaW5nOiAxXG5cdH07XG5cbiQuZWFjaChbIFwiYm9yZGVyTGVmdFN0eWxlXCIsIFwiYm9yZGVyUmlnaHRTdHlsZVwiLCBcImJvcmRlckJvdHRvbVN0eWxlXCIsIFwiYm9yZGVyVG9wU3R5bGVcIiBdLCBmdW5jdGlvbiggXywgcHJvcCApIHtcblx0JC5meC5zdGVwWyBwcm9wIF0gPSBmdW5jdGlvbiggZnggKSB7XG5cdFx0aWYgKCBmeC5lbmQgIT09IFwibm9uZVwiICYmICFmeC5zZXRBdHRyIHx8IGZ4LnBvcyA9PT0gMSAmJiAhZnguc2V0QXR0ciApIHtcblx0XHRcdGpRdWVyeS5zdHlsZSggZnguZWxlbSwgcHJvcCwgZnguZW5kICk7XG5cdFx0XHRmeC5zZXRBdHRyID0gdHJ1ZTtcblx0XHR9XG5cdH07XG59KTtcblxuZnVuY3Rpb24gZ2V0RWxlbWVudFN0eWxlcygpIHtcblx0dmFyIHN0eWxlID0gdGhpcy5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3ID9cblx0XHRcdHRoaXMub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKCB0aGlzLCBudWxsICkgOlxuXHRcdFx0dGhpcy5jdXJyZW50U3R5bGUsXG5cdFx0bmV3U3R5bGUgPSB7fSxcblx0XHRrZXksXG5cdFx0bGVuO1xuXG5cdC8vIHdlYmtpdCBlbnVtZXJhdGVzIHN0eWxlIHBvcnBlcnRpZXNcblx0aWYgKCBzdHlsZSAmJiBzdHlsZS5sZW5ndGggJiYgc3R5bGVbIDAgXSAmJiBzdHlsZVsgc3R5bGVbIDAgXSBdICkge1xuXHRcdGxlbiA9IHN0eWxlLmxlbmd0aDtcblx0XHR3aGlsZSAoIGxlbi0tICkge1xuXHRcdFx0a2V5ID0gc3R5bGVbIGxlbiBdO1xuXHRcdFx0aWYgKCB0eXBlb2Ygc3R5bGVbIGtleSBdID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRuZXdTdHlsZVsgJC5jYW1lbENhc2UoIGtleSApIF0gPSBzdHlsZVsga2V5IF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZvciAoIGtleSBpbiBzdHlsZSApIHtcblx0XHRcdGlmICggdHlwZW9mIHN0eWxlWyBrZXkgXSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0bmV3U3R5bGVbIGtleSBdID0gc3R5bGVbIGtleSBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdTdHlsZTtcbn1cblxuXG5mdW5jdGlvbiBzdHlsZURpZmZlcmVuY2UoIG9sZFN0eWxlLCBuZXdTdHlsZSApIHtcblx0dmFyIGRpZmYgPSB7fSxcblx0XHRuYW1lLCB2YWx1ZTtcblxuXHRmb3IgKCBuYW1lIGluIG5ld1N0eWxlICkge1xuXHRcdHZhbHVlID0gbmV3U3R5bGVbIG5hbWUgXTtcblx0XHRpZiAoIG9sZFN0eWxlWyBuYW1lIF0gIT09IHZhbHVlICkge1xuXHRcdFx0aWYgKCAhc2hvcnRoYW5kU3R5bGVzWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGlmICggJC5meC5zdGVwWyBuYW1lIF0gfHwgIWlzTmFOKCBwYXJzZUZsb2F0KCB2YWx1ZSApICkgKSB7XG5cdFx0XHRcdFx0ZGlmZlsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZGlmZjtcbn1cblxuJC5lZmZlY3RzLmFuaW1hdGVDbGFzcyA9IGZ1bmN0aW9uKCB2YWx1ZSwgZHVyYXRpb24sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdHZhciBvID0gJC5zcGVlZCggZHVyYXRpb24sIGVhc2luZywgY2FsbGJhY2sgKTtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFuaW1hdGVkID0gJCggdGhpcyApLFxuXHRcdFx0YmFzZUNsYXNzID0gYW5pbWF0ZWQuYXR0ciggXCJjbGFzc1wiICkgfHwgXCJcIixcblx0XHRcdGFwcGx5Q2xhc3NDaGFuZ2UsXG5cdFx0XHRhbGxBbmltYXRpb25zID0gby5jaGlsZHJlbiA/IGFuaW1hdGVkLmZpbmQoIFwiKlwiICkuYW5kU2VsZigpIDogYW5pbWF0ZWQ7XG5cblx0XHQvLyBtYXAgdGhlIGFuaW1hdGVkIG9iamVjdHMgdG8gc3RvcmUgdGhlIG9yaWdpbmFsIHN0eWxlcy5cblx0XHRhbGxBbmltYXRpb25zID0gYWxsQW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZWwgPSAkKCB0aGlzICk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRlbDogZWwsXG5cdFx0XHRcdHN0YXJ0OiBnZXRFbGVtZW50U3R5bGVzLmNhbGwoIHRoaXMgKVxuXHRcdFx0fTtcblx0XHR9KTtcblxuXHRcdC8vIGFwcGx5IGNsYXNzIGNoYW5nZVxuXHRcdGFwcGx5Q2xhc3NDaGFuZ2UgPSBmdW5jdGlvbigpIHtcblx0XHRcdCQuZWFjaCggY2xhc3NBbmltYXRpb25BY3Rpb25zLCBmdW5jdGlvbihpLCBhY3Rpb24pIHtcblx0XHRcdFx0aWYgKCB2YWx1ZVsgYWN0aW9uIF0gKSB7XG5cdFx0XHRcdFx0YW5pbWF0ZWRbIGFjdGlvbiArIFwiQ2xhc3NcIiBdKCB2YWx1ZVsgYWN0aW9uIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fTtcblx0XHRhcHBseUNsYXNzQ2hhbmdlKCk7XG5cblx0XHQvLyBtYXAgYWxsIGFuaW1hdGVkIG9iamVjdHMgYWdhaW4gLSBjYWxjdWxhdGUgbmV3IHN0eWxlcyBhbmQgZGlmZlxuXHRcdGFsbEFuaW1hdGlvbnMgPSBhbGxBbmltYXRpb25zLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuZW5kID0gZ2V0RWxlbWVudFN0eWxlcy5jYWxsKCB0aGlzLmVsWyAwIF0gKTtcblx0XHRcdHRoaXMuZGlmZiA9IHN0eWxlRGlmZmVyZW5jZSggdGhpcy5zdGFydCwgdGhpcy5lbmQgKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0pO1xuXG5cdFx0Ly8gYXBwbHkgb3JpZ2luYWwgY2xhc3Ncblx0XHRhbmltYXRlZC5hdHRyKCBcImNsYXNzXCIsIGJhc2VDbGFzcyApO1xuXG5cdFx0Ly8gbWFwIGFsbCBhbmltYXRlZCBvYmplY3RzIGFnYWluIC0gdGhpcyB0aW1lIGNvbGxlY3RpbmcgYSBwcm9taXNlXG5cdFx0YWxsQW5pbWF0aW9ucyA9IGFsbEFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHN0eWxlSW5mbyA9IHRoaXMsXG5cdFx0XHRcdGRmZCA9ICQuRGVmZXJyZWQoKSxcblx0XHRcdFx0b3B0cyA9IGpRdWVyeS5leHRlbmQoe30sIG8sIHtcblx0XHRcdFx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0XHRcdFx0Y29tcGxldGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0ZGZkLnJlc29sdmUoIHN0eWxlSW5mbyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuZWwuYW5pbWF0ZSggdGhpcy5kaWZmLCBvcHRzICk7XG5cdFx0XHRyZXR1cm4gZGZkLnByb21pc2UoKTtcblx0XHR9KTtcblxuXHRcdC8vIG9uY2UgYWxsIGFuaW1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQ6XG5cdFx0JC53aGVuLmFwcGx5KCAkLCBhbGxBbmltYXRpb25zLmdldCgpICkuZG9uZShmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gc2V0IHRoZSBmaW5hbCBjbGFzc1xuXHRcdFx0YXBwbHlDbGFzc0NoYW5nZSgpO1xuXG5cdFx0XHQvLyBmb3IgZWFjaCBhbmltYXRlZCBlbGVtZW50LFxuXHRcdFx0Ly8gY2xlYXIgYWxsIGNzcyBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBhbmltYXRlZFxuXHRcdFx0JC5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWwgPSB0aGlzLmVsO1xuXHRcdFx0XHQkLmVhY2goIHRoaXMuZGlmZiwgZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRcdFx0ZWwuY3NzKCBrZXksICcnICk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIHRoaXMgaXMgZ3Vhcm50ZWVkIHRvIGJlIHRoZXJlIGlmIHlvdSB1c2UgalF1ZXJ5LnNwZWVkKClcblx0XHRcdC8vIGl0IGFsc28gaGFuZGxlcyBkZXF1ZXVpbmcgdGhlIG5leHQgYW5pbS4uLlxuXHRcdFx0by5jb21wbGV0ZS5jYWxsKCBhbmltYXRlZFsgMCBdICk7XG5cdFx0fSk7XG5cdH0pO1xufTtcblxuJC5mbi5leHRlbmQoe1xuXHRfYWRkQ2xhc3M6ICQuZm4uYWRkQ2xhc3MsXG5cdGFkZENsYXNzOiBmdW5jdGlvbiggY2xhc3NOYW1lcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID9cblx0XHRcdCQuZWZmZWN0cy5hbmltYXRlQ2xhc3MuY2FsbCggdGhpcyxcblx0XHRcdFx0eyBhZGQ6IGNsYXNzTmFtZXMgfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSA6XG5cdFx0XHR0aGlzLl9hZGRDbGFzcyggY2xhc3NOYW1lcyApO1xuXHR9LFxuXG5cdF9yZW1vdmVDbGFzczogJC5mbi5yZW1vdmVDbGFzcyxcblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCBjbGFzc05hbWVzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgP1xuXHRcdFx0JC5lZmZlY3RzLmFuaW1hdGVDbGFzcy5jYWxsKCB0aGlzLFxuXHRcdFx0XHR7IHJlbW92ZTogY2xhc3NOYW1lcyB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIDpcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCBjbGFzc05hbWVzICk7XG5cdH0sXG5cblx0X3RvZ2dsZUNsYXNzOiAkLmZuLnRvZ2dsZUNsYXNzLFxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIGNsYXNzTmFtZXMsIGZvcmNlLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIHR5cGVvZiBmb3JjZSA9PT0gXCJib29sZWFuXCIgfHwgZm9yY2UgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggIXNwZWVkICkge1xuXHRcdFx0XHQvLyB3aXRob3V0IHNwZWVkIHBhcmFtZXRlclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdG9nZ2xlQ2xhc3MoIGNsYXNzTmFtZXMsIGZvcmNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gJC5lZmZlY3RzLmFuaW1hdGVDbGFzcy5jYWxsKCB0aGlzLFxuXHRcdFx0XHRcdChmb3JjZSA/IHsgYWRkOiBjbGFzc05hbWVzIH0gOiB7IHJlbW92ZTogY2xhc3NOYW1lcyB9KSxcblx0XHRcdFx0XHRzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyB3aXRob3V0IGZvcmNlIHBhcmFtZXRlclxuXHRcdFx0cmV0dXJuICQuZWZmZWN0cy5hbmltYXRlQ2xhc3MuY2FsbCggdGhpcyxcblx0XHRcdFx0eyB0b2dnbGU6IGNsYXNzTmFtZXMgfSwgZm9yY2UsIHNwZWVkLCBlYXNpbmcgKTtcblx0XHR9XG5cdH0sXG5cblx0c3dpdGNoQ2xhc3M6IGZ1bmN0aW9uKCByZW1vdmUsIGFkZCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spIHtcblx0XHRyZXR1cm4gJC5lZmZlY3RzLmFuaW1hdGVDbGFzcy5jYWxsKCB0aGlzLCB7XG5cdFx0XHRhZGQ6IGFkZCxcblx0XHRcdHJlbW92ZTogcmVtb3ZlXG5cdFx0fSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fVxufSk7XG5cbn0pKCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogRUZGRUNUUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuKGZ1bmN0aW9uKCkge1xuXG4kLmV4dGVuZCggJC5lZmZlY3RzLCB7XG5cdHZlcnNpb246IFwiMS45LjJcIixcblxuXHQvLyBTYXZlcyBhIHNldCBvZiBwcm9wZXJ0aWVzIGluIGEgZGF0YSBzdG9yYWdlXG5cdHNhdmU6IGZ1bmN0aW9uKCBlbGVtZW50LCBzZXQgKSB7XG5cdFx0Zm9yKCB2YXIgaT0wOyBpIDwgc2V0Lmxlbmd0aDsgaSsrICkge1xuXHRcdFx0aWYgKCBzZXRbIGkgXSAhPT0gbnVsbCApIHtcblx0XHRcdFx0ZWxlbWVudC5kYXRhKCBkYXRhU3BhY2UgKyBzZXRbIGkgXSwgZWxlbWVudFsgMCBdLnN0eWxlWyBzZXRbIGkgXSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFJlc3RvcmVzIGEgc2V0IG9mIHByZXZpb3VzbHkgc2F2ZWQgcHJvcGVydGllcyBmcm9tIGEgZGF0YSBzdG9yYWdlXG5cdHJlc3RvcmU6IGZ1bmN0aW9uKCBlbGVtZW50LCBzZXQgKSB7XG5cdFx0dmFyIHZhbCwgaTtcblx0XHRmb3IoIGk9MDsgaSA8IHNldC5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGlmICggc2V0WyBpIF0gIT09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IGVsZW1lbnQuZGF0YSggZGF0YVNwYWNlICsgc2V0WyBpIF0gKTtcblx0XHRcdFx0Ly8gc3VwcG9ydDogalF1ZXJ5IDEuNi4yXG5cdFx0XHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0Lzk5MTdcblx0XHRcdFx0Ly8galF1ZXJ5IDEuNi4yIGluY29ycmVjdGx5IHJldHVybnMgdW5kZWZpbmVkIGZvciBhbnkgZmFsc3kgdmFsdWUuXG5cdFx0XHRcdC8vIFdlIGNhbid0IGRpZmZlcmVudGlhdGUgYmV0d2VlbiBcIlwiIGFuZCAwIGhlcmUsIHNvIHdlIGp1c3QgYXNzdW1lXG5cdFx0XHRcdC8vIGVtcHR5IHN0cmluZyBzaW5jZSBpdCdzIGxpa2VseSB0byBiZSBhIG1vcmUgY29tbW9uIHZhbHVlLi4uXG5cdFx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dmFsID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbGVtZW50LmNzcyggc2V0WyBpIF0sIHZhbCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzZXRNb2RlOiBmdW5jdGlvbiggZWwsIG1vZGUgKSB7XG5cdFx0aWYgKG1vZGUgPT09IFwidG9nZ2xlXCIpIHtcblx0XHRcdG1vZGUgPSBlbC5pcyggXCI6aGlkZGVuXCIgKSA/IFwic2hvd1wiIDogXCJoaWRlXCI7XG5cdFx0fVxuXHRcdHJldHVybiBtb2RlO1xuXHR9LFxuXG5cdC8vIFRyYW5zbGF0ZXMgYSBbdG9wLGxlZnRdIGFycmF5IGludG8gYSBiYXNlbGluZSB2YWx1ZVxuXHQvLyB0aGlzIHNob3VsZCBiZSBhIGxpdHRsZSBtb3JlIGZsZXhpYmxlIGluIHRoZSBmdXR1cmUgdG8gaGFuZGxlIGEgc3RyaW5nICYgaGFzaFxuXHRnZXRCYXNlbGluZTogZnVuY3Rpb24oIG9yaWdpbiwgb3JpZ2luYWwgKSB7XG5cdFx0dmFyIHksIHg7XG5cdFx0c3dpdGNoICggb3JpZ2luWyAwIF0gKSB7XG5cdFx0XHRjYXNlIFwidG9wXCI6IHkgPSAwOyBicmVhaztcblx0XHRcdGNhc2UgXCJtaWRkbGVcIjogeSA9IDAuNTsgYnJlYWs7XG5cdFx0XHRjYXNlIFwiYm90dG9tXCI6IHkgPSAxOyBicmVhaztcblx0XHRcdGRlZmF1bHQ6IHkgPSBvcmlnaW5bIDAgXSAvIG9yaWdpbmFsLmhlaWdodDtcblx0XHR9XG5cdFx0c3dpdGNoICggb3JpZ2luWyAxIF0gKSB7XG5cdFx0XHRjYXNlIFwibGVmdFwiOiB4ID0gMDsgYnJlYWs7XG5cdFx0XHRjYXNlIFwiY2VudGVyXCI6IHggPSAwLjU7IGJyZWFrO1xuXHRcdFx0Y2FzZSBcInJpZ2h0XCI6IHggPSAxOyBicmVhaztcblx0XHRcdGRlZmF1bHQ6IHggPSBvcmlnaW5bIDEgXSAvIG9yaWdpbmFsLndpZHRoO1xuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogeCxcblx0XHRcdHk6IHlcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFdyYXBzIHRoZSBlbGVtZW50IGFyb3VuZCBhIHdyYXBwZXIgdGhhdCBjb3BpZXMgcG9zaXRpb24gcHJvcGVydGllc1xuXHRjcmVhdGVXcmFwcGVyOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblxuXHRcdC8vIGlmIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgd3JhcHBlZCwgcmV0dXJuIGl0XG5cdFx0aWYgKCBlbGVtZW50LnBhcmVudCgpLmlzKCBcIi51aS1lZmZlY3RzLXdyYXBwZXJcIiApKSB7XG5cdFx0XHRyZXR1cm4gZWxlbWVudC5wYXJlbnQoKTtcblx0XHR9XG5cblx0XHQvLyB3cmFwIHRoZSBlbGVtZW50XG5cdFx0dmFyIHByb3BzID0ge1xuXHRcdFx0XHR3aWR0aDogZWxlbWVudC5vdXRlcldpZHRoKHRydWUpLFxuXHRcdFx0XHRoZWlnaHQ6IGVsZW1lbnQub3V0ZXJIZWlnaHQodHJ1ZSksXG5cdFx0XHRcdFwiZmxvYXRcIjogZWxlbWVudC5jc3MoIFwiZmxvYXRcIiApXG5cdFx0XHR9LFxuXHRcdFx0d3JhcHBlciA9ICQoIFwiPGRpdj48L2Rpdj5cIiApXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1lZmZlY3RzLXdyYXBwZXJcIiApXG5cdFx0XHRcdC5jc3Moe1xuXHRcdFx0XHRcdGZvbnRTaXplOiBcIjEwMCVcIixcblx0XHRcdFx0XHRiYWNrZ3JvdW5kOiBcInRyYW5zcGFyZW50XCIsXG5cdFx0XHRcdFx0Ym9yZGVyOiBcIm5vbmVcIixcblx0XHRcdFx0XHRtYXJnaW46IDAsXG5cdFx0XHRcdFx0cGFkZGluZzogMFxuXHRcdFx0XHR9KSxcblx0XHRcdC8vIFN0b3JlIHRoZSBzaXplIGluIGNhc2Ugd2lkdGgvaGVpZ2h0IGFyZSBkZWZpbmVkIGluICUgLSBGaXhlcyAjNTI0NVxuXHRcdFx0c2l6ZSA9IHtcblx0XHRcdFx0d2lkdGg6IGVsZW1lbnQud2lkdGgoKSxcblx0XHRcdFx0aGVpZ2h0OiBlbGVtZW50LmhlaWdodCgpXG5cdFx0XHR9LFxuXHRcdFx0YWN0aXZlID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuXHRcdC8vIHN1cHBvcnQ6IEZpcmVmb3hcblx0XHQvLyBGaXJlZm94IGluY29ycmVjdGx5IGV4cG9zZXMgYW5vbnltb3VzIGNvbnRlbnRcblx0XHQvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NjE2NjRcblx0XHR0cnkge1xuXHRcdFx0YWN0aXZlLmlkO1xuXHRcdH0gY2F0Y2goIGUgKSB7XG5cdFx0XHRhY3RpdmUgPSBkb2N1bWVudC5ib2R5O1xuXHRcdH1cblxuXHRcdGVsZW1lbnQud3JhcCggd3JhcHBlciApO1xuXG5cdFx0Ly8gRml4ZXMgIzc1OTUgLSBFbGVtZW50cyBsb3NlIGZvY3VzIHdoZW4gd3JhcHBlZC5cblx0XHRpZiAoIGVsZW1lbnRbIDAgXSA9PT0gYWN0aXZlIHx8ICQuY29udGFpbnMoIGVsZW1lbnRbIDAgXSwgYWN0aXZlICkgKSB7XG5cdFx0XHQkKCBhY3RpdmUgKS5mb2N1cygpO1xuXHRcdH1cblxuXHRcdHdyYXBwZXIgPSBlbGVtZW50LnBhcmVudCgpOyAvL0hvdGZpeCBmb3IgalF1ZXJ5IDEuNCBzaW5jZSBzb21lIGNoYW5nZSBpbiB3cmFwKCkgc2VlbXMgdG8gYWN0dWFsbHkgbG9zZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSB3cmFwcGVkIGVsZW1lbnRcblxuXHRcdC8vIHRyYW5zZmVyIHBvc2l0aW9uaW5nIHByb3BlcnRpZXMgdG8gdGhlIHdyYXBwZXJcblx0XHRpZiAoIGVsZW1lbnQuY3NzKCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdHdyYXBwZXIuY3NzKHsgcG9zaXRpb246IFwicmVsYXRpdmVcIiB9KTtcblx0XHRcdGVsZW1lbnQuY3NzKHsgcG9zaXRpb246IFwicmVsYXRpdmVcIiB9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0JC5leHRlbmQoIHByb3BzLCB7XG5cdFx0XHRcdHBvc2l0aW9uOiBlbGVtZW50LmNzcyggXCJwb3NpdGlvblwiICksXG5cdFx0XHRcdHpJbmRleDogZWxlbWVudC5jc3MoIFwiei1pbmRleFwiIClcblx0XHRcdH0pO1xuXHRcdFx0JC5lYWNoKFsgXCJ0b3BcIiwgXCJsZWZ0XCIsIFwiYm90dG9tXCIsIFwicmlnaHRcIiBdLCBmdW5jdGlvbihpLCBwb3MpIHtcblx0XHRcdFx0cHJvcHNbIHBvcyBdID0gZWxlbWVudC5jc3MoIHBvcyApO1xuXHRcdFx0XHRpZiAoIGlzTmFOKCBwYXJzZUludCggcHJvcHNbIHBvcyBdLCAxMCApICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIHBvcyBdID0gXCJhdXRvXCI7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0ZWxlbWVudC5jc3Moe1xuXHRcdFx0XHRwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuXHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdHJpZ2h0OiBcImF1dG9cIixcblx0XHRcdFx0Ym90dG9tOiBcImF1dG9cIlxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGVsZW1lbnQuY3NzKHNpemUpO1xuXG5cdFx0cmV0dXJuIHdyYXBwZXIuY3NzKCBwcm9wcyApLnNob3coKTtcblx0fSxcblxuXHRyZW1vdmVXcmFwcGVyOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR2YXIgYWN0aXZlID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuXHRcdGlmICggZWxlbWVudC5wYXJlbnQoKS5pcyggXCIudWktZWZmZWN0cy13cmFwcGVyXCIgKSApIHtcblx0XHRcdGVsZW1lbnQucGFyZW50KCkucmVwbGFjZVdpdGgoIGVsZW1lbnQgKTtcblxuXHRcdFx0Ly8gRml4ZXMgIzc1OTUgLSBFbGVtZW50cyBsb3NlIGZvY3VzIHdoZW4gd3JhcHBlZC5cblx0XHRcdGlmICggZWxlbWVudFsgMCBdID09PSBhY3RpdmUgfHwgJC5jb250YWlucyggZWxlbWVudFsgMCBdLCBhY3RpdmUgKSApIHtcblx0XHRcdFx0JCggYWN0aXZlICkuZm9jdXMoKTtcblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdHJldHVybiBlbGVtZW50O1xuXHR9LFxuXG5cdHNldFRyYW5zaXRpb246IGZ1bmN0aW9uKCBlbGVtZW50LCBsaXN0LCBmYWN0b3IsIHZhbHVlICkge1xuXHRcdHZhbHVlID0gdmFsdWUgfHwge307XG5cdFx0JC5lYWNoKCBsaXN0LCBmdW5jdGlvbiggaSwgeCApIHtcblx0XHRcdHZhciB1bml0ID0gZWxlbWVudC5jc3NVbml0KCB4ICk7XG5cdFx0XHRpZiAoIHVuaXRbIDAgXSA+IDAgKSB7XG5cdFx0XHRcdHZhbHVlWyB4IF0gPSB1bml0WyAwIF0gKiBmYWN0b3IgKyB1bml0WyAxIF07XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG59KTtcblxuLy8gcmV0dXJuIGFuIGVmZmVjdCBvcHRpb25zIG9iamVjdCBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlcnM6XG5mdW5jdGlvbiBfbm9ybWFsaXplQXJndW1lbnRzKCBlZmZlY3QsIG9wdGlvbnMsIHNwZWVkLCBjYWxsYmFjayApIHtcblxuXHQvLyBhbGxvdyBwYXNzaW5nIGFsbCBvcHRpb25zIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXJcblx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIGVmZmVjdCApICkge1xuXHRcdG9wdGlvbnMgPSBlZmZlY3Q7XG5cdFx0ZWZmZWN0ID0gZWZmZWN0LmVmZmVjdDtcblx0fVxuXG5cdC8vIGNvbnZlcnQgdG8gYW4gb2JqZWN0XG5cdGVmZmVjdCA9IHsgZWZmZWN0OiBlZmZlY3QgfTtcblxuXHQvLyBjYXRjaCAoZWZmZWN0LCBudWxsLCAuLi4pXG5cdGlmICggb3B0aW9ucyA9PSBudWxsICkge1xuXHRcdG9wdGlvbnMgPSB7fTtcblx0fVxuXG5cdC8vIGNhdGNoIChlZmZlY3QsIGNhbGxiYWNrKVxuXHRpZiAoICQuaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXHRcdGNhbGxiYWNrID0gb3B0aW9ucztcblx0XHRzcGVlZCA9IG51bGw7XG5cdFx0b3B0aW9ucyA9IHt9O1xuXHR9XG5cblx0Ly8gY2F0Y2ggKGVmZmVjdCwgc3BlZWQsID8pXG5cdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgfHwgJC5meC5zcGVlZHNbIG9wdGlvbnMgXSApIHtcblx0XHRjYWxsYmFjayA9IHNwZWVkO1xuXHRcdHNwZWVkID0gb3B0aW9ucztcblx0XHRvcHRpb25zID0ge307XG5cdH1cblxuXHQvLyBjYXRjaCAoZWZmZWN0LCBvcHRpb25zLCBjYWxsYmFjaylcblx0aWYgKCAkLmlzRnVuY3Rpb24oIHNwZWVkICkgKSB7XG5cdFx0Y2FsbGJhY2sgPSBzcGVlZDtcblx0XHRzcGVlZCA9IG51bGw7XG5cdH1cblxuXHQvLyBhZGQgb3B0aW9ucyB0byBlZmZlY3Rcblx0aWYgKCBvcHRpb25zICkge1xuXHRcdCQuZXh0ZW5kKCBlZmZlY3QsIG9wdGlvbnMgKTtcblx0fVxuXG5cdHNwZWVkID0gc3BlZWQgfHwgb3B0aW9ucy5kdXJhdGlvbjtcblx0ZWZmZWN0LmR1cmF0aW9uID0gJC5meC5vZmYgPyAwIDpcblx0XHR0eXBlb2Ygc3BlZWQgPT09IFwibnVtYmVyXCIgPyBzcGVlZCA6XG5cdFx0c3BlZWQgaW4gJC5meC5zcGVlZHMgPyAkLmZ4LnNwZWVkc1sgc3BlZWQgXSA6XG5cdFx0JC5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cblx0ZWZmZWN0LmNvbXBsZXRlID0gY2FsbGJhY2sgfHwgb3B0aW9ucy5jb21wbGV0ZTtcblxuXHRyZXR1cm4gZWZmZWN0O1xufVxuXG5mdW5jdGlvbiBzdGFuZGFyZFNwZWVkKCBzcGVlZCApIHtcblx0Ly8gdmFsaWQgc3RhbmRhcmQgc3BlZWRzXG5cdGlmICggIXNwZWVkIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJudW1iZXJcIiB8fCAkLmZ4LnNwZWVkc1sgc3BlZWQgXSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIGludmFsaWQgc3RyaW5ncyAtIHRyZWF0IGFzIFwibm9ybWFsXCIgc3BlZWRcblx0aWYgKCB0eXBlb2Ygc3BlZWQgPT09IFwic3RyaW5nXCIgJiYgISQuZWZmZWN0cy5lZmZlY3RbIHNwZWVkIF0gKSB7XG5cdFx0Ly8gVE9ETzogcmVtb3ZlIGluIDIuMCAoIzcxMTUpXG5cdFx0aWYgKCBiYWNrQ29tcGF0ICYmICQuZWZmZWN0c1sgc3BlZWQgXSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbiQuZm4uZXh0ZW5kKHtcblx0ZWZmZWN0OiBmdW5jdGlvbiggLyogZWZmZWN0LCBvcHRpb25zLCBzcGVlZCwgY2FsbGJhY2sgKi8gKSB7XG5cdFx0dmFyIGFyZ3MgPSBfbm9ybWFsaXplQXJndW1lbnRzLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSxcblx0XHRcdG1vZGUgPSBhcmdzLm1vZGUsXG5cdFx0XHRxdWV1ZSA9IGFyZ3MucXVldWUsXG5cdFx0XHRlZmZlY3RNZXRob2QgPSAkLmVmZmVjdHMuZWZmZWN0WyBhcmdzLmVmZmVjdCBdLFxuXG5cdFx0XHQvLyBERVBSRUNBVEVEOiByZW1vdmUgaW4gMi4wICgjNzExNSlcblx0XHRcdG9sZEVmZmVjdE1ldGhvZCA9ICFlZmZlY3RNZXRob2QgJiYgYmFja0NvbXBhdCAmJiAkLmVmZmVjdHNbIGFyZ3MuZWZmZWN0IF07XG5cblx0XHRpZiAoICQuZngub2ZmIHx8ICEoIGVmZmVjdE1ldGhvZCB8fCBvbGRFZmZlY3RNZXRob2QgKSApIHtcblx0XHRcdC8vIGRlbGVnYXRlIHRvIHRoZSBvcmlnaW5hbCBtZXRob2QgKGUuZy4sIC5zaG93KCkpIGlmIHBvc3NpYmxlXG5cdFx0XHRpZiAoIG1vZGUgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzWyBtb2RlIF0oIGFyZ3MuZHVyYXRpb24sIGFyZ3MuY29tcGxldGUgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggYXJncy5jb21wbGV0ZSApIHtcblx0XHRcdFx0XHRcdGFyZ3MuY29tcGxldGUuY2FsbCggdGhpcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcnVuKCBuZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0gPSAkKCB0aGlzICksXG5cdFx0XHRcdGNvbXBsZXRlID0gYXJncy5jb21wbGV0ZSxcblx0XHRcdFx0bW9kZSA9IGFyZ3MubW9kZTtcblxuXHRcdFx0ZnVuY3Rpb24gZG9uZSgpIHtcblx0XHRcdFx0aWYgKCAkLmlzRnVuY3Rpb24oIGNvbXBsZXRlICkgKSB7XG5cdFx0XHRcdFx0Y29tcGxldGUuY2FsbCggZWxlbVswXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggJC5pc0Z1bmN0aW9uKCBuZXh0ICkgKSB7XG5cdFx0XHRcdFx0bmV4dCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIHRoZSBlbGVtZW50IGlzIGhpZGRkZW4gYW5kIG1vZGUgaXMgaGlkZSxcblx0XHRcdC8vIG9yIGVsZW1lbnQgaXMgdmlzaWJsZSBhbmQgbW9kZSBpcyBzaG93XG5cdFx0XHRpZiAoIGVsZW0uaXMoIFwiOmhpZGRlblwiICkgPyBtb2RlID09PSBcImhpZGVcIiA6IG1vZGUgPT09IFwic2hvd1wiICkge1xuXHRcdFx0XHRkb25lKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlZmZlY3RNZXRob2QuY2FsbCggZWxlbVswXSwgYXJncywgZG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFRPRE86IHJlbW92ZSB0aGlzIGNoZWNrIGluIDIuMCwgZWZmZWN0TWV0aG9kIHdpbGwgYWx3YXlzIGJlIHRydWVcblx0XHRpZiAoIGVmZmVjdE1ldGhvZCApIHtcblx0XHRcdHJldHVybiBxdWV1ZSA9PT0gZmFsc2UgPyB0aGlzLmVhY2goIHJ1biApIDogdGhpcy5xdWV1ZSggcXVldWUgfHwgXCJmeFwiLCBydW4gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gREVQUkVDQVRFRDogcmVtb3ZlIGluIDIuMCAoIzcxMTUpXG5cdFx0XHRyZXR1cm4gb2xkRWZmZWN0TWV0aG9kLmNhbGwodGhpcywge1xuXHRcdFx0XHRvcHRpb25zOiBhcmdzLFxuXHRcdFx0XHRkdXJhdGlvbjogYXJncy5kdXJhdGlvbixcblx0XHRcdFx0Y2FsbGJhY2s6IGFyZ3MuY29tcGxldGUsXG5cdFx0XHRcdG1vZGU6IGFyZ3MubW9kZVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zaG93OiAkLmZuLnNob3csXG5cdHNob3c6IGZ1bmN0aW9uKCBzcGVlZCApIHtcblx0XHRpZiAoIHN0YW5kYXJkU3BlZWQoIHNwZWVkICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc2hvdy5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBhcmdzID0gX25vcm1hbGl6ZUFyZ3VtZW50cy5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRhcmdzLm1vZGUgPSBcInNob3dcIjtcblx0XHRcdHJldHVybiB0aGlzLmVmZmVjdC5jYWxsKCB0aGlzLCBhcmdzICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9oaWRlOiAkLmZuLmhpZGUsXG5cdGhpZGU6IGZ1bmN0aW9uKCBzcGVlZCApIHtcblx0XHRpZiAoIHN0YW5kYXJkU3BlZWQoIHNwZWVkICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5faGlkZS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBhcmdzID0gX25vcm1hbGl6ZUFyZ3VtZW50cy5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRhcmdzLm1vZGUgPSBcImhpZGVcIjtcblx0XHRcdHJldHVybiB0aGlzLmVmZmVjdC5jYWxsKCB0aGlzLCBhcmdzICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGpRdWVyeSBjb3JlIG92ZXJsb2FkcyB0b2dnbGUgYW5kIGNyZWF0ZXMgX3RvZ2dsZVxuXHRfX3RvZ2dsZTogJC5mbi50b2dnbGUsXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHNwZWVkICkge1xuXHRcdGlmICggc3RhbmRhcmRTcGVlZCggc3BlZWQgKSB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiIHx8ICQuaXNGdW5jdGlvbiggc3BlZWQgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLl9fdG9nZ2xlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGFyZ3MgPSBfbm9ybWFsaXplQXJndW1lbnRzLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdGFyZ3MubW9kZSA9IFwidG9nZ2xlXCI7XG5cdFx0XHRyZXR1cm4gdGhpcy5lZmZlY3QuY2FsbCggdGhpcywgYXJncyApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBoZWxwZXIgZnVuY3Rpb25zXG5cdGNzc1VuaXQ6IGZ1bmN0aW9uKGtleSkge1xuXHRcdHZhciBzdHlsZSA9IHRoaXMuY3NzKCBrZXkgKSxcblx0XHRcdHZhbCA9IFtdO1xuXG5cdFx0JC5lYWNoKCBbIFwiZW1cIiwgXCJweFwiLCBcIiVcIiwgXCJwdFwiIF0sIGZ1bmN0aW9uKCBpLCB1bml0ICkge1xuXHRcdFx0aWYgKCBzdHlsZS5pbmRleE9mKCB1bml0ICkgPiAwICkge1xuXHRcdFx0XHR2YWwgPSBbIHBhcnNlRmxvYXQoIHN0eWxlICksIHVuaXQgXTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59KTtcblxufSkoKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFQVNJTkcgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4oZnVuY3Rpb24oKSB7XG5cbi8vIGJhc2VkIG9uIGVhc2luZyBlcXVhdGlvbnMgZnJvbSBSb2JlcnQgUGVubmVyIChodHRwOi8vd3d3LnJvYmVydHBlbm5lci5jb20vZWFzaW5nKVxuXG52YXIgYmFzZUVhc2luZ3MgPSB7fTtcblxuJC5lYWNoKCBbIFwiUXVhZFwiLCBcIkN1YmljXCIsIFwiUXVhcnRcIiwgXCJRdWludFwiLCBcIkV4cG9cIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0YmFzZUVhc2luZ3NbIG5hbWUgXSA9IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBNYXRoLnBvdyggcCwgaSArIDIgKTtcblx0fTtcbn0pO1xuXG4kLmV4dGVuZCggYmFzZUVhc2luZ3MsIHtcblx0U2luZTogZnVuY3Rpb24gKCBwICkge1xuXHRcdHJldHVybiAxIC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJIC8gMiApO1xuXHR9LFxuXHRDaXJjOiBmdW5jdGlvbiAoIHAgKSB7XG5cdFx0cmV0dXJuIDEgLSBNYXRoLnNxcnQoIDEgLSBwICogcCApO1xuXHR9LFxuXHRFbGFzdGljOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcCA9PT0gMCB8fCBwID09PSAxID8gcCA6XG5cdFx0XHQtTWF0aC5wb3coIDIsIDggKiAocCAtIDEpICkgKiBNYXRoLnNpbiggKCAocCAtIDEpICogODAgLSA3LjUgKSAqIE1hdGguUEkgLyAxNSApO1xuXHR9LFxuXHRCYWNrOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcCAqIHAgKiAoIDMgKiBwIC0gMiApO1xuXHR9LFxuXHRCb3VuY2U6IGZ1bmN0aW9uICggcCApIHtcblx0XHR2YXIgcG93Mixcblx0XHRcdGJvdW5jZSA9IDQ7XG5cblx0XHR3aGlsZSAoIHAgPCAoICggcG93MiA9IE1hdGgucG93KCAyLCAtLWJvdW5jZSApICkgLSAxICkgLyAxMSApIHt9XG5cdFx0cmV0dXJuIDEgLyBNYXRoLnBvdyggNCwgMyAtIGJvdW5jZSApIC0gNy41NjI1ICogTWF0aC5wb3coICggcG93MiAqIDMgLSAyICkgLyAyMiAtIHAsIDIgKTtcblx0fVxufSk7XG5cbiQuZWFjaCggYmFzZUVhc2luZ3MsIGZ1bmN0aW9uKCBuYW1lLCBlYXNlSW4gKSB7XG5cdCQuZWFzaW5nWyBcImVhc2VJblwiICsgbmFtZSBdID0gZWFzZUluO1xuXHQkLmVhc2luZ1sgXCJlYXNlT3V0XCIgKyBuYW1lIF0gPSBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMSAtIGVhc2VJbiggMSAtIHAgKTtcblx0fTtcblx0JC5lYXNpbmdbIFwiZWFzZUluT3V0XCIgKyBuYW1lIF0gPSBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcCA8IDAuNSA/XG5cdFx0XHRlYXNlSW4oIHAgKiAyICkgLyAyIDpcblx0XHRcdDEgLSBlYXNlSW4oIHAgKiAtMiArIDIgKSAvIDI7XG5cdH07XG59KTtcblxufSkoKTtcblxufSkoalF1ZXJ5KSk7XG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxudmFyIHJ2ZXJ0aWNhbCA9IC91cHxkb3dufHZlcnRpY2FsLyxcblx0cnBvc2l0aXZlbW90aW9uID0gL3VwfGxlZnR8dmVydGljYWx8aG9yaXpvbnRhbC87XG5cbiQuZWZmZWN0cy5lZmZlY3QuYmxpbmQgPSBmdW5jdGlvbiggbywgZG9uZSApIHtcblx0Ly8gQ3JlYXRlIGVsZW1lbnRcblx0dmFyIGVsID0gJCggdGhpcyApLFxuXHRcdHByb3BzID0gWyBcInBvc2l0aW9uXCIsIFwidG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLFxuXHRcdG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZSggZWwsIG8ubW9kZSB8fCBcImhpZGVcIiApLFxuXHRcdGRpcmVjdGlvbiA9IG8uZGlyZWN0aW9uIHx8IFwidXBcIixcblx0XHR2ZXJ0aWNhbCA9IHJ2ZXJ0aWNhbC50ZXN0KCBkaXJlY3Rpb24gKSxcblx0XHRyZWYgPSB2ZXJ0aWNhbCA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCIsXG5cdFx0cmVmMiA9IHZlcnRpY2FsID8gXCJ0b3BcIiA6IFwibGVmdFwiLFxuXHRcdG1vdGlvbiA9IHJwb3NpdGl2ZW1vdGlvbi50ZXN0KCBkaXJlY3Rpb24gKSxcblx0XHRhbmltYXRpb24gPSB7fSxcblx0XHRzaG93ID0gbW9kZSA9PT0gXCJzaG93XCIsXG5cdFx0d3JhcHBlciwgZGlzdGFuY2UsIG1hcmdpbjtcblxuXHQvLyBpZiBhbHJlYWR5IHdyYXBwZWQsIHRoZSB3cmFwcGVyJ3MgcHJvcGVydGllcyBhcmUgbXkgcHJvcGVydHkuICM2MjQ1XG5cdGlmICggZWwucGFyZW50KCkuaXMoIFwiLnVpLWVmZmVjdHMtd3JhcHBlclwiICkgKSB7XG5cdFx0JC5lZmZlY3RzLnNhdmUoIGVsLnBhcmVudCgpLCBwcm9wcyApO1xuXHR9IGVsc2Uge1xuXHRcdCQuZWZmZWN0cy5zYXZlKCBlbCwgcHJvcHMgKTtcblx0fVxuXHRlbC5zaG93KCk7XG5cdHdyYXBwZXIgPSAkLmVmZmVjdHMuY3JlYXRlV3JhcHBlciggZWwgKS5jc3Moe1xuXHRcdG92ZXJmbG93OiBcImhpZGRlblwiXG5cdH0pO1xuXG5cdGRpc3RhbmNlID0gd3JhcHBlclsgcmVmIF0oKTtcblx0bWFyZ2luID0gcGFyc2VGbG9hdCggd3JhcHBlci5jc3MoIHJlZjIgKSApIHx8IDA7XG5cblx0YW5pbWF0aW9uWyByZWYgXSA9IHNob3cgPyBkaXN0YW5jZSA6IDA7XG5cdGlmICggIW1vdGlvbiApIHtcblx0XHRlbFxuXHRcdFx0LmNzcyggdmVydGljYWwgPyBcImJvdHRvbVwiIDogXCJyaWdodFwiLCAwIClcblx0XHRcdC5jc3MoIHZlcnRpY2FsID8gXCJ0b3BcIiA6IFwibGVmdFwiLCBcImF1dG9cIiApXG5cdFx0XHQuY3NzKHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiB9KTtcblxuXHRcdGFuaW1hdGlvblsgcmVmMiBdID0gc2hvdyA/IG1hcmdpbiA6IGRpc3RhbmNlICsgbWFyZ2luO1xuXHR9XG5cblx0Ly8gc3RhcnQgYXQgMCBpZiB3ZSBhcmUgc2hvd2luZ1xuXHRpZiAoIHNob3cgKSB7XG5cdFx0d3JhcHBlci5jc3MoIHJlZiwgMCApO1xuXHRcdGlmICggISBtb3Rpb24gKSB7XG5cdFx0XHR3cmFwcGVyLmNzcyggcmVmMiwgbWFyZ2luICsgZGlzdGFuY2UgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBBbmltYXRlXG5cdHdyYXBwZXIuYW5pbWF0ZSggYW5pbWF0aW9uLCB7XG5cdFx0ZHVyYXRpb246IG8uZHVyYXRpb24sXG5cdFx0ZWFzaW5nOiBvLmVhc2luZyxcblx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0Y29tcGxldGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBtb2RlID09PSBcImhpZGVcIiApIHtcblx0XHRcdFx0ZWwuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdFx0JC5lZmZlY3RzLnJlc3RvcmUoIGVsLCBwcm9wcyApO1xuXHRcdFx0JC5lZmZlY3RzLnJlbW92ZVdyYXBwZXIoIGVsICk7XG5cdFx0XHRkb25lKCk7XG5cdFx0fVxuXHR9KTtcblxufTtcblxufSkoalF1ZXJ5KTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLmVmZmVjdHMuZWZmZWN0LmJvdW5jZSA9IGZ1bmN0aW9uKCBvLCBkb25lICkge1xuXHR2YXIgZWwgPSAkKCB0aGlzICksXG5cdFx0cHJvcHMgPSBbIFwicG9zaXRpb25cIiwgXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sXG5cblx0XHQvLyBkZWZhdWx0czpcblx0XHRtb2RlID0gJC5lZmZlY3RzLnNldE1vZGUoIGVsLCBvLm1vZGUgfHwgXCJlZmZlY3RcIiApLFxuXHRcdGhpZGUgPSBtb2RlID09PSBcImhpZGVcIixcblx0XHRzaG93ID0gbW9kZSA9PT0gXCJzaG93XCIsXG5cdFx0ZGlyZWN0aW9uID0gby5kaXJlY3Rpb24gfHwgXCJ1cFwiLFxuXHRcdGRpc3RhbmNlID0gby5kaXN0YW5jZSxcblx0XHR0aW1lcyA9IG8udGltZXMgfHwgNSxcblxuXHRcdC8vIG51bWJlciBvZiBpbnRlcm5hbCBhbmltYXRpb25zXG5cdFx0YW5pbXMgPSB0aW1lcyAqIDIgKyAoIHNob3cgfHwgaGlkZSA/IDEgOiAwICksXG5cdFx0c3BlZWQgPSBvLmR1cmF0aW9uIC8gYW5pbXMsXG5cdFx0ZWFzaW5nID0gby5lYXNpbmcsXG5cblx0XHQvLyB1dGlsaXR5OlxuXHRcdHJlZiA9ICggZGlyZWN0aW9uID09PSBcInVwXCIgfHwgZGlyZWN0aW9uID09PSBcImRvd25cIiApID8gXCJ0b3BcIiA6IFwibGVmdFwiLFxuXHRcdG1vdGlvbiA9ICggZGlyZWN0aW9uID09PSBcInVwXCIgfHwgZGlyZWN0aW9uID09PSBcImxlZnRcIiApLFxuXHRcdGksXG5cdFx0dXBBbmltLFxuXHRcdGRvd25BbmltLFxuXG5cdFx0Ly8gd2Ugd2lsbCBuZWVkIHRvIHJlLWFzc2VtYmxlIHRoZSBxdWV1ZSB0byBzdGFjayBvdXIgYW5pbWF0aW9ucyBpbiBwbGFjZVxuXHRcdHF1ZXVlID0gZWwucXVldWUoKSxcblx0XHRxdWV1ZWxlbiA9IHF1ZXVlLmxlbmd0aDtcblxuXHQvLyBBdm9pZCB0b3VjaGluZyBvcGFjaXR5IHRvIHByZXZlbnQgY2xlYXJUeXBlIGFuZCBQTkcgaXNzdWVzIGluIElFXG5cdGlmICggc2hvdyB8fCBoaWRlICkge1xuXHRcdHByb3BzLnB1c2goIFwib3BhY2l0eVwiICk7XG5cdH1cblxuXHQkLmVmZmVjdHMuc2F2ZSggZWwsIHByb3BzICk7XG5cdGVsLnNob3coKTtcblx0JC5lZmZlY3RzLmNyZWF0ZVdyYXBwZXIoIGVsICk7IC8vIENyZWF0ZSBXcmFwcGVyXG5cblx0Ly8gZGVmYXVsdCBkaXN0YW5jZSBmb3IgdGhlIEJJR0dFU1QgYm91bmNlIGlzIHRoZSBvdXRlciBEaXN0YW5jZSAvIDNcblx0aWYgKCAhZGlzdGFuY2UgKSB7XG5cdFx0ZGlzdGFuY2UgPSBlbFsgcmVmID09PSBcInRvcFwiID8gXCJvdXRlckhlaWdodFwiIDogXCJvdXRlcldpZHRoXCIgXSgpIC8gMztcblx0fVxuXG5cdGlmICggc2hvdyApIHtcblx0XHRkb3duQW5pbSA9IHsgb3BhY2l0eTogMSB9O1xuXHRcdGRvd25BbmltWyByZWYgXSA9IDA7XG5cblx0XHQvLyBpZiB3ZSBhcmUgc2hvd2luZywgZm9yY2Ugb3BhY2l0eSAwIGFuZCBzZXQgdGhlIGluaXRpYWwgcG9zaXRpb25cblx0XHQvLyB0aGVuIGRvIHRoZSBcImZpcnN0XCIgYW5pbWF0aW9uXG5cdFx0ZWwuY3NzKCBcIm9wYWNpdHlcIiwgMCApXG5cdFx0XHQuY3NzKCByZWYsIG1vdGlvbiA/IC1kaXN0YW5jZSAqIDIgOiBkaXN0YW5jZSAqIDIgKVxuXHRcdFx0LmFuaW1hdGUoIGRvd25BbmltLCBzcGVlZCwgZWFzaW5nICk7XG5cdH1cblxuXHQvLyBzdGFydCBhdCB0aGUgc21hbGxlc3QgZGlzdGFuY2UgaWYgd2UgYXJlIGhpZGluZ1xuXHRpZiAoIGhpZGUgKSB7XG5cdFx0ZGlzdGFuY2UgPSBkaXN0YW5jZSAvIE1hdGgucG93KCAyLCB0aW1lcyAtIDEgKTtcblx0fVxuXG5cdGRvd25BbmltID0ge307XG5cdGRvd25BbmltWyByZWYgXSA9IDA7XG5cdC8vIEJvdW5jZXMgdXAvZG93bi9sZWZ0L3JpZ2h0IHRoZW4gYmFjayB0byAwIC0tIHRpbWVzICogMiBhbmltYXRpb25zIGhhcHBlbiBoZXJlXG5cdGZvciAoIGkgPSAwOyBpIDwgdGltZXM7IGkrKyApIHtcblx0XHR1cEFuaW0gPSB7fTtcblx0XHR1cEFuaW1bIHJlZiBdID0gKCBtb3Rpb24gPyBcIi09XCIgOiBcIis9XCIgKSArIGRpc3RhbmNlO1xuXG5cdFx0ZWwuYW5pbWF0ZSggdXBBbmltLCBzcGVlZCwgZWFzaW5nIClcblx0XHRcdC5hbmltYXRlKCBkb3duQW5pbSwgc3BlZWQsIGVhc2luZyApO1xuXG5cdFx0ZGlzdGFuY2UgPSBoaWRlID8gZGlzdGFuY2UgKiAyIDogZGlzdGFuY2UgLyAyO1xuXHR9XG5cblx0Ly8gTGFzdCBCb3VuY2Ugd2hlbiBIaWRpbmdcblx0aWYgKCBoaWRlICkge1xuXHRcdHVwQW5pbSA9IHsgb3BhY2l0eTogMCB9O1xuXHRcdHVwQW5pbVsgcmVmIF0gPSAoIG1vdGlvbiA/IFwiLT1cIiA6IFwiKz1cIiApICsgZGlzdGFuY2U7XG5cblx0XHRlbC5hbmltYXRlKCB1cEFuaW0sIHNwZWVkLCBlYXNpbmcgKTtcblx0fVxuXG5cdGVsLnF1ZXVlKGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaGlkZSApIHtcblx0XHRcdGVsLmhpZGUoKTtcblx0XHR9XG5cdFx0JC5lZmZlY3RzLnJlc3RvcmUoIGVsLCBwcm9wcyApO1xuXHRcdCQuZWZmZWN0cy5yZW1vdmVXcmFwcGVyKCBlbCApO1xuXHRcdGRvbmUoKTtcblx0fSk7XG5cblx0Ly8gaW5qZWN0IGFsbCB0aGUgYW5pbWF0aW9ucyB3ZSBqdXN0IHF1ZXVlZCB0byBiZSBmaXJzdCBpbiBsaW5lIChhZnRlciBcImlucHJvZ3Jlc3NcIilcblx0aWYgKCBxdWV1ZWxlbiA+IDEpIHtcblx0XHRxdWV1ZS5zcGxpY2UuYXBwbHkoIHF1ZXVlLFxuXHRcdFx0WyAxLCAwIF0uY29uY2F0KCBxdWV1ZS5zcGxpY2UoIHF1ZXVlbGVuLCBhbmltcyArIDEgKSApICk7XG5cdH1cblx0ZWwuZGVxdWV1ZSgpO1xuXG59O1xuXG59KShqUXVlcnkpO1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQuZWZmZWN0cy5lZmZlY3QuY2xpcCA9IGZ1bmN0aW9uKCBvLCBkb25lICkge1xuXHQvLyBDcmVhdGUgZWxlbWVudFxuXHR2YXIgZWwgPSAkKCB0aGlzICksXG5cdFx0cHJvcHMgPSBbIFwicG9zaXRpb25cIiwgXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sXG5cdFx0bW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKCBlbCwgby5tb2RlIHx8IFwiaGlkZVwiICksXG5cdFx0c2hvdyA9IG1vZGUgPT09IFwic2hvd1wiLFxuXHRcdGRpcmVjdGlvbiA9IG8uZGlyZWN0aW9uIHx8IFwidmVydGljYWxcIixcblx0XHR2ZXJ0ID0gZGlyZWN0aW9uID09PSBcInZlcnRpY2FsXCIsXG5cdFx0c2l6ZSA9IHZlcnQgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiLFxuXHRcdHBvc2l0aW9uID0gdmVydCA/IFwidG9wXCIgOiBcImxlZnRcIixcblx0XHRhbmltYXRpb24gPSB7fSxcblx0XHR3cmFwcGVyLCBhbmltYXRlLCBkaXN0YW5jZTtcblxuXHQvLyBTYXZlICYgU2hvd1xuXHQkLmVmZmVjdHMuc2F2ZSggZWwsIHByb3BzICk7XG5cdGVsLnNob3coKTtcblxuXHQvLyBDcmVhdGUgV3JhcHBlclxuXHR3cmFwcGVyID0gJC5lZmZlY3RzLmNyZWF0ZVdyYXBwZXIoIGVsICkuY3NzKHtcblx0XHRvdmVyZmxvdzogXCJoaWRkZW5cIlxuXHR9KTtcblx0YW5pbWF0ZSA9ICggZWxbMF0udGFnTmFtZSA9PT0gXCJJTUdcIiApID8gd3JhcHBlciA6IGVsO1xuXHRkaXN0YW5jZSA9IGFuaW1hdGVbIHNpemUgXSgpO1xuXG5cdC8vIFNoaWZ0XG5cdGlmICggc2hvdyApIHtcblx0XHRhbmltYXRlLmNzcyggc2l6ZSwgMCApO1xuXHRcdGFuaW1hdGUuY3NzKCBwb3NpdGlvbiwgZGlzdGFuY2UgLyAyICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgQW5pbWF0aW9uIE9iamVjdDpcblx0YW5pbWF0aW9uWyBzaXplIF0gPSBzaG93ID8gZGlzdGFuY2UgOiAwO1xuXHRhbmltYXRpb25bIHBvc2l0aW9uIF0gPSBzaG93ID8gMCA6IGRpc3RhbmNlIC8gMjtcblxuXHQvLyBBbmltYXRlXG5cdGFuaW1hdGUuYW5pbWF0ZSggYW5pbWF0aW9uLCB7XG5cdFx0cXVldWU6IGZhbHNlLFxuXHRcdGR1cmF0aW9uOiBvLmR1cmF0aW9uLFxuXHRcdGVhc2luZzogby5lYXNpbmcsXG5cdFx0Y29tcGxldGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhc2hvdyApIHtcblx0XHRcdFx0ZWwuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdFx0JC5lZmZlY3RzLnJlc3RvcmUoIGVsLCBwcm9wcyApO1xuXHRcdFx0JC5lZmZlY3RzLnJlbW92ZVdyYXBwZXIoIGVsICk7XG5cdFx0XHRkb25lKCk7XG5cdFx0fVxuXHR9KTtcblxufTtcblxufSkoalF1ZXJ5KTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLmVmZmVjdHMuZWZmZWN0LmRyb3AgPSBmdW5jdGlvbiggbywgZG9uZSApIHtcblxuXHR2YXIgZWwgPSAkKCB0aGlzICksXG5cdFx0cHJvcHMgPSBbIFwicG9zaXRpb25cIiwgXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJvcGFjaXR5XCIsIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLFxuXHRcdG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZSggZWwsIG8ubW9kZSB8fCBcImhpZGVcIiApLFxuXHRcdHNob3cgPSBtb2RlID09PSBcInNob3dcIixcblx0XHRkaXJlY3Rpb24gPSBvLmRpcmVjdGlvbiB8fCBcImxlZnRcIixcblx0XHRyZWYgPSAoIGRpcmVjdGlvbiA9PT0gXCJ1cFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJkb3duXCIgKSA/IFwidG9wXCIgOiBcImxlZnRcIixcblx0XHRtb3Rpb24gPSAoIGRpcmVjdGlvbiA9PT0gXCJ1cFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgKSA/IFwicG9zXCIgOiBcIm5lZ1wiLFxuXHRcdGFuaW1hdGlvbiA9IHtcblx0XHRcdG9wYWNpdHk6IHNob3cgPyAxIDogMFxuXHRcdH0sXG5cdFx0ZGlzdGFuY2U7XG5cblx0Ly8gQWRqdXN0XG5cdCQuZWZmZWN0cy5zYXZlKCBlbCwgcHJvcHMgKTtcblx0ZWwuc2hvdygpO1xuXHQkLmVmZmVjdHMuY3JlYXRlV3JhcHBlciggZWwgKTtcblxuXHRkaXN0YW5jZSA9IG8uZGlzdGFuY2UgfHwgZWxbIHJlZiA9PT0gXCJ0b3BcIiA/IFwib3V0ZXJIZWlnaHRcIjogXCJvdXRlcldpZHRoXCIgXSggdHJ1ZSApIC8gMjtcblxuXHRpZiAoIHNob3cgKSB7XG5cdFx0ZWxcblx0XHRcdC5jc3MoIFwib3BhY2l0eVwiLCAwIClcblx0XHRcdC5jc3MoIHJlZiwgbW90aW9uID09PSBcInBvc1wiID8gLWRpc3RhbmNlIDogZGlzdGFuY2UgKTtcblx0fVxuXG5cdC8vIEFuaW1hdGlvblxuXHRhbmltYXRpb25bIHJlZiBdID0gKCBzaG93ID9cblx0XHQoIG1vdGlvbiA9PT0gXCJwb3NcIiA/IFwiKz1cIiA6IFwiLT1cIiApIDpcblx0XHQoIG1vdGlvbiA9PT0gXCJwb3NcIiA/IFwiLT1cIiA6IFwiKz1cIiApICkgK1xuXHRcdGRpc3RhbmNlO1xuXG5cdC8vIEFuaW1hdGVcblx0ZWwuYW5pbWF0ZSggYW5pbWF0aW9uLCB7XG5cdFx0cXVldWU6IGZhbHNlLFxuXHRcdGR1cmF0aW9uOiBvLmR1cmF0aW9uLFxuXHRcdGVhc2luZzogby5lYXNpbmcsXG5cdFx0Y29tcGxldGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBtb2RlID09PSBcImhpZGVcIiApIHtcblx0XHRcdFx0ZWwuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdFx0JC5lZmZlY3RzLnJlc3RvcmUoIGVsLCBwcm9wcyApO1xuXHRcdFx0JC5lZmZlY3RzLnJlbW92ZVdyYXBwZXIoIGVsICk7XG5cdFx0XHRkb25lKCk7XG5cdFx0fVxuXHR9KTtcbn07XG5cbn0pKGpRdWVyeSk7XG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC5lZmZlY3RzLmVmZmVjdC5leHBsb2RlID0gZnVuY3Rpb24oIG8sIGRvbmUgKSB7XG5cblx0dmFyIHJvd3MgPSBvLnBpZWNlcyA/IE1hdGgucm91bmQoIE1hdGguc3FydCggby5waWVjZXMgKSApIDogMyxcblx0XHRjZWxscyA9IHJvd3MsXG5cdFx0ZWwgPSAkKCB0aGlzICksXG5cdFx0bW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKCBlbCwgby5tb2RlIHx8IFwiaGlkZVwiICksXG5cdFx0c2hvdyA9IG1vZGUgPT09IFwic2hvd1wiLFxuXG5cdFx0Ly8gc2hvdyBhbmQgdGhlbiB2aXNpYmlsaXR5OmhpZGRlbiB0aGUgZWxlbWVudCBiZWZvcmUgY2FsY3VsYXRpbmcgb2Zmc2V0XG5cdFx0b2Zmc2V0ID0gZWwuc2hvdygpLmNzcyggXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIgKS5vZmZzZXQoKSxcblxuXHRcdC8vIHdpZHRoIGFuZCBoZWlnaHQgb2YgYSBwaWVjZVxuXHRcdHdpZHRoID0gTWF0aC5jZWlsKCBlbC5vdXRlcldpZHRoKCkgLyBjZWxscyApLFxuXHRcdGhlaWdodCA9IE1hdGguY2VpbCggZWwub3V0ZXJIZWlnaHQoKSAvIHJvd3MgKSxcblx0XHRwaWVjZXMgPSBbXSxcblxuXHRcdC8vIGxvb3Bcblx0XHRpLCBqLCBsZWZ0LCB0b3AsIG14LCBteTtcblxuXHQvLyBjaGlsZHJlbiBhbmltYXRlIGNvbXBsZXRlOlxuXHRmdW5jdGlvbiBjaGlsZENvbXBsZXRlKCkge1xuXHRcdHBpZWNlcy5wdXNoKCB0aGlzICk7XG5cdFx0aWYgKCBwaWVjZXMubGVuZ3RoID09PSByb3dzICogY2VsbHMgKSB7XG5cdFx0XHRhbmltQ29tcGxldGUoKTtcblx0XHR9XG5cdH1cblxuXHQvLyBjbG9uZSB0aGUgZWxlbWVudCBmb3IgZWFjaCByb3cgYW5kIGNlbGwuXG5cdGZvciggaSA9IDA7IGkgPCByb3dzIDsgaSsrICkgeyAvLyA9PT0+XG5cdFx0dG9wID0gb2Zmc2V0LnRvcCArIGkgKiBoZWlnaHQ7XG5cdFx0bXkgPSBpIC0gKCByb3dzIC0gMSApIC8gMiA7XG5cblx0XHRmb3IoIGogPSAwOyBqIDwgY2VsbHMgOyBqKysgKSB7IC8vIHx8fFxuXHRcdFx0bGVmdCA9IG9mZnNldC5sZWZ0ICsgaiAqIHdpZHRoO1xuXHRcdFx0bXggPSBqIC0gKCBjZWxscyAtIDEgKSAvIDIgO1xuXG5cdFx0XHQvLyBDcmVhdGUgYSBjbG9uZSBvZiB0aGUgbm93IGhpZGRlbiBtYWluIGVsZW1lbnQgdGhhdCB3aWxsIGJlIGFic29sdXRlIHBvc2l0aW9uZWRcblx0XHRcdC8vIHdpdGhpbiBhIHdyYXBwZXIgZGl2IG9mZiB0aGUgLWxlZnQgYW5kIC10b3AgZXF1YWwgdG8gc2l6ZSBvZiBvdXIgcGllY2VzXG5cdFx0XHRlbFxuXHRcdFx0XHQuY2xvbmUoKVxuXHRcdFx0XHQuYXBwZW5kVG8oIFwiYm9keVwiIClcblx0XHRcdFx0LndyYXAoIFwiPGRpdj48L2Rpdj5cIiApXG5cdFx0XHRcdC5jc3Moe1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG5cdFx0XHRcdFx0dmlzaWJpbGl0eTogXCJ2aXNpYmxlXCIsXG5cdFx0XHRcdFx0bGVmdDogLWogKiB3aWR0aCxcblx0XHRcdFx0XHR0b3A6IC1pICogaGVpZ2h0XG5cdFx0XHRcdH0pXG5cblx0XHRcdC8vIHNlbGVjdCB0aGUgd3JhcHBlciAtIG1ha2UgaXQgb3ZlcmZsb3c6IGhpZGRlbiBhbmQgYWJzb2x1dGUgcG9zaXRpb25lZCBiYXNlZCBvblxuXHRcdFx0Ly8gd2hlcmUgdGhlIG9yaWdpbmFsIHdhcyBsb2NhdGVkICtsZWZ0IGFuZCArdG9wIGVxdWFsIHRvIHRoZSBzaXplIG9mIHBpZWNlc1xuXHRcdFx0XHQucGFyZW50KClcblx0XHRcdFx0LmFkZENsYXNzKCBcInVpLWVmZmVjdHMtZXhwbG9kZVwiIClcblx0XHRcdFx0LmNzcyh7XG5cdFx0XHRcdFx0cG9zaXRpb246IFwiYWJzb2x1dGVcIixcblx0XHRcdFx0XHRvdmVyZmxvdzogXCJoaWRkZW5cIixcblx0XHRcdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHRcdFx0bGVmdDogbGVmdCArICggc2hvdyA/IG14ICogd2lkdGggOiAwICksXG5cdFx0XHRcdFx0dG9wOiB0b3AgKyAoIHNob3cgPyBteSAqIGhlaWdodCA6IDAgKSxcblx0XHRcdFx0XHRvcGFjaXR5OiBzaG93ID8gMCA6IDFcblx0XHRcdFx0fSkuYW5pbWF0ZSh7XG5cdFx0XHRcdFx0bGVmdDogbGVmdCArICggc2hvdyA/IDAgOiBteCAqIHdpZHRoICksXG5cdFx0XHRcdFx0dG9wOiB0b3AgKyAoIHNob3cgPyAwIDogbXkgKiBoZWlnaHQgKSxcblx0XHRcdFx0XHRvcGFjaXR5OiBzaG93ID8gMSA6IDBcblx0XHRcdFx0fSwgby5kdXJhdGlvbiB8fCA1MDAsIG8uZWFzaW5nLCBjaGlsZENvbXBsZXRlICk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYW5pbUNvbXBsZXRlKCkge1xuXHRcdGVsLmNzcyh7XG5cdFx0XHR2aXNpYmlsaXR5OiBcInZpc2libGVcIlxuXHRcdH0pO1xuXHRcdCQoIHBpZWNlcyApLnJlbW92ZSgpO1xuXHRcdGlmICggIXNob3cgKSB7XG5cdFx0XHRlbC5oaWRlKCk7XG5cdFx0fVxuXHRcdGRvbmUoKTtcblx0fVxufTtcblxufSkoalF1ZXJ5KTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLmVmZmVjdHMuZWZmZWN0LmZhZGUgPSBmdW5jdGlvbiggbywgZG9uZSApIHtcblx0dmFyIGVsID0gJCggdGhpcyApLFxuXHRcdG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZSggZWwsIG8ubW9kZSB8fCBcInRvZ2dsZVwiICk7XG5cblx0ZWwuYW5pbWF0ZSh7XG5cdFx0b3BhY2l0eTogbW9kZVxuXHR9LCB7XG5cdFx0cXVldWU6IGZhbHNlLFxuXHRcdGR1cmF0aW9uOiBvLmR1cmF0aW9uLFxuXHRcdGVhc2luZzogby5lYXNpbmcsXG5cdFx0Y29tcGxldGU6IGRvbmVcblx0fSk7XG59O1xuXG59KSggalF1ZXJ5ICk7XG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC5lZmZlY3RzLmVmZmVjdC5mb2xkID0gZnVuY3Rpb24oIG8sIGRvbmUgKSB7XG5cblx0Ly8gQ3JlYXRlIGVsZW1lbnRcblx0dmFyIGVsID0gJCggdGhpcyApLFxuXHRcdHByb3BzID0gWyBcInBvc2l0aW9uXCIsIFwidG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLFxuXHRcdG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZSggZWwsIG8ubW9kZSB8fCBcImhpZGVcIiApLFxuXHRcdHNob3cgPSBtb2RlID09PSBcInNob3dcIixcblx0XHRoaWRlID0gbW9kZSA9PT0gXCJoaWRlXCIsXG5cdFx0c2l6ZSA9IG8uc2l6ZSB8fCAxNSxcblx0XHRwZXJjZW50ID0gLyhbMC05XSspJS8uZXhlYyggc2l6ZSApLFxuXHRcdGhvcml6Rmlyc3QgPSAhIW8uaG9yaXpGaXJzdCxcblx0XHR3aWR0aEZpcnN0ID0gc2hvdyAhPT0gaG9yaXpGaXJzdCxcblx0XHRyZWYgPSB3aWR0aEZpcnN0ID8gWyBcIndpZHRoXCIsIFwiaGVpZ2h0XCIgXSA6IFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sXG5cdFx0ZHVyYXRpb24gPSBvLmR1cmF0aW9uIC8gMixcblx0XHR3cmFwcGVyLCBkaXN0YW5jZSxcblx0XHRhbmltYXRpb24xID0ge30sXG5cdFx0YW5pbWF0aW9uMiA9IHt9O1xuXG5cdCQuZWZmZWN0cy5zYXZlKCBlbCwgcHJvcHMgKTtcblx0ZWwuc2hvdygpO1xuXG5cdC8vIENyZWF0ZSBXcmFwcGVyXG5cdHdyYXBwZXIgPSAkLmVmZmVjdHMuY3JlYXRlV3JhcHBlciggZWwgKS5jc3Moe1xuXHRcdG92ZXJmbG93OiBcImhpZGRlblwiXG5cdH0pO1xuXHRkaXN0YW5jZSA9IHdpZHRoRmlyc3QgP1xuXHRcdFsgd3JhcHBlci53aWR0aCgpLCB3cmFwcGVyLmhlaWdodCgpIF0gOlxuXHRcdFsgd3JhcHBlci5oZWlnaHQoKSwgd3JhcHBlci53aWR0aCgpIF07XG5cblx0aWYgKCBwZXJjZW50ICkge1xuXHRcdHNpemUgPSBwYXJzZUludCggcGVyY2VudFsgMSBdLCAxMCApIC8gMTAwICogZGlzdGFuY2VbIGhpZGUgPyAwIDogMSBdO1xuXHR9XG5cdGlmICggc2hvdyApIHtcblx0XHR3cmFwcGVyLmNzcyggaG9yaXpGaXJzdCA/IHtcblx0XHRcdGhlaWdodDogMCxcblx0XHRcdHdpZHRoOiBzaXplXG5cdFx0fSA6IHtcblx0XHRcdGhlaWdodDogc2l6ZSxcblx0XHRcdHdpZHRoOiAwXG5cdFx0fSk7XG5cdH1cblxuXHQvLyBBbmltYXRpb25cblx0YW5pbWF0aW9uMVsgcmVmWyAwIF0gXSA9IHNob3cgPyBkaXN0YW5jZVsgMCBdIDogc2l6ZTtcblx0YW5pbWF0aW9uMlsgcmVmWyAxIF0gXSA9IHNob3cgPyBkaXN0YW5jZVsgMSBdIDogMDtcblxuXHQvLyBBbmltYXRlXG5cdHdyYXBwZXJcblx0XHQuYW5pbWF0ZSggYW5pbWF0aW9uMSwgZHVyYXRpb24sIG8uZWFzaW5nIClcblx0XHQuYW5pbWF0ZSggYW5pbWF0aW9uMiwgZHVyYXRpb24sIG8uZWFzaW5nLCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaGlkZSApIHtcblx0XHRcdFx0ZWwuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdFx0JC5lZmZlY3RzLnJlc3RvcmUoIGVsLCBwcm9wcyApO1xuXHRcdFx0JC5lZmZlY3RzLnJlbW92ZVdyYXBwZXIoIGVsICk7XG5cdFx0XHRkb25lKCk7XG5cdFx0fSk7XG5cbn07XG5cbn0pKGpRdWVyeSk7XG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC5lZmZlY3RzLmVmZmVjdC5oaWdobGlnaHQgPSBmdW5jdGlvbiggbywgZG9uZSApIHtcblx0dmFyIGVsZW0gPSAkKCB0aGlzICksXG5cdFx0cHJvcHMgPSBbIFwiYmFja2dyb3VuZEltYWdlXCIsIFwiYmFja2dyb3VuZENvbG9yXCIsIFwib3BhY2l0eVwiIF0sXG5cdFx0bW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKCBlbGVtLCBvLm1vZGUgfHwgXCJzaG93XCIgKSxcblx0XHRhbmltYXRpb24gPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGVsZW0uY3NzKCBcImJhY2tncm91bmRDb2xvclwiIClcblx0XHR9O1xuXG5cdGlmIChtb2RlID09PSBcImhpZGVcIikge1xuXHRcdGFuaW1hdGlvbi5vcGFjaXR5ID0gMDtcblx0fVxuXG5cdCQuZWZmZWN0cy5zYXZlKCBlbGVtLCBwcm9wcyApO1xuXG5cdGVsZW1cblx0XHQuc2hvdygpXG5cdFx0LmNzcyh7XG5cdFx0XHRiYWNrZ3JvdW5kSW1hZ2U6IFwibm9uZVwiLFxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBvLmNvbG9yIHx8IFwiI2ZmZmY5OVwiXG5cdFx0fSlcblx0XHQuYW5pbWF0ZSggYW5pbWF0aW9uLCB7XG5cdFx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0XHRkdXJhdGlvbjogby5kdXJhdGlvbixcblx0XHRcdGVhc2luZzogby5lYXNpbmcsXG5cdFx0XHRjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbW9kZSA9PT0gXCJoaWRlXCIgKSB7XG5cdFx0XHRcdFx0ZWxlbS5oaWRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0JC5lZmZlY3RzLnJlc3RvcmUoIGVsZW0sIHByb3BzICk7XG5cdFx0XHRcdGRvbmUoKTtcblx0XHRcdH1cblx0XHR9KTtcbn07XG5cbn0pKGpRdWVyeSk7XG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC5lZmZlY3RzLmVmZmVjdC5wdWxzYXRlID0gZnVuY3Rpb24oIG8sIGRvbmUgKSB7XG5cdHZhciBlbGVtID0gJCggdGhpcyApLFxuXHRcdG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZSggZWxlbSwgby5tb2RlIHx8IFwic2hvd1wiICksXG5cdFx0c2hvdyA9IG1vZGUgPT09IFwic2hvd1wiLFxuXHRcdGhpZGUgPSBtb2RlID09PSBcImhpZGVcIixcblx0XHRzaG93aGlkZSA9ICggc2hvdyB8fCBtb2RlID09PSBcImhpZGVcIiApLFxuXG5cdFx0Ly8gc2hvd2luZyBvciBoaWRpbmcgbGVhdmVzIG9mIHRoZSBcImxhc3RcIiBhbmltYXRpb25cblx0XHRhbmltcyA9ICggKCBvLnRpbWVzIHx8IDUgKSAqIDIgKSArICggc2hvd2hpZGUgPyAxIDogMCApLFxuXHRcdGR1cmF0aW9uID0gby5kdXJhdGlvbiAvIGFuaW1zLFxuXHRcdGFuaW1hdGVUbyA9IDAsXG5cdFx0cXVldWUgPSBlbGVtLnF1ZXVlKCksXG5cdFx0cXVldWVsZW4gPSBxdWV1ZS5sZW5ndGgsXG5cdFx0aTtcblxuXHRpZiAoIHNob3cgfHwgIWVsZW0uaXMoXCI6dmlzaWJsZVwiKSkge1xuXHRcdGVsZW0uY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKTtcblx0XHRhbmltYXRlVG8gPSAxO1xuXHR9XG5cblx0Ly8gYW5pbXMgLSAxIG9wYWNpdHkgXCJ0b2dnbGVzXCJcblx0Zm9yICggaSA9IDE7IGkgPCBhbmltczsgaSsrICkge1xuXHRcdGVsZW0uYW5pbWF0ZSh7XG5cdFx0XHRvcGFjaXR5OiBhbmltYXRlVG9cblx0XHR9LCBkdXJhdGlvbiwgby5lYXNpbmcgKTtcblx0XHRhbmltYXRlVG8gPSAxIC0gYW5pbWF0ZVRvO1xuXHR9XG5cblx0ZWxlbS5hbmltYXRlKHtcblx0XHRvcGFjaXR5OiBhbmltYXRlVG9cblx0fSwgZHVyYXRpb24sIG8uZWFzaW5nKTtcblxuXHRlbGVtLnF1ZXVlKGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaGlkZSApIHtcblx0XHRcdGVsZW0uaGlkZSgpO1xuXHRcdH1cblx0XHRkb25lKCk7XG5cdH0pO1xuXG5cdC8vIFdlIGp1c3QgcXVldWVkIHVwIFwiYW5pbXNcIiBhbmltYXRpb25zLCB3ZSBuZWVkIHRvIHB1dCB0aGVtIG5leHQgaW4gdGhlIHF1ZXVlXG5cdGlmICggcXVldWVsZW4gPiAxICkge1xuXHRcdHF1ZXVlLnNwbGljZS5hcHBseSggcXVldWUsXG5cdFx0XHRbIDEsIDAgXS5jb25jYXQoIHF1ZXVlLnNwbGljZSggcXVldWVsZW4sIGFuaW1zICsgMSApICkgKTtcblx0fVxuXHRlbGVtLmRlcXVldWUoKTtcbn07XG5cbn0pKGpRdWVyeSk7XG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC5lZmZlY3RzLmVmZmVjdC5wdWZmID0gZnVuY3Rpb24oIG8sIGRvbmUgKSB7XG5cdHZhciBlbGVtID0gJCggdGhpcyApLFxuXHRcdG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZSggZWxlbSwgby5tb2RlIHx8IFwiaGlkZVwiICksXG5cdFx0aGlkZSA9IG1vZGUgPT09IFwiaGlkZVwiLFxuXHRcdHBlcmNlbnQgPSBwYXJzZUludCggby5wZXJjZW50LCAxMCApIHx8IDE1MCxcblx0XHRmYWN0b3IgPSBwZXJjZW50IC8gMTAwLFxuXHRcdG9yaWdpbmFsID0ge1xuXHRcdFx0aGVpZ2h0OiBlbGVtLmhlaWdodCgpLFxuXHRcdFx0d2lkdGg6IGVsZW0ud2lkdGgoKSxcblx0XHRcdG91dGVySGVpZ2h0OiBlbGVtLm91dGVySGVpZ2h0KCksXG5cdFx0XHRvdXRlcldpZHRoOiBlbGVtLm91dGVyV2lkdGgoKVxuXHRcdH07XG5cblx0JC5leHRlbmQoIG8sIHtcblx0XHRlZmZlY3Q6IFwic2NhbGVcIixcblx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0ZmFkZTogdHJ1ZSxcblx0XHRtb2RlOiBtb2RlLFxuXHRcdGNvbXBsZXRlOiBkb25lLFxuXHRcdHBlcmNlbnQ6IGhpZGUgPyBwZXJjZW50IDogMTAwLFxuXHRcdGZyb206IGhpZGUgP1xuXHRcdFx0b3JpZ2luYWwgOlxuXHRcdFx0e1xuXHRcdFx0XHRoZWlnaHQ6IG9yaWdpbmFsLmhlaWdodCAqIGZhY3Rvcixcblx0XHRcdFx0d2lkdGg6IG9yaWdpbmFsLndpZHRoICogZmFjdG9yLFxuXHRcdFx0XHRvdXRlckhlaWdodDogb3JpZ2luYWwub3V0ZXJIZWlnaHQgKiBmYWN0b3IsXG5cdFx0XHRcdG91dGVyV2lkdGg6IG9yaWdpbmFsLm91dGVyV2lkdGggKiBmYWN0b3Jcblx0XHRcdH1cblx0fSk7XG5cblx0ZWxlbS5lZmZlY3QoIG8gKTtcbn07XG5cbiQuZWZmZWN0cy5lZmZlY3Quc2NhbGUgPSBmdW5jdGlvbiggbywgZG9uZSApIHtcblxuXHQvLyBDcmVhdGUgZWxlbWVudFxuXHR2YXIgZWwgPSAkKCB0aGlzICksXG5cdFx0b3B0aW9ucyA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgbyApLFxuXHRcdG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZSggZWwsIG8ubW9kZSB8fCBcImVmZmVjdFwiICksXG5cdFx0cGVyY2VudCA9IHBhcnNlSW50KCBvLnBlcmNlbnQsIDEwICkgfHxcblx0XHRcdCggcGFyc2VJbnQoIG8ucGVyY2VudCwgMTAgKSA9PT0gMCA/IDAgOiAoIG1vZGUgPT09IFwiaGlkZVwiID8gMCA6IDEwMCApICksXG5cdFx0ZGlyZWN0aW9uID0gby5kaXJlY3Rpb24gfHwgXCJib3RoXCIsXG5cdFx0b3JpZ2luID0gby5vcmlnaW4sXG5cdFx0b3JpZ2luYWwgPSB7XG5cdFx0XHRoZWlnaHQ6IGVsLmhlaWdodCgpLFxuXHRcdFx0d2lkdGg6IGVsLndpZHRoKCksXG5cdFx0XHRvdXRlckhlaWdodDogZWwub3V0ZXJIZWlnaHQoKSxcblx0XHRcdG91dGVyV2lkdGg6IGVsLm91dGVyV2lkdGgoKVxuXHRcdH0sXG5cdFx0ZmFjdG9yID0ge1xuXHRcdFx0eTogZGlyZWN0aW9uICE9PSBcImhvcml6b250YWxcIiA/IChwZXJjZW50IC8gMTAwKSA6IDEsXG5cdFx0XHR4OiBkaXJlY3Rpb24gIT09IFwidmVydGljYWxcIiA/IChwZXJjZW50IC8gMTAwKSA6IDFcblx0XHR9O1xuXG5cdC8vIFdlIGFyZSBnb2luZyB0byBwYXNzIHRoaXMgZWZmZWN0IHRvIHRoZSBzaXplIGVmZmVjdDpcblx0b3B0aW9ucy5lZmZlY3QgPSBcInNpemVcIjtcblx0b3B0aW9ucy5xdWV1ZSA9IGZhbHNlO1xuXHRvcHRpb25zLmNvbXBsZXRlID0gZG9uZTtcblxuXHQvLyBTZXQgZGVmYXVsdCBvcmlnaW4gYW5kIHJlc3RvcmUgZm9yIHNob3cvaGlkZVxuXHRpZiAoIG1vZGUgIT09IFwiZWZmZWN0XCIgKSB7XG5cdFx0b3B0aW9ucy5vcmlnaW4gPSBvcmlnaW4gfHwgW1wibWlkZGxlXCIsXCJjZW50ZXJcIl07XG5cdFx0b3B0aW9ucy5yZXN0b3JlID0gdHJ1ZTtcblx0fVxuXG5cdG9wdGlvbnMuZnJvbSA9IG8uZnJvbSB8fCAoIG1vZGUgPT09IFwic2hvd1wiID8ge1xuXHRcdGhlaWdodDogMCxcblx0XHR3aWR0aDogMCxcblx0XHRvdXRlckhlaWdodDogMCxcblx0XHRvdXRlcldpZHRoOiAwXG5cdH0gOiBvcmlnaW5hbCApO1xuXHRvcHRpb25zLnRvID0ge1xuXHRcdGhlaWdodDogb3JpZ2luYWwuaGVpZ2h0ICogZmFjdG9yLnksXG5cdFx0d2lkdGg6IG9yaWdpbmFsLndpZHRoICogZmFjdG9yLngsXG5cdFx0b3V0ZXJIZWlnaHQ6IG9yaWdpbmFsLm91dGVySGVpZ2h0ICogZmFjdG9yLnksXG5cdFx0b3V0ZXJXaWR0aDogb3JpZ2luYWwub3V0ZXJXaWR0aCAqIGZhY3Rvci54XG5cdH07XG5cblx0Ly8gRmFkZSBvcHRpb24gdG8gc3VwcG9ydCBwdWZmXG5cdGlmICggb3B0aW9ucy5mYWRlICkge1xuXHRcdGlmICggbW9kZSA9PT0gXCJzaG93XCIgKSB7XG5cdFx0XHRvcHRpb25zLmZyb20ub3BhY2l0eSA9IDA7XG5cdFx0XHRvcHRpb25zLnRvLm9wYWNpdHkgPSAxO1xuXHRcdH1cblx0XHRpZiAoIG1vZGUgPT09IFwiaGlkZVwiICkge1xuXHRcdFx0b3B0aW9ucy5mcm9tLm9wYWNpdHkgPSAxO1xuXHRcdFx0b3B0aW9ucy50by5vcGFjaXR5ID0gMDtcblx0XHR9XG5cdH1cblxuXHQvLyBBbmltYXRlXG5cdGVsLmVmZmVjdCggb3B0aW9ucyApO1xuXG59O1xuXG4kLmVmZmVjdHMuZWZmZWN0LnNpemUgPSBmdW5jdGlvbiggbywgZG9uZSApIHtcblxuXHQvLyBDcmVhdGUgZWxlbWVudFxuXHR2YXIgb3JpZ2luYWwsIGJhc2VsaW5lLCBmYWN0b3IsXG5cdFx0ZWwgPSAkKCB0aGlzICksXG5cdFx0cHJvcHMwID0gWyBcInBvc2l0aW9uXCIsIFwidG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJvdmVyZmxvd1wiLCBcIm9wYWNpdHlcIiBdLFxuXG5cdFx0Ly8gQWx3YXlzIHJlc3RvcmVcblx0XHRwcm9wczEgPSBbIFwicG9zaXRpb25cIiwgXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJvdmVyZmxvd1wiLCBcIm9wYWNpdHlcIiBdLFxuXG5cdFx0Ly8gQ29weSBmb3IgY2hpbGRyZW5cblx0XHRwcm9wczIgPSBbIFwid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJvdmVyZmxvd1wiIF0sXG5cdFx0Y1Byb3BzID0gWyBcImZvbnRTaXplXCIgXSxcblx0XHR2UHJvcHMgPSBbIFwiYm9yZGVyVG9wV2lkdGhcIiwgXCJib3JkZXJCb3R0b21XaWR0aFwiLCBcInBhZGRpbmdUb3BcIiwgXCJwYWRkaW5nQm90dG9tXCIgXSxcblx0XHRoUHJvcHMgPSBbIFwiYm9yZGVyTGVmdFdpZHRoXCIsIFwiYm9yZGVyUmlnaHRXaWR0aFwiLCBcInBhZGRpbmdMZWZ0XCIsIFwicGFkZGluZ1JpZ2h0XCIgXSxcblxuXHRcdC8vIFNldCBvcHRpb25zXG5cdFx0bW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKCBlbCwgby5tb2RlIHx8IFwiZWZmZWN0XCIgKSxcblx0XHRyZXN0b3JlID0gby5yZXN0b3JlIHx8IG1vZGUgIT09IFwiZWZmZWN0XCIsXG5cdFx0c2NhbGUgPSBvLnNjYWxlIHx8IFwiYm90aFwiLFxuXHRcdG9yaWdpbiA9IG8ub3JpZ2luIHx8IFsgXCJtaWRkbGVcIiwgXCJjZW50ZXJcIiBdLFxuXHRcdHBvc2l0aW9uID0gZWwuY3NzKCBcInBvc2l0aW9uXCIgKSxcblx0XHRwcm9wcyA9IHJlc3RvcmUgPyBwcm9wczAgOiBwcm9wczEsXG5cdFx0emVybyA9IHtcblx0XHRcdGhlaWdodDogMCxcblx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0b3V0ZXJIZWlnaHQ6IDAsXG5cdFx0XHRvdXRlcldpZHRoOiAwXG5cdFx0fTtcblxuXHRpZiAoIG1vZGUgPT09IFwic2hvd1wiICkge1xuXHRcdGVsLnNob3coKTtcblx0fVxuXHRvcmlnaW5hbCA9IHtcblx0XHRoZWlnaHQ6IGVsLmhlaWdodCgpLFxuXHRcdHdpZHRoOiBlbC53aWR0aCgpLFxuXHRcdG91dGVySGVpZ2h0OiBlbC5vdXRlckhlaWdodCgpLFxuXHRcdG91dGVyV2lkdGg6IGVsLm91dGVyV2lkdGgoKVxuXHR9O1xuXG5cdGlmICggby5tb2RlID09PSBcInRvZ2dsZVwiICYmIG1vZGUgPT09IFwic2hvd1wiICkge1xuXHRcdGVsLmZyb20gPSBvLnRvIHx8IHplcm87XG5cdFx0ZWwudG8gPSBvLmZyb20gfHwgb3JpZ2luYWw7XG5cdH0gZWxzZSB7XG5cdFx0ZWwuZnJvbSA9IG8uZnJvbSB8fCAoIG1vZGUgPT09IFwic2hvd1wiID8gemVybyA6IG9yaWdpbmFsICk7XG5cdFx0ZWwudG8gPSBvLnRvIHx8ICggbW9kZSA9PT0gXCJoaWRlXCIgPyB6ZXJvIDogb3JpZ2luYWwgKTtcblx0fVxuXG5cdC8vIFNldCBzY2FsaW5nIGZhY3RvclxuXHRmYWN0b3IgPSB7XG5cdFx0ZnJvbToge1xuXHRcdFx0eTogZWwuZnJvbS5oZWlnaHQgLyBvcmlnaW5hbC5oZWlnaHQsXG5cdFx0XHR4OiBlbC5mcm9tLndpZHRoIC8gb3JpZ2luYWwud2lkdGhcblx0XHR9LFxuXHRcdHRvOiB7XG5cdFx0XHR5OiBlbC50by5oZWlnaHQgLyBvcmlnaW5hbC5oZWlnaHQsXG5cdFx0XHR4OiBlbC50by53aWR0aCAvIG9yaWdpbmFsLndpZHRoXG5cdFx0fVxuXHR9O1xuXG5cdC8vIFNjYWxlIHRoZSBjc3MgYm94XG5cdGlmICggc2NhbGUgPT09IFwiYm94XCIgfHwgc2NhbGUgPT09IFwiYm90aFwiICkge1xuXG5cdFx0Ly8gVmVydGljYWwgcHJvcHMgc2NhbGluZ1xuXHRcdGlmICggZmFjdG9yLmZyb20ueSAhPT0gZmFjdG9yLnRvLnkgKSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLmNvbmNhdCggdlByb3BzICk7XG5cdFx0XHRlbC5mcm9tID0gJC5lZmZlY3RzLnNldFRyYW5zaXRpb24oIGVsLCB2UHJvcHMsIGZhY3Rvci5mcm9tLnksIGVsLmZyb20gKTtcblx0XHRcdGVsLnRvID0gJC5lZmZlY3RzLnNldFRyYW5zaXRpb24oIGVsLCB2UHJvcHMsIGZhY3Rvci50by55LCBlbC50byApO1xuXHRcdH1cblxuXHRcdC8vIEhvcml6b250YWwgcHJvcHMgc2NhbGluZ1xuXHRcdGlmICggZmFjdG9yLmZyb20ueCAhPT0gZmFjdG9yLnRvLnggKSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLmNvbmNhdCggaFByb3BzICk7XG5cdFx0XHRlbC5mcm9tID0gJC5lZmZlY3RzLnNldFRyYW5zaXRpb24oIGVsLCBoUHJvcHMsIGZhY3Rvci5mcm9tLngsIGVsLmZyb20gKTtcblx0XHRcdGVsLnRvID0gJC5lZmZlY3RzLnNldFRyYW5zaXRpb24oIGVsLCBoUHJvcHMsIGZhY3Rvci50by54LCBlbC50byApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFNjYWxlIHRoZSBjb250ZW50XG5cdGlmICggc2NhbGUgPT09IFwiY29udGVudFwiIHx8IHNjYWxlID09PSBcImJvdGhcIiApIHtcblxuXHRcdC8vIFZlcnRpY2FsIHByb3BzIHNjYWxpbmdcblx0XHRpZiAoIGZhY3Rvci5mcm9tLnkgIT09IGZhY3Rvci50by55ICkge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5jb25jYXQoIGNQcm9wcyApLmNvbmNhdCggcHJvcHMyICk7XG5cdFx0XHRlbC5mcm9tID0gJC5lZmZlY3RzLnNldFRyYW5zaXRpb24oIGVsLCBjUHJvcHMsIGZhY3Rvci5mcm9tLnksIGVsLmZyb20gKTtcblx0XHRcdGVsLnRvID0gJC5lZmZlY3RzLnNldFRyYW5zaXRpb24oIGVsLCBjUHJvcHMsIGZhY3Rvci50by55LCBlbC50byApO1xuXHRcdH1cblx0fVxuXG5cdCQuZWZmZWN0cy5zYXZlKCBlbCwgcHJvcHMgKTtcblx0ZWwuc2hvdygpO1xuXHQkLmVmZmVjdHMuY3JlYXRlV3JhcHBlciggZWwgKTtcblx0ZWwuY3NzKCBcIm92ZXJmbG93XCIsIFwiaGlkZGVuXCIgKS5jc3MoIGVsLmZyb20gKTtcblxuXHQvLyBBZGp1c3Rcblx0aWYgKG9yaWdpbikgeyAvLyBDYWxjdWxhdGUgYmFzZWxpbmUgc2hpZnRzXG5cdFx0YmFzZWxpbmUgPSAkLmVmZmVjdHMuZ2V0QmFzZWxpbmUoIG9yaWdpbiwgb3JpZ2luYWwgKTtcblx0XHRlbC5mcm9tLnRvcCA9ICggb3JpZ2luYWwub3V0ZXJIZWlnaHQgLSBlbC5vdXRlckhlaWdodCgpICkgKiBiYXNlbGluZS55O1xuXHRcdGVsLmZyb20ubGVmdCA9ICggb3JpZ2luYWwub3V0ZXJXaWR0aCAtIGVsLm91dGVyV2lkdGgoKSApICogYmFzZWxpbmUueDtcblx0XHRlbC50by50b3AgPSAoIG9yaWdpbmFsLm91dGVySGVpZ2h0IC0gZWwudG8ub3V0ZXJIZWlnaHQgKSAqIGJhc2VsaW5lLnk7XG5cdFx0ZWwudG8ubGVmdCA9ICggb3JpZ2luYWwub3V0ZXJXaWR0aCAtIGVsLnRvLm91dGVyV2lkdGggKSAqIGJhc2VsaW5lLng7XG5cdH1cblx0ZWwuY3NzKCBlbC5mcm9tICk7IC8vIHNldCB0b3AgJiBsZWZ0XG5cblx0Ly8gQW5pbWF0ZVxuXHRpZiAoIHNjYWxlID09PSBcImNvbnRlbnRcIiB8fCBzY2FsZSA9PT0gXCJib3RoXCIgKSB7IC8vIFNjYWxlIHRoZSBjaGlsZHJlblxuXG5cdFx0Ly8gQWRkIG1hcmdpbnMvZm9udC1zaXplXG5cdFx0dlByb3BzID0gdlByb3BzLmNvbmNhdChbIFwibWFyZ2luVG9wXCIsIFwibWFyZ2luQm90dG9tXCIgXSkuY29uY2F0KGNQcm9wcyk7XG5cdFx0aFByb3BzID0gaFByb3BzLmNvbmNhdChbIFwibWFyZ2luTGVmdFwiLCBcIm1hcmdpblJpZ2h0XCIgXSk7XG5cdFx0cHJvcHMyID0gcHJvcHMwLmNvbmNhdCh2UHJvcHMpLmNvbmNhdChoUHJvcHMpO1xuXG5cdFx0ZWwuZmluZCggXCIqW3dpZHRoXVwiICkuZWFjaCggZnVuY3Rpb24oKXtcblx0XHRcdHZhciBjaGlsZCA9ICQoIHRoaXMgKSxcblx0XHRcdFx0Y19vcmlnaW5hbCA9IHtcblx0XHRcdFx0XHRoZWlnaHQ6IGNoaWxkLmhlaWdodCgpLFxuXHRcdFx0XHRcdHdpZHRoOiBjaGlsZC53aWR0aCgpLFxuXHRcdFx0XHRcdG91dGVySGVpZ2h0OiBjaGlsZC5vdXRlckhlaWdodCgpLFxuXHRcdFx0XHRcdG91dGVyV2lkdGg6IGNoaWxkLm91dGVyV2lkdGgoKVxuXHRcdFx0XHR9O1xuXHRcdFx0aWYgKHJlc3RvcmUpIHtcblx0XHRcdFx0JC5lZmZlY3RzLnNhdmUoY2hpbGQsIHByb3BzMik7XG5cdFx0XHR9XG5cblx0XHRcdGNoaWxkLmZyb20gPSB7XG5cdFx0XHRcdGhlaWdodDogY19vcmlnaW5hbC5oZWlnaHQgKiBmYWN0b3IuZnJvbS55LFxuXHRcdFx0XHR3aWR0aDogY19vcmlnaW5hbC53aWR0aCAqIGZhY3Rvci5mcm9tLngsXG5cdFx0XHRcdG91dGVySGVpZ2h0OiBjX29yaWdpbmFsLm91dGVySGVpZ2h0ICogZmFjdG9yLmZyb20ueSxcblx0XHRcdFx0b3V0ZXJXaWR0aDogY19vcmlnaW5hbC5vdXRlcldpZHRoICogZmFjdG9yLmZyb20ueFxuXHRcdFx0fTtcblx0XHRcdGNoaWxkLnRvID0ge1xuXHRcdFx0XHRoZWlnaHQ6IGNfb3JpZ2luYWwuaGVpZ2h0ICogZmFjdG9yLnRvLnksXG5cdFx0XHRcdHdpZHRoOiBjX29yaWdpbmFsLndpZHRoICogZmFjdG9yLnRvLngsXG5cdFx0XHRcdG91dGVySGVpZ2h0OiBjX29yaWdpbmFsLmhlaWdodCAqIGZhY3Rvci50by55LFxuXHRcdFx0XHRvdXRlcldpZHRoOiBjX29yaWdpbmFsLndpZHRoICogZmFjdG9yLnRvLnhcblx0XHRcdH07XG5cblx0XHRcdC8vIFZlcnRpY2FsIHByb3BzIHNjYWxpbmdcblx0XHRcdGlmICggZmFjdG9yLmZyb20ueSAhPT0gZmFjdG9yLnRvLnkgKSB7XG5cdFx0XHRcdGNoaWxkLmZyb20gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbiggY2hpbGQsIHZQcm9wcywgZmFjdG9yLmZyb20ueSwgY2hpbGQuZnJvbSApO1xuXHRcdFx0XHRjaGlsZC50byA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBjaGlsZCwgdlByb3BzLCBmYWN0b3IudG8ueSwgY2hpbGQudG8gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9yaXpvbnRhbCBwcm9wcyBzY2FsaW5nXG5cdFx0XHRpZiAoIGZhY3Rvci5mcm9tLnggIT09IGZhY3Rvci50by54ICkge1xuXHRcdFx0XHRjaGlsZC5mcm9tID0gJC5lZmZlY3RzLnNldFRyYW5zaXRpb24oIGNoaWxkLCBoUHJvcHMsIGZhY3Rvci5mcm9tLngsIGNoaWxkLmZyb20gKTtcblx0XHRcdFx0Y2hpbGQudG8gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbiggY2hpbGQsIGhQcm9wcywgZmFjdG9yLnRvLngsIGNoaWxkLnRvICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFuaW1hdGUgY2hpbGRyZW5cblx0XHRcdGNoaWxkLmNzcyggY2hpbGQuZnJvbSApO1xuXHRcdFx0Y2hpbGQuYW5pbWF0ZSggY2hpbGQudG8sIG8uZHVyYXRpb24sIG8uZWFzaW5nLCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIGNoaWxkcmVuXG5cdFx0XHRcdGlmICggcmVzdG9yZSApIHtcblx0XHRcdFx0XHQkLmVmZmVjdHMucmVzdG9yZSggY2hpbGQsIHByb3BzMiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIEFuaW1hdGVcblx0ZWwuYW5pbWF0ZSggZWwudG8sIHtcblx0XHRxdWV1ZTogZmFsc2UsXG5cdFx0ZHVyYXRpb246IG8uZHVyYXRpb24sXG5cdFx0ZWFzaW5nOiBvLmVhc2luZyxcblx0XHRjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGVsLnRvLm9wYWNpdHkgPT09IDAgKSB7XG5cdFx0XHRcdGVsLmNzcyggXCJvcGFjaXR5XCIsIGVsLmZyb20ub3BhY2l0eSApO1xuXHRcdFx0fVxuXHRcdFx0aWYoIG1vZGUgPT09IFwiaGlkZVwiICkge1xuXHRcdFx0XHRlbC5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0XHQkLmVmZmVjdHMucmVzdG9yZSggZWwsIHByb3BzICk7XG5cdFx0XHRpZiAoICFyZXN0b3JlICkge1xuXG5cdFx0XHRcdC8vIHdlIG5lZWQgdG8gY2FsY3VsYXRlIG91ciBuZXcgcG9zaXRpb25pbmcgYmFzZWQgb24gdGhlIHNjYWxpbmdcblx0XHRcdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0XHRlbC5jc3Moe1xuXHRcdFx0XHRcdFx0cG9zaXRpb246IFwicmVsYXRpdmVcIixcblx0XHRcdFx0XHRcdHRvcDogZWwudG8udG9wLFxuXHRcdFx0XHRcdFx0bGVmdDogZWwudG8ubGVmdFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCQuZWFjaChbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpZHgsIHBvcyApIHtcblx0XHRcdFx0XHRcdGVsLmNzcyggcG9zLCBmdW5jdGlvbiggXywgc3RyICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdmFsID0gcGFyc2VJbnQoIHN0ciwgMTAgKSxcblx0XHRcdFx0XHRcdFx0XHR0b1JlZiA9IGlkeCA/IGVsLnRvLmxlZnQgOiBlbC50by50b3A7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgb3JpZ2luYWwgd2FzIFwiYXV0b1wiLCByZWNhbGN1bGF0ZSB0aGUgbmV3IHZhbHVlIGZyb20gd3JhcHBlclxuXHRcdFx0XHRcdFx0XHRpZiAoIHN0ciA9PT0gXCJhdXRvXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRvUmVmICsgXCJweFwiO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbCArIHRvUmVmICsgXCJweFwiO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0JC5lZmZlY3RzLnJlbW92ZVdyYXBwZXIoIGVsICk7XG5cdFx0XHRkb25lKCk7XG5cdFx0fVxuXHR9KTtcblxufTtcblxufSkoalF1ZXJ5KTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLmVmZmVjdHMuZWZmZWN0LnNoYWtlID0gZnVuY3Rpb24oIG8sIGRvbmUgKSB7XG5cblx0dmFyIGVsID0gJCggdGhpcyApLFxuXHRcdHByb3BzID0gWyBcInBvc2l0aW9uXCIsIFwidG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLFxuXHRcdG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZSggZWwsIG8ubW9kZSB8fCBcImVmZmVjdFwiICksXG5cdFx0ZGlyZWN0aW9uID0gby5kaXJlY3Rpb24gfHwgXCJsZWZ0XCIsXG5cdFx0ZGlzdGFuY2UgPSBvLmRpc3RhbmNlIHx8IDIwLFxuXHRcdHRpbWVzID0gby50aW1lcyB8fCAzLFxuXHRcdGFuaW1zID0gdGltZXMgKiAyICsgMSxcblx0XHRzcGVlZCA9IE1hdGgucm91bmQoby5kdXJhdGlvbi9hbmltcyksXG5cdFx0cmVmID0gKGRpcmVjdGlvbiA9PT0gXCJ1cFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJkb3duXCIpID8gXCJ0b3BcIiA6IFwibGVmdFwiLFxuXHRcdHBvc2l0aXZlTW90aW9uID0gKGRpcmVjdGlvbiA9PT0gXCJ1cFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIpLFxuXHRcdGFuaW1hdGlvbiA9IHt9LFxuXHRcdGFuaW1hdGlvbjEgPSB7fSxcblx0XHRhbmltYXRpb24yID0ge30sXG5cdFx0aSxcblxuXHRcdC8vIHdlIHdpbGwgbmVlZCB0byByZS1hc3NlbWJsZSB0aGUgcXVldWUgdG8gc3RhY2sgb3VyIGFuaW1hdGlvbnMgaW4gcGxhY2Vcblx0XHRxdWV1ZSA9IGVsLnF1ZXVlKCksXG5cdFx0cXVldWVsZW4gPSBxdWV1ZS5sZW5ndGg7XG5cblx0JC5lZmZlY3RzLnNhdmUoIGVsLCBwcm9wcyApO1xuXHRlbC5zaG93KCk7XG5cdCQuZWZmZWN0cy5jcmVhdGVXcmFwcGVyKCBlbCApO1xuXG5cdC8vIEFuaW1hdGlvblxuXHRhbmltYXRpb25bIHJlZiBdID0gKCBwb3NpdGl2ZU1vdGlvbiA/IFwiLT1cIiA6IFwiKz1cIiApICsgZGlzdGFuY2U7XG5cdGFuaW1hdGlvbjFbIHJlZiBdID0gKCBwb3NpdGl2ZU1vdGlvbiA/IFwiKz1cIiA6IFwiLT1cIiApICsgZGlzdGFuY2UgKiAyO1xuXHRhbmltYXRpb24yWyByZWYgXSA9ICggcG9zaXRpdmVNb3Rpb24gPyBcIi09XCIgOiBcIis9XCIgKSArIGRpc3RhbmNlICogMjtcblxuXHQvLyBBbmltYXRlXG5cdGVsLmFuaW1hdGUoIGFuaW1hdGlvbiwgc3BlZWQsIG8uZWFzaW5nICk7XG5cblx0Ly8gU2hha2VzXG5cdGZvciAoIGkgPSAxOyBpIDwgdGltZXM7IGkrKyApIHtcblx0XHRlbC5hbmltYXRlKCBhbmltYXRpb24xLCBzcGVlZCwgby5lYXNpbmcgKS5hbmltYXRlKCBhbmltYXRpb24yLCBzcGVlZCwgby5lYXNpbmcgKTtcblx0fVxuXHRlbFxuXHRcdC5hbmltYXRlKCBhbmltYXRpb24xLCBzcGVlZCwgby5lYXNpbmcgKVxuXHRcdC5hbmltYXRlKCBhbmltYXRpb24sIHNwZWVkIC8gMiwgby5lYXNpbmcgKVxuXHRcdC5xdWV1ZShmdW5jdGlvbigpIHtcblx0XHRcdGlmICggbW9kZSA9PT0gXCJoaWRlXCIgKSB7XG5cdFx0XHRcdGVsLmhpZGUoKTtcblx0XHRcdH1cblx0XHRcdCQuZWZmZWN0cy5yZXN0b3JlKCBlbCwgcHJvcHMgKTtcblx0XHRcdCQuZWZmZWN0cy5yZW1vdmVXcmFwcGVyKCBlbCApO1xuXHRcdFx0ZG9uZSgpO1xuXHRcdH0pO1xuXG5cdC8vIGluamVjdCBhbGwgdGhlIGFuaW1hdGlvbnMgd2UganVzdCBxdWV1ZWQgdG8gYmUgZmlyc3QgaW4gbGluZSAoYWZ0ZXIgXCJpbnByb2dyZXNzXCIpXG5cdGlmICggcXVldWVsZW4gPiAxKSB7XG5cdFx0cXVldWUuc3BsaWNlLmFwcGx5KCBxdWV1ZSxcblx0XHRcdFsgMSwgMCBdLmNvbmNhdCggcXVldWUuc3BsaWNlKCBxdWV1ZWxlbiwgYW5pbXMgKyAxICkgKSApO1xuXHR9XG5cdGVsLmRlcXVldWUoKTtcblxufTtcblxufSkoalF1ZXJ5KTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLmVmZmVjdHMuZWZmZWN0LnNsaWRlID0gZnVuY3Rpb24oIG8sIGRvbmUgKSB7XG5cblx0Ly8gQ3JlYXRlIGVsZW1lbnRcblx0dmFyIGVsID0gJCggdGhpcyApLFxuXHRcdHByb3BzID0gWyBcInBvc2l0aW9uXCIsIFwidG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiBdLFxuXHRcdG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZSggZWwsIG8ubW9kZSB8fCBcInNob3dcIiApLFxuXHRcdHNob3cgPSBtb2RlID09PSBcInNob3dcIixcblx0XHRkaXJlY3Rpb24gPSBvLmRpcmVjdGlvbiB8fCBcImxlZnRcIixcblx0XHRyZWYgPSAoZGlyZWN0aW9uID09PSBcInVwXCIgfHwgZGlyZWN0aW9uID09PSBcImRvd25cIikgPyBcInRvcFwiIDogXCJsZWZ0XCIsXG5cdFx0cG9zaXRpdmVNb3Rpb24gPSAoZGlyZWN0aW9uID09PSBcInVwXCIgfHwgZGlyZWN0aW9uID09PSBcImxlZnRcIiksXG5cdFx0ZGlzdGFuY2UsXG5cdFx0YW5pbWF0aW9uID0ge307XG5cblx0Ly8gQWRqdXN0XG5cdCQuZWZmZWN0cy5zYXZlKCBlbCwgcHJvcHMgKTtcblx0ZWwuc2hvdygpO1xuXHRkaXN0YW5jZSA9IG8uZGlzdGFuY2UgfHwgZWxbIHJlZiA9PT0gXCJ0b3BcIiA/IFwib3V0ZXJIZWlnaHRcIiA6IFwib3V0ZXJXaWR0aFwiIF0oIHRydWUgKTtcblxuXHQkLmVmZmVjdHMuY3JlYXRlV3JhcHBlciggZWwgKS5jc3Moe1xuXHRcdG92ZXJmbG93OiBcImhpZGRlblwiXG5cdH0pO1xuXG5cdGlmICggc2hvdyApIHtcblx0XHRlbC5jc3MoIHJlZiwgcG9zaXRpdmVNb3Rpb24gPyAoaXNOYU4oZGlzdGFuY2UpID8gXCItXCIgKyBkaXN0YW5jZSA6IC1kaXN0YW5jZSkgOiBkaXN0YW5jZSApO1xuXHR9XG5cblx0Ly8gQW5pbWF0aW9uXG5cdGFuaW1hdGlvblsgcmVmIF0gPSAoIHNob3cgP1xuXHRcdCggcG9zaXRpdmVNb3Rpb24gPyBcIis9XCIgOiBcIi09XCIpIDpcblx0XHQoIHBvc2l0aXZlTW90aW9uID8gXCItPVwiIDogXCIrPVwiKSkgK1xuXHRcdGRpc3RhbmNlO1xuXG5cdC8vIEFuaW1hdGVcblx0ZWwuYW5pbWF0ZSggYW5pbWF0aW9uLCB7XG5cdFx0cXVldWU6IGZhbHNlLFxuXHRcdGR1cmF0aW9uOiBvLmR1cmF0aW9uLFxuXHRcdGVhc2luZzogby5lYXNpbmcsXG5cdFx0Y29tcGxldGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBtb2RlID09PSBcImhpZGVcIiApIHtcblx0XHRcdFx0ZWwuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdFx0JC5lZmZlY3RzLnJlc3RvcmUoIGVsLCBwcm9wcyApO1xuXHRcdFx0JC5lZmZlY3RzLnJlbW92ZVdyYXBwZXIoIGVsICk7XG5cdFx0XHRkb25lKCk7XG5cdFx0fVxuXHR9KTtcbn07XG5cbn0pKGpRdWVyeSk7XG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC5lZmZlY3RzLmVmZmVjdC50cmFuc2ZlciA9IGZ1bmN0aW9uKCBvLCBkb25lICkge1xuXHR2YXIgZWxlbSA9ICQoIHRoaXMgKSxcblx0XHR0YXJnZXQgPSAkKCBvLnRvICksXG5cdFx0dGFyZ2V0Rml4ZWQgPSB0YXJnZXQuY3NzKCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiLFxuXHRcdGJvZHkgPSAkKFwiYm9keVwiKSxcblx0XHRmaXhUb3AgPSB0YXJnZXRGaXhlZCA/IGJvZHkuc2Nyb2xsVG9wKCkgOiAwLFxuXHRcdGZpeExlZnQgPSB0YXJnZXRGaXhlZCA/IGJvZHkuc2Nyb2xsTGVmdCgpIDogMCxcblx0XHRlbmRQb3NpdGlvbiA9IHRhcmdldC5vZmZzZXQoKSxcblx0XHRhbmltYXRpb24gPSB7XG5cdFx0XHR0b3A6IGVuZFBvc2l0aW9uLnRvcCAtIGZpeFRvcCAsXG5cdFx0XHRsZWZ0OiBlbmRQb3NpdGlvbi5sZWZ0IC0gZml4TGVmdCAsXG5cdFx0XHRoZWlnaHQ6IHRhcmdldC5pbm5lckhlaWdodCgpLFxuXHRcdFx0d2lkdGg6IHRhcmdldC5pbm5lcldpZHRoKClcblx0XHR9LFxuXHRcdHN0YXJ0UG9zaXRpb24gPSBlbGVtLm9mZnNldCgpLFxuXHRcdHRyYW5zZmVyID0gJCggJzxkaXYgY2xhc3M9XCJ1aS1lZmZlY3RzLXRyYW5zZmVyXCI+PC9kaXY+JyApXG5cdFx0XHQuYXBwZW5kVG8oIGRvY3VtZW50LmJvZHkgKVxuXHRcdFx0LmFkZENsYXNzKCBvLmNsYXNzTmFtZSApXG5cdFx0XHQuY3NzKHtcblx0XHRcdFx0dG9wOiBzdGFydFBvc2l0aW9uLnRvcCAtIGZpeFRvcCAsXG5cdFx0XHRcdGxlZnQ6IHN0YXJ0UG9zaXRpb24ubGVmdCAtIGZpeExlZnQgLFxuXHRcdFx0XHRoZWlnaHQ6IGVsZW0uaW5uZXJIZWlnaHQoKSxcblx0XHRcdFx0d2lkdGg6IGVsZW0uaW5uZXJXaWR0aCgpLFxuXHRcdFx0XHRwb3NpdGlvbjogdGFyZ2V0Rml4ZWQgPyBcImZpeGVkXCIgOiBcImFic29sdXRlXCJcblx0XHRcdH0pXG5cdFx0XHQuYW5pbWF0ZSggYW5pbWF0aW9uLCBvLmR1cmF0aW9uLCBvLmVhc2luZywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRyYW5zZmVyLnJlbW92ZSgpO1xuXHRcdFx0XHRkb25lKCk7XG5cdFx0XHR9KTtcbn07XG5cbn0pKGpRdWVyeSk7XG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxudmFyIG1vdXNlSGFuZGxlZCA9IGZhbHNlO1xuXG4kLndpZGdldCggXCJ1aS5tZW51XCIsIHtcblx0dmVyc2lvbjogXCIxLjkuMlwiLFxuXHRkZWZhdWx0RWxlbWVudDogXCI8dWw+XCIsXG5cdGRlbGF5OiAzMDAsXG5cdG9wdGlvbnM6IHtcblx0XHRpY29uczoge1xuXHRcdFx0c3VibWVudTogXCJ1aS1pY29uLWNhcmF0LTEtZVwiXG5cdFx0fSxcblx0XHRtZW51czogXCJ1bFwiLFxuXHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRteTogXCJsZWZ0IHRvcFwiLFxuXHRcdFx0YXQ6IFwicmlnaHQgdG9wXCJcblx0XHR9LFxuXHRcdHJvbGU6IFwibWVudVwiLFxuXG5cdFx0Ly8gY2FsbGJhY2tzXG5cdFx0Ymx1cjogbnVsbCxcblx0XHRmb2N1czogbnVsbCxcblx0XHRzZWxlY3Q6IG51bGxcblx0fSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmFjdGl2ZU1lbnUgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQudW5pcXVlSWQoKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLW1lbnUgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGxcIiApXG5cdFx0XHQudG9nZ2xlQ2xhc3MoIFwidWktbWVudS1pY29uc1wiLCAhIXRoaXMuZWxlbWVudC5maW5kKCBcIi51aS1pY29uXCIgKS5sZW5ndGggKVxuXHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRyb2xlOiB0aGlzLm9wdGlvbnMucm9sZSxcblx0XHRcdFx0dGFiSW5kZXg6IDBcblx0XHRcdH0pXG5cdFx0XHQvLyBuZWVkIHRvIGNhdGNoIGFsbCBjbGlja3Mgb24gZGlzYWJsZWQgbWVudVxuXHRcdFx0Ly8gbm90IHBvc3NpYmxlIHRocm91Z2ggX29uXG5cdFx0XHQuYmluZCggXCJjbGlja1wiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgJC5wcm94eShmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMgKSk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiApXG5cdFx0XHRcdC5hdHRyKCBcImFyaWEtZGlzYWJsZWRcIiwgXCJ0cnVlXCIgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9vbih7XG5cdFx0XHQvLyBQcmV2ZW50IGZvY3VzIGZyb20gc3RpY2tpbmcgdG8gbGlua3MgaW5zaWRlIG1lbnUgYWZ0ZXIgY2xpY2tpbmdcblx0XHRcdC8vIHRoZW0gKGZvY3VzIHNob3VsZCBhbHdheXMgc3RheSBvbiBVTCBkdXJpbmcgbmF2aWdhdGlvbikuXG5cdFx0XHRcIm1vdXNlZG93biAudWktbWVudS1pdGVtID4gYVwiOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9LFxuXHRcdFx0XCJjbGljayAudWktc3RhdGUtZGlzYWJsZWQgPiBhXCI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH0sXG5cdFx0XHRcImNsaWNrIC51aS1tZW51LWl0ZW06aGFzKGEpXCI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9ICQoIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoIFwiLnVpLW1lbnUtaXRlbVwiICk7XG5cdFx0XHRcdGlmICggIW1vdXNlSGFuZGxlZCAmJiB0YXJnZXQubm90KCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdG1vdXNlSGFuZGxlZCA9IHRydWU7XG5cblx0XHRcdFx0XHR0aGlzLnNlbGVjdCggZXZlbnQgKTtcblx0XHRcdFx0XHQvLyBPcGVuIHN1Ym1lbnUgb24gY2xpY2tcblx0XHRcdFx0XHRpZiAoIHRhcmdldC5oYXMoIFwiLnVpLW1lbnVcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdHRoaXMuZXhwYW5kKCBldmVudCApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICF0aGlzLmVsZW1lbnQuaXMoIFwiOmZvY3VzXCIgKSApIHtcblx0XHRcdFx0XHRcdC8vIFJlZGlyZWN0IGZvY3VzIHRvIHRoZSBtZW51XG5cdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQudHJpZ2dlciggXCJmb2N1c1wiLCBbIHRydWUgXSApO1xuXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgYWN0aXZlIGl0ZW0gaXMgb24gdGhlIHRvcCBsZXZlbCwgbGV0IGl0IHN0YXkgYWN0aXZlLlxuXHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBibHVyIHRoZSBhY3RpdmUgaXRlbSBzaW5jZSBpdCBpcyBubyBsb25nZXIgdmlzaWJsZS5cblx0XHRcdFx0XHRcdGlmICggdGhpcy5hY3RpdmUgJiYgdGhpcy5hY3RpdmUucGFyZW50cyggXCIudWktbWVudVwiICkubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRjbGVhclRpbWVvdXQoIHRoaXMudGltZXIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRcIm1vdXNlZW50ZXIgLnVpLW1lbnUtaXRlbVwiOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICk7XG5cdFx0XHRcdC8vIFJlbW92ZSB1aS1zdGF0ZS1hY3RpdmUgY2xhc3MgZnJvbSBzaWJsaW5ncyBvZiB0aGUgbmV3bHkgZm9jdXNlZCBtZW51IGl0ZW1cblx0XHRcdFx0Ly8gdG8gYXZvaWQgYSBqdW1wIGNhdXNlZCBieSBhZGphY2VudCBlbGVtZW50cyBib3RoIGhhdmluZyBhIGNsYXNzIHdpdGggYSBib3JkZXJcblx0XHRcdFx0dGFyZ2V0LnNpYmxpbmdzKCkuY2hpbGRyZW4oIFwiLnVpLXN0YXRlLWFjdGl2ZVwiICkucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdFx0dGhpcy5mb2N1cyggZXZlbnQsIHRhcmdldCApO1xuXHRcdFx0fSxcblx0XHRcdG1vdXNlbGVhdmU6IFwiY29sbGFwc2VBbGxcIixcblx0XHRcdFwibW91c2VsZWF2ZSAudWktbWVudVwiOiBcImNvbGxhcHNlQWxsXCIsXG5cdFx0XHRmb2N1czogZnVuY3Rpb24oIGV2ZW50LCBrZWVwQWN0aXZlSXRlbSApIHtcblx0XHRcdFx0Ly8gSWYgdGhlcmUncyBhbHJlYWR5IGFuIGFjdGl2ZSBpdGVtLCBrZWVwIGl0IGFjdGl2ZVxuXHRcdFx0XHQvLyBJZiBub3QsIGFjdGl2YXRlIHRoZSBmaXJzdCBpdGVtXG5cdFx0XHRcdHZhciBpdGVtID0gdGhpcy5hY3RpdmUgfHwgdGhpcy5lbGVtZW50LmNoaWxkcmVuKCBcIi51aS1tZW51LWl0ZW1cIiApLmVxKCAwICk7XG5cblx0XHRcdFx0aWYgKCAha2VlcEFjdGl2ZUl0ZW0gKSB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1cyggZXZlbnQsIGl0ZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGJsdXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCAhJC5jb250YWlucyggdGhpcy5lbGVtZW50WzBdLCB0aGlzLmRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQgKSApIHtcblx0XHRcdFx0XHRcdHRoaXMuY29sbGFwc2VBbGwoIGV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHRrZXlkb3duOiBcIl9rZXlkb3duXCJcblx0XHR9KTtcblxuXHRcdHRoaXMucmVmcmVzaCgpO1xuXG5cdFx0Ly8gQ2xpY2tzIG91dHNpZGUgb2YgYSBtZW51IGNvbGxhcHNlIGFueSBvcGVuIG1lbnVzXG5cdFx0dGhpcy5fb24oIHRoaXMuZG9jdW1lbnQsIHtcblx0XHRcdGNsaWNrOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggISQoIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoIFwiLnVpLW1lbnVcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHR0aGlzLmNvbGxhcHNlQWxsKCBldmVudCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzZXQgdGhlIG1vdXNlSGFuZGxlZCBmbGFnXG5cdFx0XHRcdG1vdXNlSGFuZGxlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHQvLyBEZXN0cm95IChzdWIpbWVudXNcblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiIClcblx0XHRcdC5maW5kKCBcIi51aS1tZW51XCIgKS5hbmRTZWxmKClcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLW1lbnUgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwgdWktbWVudS1pY29uc1wiIClcblx0XHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZVwiIClcblx0XHRcdFx0LnJlbW92ZUF0dHIoIFwidGFiSW5kZXhcIiApXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtbGFiZWxsZWRieVwiIClcblx0XHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1leHBhbmRlZFwiIClcblx0XHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1oaWRkZW5cIiApXG5cdFx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtZGlzYWJsZWRcIiApXG5cdFx0XHRcdC5yZW1vdmVVbmlxdWVJZCgpXG5cdFx0XHRcdC5zaG93KCk7XG5cblx0XHQvLyBEZXN0cm95IG1lbnUgaXRlbXNcblx0XHR0aGlzLmVsZW1lbnQuZmluZCggXCIudWktbWVudS1pdGVtXCIgKVxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLW1lbnUtaXRlbVwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcInJvbGVcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWRpc2FibGVkXCIgKVxuXHRcdFx0LmNoaWxkcmVuKCBcImFcIiApXG5cdFx0XHRcdC5yZW1vdmVVbmlxdWVJZCgpXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1jb3JuZXItYWxsIHVpLXN0YXRlLWhvdmVyXCIgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggXCJ0YWJJbmRleFwiIClcblx0XHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZVwiIClcblx0XHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1oYXNwb3B1cFwiIClcblx0XHRcdFx0LmNoaWxkcmVuKCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0gPSAkKCB0aGlzICk7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLmRhdGEoIFwidWktbWVudS1zdWJtZW51LWNhcmF0XCIgKSApIHtcblx0XHRcdFx0XHRcdGVsZW0ucmVtb3ZlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdC8vIERlc3Ryb3kgbWVudSBkaXZpZGVyc1xuXHRcdHRoaXMuZWxlbWVudC5maW5kKCBcIi51aS1tZW51LWRpdmlkZXJcIiApLnJlbW92ZUNsYXNzKCBcInVpLW1lbnUtZGl2aWRlciB1aS13aWRnZXQtY29udGVudFwiICk7XG5cdH0sXG5cblx0X2tleWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgbWF0Y2gsIHByZXYsIGNoYXJhY3Rlciwgc2tpcCwgcmVnZXgsXG5cdFx0XHRwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG5cblx0XHRmdW5jdGlvbiBlc2NhcGUoIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlLnJlcGxhY2UoIC9bXFwtXFxbXFxde30oKSorPy4sXFxcXFxcXiR8I1xcc10vZywgXCJcXFxcJCZcIiApO1xuXHRcdH1cblxuXHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9VUDpcblx0XHRcdHRoaXMucHJldmlvdXNQYWdlKCBldmVudCApO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9ET1dOOlxuXHRcdFx0dGhpcy5uZXh0UGFnZSggZXZlbnQgKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLkhPTUU6XG5cdFx0XHR0aGlzLl9tb3ZlKCBcImZpcnN0XCIsIFwiZmlyc3RcIiwgZXZlbnQgKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLkVORDpcblx0XHRcdHRoaXMuX21vdmUoIFwibGFzdFwiLCBcImxhc3RcIiwgZXZlbnQgKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLlVQOlxuXHRcdFx0dGhpcy5wcmV2aW91cyggZXZlbnQgKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLkRPV046XG5cdFx0XHR0aGlzLm5leHQoIGV2ZW50ICk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5MRUZUOlxuXHRcdFx0dGhpcy5jb2xsYXBzZSggZXZlbnQgKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJC51aS5rZXlDb2RlLlJJR0hUOlxuXHRcdFx0aWYgKCB0aGlzLmFjdGl2ZSAmJiAhdGhpcy5hY3RpdmUuaXMoIFwiLnVpLXN0YXRlLWRpc2FibGVkXCIgKSApIHtcblx0XHRcdFx0dGhpcy5leHBhbmQoIGV2ZW50ICk7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICQudWkua2V5Q29kZS5FTlRFUjpcblx0XHRjYXNlICQudWkua2V5Q29kZS5TUEFDRTpcblx0XHRcdHRoaXMuX2FjdGl2YXRlKCBldmVudCApO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAkLnVpLmtleUNvZGUuRVNDQVBFOlxuXHRcdFx0dGhpcy5jb2xsYXBzZSggZXZlbnQgKTtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuXHRcdFx0cHJldiA9IHRoaXMucHJldmlvdXNGaWx0ZXIgfHwgXCJcIjtcblx0XHRcdGNoYXJhY3RlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoIGV2ZW50LmtleUNvZGUgKTtcblx0XHRcdHNraXAgPSBmYWxzZTtcblxuXHRcdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLmZpbHRlclRpbWVyICk7XG5cblx0XHRcdGlmICggY2hhcmFjdGVyID09PSBwcmV2ICkge1xuXHRcdFx0XHRza2lwID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNoYXJhY3RlciA9IHByZXYgKyBjaGFyYWN0ZXI7XG5cdFx0XHR9XG5cblx0XHRcdHJlZ2V4ID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBlc2NhcGUoIGNoYXJhY3RlciApLCBcImlcIiApO1xuXHRcdFx0bWF0Y2ggPSB0aGlzLmFjdGl2ZU1lbnUuY2hpbGRyZW4oIFwiLnVpLW1lbnUtaXRlbVwiICkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gcmVnZXgudGVzdCggJCggdGhpcyApLmNoaWxkcmVuKCBcImFcIiApLnRleHQoKSApO1xuXHRcdFx0fSk7XG5cdFx0XHRtYXRjaCA9IHNraXAgJiYgbWF0Y2guaW5kZXgoIHRoaXMuYWN0aXZlLm5leHQoKSApICE9PSAtMSA/XG5cdFx0XHRcdHRoaXMuYWN0aXZlLm5leHRBbGwoIFwiLnVpLW1lbnUtaXRlbVwiICkgOlxuXHRcdFx0XHRtYXRjaDtcblxuXHRcdFx0Ly8gSWYgbm8gbWF0Y2hlcyBvbiB0aGUgY3VycmVudCBmaWx0ZXIsIHJlc2V0IHRvIHRoZSBsYXN0IGNoYXJhY3RlciBwcmVzc2VkXG5cdFx0XHQvLyB0byBtb3ZlIGRvd24gdGhlIG1lbnUgdG8gdGhlIGZpcnN0IGl0ZW0gdGhhdCBzdGFydHMgd2l0aCB0aGF0IGNoYXJhY3RlclxuXHRcdFx0aWYgKCAhbWF0Y2gubGVuZ3RoICkge1xuXHRcdFx0XHRjaGFyYWN0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCBldmVudC5rZXlDb2RlICk7XG5cdFx0XHRcdHJlZ2V4ID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBlc2NhcGUoIGNoYXJhY3RlciApLCBcImlcIiApO1xuXHRcdFx0XHRtYXRjaCA9IHRoaXMuYWN0aXZlTWVudS5jaGlsZHJlbiggXCIudWktbWVudS1pdGVtXCIgKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlZ2V4LnRlc3QoICQoIHRoaXMgKS5jaGlsZHJlbiggXCJhXCIgKS50ZXh0KCkgKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0Y2gubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgbWF0Y2ggKTtcblx0XHRcdFx0aWYgKCBtYXRjaC5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRcdHRoaXMucHJldmlvdXNGaWx0ZXIgPSBjaGFyYWN0ZXI7XG5cdFx0XHRcdFx0dGhpcy5maWx0ZXJUaW1lciA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMucHJldmlvdXNGaWx0ZXI7XG5cdFx0XHRcdFx0fSwgMTAwMCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLnByZXZpb3VzRmlsdGVyO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5wcmV2aW91c0ZpbHRlcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHByZXZlbnREZWZhdWx0ICkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cblx0X2FjdGl2YXRlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCAhdGhpcy5hY3RpdmUuaXMoIFwiLnVpLXN0YXRlLWRpc2FibGVkXCIgKSApIHtcblx0XHRcdGlmICggdGhpcy5hY3RpdmUuY2hpbGRyZW4oIFwiYVthcmlhLWhhc3BvcHVwPSd0cnVlJ11cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0dGhpcy5leHBhbmQoIGV2ZW50ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNlbGVjdCggZXZlbnQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVmcmVzaDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lbnVzLFxuXHRcdFx0aWNvbiA9IHRoaXMub3B0aW9ucy5pY29ucy5zdWJtZW51LFxuXHRcdFx0c3VibWVudXMgPSB0aGlzLmVsZW1lbnQuZmluZCggdGhpcy5vcHRpb25zLm1lbnVzICk7XG5cblx0XHQvLyBJbml0aWFsaXplIG5lc3RlZCBtZW51c1xuXHRcdHN1Ym1lbnVzLmZpbHRlciggXCI6bm90KC51aS1tZW51KVwiIClcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1tZW51IHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsXCIgKVxuXHRcdFx0LmhpZGUoKVxuXHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRyb2xlOiB0aGlzLm9wdGlvbnMucm9sZSxcblx0XHRcdFx0XCJhcmlhLWhpZGRlblwiOiBcInRydWVcIixcblx0XHRcdFx0XCJhcmlhLWV4cGFuZGVkXCI6IFwiZmFsc2VcIlxuXHRcdFx0fSlcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbWVudSA9ICQoIHRoaXMgKSxcblx0XHRcdFx0XHRpdGVtID0gbWVudS5wcmV2KCBcImFcIiApLFxuXHRcdFx0XHRcdHN1Ym1lbnVDYXJhdCA9ICQoIFwiPHNwYW4+XCIgKVxuXHRcdFx0XHRcdFx0LmFkZENsYXNzKCBcInVpLW1lbnUtaWNvbiB1aS1pY29uIFwiICsgaWNvbiApXG5cdFx0XHRcdFx0XHQuZGF0YSggXCJ1aS1tZW51LXN1Ym1lbnUtY2FyYXRcIiwgdHJ1ZSApO1xuXG5cdFx0XHRcdGl0ZW1cblx0XHRcdFx0XHQuYXR0ciggXCJhcmlhLWhhc3BvcHVwXCIsIFwidHJ1ZVwiIClcblx0XHRcdFx0XHQucHJlcGVuZCggc3VibWVudUNhcmF0ICk7XG5cdFx0XHRcdG1lbnUuYXR0ciggXCJhcmlhLWxhYmVsbGVkYnlcIiwgaXRlbS5hdHRyKCBcImlkXCIgKSApO1xuXHRcdFx0fSk7XG5cblx0XHRtZW51cyA9IHN1Ym1lbnVzLmFkZCggdGhpcy5lbGVtZW50ICk7XG5cblx0XHQvLyBEb24ndCByZWZyZXNoIGxpc3QgaXRlbXMgdGhhdCBhcmUgYWxyZWFkeSBhZGFwdGVkXG5cdFx0bWVudXMuY2hpbGRyZW4oIFwiOm5vdCgudWktbWVudS1pdGVtKTpoYXMoYSlcIiApXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktbWVudS1pdGVtXCIgKVxuXHRcdFx0LmF0dHIoIFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiIClcblx0XHRcdC5jaGlsZHJlbiggXCJhXCIgKVxuXHRcdFx0XHQudW5pcXVlSWQoKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktY29ybmVyLWFsbFwiIClcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdHRhYkluZGV4OiAtMSxcblx0XHRcdFx0XHRyb2xlOiB0aGlzLl9pdGVtUm9sZSgpXG5cdFx0XHRcdH0pO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB1bmxpbmtlZCBtZW51LWl0ZW1zIGNvbnRhaW5pbmcgc3BhY2VzIGFuZC9vciBkYXNoZXMgb25seSBhcyBkaXZpZGVyc1xuXHRcdG1lbnVzLmNoaWxkcmVuKCBcIjpub3QoLnVpLW1lbnUtaXRlbSlcIiApLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaXRlbSA9ICQoIHRoaXMgKTtcblx0XHRcdC8vIGh5cGhlbiwgZW0gZGFzaCwgZW4gZGFzaFxuXHRcdFx0aWYgKCAhL1teXFwt4oCU4oCTXFxzXS8udGVzdCggaXRlbS50ZXh0KCkgKSApIHtcblx0XHRcdFx0aXRlbS5hZGRDbGFzcyggXCJ1aS13aWRnZXQtY29udGVudCB1aS1tZW51LWRpdmlkZXJcIiApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gQWRkIGFyaWEtZGlzYWJsZWQgYXR0cmlidXRlIHRvIGFueSBkaXNhYmxlZCBtZW51IGl0ZW1cblx0XHRtZW51cy5jaGlsZHJlbiggXCIudWktc3RhdGUtZGlzYWJsZWRcIiApLmF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiLCBcInRydWVcIiApO1xuXG5cdFx0Ly8gSWYgdGhlIGFjdGl2ZSBpdGVtIGhhcyBiZWVuIHJlbW92ZWQsIGJsdXIgdGhlIG1lbnVcblx0XHRpZiAoIHRoaXMuYWN0aXZlICYmICEkLmNvbnRhaW5zKCB0aGlzLmVsZW1lbnRbIDAgXSwgdGhpcy5hY3RpdmVbIDAgXSApICkge1xuXHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pdGVtUm9sZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG1lbnU6IFwibWVudWl0ZW1cIixcblx0XHRcdGxpc3Rib3g6IFwib3B0aW9uXCJcblx0XHR9WyB0aGlzLm9wdGlvbnMucm9sZSBdO1xuXHR9LFxuXG5cdGZvY3VzOiBmdW5jdGlvbiggZXZlbnQsIGl0ZW0gKSB7XG5cdFx0dmFyIG5lc3RlZCwgZm9jdXNlZDtcblx0XHR0aGlzLmJsdXIoIGV2ZW50LCBldmVudCAmJiBldmVudC50eXBlID09PSBcImZvY3VzXCIgKTtcblxuXHRcdHRoaXMuX3Njcm9sbEludG9WaWV3KCBpdGVtICk7XG5cblx0XHR0aGlzLmFjdGl2ZSA9IGl0ZW0uZmlyc3QoKTtcblx0XHRmb2N1c2VkID0gdGhpcy5hY3RpdmUuY2hpbGRyZW4oIFwiYVwiICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdC8vIE9ubHkgdXBkYXRlIGFyaWEtYWN0aXZlZGVzY2VuZGFudCBpZiB0aGVyZSdzIGEgcm9sZVxuXHRcdC8vIG90aGVyd2lzZSB3ZSBhc3N1bWUgZm9jdXMgaXMgbWFuYWdlZCBlbHNld2hlcmVcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5yb2xlICkge1xuXHRcdFx0dGhpcy5lbGVtZW50LmF0dHIoIFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsIGZvY3VzZWQuYXR0ciggXCJpZFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBIaWdobGlnaHQgYWN0aXZlIHBhcmVudCBtZW51IGl0ZW0sIGlmIGFueVxuXHRcdHRoaXMuYWN0aXZlXG5cdFx0XHQucGFyZW50KClcblx0XHRcdC5jbG9zZXN0KCBcIi51aS1tZW51LWl0ZW1cIiApXG5cdFx0XHQuY2hpbGRyZW4oIFwiYTpmaXJzdFwiIClcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXG5cdFx0aWYgKCBldmVudCAmJiBldmVudC50eXBlID09PSBcImtleWRvd25cIiApIHtcblx0XHRcdHRoaXMuX2Nsb3NlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudGltZXIgPSB0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5fY2xvc2UoKTtcblx0XHRcdH0sIHRoaXMuZGVsYXkgKTtcblx0XHR9XG5cblx0XHRuZXN0ZWQgPSBpdGVtLmNoaWxkcmVuKCBcIi51aS1tZW51XCIgKTtcblx0XHRpZiAoIG5lc3RlZC5sZW5ndGggJiYgKCAvXm1vdXNlLy50ZXN0KCBldmVudC50eXBlICkgKSApIHtcblx0XHRcdHRoaXMuX3N0YXJ0T3BlbmluZyhuZXN0ZWQpO1xuXHRcdH1cblx0XHR0aGlzLmFjdGl2ZU1lbnUgPSBpdGVtLnBhcmVudCgpO1xuXG5cdFx0dGhpcy5fdHJpZ2dlciggXCJmb2N1c1wiLCBldmVudCwgeyBpdGVtOiBpdGVtIH0gKTtcblx0fSxcblxuXHRfc2Nyb2xsSW50b1ZpZXc6IGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdHZhciBib3JkZXJUb3AsIHBhZGRpbmdUb3AsIG9mZnNldCwgc2Nyb2xsLCBlbGVtZW50SGVpZ2h0LCBpdGVtSGVpZ2h0O1xuXHRcdGlmICggdGhpcy5faGFzU2Nyb2xsKCkgKSB7XG5cdFx0XHRib3JkZXJUb3AgPSBwYXJzZUZsb2F0KCAkLmNzcyggdGhpcy5hY3RpdmVNZW51WzBdLCBcImJvcmRlclRvcFdpZHRoXCIgKSApIHx8IDA7XG5cdFx0XHRwYWRkaW5nVG9wID0gcGFyc2VGbG9hdCggJC5jc3MoIHRoaXMuYWN0aXZlTWVudVswXSwgXCJwYWRkaW5nVG9wXCIgKSApIHx8IDA7XG5cdFx0XHRvZmZzZXQgPSBpdGVtLm9mZnNldCgpLnRvcCAtIHRoaXMuYWN0aXZlTWVudS5vZmZzZXQoKS50b3AgLSBib3JkZXJUb3AgLSBwYWRkaW5nVG9wO1xuXHRcdFx0c2Nyb2xsID0gdGhpcy5hY3RpdmVNZW51LnNjcm9sbFRvcCgpO1xuXHRcdFx0ZWxlbWVudEhlaWdodCA9IHRoaXMuYWN0aXZlTWVudS5oZWlnaHQoKTtcblx0XHRcdGl0ZW1IZWlnaHQgPSBpdGVtLmhlaWdodCgpO1xuXG5cdFx0XHRpZiAoIG9mZnNldCA8IDAgKSB7XG5cdFx0XHRcdHRoaXMuYWN0aXZlTWVudS5zY3JvbGxUb3AoIHNjcm9sbCArIG9mZnNldCApO1xuXHRcdFx0fSBlbHNlIGlmICggb2Zmc2V0ICsgaXRlbUhlaWdodCA+IGVsZW1lbnRIZWlnaHQgKSB7XG5cdFx0XHRcdHRoaXMuYWN0aXZlTWVudS5zY3JvbGxUb3AoIHNjcm9sbCArIG9mZnNldCAtIGVsZW1lbnRIZWlnaHQgKyBpdGVtSGVpZ2h0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGJsdXI6IGZ1bmN0aW9uKCBldmVudCwgZnJvbUZvY3VzICkge1xuXHRcdGlmICggIWZyb21Gb2N1cyApIHtcblx0XHRcdGNsZWFyVGltZW91dCggdGhpcy50aW1lciApO1xuXHRcdH1cblxuXHRcdGlmICggIXRoaXMuYWN0aXZlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuYWN0aXZlLmNoaWxkcmVuKCBcImFcIiApLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWZvY3VzXCIgKTtcblx0XHR0aGlzLmFjdGl2ZSA9IG51bGw7XG5cblx0XHR0aGlzLl90cmlnZ2VyKCBcImJsdXJcIiwgZXZlbnQsIHsgaXRlbTogdGhpcy5hY3RpdmUgfSApO1xuXHR9LFxuXG5cdF9zdGFydE9wZW5pbmc6IGZ1bmN0aW9uKCBzdWJtZW51ICkge1xuXHRcdGNsZWFyVGltZW91dCggdGhpcy50aW1lciApO1xuXG5cdFx0Ly8gRG9uJ3Qgb3BlbiBpZiBhbHJlYWR5IG9wZW4gZml4ZXMgYSBGaXJlZm94IGJ1ZyB0aGF0IGNhdXNlZCBhIC41IHBpeGVsXG5cdFx0Ly8gc2hpZnQgaW4gdGhlIHN1Ym1lbnUgcG9zaXRpb24gd2hlbiBtb3VzaW5nIG92ZXIgdGhlIGNhcmF0IGljb25cblx0XHRpZiAoIHN1Ym1lbnUuYXR0ciggXCJhcmlhLWhpZGRlblwiICkgIT09IFwidHJ1ZVwiICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMudGltZXIgPSB0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX2Nsb3NlKCk7XG5cdFx0XHR0aGlzLl9vcGVuKCBzdWJtZW51ICk7XG5cdFx0fSwgdGhpcy5kZWxheSApO1xuXHR9LFxuXG5cdF9vcGVuOiBmdW5jdGlvbiggc3VibWVudSApIHtcblx0XHR2YXIgcG9zaXRpb24gPSAkLmV4dGVuZCh7XG5cdFx0XHRvZjogdGhpcy5hY3RpdmVcblx0XHR9LCB0aGlzLm9wdGlvbnMucG9zaXRpb24gKTtcblxuXHRcdGNsZWFyVGltZW91dCggdGhpcy50aW1lciApO1xuXHRcdHRoaXMuZWxlbWVudC5maW5kKCBcIi51aS1tZW51XCIgKS5ub3QoIHN1Ym1lbnUucGFyZW50cyggXCIudWktbWVudVwiICkgKVxuXHRcdFx0LmhpZGUoKVxuXHRcdFx0LmF0dHIoIFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIgKTtcblxuXHRcdHN1Ym1lbnVcblx0XHRcdC5zaG93KClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtaGlkZGVuXCIgKVxuXHRcdFx0LmF0dHIoIFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIiApXG5cdFx0XHQucG9zaXRpb24oIHBvc2l0aW9uICk7XG5cdH0sXG5cblx0Y29sbGFwc2VBbGw6IGZ1bmN0aW9uKCBldmVudCwgYWxsICkge1xuXHRcdGNsZWFyVGltZW91dCggdGhpcy50aW1lciApO1xuXHRcdHRoaXMudGltZXIgPSB0aGlzLl9kZWxheShmdW5jdGlvbigpIHtcblx0XHRcdC8vIElmIHdlIHdlcmUgcGFzc2VkIGFuIGV2ZW50LCBsb29rIGZvciB0aGUgc3VibWVudSB0aGF0IGNvbnRhaW5zIHRoZSBldmVudFxuXHRcdFx0dmFyIGN1cnJlbnRNZW51ID0gYWxsID8gdGhpcy5lbGVtZW50IDpcblx0XHRcdFx0JCggZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICkuY2xvc2VzdCggdGhpcy5lbGVtZW50LmZpbmQoIFwiLnVpLW1lbnVcIiApICk7XG5cblx0XHRcdC8vIElmIHdlIGZvdW5kIG5vIHZhbGlkIHN1Ym1lbnUgYW5jZXN0b3IsIHVzZSB0aGUgbWFpbiBtZW51IHRvIGNsb3NlIGFsbCBzdWIgbWVudXMgYW55d2F5XG5cdFx0XHRpZiAoICFjdXJyZW50TWVudS5sZW5ndGggKSB7XG5cdFx0XHRcdGN1cnJlbnRNZW51ID0gdGhpcy5lbGVtZW50O1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9jbG9zZSggY3VycmVudE1lbnUgKTtcblxuXHRcdFx0dGhpcy5ibHVyKCBldmVudCApO1xuXHRcdFx0dGhpcy5hY3RpdmVNZW51ID0gY3VycmVudE1lbnU7XG5cdFx0fSwgdGhpcy5kZWxheSApO1xuXHR9LFxuXG5cdC8vIFdpdGggbm8gYXJndW1lbnRzLCBjbG9zZXMgdGhlIGN1cnJlbnRseSBhY3RpdmUgbWVudSAtIGlmIG5vdGhpbmcgaXMgYWN0aXZlXG5cdC8vIGl0IGNsb3NlcyBhbGwgbWVudXMuICBJZiBwYXNzZWQgYW4gYXJndW1lbnQsIGl0IHdpbGwgc2VhcmNoIGZvciBtZW51cyBCRUxPV1xuXHRfY2xvc2U6IGZ1bmN0aW9uKCBzdGFydE1lbnUgKSB7XG5cdFx0aWYgKCAhc3RhcnRNZW51ICkge1xuXHRcdFx0c3RhcnRNZW51ID0gdGhpcy5hY3RpdmUgPyB0aGlzLmFjdGl2ZS5wYXJlbnQoKSA6IHRoaXMuZWxlbWVudDtcblx0XHR9XG5cblx0XHRzdGFydE1lbnVcblx0XHRcdC5maW5kKCBcIi51aS1tZW51XCIgKVxuXHRcdFx0XHQuaGlkZSgpXG5cdFx0XHRcdC5hdHRyKCBcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiIClcblx0XHRcdFx0LmF0dHIoIFwiYXJpYS1leHBhbmRlZFwiLCBcImZhbHNlXCIgKVxuXHRcdFx0LmVuZCgpXG5cdFx0XHQuZmluZCggXCJhLnVpLXN0YXRlLWFjdGl2ZVwiIClcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdH0sXG5cblx0Y29sbGFwc2U6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgbmV3SXRlbSA9IHRoaXMuYWN0aXZlICYmXG5cdFx0XHR0aGlzLmFjdGl2ZS5wYXJlbnQoKS5jbG9zZXN0KCBcIi51aS1tZW51LWl0ZW1cIiwgdGhpcy5lbGVtZW50ICk7XG5cdFx0aWYgKCBuZXdJdGVtICYmIG5ld0l0ZW0ubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5fY2xvc2UoKTtcblx0XHRcdHRoaXMuZm9jdXMoIGV2ZW50LCBuZXdJdGVtICk7XG5cdFx0fVxuXHR9LFxuXG5cdGV4cGFuZDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBuZXdJdGVtID0gdGhpcy5hY3RpdmUgJiZcblx0XHRcdHRoaXMuYWN0aXZlXG5cdFx0XHRcdC5jaGlsZHJlbiggXCIudWktbWVudSBcIiApXG5cdFx0XHRcdC5jaGlsZHJlbiggXCIudWktbWVudS1pdGVtXCIgKVxuXHRcdFx0XHQuZmlyc3QoKTtcblxuXHRcdGlmICggbmV3SXRlbSAmJiBuZXdJdGVtLmxlbmd0aCApIHtcblx0XHRcdHRoaXMuX29wZW4oIG5ld0l0ZW0ucGFyZW50KCkgKTtcblxuXHRcdFx0Ly8gRGVsYXkgc28gRmlyZWZveCB3aWxsIG5vdCBoaWRlIGFjdGl2ZWRlc2NlbmRhbnQgY2hhbmdlIGluIGV4cGFuZGluZyBzdWJtZW51IGZyb20gQVRcblx0XHRcdHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgbmV3SXRlbSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdG5leHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR0aGlzLl9tb3ZlKCBcIm5leHRcIiwgXCJmaXJzdFwiLCBldmVudCApO1xuXHR9LFxuXG5cdHByZXZpb3VzOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dGhpcy5fbW92ZSggXCJwcmV2XCIsIFwibGFzdFwiLCBldmVudCApO1xuXHR9LFxuXG5cdGlzRmlyc3RJdGVtOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5hY3RpdmUgJiYgIXRoaXMuYWN0aXZlLnByZXZBbGwoIFwiLnVpLW1lbnUtaXRlbVwiICkubGVuZ3RoO1xuXHR9LFxuXG5cdGlzTGFzdEl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmFjdGl2ZSAmJiAhdGhpcy5hY3RpdmUubmV4dEFsbCggXCIudWktbWVudS1pdGVtXCIgKS5sZW5ndGg7XG5cdH0sXG5cblx0X21vdmU6IGZ1bmN0aW9uKCBkaXJlY3Rpb24sIGZpbHRlciwgZXZlbnQgKSB7XG5cdFx0dmFyIG5leHQ7XG5cdFx0aWYgKCB0aGlzLmFjdGl2ZSApIHtcblx0XHRcdGlmICggZGlyZWN0aW9uID09PSBcImZpcnN0XCIgfHwgZGlyZWN0aW9uID09PSBcImxhc3RcIiApIHtcblx0XHRcdFx0bmV4dCA9IHRoaXMuYWN0aXZlXG5cdFx0XHRcdFx0WyBkaXJlY3Rpb24gPT09IFwiZmlyc3RcIiA/IFwicHJldkFsbFwiIDogXCJuZXh0QWxsXCIgXSggXCIudWktbWVudS1pdGVtXCIgKVxuXHRcdFx0XHRcdC5lcSggLTEgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5leHQgPSB0aGlzLmFjdGl2ZVxuXHRcdFx0XHRcdFsgZGlyZWN0aW9uICsgXCJBbGxcIiBdKCBcIi51aS1tZW51LWl0ZW1cIiApXG5cdFx0XHRcdFx0LmVxKCAwICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggIW5leHQgfHwgIW5leHQubGVuZ3RoIHx8ICF0aGlzLmFjdGl2ZSApIHtcblx0XHRcdG5leHQgPSB0aGlzLmFjdGl2ZU1lbnUuY2hpbGRyZW4oIFwiLnVpLW1lbnUtaXRlbVwiIClbIGZpbHRlciBdKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5mb2N1cyggZXZlbnQsIG5leHQgKTtcblx0fSxcblxuXHRuZXh0UGFnZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBpdGVtLCBiYXNlLCBoZWlnaHQ7XG5cblx0XHRpZiAoICF0aGlzLmFjdGl2ZSApIHtcblx0XHRcdHRoaXMubmV4dCggZXZlbnQgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLmlzTGFzdEl0ZW0oKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLl9oYXNTY3JvbGwoKSApIHtcblx0XHRcdGJhc2UgPSB0aGlzLmFjdGl2ZS5vZmZzZXQoKS50b3A7XG5cdFx0XHRoZWlnaHQgPSB0aGlzLmVsZW1lbnQuaGVpZ2h0KCk7XG5cdFx0XHR0aGlzLmFjdGl2ZS5uZXh0QWxsKCBcIi51aS1tZW51LWl0ZW1cIiApLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGl0ZW0gPSAkKCB0aGlzICk7XG5cdFx0XHRcdHJldHVybiBpdGVtLm9mZnNldCgpLnRvcCAtIGJhc2UgLSBoZWlnaHQgPCAwO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuZm9jdXMoIGV2ZW50LCBpdGVtICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZm9jdXMoIGV2ZW50LCB0aGlzLmFjdGl2ZU1lbnUuY2hpbGRyZW4oIFwiLnVpLW1lbnUtaXRlbVwiIClcblx0XHRcdFx0WyAhdGhpcy5hY3RpdmUgPyBcImZpcnN0XCIgOiBcImxhc3RcIiBdKCkgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJldmlvdXNQYWdlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGl0ZW0sIGJhc2UsIGhlaWdodDtcblx0XHRpZiAoICF0aGlzLmFjdGl2ZSApIHtcblx0XHRcdHRoaXMubmV4dCggZXZlbnQgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLmlzRmlyc3RJdGVtKCkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggdGhpcy5faGFzU2Nyb2xsKCkgKSB7XG5cdFx0XHRiYXNlID0gdGhpcy5hY3RpdmUub2Zmc2V0KCkudG9wO1xuXHRcdFx0aGVpZ2h0ID0gdGhpcy5lbGVtZW50LmhlaWdodCgpO1xuXHRcdFx0dGhpcy5hY3RpdmUucHJldkFsbCggXCIudWktbWVudS1pdGVtXCIgKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpdGVtID0gJCggdGhpcyApO1xuXHRcdFx0XHRyZXR1cm4gaXRlbS5vZmZzZXQoKS50b3AgLSBiYXNlICsgaGVpZ2h0ID4gMDtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgaXRlbSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmZvY3VzKCBldmVudCwgdGhpcy5hY3RpdmVNZW51LmNoaWxkcmVuKCBcIi51aS1tZW51LWl0ZW1cIiApLmZpcnN0KCkgKTtcblx0XHR9XG5cdH0sXG5cblx0X2hhc1Njcm9sbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5vdXRlckhlaWdodCgpIDwgdGhpcy5lbGVtZW50LnByb3AoIFwic2Nyb2xsSGVpZ2h0XCIgKTtcblx0fSxcblxuXHRzZWxlY3Q6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHQvLyBUT0RPOiBJdCBzaG91bGQgbmV2ZXIgYmUgcG9zc2libGUgdG8gbm90IGhhdmUgYW4gYWN0aXZlIGl0ZW0gYXQgdGhpc1xuXHRcdC8vIHBvaW50LCBidXQgdGhlIHRlc3RzIGRvbid0IHRyaWdnZXIgbW91c2VlbnRlciBiZWZvcmUgY2xpY2suXG5cdFx0dGhpcy5hY3RpdmUgPSB0aGlzLmFjdGl2ZSB8fCAkKCBldmVudC50YXJnZXQgKS5jbG9zZXN0KCBcIi51aS1tZW51LWl0ZW1cIiApO1xuXHRcdHZhciB1aSA9IHsgaXRlbTogdGhpcy5hY3RpdmUgfTtcblx0XHRpZiAoICF0aGlzLmFjdGl2ZS5oYXMoIFwiLnVpLW1lbnVcIiApLmxlbmd0aCApIHtcblx0XHRcdHRoaXMuY29sbGFwc2VBbGwoIGV2ZW50LCB0cnVlICk7XG5cdFx0fVxuXHRcdHRoaXMuX3RyaWdnZXIoIFwic2VsZWN0XCIsIGV2ZW50LCB1aSApO1xuXHR9XG59KTtcblxufSggalF1ZXJ5ICkpO1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQud2lkZ2V0KCBcInVpLnByb2dyZXNzYmFyXCIsIHtcblx0dmVyc2lvbjogXCIxLjkuMlwiLFxuXHRvcHRpb25zOiB7XG5cdFx0dmFsdWU6IDAsXG5cdFx0bWF4OiAxMDBcblx0fSxcblxuXHRtaW46IDAsXG5cblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktcHJvZ3Jlc3NiYXIgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGxcIiApXG5cdFx0XHQuYXR0cih7XG5cdFx0XHRcdHJvbGU6IFwicHJvZ3Jlc3NiYXJcIixcblx0XHRcdFx0XCJhcmlhLXZhbHVlbWluXCI6IHRoaXMubWluLFxuXHRcdFx0XHRcImFyaWEtdmFsdWVtYXhcIjogdGhpcy5vcHRpb25zLm1heCxcblx0XHRcdFx0XCJhcmlhLXZhbHVlbm93XCI6IHRoaXMuX3ZhbHVlKClcblx0XHRcdH0pO1xuXG5cdFx0dGhpcy52YWx1ZURpdiA9ICQoIFwiPGRpdiBjbGFzcz0ndWktcHJvZ3Jlc3NiYXItdmFsdWUgdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItbGVmdCc+PC9kaXY+XCIgKVxuXHRcdFx0LmFwcGVuZFRvKCB0aGlzLmVsZW1lbnQgKTtcblxuXHRcdHRoaXMub2xkVmFsdWUgPSB0aGlzLl92YWx1ZSgpO1xuXHRcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1wcm9ncmVzc2JhciB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbFwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcInJvbGVcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLXZhbHVlbWluXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS12YWx1ZW1heFwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtdmFsdWVub3dcIiApO1xuXG5cdFx0dGhpcy52YWx1ZURpdi5yZW1vdmUoKTtcblx0fSxcblxuXHR2YWx1ZTogZnVuY3Rpb24oIG5ld1ZhbHVlICkge1xuXHRcdGlmICggbmV3VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiB0aGlzLl92YWx1ZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NldE9wdGlvbiggXCJ2YWx1ZVwiLCBuZXdWYWx1ZSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdGlmICgga2V5ID09PSBcInZhbHVlXCIgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xuXHRcdFx0aWYgKCB0aGlzLl92YWx1ZSgpID09PSB0aGlzLm9wdGlvbnMubWF4ICkge1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyKCBcImNvbXBsZXRlXCIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXHR9LFxuXG5cdF92YWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZhbCA9IHRoaXMub3B0aW9ucy52YWx1ZTtcblx0XHQvLyBub3JtYWxpemUgaW52YWxpZCB2YWx1ZVxuXHRcdGlmICggdHlwZW9mIHZhbCAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdHZhbCA9IDA7XG5cdFx0fVxuXHRcdHJldHVybiBNYXRoLm1pbiggdGhpcy5vcHRpb25zLm1heCwgTWF0aC5tYXgoIHRoaXMubWluLCB2YWwgKSApO1xuXHR9LFxuXG5cdF9wZXJjZW50YWdlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gMTAwICogdGhpcy5fdmFsdWUoKSAvIHRoaXMub3B0aW9ucy5tYXg7XG5cdH0sXG5cblx0X3JlZnJlc2hWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZhbHVlID0gdGhpcy52YWx1ZSgpLFxuXHRcdFx0cGVyY2VudGFnZSA9IHRoaXMuX3BlcmNlbnRhZ2UoKTtcblxuXHRcdGlmICggdGhpcy5vbGRWYWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHR0aGlzLm9sZFZhbHVlID0gdmFsdWU7XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCBcImNoYW5nZVwiICk7XG5cdFx0fVxuXG5cdFx0dGhpcy52YWx1ZURpdlxuXHRcdFx0LnRvZ2dsZSggdmFsdWUgPiB0aGlzLm1pbiApXG5cdFx0XHQudG9nZ2xlQ2xhc3MoIFwidWktY29ybmVyLXJpZ2h0XCIsIHZhbHVlID09PSB0aGlzLm9wdGlvbnMubWF4IClcblx0XHRcdC53aWR0aCggcGVyY2VudGFnZS50b0ZpeGVkKDApICsgXCIlXCIgKTtcblx0XHR0aGlzLmVsZW1lbnQuYXR0ciggXCJhcmlhLXZhbHVlbm93XCIsIHZhbHVlICk7XG5cdH1cbn0pO1xuXG59KSggalF1ZXJ5ICk7XG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxuJC53aWRnZXQoXCJ1aS5yZXNpemFibGVcIiwgJC51aS5tb3VzZSwge1xuXHR2ZXJzaW9uOiBcIjEuOS4yXCIsXG5cdHdpZGdldEV2ZW50UHJlZml4OiBcInJlc2l6ZVwiLFxuXHRvcHRpb25zOiB7XG5cdFx0YWxzb1Jlc2l6ZTogZmFsc2UsXG5cdFx0YW5pbWF0ZTogZmFsc2UsXG5cdFx0YW5pbWF0ZUR1cmF0aW9uOiBcInNsb3dcIixcblx0XHRhbmltYXRlRWFzaW5nOiBcInN3aW5nXCIsXG5cdFx0YXNwZWN0UmF0aW86IGZhbHNlLFxuXHRcdGF1dG9IaWRlOiBmYWxzZSxcblx0XHRjb250YWlubWVudDogZmFsc2UsXG5cdFx0Z2hvc3Q6IGZhbHNlLFxuXHRcdGdyaWQ6IGZhbHNlLFxuXHRcdGhhbmRsZXM6IFwiZSxzLHNlXCIsXG5cdFx0aGVscGVyOiBmYWxzZSxcblx0XHRtYXhIZWlnaHQ6IG51bGwsXG5cdFx0bWF4V2lkdGg6IG51bGwsXG5cdFx0bWluSGVpZ2h0OiAxMCxcblx0XHRtaW5XaWR0aDogMTAsXG5cdFx0ekluZGV4OiAxMDAwXG5cdH0sXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHRoYXQgPSB0aGlzLCBvID0gdGhpcy5vcHRpb25zO1xuXHRcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcInVpLXJlc2l6YWJsZVwiKTtcblxuXHRcdCQuZXh0ZW5kKHRoaXMsIHtcblx0XHRcdF9hc3BlY3RSYXRpbzogISEoby5hc3BlY3RSYXRpbyksXG5cdFx0XHRhc3BlY3RSYXRpbzogby5hc3BlY3RSYXRpbyxcblx0XHRcdG9yaWdpbmFsRWxlbWVudDogdGhpcy5lbGVtZW50LFxuXHRcdFx0X3Byb3BvcnRpb25hbGx5UmVzaXplRWxlbWVudHM6IFtdLFxuXHRcdFx0X2hlbHBlcjogby5oZWxwZXIgfHwgby5naG9zdCB8fCBvLmFuaW1hdGUgPyBvLmhlbHBlciB8fCAndWktcmVzaXphYmxlLWhlbHBlcicgOiBudWxsXG5cdFx0fSk7XG5cblx0XHQvL1dyYXAgdGhlIGVsZW1lbnQgaWYgaXQgY2Fubm90IGhvbGQgY2hpbGQgbm9kZXNcblx0XHRpZih0aGlzLmVsZW1lbnRbMF0ubm9kZU5hbWUubWF0Y2goL2NhbnZhc3x0ZXh0YXJlYXxpbnB1dHxzZWxlY3R8YnV0dG9ufGltZy9pKSkge1xuXG5cdFx0XHQvL0NyZWF0ZSBhIHdyYXBwZXIgZWxlbWVudCBhbmQgc2V0IHRoZSB3cmFwcGVyIHRvIHRoZSBuZXcgY3VycmVudCBpbnRlcm5hbCBlbGVtZW50XG5cdFx0XHR0aGlzLmVsZW1lbnQud3JhcChcblx0XHRcdFx0JCgnPGRpdiBjbGFzcz1cInVpLXdyYXBwZXJcIiBzdHlsZT1cIm92ZXJmbG93OiBoaWRkZW47XCI+PC9kaXY+JykuY3NzKHtcblx0XHRcdFx0XHRwb3NpdGlvbjogdGhpcy5lbGVtZW50LmNzcygncG9zaXRpb24nKSxcblx0XHRcdFx0XHR3aWR0aDogdGhpcy5lbGVtZW50Lm91dGVyV2lkdGgoKSxcblx0XHRcdFx0XHRoZWlnaHQ6IHRoaXMuZWxlbWVudC5vdXRlckhlaWdodCgpLFxuXHRcdFx0XHRcdHRvcDogdGhpcy5lbGVtZW50LmNzcygndG9wJyksXG5cdFx0XHRcdFx0bGVmdDogdGhpcy5lbGVtZW50LmNzcygnbGVmdCcpXG5cdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0XHQvL092ZXJ3cml0ZSB0aGUgb3JpZ2luYWwgdGhpcy5lbGVtZW50XG5cdFx0XHR0aGlzLmVsZW1lbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50KCkuZGF0YShcblx0XHRcdFx0XCJyZXNpemFibGVcIiwgdGhpcy5lbGVtZW50LmRhdGEoJ3Jlc2l6YWJsZScpXG5cdFx0XHQpO1xuXG5cdFx0XHR0aGlzLmVsZW1lbnRJc1dyYXBwZXIgPSB0cnVlO1xuXG5cdFx0XHQvL01vdmUgbWFyZ2lucyB0byB0aGUgd3JhcHBlclxuXHRcdFx0dGhpcy5lbGVtZW50LmNzcyh7IG1hcmdpbkxlZnQ6IHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyhcIm1hcmdpbkxlZnRcIiksIG1hcmdpblRvcDogdGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKFwibWFyZ2luVG9wXCIpLCBtYXJnaW5SaWdodDogdGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKFwibWFyZ2luUmlnaHRcIiksIG1hcmdpbkJvdHRvbTogdGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKFwibWFyZ2luQm90dG9tXCIpIH0pO1xuXHRcdFx0dGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKHsgbWFyZ2luTGVmdDogMCwgbWFyZ2luVG9wOiAwLCBtYXJnaW5SaWdodDogMCwgbWFyZ2luQm90dG9tOiAwfSk7XG5cblx0XHRcdC8vUHJldmVudCBTYWZhcmkgdGV4dGFyZWEgcmVzaXplXG5cdFx0XHR0aGlzLm9yaWdpbmFsUmVzaXplU3R5bGUgPSB0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoJ3Jlc2l6ZScpO1xuXHRcdFx0dGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKCdyZXNpemUnLCAnbm9uZScpO1xuXG5cdFx0XHQvL1B1c2ggdGhlIGFjdHVhbCBlbGVtZW50IHRvIG91ciBwcm9wb3J0aW9uYWxseVJlc2l6ZSBpbnRlcm5hbCBhcnJheVxuXHRcdFx0dGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50cy5wdXNoKHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyh7IHBvc2l0aW9uOiAnc3RhdGljJywgem9vbTogMSwgZGlzcGxheTogJ2Jsb2NrJyB9KSk7XG5cblx0XHRcdC8vIGF2b2lkIElFIGp1bXAgKGhhcmQgc2V0IHRoZSBtYXJnaW4pXG5cdFx0XHR0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoeyBtYXJnaW46IHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcygnbWFyZ2luJykgfSk7XG5cblx0XHRcdC8vIGZpeCBoYW5kbGVycyBvZmZzZXRcblx0XHRcdHRoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplKCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmhhbmRsZXMgPSBvLmhhbmRsZXMgfHwgKCEkKCcudWktcmVzaXphYmxlLWhhbmRsZScsIHRoaXMuZWxlbWVudCkubGVuZ3RoID8gXCJlLHMsc2VcIiA6IHsgbjogJy51aS1yZXNpemFibGUtbicsIGU6ICcudWktcmVzaXphYmxlLWUnLCBzOiAnLnVpLXJlc2l6YWJsZS1zJywgdzogJy51aS1yZXNpemFibGUtdycsIHNlOiAnLnVpLXJlc2l6YWJsZS1zZScsIHN3OiAnLnVpLXJlc2l6YWJsZS1zdycsIG5lOiAnLnVpLXJlc2l6YWJsZS1uZScsIG53OiAnLnVpLXJlc2l6YWJsZS1udycgfSk7XG5cdFx0aWYodGhpcy5oYW5kbGVzLmNvbnN0cnVjdG9yID09IFN0cmluZykge1xuXG5cdFx0XHRpZih0aGlzLmhhbmRsZXMgPT0gJ2FsbCcpIHRoaXMuaGFuZGxlcyA9ICduLGUscyx3LHNlLHN3LG5lLG53Jztcblx0XHRcdHZhciBuID0gdGhpcy5oYW5kbGVzLnNwbGl0KFwiLFwiKTsgdGhpcy5oYW5kbGVzID0ge307XG5cblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBuLmxlbmd0aDsgaSsrKSB7XG5cblx0XHRcdFx0dmFyIGhhbmRsZSA9ICQudHJpbShuW2ldKSwgaG5hbWUgPSAndWktcmVzaXphYmxlLScraGFuZGxlO1xuXHRcdFx0XHR2YXIgYXhpcyA9ICQoJzxkaXYgY2xhc3M9XCJ1aS1yZXNpemFibGUtaGFuZGxlICcgKyBobmFtZSArICdcIj48L2Rpdj4nKTtcblxuXHRcdFx0XHQvLyBBcHBseSB6SW5kZXggdG8gYWxsIGhhbmRsZXMgLSBzZWUgIzc5NjBcblx0XHRcdFx0YXhpcy5jc3MoeyB6SW5kZXg6IG8uekluZGV4IH0pO1xuXG5cdFx0XHRcdC8vVE9ETyA6IFdoYXQncyBnb2luZyBvbiBoZXJlP1xuXHRcdFx0XHRpZiAoJ3NlJyA9PSBoYW5kbGUpIHtcblx0XHRcdFx0XHRheGlzLmFkZENsYXNzKCd1aS1pY29uIHVpLWljb24tZ3JpcHNtYWxsLWRpYWdvbmFsLXNlJyk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly9JbnNlcnQgaW50byBpbnRlcm5hbCBoYW5kbGVzIG9iamVjdCBhbmQgYXBwZW5kIHRvIGVsZW1lbnRcblx0XHRcdFx0dGhpcy5oYW5kbGVzW2hhbmRsZV0gPSAnLnVpLXJlc2l6YWJsZS0nK2hhbmRsZTtcblx0XHRcdFx0dGhpcy5lbGVtZW50LmFwcGVuZChheGlzKTtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuX3JlbmRlckF4aXMgPSBmdW5jdGlvbih0YXJnZXQpIHtcblxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0IHx8IHRoaXMuZWxlbWVudDtcblxuXHRcdFx0Zm9yKHZhciBpIGluIHRoaXMuaGFuZGxlcykge1xuXG5cdFx0XHRcdGlmKHRoaXMuaGFuZGxlc1tpXS5jb25zdHJ1Y3RvciA9PSBTdHJpbmcpXG5cdFx0XHRcdFx0dGhpcy5oYW5kbGVzW2ldID0gJCh0aGlzLmhhbmRsZXNbaV0sIHRoaXMuZWxlbWVudCkuc2hvdygpO1xuXG5cdFx0XHRcdC8vQXBwbHkgcGFkIHRvIHdyYXBwZXIgZWxlbWVudCwgbmVlZGVkIHRvIGZpeCBheGlzIHBvc2l0aW9uICh0ZXh0YXJlYSwgaW5wdXRzLCBzY3JvbGxzKVxuXHRcdFx0XHRpZiAodGhpcy5lbGVtZW50SXNXcmFwcGVyICYmIHRoaXMub3JpZ2luYWxFbGVtZW50WzBdLm5vZGVOYW1lLm1hdGNoKC90ZXh0YXJlYXxpbnB1dHxzZWxlY3R8YnV0dG9uL2kpKSB7XG5cblx0XHRcdFx0XHR2YXIgYXhpcyA9ICQodGhpcy5oYW5kbGVzW2ldLCB0aGlzLmVsZW1lbnQpLCBwYWRXcmFwcGVyID0gMDtcblxuXHRcdFx0XHRcdC8vQ2hlY2tpbmcgdGhlIGNvcnJlY3QgcGFkIGFuZCBib3JkZXJcblx0XHRcdFx0XHRwYWRXcmFwcGVyID0gL3N3fG5lfG53fHNlfG58cy8udGVzdChpKSA/IGF4aXMub3V0ZXJIZWlnaHQoKSA6IGF4aXMub3V0ZXJXaWR0aCgpO1xuXG5cdFx0XHRcdFx0Ly9UaGUgcGFkZGluZyB0eXBlIGkgaGF2ZSB0byBhcHBseS4uLlxuXHRcdFx0XHRcdHZhciBwYWRQb3MgPSBbICdwYWRkaW5nJyxcblx0XHRcdFx0XHRcdC9uZXxud3xuLy50ZXN0KGkpID8gJ1RvcCcgOlxuXHRcdFx0XHRcdFx0L3NlfHN3fHMvLnRlc3QoaSkgPyAnQm90dG9tJyA6XG5cdFx0XHRcdFx0XHQvXmUkLy50ZXN0KGkpID8gJ1JpZ2h0JyA6ICdMZWZ0JyBdLmpvaW4oXCJcIik7XG5cblx0XHRcdFx0XHR0YXJnZXQuY3NzKHBhZFBvcywgcGFkV3JhcHBlcik7XG5cblx0XHRcdFx0XHR0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL1RPRE86IFdoYXQncyB0aGF0IGdvb2QgZm9yPyBUaGVyZSdzIG5vdCBhbnl0aGluZyB0byBiZSBleGVjdXRlZCBsZWZ0XG5cdFx0XHRcdGlmKCEkKHRoaXMuaGFuZGxlc1tpXSkubGVuZ3RoKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vVE9ETzogbWFrZSByZW5kZXJBeGlzIGEgcHJvdG90eXBlIGZ1bmN0aW9uXG5cdFx0dGhpcy5fcmVuZGVyQXhpcyh0aGlzLmVsZW1lbnQpO1xuXG5cdFx0dGhpcy5faGFuZGxlcyA9ICQoJy51aS1yZXNpemFibGUtaGFuZGxlJywgdGhpcy5lbGVtZW50KVxuXHRcdFx0LmRpc2FibGVTZWxlY3Rpb24oKTtcblxuXHRcdC8vTWF0Y2hpbmcgYXhpcyBuYW1lXG5cdFx0dGhpcy5faGFuZGxlcy5tb3VzZW92ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIXRoYXQucmVzaXppbmcpIHtcblx0XHRcdFx0aWYgKHRoaXMuY2xhc3NOYW1lKVxuXHRcdFx0XHRcdHZhciBheGlzID0gdGhpcy5jbGFzc05hbWUubWF0Y2goL3VpLXJlc2l6YWJsZS0oc2V8c3d8bmV8bnd8bnxlfHN8dykvaSk7XG5cdFx0XHRcdC8vQXhpcywgZGVmYXVsdCA9IHNlXG5cdFx0XHRcdHRoYXQuYXhpcyA9IGF4aXMgJiYgYXhpc1sxXSA/IGF4aXNbMV0gOiAnc2UnO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly9JZiB3ZSB3YW50IHRvIGF1dG8gaGlkZSB0aGUgZWxlbWVudHNcblx0XHRpZiAoby5hdXRvSGlkZSkge1xuXHRcdFx0dGhpcy5faGFuZGxlcy5oaWRlKCk7XG5cdFx0XHQkKHRoaXMuZWxlbWVudClcblx0XHRcdFx0LmFkZENsYXNzKFwidWktcmVzaXphYmxlLWF1dG9oaWRlXCIpXG5cdFx0XHRcdC5tb3VzZWVudGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmIChvLmRpc2FibGVkKSByZXR1cm47XG5cdFx0XHRcdFx0JCh0aGlzKS5yZW1vdmVDbGFzcyhcInVpLXJlc2l6YWJsZS1hdXRvaGlkZVwiKTtcblx0XHRcdFx0XHR0aGF0Ll9oYW5kbGVzLnNob3coKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0Lm1vdXNlbGVhdmUoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRpZiAoby5kaXNhYmxlZCkgcmV0dXJuO1xuXHRcdFx0XHRcdGlmICghdGhhdC5yZXNpemluZykge1xuXHRcdFx0XHRcdFx0JCh0aGlzKS5hZGRDbGFzcyhcInVpLXJlc2l6YWJsZS1hdXRvaGlkZVwiKTtcblx0XHRcdFx0XHRcdHRoYXQuX2hhbmRsZXMuaGlkZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly9Jbml0aWFsaXplIHRoZSBtb3VzZSBpbnRlcmFjdGlvblxuXHRcdHRoaXMuX21vdXNlSW5pdCgpO1xuXG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dGhpcy5fbW91c2VEZXN0cm95KCk7XG5cblx0XHR2YXIgX2Rlc3Ryb3kgPSBmdW5jdGlvbihleHApIHtcblx0XHRcdCQoZXhwKS5yZW1vdmVDbGFzcyhcInVpLXJlc2l6YWJsZSB1aS1yZXNpemFibGUtZGlzYWJsZWQgdWktcmVzaXphYmxlLXJlc2l6aW5nXCIpXG5cdFx0XHRcdC5yZW1vdmVEYXRhKFwicmVzaXphYmxlXCIpLnJlbW92ZURhdGEoXCJ1aS1yZXNpemFibGVcIikudW5iaW5kKFwiLnJlc2l6YWJsZVwiKS5maW5kKCcudWktcmVzaXphYmxlLWhhbmRsZScpLnJlbW92ZSgpO1xuXHRcdH07XG5cblx0XHQvL1RPRE86IFVud3JhcCBhdCBzYW1lIERPTSBwb3NpdGlvblxuXHRcdGlmICh0aGlzLmVsZW1lbnRJc1dyYXBwZXIpIHtcblx0XHRcdF9kZXN0cm95KHRoaXMuZWxlbWVudCk7XG5cdFx0XHR2YXIgd3JhcHBlciA9IHRoaXMuZWxlbWVudDtcblx0XHRcdHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyh7XG5cdFx0XHRcdHBvc2l0aW9uOiB3cmFwcGVyLmNzcygncG9zaXRpb24nKSxcblx0XHRcdFx0d2lkdGg6IHdyYXBwZXIub3V0ZXJXaWR0aCgpLFxuXHRcdFx0XHRoZWlnaHQ6IHdyYXBwZXIub3V0ZXJIZWlnaHQoKSxcblx0XHRcdFx0dG9wOiB3cmFwcGVyLmNzcygndG9wJyksXG5cdFx0XHRcdGxlZnQ6IHdyYXBwZXIuY3NzKCdsZWZ0Jylcblx0XHRcdH0pLmluc2VydEFmdGVyKCB3cmFwcGVyICk7XG5cdFx0XHR3cmFwcGVyLnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcygncmVzaXplJywgdGhpcy5vcmlnaW5hbFJlc2l6ZVN0eWxlKTtcblx0XHRfZGVzdHJveSh0aGlzLm9yaWdpbmFsRWxlbWVudCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfbW91c2VDYXB0dXJlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBoYW5kbGUgPSBmYWxzZTtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuaGFuZGxlcykge1xuXHRcdFx0aWYgKCQodGhpcy5oYW5kbGVzW2ldKVswXSA9PSBldmVudC50YXJnZXQpIHtcblx0XHRcdFx0aGFuZGxlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gIXRoaXMub3B0aW9ucy5kaXNhYmxlZCAmJiBoYW5kbGU7XG5cdH0sXG5cblx0X21vdXNlU3RhcnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucywgaW5pUG9zID0gdGhpcy5lbGVtZW50LnBvc2l0aW9uKCksIGVsID0gdGhpcy5lbGVtZW50O1xuXG5cdFx0dGhpcy5yZXNpemluZyA9IHRydWU7XG5cdFx0dGhpcy5kb2N1bWVudFNjcm9sbCA9IHsgdG9wOiAkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSwgbGVmdDogJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpIH07XG5cblx0XHQvLyBidWdmaXggZm9yIGh0dHA6Ly9kZXYuanF1ZXJ5LmNvbS90aWNrZXQvMTc0OVxuXHRcdGlmIChlbC5pcygnLnVpLWRyYWdnYWJsZScpIHx8ICgvYWJzb2x1dGUvKS50ZXN0KGVsLmNzcygncG9zaXRpb24nKSkpIHtcblx0XHRcdGVsLmNzcyh7IHBvc2l0aW9uOiAnYWJzb2x1dGUnLCB0b3A6IGluaVBvcy50b3AsIGxlZnQ6IGluaVBvcy5sZWZ0IH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuX3JlbmRlclByb3h5KCk7XG5cblx0XHR2YXIgY3VybGVmdCA9IG51bSh0aGlzLmhlbHBlci5jc3MoJ2xlZnQnKSksIGN1cnRvcCA9IG51bSh0aGlzLmhlbHBlci5jc3MoJ3RvcCcpKTtcblxuXHRcdGlmIChvLmNvbnRhaW5tZW50KSB7XG5cdFx0XHRjdXJsZWZ0ICs9ICQoby5jb250YWlubWVudCkuc2Nyb2xsTGVmdCgpIHx8IDA7XG5cdFx0XHRjdXJ0b3AgKz0gJChvLmNvbnRhaW5tZW50KS5zY3JvbGxUb3AoKSB8fCAwO1xuXHRcdH1cblxuXHRcdC8vU3RvcmUgbmVlZGVkIHZhcmlhYmxlc1xuXHRcdHRoaXMub2Zmc2V0ID0gdGhpcy5oZWxwZXIub2Zmc2V0KCk7XG5cdFx0dGhpcy5wb3NpdGlvbiA9IHsgbGVmdDogY3VybGVmdCwgdG9wOiBjdXJ0b3AgfTtcblx0XHR0aGlzLnNpemUgPSB0aGlzLl9oZWxwZXIgPyB7IHdpZHRoOiBlbC5vdXRlcldpZHRoKCksIGhlaWdodDogZWwub3V0ZXJIZWlnaHQoKSB9IDogeyB3aWR0aDogZWwud2lkdGgoKSwgaGVpZ2h0OiBlbC5oZWlnaHQoKSB9O1xuXHRcdHRoaXMub3JpZ2luYWxTaXplID0gdGhpcy5faGVscGVyID8geyB3aWR0aDogZWwub3V0ZXJXaWR0aCgpLCBoZWlnaHQ6IGVsLm91dGVySGVpZ2h0KCkgfSA6IHsgd2lkdGg6IGVsLndpZHRoKCksIGhlaWdodDogZWwuaGVpZ2h0KCkgfTtcblx0XHR0aGlzLm9yaWdpbmFsUG9zaXRpb24gPSB7IGxlZnQ6IGN1cmxlZnQsIHRvcDogY3VydG9wIH07XG5cdFx0dGhpcy5zaXplRGlmZiA9IHsgd2lkdGg6IGVsLm91dGVyV2lkdGgoKSAtIGVsLndpZHRoKCksIGhlaWdodDogZWwub3V0ZXJIZWlnaHQoKSAtIGVsLmhlaWdodCgpIH07XG5cdFx0dGhpcy5vcmlnaW5hbE1vdXNlUG9zaXRpb24gPSB7IGxlZnQ6IGV2ZW50LnBhZ2VYLCB0b3A6IGV2ZW50LnBhZ2VZIH07XG5cblx0XHQvL0FzcGVjdCBSYXRpb1xuXHRcdHRoaXMuYXNwZWN0UmF0aW8gPSAodHlwZW9mIG8uYXNwZWN0UmF0aW8gPT0gJ251bWJlcicpID8gby5hc3BlY3RSYXRpbyA6ICgodGhpcy5vcmlnaW5hbFNpemUud2lkdGggLyB0aGlzLm9yaWdpbmFsU2l6ZS5oZWlnaHQpIHx8IDEpO1xuXG5cdFx0dmFyIGN1cnNvciA9ICQoJy51aS1yZXNpemFibGUtJyArIHRoaXMuYXhpcykuY3NzKCdjdXJzb3InKTtcblx0XHQkKCdib2R5JykuY3NzKCdjdXJzb3InLCBjdXJzb3IgPT0gJ2F1dG8nID8gdGhpcy5heGlzICsgJy1yZXNpemUnIDogY3Vyc29yKTtcblxuXHRcdGVsLmFkZENsYXNzKFwidWktcmVzaXphYmxlLXJlc2l6aW5nXCIpO1xuXHRcdHRoaXMuX3Byb3BhZ2F0ZShcInN0YXJ0XCIsIGV2ZW50KTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfbW91c2VEcmFnOiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0Ly9JbmNyZWFzZSBwZXJmb3JtYW5jZSwgYXZvaWQgcmVnZXhcblx0XHR2YXIgZWwgPSB0aGlzLmhlbHBlciwgbyA9IHRoaXMub3B0aW9ucywgcHJvcHMgPSB7fSxcblx0XHRcdHRoYXQgPSB0aGlzLCBzbXAgPSB0aGlzLm9yaWdpbmFsTW91c2VQb3NpdGlvbiwgYSA9IHRoaXMuYXhpcztcblxuXHRcdHZhciBkeCA9IChldmVudC5wYWdlWC1zbXAubGVmdCl8fDAsIGR5ID0gKGV2ZW50LnBhZ2VZLXNtcC50b3ApfHwwO1xuXHRcdHZhciB0cmlnZ2VyID0gdGhpcy5fY2hhbmdlW2FdO1xuXHRcdGlmICghdHJpZ2dlcikgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Ly8gQ2FsY3VsYXRlIHRoZSBhdHRycyB0aGF0IHdpbGwgYmUgY2hhbmdlXG5cdFx0dmFyIGRhdGEgPSB0cmlnZ2VyLmFwcGx5KHRoaXMsIFtldmVudCwgZHgsIGR5XSk7XG5cblx0XHQvLyBQdXQgdGhpcyBpbiB0aGUgbW91c2VEcmFnIGhhbmRsZXIgc2luY2UgdGhlIHVzZXIgY2FuIHN0YXJ0IHByZXNzaW5nIHNoaWZ0IHdoaWxlIHJlc2l6aW5nXG5cdFx0dGhpcy5fdXBkYXRlVmlydHVhbEJvdW5kYXJpZXMoZXZlbnQuc2hpZnRLZXkpO1xuXHRcdGlmICh0aGlzLl9hc3BlY3RSYXRpbyB8fCBldmVudC5zaGlmdEtleSlcblx0XHRcdGRhdGEgPSB0aGlzLl91cGRhdGVSYXRpbyhkYXRhLCBldmVudCk7XG5cblx0XHRkYXRhID0gdGhpcy5fcmVzcGVjdFNpemUoZGF0YSwgZXZlbnQpO1xuXG5cdFx0Ly8gcGx1Z2lucyBjYWxsYmFja3MgbmVlZCB0byBiZSBjYWxsZWQgZmlyc3Rcblx0XHR0aGlzLl9wcm9wYWdhdGUoXCJyZXNpemVcIiwgZXZlbnQpO1xuXG5cdFx0ZWwuY3NzKHtcblx0XHRcdHRvcDogdGhpcy5wb3NpdGlvbi50b3AgKyBcInB4XCIsIGxlZnQ6IHRoaXMucG9zaXRpb24ubGVmdCArIFwicHhcIixcblx0XHRcdHdpZHRoOiB0aGlzLnNpemUud2lkdGggKyBcInB4XCIsIGhlaWdodDogdGhpcy5zaXplLmhlaWdodCArIFwicHhcIlxuXHRcdH0pO1xuXG5cdFx0aWYgKCF0aGlzLl9oZWxwZXIgJiYgdGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50cy5sZW5ndGgpXG5cdFx0XHR0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZSgpO1xuXG5cdFx0dGhpcy5fdXBkYXRlQ2FjaGUoZGF0YSk7XG5cblx0XHQvLyBjYWxsaW5nIHRoZSB1c2VyIGNhbGxiYWNrIGF0IHRoZSBlbmRcblx0XHR0aGlzLl90cmlnZ2VyKCdyZXNpemUnLCBldmVudCwgdGhpcy51aSgpKTtcblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfbW91c2VTdG9wOiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0dGhpcy5yZXNpemluZyA9IGZhbHNlO1xuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zLCB0aGF0ID0gdGhpcztcblxuXHRcdGlmKHRoaXMuX2hlbHBlcikge1xuXHRcdFx0dmFyIHByID0gdGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50cywgaXN0YSA9IHByLmxlbmd0aCAmJiAoL3RleHRhcmVhL2kpLnRlc3QocHJbMF0ubm9kZU5hbWUpLFxuXHRcdFx0XHRzb2Zmc2V0aCA9IGlzdGEgJiYgJC51aS5oYXNTY3JvbGwocHJbMF0sICdsZWZ0JykgLyogVE9ETyAtIGp1bXAgaGVpZ2h0ICovID8gMCA6IHRoYXQuc2l6ZURpZmYuaGVpZ2h0LFxuXHRcdFx0XHRzb2Zmc2V0dyA9IGlzdGEgPyAwIDogdGhhdC5zaXplRGlmZi53aWR0aDtcblxuXHRcdFx0dmFyIHMgPSB7IHdpZHRoOiAodGhhdC5oZWxwZXIud2lkdGgoKSAgLSBzb2Zmc2V0dyksIGhlaWdodDogKHRoYXQuaGVscGVyLmhlaWdodCgpIC0gc29mZnNldGgpIH0sXG5cdFx0XHRcdGxlZnQgPSAocGFyc2VJbnQodGhhdC5lbGVtZW50LmNzcygnbGVmdCcpLCAxMCkgKyAodGhhdC5wb3NpdGlvbi5sZWZ0IC0gdGhhdC5vcmlnaW5hbFBvc2l0aW9uLmxlZnQpKSB8fCBudWxsLFxuXHRcdFx0XHR0b3AgPSAocGFyc2VJbnQodGhhdC5lbGVtZW50LmNzcygndG9wJyksIDEwKSArICh0aGF0LnBvc2l0aW9uLnRvcCAtIHRoYXQub3JpZ2luYWxQb3NpdGlvbi50b3ApKSB8fCBudWxsO1xuXG5cdFx0XHRpZiAoIW8uYW5pbWF0ZSlcblx0XHRcdFx0dGhpcy5lbGVtZW50LmNzcygkLmV4dGVuZChzLCB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0pKTtcblxuXHRcdFx0dGhhdC5oZWxwZXIuaGVpZ2h0KHRoYXQuc2l6ZS5oZWlnaHQpO1xuXHRcdFx0dGhhdC5oZWxwZXIud2lkdGgodGhhdC5zaXplLndpZHRoKTtcblxuXHRcdFx0aWYgKHRoaXMuX2hlbHBlciAmJiAhby5hbmltYXRlKSB0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZSgpO1xuXHRcdH1cblxuXHRcdCQoJ2JvZHknKS5jc3MoJ2N1cnNvcicsICdhdXRvJyk7XG5cblx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJ1aS1yZXNpemFibGUtcmVzaXppbmdcIik7XG5cblx0XHR0aGlzLl9wcm9wYWdhdGUoXCJzdG9wXCIsIGV2ZW50KTtcblxuXHRcdGlmICh0aGlzLl9oZWxwZXIpIHRoaXMuaGVscGVyLnJlbW92ZSgpO1xuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9LFxuXG5cdF91cGRhdGVWaXJ0dWFsQm91bmRhcmllczogZnVuY3Rpb24oZm9yY2VBc3BlY3RSYXRpbykge1xuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zLCBwTWluV2lkdGgsIHBNYXhXaWR0aCwgcE1pbkhlaWdodCwgcE1heEhlaWdodCwgYjtcblxuXHRcdGIgPSB7XG5cdFx0XHRtaW5XaWR0aDogaXNOdW1iZXIoby5taW5XaWR0aCkgPyBvLm1pbldpZHRoIDogMCxcblx0XHRcdG1heFdpZHRoOiBpc051bWJlcihvLm1heFdpZHRoKSA/IG8ubWF4V2lkdGggOiBJbmZpbml0eSxcblx0XHRcdG1pbkhlaWdodDogaXNOdW1iZXIoby5taW5IZWlnaHQpID8gby5taW5IZWlnaHQgOiAwLFxuXHRcdFx0bWF4SGVpZ2h0OiBpc051bWJlcihvLm1heEhlaWdodCkgPyBvLm1heEhlaWdodCA6IEluZmluaXR5XG5cdFx0fTtcblxuXHRcdGlmKHRoaXMuX2FzcGVjdFJhdGlvIHx8IGZvcmNlQXNwZWN0UmF0aW8pIHtcblx0XHRcdC8vIFdlIHdhbnQgdG8gY3JlYXRlIGFuIGVuY2xvc2luZyBib3ggd2hvc2UgYXNwZWN0IHJhdGlvbiBpcyB0aGUgcmVxdWVzdGVkIG9uZVxuXHRcdFx0Ly8gRmlyc3QsIGNvbXB1dGUgdGhlIFwicHJvamVjdGVkXCIgc2l6ZSBmb3IgZWFjaCBkaW1lbnNpb24gYmFzZWQgb24gdGhlIGFzcGVjdCByYXRpbyBhbmQgb3RoZXIgZGltZW5zaW9uXG5cdFx0XHRwTWluV2lkdGggPSBiLm1pbkhlaWdodCAqIHRoaXMuYXNwZWN0UmF0aW87XG5cdFx0XHRwTWluSGVpZ2h0ID0gYi5taW5XaWR0aCAvIHRoaXMuYXNwZWN0UmF0aW87XG5cdFx0XHRwTWF4V2lkdGggPSBiLm1heEhlaWdodCAqIHRoaXMuYXNwZWN0UmF0aW87XG5cdFx0XHRwTWF4SGVpZ2h0ID0gYi5tYXhXaWR0aCAvIHRoaXMuYXNwZWN0UmF0aW87XG5cblx0XHRcdGlmKHBNaW5XaWR0aCA+IGIubWluV2lkdGgpIGIubWluV2lkdGggPSBwTWluV2lkdGg7XG5cdFx0XHRpZihwTWluSGVpZ2h0ID4gYi5taW5IZWlnaHQpIGIubWluSGVpZ2h0ID0gcE1pbkhlaWdodDtcblx0XHRcdGlmKHBNYXhXaWR0aCA8IGIubWF4V2lkdGgpIGIubWF4V2lkdGggPSBwTWF4V2lkdGg7XG5cdFx0XHRpZihwTWF4SGVpZ2h0IDwgYi5tYXhIZWlnaHQpIGIubWF4SGVpZ2h0ID0gcE1heEhlaWdodDtcblx0XHR9XG5cdFx0dGhpcy5fdkJvdW5kYXJpZXMgPSBiO1xuXHR9LFxuXG5cdF91cGRhdGVDYWNoZTogZnVuY3Rpb24oZGF0YSkge1xuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zO1xuXHRcdHRoaXMub2Zmc2V0ID0gdGhpcy5oZWxwZXIub2Zmc2V0KCk7XG5cdFx0aWYgKGlzTnVtYmVyKGRhdGEubGVmdCkpIHRoaXMucG9zaXRpb24ubGVmdCA9IGRhdGEubGVmdDtcblx0XHRpZiAoaXNOdW1iZXIoZGF0YS50b3ApKSB0aGlzLnBvc2l0aW9uLnRvcCA9IGRhdGEudG9wO1xuXHRcdGlmIChpc051bWJlcihkYXRhLmhlaWdodCkpIHRoaXMuc2l6ZS5oZWlnaHQgPSBkYXRhLmhlaWdodDtcblx0XHRpZiAoaXNOdW1iZXIoZGF0YS53aWR0aCkpIHRoaXMuc2l6ZS53aWR0aCA9IGRhdGEud2lkdGg7XG5cdH0sXG5cblx0X3VwZGF0ZVJhdGlvOiBmdW5jdGlvbihkYXRhLCBldmVudCkge1xuXG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnMsIGNwb3MgPSB0aGlzLnBvc2l0aW9uLCBjc2l6ZSA9IHRoaXMuc2l6ZSwgYSA9IHRoaXMuYXhpcztcblxuXHRcdGlmIChpc051bWJlcihkYXRhLmhlaWdodCkpIGRhdGEud2lkdGggPSAoZGF0YS5oZWlnaHQgKiB0aGlzLmFzcGVjdFJhdGlvKTtcblx0XHRlbHNlIGlmIChpc051bWJlcihkYXRhLndpZHRoKSkgZGF0YS5oZWlnaHQgPSAoZGF0YS53aWR0aCAvIHRoaXMuYXNwZWN0UmF0aW8pO1xuXG5cdFx0aWYgKGEgPT0gJ3N3Jykge1xuXHRcdFx0ZGF0YS5sZWZ0ID0gY3Bvcy5sZWZ0ICsgKGNzaXplLndpZHRoIC0gZGF0YS53aWR0aCk7XG5cdFx0XHRkYXRhLnRvcCA9IG51bGw7XG5cdFx0fVxuXHRcdGlmIChhID09ICdudycpIHtcblx0XHRcdGRhdGEudG9wID0gY3Bvcy50b3AgKyAoY3NpemUuaGVpZ2h0IC0gZGF0YS5oZWlnaHQpO1xuXHRcdFx0ZGF0YS5sZWZ0ID0gY3Bvcy5sZWZ0ICsgKGNzaXplLndpZHRoIC0gZGF0YS53aWR0aCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cdH0sXG5cblx0X3Jlc3BlY3RTaXplOiBmdW5jdGlvbihkYXRhLCBldmVudCkge1xuXG5cdFx0dmFyIGVsID0gdGhpcy5oZWxwZXIsIG8gPSB0aGlzLl92Qm91bmRhcmllcywgcFJhdGlvID0gdGhpcy5fYXNwZWN0UmF0aW8gfHwgZXZlbnQuc2hpZnRLZXksIGEgPSB0aGlzLmF4aXMsXG5cdFx0XHRcdGlzbWF4dyA9IGlzTnVtYmVyKGRhdGEud2lkdGgpICYmIG8ubWF4V2lkdGggJiYgKG8ubWF4V2lkdGggPCBkYXRhLndpZHRoKSwgaXNtYXhoID0gaXNOdW1iZXIoZGF0YS5oZWlnaHQpICYmIG8ubWF4SGVpZ2h0ICYmIChvLm1heEhlaWdodCA8IGRhdGEuaGVpZ2h0KSxcblx0XHRcdFx0XHRpc21pbncgPSBpc051bWJlcihkYXRhLndpZHRoKSAmJiBvLm1pbldpZHRoICYmIChvLm1pbldpZHRoID4gZGF0YS53aWR0aCksIGlzbWluaCA9IGlzTnVtYmVyKGRhdGEuaGVpZ2h0KSAmJiBvLm1pbkhlaWdodCAmJiAoby5taW5IZWlnaHQgPiBkYXRhLmhlaWdodCk7XG5cblx0XHRpZiAoaXNtaW53KSBkYXRhLndpZHRoID0gby5taW5XaWR0aDtcblx0XHRpZiAoaXNtaW5oKSBkYXRhLmhlaWdodCA9IG8ubWluSGVpZ2h0O1xuXHRcdGlmIChpc21heHcpIGRhdGEud2lkdGggPSBvLm1heFdpZHRoO1xuXHRcdGlmIChpc21heGgpIGRhdGEuaGVpZ2h0ID0gby5tYXhIZWlnaHQ7XG5cblx0XHR2YXIgZHcgPSB0aGlzLm9yaWdpbmFsUG9zaXRpb24ubGVmdCArIHRoaXMub3JpZ2luYWxTaXplLndpZHRoLCBkaCA9IHRoaXMucG9zaXRpb24udG9wICsgdGhpcy5zaXplLmhlaWdodDtcblx0XHR2YXIgY3cgPSAvc3d8bnd8dy8udGVzdChhKSwgY2ggPSAvbnd8bmV8bi8udGVzdChhKTtcblxuXHRcdGlmIChpc21pbncgJiYgY3cpIGRhdGEubGVmdCA9IGR3IC0gby5taW5XaWR0aDtcblx0XHRpZiAoaXNtYXh3ICYmIGN3KSBkYXRhLmxlZnQgPSBkdyAtIG8ubWF4V2lkdGg7XG5cdFx0aWYgKGlzbWluaCAmJiBjaClcdGRhdGEudG9wID0gZGggLSBvLm1pbkhlaWdodDtcblx0XHRpZiAoaXNtYXhoICYmIGNoKVx0ZGF0YS50b3AgPSBkaCAtIG8ubWF4SGVpZ2h0O1xuXG5cdFx0Ly8gZml4aW5nIGp1bXAgZXJyb3Igb24gdG9wL2xlZnQgLSBidWcgIzIzMzBcblx0XHR2YXIgaXNOb3R3aCA9ICFkYXRhLndpZHRoICYmICFkYXRhLmhlaWdodDtcblx0XHRpZiAoaXNOb3R3aCAmJiAhZGF0YS5sZWZ0ICYmIGRhdGEudG9wKSBkYXRhLnRvcCA9IG51bGw7XG5cdFx0ZWxzZSBpZiAoaXNOb3R3aCAmJiAhZGF0YS50b3AgJiYgZGF0YS5sZWZ0KSBkYXRhLmxlZnQgPSBudWxsO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cdH0sXG5cblx0X3Byb3BvcnRpb25hbGx5UmVzaXplOiBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zO1xuXHRcdGlmICghdGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50cy5sZW5ndGgpIHJldHVybjtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuaGVscGVyIHx8IHRoaXMuZWxlbWVudDtcblxuXHRcdGZvciAodmFyIGk9MDsgaSA8IHRoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblxuXHRcdFx0dmFyIHByZWwgPSB0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZUVsZW1lbnRzW2ldO1xuXG5cdFx0XHRpZiAoIXRoaXMuYm9yZGVyRGlmKSB7XG5cdFx0XHRcdHZhciBiID0gW3ByZWwuY3NzKCdib3JkZXJUb3BXaWR0aCcpLCBwcmVsLmNzcygnYm9yZGVyUmlnaHRXaWR0aCcpLCBwcmVsLmNzcygnYm9yZGVyQm90dG9tV2lkdGgnKSwgcHJlbC5jc3MoJ2JvcmRlckxlZnRXaWR0aCcpXSxcblx0XHRcdFx0XHRwID0gW3ByZWwuY3NzKCdwYWRkaW5nVG9wJyksIHByZWwuY3NzKCdwYWRkaW5nUmlnaHQnKSwgcHJlbC5jc3MoJ3BhZGRpbmdCb3R0b20nKSwgcHJlbC5jc3MoJ3BhZGRpbmdMZWZ0JyldO1xuXG5cdFx0XHRcdHRoaXMuYm9yZGVyRGlmID0gJC5tYXAoYiwgZnVuY3Rpb24odiwgaSkge1xuXHRcdFx0XHRcdHZhciBib3JkZXIgPSBwYXJzZUludCh2LDEwKXx8MCwgcGFkZGluZyA9IHBhcnNlSW50KHBbaV0sMTApfHwwO1xuXHRcdFx0XHRcdHJldHVybiBib3JkZXIgKyBwYWRkaW5nO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0cHJlbC5jc3Moe1xuXHRcdFx0XHRoZWlnaHQ6IChlbGVtZW50LmhlaWdodCgpIC0gdGhpcy5ib3JkZXJEaWZbMF0gLSB0aGlzLmJvcmRlckRpZlsyXSkgfHwgMCxcblx0XHRcdFx0d2lkdGg6IChlbGVtZW50LndpZHRoKCkgLSB0aGlzLmJvcmRlckRpZlsxXSAtIHRoaXMuYm9yZGVyRGlmWzNdKSB8fCAwXG5cdFx0XHR9KTtcblxuXHRcdH07XG5cblx0fSxcblxuXHRfcmVuZGVyUHJveHk6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGVsID0gdGhpcy5lbGVtZW50LCBvID0gdGhpcy5vcHRpb25zO1xuXHRcdHRoaXMuZWxlbWVudE9mZnNldCA9IGVsLm9mZnNldCgpO1xuXG5cdFx0aWYodGhpcy5faGVscGVyKSB7XG5cblx0XHRcdHRoaXMuaGVscGVyID0gdGhpcy5oZWxwZXIgfHwgJCgnPGRpdiBzdHlsZT1cIm92ZXJmbG93OmhpZGRlbjtcIj48L2Rpdj4nKTtcblxuXHRcdFx0Ly8gZml4IGllNiBvZmZzZXQgVE9ETzogVGhpcyBzZWVtcyBicm9rZW5cblx0XHRcdHZhciBpZTZvZmZzZXQgPSAoJC51aS5pZTYgPyAxIDogMCksXG5cdFx0XHRweHlvZmZzZXQgPSAoICQudWkuaWU2ID8gMiA6IC0xICk7XG5cblx0XHRcdHRoaXMuaGVscGVyLmFkZENsYXNzKHRoaXMuX2hlbHBlcikuY3NzKHtcblx0XHRcdFx0d2lkdGg6IHRoaXMuZWxlbWVudC5vdXRlcldpZHRoKCkgKyBweHlvZmZzZXQsXG5cdFx0XHRcdGhlaWdodDogdGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KCkgKyBweHlvZmZzZXQsXG5cdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHRsZWZ0OiB0aGlzLmVsZW1lbnRPZmZzZXQubGVmdCAtIGllNm9mZnNldCArJ3B4Jyxcblx0XHRcdFx0dG9wOiB0aGlzLmVsZW1lbnRPZmZzZXQudG9wIC0gaWU2b2Zmc2V0ICsncHgnLFxuXHRcdFx0XHR6SW5kZXg6ICsrby56SW5kZXggLy9UT0RPOiBEb24ndCBtb2RpZnkgb3B0aW9uXG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5oZWxwZXJcblx0XHRcdFx0LmFwcGVuZFRvKFwiYm9keVwiKVxuXHRcdFx0XHQuZGlzYWJsZVNlbGVjdGlvbigpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuaGVscGVyID0gdGhpcy5lbGVtZW50O1xuXHRcdH1cblxuXHR9LFxuXG5cdF9jaGFuZ2U6IHtcblx0XHRlOiBmdW5jdGlvbihldmVudCwgZHgsIGR5KSB7XG5cdFx0XHRyZXR1cm4geyB3aWR0aDogdGhpcy5vcmlnaW5hbFNpemUud2lkdGggKyBkeCB9O1xuXHRcdH0sXG5cdFx0dzogZnVuY3Rpb24oZXZlbnQsIGR4LCBkeSkge1xuXHRcdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnMsIGNzID0gdGhpcy5vcmlnaW5hbFNpemUsIHNwID0gdGhpcy5vcmlnaW5hbFBvc2l0aW9uO1xuXHRcdFx0cmV0dXJuIHsgbGVmdDogc3AubGVmdCArIGR4LCB3aWR0aDogY3Mud2lkdGggLSBkeCB9O1xuXHRcdH0sXG5cdFx0bjogZnVuY3Rpb24oZXZlbnQsIGR4LCBkeSkge1xuXHRcdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnMsIGNzID0gdGhpcy5vcmlnaW5hbFNpemUsIHNwID0gdGhpcy5vcmlnaW5hbFBvc2l0aW9uO1xuXHRcdFx0cmV0dXJuIHsgdG9wOiBzcC50b3AgKyBkeSwgaGVpZ2h0OiBjcy5oZWlnaHQgLSBkeSB9O1xuXHRcdH0sXG5cdFx0czogZnVuY3Rpb24oZXZlbnQsIGR4LCBkeSkge1xuXHRcdFx0cmV0dXJuIHsgaGVpZ2h0OiB0aGlzLm9yaWdpbmFsU2l6ZS5oZWlnaHQgKyBkeSB9O1xuXHRcdH0sXG5cdFx0c2U6IGZ1bmN0aW9uKGV2ZW50LCBkeCwgZHkpIHtcblx0XHRcdHJldHVybiAkLmV4dGVuZCh0aGlzLl9jaGFuZ2Uucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzLl9jaGFuZ2UuZS5hcHBseSh0aGlzLCBbZXZlbnQsIGR4LCBkeV0pKTtcblx0XHR9LFxuXHRcdHN3OiBmdW5jdGlvbihldmVudCwgZHgsIGR5KSB7XG5cdFx0XHRyZXR1cm4gJC5leHRlbmQodGhpcy5fY2hhbmdlLnMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGhpcy5fY2hhbmdlLncuYXBwbHkodGhpcywgW2V2ZW50LCBkeCwgZHldKSk7XG5cdFx0fSxcblx0XHRuZTogZnVuY3Rpb24oZXZlbnQsIGR4LCBkeSkge1xuXHRcdFx0cmV0dXJuICQuZXh0ZW5kKHRoaXMuX2NoYW5nZS5uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXMuX2NoYW5nZS5lLmFwcGx5KHRoaXMsIFtldmVudCwgZHgsIGR5XSkpO1xuXHRcdH0sXG5cdFx0bnc6IGZ1bmN0aW9uKGV2ZW50LCBkeCwgZHkpIHtcblx0XHRcdHJldHVybiAkLmV4dGVuZCh0aGlzLl9jaGFuZ2Uubi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzLl9jaGFuZ2Uudy5hcHBseSh0aGlzLCBbZXZlbnQsIGR4LCBkeV0pKTtcblx0XHR9XG5cdH0sXG5cblx0X3Byb3BhZ2F0ZTogZnVuY3Rpb24obiwgZXZlbnQpIHtcblx0XHQkLnVpLnBsdWdpbi5jYWxsKHRoaXMsIG4sIFtldmVudCwgdGhpcy51aSgpXSk7XG5cdFx0KG4gIT0gXCJyZXNpemVcIiAmJiB0aGlzLl90cmlnZ2VyKG4sIGV2ZW50LCB0aGlzLnVpKCkpKTtcblx0fSxcblxuXHRwbHVnaW5zOiB7fSxcblxuXHR1aTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG9yaWdpbmFsRWxlbWVudDogdGhpcy5vcmlnaW5hbEVsZW1lbnQsXG5cdFx0XHRlbGVtZW50OiB0aGlzLmVsZW1lbnQsXG5cdFx0XHRoZWxwZXI6IHRoaXMuaGVscGVyLFxuXHRcdFx0cG9zaXRpb246IHRoaXMucG9zaXRpb24sXG5cdFx0XHRzaXplOiB0aGlzLnNpemUsXG5cdFx0XHRvcmlnaW5hbFNpemU6IHRoaXMub3JpZ2luYWxTaXplLFxuXHRcdFx0b3JpZ2luYWxQb3NpdGlvbjogdGhpcy5vcmlnaW5hbFBvc2l0aW9uXG5cdFx0fTtcblx0fVxuXG59KTtcblxuLypcbiAqIFJlc2l6YWJsZSBFeHRlbnNpb25zXG4gKi9cblxuJC51aS5wbHVnaW4uYWRkKFwicmVzaXphYmxlXCIsIFwiYWxzb1Jlc2l6ZVwiLCB7XG5cblx0c3RhcnQ6IGZ1bmN0aW9uIChldmVudCwgdWkpIHtcblx0XHR2YXIgdGhhdCA9ICQodGhpcykuZGF0YShcInJlc2l6YWJsZVwiKSwgbyA9IHRoYXQub3B0aW9ucztcblxuXHRcdHZhciBfc3RvcmUgPSBmdW5jdGlvbiAoZXhwKSB7XG5cdFx0XHQkKGV4cCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsID0gJCh0aGlzKTtcblx0XHRcdFx0ZWwuZGF0YShcInJlc2l6YWJsZS1hbHNvcmVzaXplXCIsIHtcblx0XHRcdFx0XHR3aWR0aDogcGFyc2VJbnQoZWwud2lkdGgoKSwgMTApLCBoZWlnaHQ6IHBhcnNlSW50KGVsLmhlaWdodCgpLCAxMCksXG5cdFx0XHRcdFx0bGVmdDogcGFyc2VJbnQoZWwuY3NzKCdsZWZ0JyksIDEwKSwgdG9wOiBwYXJzZUludChlbC5jc3MoJ3RvcCcpLCAxMClcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0aWYgKHR5cGVvZihvLmFsc29SZXNpemUpID09ICdvYmplY3QnICYmICFvLmFsc29SZXNpemUucGFyZW50Tm9kZSkge1xuXHRcdFx0aWYgKG8uYWxzb1Jlc2l6ZS5sZW5ndGgpIHsgby5hbHNvUmVzaXplID0gby5hbHNvUmVzaXplWzBdOyBfc3RvcmUoby5hbHNvUmVzaXplKTsgfVxuXHRcdFx0ZWxzZSB7ICQuZWFjaChvLmFsc29SZXNpemUsIGZ1bmN0aW9uIChleHApIHsgX3N0b3JlKGV4cCk7IH0pOyB9XG5cdFx0fWVsc2V7XG5cdFx0XHRfc3RvcmUoby5hbHNvUmVzaXplKTtcblx0XHR9XG5cdH0sXG5cblx0cmVzaXplOiBmdW5jdGlvbiAoZXZlbnQsIHVpKSB7XG5cdFx0dmFyIHRoYXQgPSAkKHRoaXMpLmRhdGEoXCJyZXNpemFibGVcIiksIG8gPSB0aGF0Lm9wdGlvbnMsIG9zID0gdGhhdC5vcmlnaW5hbFNpemUsIG9wID0gdGhhdC5vcmlnaW5hbFBvc2l0aW9uO1xuXG5cdFx0dmFyIGRlbHRhID0ge1xuXHRcdFx0aGVpZ2h0OiAodGhhdC5zaXplLmhlaWdodCAtIG9zLmhlaWdodCkgfHwgMCwgd2lkdGg6ICh0aGF0LnNpemUud2lkdGggLSBvcy53aWR0aCkgfHwgMCxcblx0XHRcdHRvcDogKHRoYXQucG9zaXRpb24udG9wIC0gb3AudG9wKSB8fCAwLCBsZWZ0OiAodGhhdC5wb3NpdGlvbi5sZWZ0IC0gb3AubGVmdCkgfHwgMFxuXHRcdH0sXG5cblx0XHRfYWxzb1Jlc2l6ZSA9IGZ1bmN0aW9uIChleHAsIGMpIHtcblx0XHRcdCQoZXhwKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWwgPSAkKHRoaXMpLCBzdGFydCA9ICQodGhpcykuZGF0YShcInJlc2l6YWJsZS1hbHNvcmVzaXplXCIpLCBzdHlsZSA9IHt9LFxuXHRcdFx0XHRcdGNzcyA9IGMgJiYgYy5sZW5ndGggPyBjIDogZWwucGFyZW50cyh1aS5vcmlnaW5hbEVsZW1lbnRbMF0pLmxlbmd0aCA/IFsnd2lkdGgnLCAnaGVpZ2h0J10gOiBbJ3dpZHRoJywgJ2hlaWdodCcsICd0b3AnLCAnbGVmdCddO1xuXG5cdFx0XHRcdCQuZWFjaChjc3MsIGZ1bmN0aW9uIChpLCBwcm9wKSB7XG5cdFx0XHRcdFx0dmFyIHN1bSA9IChzdGFydFtwcm9wXXx8MCkgKyAoZGVsdGFbcHJvcF18fDApO1xuXHRcdFx0XHRcdGlmIChzdW0gJiYgc3VtID49IDApXG5cdFx0XHRcdFx0XHRzdHlsZVtwcm9wXSA9IHN1bSB8fCBudWxsO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRlbC5jc3Moc3R5bGUpO1xuXHRcdFx0fSk7XG5cdFx0fTtcblxuXHRcdGlmICh0eXBlb2Yoby5hbHNvUmVzaXplKSA9PSAnb2JqZWN0JyAmJiAhby5hbHNvUmVzaXplLm5vZGVUeXBlKSB7XG5cdFx0XHQkLmVhY2goby5hbHNvUmVzaXplLCBmdW5jdGlvbiAoZXhwLCBjKSB7IF9hbHNvUmVzaXplKGV4cCwgYyk7IH0pO1xuXHRcdH1lbHNle1xuXHRcdFx0X2Fsc29SZXNpemUoby5hbHNvUmVzaXplKTtcblx0XHR9XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24gKGV2ZW50LCB1aSkge1xuXHRcdCQodGhpcykucmVtb3ZlRGF0YShcInJlc2l6YWJsZS1hbHNvcmVzaXplXCIpO1xuXHR9XG59KTtcblxuJC51aS5wbHVnaW4uYWRkKFwicmVzaXphYmxlXCIsIFwiYW5pbWF0ZVwiLCB7XG5cblx0c3RvcDogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cdFx0dmFyIHRoYXQgPSAkKHRoaXMpLmRhdGEoXCJyZXNpemFibGVcIiksIG8gPSB0aGF0Lm9wdGlvbnM7XG5cblx0XHR2YXIgcHIgPSB0aGF0Ll9wcm9wb3J0aW9uYWxseVJlc2l6ZUVsZW1lbnRzLCBpc3RhID0gcHIubGVuZ3RoICYmICgvdGV4dGFyZWEvaSkudGVzdChwclswXS5ub2RlTmFtZSksXG5cdFx0XHRcdFx0c29mZnNldGggPSBpc3RhICYmICQudWkuaGFzU2Nyb2xsKHByWzBdLCAnbGVmdCcpIC8qIFRPRE8gLSBqdW1wIGhlaWdodCAqLyA/IDAgOiB0aGF0LnNpemVEaWZmLmhlaWdodCxcblx0XHRcdFx0XHRcdHNvZmZzZXR3ID0gaXN0YSA/IDAgOiB0aGF0LnNpemVEaWZmLndpZHRoO1xuXG5cdFx0dmFyIHN0eWxlID0geyB3aWR0aDogKHRoYXQuc2l6ZS53aWR0aCAtIHNvZmZzZXR3KSwgaGVpZ2h0OiAodGhhdC5zaXplLmhlaWdodCAtIHNvZmZzZXRoKSB9LFxuXHRcdFx0XHRcdGxlZnQgPSAocGFyc2VJbnQodGhhdC5lbGVtZW50LmNzcygnbGVmdCcpLCAxMCkgKyAodGhhdC5wb3NpdGlvbi5sZWZ0IC0gdGhhdC5vcmlnaW5hbFBvc2l0aW9uLmxlZnQpKSB8fCBudWxsLFxuXHRcdFx0XHRcdFx0dG9wID0gKHBhcnNlSW50KHRoYXQuZWxlbWVudC5jc3MoJ3RvcCcpLCAxMCkgKyAodGhhdC5wb3NpdGlvbi50b3AgLSB0aGF0Lm9yaWdpbmFsUG9zaXRpb24udG9wKSkgfHwgbnVsbDtcblxuXHRcdHRoYXQuZWxlbWVudC5hbmltYXRlKFxuXHRcdFx0JC5leHRlbmQoc3R5bGUsIHRvcCAmJiBsZWZ0ID8geyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9IDoge30pLCB7XG5cdFx0XHRcdGR1cmF0aW9uOiBvLmFuaW1hdGVEdXJhdGlvbixcblx0XHRcdFx0ZWFzaW5nOiBvLmFuaW1hdGVFYXNpbmcsXG5cdFx0XHRcdHN0ZXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdFx0XHR3aWR0aDogcGFyc2VJbnQodGhhdC5lbGVtZW50LmNzcygnd2lkdGgnKSwgMTApLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBwYXJzZUludCh0aGF0LmVsZW1lbnQuY3NzKCdoZWlnaHQnKSwgMTApLFxuXHRcdFx0XHRcdFx0dG9wOiBwYXJzZUludCh0aGF0LmVsZW1lbnQuY3NzKCd0b3AnKSwgMTApLFxuXHRcdFx0XHRcdFx0bGVmdDogcGFyc2VJbnQodGhhdC5lbGVtZW50LmNzcygnbGVmdCcpLCAxMClcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0aWYgKHByICYmIHByLmxlbmd0aCkgJChwclswXSkuY3NzKHsgd2lkdGg6IGRhdGEud2lkdGgsIGhlaWdodDogZGF0YS5oZWlnaHQgfSk7XG5cblx0XHRcdFx0XHQvLyBwcm9wYWdhdGluZyByZXNpemUsIGFuZCB1cGRhdGluZyB2YWx1ZXMgZm9yIGVhY2ggYW5pbWF0aW9uIHN0ZXBcblx0XHRcdFx0XHR0aGF0Ll91cGRhdGVDYWNoZShkYXRhKTtcblx0XHRcdFx0XHR0aGF0Ll9wcm9wYWdhdGUoXCJyZXNpemVcIiwgZXZlbnQpO1xuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHQpO1xuXHR9XG5cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJyZXNpemFibGVcIiwgXCJjb250YWlubWVudFwiLCB7XG5cblx0c3RhcnQ6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXHRcdHZhciB0aGF0ID0gJCh0aGlzKS5kYXRhKFwicmVzaXphYmxlXCIpLCBvID0gdGhhdC5vcHRpb25zLCBlbCA9IHRoYXQuZWxlbWVudDtcblx0XHR2YXIgb2MgPSBvLmNvbnRhaW5tZW50LFx0Y2UgPSAob2MgaW5zdGFuY2VvZiAkKSA/IG9jLmdldCgwKSA6ICgvcGFyZW50Ly50ZXN0KG9jKSkgPyBlbC5wYXJlbnQoKS5nZXQoMCkgOiBvYztcblx0XHRpZiAoIWNlKSByZXR1cm47XG5cblx0XHR0aGF0LmNvbnRhaW5lckVsZW1lbnQgPSAkKGNlKTtcblxuXHRcdGlmICgvZG9jdW1lbnQvLnRlc3Qob2MpIHx8IG9jID09IGRvY3VtZW50KSB7XG5cdFx0XHR0aGF0LmNvbnRhaW5lck9mZnNldCA9IHsgbGVmdDogMCwgdG9wOiAwIH07XG5cdFx0XHR0aGF0LmNvbnRhaW5lclBvc2l0aW9uID0geyBsZWZ0OiAwLCB0b3A6IDAgfTtcblxuXHRcdFx0dGhhdC5wYXJlbnREYXRhID0ge1xuXHRcdFx0XHRlbGVtZW50OiAkKGRvY3VtZW50KSwgbGVmdDogMCwgdG9wOiAwLFxuXHRcdFx0XHR3aWR0aDogJChkb2N1bWVudCkud2lkdGgoKSwgaGVpZ2h0OiAkKGRvY3VtZW50KS5oZWlnaHQoKSB8fCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUuc2Nyb2xsSGVpZ2h0XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIGknbSBhIG5vZGUsIHNvIGNvbXB1dGUgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tXG5cdFx0ZWxzZSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9ICQoY2UpLCBwID0gW107XG5cdFx0XHQkKFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkxlZnRcIiwgXCJCb3R0b21cIiBdKS5lYWNoKGZ1bmN0aW9uKGksIG5hbWUpIHsgcFtpXSA9IG51bShlbGVtZW50LmNzcyhcInBhZGRpbmdcIiArIG5hbWUpKTsgfSk7XG5cblx0XHRcdHRoYXQuY29udGFpbmVyT2Zmc2V0ID0gZWxlbWVudC5vZmZzZXQoKTtcblx0XHRcdHRoYXQuY29udGFpbmVyUG9zaXRpb24gPSBlbGVtZW50LnBvc2l0aW9uKCk7XG5cdFx0XHR0aGF0LmNvbnRhaW5lclNpemUgPSB7IGhlaWdodDogKGVsZW1lbnQuaW5uZXJIZWlnaHQoKSAtIHBbM10pLCB3aWR0aDogKGVsZW1lbnQuaW5uZXJXaWR0aCgpIC0gcFsxXSkgfTtcblxuXHRcdFx0dmFyIGNvID0gdGhhdC5jb250YWluZXJPZmZzZXQsIGNoID0gdGhhdC5jb250YWluZXJTaXplLmhlaWdodCxcdGN3ID0gdGhhdC5jb250YWluZXJTaXplLndpZHRoLFxuXHRcdFx0XHRcdFx0d2lkdGggPSAoJC51aS5oYXNTY3JvbGwoY2UsIFwibGVmdFwiKSA/IGNlLnNjcm9sbFdpZHRoIDogY3cgKSwgaGVpZ2h0ID0gKCQudWkuaGFzU2Nyb2xsKGNlKSA/IGNlLnNjcm9sbEhlaWdodCA6IGNoKTtcblxuXHRcdFx0dGhhdC5wYXJlbnREYXRhID0ge1xuXHRcdFx0XHRlbGVtZW50OiBjZSwgbGVmdDogY28ubGVmdCwgdG9wOiBjby50b3AsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHRcblx0XHRcdH07XG5cdFx0fVxuXHR9LFxuXG5cdHJlc2l6ZTogZnVuY3Rpb24oZXZlbnQsIHVpKSB7XG5cdFx0dmFyIHRoYXQgPSAkKHRoaXMpLmRhdGEoXCJyZXNpemFibGVcIiksIG8gPSB0aGF0Lm9wdGlvbnMsXG5cdFx0XHRcdHBzID0gdGhhdC5jb250YWluZXJTaXplLCBjbyA9IHRoYXQuY29udGFpbmVyT2Zmc2V0LCBjcyA9IHRoYXQuc2l6ZSwgY3AgPSB0aGF0LnBvc2l0aW9uLFxuXHRcdFx0XHRwUmF0aW8gPSB0aGF0Ll9hc3BlY3RSYXRpbyB8fCBldmVudC5zaGlmdEtleSwgY29wID0geyB0b3A6MCwgbGVmdDowIH0sIGNlID0gdGhhdC5jb250YWluZXJFbGVtZW50O1xuXG5cdFx0aWYgKGNlWzBdICE9IGRvY3VtZW50ICYmICgvc3RhdGljLykudGVzdChjZS5jc3MoJ3Bvc2l0aW9uJykpKSBjb3AgPSBjbztcblxuXHRcdGlmIChjcC5sZWZ0IDwgKHRoYXQuX2hlbHBlciA/IGNvLmxlZnQgOiAwKSkge1xuXHRcdFx0dGhhdC5zaXplLndpZHRoID0gdGhhdC5zaXplLndpZHRoICsgKHRoYXQuX2hlbHBlciA/ICh0aGF0LnBvc2l0aW9uLmxlZnQgLSBjby5sZWZ0KSA6ICh0aGF0LnBvc2l0aW9uLmxlZnQgLSBjb3AubGVmdCkpO1xuXHRcdFx0aWYgKHBSYXRpbykgdGhhdC5zaXplLmhlaWdodCA9IHRoYXQuc2l6ZS53aWR0aCAvIHRoYXQuYXNwZWN0UmF0aW87XG5cdFx0XHR0aGF0LnBvc2l0aW9uLmxlZnQgPSBvLmhlbHBlciA/IGNvLmxlZnQgOiAwO1xuXHRcdH1cblxuXHRcdGlmIChjcC50b3AgPCAodGhhdC5faGVscGVyID8gY28udG9wIDogMCkpIHtcblx0XHRcdHRoYXQuc2l6ZS5oZWlnaHQgPSB0aGF0LnNpemUuaGVpZ2h0ICsgKHRoYXQuX2hlbHBlciA/ICh0aGF0LnBvc2l0aW9uLnRvcCAtIGNvLnRvcCkgOiB0aGF0LnBvc2l0aW9uLnRvcCk7XG5cdFx0XHRpZiAocFJhdGlvKSB0aGF0LnNpemUud2lkdGggPSB0aGF0LnNpemUuaGVpZ2h0ICogdGhhdC5hc3BlY3RSYXRpbztcblx0XHRcdHRoYXQucG9zaXRpb24udG9wID0gdGhhdC5faGVscGVyID8gY28udG9wIDogMDtcblx0XHR9XG5cblx0XHR0aGF0Lm9mZnNldC5sZWZ0ID0gdGhhdC5wYXJlbnREYXRhLmxlZnQrdGhhdC5wb3NpdGlvbi5sZWZ0O1xuXHRcdHRoYXQub2Zmc2V0LnRvcCA9IHRoYXQucGFyZW50RGF0YS50b3ArdGhhdC5wb3NpdGlvbi50b3A7XG5cblx0XHR2YXIgd29zZXQgPSBNYXRoLmFicyggKHRoYXQuX2hlbHBlciA/IHRoYXQub2Zmc2V0LmxlZnQgLSBjb3AubGVmdCA6ICh0aGF0Lm9mZnNldC5sZWZ0IC0gY29wLmxlZnQpKSArIHRoYXQuc2l6ZURpZmYud2lkdGggKSxcblx0XHRcdFx0XHRob3NldCA9IE1hdGguYWJzKCAodGhhdC5faGVscGVyID8gdGhhdC5vZmZzZXQudG9wIC0gY29wLnRvcCA6ICh0aGF0Lm9mZnNldC50b3AgLSBjby50b3ApKSArIHRoYXQuc2l6ZURpZmYuaGVpZ2h0ICk7XG5cblx0XHR2YXIgaXNQYXJlbnQgPSB0aGF0LmNvbnRhaW5lckVsZW1lbnQuZ2V0KDApID09IHRoYXQuZWxlbWVudC5wYXJlbnQoKS5nZXQoMCksXG5cdFx0XHRpc09mZnNldFJlbGF0aXZlID0gL3JlbGF0aXZlfGFic29sdXRlLy50ZXN0KHRoYXQuY29udGFpbmVyRWxlbWVudC5jc3MoJ3Bvc2l0aW9uJykpO1xuXG5cdFx0aWYoaXNQYXJlbnQgJiYgaXNPZmZzZXRSZWxhdGl2ZSkgd29zZXQgLT0gdGhhdC5wYXJlbnREYXRhLmxlZnQ7XG5cblx0XHRpZiAod29zZXQgKyB0aGF0LnNpemUud2lkdGggPj0gdGhhdC5wYXJlbnREYXRhLndpZHRoKSB7XG5cdFx0XHR0aGF0LnNpemUud2lkdGggPSB0aGF0LnBhcmVudERhdGEud2lkdGggLSB3b3NldDtcblx0XHRcdGlmIChwUmF0aW8pIHRoYXQuc2l6ZS5oZWlnaHQgPSB0aGF0LnNpemUud2lkdGggLyB0aGF0LmFzcGVjdFJhdGlvO1xuXHRcdH1cblxuXHRcdGlmIChob3NldCArIHRoYXQuc2l6ZS5oZWlnaHQgPj0gdGhhdC5wYXJlbnREYXRhLmhlaWdodCkge1xuXHRcdFx0dGhhdC5zaXplLmhlaWdodCA9IHRoYXQucGFyZW50RGF0YS5oZWlnaHQgLSBob3NldDtcblx0XHRcdGlmIChwUmF0aW8pIHRoYXQuc2l6ZS53aWR0aCA9IHRoYXQuc2l6ZS5oZWlnaHQgKiB0aGF0LmFzcGVjdFJhdGlvO1xuXHRcdH1cblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbihldmVudCwgdWkpe1xuXHRcdHZhciB0aGF0ID0gJCh0aGlzKS5kYXRhKFwicmVzaXphYmxlXCIpLCBvID0gdGhhdC5vcHRpb25zLCBjcCA9IHRoYXQucG9zaXRpb24sXG5cdFx0XHRcdGNvID0gdGhhdC5jb250YWluZXJPZmZzZXQsIGNvcCA9IHRoYXQuY29udGFpbmVyUG9zaXRpb24sIGNlID0gdGhhdC5jb250YWluZXJFbGVtZW50O1xuXG5cdFx0dmFyIGhlbHBlciA9ICQodGhhdC5oZWxwZXIpLCBobyA9IGhlbHBlci5vZmZzZXQoKSwgdyA9IGhlbHBlci5vdXRlcldpZHRoKCkgLSB0aGF0LnNpemVEaWZmLndpZHRoLCBoID0gaGVscGVyLm91dGVySGVpZ2h0KCkgLSB0aGF0LnNpemVEaWZmLmhlaWdodDtcblxuXHRcdGlmICh0aGF0Ll9oZWxwZXIgJiYgIW8uYW5pbWF0ZSAmJiAoL3JlbGF0aXZlLykudGVzdChjZS5jc3MoJ3Bvc2l0aW9uJykpKVxuXHRcdFx0JCh0aGlzKS5jc3MoeyBsZWZ0OiBoby5sZWZ0IC0gY29wLmxlZnQgLSBjby5sZWZ0LCB3aWR0aDogdywgaGVpZ2h0OiBoIH0pO1xuXG5cdFx0aWYgKHRoYXQuX2hlbHBlciAmJiAhby5hbmltYXRlICYmICgvc3RhdGljLykudGVzdChjZS5jc3MoJ3Bvc2l0aW9uJykpKVxuXHRcdFx0JCh0aGlzKS5jc3MoeyBsZWZ0OiBoby5sZWZ0IC0gY29wLmxlZnQgLSBjby5sZWZ0LCB3aWR0aDogdywgaGVpZ2h0OiBoIH0pO1xuXG5cdH1cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJyZXNpemFibGVcIiwgXCJnaG9zdFwiLCB7XG5cblx0c3RhcnQ6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXG5cdFx0dmFyIHRoYXQgPSAkKHRoaXMpLmRhdGEoXCJyZXNpemFibGVcIiksIG8gPSB0aGF0Lm9wdGlvbnMsIGNzID0gdGhhdC5zaXplO1xuXG5cdFx0dGhhdC5naG9zdCA9IHRoYXQub3JpZ2luYWxFbGVtZW50LmNsb25lKCk7XG5cdFx0dGhhdC5naG9zdFxuXHRcdFx0LmNzcyh7IG9wYWNpdHk6IC4yNSwgZGlzcGxheTogJ2Jsb2NrJywgcG9zaXRpb246ICdyZWxhdGl2ZScsIGhlaWdodDogY3MuaGVpZ2h0LCB3aWR0aDogY3Mud2lkdGgsIG1hcmdpbjogMCwgbGVmdDogMCwgdG9wOiAwIH0pXG5cdFx0XHQuYWRkQ2xhc3MoJ3VpLXJlc2l6YWJsZS1naG9zdCcpXG5cdFx0XHQuYWRkQ2xhc3ModHlwZW9mIG8uZ2hvc3QgPT0gJ3N0cmluZycgPyBvLmdob3N0IDogJycpO1xuXG5cdFx0dGhhdC5naG9zdC5hcHBlbmRUbyh0aGF0LmhlbHBlcik7XG5cblx0fSxcblxuXHRyZXNpemU6IGZ1bmN0aW9uKGV2ZW50LCB1aSl7XG5cdFx0dmFyIHRoYXQgPSAkKHRoaXMpLmRhdGEoXCJyZXNpemFibGVcIiksIG8gPSB0aGF0Lm9wdGlvbnM7XG5cdFx0aWYgKHRoYXQuZ2hvc3QpIHRoYXQuZ2hvc3QuY3NzKHsgcG9zaXRpb246ICdyZWxhdGl2ZScsIGhlaWdodDogdGhhdC5zaXplLmhlaWdodCwgd2lkdGg6IHRoYXQuc2l6ZS53aWR0aCB9KTtcblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbihldmVudCwgdWkpe1xuXHRcdHZhciB0aGF0ID0gJCh0aGlzKS5kYXRhKFwicmVzaXphYmxlXCIpLCBvID0gdGhhdC5vcHRpb25zO1xuXHRcdGlmICh0aGF0Lmdob3N0ICYmIHRoYXQuaGVscGVyKSB0aGF0LmhlbHBlci5nZXQoMCkucmVtb3ZlQ2hpbGQodGhhdC5naG9zdC5nZXQoMCkpO1xuXHR9XG5cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJyZXNpemFibGVcIiwgXCJncmlkXCIsIHtcblxuXHRyZXNpemU6IGZ1bmN0aW9uKGV2ZW50LCB1aSkge1xuXHRcdHZhciB0aGF0ID0gJCh0aGlzKS5kYXRhKFwicmVzaXphYmxlXCIpLCBvID0gdGhhdC5vcHRpb25zLCBjcyA9IHRoYXQuc2l6ZSwgb3MgPSB0aGF0Lm9yaWdpbmFsU2l6ZSwgb3AgPSB0aGF0Lm9yaWdpbmFsUG9zaXRpb24sIGEgPSB0aGF0LmF4aXMsIHJhdGlvID0gby5fYXNwZWN0UmF0aW8gfHwgZXZlbnQuc2hpZnRLZXk7XG5cdFx0by5ncmlkID0gdHlwZW9mIG8uZ3JpZCA9PSBcIm51bWJlclwiID8gW28uZ3JpZCwgby5ncmlkXSA6IG8uZ3JpZDtcblx0XHR2YXIgb3ggPSBNYXRoLnJvdW5kKChjcy53aWR0aCAtIG9zLndpZHRoKSAvIChvLmdyaWRbMF18fDEpKSAqIChvLmdyaWRbMF18fDEpLCBveSA9IE1hdGgucm91bmQoKGNzLmhlaWdodCAtIG9zLmhlaWdodCkgLyAoby5ncmlkWzFdfHwxKSkgKiAoby5ncmlkWzFdfHwxKTtcblxuXHRcdGlmICgvXihzZXxzfGUpJC8udGVzdChhKSkge1xuXHRcdFx0dGhhdC5zaXplLndpZHRoID0gb3Mud2lkdGggKyBveDtcblx0XHRcdHRoYXQuc2l6ZS5oZWlnaHQgPSBvcy5oZWlnaHQgKyBveTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoL14obmUpJC8udGVzdChhKSkge1xuXHRcdFx0dGhhdC5zaXplLndpZHRoID0gb3Mud2lkdGggKyBveDtcblx0XHRcdHRoYXQuc2l6ZS5oZWlnaHQgPSBvcy5oZWlnaHQgKyBveTtcblx0XHRcdHRoYXQucG9zaXRpb24udG9wID0gb3AudG9wIC0gb3k7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKC9eKHN3KSQvLnRlc3QoYSkpIHtcblx0XHRcdHRoYXQuc2l6ZS53aWR0aCA9IG9zLndpZHRoICsgb3g7XG5cdFx0XHR0aGF0LnNpemUuaGVpZ2h0ID0gb3MuaGVpZ2h0ICsgb3k7XG5cdFx0XHR0aGF0LnBvc2l0aW9uLmxlZnQgPSBvcC5sZWZ0IC0gb3g7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhhdC5zaXplLndpZHRoID0gb3Mud2lkdGggKyBveDtcblx0XHRcdHRoYXQuc2l6ZS5oZWlnaHQgPSBvcy5oZWlnaHQgKyBveTtcblx0XHRcdHRoYXQucG9zaXRpb24udG9wID0gb3AudG9wIC0gb3k7XG5cdFx0XHR0aGF0LnBvc2l0aW9uLmxlZnQgPSBvcC5sZWZ0IC0gb3g7XG5cdFx0fVxuXHR9XG5cbn0pO1xuXG52YXIgbnVtID0gZnVuY3Rpb24odikge1xuXHRyZXR1cm4gcGFyc2VJbnQodiwgMTApIHx8IDA7XG59O1xuXG52YXIgaXNOdW1iZXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRyZXR1cm4gIWlzTmFOKHBhcnNlSW50KHZhbHVlLCAxMCkpO1xufTtcblxufSkoalF1ZXJ5KTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4kLndpZGdldChcInVpLnNlbGVjdGFibGVcIiwgJC51aS5tb3VzZSwge1xuXHR2ZXJzaW9uOiBcIjEuOS4yXCIsXG5cdG9wdGlvbnM6IHtcblx0XHRhcHBlbmRUbzogJ2JvZHknLFxuXHRcdGF1dG9SZWZyZXNoOiB0cnVlLFxuXHRcdGRpc3RhbmNlOiAwLFxuXHRcdGZpbHRlcjogJyonLFxuXHRcdHRvbGVyYW5jZTogJ3RvdWNoJ1xuXHR9LFxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXCJ1aS1zZWxlY3RhYmxlXCIpO1xuXG5cdFx0dGhpcy5kcmFnZ2VkID0gZmFsc2U7XG5cblx0XHQvLyBjYWNoZSBzZWxlY3RlZSBjaGlsZHJlbiBiYXNlZCBvbiBmaWx0ZXJcblx0XHR2YXIgc2VsZWN0ZWVzO1xuXHRcdHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2VsZWN0ZWVzID0gJCh0aGF0Lm9wdGlvbnMuZmlsdGVyLCB0aGF0LmVsZW1lbnRbMF0pO1xuXHRcdFx0c2VsZWN0ZWVzLmFkZENsYXNzKFwidWktc2VsZWN0ZWVcIik7XG5cdFx0XHRzZWxlY3RlZXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyICR0aGlzID0gJCh0aGlzKTtcblx0XHRcdFx0dmFyIHBvcyA9ICR0aGlzLm9mZnNldCgpO1xuXHRcdFx0XHQkLmRhdGEodGhpcywgXCJzZWxlY3RhYmxlLWl0ZW1cIiwge1xuXHRcdFx0XHRcdGVsZW1lbnQ6IHRoaXMsXG5cdFx0XHRcdFx0JGVsZW1lbnQ6ICR0aGlzLFxuXHRcdFx0XHRcdGxlZnQ6IHBvcy5sZWZ0LFxuXHRcdFx0XHRcdHRvcDogcG9zLnRvcCxcblx0XHRcdFx0XHRyaWdodDogcG9zLmxlZnQgKyAkdGhpcy5vdXRlcldpZHRoKCksXG5cdFx0XHRcdFx0Ym90dG9tOiBwb3MudG9wICsgJHRoaXMub3V0ZXJIZWlnaHQoKSxcblx0XHRcdFx0XHRzdGFydHNlbGVjdGVkOiBmYWxzZSxcblx0XHRcdFx0XHRzZWxlY3RlZDogJHRoaXMuaGFzQ2xhc3MoJ3VpLXNlbGVjdGVkJyksXG5cdFx0XHRcdFx0c2VsZWN0aW5nOiAkdGhpcy5oYXNDbGFzcygndWktc2VsZWN0aW5nJyksXG5cdFx0XHRcdFx0dW5zZWxlY3Rpbmc6ICR0aGlzLmhhc0NsYXNzKCd1aS11bnNlbGVjdGluZycpXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0XHR0aGlzLnJlZnJlc2goKTtcblxuXHRcdHRoaXMuc2VsZWN0ZWVzID0gc2VsZWN0ZWVzLmFkZENsYXNzKFwidWktc2VsZWN0ZWVcIik7XG5cblx0XHR0aGlzLl9tb3VzZUluaXQoKTtcblxuXHRcdHRoaXMuaGVscGVyID0gJChcIjxkaXYgY2xhc3M9J3VpLXNlbGVjdGFibGUtaGVscGVyJz48L2Rpdj5cIik7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc2VsZWN0ZWVzXG5cdFx0XHQucmVtb3ZlQ2xhc3MoXCJ1aS1zZWxlY3RlZVwiKVxuXHRcdFx0LnJlbW92ZURhdGEoXCJzZWxlY3RhYmxlLWl0ZW1cIik7XG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQucmVtb3ZlQ2xhc3MoXCJ1aS1zZWxlY3RhYmxlIHVpLXNlbGVjdGFibGUtZGlzYWJsZWRcIik7XG5cdFx0dGhpcy5fbW91c2VEZXN0cm95KCk7XG5cdH0sXG5cblx0X21vdXNlU3RhcnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5vcG9zID0gW2V2ZW50LnBhZ2VYLCBldmVudC5wYWdlWV07XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLmRpc2FibGVkKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR0aGlzLnNlbGVjdGVlcyA9ICQob3B0aW9ucy5maWx0ZXIsIHRoaXMuZWxlbWVudFswXSk7XG5cblx0XHR0aGlzLl90cmlnZ2VyKFwic3RhcnRcIiwgZXZlbnQpO1xuXG5cdFx0JChvcHRpb25zLmFwcGVuZFRvKS5hcHBlbmQodGhpcy5oZWxwZXIpO1xuXHRcdC8vIHBvc2l0aW9uIGhlbHBlciAobGFzc28pXG5cdFx0dGhpcy5oZWxwZXIuY3NzKHtcblx0XHRcdFwibGVmdFwiOiBldmVudC5jbGllbnRYLFxuXHRcdFx0XCJ0b3BcIjogZXZlbnQuY2xpZW50WSxcblx0XHRcdFwid2lkdGhcIjogMCxcblx0XHRcdFwiaGVpZ2h0XCI6IDBcblx0XHR9KTtcblxuXHRcdGlmIChvcHRpb25zLmF1dG9SZWZyZXNoKSB7XG5cdFx0XHR0aGlzLnJlZnJlc2goKTtcblx0XHR9XG5cblx0XHR0aGlzLnNlbGVjdGVlcy5maWx0ZXIoJy51aS1zZWxlY3RlZCcpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZWN0ZWUgPSAkLmRhdGEodGhpcywgXCJzZWxlY3RhYmxlLWl0ZW1cIik7XG5cdFx0XHRzZWxlY3RlZS5zdGFydHNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdGlmICghZXZlbnQubWV0YUtleSAmJiAhZXZlbnQuY3RybEtleSkge1xuXHRcdFx0XHRzZWxlY3RlZS4kZWxlbWVudC5yZW1vdmVDbGFzcygndWktc2VsZWN0ZWQnKTtcblx0XHRcdFx0c2VsZWN0ZWUuc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0c2VsZWN0ZWUuJGVsZW1lbnQuYWRkQ2xhc3MoJ3VpLXVuc2VsZWN0aW5nJyk7XG5cdFx0XHRcdHNlbGVjdGVlLnVuc2VsZWN0aW5nID0gdHJ1ZTtcblx0XHRcdFx0Ly8gc2VsZWN0YWJsZSBVTlNFTEVDVElORyBjYWxsYmFja1xuXHRcdFx0XHR0aGF0Ll90cmlnZ2VyKFwidW5zZWxlY3RpbmdcIiwgZXZlbnQsIHtcblx0XHRcdFx0XHR1bnNlbGVjdGluZzogc2VsZWN0ZWUuZWxlbWVudFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdCQoZXZlbnQudGFyZ2V0KS5wYXJlbnRzKCkuYW5kU2VsZigpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZWN0ZWUgPSAkLmRhdGEodGhpcywgXCJzZWxlY3RhYmxlLWl0ZW1cIik7XG5cdFx0XHRpZiAoc2VsZWN0ZWUpIHtcblx0XHRcdFx0dmFyIGRvU2VsZWN0ID0gKCFldmVudC5tZXRhS2V5ICYmICFldmVudC5jdHJsS2V5KSB8fCAhc2VsZWN0ZWUuJGVsZW1lbnQuaGFzQ2xhc3MoJ3VpLXNlbGVjdGVkJyk7XG5cdFx0XHRcdHNlbGVjdGVlLiRlbGVtZW50XG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKGRvU2VsZWN0ID8gXCJ1aS11bnNlbGVjdGluZ1wiIDogXCJ1aS1zZWxlY3RlZFwiKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyhkb1NlbGVjdCA/IFwidWktc2VsZWN0aW5nXCIgOiBcInVpLXVuc2VsZWN0aW5nXCIpO1xuXHRcdFx0XHRzZWxlY3RlZS51bnNlbGVjdGluZyA9ICFkb1NlbGVjdDtcblx0XHRcdFx0c2VsZWN0ZWUuc2VsZWN0aW5nID0gZG9TZWxlY3Q7XG5cdFx0XHRcdHNlbGVjdGVlLnNlbGVjdGVkID0gZG9TZWxlY3Q7XG5cdFx0XHRcdC8vIHNlbGVjdGFibGUgKFVOKVNFTEVDVElORyBjYWxsYmFja1xuXHRcdFx0XHRpZiAoZG9TZWxlY3QpIHtcblx0XHRcdFx0XHR0aGF0Ll90cmlnZ2VyKFwic2VsZWN0aW5nXCIsIGV2ZW50LCB7XG5cdFx0XHRcdFx0XHRzZWxlY3Rpbmc6IHNlbGVjdGVlLmVsZW1lbnRcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGF0Ll90cmlnZ2VyKFwidW5zZWxlY3RpbmdcIiwgZXZlbnQsIHtcblx0XHRcdFx0XHRcdHVuc2VsZWN0aW5nOiBzZWxlY3RlZS5lbGVtZW50XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH0sXG5cblx0X21vdXNlRHJhZzogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dGhpcy5kcmFnZ2VkID0gdHJ1ZTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZWQpXG5cdFx0XHRyZXR1cm47XG5cblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdHZhciB4MSA9IHRoaXMub3Bvc1swXSwgeTEgPSB0aGlzLm9wb3NbMV0sIHgyID0gZXZlbnQucGFnZVgsIHkyID0gZXZlbnQucGFnZVk7XG5cdFx0aWYgKHgxID4geDIpIHsgdmFyIHRtcCA9IHgyOyB4MiA9IHgxOyB4MSA9IHRtcDsgfVxuXHRcdGlmICh5MSA+IHkyKSB7IHZhciB0bXAgPSB5MjsgeTIgPSB5MTsgeTEgPSB0bXA7IH1cblx0XHR0aGlzLmhlbHBlci5jc3Moe2xlZnQ6IHgxLCB0b3A6IHkxLCB3aWR0aDogeDIteDEsIGhlaWdodDogeTIteTF9KTtcblxuXHRcdHRoaXMuc2VsZWN0ZWVzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZWN0ZWUgPSAkLmRhdGEodGhpcywgXCJzZWxlY3RhYmxlLWl0ZW1cIik7XG5cdFx0XHQvL3ByZXZlbnQgaGVscGVyIGZyb20gYmVpbmcgc2VsZWN0ZWQgaWYgYXBwZW5kVG86IHNlbGVjdGFibGVcblx0XHRcdGlmICghc2VsZWN0ZWUgfHwgc2VsZWN0ZWUuZWxlbWVudCA9PSB0aGF0LmVsZW1lbnRbMF0pXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciBoaXQgPSBmYWxzZTtcblx0XHRcdGlmIChvcHRpb25zLnRvbGVyYW5jZSA9PSAndG91Y2gnKSB7XG5cdFx0XHRcdGhpdCA9ICggIShzZWxlY3RlZS5sZWZ0ID4geDIgfHwgc2VsZWN0ZWUucmlnaHQgPCB4MSB8fCBzZWxlY3RlZS50b3AgPiB5MiB8fCBzZWxlY3RlZS5ib3R0b20gPCB5MSkgKTtcblx0XHRcdH0gZWxzZSBpZiAob3B0aW9ucy50b2xlcmFuY2UgPT0gJ2ZpdCcpIHtcblx0XHRcdFx0aGl0ID0gKHNlbGVjdGVlLmxlZnQgPiB4MSAmJiBzZWxlY3RlZS5yaWdodCA8IHgyICYmIHNlbGVjdGVlLnRvcCA+IHkxICYmIHNlbGVjdGVlLmJvdHRvbSA8IHkyKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGhpdCkge1xuXHRcdFx0XHQvLyBTRUxFQ1Rcblx0XHRcdFx0aWYgKHNlbGVjdGVlLnNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0c2VsZWN0ZWUuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ3VpLXNlbGVjdGVkJyk7XG5cdFx0XHRcdFx0c2VsZWN0ZWUuc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc2VsZWN0ZWUudW5zZWxlY3RpbmcpIHtcblx0XHRcdFx0XHRzZWxlY3RlZS4kZWxlbWVudC5yZW1vdmVDbGFzcygndWktdW5zZWxlY3RpbmcnKTtcblx0XHRcdFx0XHRzZWxlY3RlZS51bnNlbGVjdGluZyA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc2VsZWN0ZWUuc2VsZWN0aW5nKSB7XG5cdFx0XHRcdFx0c2VsZWN0ZWUuJGVsZW1lbnQuYWRkQ2xhc3MoJ3VpLXNlbGVjdGluZycpO1xuXHRcdFx0XHRcdHNlbGVjdGVlLnNlbGVjdGluZyA9IHRydWU7XG5cdFx0XHRcdFx0Ly8gc2VsZWN0YWJsZSBTRUxFQ1RJTkcgY2FsbGJhY2tcblx0XHRcdFx0XHR0aGF0Ll90cmlnZ2VyKFwic2VsZWN0aW5nXCIsIGV2ZW50LCB7XG5cdFx0XHRcdFx0XHRzZWxlY3Rpbmc6IHNlbGVjdGVlLmVsZW1lbnRcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gVU5TRUxFQ1Rcblx0XHRcdFx0aWYgKHNlbGVjdGVlLnNlbGVjdGluZykge1xuXHRcdFx0XHRcdGlmICgoZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KSAmJiBzZWxlY3RlZS5zdGFydHNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZS4kZWxlbWVudC5yZW1vdmVDbGFzcygndWktc2VsZWN0aW5nJyk7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZS5zZWxlY3RpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHNlbGVjdGVlLiRlbGVtZW50LmFkZENsYXNzKCd1aS1zZWxlY3RlZCcpO1xuXHRcdFx0XHRcdFx0c2VsZWN0ZWUuc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZS4kZWxlbWVudC5yZW1vdmVDbGFzcygndWktc2VsZWN0aW5nJyk7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZS5zZWxlY3RpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGlmIChzZWxlY3RlZS5zdGFydHNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGVjdGVlLiRlbGVtZW50LmFkZENsYXNzKCd1aS11bnNlbGVjdGluZycpO1xuXHRcdFx0XHRcdFx0XHRzZWxlY3RlZS51bnNlbGVjdGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBzZWxlY3RhYmxlIFVOU0VMRUNUSU5HIGNhbGxiYWNrXG5cdFx0XHRcdFx0XHR0aGF0Ll90cmlnZ2VyKFwidW5zZWxlY3RpbmdcIiwgZXZlbnQsIHtcblx0XHRcdFx0XHRcdFx0dW5zZWxlY3Rpbmc6IHNlbGVjdGVlLmVsZW1lbnRcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc2VsZWN0ZWUuc2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRpZiAoIWV2ZW50Lm1ldGFLZXkgJiYgIWV2ZW50LmN0cmxLZXkgJiYgIXNlbGVjdGVlLnN0YXJ0c2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRcdHNlbGVjdGVlLiRlbGVtZW50LnJlbW92ZUNsYXNzKCd1aS1zZWxlY3RlZCcpO1xuXHRcdFx0XHRcdFx0c2VsZWN0ZWUuc2VsZWN0ZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0c2VsZWN0ZWUuJGVsZW1lbnQuYWRkQ2xhc3MoJ3VpLXVuc2VsZWN0aW5nJyk7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZS51bnNlbGVjdGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHQvLyBzZWxlY3RhYmxlIFVOU0VMRUNUSU5HIGNhbGxiYWNrXG5cdFx0XHRcdFx0XHR0aGF0Ll90cmlnZ2VyKFwidW5zZWxlY3RpbmdcIiwgZXZlbnQsIHtcblx0XHRcdFx0XHRcdFx0dW5zZWxlY3Rpbmc6IHNlbGVjdGVlLmVsZW1lbnRcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9tb3VzZVN0b3A6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5kcmFnZ2VkID0gZmFsc2U7XG5cblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdCQoJy51aS11bnNlbGVjdGluZycsIHRoaXMuZWxlbWVudFswXSkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxlY3RlZSA9ICQuZGF0YSh0aGlzLCBcInNlbGVjdGFibGUtaXRlbVwiKTtcblx0XHRcdHNlbGVjdGVlLiRlbGVtZW50LnJlbW92ZUNsYXNzKCd1aS11bnNlbGVjdGluZycpO1xuXHRcdFx0c2VsZWN0ZWUudW5zZWxlY3RpbmcgPSBmYWxzZTtcblx0XHRcdHNlbGVjdGVlLnN0YXJ0c2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdHRoYXQuX3RyaWdnZXIoXCJ1bnNlbGVjdGVkXCIsIGV2ZW50LCB7XG5cdFx0XHRcdHVuc2VsZWN0ZWQ6IHNlbGVjdGVlLmVsZW1lbnRcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdCQoJy51aS1zZWxlY3RpbmcnLCB0aGlzLmVsZW1lbnRbMF0pLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZWN0ZWUgPSAkLmRhdGEodGhpcywgXCJzZWxlY3RhYmxlLWl0ZW1cIik7XG5cdFx0XHRzZWxlY3RlZS4kZWxlbWVudC5yZW1vdmVDbGFzcygndWktc2VsZWN0aW5nJykuYWRkQ2xhc3MoJ3VpLXNlbGVjdGVkJyk7XG5cdFx0XHRzZWxlY3RlZS5zZWxlY3RpbmcgPSBmYWxzZTtcblx0XHRcdHNlbGVjdGVlLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdHNlbGVjdGVlLnN0YXJ0c2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0dGhhdC5fdHJpZ2dlcihcInNlbGVjdGVkXCIsIGV2ZW50LCB7XG5cdFx0XHRcdHNlbGVjdGVkOiBzZWxlY3RlZS5lbGVtZW50XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHR0aGlzLl90cmlnZ2VyKFwic3RvcFwiLCBldmVudCk7XG5cblx0XHR0aGlzLmhlbHBlci5yZW1vdmUoKTtcblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG59KTtcblxufSkoalF1ZXJ5KTtcbihmdW5jdGlvbiggJCwgdW5kZWZpbmVkICkge1xuXG4vLyBudW1iZXIgb2YgcGFnZXMgaW4gYSBzbGlkZXJcbi8vIChob3cgbWFueSB0aW1lcyBjYW4geW91IHBhZ2UgdXAvZG93biB0byBnbyB0aHJvdWdoIHRoZSB3aG9sZSByYW5nZSlcbnZhciBudW1QYWdlcyA9IDU7XG5cbiQud2lkZ2V0KCBcInVpLnNsaWRlclwiLCAkLnVpLm1vdXNlLCB7XG5cdHZlcnNpb246IFwiMS45LjJcIixcblx0d2lkZ2V0RXZlbnRQcmVmaXg6IFwic2xpZGVcIixcblxuXHRvcHRpb25zOiB7XG5cdFx0YW5pbWF0ZTogZmFsc2UsXG5cdFx0ZGlzdGFuY2U6IDAsXG5cdFx0bWF4OiAxMDAsXG5cdFx0bWluOiAwLFxuXHRcdG9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcblx0XHRyYW5nZTogZmFsc2UsXG5cdFx0c3RlcDogMSxcblx0XHR2YWx1ZTogMCxcblx0XHR2YWx1ZXM6IG51bGxcblx0fSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaSwgaGFuZGxlQ291bnQsXG5cdFx0XHRvID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0ZXhpc3RpbmdIYW5kbGVzID0gdGhpcy5lbGVtZW50LmZpbmQoIFwiLnVpLXNsaWRlci1oYW5kbGVcIiApLmFkZENsYXNzKCBcInVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbFwiICksXG5cdFx0XHRoYW5kbGUgPSBcIjxhIGNsYXNzPSd1aS1zbGlkZXItaGFuZGxlIHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbCcgaHJlZj0nIyc+PC9hPlwiLFxuXHRcdFx0aGFuZGxlcyA9IFtdO1xuXG5cdFx0dGhpcy5fa2V5U2xpZGluZyA9IGZhbHNlO1xuXHRcdHRoaXMuX21vdXNlU2xpZGluZyA9IGZhbHNlO1xuXHRcdHRoaXMuX2FuaW1hdGVPZmYgPSB0cnVlO1xuXHRcdHRoaXMuX2hhbmRsZUluZGV4ID0gbnVsbDtcblx0XHR0aGlzLl9kZXRlY3RPcmllbnRhdGlvbigpO1xuXHRcdHRoaXMuX21vdXNlSW5pdCgpO1xuXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktc2xpZGVyXCIgK1xuXHRcdFx0XHRcIiB1aS1zbGlkZXItXCIgKyB0aGlzLm9yaWVudGF0aW9uICtcblx0XHRcdFx0XCIgdWktd2lkZ2V0XCIgK1xuXHRcdFx0XHRcIiB1aS13aWRnZXQtY29udGVudFwiICtcblx0XHRcdFx0XCIgdWktY29ybmVyLWFsbFwiICtcblx0XHRcdFx0KCBvLmRpc2FibGVkID8gXCIgdWktc2xpZGVyLWRpc2FibGVkIHVpLWRpc2FibGVkXCIgOiBcIlwiICkgKTtcblxuXHRcdHRoaXMucmFuZ2UgPSAkKFtdKTtcblxuXHRcdGlmICggby5yYW5nZSApIHtcblx0XHRcdGlmICggby5yYW5nZSA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0aWYgKCAhby52YWx1ZXMgKSB7XG5cdFx0XHRcdFx0by52YWx1ZXMgPSBbIHRoaXMuX3ZhbHVlTWluKCksIHRoaXMuX3ZhbHVlTWluKCkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG8udmFsdWVzLmxlbmd0aCAmJiBvLnZhbHVlcy5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdFx0by52YWx1ZXMgPSBbIG8udmFsdWVzWzBdLCBvLnZhbHVlc1swXSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMucmFuZ2UgPSAkKCBcIjxkaXY+PC9kaXY+XCIgKVxuXHRcdFx0XHQuYXBwZW5kVG8oIHRoaXMuZWxlbWVudCApXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS1zbGlkZXItcmFuZ2VcIiArXG5cdFx0XHRcdC8vIG5vdGU6IHRoaXMgaXNuJ3QgdGhlIG1vc3QgZml0dGluZ2x5IHNlbWFudGljIGZyYW1ld29yayBjbGFzcyBmb3IgdGhpcyBlbGVtZW50LFxuXHRcdFx0XHQvLyBidXQgd29ya2VkIGJlc3QgdmlzdWFsbHkgd2l0aCBhIHZhcmlldHkgb2YgdGhlbWVzXG5cdFx0XHRcdFwiIHVpLXdpZGdldC1oZWFkZXJcIiArXG5cdFx0XHRcdCggKCBvLnJhbmdlID09PSBcIm1pblwiIHx8IG8ucmFuZ2UgPT09IFwibWF4XCIgKSA/IFwiIHVpLXNsaWRlci1yYW5nZS1cIiArIG8ucmFuZ2UgOiBcIlwiICkgKTtcblx0XHR9XG5cblx0XHRoYW5kbGVDb3VudCA9ICggby52YWx1ZXMgJiYgby52YWx1ZXMubGVuZ3RoICkgfHwgMTtcblxuXHRcdGZvciAoIGkgPSBleGlzdGluZ0hhbmRsZXMubGVuZ3RoOyBpIDwgaGFuZGxlQ291bnQ7IGkrKyApIHtcblx0XHRcdGhhbmRsZXMucHVzaCggaGFuZGxlICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5oYW5kbGVzID0gZXhpc3RpbmdIYW5kbGVzLmFkZCggJCggaGFuZGxlcy5qb2luKCBcIlwiICkgKS5hcHBlbmRUbyggdGhpcy5lbGVtZW50ICkgKTtcblxuXHRcdHRoaXMuaGFuZGxlID0gdGhpcy5oYW5kbGVzLmVxKCAwICk7XG5cblx0XHR0aGlzLmhhbmRsZXMuYWRkKCB0aGlzLnJhbmdlICkuZmlsdGVyKCBcImFcIiApXG5cdFx0XHQuY2xpY2soZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fSlcblx0XHRcdC5tb3VzZWVudGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFvLmRpc2FibGVkICkge1xuXHRcdFx0XHRcdCQoIHRoaXMgKS5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQubW91c2VsZWF2ZShmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcyApLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdH0pXG5cdFx0XHQuZm9jdXMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIW8uZGlzYWJsZWQgKSB7XG5cdFx0XHRcdFx0JCggXCIudWktc2xpZGVyIC51aS1zdGF0ZS1mb2N1c1wiICkucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0XHRcdCQoIHRoaXMgKS5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JCggdGhpcyApLmJsdXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC5ibHVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkKCB0aGlzICkucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fSk7XG5cblx0XHR0aGlzLmhhbmRsZXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdCQoIHRoaXMgKS5kYXRhKCBcInVpLXNsaWRlci1oYW5kbGUtaW5kZXhcIiwgaSApO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fb24oIHRoaXMuaGFuZGxlcywge1xuXHRcdFx0a2V5ZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgYWxsb3dlZCwgY3VyVmFsLCBuZXdWYWwsIHN0ZXAsXG5cdFx0XHRcdFx0aW5kZXggPSAkKCBldmVudC50YXJnZXQgKS5kYXRhKCBcInVpLXNsaWRlci1oYW5kbGUtaW5kZXhcIiApO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cdFx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuSE9NRTpcblx0XHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5FTkQ6XG5cdFx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9VUDpcblx0XHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5QQUdFX0RPV046XG5cdFx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuVVA6XG5cdFx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUklHSFQ6XG5cdFx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuRE9XTjpcblx0XHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5MRUZUOlxuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdGlmICggIXRoaXMuX2tleVNsaWRpbmcgKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2tleVNsaWRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHQkKCBldmVudC50YXJnZXQgKS5hZGRDbGFzcyggXCJ1aS1zdGF0ZS1hY3RpdmVcIiApO1xuXHRcdFx0XHRcdFx0XHRhbGxvd2VkID0gdGhpcy5fc3RhcnQoIGV2ZW50LCBpbmRleCApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGFsbG93ZWQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdGVwID0gdGhpcy5vcHRpb25zLnN0ZXA7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnZhbHVlcyAmJiB0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRjdXJWYWwgPSBuZXdWYWwgPSB0aGlzLnZhbHVlcyggaW5kZXggKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdXJWYWwgPSBuZXdWYWwgPSB0aGlzLnZhbHVlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXHRcdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkhPTUU6XG5cdFx0XHRcdFx0XHRuZXdWYWwgPSB0aGlzLl92YWx1ZU1pbigpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuRU5EOlxuXHRcdFx0XHRcdFx0bmV3VmFsID0gdGhpcy5fdmFsdWVNYXgoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLlBBR0VfVVA6XG5cdFx0XHRcdFx0XHRuZXdWYWwgPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggY3VyVmFsICsgKCAodGhpcy5fdmFsdWVNYXgoKSAtIHRoaXMuX3ZhbHVlTWluKCkpIC8gbnVtUGFnZXMgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9ET1dOOlxuXHRcdFx0XHRcdFx0bmV3VmFsID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIGN1clZhbCAtICggKHRoaXMuX3ZhbHVlTWF4KCkgLSB0aGlzLl92YWx1ZU1pbigpKSAvIG51bVBhZ2VzICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLlVQOlxuXHRcdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLlJJR0hUOlxuXHRcdFx0XHRcdFx0aWYgKCBjdXJWYWwgPT09IHRoaXMuX3ZhbHVlTWF4KCkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG5ld1ZhbCA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKCBjdXJWYWwgKyBzdGVwICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICQudWkua2V5Q29kZS5ET1dOOlxuXHRcdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkxFRlQ6XG5cdFx0XHRcdFx0XHRpZiAoIGN1clZhbCA9PT0gdGhpcy5fdmFsdWVNaW4oKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bmV3VmFsID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIGN1clZhbCAtIHN0ZXAgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fc2xpZGUoIGV2ZW50LCBpbmRleCwgbmV3VmFsICk7XG5cdFx0XHR9LFxuXHRcdFx0a2V5dXA6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gJCggZXZlbnQudGFyZ2V0ICkuZGF0YSggXCJ1aS1zbGlkZXItaGFuZGxlLWluZGV4XCIgKTtcblxuXHRcdFx0XHRpZiAoIHRoaXMuX2tleVNsaWRpbmcgKSB7XG5cdFx0XHRcdFx0dGhpcy5fa2V5U2xpZGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdHRoaXMuX3N0b3AoIGV2ZW50LCBpbmRleCApO1xuXHRcdFx0XHRcdHRoaXMuX2NoYW5nZSggZXZlbnQsIGluZGV4ICk7XG5cdFx0XHRcdFx0JCggZXZlbnQudGFyZ2V0ICkucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cblx0XHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGFuZGxlcy5yZW1vdmUoKTtcblx0XHR0aGlzLnJhbmdlLnJlbW92ZSgpO1xuXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktc2xpZGVyXCIgK1xuXHRcdFx0XHRcIiB1aS1zbGlkZXItaG9yaXpvbnRhbFwiICtcblx0XHRcdFx0XCIgdWktc2xpZGVyLXZlcnRpY2FsXCIgK1xuXHRcdFx0XHRcIiB1aS1zbGlkZXItZGlzYWJsZWRcIiArXG5cdFx0XHRcdFwiIHVpLXdpZGdldFwiICtcblx0XHRcdFx0XCIgdWktd2lkZ2V0LWNvbnRlbnRcIiArXG5cdFx0XHRcdFwiIHVpLWNvcm5lci1hbGxcIiApO1xuXG5cdFx0dGhpcy5fbW91c2VEZXN0cm95KCk7XG5cdH0sXG5cblx0X21vdXNlQ2FwdHVyZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBwb3NpdGlvbiwgbm9ybVZhbHVlLCBkaXN0YW5jZSwgY2xvc2VzdEhhbmRsZSwgaW5kZXgsIGFsbG93ZWQsIG9mZnNldCwgbW91c2VPdmVySGFuZGxlLFxuXHRcdFx0dGhhdCA9IHRoaXMsXG5cdFx0XHRvID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKCBvLmRpc2FibGVkICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMuZWxlbWVudFNpemUgPSB7XG5cdFx0XHR3aWR0aDogdGhpcy5lbGVtZW50Lm91dGVyV2lkdGgoKSxcblx0XHRcdGhlaWdodDogdGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KClcblx0XHR9O1xuXHRcdHRoaXMuZWxlbWVudE9mZnNldCA9IHRoaXMuZWxlbWVudC5vZmZzZXQoKTtcblxuXHRcdHBvc2l0aW9uID0geyB4OiBldmVudC5wYWdlWCwgeTogZXZlbnQucGFnZVkgfTtcblx0XHRub3JtVmFsdWUgPSB0aGlzLl9ub3JtVmFsdWVGcm9tTW91c2UoIHBvc2l0aW9uICk7XG5cdFx0ZGlzdGFuY2UgPSB0aGlzLl92YWx1ZU1heCgpIC0gdGhpcy5fdmFsdWVNaW4oKSArIDE7XG5cdFx0dGhpcy5oYW5kbGVzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdGhpc0Rpc3RhbmNlID0gTWF0aC5hYnMoIG5vcm1WYWx1ZSAtIHRoYXQudmFsdWVzKGkpICk7XG5cdFx0XHRpZiAoIGRpc3RhbmNlID4gdGhpc0Rpc3RhbmNlICkge1xuXHRcdFx0XHRkaXN0YW5jZSA9IHRoaXNEaXN0YW5jZTtcblx0XHRcdFx0Y2xvc2VzdEhhbmRsZSA9ICQoIHRoaXMgKTtcblx0XHRcdFx0aW5kZXggPSBpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gd29ya2Fyb3VuZCBmb3IgYnVnICMzNzM2IChpZiBib3RoIGhhbmRsZXMgb2YgYSByYW5nZSBhcmUgYXQgMCxcblx0XHQvLyB0aGUgZmlyc3QgaXMgYWx3YXlzIHVzZWQgYXMgdGhlIG9uZSB3aXRoIGxlYXN0IGRpc3RhbmNlLFxuXHRcdC8vIGFuZCBtb3ZpbmcgaXQgaXMgb2J2aW91c2x5IHByZXZlbnRlZCBieSBwcmV2ZW50aW5nIG5lZ2F0aXZlIHJhbmdlcylcblx0XHRpZiggby5yYW5nZSA9PT0gdHJ1ZSAmJiB0aGlzLnZhbHVlcygxKSA9PT0gby5taW4gKSB7XG5cdFx0XHRpbmRleCArPSAxO1xuXHRcdFx0Y2xvc2VzdEhhbmRsZSA9ICQoIHRoaXMuaGFuZGxlc1tpbmRleF0gKTtcblx0XHR9XG5cblx0XHRhbGxvd2VkID0gdGhpcy5fc3RhcnQoIGV2ZW50LCBpbmRleCApO1xuXHRcdGlmICggYWxsb3dlZCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHRoaXMuX21vdXNlU2xpZGluZyA9IHRydWU7XG5cblx0XHR0aGlzLl9oYW5kbGVJbmRleCA9IGluZGV4O1xuXG5cdFx0Y2xvc2VzdEhhbmRsZVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiIClcblx0XHRcdC5mb2N1cygpO1xuXG5cdFx0b2Zmc2V0ID0gY2xvc2VzdEhhbmRsZS5vZmZzZXQoKTtcblx0XHRtb3VzZU92ZXJIYW5kbGUgPSAhJCggZXZlbnQudGFyZ2V0ICkucGFyZW50cygpLmFuZFNlbGYoKS5pcyggXCIudWktc2xpZGVyLWhhbmRsZVwiICk7XG5cdFx0dGhpcy5fY2xpY2tPZmZzZXQgPSBtb3VzZU92ZXJIYW5kbGUgPyB7IGxlZnQ6IDAsIHRvcDogMCB9IDoge1xuXHRcdFx0bGVmdDogZXZlbnQucGFnZVggLSBvZmZzZXQubGVmdCAtICggY2xvc2VzdEhhbmRsZS53aWR0aCgpIC8gMiApLFxuXHRcdFx0dG9wOiBldmVudC5wYWdlWSAtIG9mZnNldC50b3AgLVxuXHRcdFx0XHQoIGNsb3Nlc3RIYW5kbGUuaGVpZ2h0KCkgLyAyICkgLVxuXHRcdFx0XHQoIHBhcnNlSW50KCBjbG9zZXN0SGFuZGxlLmNzcyhcImJvcmRlclRvcFdpZHRoXCIpLCAxMCApIHx8IDAgKSAtXG5cdFx0XHRcdCggcGFyc2VJbnQoIGNsb3Nlc3RIYW5kbGUuY3NzKFwiYm9yZGVyQm90dG9tV2lkdGhcIiksIDEwICkgfHwgMCkgK1xuXHRcdFx0XHQoIHBhcnNlSW50KCBjbG9zZXN0SGFuZGxlLmNzcyhcIm1hcmdpblRvcFwiKSwgMTAgKSB8fCAwKVxuXHRcdH07XG5cblx0XHRpZiAoICF0aGlzLmhhbmRsZXMuaGFzQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApICkge1xuXHRcdFx0dGhpcy5fc2xpZGUoIGV2ZW50LCBpbmRleCwgbm9ybVZhbHVlICk7XG5cdFx0fVxuXHRcdHRoaXMuX2FuaW1hdGVPZmYgPSB0cnVlO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9tb3VzZVN0YXJ0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfbW91c2VEcmFnOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIHBvc2l0aW9uID0geyB4OiBldmVudC5wYWdlWCwgeTogZXZlbnQucGFnZVkgfSxcblx0XHRcdG5vcm1WYWx1ZSA9IHRoaXMuX25vcm1WYWx1ZUZyb21Nb3VzZSggcG9zaXRpb24gKTtcblxuXHRcdHRoaXMuX3NsaWRlKCBldmVudCwgdGhpcy5faGFuZGxlSW5kZXgsIG5vcm1WYWx1ZSApO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9tb3VzZVN0b3A6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR0aGlzLmhhbmRsZXMucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHR0aGlzLl9tb3VzZVNsaWRpbmcgPSBmYWxzZTtcblxuXHRcdHRoaXMuX3N0b3AoIGV2ZW50LCB0aGlzLl9oYW5kbGVJbmRleCApO1xuXHRcdHRoaXMuX2NoYW5nZSggZXZlbnQsIHRoaXMuX2hhbmRsZUluZGV4ICk7XG5cblx0XHR0aGlzLl9oYW5kbGVJbmRleCA9IG51bGw7XG5cdFx0dGhpcy5fY2xpY2tPZmZzZXQgPSBudWxsO1xuXHRcdHRoaXMuX2FuaW1hdGVPZmYgPSBmYWxzZTtcblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfZGV0ZWN0T3JpZW50YXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMub3JpZW50YXRpb24gPSAoIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiICkgPyBcInZlcnRpY2FsXCIgOiBcImhvcml6b250YWxcIjtcblx0fSxcblxuXHRfbm9ybVZhbHVlRnJvbU1vdXNlOiBmdW5jdGlvbiggcG9zaXRpb24gKSB7XG5cdFx0dmFyIHBpeGVsVG90YWwsXG5cdFx0XHRwaXhlbE1vdXNlLFxuXHRcdFx0cGVyY2VudE1vdXNlLFxuXHRcdFx0dmFsdWVUb3RhbCxcblx0XHRcdHZhbHVlTW91c2U7XG5cblx0XHRpZiAoIHRoaXMub3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiICkge1xuXHRcdFx0cGl4ZWxUb3RhbCA9IHRoaXMuZWxlbWVudFNpemUud2lkdGg7XG5cdFx0XHRwaXhlbE1vdXNlID0gcG9zaXRpb24ueCAtIHRoaXMuZWxlbWVudE9mZnNldC5sZWZ0IC0gKCB0aGlzLl9jbGlja09mZnNldCA/IHRoaXMuX2NsaWNrT2Zmc2V0LmxlZnQgOiAwICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBpeGVsVG90YWwgPSB0aGlzLmVsZW1lbnRTaXplLmhlaWdodDtcblx0XHRcdHBpeGVsTW91c2UgPSBwb3NpdGlvbi55IC0gdGhpcy5lbGVtZW50T2Zmc2V0LnRvcCAtICggdGhpcy5fY2xpY2tPZmZzZXQgPyB0aGlzLl9jbGlja09mZnNldC50b3AgOiAwICk7XG5cdFx0fVxuXG5cdFx0cGVyY2VudE1vdXNlID0gKCBwaXhlbE1vdXNlIC8gcGl4ZWxUb3RhbCApO1xuXHRcdGlmICggcGVyY2VudE1vdXNlID4gMSApIHtcblx0XHRcdHBlcmNlbnRNb3VzZSA9IDE7XG5cdFx0fVxuXHRcdGlmICggcGVyY2VudE1vdXNlIDwgMCApIHtcblx0XHRcdHBlcmNlbnRNb3VzZSA9IDA7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5vcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiICkge1xuXHRcdFx0cGVyY2VudE1vdXNlID0gMSAtIHBlcmNlbnRNb3VzZTtcblx0XHR9XG5cblx0XHR2YWx1ZVRvdGFsID0gdGhpcy5fdmFsdWVNYXgoKSAtIHRoaXMuX3ZhbHVlTWluKCk7XG5cdFx0dmFsdWVNb3VzZSA9IHRoaXMuX3ZhbHVlTWluKCkgKyBwZXJjZW50TW91c2UgKiB2YWx1ZVRvdGFsO1xuXG5cdFx0cmV0dXJuIHRoaXMuX3RyaW1BbGlnblZhbHVlKCB2YWx1ZU1vdXNlICk7XG5cdH0sXG5cblx0X3N0YXJ0OiBmdW5jdGlvbiggZXZlbnQsIGluZGV4ICkge1xuXHRcdHZhciB1aUhhc2ggPSB7XG5cdFx0XHRoYW5kbGU6IHRoaXMuaGFuZGxlc1sgaW5kZXggXSxcblx0XHRcdHZhbHVlOiB0aGlzLnZhbHVlKClcblx0XHR9O1xuXHRcdGlmICggdGhpcy5vcHRpb25zLnZhbHVlcyAmJiB0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCApIHtcblx0XHRcdHVpSGFzaC52YWx1ZSA9IHRoaXMudmFsdWVzKCBpbmRleCApO1xuXHRcdFx0dWlIYXNoLnZhbHVlcyA9IHRoaXMudmFsdWVzKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl90cmlnZ2VyKCBcInN0YXJ0XCIsIGV2ZW50LCB1aUhhc2ggKTtcblx0fSxcblxuXHRfc2xpZGU6IGZ1bmN0aW9uKCBldmVudCwgaW5kZXgsIG5ld1ZhbCApIHtcblx0XHR2YXIgb3RoZXJWYWwsXG5cdFx0XHRuZXdWYWx1ZXMsXG5cdFx0XHRhbGxvd2VkO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMudmFsdWVzICYmIHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoICkge1xuXHRcdFx0b3RoZXJWYWwgPSB0aGlzLnZhbHVlcyggaW5kZXggPyAwIDogMSApO1xuXG5cdFx0XHRpZiAoICggdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGggPT09IDIgJiYgdGhpcy5vcHRpb25zLnJhbmdlID09PSB0cnVlICkgJiZcblx0XHRcdFx0XHQoICggaW5kZXggPT09IDAgJiYgbmV3VmFsID4gb3RoZXJWYWwpIHx8ICggaW5kZXggPT09IDEgJiYgbmV3VmFsIDwgb3RoZXJWYWwgKSApXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRuZXdWYWwgPSBvdGhlclZhbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBuZXdWYWwgIT09IHRoaXMudmFsdWVzKCBpbmRleCApICkge1xuXHRcdFx0XHRuZXdWYWx1ZXMgPSB0aGlzLnZhbHVlcygpO1xuXHRcdFx0XHRuZXdWYWx1ZXNbIGluZGV4IF0gPSBuZXdWYWw7XG5cdFx0XHRcdC8vIEEgc2xpZGUgY2FuIGJlIGNhbmNlbGVkIGJ5IHJldHVybmluZyBmYWxzZSBmcm9tIHRoZSBzbGlkZSBjYWxsYmFja1xuXHRcdFx0XHRhbGxvd2VkID0gdGhpcy5fdHJpZ2dlciggXCJzbGlkZVwiLCBldmVudCwge1xuXHRcdFx0XHRcdGhhbmRsZTogdGhpcy5oYW5kbGVzWyBpbmRleCBdLFxuXHRcdFx0XHRcdHZhbHVlOiBuZXdWYWwsXG5cdFx0XHRcdFx0dmFsdWVzOiBuZXdWYWx1ZXNcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRvdGhlclZhbCA9IHRoaXMudmFsdWVzKCBpbmRleCA/IDAgOiAxICk7XG5cdFx0XHRcdGlmICggYWxsb3dlZCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZXMoIGluZGV4LCBuZXdWYWwsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIG5ld1ZhbCAhPT0gdGhpcy52YWx1ZSgpICkge1xuXHRcdFx0XHQvLyBBIHNsaWRlIGNhbiBiZSBjYW5jZWxlZCBieSByZXR1cm5pbmcgZmFsc2UgZnJvbSB0aGUgc2xpZGUgY2FsbGJhY2tcblx0XHRcdFx0YWxsb3dlZCA9IHRoaXMuX3RyaWdnZXIoIFwic2xpZGVcIiwgZXZlbnQsIHtcblx0XHRcdFx0XHRoYW5kbGU6IHRoaXMuaGFuZGxlc1sgaW5kZXggXSxcblx0XHRcdFx0XHR2YWx1ZTogbmV3VmFsXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0aWYgKCBhbGxvd2VkICE9PSBmYWxzZSApIHtcblx0XHRcdFx0XHR0aGlzLnZhbHVlKCBuZXdWYWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfc3RvcDogZnVuY3Rpb24oIGV2ZW50LCBpbmRleCApIHtcblx0XHR2YXIgdWlIYXNoID0ge1xuXHRcdFx0aGFuZGxlOiB0aGlzLmhhbmRsZXNbIGluZGV4IF0sXG5cdFx0XHR2YWx1ZTogdGhpcy52YWx1ZSgpXG5cdFx0fTtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy52YWx1ZXMgJiYgdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGggKSB7XG5cdFx0XHR1aUhhc2gudmFsdWUgPSB0aGlzLnZhbHVlcyggaW5kZXggKTtcblx0XHRcdHVpSGFzaC52YWx1ZXMgPSB0aGlzLnZhbHVlcygpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RyaWdnZXIoIFwic3RvcFwiLCBldmVudCwgdWlIYXNoICk7XG5cdH0sXG5cblx0X2NoYW5nZTogZnVuY3Rpb24oIGV2ZW50LCBpbmRleCApIHtcblx0XHRpZiAoICF0aGlzLl9rZXlTbGlkaW5nICYmICF0aGlzLl9tb3VzZVNsaWRpbmcgKSB7XG5cdFx0XHR2YXIgdWlIYXNoID0ge1xuXHRcdFx0XHRoYW5kbGU6IHRoaXMuaGFuZGxlc1sgaW5kZXggXSxcblx0XHRcdFx0dmFsdWU6IHRoaXMudmFsdWUoKVxuXHRcdFx0fTtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnZhbHVlcyAmJiB0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCApIHtcblx0XHRcdFx0dWlIYXNoLnZhbHVlID0gdGhpcy52YWx1ZXMoIGluZGV4ICk7XG5cdFx0XHRcdHVpSGFzaC52YWx1ZXMgPSB0aGlzLnZhbHVlcygpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl90cmlnZ2VyKCBcImNoYW5nZVwiLCBldmVudCwgdWlIYXNoICk7XG5cdFx0fVxuXHR9LFxuXG5cdHZhbHVlOiBmdW5jdGlvbiggbmV3VmFsdWUgKSB7XG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnZhbHVlID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIG5ld1ZhbHVlICk7XG5cdFx0XHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcblx0XHRcdHRoaXMuX2NoYW5nZSggbnVsbCwgMCApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl92YWx1ZSgpO1xuXHR9LFxuXG5cdHZhbHVlczogZnVuY3Rpb24oIGluZGV4LCBuZXdWYWx1ZSApIHtcblx0XHR2YXIgdmFscyxcblx0XHRcdG5ld1ZhbHVlcyxcblx0XHRcdGk7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnZhbHVlc1sgaW5kZXggXSA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKCBuZXdWYWx1ZSApO1xuXHRcdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdFx0XHR0aGlzLl9jaGFuZ2UoIG51bGwsIGluZGV4ICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCAkLmlzQXJyYXkoIGFyZ3VtZW50c1sgMCBdICkgKSB7XG5cdFx0XHRcdHZhbHMgPSB0aGlzLm9wdGlvbnMudmFsdWVzO1xuXHRcdFx0XHRuZXdWYWx1ZXMgPSBhcmd1bWVudHNbIDAgXTtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRcdHZhbHNbIGkgXSA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKCBuZXdWYWx1ZXNbIGkgXSApO1xuXHRcdFx0XHRcdHRoaXMuX2NoYW5nZSggbnVsbCwgaSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMudmFsdWVzICYmIHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLl92YWx1ZXMoIGluZGV4ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudmFsdWUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdmFsdWVzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLFxuXHRcdFx0dmFsc0xlbmd0aCA9IDA7XG5cblx0XHRpZiAoICQuaXNBcnJheSggdGhpcy5vcHRpb25zLnZhbHVlcyApICkge1xuXHRcdFx0dmFsc0xlbmd0aCA9IHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoO1xuXHRcdH1cblxuXHRcdCQuV2lkZ2V0LnByb3RvdHlwZS5fc2V0T3B0aW9uLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuXHRcdHN3aXRjaCAoIGtleSApIHtcblx0XHRcdGNhc2UgXCJkaXNhYmxlZFwiOlxuXHRcdFx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0XHRcdHRoaXMuaGFuZGxlcy5maWx0ZXIoIFwiLnVpLXN0YXRlLWZvY3VzXCIgKS5ibHVyKCk7XG5cdFx0XHRcdFx0dGhpcy5oYW5kbGVzLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdFx0XHR0aGlzLmhhbmRsZXMucHJvcCggXCJkaXNhYmxlZFwiLCB0cnVlICk7XG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKCBcInVpLWRpc2FibGVkXCIgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmhhbmRsZXMucHJvcCggXCJkaXNhYmxlZFwiLCBmYWxzZSApO1xuXHRcdFx0XHRcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyggXCJ1aS1kaXNhYmxlZFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwib3JpZW50YXRpb25cIjpcblx0XHRcdFx0dGhpcy5fZGV0ZWN0T3JpZW50YXRpb24oKTtcblx0XHRcdFx0dGhpcy5lbGVtZW50XG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLXNsaWRlci1ob3Jpem9udGFsIHVpLXNsaWRlci12ZXJ0aWNhbFwiIClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktc2xpZGVyLVwiICsgdGhpcy5vcmllbnRhdGlvbiApO1xuXHRcdFx0XHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwidmFsdWVcIjpcblx0XHRcdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IHRydWU7XG5cdFx0XHRcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xuXHRcdFx0XHR0aGlzLl9jaGFuZ2UoIG51bGwsIDAgKTtcblx0XHRcdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJ2YWx1ZXNcIjpcblx0XHRcdFx0dGhpcy5fYW5pbWF0ZU9mZiA9IHRydWU7XG5cdFx0XHRcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IHZhbHNMZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0XHR0aGlzLl9jaGFuZ2UoIG51bGwsIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcIm1pblwiOlxuXHRcdFx0Y2FzZSBcIm1heFwiOlxuXHRcdFx0XHR0aGlzLl9hbmltYXRlT2ZmID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGVPZmYgPSBmYWxzZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9LFxuXG5cdC8vaW50ZXJuYWwgdmFsdWUgZ2V0dGVyXG5cdC8vIF92YWx1ZSgpIHJldHVybnMgdmFsdWUgdHJpbW1lZCBieSBtaW4gYW5kIG1heCwgYWxpZ25lZCBieSBzdGVwXG5cdF92YWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZhbCA9IHRoaXMub3B0aW9ucy52YWx1ZTtcblx0XHR2YWwgPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggdmFsICk7XG5cblx0XHRyZXR1cm4gdmFsO1xuXHR9LFxuXG5cdC8vaW50ZXJuYWwgdmFsdWVzIGdldHRlclxuXHQvLyBfdmFsdWVzKCkgcmV0dXJucyBhcnJheSBvZiB2YWx1ZXMgdHJpbW1lZCBieSBtaW4gYW5kIG1heCwgYWxpZ25lZCBieSBzdGVwXG5cdC8vIF92YWx1ZXMoIGluZGV4ICkgcmV0dXJucyBzaW5nbGUgdmFsdWUgdHJpbW1lZCBieSBtaW4gYW5kIG1heCwgYWxpZ25lZCBieSBzdGVwXG5cdF92YWx1ZXM6IGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHR2YXIgdmFsLFxuXHRcdFx0dmFscyxcblx0XHRcdGk7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR2YWwgPSB0aGlzLm9wdGlvbnMudmFsdWVzWyBpbmRleCBdO1xuXHRcdFx0dmFsID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoIHZhbCApO1xuXG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyAuc2xpY2UoKSBjcmVhdGVzIGEgY29weSBvZiB0aGUgYXJyYXlcblx0XHRcdC8vIHRoaXMgY29weSBnZXRzIHRyaW1tZWQgYnkgbWluIGFuZCBtYXggYW5kIHRoZW4gcmV0dXJuZWRcblx0XHRcdHZhbHMgPSB0aGlzLm9wdGlvbnMudmFsdWVzLnNsaWNlKCk7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKz0gMSkge1xuXHRcdFx0XHR2YWxzWyBpIF0gPSB0aGlzLl90cmltQWxpZ25WYWx1ZSggdmFsc1sgaSBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWxzO1xuXHRcdH1cblx0fSxcblxuXHQvLyByZXR1cm5zIHRoZSBzdGVwLWFsaWduZWQgdmFsdWUgdGhhdCB2YWwgaXMgY2xvc2VzdCB0bywgYmV0d2VlbiAoaW5jbHVzaXZlKSBtaW4gYW5kIG1heFxuXHRfdHJpbUFsaWduVmFsdWU6IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0aWYgKCB2YWwgPD0gdGhpcy5fdmFsdWVNaW4oKSApIHtcblx0XHRcdHJldHVybiB0aGlzLl92YWx1ZU1pbigpO1xuXHRcdH1cblx0XHRpZiAoIHZhbCA+PSB0aGlzLl92YWx1ZU1heCgpICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3ZhbHVlTWF4KCk7XG5cdFx0fVxuXHRcdHZhciBzdGVwID0gKCB0aGlzLm9wdGlvbnMuc3RlcCA+IDAgKSA/IHRoaXMub3B0aW9ucy5zdGVwIDogMSxcblx0XHRcdHZhbE1vZFN0ZXAgPSAodmFsIC0gdGhpcy5fdmFsdWVNaW4oKSkgJSBzdGVwLFxuXHRcdFx0YWxpZ25WYWx1ZSA9IHZhbCAtIHZhbE1vZFN0ZXA7XG5cblx0XHRpZiAoIE1hdGguYWJzKHZhbE1vZFN0ZXApICogMiA+PSBzdGVwICkge1xuXHRcdFx0YWxpZ25WYWx1ZSArPSAoIHZhbE1vZFN0ZXAgPiAwICkgPyBzdGVwIDogKCAtc3RlcCApO1xuXHRcdH1cblxuXHRcdC8vIFNpbmNlIEphdmFTY3JpcHQgaGFzIHByb2JsZW1zIHdpdGggbGFyZ2UgZmxvYXRzLCByb3VuZFxuXHRcdC8vIHRoZSBmaW5hbCB2YWx1ZSB0byA1IGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCAoc2VlICM0MTI0KVxuXHRcdHJldHVybiBwYXJzZUZsb2F0KCBhbGlnblZhbHVlLnRvRml4ZWQoNSkgKTtcblx0fSxcblxuXHRfdmFsdWVNaW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWluO1xuXHR9LFxuXG5cdF92YWx1ZU1heDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5tYXg7XG5cdH0sXG5cblx0X3JlZnJlc2hWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxhc3RWYWxQZXJjZW50LCB2YWxQZXJjZW50LCB2YWx1ZSwgdmFsdWVNaW4sIHZhbHVlTWF4LFxuXHRcdFx0b1JhbmdlID0gdGhpcy5vcHRpb25zLnJhbmdlLFxuXHRcdFx0byA9IHRoaXMub3B0aW9ucyxcblx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0YW5pbWF0ZSA9ICggIXRoaXMuX2FuaW1hdGVPZmYgKSA/IG8uYW5pbWF0ZSA6IGZhbHNlLFxuXHRcdFx0X3NldCA9IHt9O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMudmFsdWVzICYmIHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5oYW5kbGVzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHZhbFBlcmNlbnQgPSAoIHRoYXQudmFsdWVzKGkpIC0gdGhhdC5fdmFsdWVNaW4oKSApIC8gKCB0aGF0Ll92YWx1ZU1heCgpIC0gdGhhdC5fdmFsdWVNaW4oKSApICogMTAwO1xuXHRcdFx0XHRfc2V0WyB0aGF0Lm9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IFwibGVmdFwiIDogXCJib3R0b21cIiBdID0gdmFsUGVyY2VudCArIFwiJVwiO1xuXHRcdFx0XHQkKCB0aGlzICkuc3RvcCggMSwgMSApWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIF9zZXQsIG8uYW5pbWF0ZSApO1xuXHRcdFx0XHRpZiAoIHRoYXQub3B0aW9ucy5yYW5nZSA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRpZiAoIHRoYXQub3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiICkge1xuXHRcdFx0XHRcdFx0aWYgKCBpID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHR0aGF0LnJhbmdlLnN0b3AoIDEsIDEgKVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7IGxlZnQ6IHZhbFBlcmNlbnQgKyBcIiVcIiB9LCBvLmFuaW1hdGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggaSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0dGhhdC5yYW5nZVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7IHdpZHRoOiAoIHZhbFBlcmNlbnQgLSBsYXN0VmFsUGVyY2VudCApICsgXCIlXCIgfSwgeyBxdWV1ZTogZmFsc2UsIGR1cmF0aW9uOiBvLmFuaW1hdGUgfSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoIGkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdHRoYXQucmFuZ2Uuc3RvcCggMSwgMSApWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHsgYm90dG9tOiAoIHZhbFBlcmNlbnQgKSArIFwiJVwiIH0sIG8uYW5pbWF0ZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBpID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHR0aGF0LnJhbmdlWyBhbmltYXRlID8gXCJhbmltYXRlXCIgOiBcImNzc1wiIF0oIHsgaGVpZ2h0OiAoIHZhbFBlcmNlbnQgLSBsYXN0VmFsUGVyY2VudCApICsgXCIlXCIgfSwgeyBxdWV1ZTogZmFsc2UsIGR1cmF0aW9uOiBvLmFuaW1hdGUgfSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRsYXN0VmFsUGVyY2VudCA9IHZhbFBlcmNlbnQ7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsdWUgPSB0aGlzLnZhbHVlKCk7XG5cdFx0XHR2YWx1ZU1pbiA9IHRoaXMuX3ZhbHVlTWluKCk7XG5cdFx0XHR2YWx1ZU1heCA9IHRoaXMuX3ZhbHVlTWF4KCk7XG5cdFx0XHR2YWxQZXJjZW50ID0gKCB2YWx1ZU1heCAhPT0gdmFsdWVNaW4gKSA/XG5cdFx0XHRcdFx0KCB2YWx1ZSAtIHZhbHVlTWluICkgLyAoIHZhbHVlTWF4IC0gdmFsdWVNaW4gKSAqIDEwMCA6XG5cdFx0XHRcdFx0MDtcblx0XHRcdF9zZXRbIHRoaXMub3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gXCJsZWZ0XCIgOiBcImJvdHRvbVwiIF0gPSB2YWxQZXJjZW50ICsgXCIlXCI7XG5cdFx0XHR0aGlzLmhhbmRsZS5zdG9wKCAxLCAxIClbIGFuaW1hdGUgPyBcImFuaW1hdGVcIiA6IFwiY3NzXCIgXSggX3NldCwgby5hbmltYXRlICk7XG5cblx0XHRcdGlmICggb1JhbmdlID09PSBcIm1pblwiICYmIHRoaXMub3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiICkge1xuXHRcdFx0XHR0aGlzLnJhbmdlLnN0b3AoIDEsIDEgKVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7IHdpZHRoOiB2YWxQZXJjZW50ICsgXCIlXCIgfSwgby5hbmltYXRlICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9SYW5nZSA9PT0gXCJtYXhcIiAmJiB0aGlzLm9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiApIHtcblx0XHRcdFx0dGhpcy5yYW5nZVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7IHdpZHRoOiAoIDEwMCAtIHZhbFBlcmNlbnQgKSArIFwiJVwiIH0sIHsgcXVldWU6IGZhbHNlLCBkdXJhdGlvbjogby5hbmltYXRlIH0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggb1JhbmdlID09PSBcIm1pblwiICYmIHRoaXMub3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiApIHtcblx0XHRcdFx0dGhpcy5yYW5nZS5zdG9wKCAxLCAxIClbIGFuaW1hdGUgPyBcImFuaW1hdGVcIiA6IFwiY3NzXCIgXSggeyBoZWlnaHQ6IHZhbFBlcmNlbnQgKyBcIiVcIiB9LCBvLmFuaW1hdGUgKTtcblx0XHRcdH1cblx0XHRcdGlmICggb1JhbmdlID09PSBcIm1heFwiICYmIHRoaXMub3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiApIHtcblx0XHRcdFx0dGhpcy5yYW5nZVsgYW5pbWF0ZSA/IFwiYW5pbWF0ZVwiIDogXCJjc3NcIiBdKCB7IGhlaWdodDogKCAxMDAgLSB2YWxQZXJjZW50ICkgKyBcIiVcIiB9LCB7IHF1ZXVlOiBmYWxzZSwgZHVyYXRpb246IG8uYW5pbWF0ZSB9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cbn0pO1xuXG59KGpRdWVyeSkpO1xuKGZ1bmN0aW9uKCAkLCB1bmRlZmluZWQgKSB7XG5cbiQud2lkZ2V0KFwidWkuc29ydGFibGVcIiwgJC51aS5tb3VzZSwge1xuXHR2ZXJzaW9uOiBcIjEuOS4yXCIsXG5cdHdpZGdldEV2ZW50UHJlZml4OiBcInNvcnRcIixcblx0cmVhZHk6IGZhbHNlLFxuXHRvcHRpb25zOiB7XG5cdFx0YXBwZW5kVG86IFwicGFyZW50XCIsXG5cdFx0YXhpczogZmFsc2UsXG5cdFx0Y29ubmVjdFdpdGg6IGZhbHNlLFxuXHRcdGNvbnRhaW5tZW50OiBmYWxzZSxcblx0XHRjdXJzb3I6ICdhdXRvJyxcblx0XHRjdXJzb3JBdDogZmFsc2UsXG5cdFx0ZHJvcE9uRW1wdHk6IHRydWUsXG5cdFx0Zm9yY2VQbGFjZWhvbGRlclNpemU6IGZhbHNlLFxuXHRcdGZvcmNlSGVscGVyU2l6ZTogZmFsc2UsXG5cdFx0Z3JpZDogZmFsc2UsXG5cdFx0aGFuZGxlOiBmYWxzZSxcblx0XHRoZWxwZXI6IFwib3JpZ2luYWxcIixcblx0XHRpdGVtczogJz4gKicsXG5cdFx0b3BhY2l0eTogZmFsc2UsXG5cdFx0cGxhY2Vob2xkZXI6IGZhbHNlLFxuXHRcdHJldmVydDogZmFsc2UsXG5cdFx0c2Nyb2xsOiB0cnVlLFxuXHRcdHNjcm9sbFNlbnNpdGl2aXR5OiAyMCxcblx0XHRzY3JvbGxTcGVlZDogMjAsXG5cdFx0c2NvcGU6IFwiZGVmYXVsdFwiLFxuXHRcdHRvbGVyYW5jZTogXCJpbnRlcnNlY3RcIixcblx0XHR6SW5kZXg6IDEwMDBcblx0fSxcblx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucztcblx0XHR0aGlzLmNvbnRhaW5lckNhY2hlID0ge307XG5cdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKFwidWktc29ydGFibGVcIik7XG5cblx0XHQvL0dldCB0aGUgaXRlbXNcblx0XHR0aGlzLnJlZnJlc2goKTtcblxuXHRcdC8vTGV0J3MgZGV0ZXJtaW5lIGlmIHRoZSBpdGVtcyBhcmUgYmVpbmcgZGlzcGxheWVkIGhvcml6b250YWxseVxuXHRcdHRoaXMuZmxvYXRpbmcgPSB0aGlzLml0ZW1zLmxlbmd0aCA/IG8uYXhpcyA9PT0gJ3gnIHx8ICgvbGVmdHxyaWdodC8pLnRlc3QodGhpcy5pdGVtc1swXS5pdGVtLmNzcygnZmxvYXQnKSkgfHwgKC9pbmxpbmV8dGFibGUtY2VsbC8pLnRlc3QodGhpcy5pdGVtc1swXS5pdGVtLmNzcygnZGlzcGxheScpKSA6IGZhbHNlO1xuXG5cdFx0Ly9MZXQncyBkZXRlcm1pbmUgdGhlIHBhcmVudCdzIG9mZnNldFxuXHRcdHRoaXMub2Zmc2V0ID0gdGhpcy5lbGVtZW50Lm9mZnNldCgpO1xuXG5cdFx0Ly9Jbml0aWFsaXplIG1vdXNlIGV2ZW50cyBmb3IgaW50ZXJhY3Rpb25cblx0XHR0aGlzLl9tb3VzZUluaXQoKTtcblxuXHRcdC8vV2UncmUgcmVhZHkgdG8gZ29cblx0XHR0aGlzLnJlYWR5ID0gdHJ1ZVxuXG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0LnJlbW92ZUNsYXNzKFwidWktc29ydGFibGUgdWktc29ydGFibGUtZGlzYWJsZWRcIik7XG5cdFx0dGhpcy5fbW91c2VEZXN0cm95KCk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKVxuXHRcdFx0dGhpcy5pdGVtc1tpXS5pdGVtLnJlbW92ZURhdGEodGhpcy53aWRnZXROYW1lICsgXCItaXRlbVwiKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuXHRcdGlmICgga2V5ID09PSBcImRpc2FibGVkXCIgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnNbIGtleSBdID0gdmFsdWU7XG5cblx0XHRcdHRoaXMud2lkZ2V0KCkudG9nZ2xlQ2xhc3MoIFwidWktc29ydGFibGUtZGlzYWJsZWRcIiwgISF2YWx1ZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBEb24ndCBjYWxsIHdpZGdldCBiYXNlIF9zZXRPcHRpb24gZm9yIGRpc2FibGUgYXMgaXQgYWRkcyB1aS1zdGF0ZS1kaXNhYmxlZCBjbGFzc1xuXHRcdFx0JC5XaWRnZXQucHJvdG90eXBlLl9zZXRPcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9XG5cdH0sXG5cblx0X21vdXNlQ2FwdHVyZTogZnVuY3Rpb24oZXZlbnQsIG92ZXJyaWRlSGFuZGxlKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0aWYgKHRoaXMucmV2ZXJ0aW5nKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5vcHRpb25zLmRpc2FibGVkIHx8IHRoaXMub3B0aW9ucy50eXBlID09ICdzdGF0aWMnKSByZXR1cm4gZmFsc2U7XG5cblx0XHQvL1dlIGhhdmUgdG8gcmVmcmVzaCB0aGUgaXRlbXMgZGF0YSBvbmNlIGZpcnN0XG5cdFx0dGhpcy5fcmVmcmVzaEl0ZW1zKGV2ZW50KTtcblxuXHRcdC8vRmluZCBvdXQgaWYgdGhlIGNsaWNrZWQgbm9kZSAob3Igb25lIG9mIGl0cyBwYXJlbnRzKSBpcyBhIGFjdHVhbCBpdGVtIGluIHRoaXMuaXRlbXNcblx0XHR2YXIgY3VycmVudEl0ZW0gPSBudWxsLCBub2RlcyA9ICQoZXZlbnQudGFyZ2V0KS5wYXJlbnRzKCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmKCQuZGF0YSh0aGlzLCB0aGF0LndpZGdldE5hbWUgKyAnLWl0ZW0nKSA9PSB0aGF0KSB7XG5cdFx0XHRcdGN1cnJlbnRJdGVtID0gJCh0aGlzKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlmKCQuZGF0YShldmVudC50YXJnZXQsIHRoYXQud2lkZ2V0TmFtZSArICctaXRlbScpID09IHRoYXQpIGN1cnJlbnRJdGVtID0gJChldmVudC50YXJnZXQpO1xuXG5cdFx0aWYoIWN1cnJlbnRJdGVtKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYodGhpcy5vcHRpb25zLmhhbmRsZSAmJiAhb3ZlcnJpZGVIYW5kbGUpIHtcblx0XHRcdHZhciB2YWxpZEhhbmRsZSA9IGZhbHNlO1xuXG5cdFx0XHQkKHRoaXMub3B0aW9ucy5oYW5kbGUsIGN1cnJlbnRJdGVtKS5maW5kKFwiKlwiKS5hbmRTZWxmKCkuZWFjaChmdW5jdGlvbigpIHsgaWYodGhpcyA9PSBldmVudC50YXJnZXQpIHZhbGlkSGFuZGxlID0gdHJ1ZTsgfSk7XG5cdFx0XHRpZighdmFsaWRIYW5kbGUpIHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0aGlzLmN1cnJlbnRJdGVtID0gY3VycmVudEl0ZW07XG5cdFx0dGhpcy5fcmVtb3ZlQ3VycmVudHNGcm9tSXRlbXMoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9LFxuXG5cdF9tb3VzZVN0YXJ0OiBmdW5jdGlvbihldmVudCwgb3ZlcnJpZGVIYW5kbGUsIG5vQWN0aXZhdGlvbikge1xuXG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnM7XG5cdFx0dGhpcy5jdXJyZW50Q29udGFpbmVyID0gdGhpcztcblxuXHRcdC8vV2Ugb25seSBuZWVkIHRvIGNhbGwgcmVmcmVzaFBvc2l0aW9ucywgYmVjYXVzZSB0aGUgcmVmcmVzaEl0ZW1zIGNhbGwgaGFzIGJlZW4gbW92ZWQgdG8gbW91c2VDYXB0dXJlXG5cdFx0dGhpcy5yZWZyZXNoUG9zaXRpb25zKCk7XG5cblx0XHQvL0NyZWF0ZSBhbmQgYXBwZW5kIHRoZSB2aXNpYmxlIGhlbHBlclxuXHRcdHRoaXMuaGVscGVyID0gdGhpcy5fY3JlYXRlSGVscGVyKGV2ZW50KTtcblxuXHRcdC8vQ2FjaGUgdGhlIGhlbHBlciBzaXplXG5cdFx0dGhpcy5fY2FjaGVIZWxwZXJQcm9wb3J0aW9ucygpO1xuXG5cdFx0Lypcblx0XHQgKiAtIFBvc2l0aW9uIGdlbmVyYXRpb24gLVxuXHRcdCAqIFRoaXMgYmxvY2sgZ2VuZXJhdGVzIGV2ZXJ5dGhpbmcgcG9zaXRpb24gcmVsYXRlZCAtIGl0J3MgdGhlIGNvcmUgb2YgZHJhZ2dhYmxlcy5cblx0XHQgKi9cblxuXHRcdC8vQ2FjaGUgdGhlIG1hcmdpbnMgb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnRcblx0XHR0aGlzLl9jYWNoZU1hcmdpbnMoKTtcblxuXHRcdC8vR2V0IHRoZSBuZXh0IHNjcm9sbGluZyBwYXJlbnRcblx0XHR0aGlzLnNjcm9sbFBhcmVudCA9IHRoaXMuaGVscGVyLnNjcm9sbFBhcmVudCgpO1xuXG5cdFx0Ly9UaGUgZWxlbWVudCdzIGFic29sdXRlIHBvc2l0aW9uIG9uIHRoZSBwYWdlIG1pbnVzIG1hcmdpbnNcblx0XHR0aGlzLm9mZnNldCA9IHRoaXMuY3VycmVudEl0ZW0ub2Zmc2V0KCk7XG5cdFx0dGhpcy5vZmZzZXQgPSB7XG5cdFx0XHR0b3A6IHRoaXMub2Zmc2V0LnRvcCAtIHRoaXMubWFyZ2lucy50b3AsXG5cdFx0XHRsZWZ0OiB0aGlzLm9mZnNldC5sZWZ0IC0gdGhpcy5tYXJnaW5zLmxlZnRcblx0XHR9O1xuXG5cdFx0JC5leHRlbmQodGhpcy5vZmZzZXQsIHtcblx0XHRcdGNsaWNrOiB7IC8vV2hlcmUgdGhlIGNsaWNrIGhhcHBlbmVkLCByZWxhdGl2ZSB0byB0aGUgZWxlbWVudFxuXHRcdFx0XHRsZWZ0OiBldmVudC5wYWdlWCAtIHRoaXMub2Zmc2V0LmxlZnQsXG5cdFx0XHRcdHRvcDogZXZlbnQucGFnZVkgLSB0aGlzLm9mZnNldC50b3Bcblx0XHRcdH0sXG5cdFx0XHRwYXJlbnQ6IHRoaXMuX2dldFBhcmVudE9mZnNldCgpLFxuXHRcdFx0cmVsYXRpdmU6IHRoaXMuX2dldFJlbGF0aXZlT2Zmc2V0KCkgLy9UaGlzIGlzIGEgcmVsYXRpdmUgdG8gYWJzb2x1dGUgcG9zaXRpb24gbWludXMgdGhlIGFjdHVhbCBwb3NpdGlvbiBjYWxjdWxhdGlvbiAtIG9ubHkgdXNlZCBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBoZWxwZXJcblx0XHR9KTtcblxuXHRcdC8vIE9ubHkgYWZ0ZXIgd2UgZ290IHRoZSBvZmZzZXQsIHdlIGNhbiBjaGFuZ2UgdGhlIGhlbHBlcidzIHBvc2l0aW9uIHRvIGFic29sdXRlXG5cdFx0Ly8gVE9ETzogU3RpbGwgbmVlZCB0byBmaWd1cmUgb3V0IGEgd2F5IHRvIG1ha2UgcmVsYXRpdmUgc29ydGluZyBwb3NzaWJsZVxuXHRcdHRoaXMuaGVscGVyLmNzcyhcInBvc2l0aW9uXCIsIFwiYWJzb2x1dGVcIik7XG5cdFx0dGhpcy5jc3NQb3NpdGlvbiA9IHRoaXMuaGVscGVyLmNzcyhcInBvc2l0aW9uXCIpO1xuXG5cdFx0Ly9HZW5lcmF0ZSB0aGUgb3JpZ2luYWwgcG9zaXRpb25cblx0XHR0aGlzLm9yaWdpbmFsUG9zaXRpb24gPSB0aGlzLl9nZW5lcmF0ZVBvc2l0aW9uKGV2ZW50KTtcblx0XHR0aGlzLm9yaWdpbmFsUGFnZVggPSBldmVudC5wYWdlWDtcblx0XHR0aGlzLm9yaWdpbmFsUGFnZVkgPSBldmVudC5wYWdlWTtcblxuXHRcdC8vQWRqdXN0IHRoZSBtb3VzZSBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIGhlbHBlciBpZiAnY3Vyc29yQXQnIGlzIHN1cHBsaWVkXG5cdFx0KG8uY3Vyc29yQXQgJiYgdGhpcy5fYWRqdXN0T2Zmc2V0RnJvbUhlbHBlcihvLmN1cnNvckF0KSk7XG5cblx0XHQvL0NhY2hlIHRoZSBmb3JtZXIgRE9NIHBvc2l0aW9uXG5cdFx0dGhpcy5kb21Qb3NpdGlvbiA9IHsgcHJldjogdGhpcy5jdXJyZW50SXRlbS5wcmV2KClbMF0sIHBhcmVudDogdGhpcy5jdXJyZW50SXRlbS5wYXJlbnQoKVswXSB9O1xuXG5cdFx0Ly9JZiB0aGUgaGVscGVyIGlzIG5vdCB0aGUgb3JpZ2luYWwsIGhpZGUgdGhlIG9yaWdpbmFsIHNvIGl0J3Mgbm90IHBsYXlpbmcgYW55IHJvbGUgZHVyaW5nIHRoZSBkcmFnLCB3b24ndCBjYXVzZSBhbnl0aGluZyBiYWQgdGhpcyB3YXlcblx0XHRpZih0aGlzLmhlbHBlclswXSAhPSB0aGlzLmN1cnJlbnRJdGVtWzBdKSB7XG5cdFx0XHR0aGlzLmN1cnJlbnRJdGVtLmhpZGUoKTtcblx0XHR9XG5cblx0XHQvL0NyZWF0ZSB0aGUgcGxhY2Vob2xkZXJcblx0XHR0aGlzLl9jcmVhdGVQbGFjZWhvbGRlcigpO1xuXG5cdFx0Ly9TZXQgYSBjb250YWlubWVudCBpZiBnaXZlbiBpbiB0aGUgb3B0aW9uc1xuXHRcdGlmKG8uY29udGFpbm1lbnQpXG5cdFx0XHR0aGlzLl9zZXRDb250YWlubWVudCgpO1xuXG5cdFx0aWYoby5jdXJzb3IpIHsgLy8gY3Vyc29yIG9wdGlvblxuXHRcdFx0aWYgKCQoJ2JvZHknKS5jc3MoXCJjdXJzb3JcIikpIHRoaXMuX3N0b3JlZEN1cnNvciA9ICQoJ2JvZHknKS5jc3MoXCJjdXJzb3JcIik7XG5cdFx0XHQkKCdib2R5JykuY3NzKFwiY3Vyc29yXCIsIG8uY3Vyc29yKTtcblx0XHR9XG5cblx0XHRpZihvLm9wYWNpdHkpIHsgLy8gb3BhY2l0eSBvcHRpb25cblx0XHRcdGlmICh0aGlzLmhlbHBlci5jc3MoXCJvcGFjaXR5XCIpKSB0aGlzLl9zdG9yZWRPcGFjaXR5ID0gdGhpcy5oZWxwZXIuY3NzKFwib3BhY2l0eVwiKTtcblx0XHRcdHRoaXMuaGVscGVyLmNzcyhcIm9wYWNpdHlcIiwgby5vcGFjaXR5KTtcblx0XHR9XG5cblx0XHRpZihvLnpJbmRleCkgeyAvLyB6SW5kZXggb3B0aW9uXG5cdFx0XHRpZiAodGhpcy5oZWxwZXIuY3NzKFwiekluZGV4XCIpKSB0aGlzLl9zdG9yZWRaSW5kZXggPSB0aGlzLmhlbHBlci5jc3MoXCJ6SW5kZXhcIik7XG5cdFx0XHR0aGlzLmhlbHBlci5jc3MoXCJ6SW5kZXhcIiwgby56SW5kZXgpO1xuXHRcdH1cblxuXHRcdC8vUHJlcGFyZSBzY3JvbGxpbmdcblx0XHRpZih0aGlzLnNjcm9sbFBhcmVudFswXSAhPSBkb2N1bWVudCAmJiB0aGlzLnNjcm9sbFBhcmVudFswXS50YWdOYW1lICE9ICdIVE1MJylcblx0XHRcdHRoaXMub3ZlcmZsb3dPZmZzZXQgPSB0aGlzLnNjcm9sbFBhcmVudC5vZmZzZXQoKTtcblxuXHRcdC8vQ2FsbCBjYWxsYmFja3Ncblx0XHR0aGlzLl90cmlnZ2VyKFwic3RhcnRcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTtcblxuXHRcdC8vUmVjYWNoZSB0aGUgaGVscGVyIHNpemVcblx0XHRpZighdGhpcy5fcHJlc2VydmVIZWxwZXJQcm9wb3J0aW9ucylcblx0XHRcdHRoaXMuX2NhY2hlSGVscGVyUHJvcG9ydGlvbnMoKTtcblxuXG5cdFx0Ly9Qb3N0ICdhY3RpdmF0ZScgZXZlbnRzIHRvIHBvc3NpYmxlIGNvbnRhaW5lcnNcblx0XHRpZighbm9BY3RpdmF0aW9uKSB7XG5cdFx0XHQgZm9yICh2YXIgaSA9IHRoaXMuY29udGFpbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgeyB0aGlzLmNvbnRhaW5lcnNbaV0uX3RyaWdnZXIoXCJhY3RpdmF0ZVwiLCBldmVudCwgdGhpcy5fdWlIYXNoKHRoaXMpKTsgfVxuXHRcdH1cblxuXHRcdC8vUHJlcGFyZSBwb3NzaWJsZSBkcm9wcGFibGVzXG5cdFx0aWYoJC51aS5kZG1hbmFnZXIpXG5cdFx0XHQkLnVpLmRkbWFuYWdlci5jdXJyZW50ID0gdGhpcztcblxuXHRcdGlmICgkLnVpLmRkbWFuYWdlciAmJiAhby5kcm9wQmVoYXZpb3VyKVxuXHRcdFx0JC51aS5kZG1hbmFnZXIucHJlcGFyZU9mZnNldHModGhpcywgZXZlbnQpO1xuXG5cdFx0dGhpcy5kcmFnZ2luZyA9IHRydWU7XG5cblx0XHR0aGlzLmhlbHBlci5hZGRDbGFzcyhcInVpLXNvcnRhYmxlLWhlbHBlclwiKTtcblx0XHR0aGlzLl9tb3VzZURyYWcoZXZlbnQpOyAvL0V4ZWN1dGUgdGhlIGRyYWcgb25jZSAtIHRoaXMgY2F1c2VzIHRoZSBoZWxwZXIgbm90IHRvIGJlIHZpc2libGUgYmVmb3JlIGdldHRpbmcgaXRzIGNvcnJlY3QgcG9zaXRpb25cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9LFxuXG5cdF9tb3VzZURyYWc6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHQvL0NvbXB1dGUgdGhlIGhlbHBlcnMgcG9zaXRpb25cblx0XHR0aGlzLnBvc2l0aW9uID0gdGhpcy5fZ2VuZXJhdGVQb3NpdGlvbihldmVudCk7XG5cdFx0dGhpcy5wb3NpdGlvbkFicyA9IHRoaXMuX2NvbnZlcnRQb3NpdGlvblRvKFwiYWJzb2x1dGVcIik7XG5cblx0XHRpZiAoIXRoaXMubGFzdFBvc2l0aW9uQWJzKSB7XG5cdFx0XHR0aGlzLmxhc3RQb3NpdGlvbkFicyA9IHRoaXMucG9zaXRpb25BYnM7XG5cdFx0fVxuXG5cdFx0Ly9EbyBzY3JvbGxpbmdcblx0XHRpZih0aGlzLm9wdGlvbnMuc2Nyb2xsKSB7XG5cdFx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucywgc2Nyb2xsZWQgPSBmYWxzZTtcblx0XHRcdGlmKHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9IGRvY3VtZW50ICYmIHRoaXMuc2Nyb2xsUGFyZW50WzBdLnRhZ05hbWUgIT0gJ0hUTUwnKSB7XG5cblx0XHRcdFx0aWYoKHRoaXMub3ZlcmZsb3dPZmZzZXQudG9wICsgdGhpcy5zY3JvbGxQYXJlbnRbMF0ub2Zmc2V0SGVpZ2h0KSAtIGV2ZW50LnBhZ2VZIDwgby5zY3JvbGxTZW5zaXRpdml0eSlcblx0XHRcdFx0XHR0aGlzLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3AgPSBzY3JvbGxlZCA9IHRoaXMuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbFRvcCArIG8uc2Nyb2xsU3BlZWQ7XG5cdFx0XHRcdGVsc2UgaWYoZXZlbnQucGFnZVkgLSB0aGlzLm92ZXJmbG93T2Zmc2V0LnRvcCA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpXG5cdFx0XHRcdFx0dGhpcy5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsVG9wID0gc2Nyb2xsZWQgPSB0aGlzLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3AgLSBvLnNjcm9sbFNwZWVkO1xuXG5cdFx0XHRcdGlmKCh0aGlzLm92ZXJmbG93T2Zmc2V0LmxlZnQgKyB0aGlzLnNjcm9sbFBhcmVudFswXS5vZmZzZXRXaWR0aCkgLSBldmVudC5wYWdlWCA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpXG5cdFx0XHRcdFx0dGhpcy5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsTGVmdCA9IHNjcm9sbGVkID0gdGhpcy5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsTGVmdCArIG8uc2Nyb2xsU3BlZWQ7XG5cdFx0XHRcdGVsc2UgaWYoZXZlbnQucGFnZVggLSB0aGlzLm92ZXJmbG93T2Zmc2V0LmxlZnQgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KVxuXHRcdFx0XHRcdHRoaXMuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQgPSBzY3JvbGxlZCA9IHRoaXMuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQgLSBvLnNjcm9sbFNwZWVkO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmKGV2ZW50LnBhZ2VZIC0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KVxuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIC0gby5zY3JvbGxTcGVlZCk7XG5cdFx0XHRcdGVsc2UgaWYoJCh3aW5kb3cpLmhlaWdodCgpIC0gKGV2ZW50LnBhZ2VZIC0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkpIDwgby5zY3JvbGxTZW5zaXRpdml0eSlcblx0XHRcdFx0XHRzY3JvbGxlZCA9ICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSArIG8uc2Nyb2xsU3BlZWQpO1xuXG5cdFx0XHRcdGlmKGV2ZW50LnBhZ2VYIC0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpIDwgby5zY3JvbGxTZW5zaXRpdml0eSlcblx0XHRcdFx0XHRzY3JvbGxlZCA9ICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpIC0gby5zY3JvbGxTcGVlZCk7XG5cdFx0XHRcdGVsc2UgaWYoJCh3aW5kb3cpLndpZHRoKCkgLSAoZXZlbnQucGFnZVggLSAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkpIDwgby5zY3JvbGxTZW5zaXRpdml0eSlcblx0XHRcdFx0XHRzY3JvbGxlZCA9ICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpICsgby5zY3JvbGxTcGVlZCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYoc2Nyb2xsZWQgIT09IGZhbHNlICYmICQudWkuZGRtYW5hZ2VyICYmICFvLmRyb3BCZWhhdmlvdXIpXG5cdFx0XHRcdCQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKHRoaXMsIGV2ZW50KTtcblx0XHR9XG5cblx0XHQvL1JlZ2VuZXJhdGUgdGhlIGFic29sdXRlIHBvc2l0aW9uIHVzZWQgZm9yIHBvc2l0aW9uIGNoZWNrc1xuXHRcdHRoaXMucG9zaXRpb25BYnMgPSB0aGlzLl9jb252ZXJ0UG9zaXRpb25UbyhcImFic29sdXRlXCIpO1xuXG5cdFx0Ly9TZXQgdGhlIGhlbHBlciBwb3NpdGlvblxuXHRcdGlmKCF0aGlzLm9wdGlvbnMuYXhpcyB8fCB0aGlzLm9wdGlvbnMuYXhpcyAhPSBcInlcIikgdGhpcy5oZWxwZXJbMF0uc3R5bGUubGVmdCA9IHRoaXMucG9zaXRpb24ubGVmdCsncHgnO1xuXHRcdGlmKCF0aGlzLm9wdGlvbnMuYXhpcyB8fCB0aGlzLm9wdGlvbnMuYXhpcyAhPSBcInhcIikgdGhpcy5oZWxwZXJbMF0uc3R5bGUudG9wID0gdGhpcy5wb3NpdGlvbi50b3ArJ3B4JztcblxuXHRcdC8vUmVhcnJhbmdlXG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMuaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblxuXHRcdFx0Ly9DYWNoZSB2YXJpYWJsZXMgYW5kIGludGVyc2VjdGlvbiwgY29udGludWUgaWYgbm8gaW50ZXJzZWN0aW9uXG5cdFx0XHR2YXIgaXRlbSA9IHRoaXMuaXRlbXNbaV0sIGl0ZW1FbGVtZW50ID0gaXRlbS5pdGVtWzBdLCBpbnRlcnNlY3Rpb24gPSB0aGlzLl9pbnRlcnNlY3RzV2l0aFBvaW50ZXIoaXRlbSk7XG5cdFx0XHRpZiAoIWludGVyc2VjdGlvbikgY29udGludWU7XG5cblx0XHRcdC8vIE9ubHkgcHV0IHRoZSBwbGFjZWhvbGRlciBpbnNpZGUgdGhlIGN1cnJlbnQgQ29udGFpbmVyLCBza2lwIGFsbFxuXHRcdFx0Ly8gaXRlbXMgZm9ybSBvdGhlciBjb250YWluZXJzLiBUaGlzIHdvcmtzIGJlY2F1c2Ugd2hlbiBtb3Zpbmdcblx0XHRcdC8vIGFuIGl0ZW0gZnJvbSBvbmUgY29udGFpbmVyIHRvIGFub3RoZXIgdGhlXG5cdFx0XHQvLyBjdXJyZW50Q29udGFpbmVyIGlzIHN3aXRjaGVkIGJlZm9yZSB0aGUgcGxhY2Vob2xkZXIgaXMgbW92ZWQuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gV2l0aG91dCB0aGlzIG1vdmluZyBpdGVtcyBpbiBcInN1Yi1zb3J0YWJsZXNcIiBjYW4gY2F1c2UgdGhlIHBsYWNlaG9sZGVyIHRvIGppdHRlclxuXHRcdFx0Ly8gYmVldHdlZW4gdGhlIG91dGVyIGFuZCBpbm5lciBjb250YWluZXIuXG5cdFx0XHRpZiAoaXRlbS5pbnN0YW5jZSAhPT0gdGhpcy5jdXJyZW50Q29udGFpbmVyKSBjb250aW51ZTtcblxuXHRcdFx0aWYgKGl0ZW1FbGVtZW50ICE9IHRoaXMuY3VycmVudEl0ZW1bMF0gLy9jYW5ub3QgaW50ZXJzZWN0IHdpdGggaXRzZWxmXG5cdFx0XHRcdCYmXHR0aGlzLnBsYWNlaG9sZGVyW2ludGVyc2VjdGlvbiA9PSAxID8gXCJuZXh0XCIgOiBcInByZXZcIl0oKVswXSAhPSBpdGVtRWxlbWVudCAvL25vIHVzZWxlc3MgYWN0aW9ucyB0aGF0IGhhdmUgYmVlbiBkb25lIGJlZm9yZVxuXHRcdFx0XHQmJlx0ISQuY29udGFpbnModGhpcy5wbGFjZWhvbGRlclswXSwgaXRlbUVsZW1lbnQpIC8vbm8gYWN0aW9uIGlmIHRoZSBpdGVtIG1vdmVkIGlzIHRoZSBwYXJlbnQgb2YgdGhlIGl0ZW0gY2hlY2tlZFxuXHRcdFx0XHQmJiAodGhpcy5vcHRpb25zLnR5cGUgPT0gJ3NlbWktZHluYW1pYycgPyAhJC5jb250YWlucyh0aGlzLmVsZW1lbnRbMF0sIGl0ZW1FbGVtZW50KSA6IHRydWUpXG5cdFx0XHRcdC8vJiYgaXRlbUVsZW1lbnQucGFyZW50Tm9kZSA9PSB0aGlzLnBsYWNlaG9sZGVyWzBdLnBhcmVudE5vZGUgLy8gb25seSByZWFycmFuZ2UgaXRlbXMgd2l0aGluIHRoZSBzYW1lIGNvbnRhaW5lclxuXHRcdFx0KSB7XG5cblx0XHRcdFx0dGhpcy5kaXJlY3Rpb24gPSBpbnRlcnNlY3Rpb24gPT0gMSA/IFwiZG93blwiIDogXCJ1cFwiO1xuXG5cdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMudG9sZXJhbmNlID09IFwicG9pbnRlclwiIHx8IHRoaXMuX2ludGVyc2VjdHNXaXRoU2lkZXMoaXRlbSkpIHtcblx0XHRcdFx0XHR0aGlzLl9yZWFycmFuZ2UoZXZlbnQsIGl0ZW0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fdHJpZ2dlcihcImNoYW5nZVwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL1Bvc3QgZXZlbnRzIHRvIGNvbnRhaW5lcnNcblx0XHR0aGlzLl9jb250YWN0Q29udGFpbmVycyhldmVudCk7XG5cblx0XHQvL0ludGVyY29ubmVjdCB3aXRoIGRyb3BwYWJsZXNcblx0XHRpZigkLnVpLmRkbWFuYWdlcikgJC51aS5kZG1hbmFnZXIuZHJhZyh0aGlzLCBldmVudCk7XG5cblx0XHQvL0NhbGwgY2FsbGJhY2tzXG5cdFx0dGhpcy5fdHJpZ2dlcignc29ydCcsIGV2ZW50LCB0aGlzLl91aUhhc2goKSk7XG5cblx0XHR0aGlzLmxhc3RQb3NpdGlvbkFicyA9IHRoaXMucG9zaXRpb25BYnM7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH0sXG5cblx0X21vdXNlU3RvcDogZnVuY3Rpb24oZXZlbnQsIG5vUHJvcGFnYXRpb24pIHtcblxuXHRcdGlmKCFldmVudCkgcmV0dXJuO1xuXG5cdFx0Ly9JZiB3ZSBhcmUgdXNpbmcgZHJvcHBhYmxlcywgaW5mb3JtIHRoZSBtYW5hZ2VyIGFib3V0IHRoZSBkcm9wXG5cdFx0aWYgKCQudWkuZGRtYW5hZ2VyICYmICF0aGlzLm9wdGlvbnMuZHJvcEJlaGF2aW91cilcblx0XHRcdCQudWkuZGRtYW5hZ2VyLmRyb3AodGhpcywgZXZlbnQpO1xuXG5cdFx0aWYodGhpcy5vcHRpb25zLnJldmVydCkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0dmFyIGN1ciA9IHRoaXMucGxhY2Vob2xkZXIub2Zmc2V0KCk7XG5cblx0XHRcdHRoaXMucmV2ZXJ0aW5nID0gdHJ1ZTtcblxuXHRcdFx0JCh0aGlzLmhlbHBlcikuYW5pbWF0ZSh7XG5cdFx0XHRcdGxlZnQ6IGN1ci5sZWZ0IC0gdGhpcy5vZmZzZXQucGFyZW50LmxlZnQgLSB0aGlzLm1hcmdpbnMubGVmdCArICh0aGlzLm9mZnNldFBhcmVudFswXSA9PSBkb2N1bWVudC5ib2R5ID8gMCA6IHRoaXMub2Zmc2V0UGFyZW50WzBdLnNjcm9sbExlZnQpLFxuXHRcdFx0XHR0b3A6IGN1ci50b3AgLSB0aGlzLm9mZnNldC5wYXJlbnQudG9wIC0gdGhpcy5tYXJnaW5zLnRvcCArICh0aGlzLm9mZnNldFBhcmVudFswXSA9PSBkb2N1bWVudC5ib2R5ID8gMCA6IHRoaXMub2Zmc2V0UGFyZW50WzBdLnNjcm9sbFRvcClcblx0XHRcdH0sIHBhcnNlSW50KHRoaXMub3B0aW9ucy5yZXZlcnQsIDEwKSB8fCA1MDAsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGF0Ll9jbGVhcihldmVudCk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY2xlYXIoZXZlbnQsIG5vUHJvcGFnYXRpb24pO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9LFxuXG5cdGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cblx0XHRpZih0aGlzLmRyYWdnaW5nKSB7XG5cblx0XHRcdHRoaXMuX21vdXNlVXAoeyB0YXJnZXQ6IG51bGwgfSk7XG5cblx0XHRcdGlmKHRoaXMub3B0aW9ucy5oZWxwZXIgPT0gXCJvcmlnaW5hbFwiKVxuXHRcdFx0XHR0aGlzLmN1cnJlbnRJdGVtLmNzcyh0aGlzLl9zdG9yZWRDU1MpLnJlbW92ZUNsYXNzKFwidWktc29ydGFibGUtaGVscGVyXCIpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0aGlzLmN1cnJlbnRJdGVtLnNob3coKTtcblxuXHRcdFx0Ly9Qb3N0IGRlYWN0aXZhdGluZyBldmVudHMgdG8gY29udGFpbmVyc1xuXHRcdFx0Zm9yICh2YXIgaSA9IHRoaXMuY29udGFpbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG5cdFx0XHRcdHRoaXMuY29udGFpbmVyc1tpXS5fdHJpZ2dlcihcImRlYWN0aXZhdGVcIiwgbnVsbCwgdGhpcy5fdWlIYXNoKHRoaXMpKTtcblx0XHRcdFx0aWYodGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlLm92ZXIpIHtcblx0XHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbaV0uX3RyaWdnZXIoXCJvdXRcIiwgbnVsbCwgdGhpcy5fdWlIYXNoKHRoaXMpKTtcblx0XHRcdFx0XHR0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUub3ZlciA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICh0aGlzLnBsYWNlaG9sZGVyKSB7XG5cdFx0XHQvLyQodGhpcy5wbGFjZWhvbGRlclswXSkucmVtb3ZlKCk7IHdvdWxkIGhhdmUgYmVlbiB0aGUgalF1ZXJ5IHdheSAtIHVuZm9ydHVuYXRlbHksIGl0IHVuYmluZHMgQUxMIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCBub2RlIVxuXHRcdFx0aWYodGhpcy5wbGFjZWhvbGRlclswXS5wYXJlbnROb2RlKSB0aGlzLnBsYWNlaG9sZGVyWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wbGFjZWhvbGRlclswXSk7XG5cdFx0XHRpZih0aGlzLm9wdGlvbnMuaGVscGVyICE9IFwib3JpZ2luYWxcIiAmJiB0aGlzLmhlbHBlciAmJiB0aGlzLmhlbHBlclswXS5wYXJlbnROb2RlKSB0aGlzLmhlbHBlci5yZW1vdmUoKTtcblxuXHRcdFx0JC5leHRlbmQodGhpcywge1xuXHRcdFx0XHRoZWxwZXI6IG51bGwsXG5cdFx0XHRcdGRyYWdnaW5nOiBmYWxzZSxcblx0XHRcdFx0cmV2ZXJ0aW5nOiBmYWxzZSxcblx0XHRcdFx0X25vRmluYWxTb3J0OiBudWxsXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYodGhpcy5kb21Qb3NpdGlvbi5wcmV2KSB7XG5cdFx0XHRcdCQodGhpcy5kb21Qb3NpdGlvbi5wcmV2KS5hZnRlcih0aGlzLmN1cnJlbnRJdGVtKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCQodGhpcy5kb21Qb3NpdGlvbi5wYXJlbnQpLnByZXBlbmQodGhpcy5jdXJyZW50SXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKG8pIHtcblxuXHRcdHZhciBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zQXNqUXVlcnkobyAmJiBvLmNvbm5lY3RlZCk7XG5cdFx0dmFyIHN0ciA9IFtdOyBvID0gbyB8fCB7fTtcblxuXHRcdCQoaXRlbXMpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVzID0gKCQoby5pdGVtIHx8IHRoaXMpLmF0dHIoby5hdHRyaWJ1dGUgfHwgJ2lkJykgfHwgJycpLm1hdGNoKG8uZXhwcmVzc2lvbiB8fCAoLyguKylbLT1fXSguKykvKSk7XG5cdFx0XHRpZihyZXMpIHN0ci5wdXNoKChvLmtleSB8fCByZXNbMV0rJ1tdJykrJz0nKyhvLmtleSAmJiBvLmV4cHJlc3Npb24gPyByZXNbMV0gOiByZXNbMl0pKTtcblx0XHR9KTtcblxuXHRcdGlmKCFzdHIubGVuZ3RoICYmIG8ua2V5KSB7XG5cdFx0XHRzdHIucHVzaChvLmtleSArICc9Jyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0ci5qb2luKCcmJyk7XG5cblx0fSxcblxuXHR0b0FycmF5OiBmdW5jdGlvbihvKSB7XG5cblx0XHR2YXIgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0FzalF1ZXJ5KG8gJiYgby5jb25uZWN0ZWQpO1xuXHRcdHZhciByZXQgPSBbXTsgbyA9IG8gfHwge307XG5cblx0XHRpdGVtcy5lYWNoKGZ1bmN0aW9uKCkgeyByZXQucHVzaCgkKG8uaXRlbSB8fCB0aGlzKS5hdHRyKG8uYXR0cmlidXRlIHx8ICdpZCcpIHx8ICcnKTsgfSk7XG5cdFx0cmV0dXJuIHJldDtcblxuXHR9LFxuXG5cdC8qIEJlIGNhcmVmdWwgd2l0aCB0aGUgZm9sbG93aW5nIGNvcmUgZnVuY3Rpb25zICovXG5cdF9pbnRlcnNlY3RzV2l0aDogZnVuY3Rpb24oaXRlbSkge1xuXG5cdFx0dmFyIHgxID0gdGhpcy5wb3NpdGlvbkFicy5sZWZ0LFxuXHRcdFx0eDIgPSB4MSArIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGgsXG5cdFx0XHR5MSA9IHRoaXMucG9zaXRpb25BYnMudG9wLFxuXHRcdFx0eTIgPSB5MSArIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0O1xuXG5cdFx0dmFyIGwgPSBpdGVtLmxlZnQsXG5cdFx0XHRyID0gbCArIGl0ZW0ud2lkdGgsXG5cdFx0XHR0ID0gaXRlbS50b3AsXG5cdFx0XHRiID0gdCArIGl0ZW0uaGVpZ2h0O1xuXG5cdFx0dmFyIGR5Q2xpY2sgPSB0aGlzLm9mZnNldC5jbGljay50b3AsXG5cdFx0XHRkeENsaWNrID0gdGhpcy5vZmZzZXQuY2xpY2subGVmdDtcblxuXHRcdHZhciBpc092ZXJFbGVtZW50ID0gKHkxICsgZHlDbGljaykgPiB0ICYmICh5MSArIGR5Q2xpY2spIDwgYiAmJiAoeDEgKyBkeENsaWNrKSA+IGwgJiYgKHgxICsgZHhDbGljaykgPCByO1xuXG5cdFx0aWYoXHQgICB0aGlzLm9wdGlvbnMudG9sZXJhbmNlID09IFwicG9pbnRlclwiXG5cdFx0XHR8fCB0aGlzLm9wdGlvbnMuZm9yY2VQb2ludGVyRm9yQ29udGFpbmVyc1xuXHRcdFx0fHwgKHRoaXMub3B0aW9ucy50b2xlcmFuY2UgIT0gXCJwb2ludGVyXCIgJiYgdGhpcy5oZWxwZXJQcm9wb3J0aW9uc1t0aGlzLmZsb2F0aW5nID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSA+IGl0ZW1bdGhpcy5mbG9hdGluZyA/ICd3aWR0aCcgOiAnaGVpZ2h0J10pXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gaXNPdmVyRWxlbWVudDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gKGwgPCB4MSArICh0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC8gMikgLy8gUmlnaHQgSGFsZlxuXHRcdFx0XHQmJiB4MiAtICh0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC8gMikgPCByIC8vIExlZnQgSGFsZlxuXHRcdFx0XHQmJiB0IDwgeTEgKyAodGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLyAyKSAvLyBCb3R0b20gSGFsZlxuXHRcdFx0XHQmJiB5MiAtICh0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAvIDIpIDwgYiApOyAvLyBUb3AgSGFsZlxuXG5cdFx0fVxuXHR9LFxuXG5cdF9pbnRlcnNlY3RzV2l0aFBvaW50ZXI6IGZ1bmN0aW9uKGl0ZW0pIHtcblxuXHRcdHZhciBpc092ZXJFbGVtZW50SGVpZ2h0ID0gKHRoaXMub3B0aW9ucy5heGlzID09PSAneCcpIHx8ICQudWkuaXNPdmVyQXhpcyh0aGlzLnBvc2l0aW9uQWJzLnRvcCArIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCwgaXRlbS50b3AsIGl0ZW0uaGVpZ2h0KSxcblx0XHRcdGlzT3ZlckVsZW1lbnRXaWR0aCA9ICh0aGlzLm9wdGlvbnMuYXhpcyA9PT0gJ3knKSB8fCAkLnVpLmlzT3ZlckF4aXModGhpcy5wb3NpdGlvbkFicy5sZWZ0ICsgdGhpcy5vZmZzZXQuY2xpY2subGVmdCwgaXRlbS5sZWZ0LCBpdGVtLndpZHRoKSxcblx0XHRcdGlzT3ZlckVsZW1lbnQgPSBpc092ZXJFbGVtZW50SGVpZ2h0ICYmIGlzT3ZlckVsZW1lbnRXaWR0aCxcblx0XHRcdHZlcnRpY2FsRGlyZWN0aW9uID0gdGhpcy5fZ2V0RHJhZ1ZlcnRpY2FsRGlyZWN0aW9uKCksXG5cdFx0XHRob3Jpem9udGFsRGlyZWN0aW9uID0gdGhpcy5fZ2V0RHJhZ0hvcml6b250YWxEaXJlY3Rpb24oKTtcblxuXHRcdGlmICghaXNPdmVyRWxlbWVudClcblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdHJldHVybiB0aGlzLmZsb2F0aW5nID9cblx0XHRcdCggKChob3Jpem9udGFsRGlyZWN0aW9uICYmIGhvcml6b250YWxEaXJlY3Rpb24gPT0gXCJyaWdodFwiKSB8fCB2ZXJ0aWNhbERpcmVjdGlvbiA9PSBcImRvd25cIikgPyAyIDogMSApXG5cdFx0XHQ6ICggdmVydGljYWxEaXJlY3Rpb24gJiYgKHZlcnRpY2FsRGlyZWN0aW9uID09IFwiZG93blwiID8gMiA6IDEpICk7XG5cblx0fSxcblxuXHRfaW50ZXJzZWN0c1dpdGhTaWRlczogZnVuY3Rpb24oaXRlbSkge1xuXG5cdFx0dmFyIGlzT3ZlckJvdHRvbUhhbGYgPSAkLnVpLmlzT3ZlckF4aXModGhpcy5wb3NpdGlvbkFicy50b3AgKyB0aGlzLm9mZnNldC5jbGljay50b3AsIGl0ZW0udG9wICsgKGl0ZW0uaGVpZ2h0LzIpLCBpdGVtLmhlaWdodCksXG5cdFx0XHRpc092ZXJSaWdodEhhbGYgPSAkLnVpLmlzT3ZlckF4aXModGhpcy5wb3NpdGlvbkFicy5sZWZ0ICsgdGhpcy5vZmZzZXQuY2xpY2subGVmdCwgaXRlbS5sZWZ0ICsgKGl0ZW0ud2lkdGgvMiksIGl0ZW0ud2lkdGgpLFxuXHRcdFx0dmVydGljYWxEaXJlY3Rpb24gPSB0aGlzLl9nZXREcmFnVmVydGljYWxEaXJlY3Rpb24oKSxcblx0XHRcdGhvcml6b250YWxEaXJlY3Rpb24gPSB0aGlzLl9nZXREcmFnSG9yaXpvbnRhbERpcmVjdGlvbigpO1xuXG5cdFx0aWYgKHRoaXMuZmxvYXRpbmcgJiYgaG9yaXpvbnRhbERpcmVjdGlvbikge1xuXHRcdFx0cmV0dXJuICgoaG9yaXpvbnRhbERpcmVjdGlvbiA9PSBcInJpZ2h0XCIgJiYgaXNPdmVyUmlnaHRIYWxmKSB8fCAoaG9yaXpvbnRhbERpcmVjdGlvbiA9PSBcImxlZnRcIiAmJiAhaXNPdmVyUmlnaHRIYWxmKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB2ZXJ0aWNhbERpcmVjdGlvbiAmJiAoKHZlcnRpY2FsRGlyZWN0aW9uID09IFwiZG93blwiICYmIGlzT3ZlckJvdHRvbUhhbGYpIHx8ICh2ZXJ0aWNhbERpcmVjdGlvbiA9PSBcInVwXCIgJiYgIWlzT3ZlckJvdHRvbUhhbGYpKTtcblx0XHR9XG5cblx0fSxcblxuXHRfZ2V0RHJhZ1ZlcnRpY2FsRGlyZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGVsdGEgPSB0aGlzLnBvc2l0aW9uQWJzLnRvcCAtIHRoaXMubGFzdFBvc2l0aW9uQWJzLnRvcDtcblx0XHRyZXR1cm4gZGVsdGEgIT0gMCAmJiAoZGVsdGEgPiAwID8gXCJkb3duXCIgOiBcInVwXCIpO1xuXHR9LFxuXG5cdF9nZXREcmFnSG9yaXpvbnRhbERpcmVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRlbHRhID0gdGhpcy5wb3NpdGlvbkFicy5sZWZ0IC0gdGhpcy5sYXN0UG9zaXRpb25BYnMubGVmdDtcblx0XHRyZXR1cm4gZGVsdGEgIT0gMCAmJiAoZGVsdGEgPiAwID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpO1xuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dGhpcy5fcmVmcmVzaEl0ZW1zKGV2ZW50KTtcblx0XHR0aGlzLnJlZnJlc2hQb3NpdGlvbnMoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfY29ubmVjdFdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXHRcdHJldHVybiBvcHRpb25zLmNvbm5lY3RXaXRoLmNvbnN0cnVjdG9yID09IFN0cmluZ1xuXHRcdFx0PyBbb3B0aW9ucy5jb25uZWN0V2l0aF1cblx0XHRcdDogb3B0aW9ucy5jb25uZWN0V2l0aDtcblx0fSxcblxuXHRfZ2V0SXRlbXNBc2pRdWVyeTogZnVuY3Rpb24oY29ubmVjdGVkKSB7XG5cblx0XHR2YXIgaXRlbXMgPSBbXTtcblx0XHR2YXIgcXVlcmllcyA9IFtdO1xuXHRcdHZhciBjb25uZWN0V2l0aCA9IHRoaXMuX2Nvbm5lY3RXaXRoKCk7XG5cblx0XHRpZihjb25uZWN0V2l0aCAmJiBjb25uZWN0ZWQpIHtcblx0XHRcdGZvciAodmFyIGkgPSBjb25uZWN0V2l0aC5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG5cdFx0XHRcdHZhciBjdXIgPSAkKGNvbm5lY3RXaXRoW2ldKTtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IGN1ci5sZW5ndGggLSAxOyBqID49IDA7IGotLSl7XG5cdFx0XHRcdFx0dmFyIGluc3QgPSAkLmRhdGEoY3VyW2pdLCB0aGlzLndpZGdldE5hbWUpO1xuXHRcdFx0XHRcdGlmKGluc3QgJiYgaW5zdCAhPSB0aGlzICYmICFpbnN0Lm9wdGlvbnMuZGlzYWJsZWQpIHtcblx0XHRcdFx0XHRcdHF1ZXJpZXMucHVzaChbJC5pc0Z1bmN0aW9uKGluc3Qub3B0aW9ucy5pdGVtcykgPyBpbnN0Lm9wdGlvbnMuaXRlbXMuY2FsbChpbnN0LmVsZW1lbnQpIDogJChpbnN0Lm9wdGlvbnMuaXRlbXMsIGluc3QuZWxlbWVudCkubm90KFwiLnVpLXNvcnRhYmxlLWhlbHBlclwiKS5ub3QoJy51aS1zb3J0YWJsZS1wbGFjZWhvbGRlcicpLCBpbnN0XSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRxdWVyaWVzLnB1c2goWyQuaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMuaXRlbXMpID8gdGhpcy5vcHRpb25zLml0ZW1zLmNhbGwodGhpcy5lbGVtZW50LCBudWxsLCB7IG9wdGlvbnM6IHRoaXMub3B0aW9ucywgaXRlbTogdGhpcy5jdXJyZW50SXRlbSB9KSA6ICQodGhpcy5vcHRpb25zLml0ZW1zLCB0aGlzLmVsZW1lbnQpLm5vdChcIi51aS1zb3J0YWJsZS1oZWxwZXJcIikubm90KCcudWktc29ydGFibGUtcGxhY2Vob2xkZXInKSwgdGhpc10pO1xuXG5cdFx0Zm9yICh2YXIgaSA9IHF1ZXJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuXHRcdFx0cXVlcmllc1tpXVswXS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpdGVtcy5wdXNoKHRoaXMpO1xuXHRcdFx0fSk7XG5cdFx0fTtcblxuXHRcdHJldHVybiAkKGl0ZW1zKTtcblxuXHR9LFxuXG5cdF9yZW1vdmVDdXJyZW50c0Zyb21JdGVtczogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgbGlzdCA9IHRoaXMuY3VycmVudEl0ZW0uZmluZChcIjpkYXRhKFwiICsgdGhpcy53aWRnZXROYW1lICsgXCItaXRlbSlcIik7XG5cblx0XHR0aGlzLml0ZW1zID0gJC5ncmVwKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRmb3IgKHZhciBqPTA7IGogPCBsaXN0Lmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGlmKGxpc3Rbal0gPT0gaXRlbS5pdGVtWzBdKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9KTtcblxuXHR9LFxuXG5cdF9yZWZyZXNoSXRlbXM6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHR0aGlzLml0ZW1zID0gW107XG5cdFx0dGhpcy5jb250YWluZXJzID0gW3RoaXNdO1xuXHRcdHZhciBpdGVtcyA9IHRoaXMuaXRlbXM7XG5cdFx0dmFyIHF1ZXJpZXMgPSBbWyQuaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMuaXRlbXMpID8gdGhpcy5vcHRpb25zLml0ZW1zLmNhbGwodGhpcy5lbGVtZW50WzBdLCBldmVudCwgeyBpdGVtOiB0aGlzLmN1cnJlbnRJdGVtIH0pIDogJCh0aGlzLm9wdGlvbnMuaXRlbXMsIHRoaXMuZWxlbWVudCksIHRoaXNdXTtcblx0XHR2YXIgY29ubmVjdFdpdGggPSB0aGlzLl9jb25uZWN0V2l0aCgpO1xuXG5cdFx0aWYoY29ubmVjdFdpdGggJiYgdGhpcy5yZWFkeSkgeyAvL1Nob3VsZG4ndCBiZSBydW4gdGhlIGZpcnN0IHRpbWUgdGhyb3VnaCBkdWUgdG8gbWFzc2l2ZSBzbG93LWRvd25cblx0XHRcdGZvciAodmFyIGkgPSBjb25uZWN0V2l0aC5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG5cdFx0XHRcdHZhciBjdXIgPSAkKGNvbm5lY3RXaXRoW2ldKTtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IGN1ci5sZW5ndGggLSAxOyBqID49IDA7IGotLSl7XG5cdFx0XHRcdFx0dmFyIGluc3QgPSAkLmRhdGEoY3VyW2pdLCB0aGlzLndpZGdldE5hbWUpO1xuXHRcdFx0XHRcdGlmKGluc3QgJiYgaW5zdCAhPSB0aGlzICYmICFpbnN0Lm9wdGlvbnMuZGlzYWJsZWQpIHtcblx0XHRcdFx0XHRcdHF1ZXJpZXMucHVzaChbJC5pc0Z1bmN0aW9uKGluc3Qub3B0aW9ucy5pdGVtcykgPyBpbnN0Lm9wdGlvbnMuaXRlbXMuY2FsbChpbnN0LmVsZW1lbnRbMF0sIGV2ZW50LCB7IGl0ZW06IHRoaXMuY3VycmVudEl0ZW0gfSkgOiAkKGluc3Qub3B0aW9ucy5pdGVtcywgaW5zdC5lbGVtZW50KSwgaW5zdF0pO1xuXHRcdFx0XHRcdFx0dGhpcy5jb250YWluZXJzLnB1c2goaW5zdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gcXVlcmllcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIHRhcmdldERhdGEgPSBxdWVyaWVzW2ldWzFdO1xuXHRcdFx0dmFyIF9xdWVyaWVzID0gcXVlcmllc1tpXVswXTtcblxuXHRcdFx0Zm9yICh2YXIgaj0wLCBxdWVyaWVzTGVuZ3RoID0gX3F1ZXJpZXMubGVuZ3RoOyBqIDwgcXVlcmllc0xlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gJChfcXVlcmllc1tqXSk7XG5cblx0XHRcdFx0aXRlbS5kYXRhKHRoaXMud2lkZ2V0TmFtZSArICctaXRlbScsIHRhcmdldERhdGEpOyAvLyBEYXRhIGZvciB0YXJnZXQgY2hlY2tpbmcgKG1vdXNlIG1hbmFnZXIpXG5cblx0XHRcdFx0aXRlbXMucHVzaCh7XG5cdFx0XHRcdFx0aXRlbTogaXRlbSxcblx0XHRcdFx0XHRpbnN0YW5jZTogdGFyZ2V0RGF0YSxcblx0XHRcdFx0XHR3aWR0aDogMCwgaGVpZ2h0OiAwLFxuXHRcdFx0XHRcdGxlZnQ6IDAsIHRvcDogMFxuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0fTtcblxuXHR9LFxuXG5cdHJlZnJlc2hQb3NpdGlvbnM6IGZ1bmN0aW9uKGZhc3QpIHtcblxuXHRcdC8vVGhpcyBoYXMgdG8gYmUgcmVkb25lIGJlY2F1c2UgZHVlIHRvIHRoZSBpdGVtIGJlaW5nIG1vdmVkIG91dC9pbnRvIHRoZSBvZmZzZXRQYXJlbnQsIHRoZSBvZmZzZXRQYXJlbnQncyBwb3NpdGlvbiB3aWxsIGNoYW5nZVxuXHRcdGlmKHRoaXMub2Zmc2V0UGFyZW50ICYmIHRoaXMuaGVscGVyKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5wYXJlbnQgPSB0aGlzLl9nZXRQYXJlbnRPZmZzZXQoKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gdGhpcy5pdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG5cdFx0XHR2YXIgaXRlbSA9IHRoaXMuaXRlbXNbaV07XG5cblx0XHRcdC8vV2UgaWdub3JlIGNhbGN1bGF0aW5nIHBvc2l0aW9ucyBvZiBhbGwgY29ubmVjdGVkIGNvbnRhaW5lcnMgd2hlbiB3ZSdyZSBub3Qgb3ZlciB0aGVtXG5cdFx0XHRpZihpdGVtLmluc3RhbmNlICE9IHRoaXMuY3VycmVudENvbnRhaW5lciAmJiB0aGlzLmN1cnJlbnRDb250YWluZXIgJiYgaXRlbS5pdGVtWzBdICE9IHRoaXMuY3VycmVudEl0ZW1bMF0pXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgdCA9IHRoaXMub3B0aW9ucy50b2xlcmFuY2VFbGVtZW50ID8gJCh0aGlzLm9wdGlvbnMudG9sZXJhbmNlRWxlbWVudCwgaXRlbS5pdGVtKSA6IGl0ZW0uaXRlbTtcblxuXHRcdFx0aWYgKCFmYXN0KSB7XG5cdFx0XHRcdGl0ZW0ud2lkdGggPSB0Lm91dGVyV2lkdGgoKTtcblx0XHRcdFx0aXRlbS5oZWlnaHQgPSB0Lm91dGVySGVpZ2h0KCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBwID0gdC5vZmZzZXQoKTtcblx0XHRcdGl0ZW0ubGVmdCA9IHAubGVmdDtcblx0XHRcdGl0ZW0udG9wID0gcC50b3A7XG5cdFx0fTtcblxuXHRcdGlmKHRoaXMub3B0aW9ucy5jdXN0b20gJiYgdGhpcy5vcHRpb25zLmN1c3RvbS5yZWZyZXNoQ29udGFpbmVycykge1xuXHRcdFx0dGhpcy5vcHRpb25zLmN1c3RvbS5yZWZyZXNoQ29udGFpbmVycy5jYWxsKHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKHZhciBpID0gdGhpcy5jb250YWluZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcblx0XHRcdFx0dmFyIHAgPSB0aGlzLmNvbnRhaW5lcnNbaV0uZWxlbWVudC5vZmZzZXQoKTtcblx0XHRcdFx0dGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlLmxlZnQgPSBwLmxlZnQ7XG5cdFx0XHRcdHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZS50b3AgPSBwLnRvcDtcblx0XHRcdFx0dGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlLndpZHRoXHQ9IHRoaXMuY29udGFpbmVyc1tpXS5lbGVtZW50Lm91dGVyV2lkdGgoKTtcblx0XHRcdFx0dGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlLmhlaWdodCA9IHRoaXMuY29udGFpbmVyc1tpXS5lbGVtZW50Lm91dGVySGVpZ2h0KCk7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9jcmVhdGVQbGFjZWhvbGRlcjogZnVuY3Rpb24odGhhdCkge1xuXHRcdHRoYXQgPSB0aGF0IHx8IHRoaXM7XG5cdFx0dmFyIG8gPSB0aGF0Lm9wdGlvbnM7XG5cblx0XHRpZighby5wbGFjZWhvbGRlciB8fCBvLnBsYWNlaG9sZGVyLmNvbnN0cnVjdG9yID09IFN0cmluZykge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IG8ucGxhY2Vob2xkZXI7XG5cdFx0XHRvLnBsYWNlaG9sZGVyID0ge1xuXHRcdFx0XHRlbGVtZW50OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdHZhciBlbCA9ICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGF0LmN1cnJlbnRJdGVtWzBdLm5vZGVOYW1lKSlcblx0XHRcdFx0XHRcdC5hZGRDbGFzcyhjbGFzc05hbWUgfHwgdGhhdC5jdXJyZW50SXRlbVswXS5jbGFzc05hbWUrXCIgdWktc29ydGFibGUtcGxhY2Vob2xkZXJcIilcblx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyhcInVpLXNvcnRhYmxlLWhlbHBlclwiKVswXTtcblxuXHRcdFx0XHRcdGlmKCFjbGFzc05hbWUpXG5cdFx0XHRcdFx0XHRlbC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcblxuXHRcdFx0XHRcdHJldHVybiBlbDtcblx0XHRcdFx0fSxcblx0XHRcdFx0dXBkYXRlOiBmdW5jdGlvbihjb250YWluZXIsIHApIHtcblxuXHRcdFx0XHRcdC8vIDEuIElmIGEgY2xhc3NOYW1lIGlzIHNldCBhcyAncGxhY2Vob2xkZXIgb3B0aW9uLCB3ZSBkb24ndCBmb3JjZSBzaXplcyAtIHRoZSBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgdGhhdFxuXHRcdFx0XHRcdC8vIDIuIFRoZSBvcHRpb24gJ2ZvcmNlUGxhY2Vob2xkZXJTaXplIGNhbiBiZSBlbmFibGVkIHRvIGZvcmNlIGl0IGV2ZW4gaWYgYSBjbGFzcyBuYW1lIGlzIHNwZWNpZmllZFxuXHRcdFx0XHRcdGlmKGNsYXNzTmFtZSAmJiAhby5mb3JjZVBsYWNlaG9sZGVyU2l6ZSkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0Ly9JZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYSBhY3R1YWwgaGVpZ2h0IGJ5IGl0c2VsZiAod2l0aG91dCBzdHlsZXMgY29taW5nIGZyb20gYSBzdHlsZXNoZWV0KSwgaXQgcmVjZWl2ZXMgdGhlIGlubGluZSBoZWlnaHQgZnJvbSB0aGUgZHJhZ2dlZCBpdGVtXG5cdFx0XHRcdFx0aWYoIXAuaGVpZ2h0KCkpIHsgcC5oZWlnaHQodGhhdC5jdXJyZW50SXRlbS5pbm5lckhlaWdodCgpIC0gcGFyc2VJbnQodGhhdC5jdXJyZW50SXRlbS5jc3MoJ3BhZGRpbmdUb3AnKXx8MCwgMTApIC0gcGFyc2VJbnQodGhhdC5jdXJyZW50SXRlbS5jc3MoJ3BhZGRpbmdCb3R0b20nKXx8MCwgMTApKTsgfTtcblx0XHRcdFx0XHRpZighcC53aWR0aCgpKSB7IHAud2lkdGgodGhhdC5jdXJyZW50SXRlbS5pbm5lcldpZHRoKCkgLSBwYXJzZUludCh0aGF0LmN1cnJlbnRJdGVtLmNzcygncGFkZGluZ0xlZnQnKXx8MCwgMTApIC0gcGFyc2VJbnQodGhhdC5jdXJyZW50SXRlbS5jc3MoJ3BhZGRpbmdSaWdodCcpfHwwLCAxMCkpOyB9O1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vQ3JlYXRlIHRoZSBwbGFjZWhvbGRlclxuXHRcdHRoYXQucGxhY2Vob2xkZXIgPSAkKG8ucGxhY2Vob2xkZXIuZWxlbWVudC5jYWxsKHRoYXQuZWxlbWVudCwgdGhhdC5jdXJyZW50SXRlbSkpO1xuXG5cdFx0Ly9BcHBlbmQgaXQgYWZ0ZXIgdGhlIGFjdHVhbCBjdXJyZW50IGl0ZW1cblx0XHR0aGF0LmN1cnJlbnRJdGVtLmFmdGVyKHRoYXQucGxhY2Vob2xkZXIpO1xuXG5cdFx0Ly9VcGRhdGUgdGhlIHNpemUgb2YgdGhlIHBsYWNlaG9sZGVyIChUT0RPOiBMb2dpYyB0byBmdXp6eSwgc2VlIGxpbmUgMzE2LzMxNylcblx0XHRvLnBsYWNlaG9sZGVyLnVwZGF0ZSh0aGF0LCB0aGF0LnBsYWNlaG9sZGVyKTtcblxuXHR9LFxuXG5cdF9jb250YWN0Q29udGFpbmVyczogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdC8vIGdldCBpbm5lcm1vc3QgY29udGFpbmVyIHRoYXQgaW50ZXJzZWN0cyB3aXRoIGl0ZW1cblx0XHR2YXIgaW5uZXJtb3N0Q29udGFpbmVyID0gbnVsbCwgaW5uZXJtb3N0SW5kZXggPSBudWxsO1xuXG5cblx0XHRmb3IgKHZhciBpID0gdGhpcy5jb250YWluZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcblxuXHRcdFx0Ly8gbmV2ZXIgY29uc2lkZXIgYSBjb250YWluZXIgdGhhdCdzIGxvY2F0ZWQgd2l0aGluIHRoZSBpdGVtIGl0c2VsZlxuXHRcdFx0aWYoJC5jb250YWlucyh0aGlzLmN1cnJlbnRJdGVtWzBdLCB0aGlzLmNvbnRhaW5lcnNbaV0uZWxlbWVudFswXSkpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRpZih0aGlzLl9pbnRlcnNlY3RzV2l0aCh0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUpKSB7XG5cblx0XHRcdFx0Ly8gaWYgd2UndmUgYWxyZWFkeSBmb3VuZCBhIGNvbnRhaW5lciBhbmQgaXQncyBtb3JlIFwiaW5uZXJcIiB0aGFuIHRoaXMsIHRoZW4gY29udGludWVcblx0XHRcdFx0aWYoaW5uZXJtb3N0Q29udGFpbmVyICYmICQuY29udGFpbnModGhpcy5jb250YWluZXJzW2ldLmVsZW1lbnRbMF0sIGlubmVybW9zdENvbnRhaW5lci5lbGVtZW50WzBdKSlcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRpbm5lcm1vc3RDb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcnNbaV07XG5cdFx0XHRcdGlubmVybW9zdEluZGV4ID0gaTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gY29udGFpbmVyIGRvZXNuJ3QgaW50ZXJzZWN0LiB0cmlnZ2VyIFwib3V0XCIgZXZlbnQgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdGlmKHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZS5vdmVyKSB7XG5cdFx0XHRcdFx0dGhpcy5jb250YWluZXJzW2ldLl90cmlnZ2VyKFwib3V0XCIsIGV2ZW50LCB0aGlzLl91aUhhc2godGhpcykpO1xuXHRcdFx0XHRcdHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZS5vdmVyID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gaWYgbm8gaW50ZXJzZWN0aW5nIGNvbnRhaW5lcnMgZm91bmQsIHJldHVyblxuXHRcdGlmKCFpbm5lcm1vc3RDb250YWluZXIpIHJldHVybjtcblxuXHRcdC8vIG1vdmUgdGhlIGl0ZW0gaW50byB0aGUgY29udGFpbmVyIGlmIGl0J3Mgbm90IHRoZXJlIGFscmVhZHlcblx0XHRpZih0aGlzLmNvbnRhaW5lcnMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLl90cmlnZ2VyKFwib3ZlclwiLCBldmVudCwgdGhpcy5fdWlIYXNoKHRoaXMpKTtcblx0XHRcdHRoaXMuY29udGFpbmVyc1tpbm5lcm1vc3RJbmRleF0uY29udGFpbmVyQ2FjaGUub3ZlciA9IDE7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly9XaGVuIGVudGVyaW5nIGEgbmV3IGNvbnRhaW5lciwgd2Ugd2lsbCBmaW5kIHRoZSBpdGVtIHdpdGggdGhlIGxlYXN0IGRpc3RhbmNlIGFuZCBhcHBlbmQgb3VyIGl0ZW0gbmVhciBpdFxuXHRcdFx0dmFyIGRpc3QgPSAxMDAwMDsgdmFyIGl0ZW1XaXRoTGVhc3REaXN0YW5jZSA9IG51bGw7XG5cdFx0XHR2YXIgcG9zUHJvcGVydHkgPSB0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLmZsb2F0aW5nID8gJ2xlZnQnIDogJ3RvcCc7XG5cdFx0XHR2YXIgc2l6ZVByb3BlcnR5ID0gdGhpcy5jb250YWluZXJzW2lubmVybW9zdEluZGV4XS5mbG9hdGluZyA/ICd3aWR0aCcgOiAnaGVpZ2h0Jztcblx0XHRcdHZhciBiYXNlID0gdGhpcy5wb3NpdGlvbkFic1twb3NQcm9wZXJ0eV0gKyB0aGlzLm9mZnNldC5jbGlja1twb3NQcm9wZXJ0eV07XG5cdFx0XHRmb3IgKHZhciBqID0gdGhpcy5pdGVtcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHRpZighJC5jb250YWlucyh0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLmVsZW1lbnRbMF0sIHRoaXMuaXRlbXNbal0uaXRlbVswXSkpIGNvbnRpbnVlO1xuXHRcdFx0XHRpZih0aGlzLml0ZW1zW2pdLml0ZW1bMF0gPT0gdGhpcy5jdXJyZW50SXRlbVswXSkgY29udGludWU7XG5cdFx0XHRcdHZhciBjdXIgPSB0aGlzLml0ZW1zW2pdLml0ZW0ub2Zmc2V0KClbcG9zUHJvcGVydHldO1xuXHRcdFx0XHR2YXIgbmVhckJvdHRvbSA9IGZhbHNlO1xuXHRcdFx0XHRpZihNYXRoLmFicyhjdXIgLSBiYXNlKSA+IE1hdGguYWJzKGN1ciArIHRoaXMuaXRlbXNbal1bc2l6ZVByb3BlcnR5XSAtIGJhc2UpKXtcblx0XHRcdFx0XHRuZWFyQm90dG9tID0gdHJ1ZTtcblx0XHRcdFx0XHRjdXIgKz0gdGhpcy5pdGVtc1tqXVtzaXplUHJvcGVydHldO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYoTWF0aC5hYnMoY3VyIC0gYmFzZSkgPCBkaXN0KSB7XG5cdFx0XHRcdFx0ZGlzdCA9IE1hdGguYWJzKGN1ciAtIGJhc2UpOyBpdGVtV2l0aExlYXN0RGlzdGFuY2UgPSB0aGlzLml0ZW1zW2pdO1xuXHRcdFx0XHRcdHRoaXMuZGlyZWN0aW9uID0gbmVhckJvdHRvbSA/IFwidXBcIjogXCJkb3duXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYoIWl0ZW1XaXRoTGVhc3REaXN0YW5jZSAmJiAhdGhpcy5vcHRpb25zLmRyb3BPbkVtcHR5KSAvL0NoZWNrIGlmIGRyb3BPbkVtcHR5IGlzIGVuYWJsZWRcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR0aGlzLmN1cnJlbnRDb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdO1xuXHRcdFx0aXRlbVdpdGhMZWFzdERpc3RhbmNlID8gdGhpcy5fcmVhcnJhbmdlKGV2ZW50LCBpdGVtV2l0aExlYXN0RGlzdGFuY2UsIG51bGwsIHRydWUpIDogdGhpcy5fcmVhcnJhbmdlKGV2ZW50LCBudWxsLCB0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLmVsZW1lbnQsIHRydWUpO1xuXHRcdFx0dGhpcy5fdHJpZ2dlcihcImNoYW5nZVwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkpO1xuXHRcdFx0dGhpcy5jb250YWluZXJzW2lubmVybW9zdEluZGV4XS5fdHJpZ2dlcihcImNoYW5nZVwiLCBldmVudCwgdGhpcy5fdWlIYXNoKHRoaXMpKTtcblxuXHRcdFx0Ly9VcGRhdGUgdGhlIHBsYWNlaG9sZGVyXG5cdFx0XHR0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIudXBkYXRlKHRoaXMuY3VycmVudENvbnRhaW5lciwgdGhpcy5wbGFjZWhvbGRlcik7XG5cblx0XHRcdHRoaXMuY29udGFpbmVyc1tpbm5lcm1vc3RJbmRleF0uX3RyaWdnZXIoXCJvdmVyXCIsIGV2ZW50LCB0aGlzLl91aUhhc2godGhpcykpO1xuXHRcdFx0dGhpcy5jb250YWluZXJzW2lubmVybW9zdEluZGV4XS5jb250YWluZXJDYWNoZS5vdmVyID0gMTtcblx0XHR9XG5cblxuXHR9LFxuXG5cdF9jcmVhdGVIZWxwZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucztcblx0XHR2YXIgaGVscGVyID0gJC5pc0Z1bmN0aW9uKG8uaGVscGVyKSA/ICQoby5oZWxwZXIuYXBwbHkodGhpcy5lbGVtZW50WzBdLCBbZXZlbnQsIHRoaXMuY3VycmVudEl0ZW1dKSkgOiAoby5oZWxwZXIgPT0gJ2Nsb25lJyA/IHRoaXMuY3VycmVudEl0ZW0uY2xvbmUoKSA6IHRoaXMuY3VycmVudEl0ZW0pO1xuXG5cdFx0aWYoIWhlbHBlci5wYXJlbnRzKCdib2R5JykubGVuZ3RoKSAvL0FkZCB0aGUgaGVscGVyIHRvIHRoZSBET00gaWYgdGhhdCBkaWRuJ3QgaGFwcGVuIGFscmVhZHlcblx0XHRcdCQoby5hcHBlbmRUbyAhPSAncGFyZW50JyA/IG8uYXBwZW5kVG8gOiB0aGlzLmN1cnJlbnRJdGVtWzBdLnBhcmVudE5vZGUpWzBdLmFwcGVuZENoaWxkKGhlbHBlclswXSk7XG5cblx0XHRpZihoZWxwZXJbMF0gPT0gdGhpcy5jdXJyZW50SXRlbVswXSlcblx0XHRcdHRoaXMuX3N0b3JlZENTUyA9IHsgd2lkdGg6IHRoaXMuY3VycmVudEl0ZW1bMF0uc3R5bGUud2lkdGgsIGhlaWdodDogdGhpcy5jdXJyZW50SXRlbVswXS5zdHlsZS5oZWlnaHQsIHBvc2l0aW9uOiB0aGlzLmN1cnJlbnRJdGVtLmNzcyhcInBvc2l0aW9uXCIpLCB0b3A6IHRoaXMuY3VycmVudEl0ZW0uY3NzKFwidG9wXCIpLCBsZWZ0OiB0aGlzLmN1cnJlbnRJdGVtLmNzcyhcImxlZnRcIikgfTtcblxuXHRcdGlmKGhlbHBlclswXS5zdHlsZS53aWR0aCA9PSAnJyB8fCBvLmZvcmNlSGVscGVyU2l6ZSkgaGVscGVyLndpZHRoKHRoaXMuY3VycmVudEl0ZW0ud2lkdGgoKSk7XG5cdFx0aWYoaGVscGVyWzBdLnN0eWxlLmhlaWdodCA9PSAnJyB8fCBvLmZvcmNlSGVscGVyU2l6ZSkgaGVscGVyLmhlaWdodCh0aGlzLmN1cnJlbnRJdGVtLmhlaWdodCgpKTtcblxuXHRcdHJldHVybiBoZWxwZXI7XG5cblx0fSxcblxuXHRfYWRqdXN0T2Zmc2V0RnJvbUhlbHBlcjogZnVuY3Rpb24ob2JqKSB7XG5cdFx0aWYgKHR5cGVvZiBvYmogPT0gJ3N0cmluZycpIHtcblx0XHRcdG9iaiA9IG9iai5zcGxpdCgnICcpO1xuXHRcdH1cblx0XHRpZiAoJC5pc0FycmF5KG9iaikpIHtcblx0XHRcdG9iaiA9IHtsZWZ0OiArb2JqWzBdLCB0b3A6ICtvYmpbMV0gfHwgMH07XG5cdFx0fVxuXHRcdGlmICgnbGVmdCcgaW4gb2JqKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5jbGljay5sZWZ0ID0gb2JqLmxlZnQgKyB0aGlzLm1hcmdpbnMubGVmdDtcblx0XHR9XG5cdFx0aWYgKCdyaWdodCcgaW4gb2JqKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5jbGljay5sZWZ0ID0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIG9iai5yaWdodCArIHRoaXMubWFyZ2lucy5sZWZ0O1xuXHRcdH1cblx0XHRpZiAoJ3RvcCcgaW4gb2JqKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5jbGljay50b3AgPSBvYmoudG9wICsgdGhpcy5tYXJnaW5zLnRvcDtcblx0XHR9XG5cdFx0aWYgKCdib3R0b20nIGluIG9iaikge1xuXHRcdFx0dGhpcy5vZmZzZXQuY2xpY2sudG9wID0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSBvYmouYm90dG9tICsgdGhpcy5tYXJnaW5zLnRvcDtcblx0XHR9XG5cdH0sXG5cblx0X2dldFBhcmVudE9mZnNldDogZnVuY3Rpb24oKSB7XG5cblxuXHRcdC8vR2V0IHRoZSBvZmZzZXRQYXJlbnQgYW5kIGNhY2hlIGl0cyBwb3NpdGlvblxuXHRcdHRoaXMub2Zmc2V0UGFyZW50ID0gdGhpcy5oZWxwZXIub2Zmc2V0UGFyZW50KCk7XG5cdFx0dmFyIHBvID0gdGhpcy5vZmZzZXRQYXJlbnQub2Zmc2V0KCk7XG5cblx0XHQvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIHdoZXJlIHdlIG5lZWQgdG8gbW9kaWZ5IGEgb2Zmc2V0IGNhbGN1bGF0ZWQgb24gc3RhcnQsIHNpbmNlIHRoZSBmb2xsb3dpbmcgaGFwcGVuZWQ6XG5cdFx0Ly8gMS4gVGhlIHBvc2l0aW9uIG9mIHRoZSBoZWxwZXIgaXMgYWJzb2x1dGUsIHNvIGl0J3MgcG9zaXRpb24gaXMgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgbmV4dCBwb3NpdGlvbmVkIHBhcmVudFxuXHRcdC8vIDIuIFRoZSBhY3R1YWwgb2Zmc2V0IHBhcmVudCBpcyBhIGNoaWxkIG9mIHRoZSBzY3JvbGwgcGFyZW50LCBhbmQgdGhlIHNjcm9sbCBwYXJlbnQgaXNuJ3QgdGhlIGRvY3VtZW50LCB3aGljaCBtZWFucyB0aGF0XG5cdFx0Ly8gICAgdGhlIHNjcm9sbCBpcyBpbmNsdWRlZCBpbiB0aGUgaW5pdGlhbCBjYWxjdWxhdGlvbiBvZiB0aGUgb2Zmc2V0IG9mIHRoZSBwYXJlbnQsIGFuZCBuZXZlciByZWNhbGN1bGF0ZWQgdXBvbiBkcmFnXG5cdFx0aWYodGhpcy5jc3NQb3NpdGlvbiA9PSAnYWJzb2x1dGUnICYmIHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9IGRvY3VtZW50ICYmICQuY29udGFpbnModGhpcy5zY3JvbGxQYXJlbnRbMF0sIHRoaXMub2Zmc2V0UGFyZW50WzBdKSkge1xuXHRcdFx0cG8ubGVmdCArPSB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCk7XG5cdFx0XHRwby50b3AgKz0gdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCk7XG5cdFx0fVxuXG5cdFx0aWYoKHRoaXMub2Zmc2V0UGFyZW50WzBdID09IGRvY3VtZW50LmJvZHkpIC8vVGhpcyBuZWVkcyB0byBiZSBhY3R1YWxseSBkb25lIGZvciBhbGwgYnJvd3NlcnMsIHNpbmNlIHBhZ2VYL3BhZ2VZIGluY2x1ZGVzIHRoaXMgaW5mb3JtYXRpb25cblx0XHR8fCAodGhpcy5vZmZzZXRQYXJlbnRbMF0udGFnTmFtZSAmJiB0aGlzLm9mZnNldFBhcmVudFswXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ2h0bWwnICYmICQudWkuaWUpKSAvL1VnbHkgSUUgZml4XG5cdFx0XHRwbyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBwby50b3AgKyAocGFyc2VJbnQodGhpcy5vZmZzZXRQYXJlbnQuY3NzKFwiYm9yZGVyVG9wV2lkdGhcIiksMTApIHx8IDApLFxuXHRcdFx0bGVmdDogcG8ubGVmdCArIChwYXJzZUludCh0aGlzLm9mZnNldFBhcmVudC5jc3MoXCJib3JkZXJMZWZ0V2lkdGhcIiksMTApIHx8IDApXG5cdFx0fTtcblxuXHR9LFxuXG5cdF9nZXRSZWxhdGl2ZU9mZnNldDogZnVuY3Rpb24oKSB7XG5cblx0XHRpZih0aGlzLmNzc1Bvc2l0aW9uID09IFwicmVsYXRpdmVcIikge1xuXHRcdFx0dmFyIHAgPSB0aGlzLmN1cnJlbnRJdGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0b3A6IHAudG9wIC0gKHBhcnNlSW50KHRoaXMuaGVscGVyLmNzcyhcInRvcFwiKSwxMCkgfHwgMCkgKyB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKSxcblx0XHRcdFx0bGVmdDogcC5sZWZ0IC0gKHBhcnNlSW50KHRoaXMuaGVscGVyLmNzcyhcImxlZnRcIiksMTApIHx8IDApICsgdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCgpXG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0fSxcblxuXHRfY2FjaGVNYXJnaW5zOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLm1hcmdpbnMgPSB7XG5cdFx0XHRsZWZ0OiAocGFyc2VJbnQodGhpcy5jdXJyZW50SXRlbS5jc3MoXCJtYXJnaW5MZWZ0XCIpLDEwKSB8fCAwKSxcblx0XHRcdHRvcDogKHBhcnNlSW50KHRoaXMuY3VycmVudEl0ZW0uY3NzKFwibWFyZ2luVG9wXCIpLDEwKSB8fCAwKVxuXHRcdH07XG5cdH0sXG5cblx0X2NhY2hlSGVscGVyUHJvcG9ydGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGVscGVyUHJvcG9ydGlvbnMgPSB7XG5cdFx0XHR3aWR0aDogdGhpcy5oZWxwZXIub3V0ZXJXaWR0aCgpLFxuXHRcdFx0aGVpZ2h0OiB0aGlzLmhlbHBlci5vdXRlckhlaWdodCgpXG5cdFx0fTtcblx0fSxcblxuXHRfc2V0Q29udGFpbm1lbnQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnM7XG5cdFx0aWYoby5jb250YWlubWVudCA9PSAncGFyZW50Jykgby5jb250YWlubWVudCA9IHRoaXMuaGVscGVyWzBdLnBhcmVudE5vZGU7XG5cdFx0aWYoby5jb250YWlubWVudCA9PSAnZG9jdW1lbnQnIHx8IG8uY29udGFpbm1lbnQgPT0gJ3dpbmRvdycpIHRoaXMuY29udGFpbm1lbnQgPSBbXG5cdFx0XHQwIC0gdGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdCAtIHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0LFxuXHRcdFx0MCAtIHRoaXMub2Zmc2V0LnJlbGF0aXZlLnRvcCAtIHRoaXMub2Zmc2V0LnBhcmVudC50b3AsXG5cdFx0XHQkKG8uY29udGFpbm1lbnQgPT0gJ2RvY3VtZW50JyA/IGRvY3VtZW50IDogd2luZG93KS53aWR0aCgpIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIHRoaXMubWFyZ2lucy5sZWZ0LFxuXHRcdFx0KCQoby5jb250YWlubWVudCA9PSAnZG9jdW1lbnQnID8gZG9jdW1lbnQgOiB3aW5kb3cpLmhlaWdodCgpIHx8IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZS5zY3JvbGxIZWlnaHQpIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wXG5cdFx0XTtcblxuXHRcdGlmKCEoL14oZG9jdW1lbnR8d2luZG93fHBhcmVudCkkLykudGVzdChvLmNvbnRhaW5tZW50KSkge1xuXHRcdFx0dmFyIGNlID0gJChvLmNvbnRhaW5tZW50KVswXTtcblx0XHRcdHZhciBjbyA9ICQoby5jb250YWlubWVudCkub2Zmc2V0KCk7XG5cdFx0XHR2YXIgb3ZlciA9ICgkKGNlKS5jc3MoXCJvdmVyZmxvd1wiKSAhPSAnaGlkZGVuJyk7XG5cblx0XHRcdHRoaXMuY29udGFpbm1lbnQgPSBbXG5cdFx0XHRcdGNvLmxlZnQgKyAocGFyc2VJbnQoJChjZSkuY3NzKFwiYm9yZGVyTGVmdFdpZHRoXCIpLDEwKSB8fCAwKSArIChwYXJzZUludCgkKGNlKS5jc3MoXCJwYWRkaW5nTGVmdFwiKSwxMCkgfHwgMCkgLSB0aGlzLm1hcmdpbnMubGVmdCxcblx0XHRcdFx0Y28udG9wICsgKHBhcnNlSW50KCQoY2UpLmNzcyhcImJvcmRlclRvcFdpZHRoXCIpLDEwKSB8fCAwKSArIChwYXJzZUludCgkKGNlKS5jc3MoXCJwYWRkaW5nVG9wXCIpLDEwKSB8fCAwKSAtIHRoaXMubWFyZ2lucy50b3AsXG5cdFx0XHRcdGNvLmxlZnQrKG92ZXIgPyBNYXRoLm1heChjZS5zY3JvbGxXaWR0aCxjZS5vZmZzZXRXaWR0aCkgOiBjZS5vZmZzZXRXaWR0aCkgLSAocGFyc2VJbnQoJChjZSkuY3NzKFwiYm9yZGVyTGVmdFdpZHRoXCIpLDEwKSB8fCAwKSAtIChwYXJzZUludCgkKGNlKS5jc3MoXCJwYWRkaW5nUmlnaHRcIiksMTApIHx8IDApIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIHRoaXMubWFyZ2lucy5sZWZ0LFxuXHRcdFx0XHRjby50b3ArKG92ZXIgPyBNYXRoLm1heChjZS5zY3JvbGxIZWlnaHQsY2Uub2Zmc2V0SGVpZ2h0KSA6IGNlLm9mZnNldEhlaWdodCkgLSAocGFyc2VJbnQoJChjZSkuY3NzKFwiYm9yZGVyVG9wV2lkdGhcIiksMTApIHx8IDApIC0gKHBhcnNlSW50KCQoY2UpLmNzcyhcInBhZGRpbmdCb3R0b21cIiksMTApIHx8IDApIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wXG5cdFx0XHRdO1xuXHRcdH1cblxuXHR9LFxuXG5cdF9jb252ZXJ0UG9zaXRpb25UbzogZnVuY3Rpb24oZCwgcG9zKSB7XG5cblx0XHRpZighcG9zKSBwb3MgPSB0aGlzLnBvc2l0aW9uO1xuXHRcdHZhciBtb2QgPSBkID09IFwiYWJzb2x1dGVcIiA/IDEgOiAtMTtcblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucywgc2Nyb2xsID0gdGhpcy5jc3NQb3NpdGlvbiA9PSAnYWJzb2x1dGUnICYmICEodGhpcy5zY3JvbGxQYXJlbnRbMF0gIT0gZG9jdW1lbnQgJiYgJC5jb250YWlucyh0aGlzLnNjcm9sbFBhcmVudFswXSwgdGhpcy5vZmZzZXRQYXJlbnRbMF0pKSA/IHRoaXMub2Zmc2V0UGFyZW50IDogdGhpcy5zY3JvbGxQYXJlbnQsIHNjcm9sbElzUm9vdE5vZGUgPSAoLyhodG1sfGJvZHkpL2kpLnRlc3Qoc2Nyb2xsWzBdLnRhZ05hbWUpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogKFxuXHRcdFx0XHRwb3MudG9wXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxuXHRcdFx0XHQrIHRoaXMub2Zmc2V0LnJlbGF0aXZlLnRvcCAqIG1vZFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBub2RlczogUmVsYXRpdmUgb2Zmc2V0IGZyb20gZWxlbWVudCB0byBvZmZzZXQgcGFyZW50XG5cdFx0XHRcdCsgdGhpcy5vZmZzZXQucGFyZW50LnRvcCAqIG1vZFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxuXHRcdFx0XHQtICggKCB0aGlzLmNzc1Bvc2l0aW9uID09ICdmaXhlZCcgPyAtdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCkgOiAoIHNjcm9sbElzUm9vdE5vZGUgPyAwIDogc2Nyb2xsLnNjcm9sbFRvcCgpICkgKSAqIG1vZClcblx0XHRcdCksXG5cdFx0XHRsZWZ0OiAoXG5cdFx0XHRcdHBvcy5sZWZ0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cblx0XHRcdFx0KyB0aGlzLm9mZnNldC5yZWxhdGl2ZS5sZWZ0ICogbW9kXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcblx0XHRcdFx0KyB0aGlzLm9mZnNldC5wYXJlbnQubGVmdCAqIG1vZFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxuXHRcdFx0XHQtICggKCB0aGlzLmNzc1Bvc2l0aW9uID09ICdmaXhlZCcgPyAtdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCgpIDogc2Nyb2xsSXNSb290Tm9kZSA/IDAgOiBzY3JvbGwuc2Nyb2xsTGVmdCgpICkgKiBtb2QpXG5cdFx0XHQpXG5cdFx0fTtcblxuXHR9LFxuXG5cdF9nZW5lcmF0ZVBvc2l0aW9uOiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnMsIHNjcm9sbCA9IHRoaXMuY3NzUG9zaXRpb24gPT0gJ2Fic29sdXRlJyAmJiAhKHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9IGRvY3VtZW50ICYmICQuY29udGFpbnModGhpcy5zY3JvbGxQYXJlbnRbMF0sIHRoaXMub2Zmc2V0UGFyZW50WzBdKSkgPyB0aGlzLm9mZnNldFBhcmVudCA6IHRoaXMuc2Nyb2xsUGFyZW50LCBzY3JvbGxJc1Jvb3ROb2RlID0gKC8oaHRtbHxib2R5KS9pKS50ZXN0KHNjcm9sbFswXS50YWdOYW1lKTtcblxuXHRcdC8vIFRoaXMgaXMgYW5vdGhlciB2ZXJ5IHdlaXJkIHNwZWNpYWwgY2FzZSB0aGF0IG9ubHkgaGFwcGVucyBmb3IgcmVsYXRpdmUgZWxlbWVudHM6XG5cdFx0Ly8gMS4gSWYgdGhlIGNzcyBwb3NpdGlvbiBpcyByZWxhdGl2ZVxuXHRcdC8vIDIuIGFuZCB0aGUgc2Nyb2xsIHBhcmVudCBpcyB0aGUgZG9jdW1lbnQgb3Igc2ltaWxhciB0byB0aGUgb2Zmc2V0IHBhcmVudFxuXHRcdC8vIHdlIGhhdmUgdG8gcmVmcmVzaCB0aGUgcmVsYXRpdmUgb2Zmc2V0IGR1cmluZyB0aGUgc2Nyb2xsIHNvIHRoZXJlIGFyZSBubyBqdW1wc1xuXHRcdGlmKHRoaXMuY3NzUG9zaXRpb24gPT0gJ3JlbGF0aXZlJyAmJiAhKHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9IGRvY3VtZW50ICYmIHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9IHRoaXMub2Zmc2V0UGFyZW50WzBdKSkge1xuXHRcdFx0dGhpcy5vZmZzZXQucmVsYXRpdmUgPSB0aGlzLl9nZXRSZWxhdGl2ZU9mZnNldCgpO1xuXHRcdH1cblxuXHRcdHZhciBwYWdlWCA9IGV2ZW50LnBhZ2VYO1xuXHRcdHZhciBwYWdlWSA9IGV2ZW50LnBhZ2VZO1xuXG5cdFx0Lypcblx0XHQgKiAtIFBvc2l0aW9uIGNvbnN0cmFpbmluZyAtXG5cdFx0ICogQ29uc3RyYWluIHRoZSBwb3NpdGlvbiB0byBhIG1peCBvZiBncmlkLCBjb250YWlubWVudC5cblx0XHQgKi9cblxuXHRcdGlmKHRoaXMub3JpZ2luYWxQb3NpdGlvbikgeyAvL0lmIHdlIGFyZSBub3QgZHJhZ2dpbmcgeWV0LCB3ZSB3b24ndCBjaGVjayBmb3Igb3B0aW9uc1xuXG5cdFx0XHRpZih0aGlzLmNvbnRhaW5tZW50KSB7XG5cdFx0XHRcdGlmKGV2ZW50LnBhZ2VYIC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA8IHRoaXMuY29udGFpbm1lbnRbMF0pIHBhZ2VYID0gdGhpcy5jb250YWlubWVudFswXSArIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQ7XG5cdFx0XHRcdGlmKGV2ZW50LnBhZ2VZIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wIDwgdGhpcy5jb250YWlubWVudFsxXSkgcGFnZVkgPSB0aGlzLmNvbnRhaW5tZW50WzFdICsgdGhpcy5vZmZzZXQuY2xpY2sudG9wO1xuXHRcdFx0XHRpZihldmVudC5wYWdlWCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPiB0aGlzLmNvbnRhaW5tZW50WzJdKSBwYWdlWCA9IHRoaXMuY29udGFpbm1lbnRbMl0gKyB0aGlzLm9mZnNldC5jbGljay5sZWZ0O1xuXHRcdFx0XHRpZihldmVudC5wYWdlWSAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+IHRoaXMuY29udGFpbm1lbnRbM10pIHBhZ2VZID0gdGhpcy5jb250YWlubWVudFszXSArIHRoaXMub2Zmc2V0LmNsaWNrLnRvcDtcblx0XHRcdH1cblxuXHRcdFx0aWYoby5ncmlkKSB7XG5cdFx0XHRcdHZhciB0b3AgPSB0aGlzLm9yaWdpbmFsUGFnZVkgKyBNYXRoLnJvdW5kKChwYWdlWSAtIHRoaXMub3JpZ2luYWxQYWdlWSkgLyBvLmdyaWRbMV0pICogby5ncmlkWzFdO1xuXHRcdFx0XHRwYWdlWSA9IHRoaXMuY29udGFpbm1lbnQgPyAoISh0b3AgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPCB0aGlzLmNvbnRhaW5tZW50WzFdIHx8IHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+IHRoaXMuY29udGFpbm1lbnRbM10pID8gdG9wIDogKCEodG9wIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wIDwgdGhpcy5jb250YWlubWVudFsxXSkgPyB0b3AgLSBvLmdyaWRbMV0gOiB0b3AgKyBvLmdyaWRbMV0pKSA6IHRvcDtcblxuXHRcdFx0XHR2YXIgbGVmdCA9IHRoaXMub3JpZ2luYWxQYWdlWCArIE1hdGgucm91bmQoKHBhZ2VYIC0gdGhpcy5vcmlnaW5hbFBhZ2VYKSAvIG8uZ3JpZFswXSkgKiBvLmdyaWRbMF07XG5cdFx0XHRcdHBhZ2VYID0gdGhpcy5jb250YWlubWVudCA/ICghKGxlZnQgLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0IDwgdGhpcy5jb250YWlubWVudFswXSB8fCBsZWZ0IC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+IHRoaXMuY29udGFpbm1lbnRbMl0pID8gbGVmdCA6ICghKGxlZnQgLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0IDwgdGhpcy5jb250YWlubWVudFswXSkgPyBsZWZ0IC0gby5ncmlkWzBdIDogbGVmdCArIG8uZ3JpZFswXSkpIDogbGVmdDtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IChcblx0XHRcdFx0cGFnZVlcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxuXHRcdFx0XHQtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2xpY2sgb2Zmc2V0IChyZWxhdGl2ZSB0byB0aGUgZWxlbWVudClcblx0XHRcdFx0LSB0aGlzLm9mZnNldC5yZWxhdGl2ZS50b3BcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcblx0XHRcdFx0LSB0aGlzLm9mZnNldC5wYXJlbnQudG9wXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcblx0XHRcdFx0KyAoICggdGhpcy5jc3NQb3NpdGlvbiA9PSAnZml4ZWQnID8gLXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpIDogKCBzY3JvbGxJc1Jvb3ROb2RlID8gMCA6IHNjcm9sbC5zY3JvbGxUb3AoKSApICkpXG5cdFx0XHQpLFxuXHRcdFx0bGVmdDogKFxuXHRcdFx0XHRwYWdlWFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENsaWNrIG9mZnNldCAocmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQpXG5cdFx0XHRcdC0gdGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHQtIHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcblx0XHRcdFx0KyAoICggdGhpcy5jc3NQb3NpdGlvbiA9PSAnZml4ZWQnID8gLXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKSA6IHNjcm9sbElzUm9vdE5vZGUgPyAwIDogc2Nyb2xsLnNjcm9sbExlZnQoKSApKVxuXHRcdFx0KVxuXHRcdH07XG5cblx0fSxcblxuXHRfcmVhcnJhbmdlOiBmdW5jdGlvbihldmVudCwgaSwgYSwgaGFyZFJlZnJlc2gpIHtcblxuXHRcdGEgPyBhWzBdLmFwcGVuZENoaWxkKHRoaXMucGxhY2Vob2xkZXJbMF0pIDogaS5pdGVtWzBdLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMucGxhY2Vob2xkZXJbMF0sICh0aGlzLmRpcmVjdGlvbiA9PSAnZG93bicgPyBpLml0ZW1bMF0gOiBpLml0ZW1bMF0ubmV4dFNpYmxpbmcpKTtcblxuXHRcdC8vVmFyaW91cyB0aGluZ3MgZG9uZSBoZXJlIHRvIGltcHJvdmUgdGhlIHBlcmZvcm1hbmNlOlxuXHRcdC8vIDEuIHdlIGNyZWF0ZSBhIHNldFRpbWVvdXQsIHRoYXQgY2FsbHMgcmVmcmVzaFBvc2l0aW9uc1xuXHRcdC8vIDIuIG9uIHRoZSBpbnN0YW5jZSwgd2UgaGF2ZSBhIGNvdW50ZXIgdmFyaWFibGUsIHRoYXQgZ2V0J3MgaGlnaGVyIGFmdGVyIGV2ZXJ5IGFwcGVuZFxuXHRcdC8vIDMuIG9uIHRoZSBsb2NhbCBzY29wZSwgd2UgY29weSB0aGUgY291bnRlciB2YXJpYWJsZSwgYW5kIGNoZWNrIGluIHRoZSB0aW1lb3V0LCBpZiBpdCdzIHN0aWxsIHRoZSBzYW1lXG5cdFx0Ly8gNC4gdGhpcyBsZXRzIG9ubHkgdGhlIGxhc3QgYWRkaXRpb24gdG8gdGhlIHRpbWVvdXQgc3RhY2sgdGhyb3VnaFxuXHRcdHRoaXMuY291bnRlciA9IHRoaXMuY291bnRlciA/ICsrdGhpcy5jb3VudGVyIDogMTtcblx0XHR2YXIgY291bnRlciA9IHRoaXMuY291bnRlcjtcblxuXHRcdHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYoY291bnRlciA9PSB0aGlzLmNvdW50ZXIpIHRoaXMucmVmcmVzaFBvc2l0aW9ucyghaGFyZFJlZnJlc2gpOyAvL1ByZWNvbXB1dGUgYWZ0ZXIgZWFjaCBET00gaW5zZXJ0aW9uLCBOT1Qgb24gbW91c2Vtb3ZlXG5cdFx0fSk7XG5cblx0fSxcblxuXHRfY2xlYXI6IGZ1bmN0aW9uKGV2ZW50LCBub1Byb3BhZ2F0aW9uKSB7XG5cblx0XHR0aGlzLnJldmVydGluZyA9IGZhbHNlO1xuXHRcdC8vIFdlIGRlbGF5IGFsbCBldmVudHMgdGhhdCBoYXZlIHRvIGJlIHRyaWdnZXJlZCB0byBhZnRlciB0aGUgcG9pbnQgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGhhcyBiZWVuIHJlbW92ZWQgYW5kXG5cdFx0Ly8gZXZlcnl0aGluZyBlbHNlIG5vcm1hbGl6ZWQgYWdhaW5cblx0XHR2YXIgZGVsYXllZFRyaWdnZXJzID0gW107XG5cblx0XHQvLyBXZSBmaXJzdCBoYXZlIHRvIHVwZGF0ZSB0aGUgZG9tIHBvc2l0aW9uIG9mIHRoZSBhY3R1YWwgY3VycmVudEl0ZW1cblx0XHQvLyBOb3RlOiBkb24ndCBkbyBpdCBpZiB0aGUgY3VycmVudCBpdGVtIGlzIGFscmVhZHkgcmVtb3ZlZCAoYnkgYSB1c2VyKSwgb3IgaXQgZ2V0cyByZWFwcGVuZGVkIChzZWUgIzQwODgpXG5cdFx0aWYoIXRoaXMuX25vRmluYWxTb3J0ICYmIHRoaXMuY3VycmVudEl0ZW0ucGFyZW50KCkubGVuZ3RoKSB0aGlzLnBsYWNlaG9sZGVyLmJlZm9yZSh0aGlzLmN1cnJlbnRJdGVtKTtcblx0XHR0aGlzLl9ub0ZpbmFsU29ydCA9IG51bGw7XG5cblx0XHRpZih0aGlzLmhlbHBlclswXSA9PSB0aGlzLmN1cnJlbnRJdGVtWzBdKSB7XG5cdFx0XHRmb3IodmFyIGkgaW4gdGhpcy5fc3RvcmVkQ1NTKSB7XG5cdFx0XHRcdGlmKHRoaXMuX3N0b3JlZENTU1tpXSA9PSAnYXV0bycgfHwgdGhpcy5fc3RvcmVkQ1NTW2ldID09ICdzdGF0aWMnKSB0aGlzLl9zdG9yZWRDU1NbaV0gPSAnJztcblx0XHRcdH1cblx0XHRcdHRoaXMuY3VycmVudEl0ZW0uY3NzKHRoaXMuX3N0b3JlZENTUykucmVtb3ZlQ2xhc3MoXCJ1aS1zb3J0YWJsZS1oZWxwZXJcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuY3VycmVudEl0ZW0uc2hvdygpO1xuXHRcdH1cblxuXHRcdGlmKHRoaXMuZnJvbU91dHNpZGUgJiYgIW5vUHJvcGFnYXRpb24pIGRlbGF5ZWRUcmlnZ2Vycy5wdXNoKGZ1bmN0aW9uKGV2ZW50KSB7IHRoaXMuX3RyaWdnZXIoXCJyZWNlaXZlXCIsIGV2ZW50LCB0aGlzLl91aUhhc2godGhpcy5mcm9tT3V0c2lkZSkpOyB9KTtcblx0XHRpZigodGhpcy5mcm9tT3V0c2lkZSB8fCB0aGlzLmRvbVBvc2l0aW9uLnByZXYgIT0gdGhpcy5jdXJyZW50SXRlbS5wcmV2KCkubm90KFwiLnVpLXNvcnRhYmxlLWhlbHBlclwiKVswXSB8fCB0aGlzLmRvbVBvc2l0aW9uLnBhcmVudCAhPSB0aGlzLmN1cnJlbnRJdGVtLnBhcmVudCgpWzBdKSAmJiAhbm9Qcm9wYWdhdGlvbikgZGVsYXllZFRyaWdnZXJzLnB1c2goZnVuY3Rpb24oZXZlbnQpIHsgdGhpcy5fdHJpZ2dlcihcInVwZGF0ZVwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkpOyB9KTsgLy9UcmlnZ2VyIHVwZGF0ZSBjYWxsYmFjayBpZiB0aGUgRE9NIHBvc2l0aW9uIGhhcyBjaGFuZ2VkXG5cblx0XHQvLyBDaGVjayBpZiB0aGUgaXRlbXMgQ29udGFpbmVyIGhhcyBDaGFuZ2VkIGFuZCB0cmlnZ2VyIGFwcHJvcHJpYXRlXG5cdFx0Ly8gZXZlbnRzLlxuXHRcdGlmICh0aGlzICE9PSB0aGlzLmN1cnJlbnRDb250YWluZXIpIHtcblx0XHRcdGlmKCFub1Byb3BhZ2F0aW9uKSB7XG5cdFx0XHRcdGRlbGF5ZWRUcmlnZ2Vycy5wdXNoKGZ1bmN0aW9uKGV2ZW50KSB7IHRoaXMuX3RyaWdnZXIoXCJyZW1vdmVcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTsgfSk7XG5cdFx0XHRcdGRlbGF5ZWRUcmlnZ2Vycy5wdXNoKChmdW5jdGlvbihjKSB7IHJldHVybiBmdW5jdGlvbihldmVudCkgeyBjLl90cmlnZ2VyKFwicmVjZWl2ZVwiLCBldmVudCwgdGhpcy5fdWlIYXNoKHRoaXMpKTsgfTsgIH0pLmNhbGwodGhpcywgdGhpcy5jdXJyZW50Q29udGFpbmVyKSk7XG5cdFx0XHRcdGRlbGF5ZWRUcmlnZ2Vycy5wdXNoKChmdW5jdGlvbihjKSB7IHJldHVybiBmdW5jdGlvbihldmVudCkgeyBjLl90cmlnZ2VyKFwidXBkYXRlXCIsIGV2ZW50LCB0aGlzLl91aUhhc2godGhpcykpOyAgfTsgfSkuY2FsbCh0aGlzLCB0aGlzLmN1cnJlbnRDb250YWluZXIpKTtcblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdC8vUG9zdCBldmVudHMgdG8gY29udGFpbmVyc1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLmNvbnRhaW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuXHRcdFx0aWYoIW5vUHJvcGFnYXRpb24pIGRlbGF5ZWRUcmlnZ2Vycy5wdXNoKChmdW5jdGlvbihjKSB7IHJldHVybiBmdW5jdGlvbihldmVudCkgeyBjLl90cmlnZ2VyKFwiZGVhY3RpdmF0ZVwiLCBldmVudCwgdGhpcy5fdWlIYXNoKHRoaXMpKTsgfTsgIH0pLmNhbGwodGhpcywgdGhpcy5jb250YWluZXJzW2ldKSk7XG5cdFx0XHRpZih0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUub3Zlcikge1xuXHRcdFx0XHRkZWxheWVkVHJpZ2dlcnMucHVzaCgoZnVuY3Rpb24oYykgeyByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHsgYy5fdHJpZ2dlcihcIm91dFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKHRoaXMpKTsgfTsgIH0pLmNhbGwodGhpcywgdGhpcy5jb250YWluZXJzW2ldKSk7XG5cdFx0XHRcdHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZS5vdmVyID0gMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL0RvIHdoYXQgd2FzIG9yaWdpbmFsbHkgaW4gcGx1Z2luc1xuXHRcdGlmKHRoaXMuX3N0b3JlZEN1cnNvcikgJCgnYm9keScpLmNzcyhcImN1cnNvclwiLCB0aGlzLl9zdG9yZWRDdXJzb3IpOyAvL1Jlc2V0IGN1cnNvclxuXHRcdGlmKHRoaXMuX3N0b3JlZE9wYWNpdHkpIHRoaXMuaGVscGVyLmNzcyhcIm9wYWNpdHlcIiwgdGhpcy5fc3RvcmVkT3BhY2l0eSk7IC8vUmVzZXQgb3BhY2l0eVxuXHRcdGlmKHRoaXMuX3N0b3JlZFpJbmRleCkgdGhpcy5oZWxwZXIuY3NzKFwiekluZGV4XCIsIHRoaXMuX3N0b3JlZFpJbmRleCA9PSAnYXV0bycgPyAnJyA6IHRoaXMuX3N0b3JlZFpJbmRleCk7IC8vUmVzZXQgei1pbmRleFxuXG5cdFx0dGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuXHRcdGlmKHRoaXMuY2FuY2VsSGVscGVyUmVtb3ZhbCkge1xuXHRcdFx0aWYoIW5vUHJvcGFnYXRpb24pIHtcblx0XHRcdFx0dGhpcy5fdHJpZ2dlcihcImJlZm9yZVN0b3BcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTtcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpIDwgZGVsYXllZFRyaWdnZXJzLmxlbmd0aDsgaSsrKSB7IGRlbGF5ZWRUcmlnZ2Vyc1tpXS5jYWxsKHRoaXMsIGV2ZW50KTsgfTsgLy9UcmlnZ2VyIGFsbCBkZWxheWVkIGV2ZW50c1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyKFwic3RvcFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmZyb21PdXRzaWRlID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYoIW5vUHJvcGFnYXRpb24pIHRoaXMuX3RyaWdnZXIoXCJiZWZvcmVTdG9wXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goKSk7XG5cblx0XHQvLyQodGhpcy5wbGFjZWhvbGRlclswXSkucmVtb3ZlKCk7IHdvdWxkIGhhdmUgYmVlbiB0aGUgalF1ZXJ5IHdheSAtIHVuZm9ydHVuYXRlbHksIGl0IHVuYmluZHMgQUxMIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCBub2RlIVxuXHRcdHRoaXMucGxhY2Vob2xkZXJbMF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBsYWNlaG9sZGVyWzBdKTtcblxuXHRcdGlmKHRoaXMuaGVscGVyWzBdICE9IHRoaXMuY3VycmVudEl0ZW1bMF0pIHRoaXMuaGVscGVyLnJlbW92ZSgpOyB0aGlzLmhlbHBlciA9IG51bGw7XG5cblx0XHRpZighbm9Qcm9wYWdhdGlvbikge1xuXHRcdFx0Zm9yICh2YXIgaT0wOyBpIDwgZGVsYXllZFRyaWdnZXJzLmxlbmd0aDsgaSsrKSB7IGRlbGF5ZWRUcmlnZ2Vyc1tpXS5jYWxsKHRoaXMsIGV2ZW50KTsgfTsgLy9UcmlnZ2VyIGFsbCBkZWxheWVkIGV2ZW50c1xuXHRcdFx0dGhpcy5fdHJpZ2dlcihcInN0b3BcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTtcblx0XHR9XG5cblx0XHR0aGlzLmZyb21PdXRzaWRlID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fSxcblxuXHRfdHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCQuV2lkZ2V0LnByb3RvdHlwZS5fdHJpZ2dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpID09PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5jYW5jZWwoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VpSGFzaDogZnVuY3Rpb24oX2luc3QpIHtcblx0XHR2YXIgaW5zdCA9IF9pbnN0IHx8IHRoaXM7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGhlbHBlcjogaW5zdC5oZWxwZXIsXG5cdFx0XHRwbGFjZWhvbGRlcjogaW5zdC5wbGFjZWhvbGRlciB8fCAkKFtdKSxcblx0XHRcdHBvc2l0aW9uOiBpbnN0LnBvc2l0aW9uLFxuXHRcdFx0b3JpZ2luYWxQb3NpdGlvbjogaW5zdC5vcmlnaW5hbFBvc2l0aW9uLFxuXHRcdFx0b2Zmc2V0OiBpbnN0LnBvc2l0aW9uQWJzLFxuXHRcdFx0aXRlbTogaW5zdC5jdXJyZW50SXRlbSxcblx0XHRcdHNlbmRlcjogX2luc3QgPyBfaW5zdC5lbGVtZW50IDogbnVsbFxuXHRcdH07XG5cdH1cblxufSk7XG5cbn0pKGpRdWVyeSk7XG4oZnVuY3Rpb24oICQgKSB7XG5cbmZ1bmN0aW9uIG1vZGlmaWVyKCBmbiApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwcmV2aW91cyA9IHRoaXMuZWxlbWVudC52YWwoKTtcblx0XHRmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0dGhpcy5fcmVmcmVzaCgpO1xuXHRcdGlmICggcHJldmlvdXMgIT09IHRoaXMuZWxlbWVudC52YWwoKSApIHtcblx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiY2hhbmdlXCIgKTtcblx0XHR9XG5cdH07XG59XG5cbiQud2lkZ2V0KCBcInVpLnNwaW5uZXJcIiwge1xuXHR2ZXJzaW9uOiBcIjEuOS4yXCIsXG5cdGRlZmF1bHRFbGVtZW50OiBcIjxpbnB1dD5cIixcblx0d2lkZ2V0RXZlbnRQcmVmaXg6IFwic3BpblwiLFxuXHRvcHRpb25zOiB7XG5cdFx0Y3VsdHVyZTogbnVsbCxcblx0XHRpY29uczoge1xuXHRcdFx0ZG93bjogXCJ1aS1pY29uLXRyaWFuZ2xlLTEtc1wiLFxuXHRcdFx0dXA6IFwidWktaWNvbi10cmlhbmdsZS0xLW5cIlxuXHRcdH0sXG5cdFx0aW5jcmVtZW50YWw6IHRydWUsXG5cdFx0bWF4OiBudWxsLFxuXHRcdG1pbjogbnVsbCxcblx0XHRudW1iZXJGb3JtYXQ6IG51bGwsXG5cdFx0cGFnZTogMTAsXG5cdFx0c3RlcDogMSxcblxuXHRcdGNoYW5nZTogbnVsbCxcblx0XHRzcGluOiBudWxsLFxuXHRcdHN0YXJ0OiBudWxsLFxuXHRcdHN0b3A6IG51bGxcblx0fSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHQvLyBoYW5kbGUgc3RyaW5nIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgcGFyc2VkXG5cdFx0dGhpcy5fc2V0T3B0aW9uKCBcIm1heFwiLCB0aGlzLm9wdGlvbnMubWF4ICk7XG5cdFx0dGhpcy5fc2V0T3B0aW9uKCBcIm1pblwiLCB0aGlzLm9wdGlvbnMubWluICk7XG5cdFx0dGhpcy5fc2V0T3B0aW9uKCBcInN0ZXBcIiwgdGhpcy5vcHRpb25zLnN0ZXAgKTtcblxuXHRcdC8vIGZvcm1hdCB0aGUgdmFsdWUsIGJ1dCBkb24ndCBjb25zdHJhaW5cblx0XHR0aGlzLl92YWx1ZSggdGhpcy5lbGVtZW50LnZhbCgpLCB0cnVlICk7XG5cblx0XHR0aGlzLl9kcmF3KCk7XG5cdFx0dGhpcy5fb24oIHRoaXMuX2V2ZW50cyApO1xuXHRcdHRoaXMuX3JlZnJlc2goKTtcblxuXHRcdC8vIHR1cm5pbmcgb2ZmIGF1dG9jb21wbGV0ZSBwcmV2ZW50cyB0aGUgYnJvd3NlciBmcm9tIHJlbWVtYmVyaW5nIHRoZVxuXHRcdC8vIHZhbHVlIHdoZW4gbmF2aWdhdGluZyB0aHJvdWdoIGhpc3RvcnksIHNvIHdlIHJlLWVuYWJsZSBhdXRvY29tcGxldGVcblx0XHQvLyBpZiB0aGUgcGFnZSBpcyB1bmxvYWRlZCBiZWZvcmUgdGhlIHdpZGdldCBpcyBkZXN0cm95ZWQuICM3NzkwXG5cdFx0dGhpcy5fb24oIHRoaXMud2luZG93LCB7XG5cdFx0XHRiZWZvcmV1bmxvYWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQXR0ciggXCJhdXRvY29tcGxldGVcIiApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9nZXRDcmVhdGVPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3B0aW9ucyA9IHt9LFxuXHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuXHRcdCQuZWFjaCggWyBcIm1pblwiLCBcIm1heFwiLCBcInN0ZXBcIiBdLCBmdW5jdGlvbiggaSwgb3B0aW9uICkge1xuXHRcdFx0dmFyIHZhbHVlID0gZWxlbWVudC5hdHRyKCBvcHRpb24gKTtcblx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5sZW5ndGggKSB7XG5cdFx0XHRcdG9wdGlvbnNbIG9wdGlvbiBdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fSxcblxuXHRfZXZlbnRzOiB7XG5cdFx0a2V5ZG93bjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0aWYgKCB0aGlzLl9zdGFydCggZXZlbnQgKSAmJiB0aGlzLl9rZXlkb3duKCBldmVudCApICkge1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0a2V5dXA6IFwiX3N0b3BcIixcblx0XHRmb2N1czogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnByZXZpb3VzID0gdGhpcy5lbGVtZW50LnZhbCgpO1xuXHRcdH0sXG5cdFx0Ymx1cjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0aWYgKCB0aGlzLmNhbmNlbEJsdXIgKSB7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmNhbmNlbEJsdXI7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcmVmcmVzaCgpO1xuXHRcdFx0aWYgKCB0aGlzLnByZXZpb3VzICE9PSB0aGlzLmVsZW1lbnQudmFsKCkgKSB7XG5cdFx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiY2hhbmdlXCIsIGV2ZW50ICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRtb3VzZXdoZWVsOiBmdW5jdGlvbiggZXZlbnQsIGRlbHRhICkge1xuXHRcdFx0aWYgKCAhZGVsdGEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICggIXRoaXMuc3Bpbm5pbmcgJiYgIXRoaXMuX3N0YXJ0KCBldmVudCApICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3NwaW4oIChkZWx0YSA+IDAgPyAxIDogLTEpICogdGhpcy5vcHRpb25zLnN0ZXAsIGV2ZW50ICk7XG5cdFx0XHRjbGVhclRpbWVvdXQoIHRoaXMubW91c2V3aGVlbFRpbWVyICk7XG5cdFx0XHR0aGlzLm1vdXNld2hlZWxUaW1lciA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMuc3Bpbm5pbmcgKSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RvcCggZXZlbnQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgMTAwICk7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH0sXG5cdFx0XCJtb3VzZWRvd24gLnVpLXNwaW5uZXItYnV0dG9uXCI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBwcmV2aW91cztcblxuXHRcdFx0Ly8gV2UgbmV2ZXIgd2FudCB0aGUgYnV0dG9ucyB0byBoYXZlIGZvY3VzOyB3aGVuZXZlciB0aGUgdXNlciBpc1xuXHRcdFx0Ly8gaW50ZXJhY3Rpbmcgd2l0aCB0aGUgc3Bpbm5lciwgdGhlIGZvY3VzIHNob3VsZCBiZSBvbiB0aGUgaW5wdXQuXG5cdFx0XHQvLyBJZiB0aGUgaW5wdXQgaXMgZm9jdXNlZCB0aGVuIHRoaXMucHJldmlvdXMgaXMgcHJvcGVybHkgc2V0IGZyb21cblx0XHRcdC8vIHdoZW4gdGhlIGlucHV0IGZpcnN0IHJlY2VpdmVkIGZvY3VzLiBJZiB0aGUgaW5wdXQgaXMgbm90IGZvY3VzZWRcblx0XHRcdC8vIHRoZW4gd2UgbmVlZCB0byBzZXQgdGhpcy5wcmV2aW91cyBiYXNlZCBvbiB0aGUgdmFsdWUgYmVmb3JlIHNwaW5uaW5nLlxuXHRcdFx0cHJldmlvdXMgPSB0aGlzLmVsZW1lbnRbMF0gPT09IHRoaXMuZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudCA/XG5cdFx0XHRcdHRoaXMucHJldmlvdXMgOiB0aGlzLmVsZW1lbnQudmFsKCk7XG5cdFx0XHRmdW5jdGlvbiBjaGVja0ZvY3VzKCkge1xuXHRcdFx0XHR2YXIgaXNBY3RpdmUgPSB0aGlzLmVsZW1lbnRbMF0gPT09IHRoaXMuZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudDtcblx0XHRcdFx0aWYgKCAhaXNBY3RpdmUgKSB7XG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50LmZvY3VzKCk7XG5cdFx0XHRcdFx0dGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuXHRcdFx0XHRcdC8vIHN1cHBvcnQ6IElFXG5cdFx0XHRcdFx0Ly8gSUUgc2V0cyBmb2N1cyBhc3luY2hyb25vdXNseSwgc28gd2UgbmVlZCB0byBjaGVjayBpZiBmb2N1c1xuXHRcdFx0XHRcdC8vIG1vdmVkIG9mZiBvZiB0aGUgaW5wdXQgYmVjYXVzZSB0aGUgdXNlciBjbGlja2VkIG9uIHRoZSBidXR0b24uXG5cdFx0XHRcdFx0dGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gZW5zdXJlIGZvY3VzIGlzIG9uIChvciBzdGF5cyBvbikgdGhlIHRleHQgZmllbGRcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRjaGVja0ZvY3VzLmNhbGwoIHRoaXMgKTtcblxuXHRcdFx0Ly8gc3VwcG9ydDogSUVcblx0XHRcdC8vIElFIGRvZXNuJ3QgcHJldmVudCBtb3ZpbmcgZm9jdXMgZXZlbiB3aXRoIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblx0XHRcdC8vIHNvIHdlIHNldCBhIGZsYWcgdG8ga25vdyB3aGVuIHdlIHNob3VsZCBpZ25vcmUgdGhlIGJsdXIgZXZlbnRcblx0XHRcdC8vIGFuZCBjaGVjayAoYWdhaW4pIGlmIGZvY3VzIG1vdmVkIG9mZiBvZiB0aGUgaW5wdXQuXG5cdFx0XHR0aGlzLmNhbmNlbEJsdXIgPSB0cnVlO1xuXHRcdFx0dGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmNhbmNlbEJsdXI7XG5cdFx0XHRcdGNoZWNrRm9jdXMuY2FsbCggdGhpcyApO1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmICggdGhpcy5fc3RhcnQoIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3JlcGVhdCggbnVsbCwgJCggZXZlbnQuY3VycmVudFRhcmdldCApLmhhc0NsYXNzKCBcInVpLXNwaW5uZXItdXBcIiApID8gMSA6IC0xLCBldmVudCApO1xuXHRcdH0sXG5cdFx0XCJtb3VzZXVwIC51aS1zcGlubmVyLWJ1dHRvblwiOiBcIl9zdG9wXCIsXG5cdFx0XCJtb3VzZWVudGVyIC51aS1zcGlubmVyLWJ1dHRvblwiOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHQvLyBidXR0b24gd2lsbCBhZGQgdWktc3RhdGUtYWN0aXZlIGlmIG1vdXNlIHdhcyBkb3duIHdoaWxlIG1vdXNlbGVhdmUgYW5kIGtlcHQgZG93blxuXHRcdFx0aWYgKCAhJCggZXZlbnQuY3VycmVudFRhcmdldCApLmhhc0NsYXNzKCBcInVpLXN0YXRlLWFjdGl2ZVwiICkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLl9zdGFydCggZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlcGVhdCggbnVsbCwgJCggZXZlbnQuY3VycmVudFRhcmdldCApLmhhc0NsYXNzKCBcInVpLXNwaW5uZXItdXBcIiApID8gMSA6IC0xLCBldmVudCApO1xuXHRcdH0sXG5cdFx0Ly8gVE9ETzogZG8gd2UgcmVhbGx5IHdhbnQgdG8gY29uc2lkZXIgdGhpcyBhIHN0b3A/XG5cdFx0Ly8gc2hvdWxkbid0IHdlIGp1c3Qgc3RvcCB0aGUgcmVwZWF0ZXIgYW5kIHdhaXQgdW50aWwgbW91c2V1cCBiZWZvcmVcblx0XHQvLyB3ZSB0cmlnZ2VyIHRoZSBzdG9wIGV2ZW50P1xuXHRcdFwibW91c2VsZWF2ZSAudWktc3Bpbm5lci1idXR0b25cIjogXCJfc3RvcFwiXG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB1aVNwaW5uZXIgPSB0aGlzLnVpU3Bpbm5lciA9IHRoaXMuZWxlbWVudFxuXHRcdFx0LmFkZENsYXNzKCBcInVpLXNwaW5uZXItaW5wdXRcIiApXG5cdFx0XHQuYXR0ciggXCJhdXRvY29tcGxldGVcIiwgXCJvZmZcIiApXG5cdFx0XHQud3JhcCggdGhpcy5fdWlTcGlubmVySHRtbCgpIClcblx0XHRcdC5wYXJlbnQoKVxuXHRcdFx0XHQvLyBhZGQgYnV0dG9uc1xuXHRcdFx0XHQuYXBwZW5kKCB0aGlzLl9idXR0b25IdG1sKCkgKTtcblxuXHRcdHRoaXMuZWxlbWVudC5hdHRyKCBcInJvbGVcIiwgXCJzcGluYnV0dG9uXCIgKTtcblxuXHRcdC8vIGJ1dHRvbiBiaW5kaW5nc1xuXHRcdHRoaXMuYnV0dG9ucyA9IHVpU3Bpbm5lci5maW5kKCBcIi51aS1zcGlubmVyLWJ1dHRvblwiIClcblx0XHRcdC5hdHRyKCBcInRhYkluZGV4XCIsIC0xIClcblx0XHRcdC5idXR0b24oKVxuXHRcdFx0LnJlbW92ZUNsYXNzKCBcInVpLWNvcm5lci1hbGxcIiApO1xuXG5cdFx0Ly8gSUUgNiBkb2Vzbid0IHVuZGVyc3RhbmQgaGVpZ2h0OiA1MCUgZm9yIHRoZSBidXR0b25zXG5cdFx0Ly8gdW5sZXNzIHRoZSB3cmFwcGVyIGhhcyBhbiBleHBsaWNpdCBoZWlnaHRcblx0XHRpZiAoIHRoaXMuYnV0dG9ucy5oZWlnaHQoKSA+IE1hdGguY2VpbCggdWlTcGlubmVyLmhlaWdodCgpICogMC41ICkgJiZcblx0XHRcdFx0dWlTcGlubmVyLmhlaWdodCgpID4gMCApIHtcblx0XHRcdHVpU3Bpbm5lci5oZWlnaHQoIHVpU3Bpbm5lci5oZWlnaHQoKSApO1xuXHRcdH1cblxuXHRcdC8vIGRpc2FibGUgc3Bpbm5lciBpZiBlbGVtZW50IHdhcyBhbHJlYWR5IGRpc2FibGVkXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHR0aGlzLmRpc2FibGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X2tleWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGtleUNvZGUgPSAkLnVpLmtleUNvZGU7XG5cblx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXHRcdGNhc2Uga2V5Q29kZS5VUDpcblx0XHRcdHRoaXMuX3JlcGVhdCggbnVsbCwgMSwgZXZlbnQgKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdGNhc2Uga2V5Q29kZS5ET1dOOlxuXHRcdFx0dGhpcy5fcmVwZWF0KCBudWxsLCAtMSwgZXZlbnQgKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdGNhc2Uga2V5Q29kZS5QQUdFX1VQOlxuXHRcdFx0dGhpcy5fcmVwZWF0KCBudWxsLCBvcHRpb25zLnBhZ2UsIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRjYXNlIGtleUNvZGUuUEFHRV9ET1dOOlxuXHRcdFx0dGhpcy5fcmVwZWF0KCBudWxsLCAtb3B0aW9ucy5wYWdlLCBldmVudCApO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF91aVNwaW5uZXJIdG1sOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCI8c3BhbiBjbGFzcz0ndWktc3Bpbm5lciB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCc+PC9zcGFuPlwiO1xuXHR9LFxuXG5cdF9idXR0b25IdG1sOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJcIiArXG5cdFx0XHRcIjxhIGNsYXNzPSd1aS1zcGlubmVyLWJ1dHRvbiB1aS1zcGlubmVyLXVwIHVpLWNvcm5lci10cic+XCIgK1xuXHRcdFx0XHRcIjxzcGFuIGNsYXNzPSd1aS1pY29uIFwiICsgdGhpcy5vcHRpb25zLmljb25zLnVwICsgXCInPiYjOTY1MDs8L3NwYW4+XCIgK1xuXHRcdFx0XCI8L2E+XCIgK1xuXHRcdFx0XCI8YSBjbGFzcz0ndWktc3Bpbm5lci1idXR0b24gdWktc3Bpbm5lci1kb3duIHVpLWNvcm5lci1icic+XCIgK1xuXHRcdFx0XHRcIjxzcGFuIGNsYXNzPSd1aS1pY29uIFwiICsgdGhpcy5vcHRpb25zLmljb25zLmRvd24gKyBcIic+JiM5NjYwOzwvc3Bhbj5cIiArXG5cdFx0XHRcIjwvYT5cIjtcblx0fSxcblxuXHRfc3RhcnQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoICF0aGlzLnNwaW5uaW5nICYmIHRoaXMuX3RyaWdnZXIoIFwic3RhcnRcIiwgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGhpcy5jb3VudGVyICkge1xuXHRcdFx0dGhpcy5jb3VudGVyID0gMTtcblx0XHR9XG5cdFx0dGhpcy5zcGlubmluZyA9IHRydWU7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X3JlcGVhdDogZnVuY3Rpb24oIGksIHN0ZXBzLCBldmVudCApIHtcblx0XHRpID0gaSB8fCA1MDA7XG5cblx0XHRjbGVhclRpbWVvdXQoIHRoaXMudGltZXIgKTtcblx0XHR0aGlzLnRpbWVyID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9yZXBlYXQoIDQwLCBzdGVwcywgZXZlbnQgKTtcblx0XHR9LCBpICk7XG5cblx0XHR0aGlzLl9zcGluKCBzdGVwcyAqIHRoaXMub3B0aW9ucy5zdGVwLCBldmVudCApO1xuXHR9LFxuXG5cdF9zcGluOiBmdW5jdGlvbiggc3RlcCwgZXZlbnQgKSB7XG5cdFx0dmFyIHZhbHVlID0gdGhpcy52YWx1ZSgpIHx8IDA7XG5cblx0XHRpZiAoICF0aGlzLmNvdW50ZXIgKSB7XG5cdFx0XHR0aGlzLmNvdW50ZXIgPSAxO1xuXHRcdH1cblxuXHRcdHZhbHVlID0gdGhpcy5fYWRqdXN0VmFsdWUoIHZhbHVlICsgc3RlcCAqIHRoaXMuX2luY3JlbWVudCggdGhpcy5jb3VudGVyICkgKTtcblxuXHRcdGlmICggIXRoaXMuc3Bpbm5pbmcgfHwgdGhpcy5fdHJpZ2dlciggXCJzcGluXCIsIGV2ZW50LCB7IHZhbHVlOiB2YWx1ZSB9ICkgIT09IGZhbHNlKSB7XG5cdFx0XHR0aGlzLl92YWx1ZSggdmFsdWUgKTtcblx0XHRcdHRoaXMuY291bnRlcisrO1xuXHRcdH1cblx0fSxcblxuXHRfaW5jcmVtZW50OiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgaW5jcmVtZW50YWwgPSB0aGlzLm9wdGlvbnMuaW5jcmVtZW50YWw7XG5cblx0XHRpZiAoIGluY3JlbWVudGFsICkge1xuXHRcdFx0cmV0dXJuICQuaXNGdW5jdGlvbiggaW5jcmVtZW50YWwgKSA/XG5cdFx0XHRcdGluY3JlbWVudGFsKCBpICkgOlxuXHRcdFx0XHRNYXRoLmZsb29yKCBpKmkqaS81MDAwMCAtIGkqaS81MDAgKyAxNyppLzIwMCArIDEgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gMTtcblx0fSxcblxuXHRfcHJlY2lzaW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcHJlY2lzaW9uID0gdGhpcy5fcHJlY2lzaW9uT2YoIHRoaXMub3B0aW9ucy5zdGVwICk7XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMubWluICE9PSBudWxsICkge1xuXHRcdFx0cHJlY2lzaW9uID0gTWF0aC5tYXgoIHByZWNpc2lvbiwgdGhpcy5fcHJlY2lzaW9uT2YoIHRoaXMub3B0aW9ucy5taW4gKSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcHJlY2lzaW9uO1xuXHR9LFxuXG5cdF9wcmVjaXNpb25PZjogZnVuY3Rpb24oIG51bSApIHtcblx0XHR2YXIgc3RyID0gbnVtLnRvU3RyaW5nKCksXG5cdFx0XHRkZWNpbWFsID0gc3RyLmluZGV4T2YoIFwiLlwiICk7XG5cdFx0cmV0dXJuIGRlY2ltYWwgPT09IC0xID8gMCA6IHN0ci5sZW5ndGggLSBkZWNpbWFsIC0gMTtcblx0fSxcblxuXHRfYWRqdXN0VmFsdWU6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgYmFzZSwgYWJvdmVNaW4sXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0Ly8gbWFrZSBzdXJlIHdlJ3JlIGF0IGEgdmFsaWQgc3RlcFxuXHRcdC8vIC0gZmluZCBvdXQgd2hlcmUgd2UgYXJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIChtaW4gb3IgMClcblx0XHRiYXNlID0gb3B0aW9ucy5taW4gIT09IG51bGwgPyBvcHRpb25zLm1pbiA6IDA7XG5cdFx0YWJvdmVNaW4gPSB2YWx1ZSAtIGJhc2U7XG5cdFx0Ly8gLSByb3VuZCB0byB0aGUgbmVhcmVzdCBzdGVwXG5cdFx0YWJvdmVNaW4gPSBNYXRoLnJvdW5kKGFib3ZlTWluIC8gb3B0aW9ucy5zdGVwKSAqIG9wdGlvbnMuc3RlcDtcblx0XHQvLyAtIHJvdW5kaW5nIGlzIGJhc2VkIG9uIDAsIHNvIGFkanVzdCBiYWNrIHRvIG91ciBiYXNlXG5cdFx0dmFsdWUgPSBiYXNlICsgYWJvdmVNaW47XG5cblx0XHQvLyBmaXggcHJlY2lzaW9uIGZyb20gYmFkIEpTIGZsb2F0aW5nIHBvaW50IG1hdGhcblx0XHR2YWx1ZSA9IHBhcnNlRmxvYXQoIHZhbHVlLnRvRml4ZWQoIHRoaXMuX3ByZWNpc2lvbigpICkgKTtcblxuXHRcdC8vIGNsYW1wIHRoZSB2YWx1ZVxuXHRcdGlmICggb3B0aW9ucy5tYXggIT09IG51bGwgJiYgdmFsdWUgPiBvcHRpb25zLm1heCkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMubWF4O1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubWluICE9PSBudWxsICYmIHZhbHVlIDwgb3B0aW9ucy5taW4gKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucy5taW47XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXG5cdF9zdG9wOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCAhdGhpcy5zcGlubmluZyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjbGVhclRpbWVvdXQoIHRoaXMudGltZXIgKTtcblx0XHRjbGVhclRpbWVvdXQoIHRoaXMubW91c2V3aGVlbFRpbWVyICk7XG5cdFx0dGhpcy5jb3VudGVyID0gMDtcblx0XHR0aGlzLnNwaW5uaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5fdHJpZ2dlciggXCJzdG9wXCIsIGV2ZW50ICk7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0aWYgKCBrZXkgPT09IFwiY3VsdHVyZVwiIHx8IGtleSA9PT0gXCJudW1iZXJGb3JtYXRcIiApIHtcblx0XHRcdHZhciBwcmV2VmFsdWUgPSB0aGlzLl9wYXJzZSggdGhpcy5lbGVtZW50LnZhbCgpICk7XG5cdFx0XHR0aGlzLm9wdGlvbnNbIGtleSBdID0gdmFsdWU7XG5cdFx0XHR0aGlzLmVsZW1lbnQudmFsKCB0aGlzLl9mb3JtYXQoIHByZXZWYWx1ZSApICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IFwibWF4XCIgfHwga2V5ID09PSBcIm1pblwiIHx8IGtleSA9PT0gXCJzdGVwXCIgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLl9wYXJzZSggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdGlmICggdmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5wcm9wKCBcImRpc2FibGVkXCIsIHRydWUgKTtcblx0XHRcdFx0dGhpcy5idXR0b25zLmJ1dHRvbiggXCJkaXNhYmxlXCIgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5wcm9wKCBcImRpc2FibGVkXCIsIGZhbHNlICk7XG5cdFx0XHRcdHRoaXMuYnV0dG9ucy5idXR0b24oIFwiZW5hYmxlXCIgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3NldE9wdGlvbnM6IG1vZGlmaWVyKGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHRoaXMuX3N1cGVyKCBvcHRpb25zICk7XG5cdFx0dGhpcy5fdmFsdWUoIHRoaXMuZWxlbWVudC52YWwoKSApO1xuXHR9KSxcblxuXHRfcGFyc2U6IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0aWYgKCB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiICYmIHZhbCAhPT0gXCJcIiApIHtcblx0XHRcdHZhbCA9IHdpbmRvdy5HbG9iYWxpemUgJiYgdGhpcy5vcHRpb25zLm51bWJlckZvcm1hdCA/XG5cdFx0XHRcdEdsb2JhbGl6ZS5wYXJzZUZsb2F0KCB2YWwsIDEwLCB0aGlzLm9wdGlvbnMuY3VsdHVyZSApIDogK3ZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbCA9PT0gXCJcIiB8fCBpc05hTiggdmFsICkgPyBudWxsIDogdmFsO1xuXHR9LFxuXG5cdF9mb3JtYXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBcIlwiICkge1xuXHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0fVxuXHRcdHJldHVybiB3aW5kb3cuR2xvYmFsaXplICYmIHRoaXMub3B0aW9ucy5udW1iZXJGb3JtYXQgP1xuXHRcdFx0R2xvYmFsaXplLmZvcm1hdCggdmFsdWUsIHRoaXMub3B0aW9ucy5udW1iZXJGb3JtYXQsIHRoaXMub3B0aW9ucy5jdWx0dXJlICkgOlxuXHRcdFx0dmFsdWU7XG5cdH0sXG5cblx0X3JlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWxlbWVudC5hdHRyKHtcblx0XHRcdFwiYXJpYS12YWx1ZW1pblwiOiB0aGlzLm9wdGlvbnMubWluLFxuXHRcdFx0XCJhcmlhLXZhbHVlbWF4XCI6IHRoaXMub3B0aW9ucy5tYXgsXG5cdFx0XHQvLyBUT0RPOiB3aGF0IHNob3VsZCB3ZSBkbyB3aXRoIHZhbHVlcyB0aGF0IGNhbid0IGJlIHBhcnNlZD9cblx0XHRcdFwiYXJpYS12YWx1ZW5vd1wiOiB0aGlzLl9wYXJzZSggdGhpcy5lbGVtZW50LnZhbCgpIClcblx0XHR9KTtcblx0fSxcblxuXHQvLyB1cGRhdGUgdGhlIHZhbHVlIHdpdGhvdXQgdHJpZ2dlcmluZyBjaGFuZ2Vcblx0X3ZhbHVlOiBmdW5jdGlvbiggdmFsdWUsIGFsbG93QW55ICkge1xuXHRcdHZhciBwYXJzZWQ7XG5cdFx0aWYgKCB2YWx1ZSAhPT0gXCJcIiApIHtcblx0XHRcdHBhcnNlZCA9IHRoaXMuX3BhcnNlKCB2YWx1ZSApO1xuXHRcdFx0aWYgKCBwYXJzZWQgIT09IG51bGwgKSB7XG5cdFx0XHRcdGlmICggIWFsbG93QW55ICkge1xuXHRcdFx0XHRcdHBhcnNlZCA9IHRoaXMuX2FkanVzdFZhbHVlKCBwYXJzZWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuX2Zvcm1hdCggcGFyc2VkICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuZWxlbWVudC52YWwoIHZhbHVlICk7XG5cdFx0dGhpcy5fcmVmcmVzaCgpO1xuXHR9LFxuXG5cdF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1zcGlubmVyLWlucHV0XCIgKVxuXHRcdFx0LnByb3AoIFwiZGlzYWJsZWRcIiwgZmFsc2UgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXV0b2NvbXBsZXRlXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwicm9sZVwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtdmFsdWVtaW5cIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLXZhbHVlbWF4XCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS12YWx1ZW5vd1wiICk7XG5cdFx0dGhpcy51aVNwaW5uZXIucmVwbGFjZVdpdGgoIHRoaXMuZWxlbWVudCApO1xuXHR9LFxuXG5cdHN0ZXBVcDogbW9kaWZpZXIoZnVuY3Rpb24oIHN0ZXBzICkge1xuXHRcdHRoaXMuX3N0ZXBVcCggc3RlcHMgKTtcblx0fSksXG5cdF9zdGVwVXA6IGZ1bmN0aW9uKCBzdGVwcyApIHtcblx0XHR0aGlzLl9zcGluKCAoc3RlcHMgfHwgMSkgKiB0aGlzLm9wdGlvbnMuc3RlcCApO1xuXHR9LFxuXG5cdHN0ZXBEb3duOiBtb2RpZmllcihmdW5jdGlvbiggc3RlcHMgKSB7XG5cdFx0dGhpcy5fc3RlcERvd24oIHN0ZXBzICk7XG5cdH0pLFxuXHRfc3RlcERvd246IGZ1bmN0aW9uKCBzdGVwcyApIHtcblx0XHR0aGlzLl9zcGluKCAoc3RlcHMgfHwgMSkgKiAtdGhpcy5vcHRpb25zLnN0ZXAgKTtcblx0fSxcblxuXHRwYWdlVXA6IG1vZGlmaWVyKGZ1bmN0aW9uKCBwYWdlcyApIHtcblx0XHR0aGlzLl9zdGVwVXAoIChwYWdlcyB8fCAxKSAqIHRoaXMub3B0aW9ucy5wYWdlICk7XG5cdH0pLFxuXG5cdHBhZ2VEb3duOiBtb2RpZmllcihmdW5jdGlvbiggcGFnZXMgKSB7XG5cdFx0dGhpcy5fc3RlcERvd24oIChwYWdlcyB8fCAxKSAqIHRoaXMub3B0aW9ucy5wYWdlICk7XG5cdH0pLFxuXG5cdHZhbHVlOiBmdW5jdGlvbiggbmV3VmFsICkge1xuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcGFyc2UoIHRoaXMuZWxlbWVudC52YWwoKSApO1xuXHRcdH1cblx0XHRtb2RpZmllciggdGhpcy5fdmFsdWUgKS5jYWxsKCB0aGlzLCBuZXdWYWwgKTtcblx0fSxcblxuXHR3aWRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnVpU3Bpbm5lcjtcblx0fVxufSk7XG5cbn0oIGpRdWVyeSApICk7XG4oZnVuY3Rpb24oICQsIHVuZGVmaW5lZCApIHtcblxudmFyIHRhYklkID0gMCxcblx0cmhhc2ggPSAvIy4qJC87XG5cbmZ1bmN0aW9uIGdldE5leHRUYWJJZCgpIHtcblx0cmV0dXJuICsrdGFiSWQ7XG59XG5cbmZ1bmN0aW9uIGlzTG9jYWwoIGFuY2hvciApIHtcblx0cmV0dXJuIGFuY2hvci5oYXNoLmxlbmd0aCA+IDEgJiZcblx0XHRhbmNob3IuaHJlZi5yZXBsYWNlKCByaGFzaCwgXCJcIiApID09PVxuXHRcdFx0bG9jYXRpb24uaHJlZi5yZXBsYWNlKCByaGFzaCwgXCJcIiApXG5cdFx0XHRcdC8vIHN1cHBvcnQ6IFNhZmFyaSA1LjFcblx0XHRcdFx0Ly8gU2FmYXJpIDUuMSBkb2Vzbid0IGVuY29kZSBzcGFjZXMgaW4gd2luZG93LmxvY2F0aW9uXG5cdFx0XHRcdC8vIGJ1dCBpdCBkb2VzIGVuY29kZSBzcGFjZXMgZnJvbSBhbmNob3JzICgjODc3Nylcblx0XHRcdFx0LnJlcGxhY2UoIC9cXHMvZywgXCIlMjBcIiApO1xufVxuXG4kLndpZGdldCggXCJ1aS50YWJzXCIsIHtcblx0dmVyc2lvbjogXCIxLjkuMlwiLFxuXHRkZWxheTogMzAwLFxuXHRvcHRpb25zOiB7XG5cdFx0YWN0aXZlOiBudWxsLFxuXHRcdGNvbGxhcHNpYmxlOiBmYWxzZSxcblx0XHRldmVudDogXCJjbGlja1wiLFxuXHRcdGhlaWdodFN0eWxlOiBcImNvbnRlbnRcIixcblx0XHRoaWRlOiBudWxsLFxuXHRcdHNob3c6IG51bGwsXG5cblx0XHQvLyBjYWxsYmFja3Ncblx0XHRhY3RpdmF0ZTogbnVsbCxcblx0XHRiZWZvcmVBY3RpdmF0ZTogbnVsbCxcblx0XHRiZWZvcmVMb2FkOiBudWxsLFxuXHRcdGxvYWQ6IG51bGxcblx0fSxcblxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0YWN0aXZlID0gb3B0aW9ucy5hY3RpdmUsXG5cdFx0XHRsb2NhdGlvbkhhc2ggPSBsb2NhdGlvbi5oYXNoLnN1YnN0cmluZyggMSApO1xuXG5cdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC5hZGRDbGFzcyggXCJ1aS10YWJzIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsXCIgKVxuXHRcdFx0LnRvZ2dsZUNsYXNzKCBcInVpLXRhYnMtY29sbGFwc2libGVcIiwgb3B0aW9ucy5jb2xsYXBzaWJsZSApXG5cdFx0XHQvLyBQcmV2ZW50IHVzZXJzIGZyb20gZm9jdXNpbmcgZGlzYWJsZWQgdGFicyB2aWEgY2xpY2tcblx0XHRcdC5kZWxlZ2F0ZSggXCIudWktdGFicy1uYXYgPiBsaVwiLCBcIm1vdXNlZG93blwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoICQoIHRoaXMgKS5pcyggXCIudWktc3RhdGUtZGlzYWJsZWRcIiApICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQvLyBzdXBwb3J0OiBJRSA8OVxuXHRcdFx0Ly8gUHJldmVudGluZyB0aGUgZGVmYXVsdCBhY3Rpb24gaW4gbW91c2Vkb3duIGRvZXNuJ3QgcHJldmVudCBJRVxuXHRcdFx0Ly8gZnJvbSBmb2N1c2luZyB0aGUgZWxlbWVudCwgc28gaWYgdGhlIGFuY2hvciBnZXRzIGZvY3VzZWQsIGJsdXIuXG5cdFx0XHQvLyBXZSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IGZvY3VzaW5nIHRoZSBwcmV2aW91c2x5IGZvY3VzZWRcblx0XHRcdC8vIGVsZW1lbnQgc2luY2UgY2xpY2tpbmcgb24gYSBub24tZm9jdXNhYmxlIGVsZW1lbnQgc2hvdWxkIGZvY3VzXG5cdFx0XHQvLyB0aGUgYm9keSBhbnl3YXkuXG5cdFx0XHQuZGVsZWdhdGUoIFwiLnVpLXRhYnMtYW5jaG9yXCIsIFwiZm9jdXNcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICQoIHRoaXMgKS5jbG9zZXN0KCBcImxpXCIgKS5pcyggXCIudWktc3RhdGUtZGlzYWJsZWRcIiApICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdHRoaXMuX3Byb2Nlc3NUYWJzKCk7XG5cblx0XHRpZiAoIGFjdGl2ZSA9PT0gbnVsbCApIHtcblx0XHRcdC8vIGNoZWNrIHRoZSBmcmFnbWVudCBpZGVudGlmaWVyIGluIHRoZSBVUkxcblx0XHRcdGlmICggbG9jYXRpb25IYXNoICkge1xuXHRcdFx0XHR0aGlzLnRhYnMuZWFjaChmdW5jdGlvbiggaSwgdGFiICkge1xuXHRcdFx0XHRcdGlmICggJCggdGFiICkuYXR0ciggXCJhcmlhLWNvbnRyb2xzXCIgKSA9PT0gbG9jYXRpb25IYXNoICkge1xuXHRcdFx0XHRcdFx0YWN0aXZlID0gaTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBmb3IgYSB0YWIgbWFya2VkIGFjdGl2ZSB2aWEgYSBjbGFzc1xuXHRcdFx0aWYgKCBhY3RpdmUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGFjdGl2ZSA9IHRoaXMudGFicy5pbmRleCggdGhpcy50YWJzLmZpbHRlciggXCIudWktdGFicy1hY3RpdmVcIiApICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIG5vIGFjdGl2ZSB0YWIsIHNldCB0byBmYWxzZVxuXHRcdFx0aWYgKCBhY3RpdmUgPT09IG51bGwgfHwgYWN0aXZlID09PSAtMSApIHtcblx0XHRcdFx0YWN0aXZlID0gdGhpcy50YWJzLmxlbmd0aCA/IDAgOiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBoYW5kbGUgbnVtYmVyczogbmVnYXRpdmUsIG91dCBvZiByYW5nZVxuXHRcdGlmICggYWN0aXZlICE9PSBmYWxzZSApIHtcblx0XHRcdGFjdGl2ZSA9IHRoaXMudGFicy5pbmRleCggdGhpcy50YWJzLmVxKCBhY3RpdmUgKSApO1xuXHRcdFx0aWYgKCBhY3RpdmUgPT09IC0xICkge1xuXHRcdFx0XHRhY3RpdmUgPSBvcHRpb25zLmNvbGxhcHNpYmxlID8gZmFsc2UgOiAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRvcHRpb25zLmFjdGl2ZSA9IGFjdGl2ZTtcblxuXHRcdC8vIGRvbid0IGFsbG93IGNvbGxhcHNpYmxlOiBmYWxzZSBhbmQgYWN0aXZlOiBmYWxzZVxuXHRcdGlmICggIW9wdGlvbnMuY29sbGFwc2libGUgJiYgb3B0aW9ucy5hY3RpdmUgPT09IGZhbHNlICYmIHRoaXMuYW5jaG9ycy5sZW5ndGggKSB7XG5cdFx0XHRvcHRpb25zLmFjdGl2ZSA9IDA7XG5cdFx0fVxuXG5cdFx0Ly8gVGFrZSBkaXNhYmxpbmcgdGFicyB2aWEgY2xhc3MgYXR0cmlidXRlIGZyb20gSFRNTFxuXHRcdC8vIGludG8gYWNjb3VudCBhbmQgdXBkYXRlIG9wdGlvbiBwcm9wZXJseS5cblx0XHRpZiAoICQuaXNBcnJheSggb3B0aW9ucy5kaXNhYmxlZCApICkge1xuXHRcdFx0b3B0aW9ucy5kaXNhYmxlZCA9ICQudW5pcXVlKCBvcHRpb25zLmRpc2FibGVkLmNvbmNhdChcblx0XHRcdFx0JC5tYXAoIHRoaXMudGFicy5maWx0ZXIoIFwiLnVpLXN0YXRlLWRpc2FibGVkXCIgKSwgZnVuY3Rpb24oIGxpICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGF0LnRhYnMuaW5kZXgoIGxpICk7XG5cdFx0XHRcdH0pXG5cdFx0XHQpICkuc29ydCgpO1xuXHRcdH1cblxuXHRcdC8vIGNoZWNrIGZvciBsZW5ndGggYXZvaWRzIGVycm9yIHdoZW4gaW5pdGlhbGl6aW5nIGVtcHR5IGxpc3Rcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5hY3RpdmUgIT09IGZhbHNlICYmIHRoaXMuYW5jaG9ycy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLmFjdGl2ZSA9IHRoaXMuX2ZpbmRBY3RpdmUoIHRoaXMub3B0aW9ucy5hY3RpdmUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5hY3RpdmUgPSAkKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcmVmcmVzaCgpO1xuXG5cdFx0aWYgKCB0aGlzLmFjdGl2ZS5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLmxvYWQoIG9wdGlvbnMuYWN0aXZlICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRDcmVhdGVFdmVudERhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0YWI6IHRoaXMuYWN0aXZlLFxuXHRcdFx0cGFuZWw6ICF0aGlzLmFjdGl2ZS5sZW5ndGggPyAkKCkgOiB0aGlzLl9nZXRQYW5lbEZvclRhYiggdGhpcy5hY3RpdmUgKVxuXHRcdH07XG5cdH0sXG5cblx0X3RhYktleWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgZm9jdXNlZFRhYiA9ICQoIHRoaXMuZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudCApLmNsb3Nlc3QoIFwibGlcIiApLFxuXHRcdFx0c2VsZWN0ZWRJbmRleCA9IHRoaXMudGFicy5pbmRleCggZm9jdXNlZFRhYiApLFxuXHRcdFx0Z29pbmdGb3J3YXJkID0gdHJ1ZTtcblxuXHRcdGlmICggdGhpcy5faGFuZGxlUGFnZU5hdiggZXZlbnQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuUklHSFQ6XG5cdFx0XHRjYXNlICQudWkua2V5Q29kZS5ET1dOOlxuXHRcdFx0XHRzZWxlY3RlZEluZGV4Kys7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuVVA6XG5cdFx0XHRjYXNlICQudWkua2V5Q29kZS5MRUZUOlxuXHRcdFx0XHRnb2luZ0ZvcndhcmQgPSBmYWxzZTtcblx0XHRcdFx0c2VsZWN0ZWRJbmRleC0tO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkVORDpcblx0XHRcdFx0c2VsZWN0ZWRJbmRleCA9IHRoaXMuYW5jaG9ycy5sZW5ndGggLSAxO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkhPTUU6XG5cdFx0XHRcdHNlbGVjdGVkSW5kZXggPSAwO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLlNQQUNFOlxuXHRcdFx0XHQvLyBBY3RpdmF0ZSBvbmx5LCBubyBjb2xsYXBzaW5nXG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdGNsZWFyVGltZW91dCggdGhpcy5hY3RpdmF0aW5nICk7XG5cdFx0XHRcdHRoaXMuX2FjdGl2YXRlKCBzZWxlY3RlZEluZGV4ICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkVOVEVSOlxuXHRcdFx0XHQvLyBUb2dnbGUgKGNhbmNlbCBkZWxheWVkIGFjdGl2YXRpb24sIGFsbG93IGNvbGxhcHNpbmcpXG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdGNsZWFyVGltZW91dCggdGhpcy5hY3RpdmF0aW5nICk7XG5cdFx0XHRcdC8vIERldGVybWluZSBpZiB3ZSBzaG91bGQgY29sbGFwc2Ugb3IgYWN0aXZhdGVcblx0XHRcdFx0dGhpcy5fYWN0aXZhdGUoIHNlbGVjdGVkSW5kZXggPT09IHRoaXMub3B0aW9ucy5hY3RpdmUgPyBmYWxzZSA6IHNlbGVjdGVkSW5kZXggKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZvY3VzIHRoZSBhcHByb3ByaWF0ZSB0YWIsIGJhc2VkIG9uIHdoaWNoIGtleSB3YXMgcHJlc3NlZFxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0Y2xlYXJUaW1lb3V0KCB0aGlzLmFjdGl2YXRpbmcgKTtcblx0XHRzZWxlY3RlZEluZGV4ID0gdGhpcy5fZm9jdXNOZXh0VGFiKCBzZWxlY3RlZEluZGV4LCBnb2luZ0ZvcndhcmQgKTtcblxuXHRcdC8vIE5hdmlnYXRpbmcgd2l0aCBjb250cm9sIGtleSB3aWxsIHByZXZlbnQgYXV0b21hdGljIGFjdGl2YXRpb25cblx0XHRpZiAoICFldmVudC5jdHJsS2V5ICkge1xuXHRcdFx0Ly8gVXBkYXRlIGFyaWEtc2VsZWN0ZWQgaW1tZWRpYXRlbHkgc28gdGhhdCBBVCB0aGluayB0aGUgdGFiIGlzIGFscmVhZHkgc2VsZWN0ZWQuXG5cdFx0XHQvLyBPdGhlcndpc2UgQVQgbWF5IGNvbmZ1c2UgdGhlIHVzZXIgYnkgc3RhdGluZyB0aGF0IHRoZXkgbmVlZCB0byBhY3RpdmF0ZSB0aGUgdGFiLFxuXHRcdFx0Ly8gYnV0IHRoZSB0YWIgd2lsbCBhbHJlYWR5IGJlIGFjdGl2YXRlZCBieSB0aGUgdGltZSB0aGUgYW5ub3VuY2VtZW50IGZpbmlzaGVzLlxuXHRcdFx0Zm9jdXNlZFRhYi5hdHRyKCBcImFyaWEtc2VsZWN0ZWRcIiwgXCJmYWxzZVwiICk7XG5cdFx0XHR0aGlzLnRhYnMuZXEoIHNlbGVjdGVkSW5kZXggKS5hdHRyKCBcImFyaWEtc2VsZWN0ZWRcIiwgXCJ0cnVlXCIgKTtcblxuXHRcdFx0dGhpcy5hY3RpdmF0aW5nID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9uKCBcImFjdGl2ZVwiLCBzZWxlY3RlZEluZGV4ICk7XG5cdFx0XHR9LCB0aGlzLmRlbGF5ICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9wYW5lbEtleWRvd246IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoIHRoaXMuX2hhbmRsZVBhZ2VOYXYoIGV2ZW50ICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ3RybCt1cCBtb3ZlcyBmb2N1cyB0byB0aGUgY3VycmVudCB0YWJcblx0XHRpZiAoIGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQua2V5Q29kZSA9PT0gJC51aS5rZXlDb2RlLlVQICkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMuYWN0aXZlLmZvY3VzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEFsdCtwYWdlIHVwL2Rvd24gbW92ZXMgZm9jdXMgdG8gdGhlIHByZXZpb3VzL25leHQgdGFiIChhbmQgYWN0aXZhdGVzKVxuXHRfaGFuZGxlUGFnZU5hdjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggZXZlbnQuYWx0S2V5ICYmIGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5QQUdFX1VQICkge1xuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIHRoaXMuX2ZvY3VzTmV4dFRhYiggdGhpcy5vcHRpb25zLmFjdGl2ZSAtIDEsIGZhbHNlICkgKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRpZiAoIGV2ZW50LmFsdEtleSAmJiBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuUEFHRV9ET1dOICkge1xuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIHRoaXMuX2ZvY3VzTmV4dFRhYiggdGhpcy5vcHRpb25zLmFjdGl2ZSArIDEsIHRydWUgKSApO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdF9maW5kTmV4dFRhYjogZnVuY3Rpb24oIGluZGV4LCBnb2luZ0ZvcndhcmQgKSB7XG5cdFx0dmFyIGxhc3RUYWJJbmRleCA9IHRoaXMudGFicy5sZW5ndGggLSAxO1xuXG5cdFx0ZnVuY3Rpb24gY29uc3RyYWluKCkge1xuXHRcdFx0aWYgKCBpbmRleCA+IGxhc3RUYWJJbmRleCApIHtcblx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdGluZGV4ID0gbGFzdFRhYkluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGluZGV4O1xuXHRcdH1cblxuXHRcdHdoaWxlICggJC5pbkFycmF5KCBjb25zdHJhaW4oKSwgdGhpcy5vcHRpb25zLmRpc2FibGVkICkgIT09IC0xICkge1xuXHRcdFx0aW5kZXggPSBnb2luZ0ZvcndhcmQgPyBpbmRleCArIDEgOiBpbmRleCAtIDE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9LFxuXG5cdF9mb2N1c05leHRUYWI6IGZ1bmN0aW9uKCBpbmRleCwgZ29pbmdGb3J3YXJkICkge1xuXHRcdGluZGV4ID0gdGhpcy5fZmluZE5leHRUYWIoIGluZGV4LCBnb2luZ0ZvcndhcmQgKTtcblx0XHR0aGlzLnRhYnMuZXEoIGluZGV4ICkuZm9jdXMoKTtcblx0XHRyZXR1cm4gaW5kZXg7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0aWYgKCBrZXkgPT09IFwiYWN0aXZlXCIgKSB7XG5cdFx0XHQvLyBfYWN0aXZhdGUoKSB3aWxsIGhhbmRsZSBpbnZhbGlkIHZhbHVlcyBhbmQgdXBkYXRlIHRoaXMub3B0aW9uc1xuXHRcdFx0dGhpcy5fYWN0aXZhdGUoIHZhbHVlICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdC8vIGRvbid0IHVzZSB0aGUgd2lkZ2V0IGZhY3RvcnkncyBkaXNhYmxlZCBoYW5kbGluZ1xuXHRcdFx0dGhpcy5fc2V0dXBEaXNhYmxlZCggdmFsdWUgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSk7XG5cblx0XHRpZiAoIGtleSA9PT0gXCJjb2xsYXBzaWJsZVwiICkge1xuXHRcdFx0dGhpcy5lbGVtZW50LnRvZ2dsZUNsYXNzKCBcInVpLXRhYnMtY29sbGFwc2libGVcIiwgdmFsdWUgKTtcblx0XHRcdC8vIFNldHRpbmcgY29sbGFwc2libGU6IGZhbHNlIHdoaWxlIGNvbGxhcHNlZDsgb3BlbiBmaXJzdCBwYW5lbFxuXHRcdFx0aWYgKCAhdmFsdWUgJiYgdGhpcy5vcHRpb25zLmFjdGl2ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2YXRlKCAwICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IFwiZXZlbnRcIiApIHtcblx0XHRcdHRoaXMuX3NldHVwRXZlbnRzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ID09PSBcImhlaWdodFN0eWxlXCIgKSB7XG5cdFx0XHR0aGlzLl9zZXR1cEhlaWdodFN0eWxlKCB2YWx1ZSApO1xuXHRcdH1cblx0fSxcblxuXHRfdGFiSWQ6IGZ1bmN0aW9uKCB0YWIgKSB7XG5cdFx0cmV0dXJuIHRhYi5hdHRyKCBcImFyaWEtY29udHJvbHNcIiApIHx8IFwidWktdGFicy1cIiArIGdldE5leHRUYWJJZCgpO1xuXHR9LFxuXG5cdF9zYW5pdGl6ZVNlbGVjdG9yOiBmdW5jdGlvbiggaGFzaCApIHtcblx0XHRyZXR1cm4gaGFzaCA/IGhhc2gucmVwbGFjZSggL1shXCIkJSYnKCkqKywuXFwvOjs8PT4/QFxcW1xcXVxcXmB7fH1+XS9nLCBcIlxcXFwkJlwiICkgOiBcIlwiO1xuXHR9LFxuXG5cdHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0bGlzID0gdGhpcy50YWJsaXN0LmNoaWxkcmVuKCBcIjpoYXMoYVtocmVmXSlcIiApO1xuXG5cdFx0Ly8gZ2V0IGRpc2FibGVkIHRhYnMgZnJvbSBjbGFzcyBhdHRyaWJ1dGUgZnJvbSBIVE1MXG5cdFx0Ly8gdGhpcyB3aWxsIGdldCBjb252ZXJ0ZWQgdG8gYSBib29sZWFuIGlmIG5lZWRlZCBpbiBfcmVmcmVzaCgpXG5cdFx0b3B0aW9ucy5kaXNhYmxlZCA9ICQubWFwKCBsaXMuZmlsdGVyKCBcIi51aS1zdGF0ZS1kaXNhYmxlZFwiICksIGZ1bmN0aW9uKCB0YWIgKSB7XG5cdFx0XHRyZXR1cm4gbGlzLmluZGV4KCB0YWIgKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuX3Byb2Nlc3NUYWJzKCk7XG5cblx0XHQvLyB3YXMgY29sbGFwc2VkIG9yIG5vIHRhYnNcblx0XHRpZiAoIG9wdGlvbnMuYWN0aXZlID09PSBmYWxzZSB8fCAhdGhpcy5hbmNob3JzLmxlbmd0aCApIHtcblx0XHRcdG9wdGlvbnMuYWN0aXZlID0gZmFsc2U7XG5cdFx0XHR0aGlzLmFjdGl2ZSA9ICQoKTtcblx0XHQvLyB3YXMgYWN0aXZlLCBidXQgYWN0aXZlIHRhYiBpcyBnb25lXG5cdFx0fSBlbHNlIGlmICggdGhpcy5hY3RpdmUubGVuZ3RoICYmICEkLmNvbnRhaW5zKCB0aGlzLnRhYmxpc3RbIDAgXSwgdGhpcy5hY3RpdmVbIDAgXSApICkge1xuXHRcdFx0Ly8gYWxsIHJlbWFpbmluZyB0YWJzIGFyZSBkaXNhYmxlZFxuXHRcdFx0aWYgKCB0aGlzLnRhYnMubGVuZ3RoID09PSBvcHRpb25zLmRpc2FibGVkLmxlbmd0aCApIHtcblx0XHRcdFx0b3B0aW9ucy5hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5hY3RpdmUgPSAkKCk7XG5cdFx0XHQvLyBhY3RpdmF0ZSBwcmV2aW91cyB0YWJcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2YXRlKCB0aGlzLl9maW5kTmV4dFRhYiggTWF0aC5tYXgoIDAsIG9wdGlvbnMuYWN0aXZlIC0gMSApLCBmYWxzZSApICk7XG5cdFx0XHR9XG5cdFx0Ly8gd2FzIGFjdGl2ZSwgYWN0aXZlIHRhYiBzdGlsbCBleGlzdHNcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gbWFrZSBzdXJlIGFjdGl2ZSBpbmRleCBpcyBjb3JyZWN0XG5cdFx0XHRvcHRpb25zLmFjdGl2ZSA9IHRoaXMudGFicy5pbmRleCggdGhpcy5hY3RpdmUgKTtcblx0XHR9XG5cblx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cdH0sXG5cblx0X3JlZnJlc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3NldHVwRGlzYWJsZWQoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCApO1xuXHRcdHRoaXMuX3NldHVwRXZlbnRzKCB0aGlzLm9wdGlvbnMuZXZlbnQgKTtcblx0XHR0aGlzLl9zZXR1cEhlaWdodFN0eWxlKCB0aGlzLm9wdGlvbnMuaGVpZ2h0U3R5bGUgKTtcblxuXHRcdHRoaXMudGFicy5ub3QoIHRoaXMuYWN0aXZlICkuYXR0cih7XG5cdFx0XHRcImFyaWEtc2VsZWN0ZWRcIjogXCJmYWxzZVwiLFxuXHRcdFx0dGFiSW5kZXg6IC0xXG5cdFx0fSk7XG5cdFx0dGhpcy5wYW5lbHMubm90KCB0aGlzLl9nZXRQYW5lbEZvclRhYiggdGhpcy5hY3RpdmUgKSApXG5cdFx0XHQuaGlkZSgpXG5cdFx0XHQuYXR0cih7XG5cdFx0XHRcdFwiYXJpYS1leHBhbmRlZFwiOiBcImZhbHNlXCIsXG5cdFx0XHRcdFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCJcblx0XHRcdH0pO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIG9uZSB0YWIgaXMgaW4gdGhlIHRhYiBvcmRlclxuXHRcdGlmICggIXRoaXMuYWN0aXZlLmxlbmd0aCApIHtcblx0XHRcdHRoaXMudGFicy5lcSggMCApLmF0dHIoIFwidGFiSW5kZXhcIiwgMCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFjdGl2ZVxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktdGFicy1hY3RpdmUgdWktc3RhdGUtYWN0aXZlXCIgKVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XCJhcmlhLXNlbGVjdGVkXCI6IFwidHJ1ZVwiLFxuXHRcdFx0XHRcdHRhYkluZGV4OiAwXG5cdFx0XHRcdH0pO1xuXHRcdFx0dGhpcy5fZ2V0UGFuZWxGb3JUYWIoIHRoaXMuYWN0aXZlIClcblx0XHRcdFx0LnNob3coKVxuXHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XCJhcmlhLWV4cGFuZGVkXCI6IFwidHJ1ZVwiLFxuXHRcdFx0XHRcdFwiYXJpYS1oaWRkZW5cIjogXCJmYWxzZVwiXG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRfcHJvY2Vzc1RhYnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdHRoaXMudGFibGlzdCA9IHRoaXMuX2dldExpc3QoKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLXRhYnMtbmF2IHVpLWhlbHBlci1yZXNldCB1aS1oZWxwZXItY2xlYXJmaXggdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItYWxsXCIgKVxuXHRcdFx0LmF0dHIoIFwicm9sZVwiLCBcInRhYmxpc3RcIiApO1xuXG5cdFx0dGhpcy50YWJzID0gdGhpcy50YWJsaXN0LmZpbmQoIFwiPiBsaTpoYXMoYVtocmVmXSlcIiApXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItdG9wXCIgKVxuXHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRyb2xlOiBcInRhYlwiLFxuXHRcdFx0XHR0YWJJbmRleDogLTFcblx0XHRcdH0pO1xuXG5cdFx0dGhpcy5hbmNob3JzID0gdGhpcy50YWJzLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICQoIFwiYVwiLCB0aGlzIClbIDAgXTtcblx0XHRcdH0pXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktdGFicy1hbmNob3JcIiApXG5cdFx0XHQuYXR0cih7XG5cdFx0XHRcdHJvbGU6IFwicHJlc2VudGF0aW9uXCIsXG5cdFx0XHRcdHRhYkluZGV4OiAtMVxuXHRcdFx0fSk7XG5cblx0XHR0aGlzLnBhbmVscyA9ICQoKTtcblxuXHRcdHRoaXMuYW5jaG9ycy5lYWNoKGZ1bmN0aW9uKCBpLCBhbmNob3IgKSB7XG5cdFx0XHR2YXIgc2VsZWN0b3IsIHBhbmVsLCBwYW5lbElkLFxuXHRcdFx0XHRhbmNob3JJZCA9ICQoIGFuY2hvciApLnVuaXF1ZUlkKCkuYXR0ciggXCJpZFwiICksXG5cdFx0XHRcdHRhYiA9ICQoIGFuY2hvciApLmNsb3Nlc3QoIFwibGlcIiApLFxuXHRcdFx0XHRvcmlnaW5hbEFyaWFDb250cm9scyA9IHRhYi5hdHRyKCBcImFyaWEtY29udHJvbHNcIiApO1xuXG5cdFx0XHQvLyBpbmxpbmUgdGFiXG5cdFx0XHRpZiAoIGlzTG9jYWwoIGFuY2hvciApICkge1xuXHRcdFx0XHRzZWxlY3RvciA9IGFuY2hvci5oYXNoO1xuXHRcdFx0XHRwYW5lbCA9IHRoYXQuZWxlbWVudC5maW5kKCB0aGF0Ll9zYW5pdGl6ZVNlbGVjdG9yKCBzZWxlY3RvciApICk7XG5cdFx0XHQvLyByZW1vdGUgdGFiXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYW5lbElkID0gdGhhdC5fdGFiSWQoIHRhYiApO1xuXHRcdFx0XHRzZWxlY3RvciA9IFwiI1wiICsgcGFuZWxJZDtcblx0XHRcdFx0cGFuZWwgPSB0aGF0LmVsZW1lbnQuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdFx0aWYgKCAhcGFuZWwubGVuZ3RoICkge1xuXHRcdFx0XHRcdHBhbmVsID0gdGhhdC5fY3JlYXRlUGFuZWwoIHBhbmVsSWQgKTtcblx0XHRcdFx0XHRwYW5lbC5pbnNlcnRBZnRlciggdGhhdC5wYW5lbHNbIGkgLSAxIF0gfHwgdGhhdC50YWJsaXN0ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFuZWwuYXR0ciggXCJhcmlhLWxpdmVcIiwgXCJwb2xpdGVcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHBhbmVsLmxlbmd0aCkge1xuXHRcdFx0XHR0aGF0LnBhbmVscyA9IHRoYXQucGFuZWxzLmFkZCggcGFuZWwgKTtcblx0XHRcdH1cblx0XHRcdGlmICggb3JpZ2luYWxBcmlhQ29udHJvbHMgKSB7XG5cdFx0XHRcdHRhYi5kYXRhKCBcInVpLXRhYnMtYXJpYS1jb250cm9sc1wiLCBvcmlnaW5hbEFyaWFDb250cm9scyApO1xuXHRcdFx0fVxuXHRcdFx0dGFiLmF0dHIoe1xuXHRcdFx0XHRcImFyaWEtY29udHJvbHNcIjogc2VsZWN0b3Iuc3Vic3RyaW5nKCAxICksXG5cdFx0XHRcdFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGFuY2hvcklkXG5cdFx0XHR9KTtcblx0XHRcdHBhbmVsLmF0dHIoIFwiYXJpYS1sYWJlbGxlZGJ5XCIsIGFuY2hvcklkICk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnBhbmVsc1xuXHRcdFx0LmFkZENsYXNzKCBcInVpLXRhYnMtcGFuZWwgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWJvdHRvbVwiIClcblx0XHRcdC5hdHRyKCBcInJvbGVcIiwgXCJ0YWJwYW5lbFwiICk7XG5cdH0sXG5cblx0Ly8gYWxsb3cgb3ZlcnJpZGluZyBob3cgdG8gZmluZCB0aGUgbGlzdCBmb3IgcmFyZSB1c2FnZSBzY2VuYXJpb3MgKCM3NzE1KVxuXHRfZ2V0TGlzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5maW5kKCBcIm9sLHVsXCIgKS5lcSggMCApO1xuXHR9LFxuXG5cdF9jcmVhdGVQYW5lbDogZnVuY3Rpb24oIGlkICkge1xuXHRcdHJldHVybiAkKCBcIjxkaXY+XCIgKVxuXHRcdFx0LmF0dHIoIFwiaWRcIiwgaWQgKVxuXHRcdFx0LmFkZENsYXNzKCBcInVpLXRhYnMtcGFuZWwgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWJvdHRvbVwiIClcblx0XHRcdC5kYXRhKCBcInVpLXRhYnMtZGVzdHJveVwiLCB0cnVlICk7XG5cdH0sXG5cblx0X3NldHVwRGlzYWJsZWQ6IGZ1bmN0aW9uKCBkaXNhYmxlZCApIHtcblx0XHRpZiAoICQuaXNBcnJheSggZGlzYWJsZWQgKSApIHtcblx0XHRcdGlmICggIWRpc2FibGVkLmxlbmd0aCApIHtcblx0XHRcdFx0ZGlzYWJsZWQgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIGRpc2FibGVkLmxlbmd0aCA9PT0gdGhpcy5hbmNob3JzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGRpc2FibGUgdGFic1xuXHRcdGZvciAoIHZhciBpID0gMCwgbGk7ICggbGkgPSB0aGlzLnRhYnNbIGkgXSApOyBpKysgKSB7XG5cdFx0XHRpZiAoIGRpc2FibGVkID09PSB0cnVlIHx8ICQuaW5BcnJheSggaSwgZGlzYWJsZWQgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdCQoIGxpIClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiApXG5cdFx0XHRcdFx0LmF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiLCBcInRydWVcIiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JCggbGkgKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiIClcblx0XHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWRpc2FibGVkXCIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLm9wdGlvbnMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcblx0fSxcblxuXHRfc2V0dXBFdmVudHM6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0Y2xpY2s6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGlmICggZXZlbnQgKSB7XG5cdFx0XHQkLmVhY2goIGV2ZW50LnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oIGluZGV4LCBldmVudE5hbWUgKSB7XG5cdFx0XHRcdGV2ZW50c1sgZXZlbnROYW1lIF0gPSBcIl9ldmVudEhhbmRsZXJcIjtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuX29mZiggdGhpcy5hbmNob3JzLmFkZCggdGhpcy50YWJzICkuYWRkKCB0aGlzLnBhbmVscyApICk7XG5cdFx0dGhpcy5fb24oIHRoaXMuYW5jaG9ycywgZXZlbnRzICk7XG5cdFx0dGhpcy5fb24oIHRoaXMudGFicywgeyBrZXlkb3duOiBcIl90YWJLZXlkb3duXCIgfSApO1xuXHRcdHRoaXMuX29uKCB0aGlzLnBhbmVscywgeyBrZXlkb3duOiBcIl9wYW5lbEtleWRvd25cIiB9ICk7XG5cblx0XHR0aGlzLl9mb2N1c2FibGUoIHRoaXMudGFicyApO1xuXHRcdHRoaXMuX2hvdmVyYWJsZSggdGhpcy50YWJzICk7XG5cdH0sXG5cblx0X3NldHVwSGVpZ2h0U3R5bGU6IGZ1bmN0aW9uKCBoZWlnaHRTdHlsZSApIHtcblx0XHR2YXIgbWF4SGVpZ2h0LCBvdmVyZmxvdyxcblx0XHRcdHBhcmVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnQoKTtcblxuXHRcdGlmICggaGVpZ2h0U3R5bGUgPT09IFwiZmlsbFwiICkge1xuXHRcdFx0Ly8gSUUgNiB0cmVhdHMgaGVpZ2h0IGxpa2UgbWluSGVpZ2h0LCBzbyB3ZSBuZWVkIHRvIHR1cm4gb2ZmIG92ZXJmbG93XG5cdFx0XHQvLyBpbiBvcmRlciB0byBnZXQgYSByZWxpYWJsZSBoZWlnaHRcblx0XHRcdC8vIHdlIHVzZSB0aGUgbWluSGVpZ2h0IHN1cHBvcnQgdGVzdCBiZWNhdXNlIHdlIGFzc3VtZSB0aGF0IG9ubHlcblx0XHRcdC8vIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBtaW5IZWlnaHQgd2lsbCB0cmVhdCBoZWlnaHQgYXMgbWluSGVpZ2h0XG5cdFx0XHRpZiAoICEkLnN1cHBvcnQubWluSGVpZ2h0ICkge1xuXHRcdFx0XHRvdmVyZmxvdyA9IHBhcmVudC5jc3MoIFwib3ZlcmZsb3dcIiApO1xuXHRcdFx0XHRwYXJlbnQuY3NzKCBcIm92ZXJmbG93XCIsIFwiaGlkZGVuXCIpO1xuXHRcdFx0fVxuXHRcdFx0bWF4SGVpZ2h0ID0gcGFyZW50LmhlaWdodCgpO1xuXHRcdFx0dGhpcy5lbGVtZW50LnNpYmxpbmdzKCBcIjp2aXNpYmxlXCIgKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9ICQoIHRoaXMgKSxcblx0XHRcdFx0XHRwb3NpdGlvbiA9IGVsZW0uY3NzKCBcInBvc2l0aW9uXCIgKTtcblxuXHRcdFx0XHRpZiAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0bWF4SGVpZ2h0IC09IGVsZW0ub3V0ZXJIZWlnaHQoIHRydWUgKTtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKCBvdmVyZmxvdyApIHtcblx0XHRcdFx0cGFyZW50LmNzcyggXCJvdmVyZmxvd1wiLCBvdmVyZmxvdyApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmVsZW1lbnQuY2hpbGRyZW4oKS5ub3QoIHRoaXMucGFuZWxzICkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0bWF4SGVpZ2h0IC09ICQoIHRoaXMgKS5vdXRlckhlaWdodCggdHJ1ZSApO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMucGFuZWxzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5oZWlnaHQoIE1hdGgubWF4KCAwLCBtYXhIZWlnaHQgLVxuXHRcdFx0XHRcdCQoIHRoaXMgKS5pbm5lckhlaWdodCgpICsgJCggdGhpcyApLmhlaWdodCgpICkgKTtcblx0XHRcdH0pXG5cdFx0XHQuY3NzKCBcIm92ZXJmbG93XCIsIFwiYXV0b1wiICk7XG5cdFx0fSBlbHNlIGlmICggaGVpZ2h0U3R5bGUgPT09IFwiYXV0b1wiICkge1xuXHRcdFx0bWF4SGVpZ2h0ID0gMDtcblx0XHRcdHRoaXMucGFuZWxzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdG1heEhlaWdodCA9IE1hdGgubWF4KCBtYXhIZWlnaHQsICQoIHRoaXMgKS5oZWlnaHQoIFwiXCIgKS5oZWlnaHQoKSApO1xuXHRcdFx0fSkuaGVpZ2h0KCBtYXhIZWlnaHQgKTtcblx0XHR9XG5cdH0sXG5cblx0X2V2ZW50SGFuZGxlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0YWN0aXZlID0gdGhpcy5hY3RpdmUsXG5cdFx0XHRhbmNob3IgPSAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksXG5cdFx0XHR0YWIgPSBhbmNob3IuY2xvc2VzdCggXCJsaVwiICksXG5cdFx0XHRjbGlja2VkSXNBY3RpdmUgPSB0YWJbIDAgXSA9PT0gYWN0aXZlWyAwIF0sXG5cdFx0XHRjb2xsYXBzaW5nID0gY2xpY2tlZElzQWN0aXZlICYmIG9wdGlvbnMuY29sbGFwc2libGUsXG5cdFx0XHR0b1Nob3cgPSBjb2xsYXBzaW5nID8gJCgpIDogdGhpcy5fZ2V0UGFuZWxGb3JUYWIoIHRhYiApLFxuXHRcdFx0dG9IaWRlID0gIWFjdGl2ZS5sZW5ndGggPyAkKCkgOiB0aGlzLl9nZXRQYW5lbEZvclRhYiggYWN0aXZlICksXG5cdFx0XHRldmVudERhdGEgPSB7XG5cdFx0XHRcdG9sZFRhYjogYWN0aXZlLFxuXHRcdFx0XHRvbGRQYW5lbDogdG9IaWRlLFxuXHRcdFx0XHRuZXdUYWI6IGNvbGxhcHNpbmcgPyAkKCkgOiB0YWIsXG5cdFx0XHRcdG5ld1BhbmVsOiB0b1Nob3dcblx0XHRcdH07XG5cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0aWYgKCB0YWIuaGFzQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiApIHx8XG5cdFx0XHRcdC8vIHRhYiBpcyBhbHJlYWR5IGxvYWRpbmdcblx0XHRcdFx0dGFiLmhhc0NsYXNzKCBcInVpLXRhYnMtbG9hZGluZ1wiICkgfHxcblx0XHRcdFx0Ly8gY2FuJ3Qgc3dpdGNoIGR1cm5pbmcgYW4gYW5pbWF0aW9uXG5cdFx0XHRcdHRoaXMucnVubmluZyB8fFxuXHRcdFx0XHQvLyBjbGljayBvbiBhY3RpdmUgaGVhZGVyLCBidXQgbm90IGNvbGxhcHNpYmxlXG5cdFx0XHRcdCggY2xpY2tlZElzQWN0aXZlICYmICFvcHRpb25zLmNvbGxhcHNpYmxlICkgfHxcblx0XHRcdFx0Ly8gYWxsb3cgY2FuY2VsaW5nIGFjdGl2YXRpb25cblx0XHRcdFx0KCB0aGlzLl90cmlnZ2VyKCBcImJlZm9yZUFjdGl2YXRlXCIsIGV2ZW50LCBldmVudERhdGEgKSA9PT0gZmFsc2UgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRvcHRpb25zLmFjdGl2ZSA9IGNvbGxhcHNpbmcgPyBmYWxzZSA6IHRoaXMudGFicy5pbmRleCggdGFiICk7XG5cblx0XHR0aGlzLmFjdGl2ZSA9IGNsaWNrZWRJc0FjdGl2ZSA/ICQoKSA6IHRhYjtcblx0XHRpZiAoIHRoaXMueGhyICkge1xuXHRcdFx0dGhpcy54aHIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHRpZiAoICF0b0hpZGUubGVuZ3RoICYmICF0b1Nob3cubGVuZ3RoICkge1xuXHRcdFx0JC5lcnJvciggXCJqUXVlcnkgVUkgVGFiczogTWlzbWF0Y2hpbmcgZnJhZ21lbnQgaWRlbnRpZmllci5cIiApO1xuXHRcdH1cblxuXHRcdGlmICggdG9TaG93Lmxlbmd0aCApIHtcblx0XHRcdHRoaXMubG9hZCggdGhpcy50YWJzLmluZGV4KCB0YWIgKSwgZXZlbnQgKTtcblx0XHR9XG5cdFx0dGhpcy5fdG9nZ2xlKCBldmVudCwgZXZlbnREYXRhICk7XG5cdH0sXG5cblx0Ly8gaGFuZGxlcyBzaG93L2hpZGUgZm9yIHNlbGVjdGluZyB0YWJzXG5cdF90b2dnbGU6IGZ1bmN0aW9uKCBldmVudCwgZXZlbnREYXRhICkge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdHRvU2hvdyA9IGV2ZW50RGF0YS5uZXdQYW5lbCxcblx0XHRcdHRvSGlkZSA9IGV2ZW50RGF0YS5vbGRQYW5lbDtcblxuXHRcdHRoaXMucnVubmluZyA9IHRydWU7XG5cblx0XHRmdW5jdGlvbiBjb21wbGV0ZSgpIHtcblx0XHRcdHRoYXQucnVubmluZyA9IGZhbHNlO1xuXHRcdFx0dGhhdC5fdHJpZ2dlciggXCJhY3RpdmF0ZVwiLCBldmVudCwgZXZlbnREYXRhICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2hvdygpIHtcblx0XHRcdGV2ZW50RGF0YS5uZXdUYWIuY2xvc2VzdCggXCJsaVwiICkuYWRkQ2xhc3MoIFwidWktdGFicy1hY3RpdmUgdWktc3RhdGUtYWN0aXZlXCIgKTtcblxuXHRcdFx0aWYgKCB0b1Nob3cubGVuZ3RoICYmIHRoYXQub3B0aW9ucy5zaG93ICkge1xuXHRcdFx0XHR0aGF0Ll9zaG93KCB0b1Nob3csIHRoYXQub3B0aW9ucy5zaG93LCBjb21wbGV0ZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG9TaG93LnNob3coKTtcblx0XHRcdFx0Y29tcGxldGUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzdGFydCBvdXQgYnkgaGlkaW5nLCB0aGVuIHNob3dpbmcsIHRoZW4gY29tcGxldGluZ1xuXHRcdGlmICggdG9IaWRlLmxlbmd0aCAmJiB0aGlzLm9wdGlvbnMuaGlkZSApIHtcblx0XHRcdHRoaXMuX2hpZGUoIHRvSGlkZSwgdGhpcy5vcHRpb25zLmhpZGUsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRldmVudERhdGEub2xkVGFiLmNsb3Nlc3QoIFwibGlcIiApLnJlbW92ZUNsYXNzKCBcInVpLXRhYnMtYWN0aXZlIHVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHRcdHNob3coKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRldmVudERhdGEub2xkVGFiLmNsb3Nlc3QoIFwibGlcIiApLnJlbW92ZUNsYXNzKCBcInVpLXRhYnMtYWN0aXZlIHVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHR0b0hpZGUuaGlkZSgpO1xuXHRcdFx0c2hvdygpO1xuXHRcdH1cblxuXHRcdHRvSGlkZS5hdHRyKHtcblx0XHRcdFwiYXJpYS1leHBhbmRlZFwiOiBcImZhbHNlXCIsXG5cdFx0XHRcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiXG5cdFx0fSk7XG5cdFx0ZXZlbnREYXRhLm9sZFRhYi5hdHRyKCBcImFyaWEtc2VsZWN0ZWRcIiwgXCJmYWxzZVwiICk7XG5cdFx0Ly8gSWYgd2UncmUgc3dpdGNoaW5nIHRhYnMsIHJlbW92ZSB0aGUgb2xkIHRhYiBmcm9tIHRoZSB0YWIgb3JkZXIuXG5cdFx0Ly8gSWYgd2UncmUgb3BlbmluZyBmcm9tIGNvbGxhcHNlZCBzdGF0ZSwgcmVtb3ZlIHRoZSBwcmV2aW91cyB0YWIgZnJvbSB0aGUgdGFiIG9yZGVyLlxuXHRcdC8vIElmIHdlJ3JlIGNvbGxhcHNpbmcsIHRoZW4ga2VlcCB0aGUgY29sbGFwc2luZyB0YWIgaW4gdGhlIHRhYiBvcmRlci5cblx0XHRpZiAoIHRvU2hvdy5sZW5ndGggJiYgdG9IaWRlLmxlbmd0aCApIHtcblx0XHRcdGV2ZW50RGF0YS5vbGRUYWIuYXR0ciggXCJ0YWJJbmRleFwiLCAtMSApO1xuXHRcdH0gZWxzZSBpZiAoIHRvU2hvdy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLnRhYnMuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJCggdGhpcyApLmF0dHIoIFwidGFiSW5kZXhcIiApID09PSAwO1xuXHRcdFx0fSlcblx0XHRcdC5hdHRyKCBcInRhYkluZGV4XCIsIC0xICk7XG5cdFx0fVxuXG5cdFx0dG9TaG93LmF0dHIoe1xuXHRcdFx0XCJhcmlhLWV4cGFuZGVkXCI6IFwidHJ1ZVwiLFxuXHRcdFx0XCJhcmlhLWhpZGRlblwiOiBcImZhbHNlXCJcblx0XHR9KTtcblx0XHRldmVudERhdGEubmV3VGFiLmF0dHIoe1xuXHRcdFx0XCJhcmlhLXNlbGVjdGVkXCI6IFwidHJ1ZVwiLFxuXHRcdFx0dGFiSW5kZXg6IDBcblx0XHR9KTtcblx0fSxcblxuXHRfYWN0aXZhdGU6IGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHR2YXIgYW5jaG9yLFxuXHRcdFx0YWN0aXZlID0gdGhpcy5fZmluZEFjdGl2ZSggaW5kZXggKTtcblxuXHRcdC8vIHRyeWluZyB0byBhY3RpdmF0ZSB0aGUgYWxyZWFkeSBhY3RpdmUgcGFuZWxcblx0XHRpZiAoIGFjdGl2ZVsgMCBdID09PSB0aGlzLmFjdGl2ZVsgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIHRyeWluZyB0byBjb2xsYXBzZSwgc2ltdWxhdGUgYSBjbGljayBvbiB0aGUgY3VycmVudCBhY3RpdmUgaGVhZGVyXG5cdFx0aWYgKCAhYWN0aXZlLmxlbmd0aCApIHtcblx0XHRcdGFjdGl2ZSA9IHRoaXMuYWN0aXZlO1xuXHRcdH1cblxuXHRcdGFuY2hvciA9IGFjdGl2ZS5maW5kKCBcIi51aS10YWJzLWFuY2hvclwiIClbIDAgXTtcblx0XHR0aGlzLl9ldmVudEhhbmRsZXIoe1xuXHRcdFx0dGFyZ2V0OiBhbmNob3IsXG5cdFx0XHRjdXJyZW50VGFyZ2V0OiBhbmNob3IsXG5cdFx0XHRwcmV2ZW50RGVmYXVsdDogJC5ub29wXG5cdFx0fSk7XG5cdH0sXG5cblx0X2ZpbmRBY3RpdmU6IGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRyZXR1cm4gaW5kZXggPT09IGZhbHNlID8gJCgpIDogdGhpcy50YWJzLmVxKCBpbmRleCApO1xuXHR9LFxuXG5cdF9nZXRJbmRleDogZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdC8vIG1ldGEtZnVuY3Rpb24gdG8gZ2l2ZSB1c2VycyBvcHRpb24gdG8gcHJvdmlkZSBhIGhyZWYgc3RyaW5nIGluc3RlYWQgb2YgYSBudW1lcmljYWwgaW5kZXguXG5cdFx0aWYgKCB0eXBlb2YgaW5kZXggPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpbmRleCA9IHRoaXMuYW5jaG9ycy5pbmRleCggdGhpcy5hbmNob3JzLmZpbHRlciggXCJbaHJlZiQ9J1wiICsgaW5kZXggKyBcIiddXCIgKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBpbmRleDtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCB0aGlzLnhociApIHtcblx0XHRcdHRoaXMueGhyLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKCBcInVpLXRhYnMgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwgdWktdGFicy1jb2xsYXBzaWJsZVwiICk7XG5cblx0XHR0aGlzLnRhYmxpc3Rcblx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS10YWJzLW5hdiB1aS1oZWxwZXItcmVzZXQgdWktaGVscGVyLWNsZWFyZml4IHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLWFsbFwiIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcInJvbGVcIiApO1xuXG5cdFx0dGhpcy5hbmNob3JzXG5cdFx0XHQucmVtb3ZlQ2xhc3MoIFwidWktdGFicy1hbmNob3JcIiApXG5cdFx0XHQucmVtb3ZlQXR0ciggXCJyb2xlXCIgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwidGFiSW5kZXhcIiApXG5cdFx0XHQucmVtb3ZlRGF0YSggXCJocmVmLnRhYnNcIiApXG5cdFx0XHQucmVtb3ZlRGF0YSggXCJsb2FkLnRhYnNcIiApXG5cdFx0XHQucmVtb3ZlVW5pcXVlSWQoKTtcblxuXHRcdHRoaXMudGFicy5hZGQoIHRoaXMucGFuZWxzICkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggJC5kYXRhKCB0aGlzLCBcInVpLXRhYnMtZGVzdHJveVwiICkgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCQoIHRoaXMgKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1kZWZhdWx0IHVpLXN0YXRlLWFjdGl2ZSB1aS1zdGF0ZS1kaXNhYmxlZCBcIiArXG5cdFx0XHRcdFx0XHRcInVpLWNvcm5lci10b3AgdWktY29ybmVyLWJvdHRvbSB1aS13aWRnZXQtY29udGVudCB1aS10YWJzLWFjdGl2ZSB1aS10YWJzLXBhbmVsXCIgKVxuXHRcdFx0XHRcdC5yZW1vdmVBdHRyKCBcInRhYkluZGV4XCIgKVxuXHRcdFx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtbGl2ZVwiIClcblx0XHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWJ1c3lcIiApXG5cdFx0XHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1zZWxlY3RlZFwiIClcblx0XHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWxhYmVsbGVkYnlcIiApXG5cdFx0XHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1oaWRkZW5cIiApXG5cdFx0XHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1leHBhbmRlZFwiIClcblx0XHRcdFx0XHQucmVtb3ZlQXR0ciggXCJyb2xlXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMudGFicy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGxpID0gJCggdGhpcyApLFxuXHRcdFx0XHRwcmV2ID0gbGkuZGF0YSggXCJ1aS10YWJzLWFyaWEtY29udHJvbHNcIiApO1xuXHRcdFx0aWYgKCBwcmV2ICkge1xuXHRcdFx0XHRsaS5hdHRyKCBcImFyaWEtY29udHJvbHNcIiwgcHJldiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGkucmVtb3ZlQXR0ciggXCJhcmlhLWNvbnRyb2xzXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMucGFuZWxzLnNob3coKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmhlaWdodFN0eWxlICE9PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdHRoaXMucGFuZWxzLmNzcyggXCJoZWlnaHRcIiwgXCJcIiApO1xuXHRcdH1cblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHR2YXIgZGlzYWJsZWQgPSB0aGlzLm9wdGlvbnMuZGlzYWJsZWQ7XG5cdFx0aWYgKCBkaXNhYmxlZCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0ZGlzYWJsZWQgPSBmYWxzZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5kZXggPSB0aGlzLl9nZXRJbmRleCggaW5kZXggKTtcblx0XHRcdGlmICggJC5pc0FycmF5KCBkaXNhYmxlZCApICkge1xuXHRcdFx0XHRkaXNhYmxlZCA9ICQubWFwKCBkaXNhYmxlZCwgZnVuY3Rpb24oIG51bSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVtICE9PSBpbmRleCA/IG51bSA6IG51bGw7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGlzYWJsZWQgPSAkLm1hcCggdGhpcy50YWJzLCBmdW5jdGlvbiggbGksIG51bSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVtICE9PSBpbmRleCA/IG51bSA6IG51bGw7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9zZXR1cERpc2FibGVkKCBkaXNhYmxlZCApO1xuXHR9LFxuXG5cdGRpc2FibGU6IGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHR2YXIgZGlzYWJsZWQgPSB0aGlzLm9wdGlvbnMuZGlzYWJsZWQ7XG5cdFx0aWYgKCBkaXNhYmxlZCA9PT0gdHJ1ZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRkaXNhYmxlZCA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGluZGV4ID0gdGhpcy5fZ2V0SW5kZXgoIGluZGV4ICk7XG5cdFx0XHRpZiAoICQuaW5BcnJheSggaW5kZXgsIGRpc2FibGVkICkgIT09IC0xICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoICQuaXNBcnJheSggZGlzYWJsZWQgKSApIHtcblx0XHRcdFx0ZGlzYWJsZWQgPSAkLm1lcmdlKCBbIGluZGV4IF0sIGRpc2FibGVkICkuc29ydCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGlzYWJsZWQgPSBbIGluZGV4IF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX3NldHVwRGlzYWJsZWQoIGRpc2FibGVkICk7XG5cdH0sXG5cblx0bG9hZDogZnVuY3Rpb24oIGluZGV4LCBldmVudCApIHtcblx0XHRpbmRleCA9IHRoaXMuX2dldEluZGV4KCBpbmRleCApO1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdHRhYiA9IHRoaXMudGFicy5lcSggaW5kZXggKSxcblx0XHRcdGFuY2hvciA9IHRhYi5maW5kKCBcIi51aS10YWJzLWFuY2hvclwiICksXG5cdFx0XHRwYW5lbCA9IHRoaXMuX2dldFBhbmVsRm9yVGFiKCB0YWIgKSxcblx0XHRcdGV2ZW50RGF0YSA9IHtcblx0XHRcdFx0dGFiOiB0YWIsXG5cdFx0XHRcdHBhbmVsOiBwYW5lbFxuXHRcdFx0fTtcblxuXHRcdC8vIG5vdCByZW1vdGVcblx0XHRpZiAoIGlzTG9jYWwoIGFuY2hvclsgMCBdICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy54aHIgPSAkLmFqYXgoIHRoaXMuX2FqYXhTZXR0aW5ncyggYW5jaG9yLCBldmVudCwgZXZlbnREYXRhICkgKTtcblxuXHRcdC8vIHN1cHBvcnQ6IGpRdWVyeSA8MS44XG5cdFx0Ly8galF1ZXJ5IDwxLjggcmV0dXJucyBmYWxzZSBpZiB0aGUgcmVxdWVzdCBpcyBjYW5jZWxlZCBpbiBiZWZvcmVTZW5kLFxuXHRcdC8vIGJ1dCBhcyBvZiAxLjgsICQuYWpheCgpIGFsd2F5cyByZXR1cm5zIGEganFYSFIgb2JqZWN0LlxuXHRcdGlmICggdGhpcy54aHIgJiYgdGhpcy54aHIuc3RhdHVzVGV4dCAhPT0gXCJjYW5jZWxlZFwiICkge1xuXHRcdFx0dGFiLmFkZENsYXNzKCBcInVpLXRhYnMtbG9hZGluZ1wiICk7XG5cdFx0XHRwYW5lbC5hdHRyKCBcImFyaWEtYnVzeVwiLCBcInRydWVcIiApO1xuXG5cdFx0XHR0aGlzLnhoclxuXHRcdFx0XHQuc3VjY2VzcyhmdW5jdGlvbiggcmVzcG9uc2UgKSB7XG5cdFx0XHRcdFx0Ly8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcblx0XHRcdFx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMTc3OFxuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRwYW5lbC5odG1sKCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0dGhhdC5fdHJpZ2dlciggXCJsb2FkXCIsIGV2ZW50LCBldmVudERhdGEgKTtcblx0XHRcdFx0XHR9LCAxICk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5jb21wbGV0ZShmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdFx0XHQvLyBzdXBwb3J0OiBqUXVlcnkgPDEuOFxuXHRcdFx0XHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzExNzc4XG5cdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggc3RhdHVzID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdHRoYXQucGFuZWxzLnN0b3AoIGZhbHNlLCB0cnVlICk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRhYi5yZW1vdmVDbGFzcyggXCJ1aS10YWJzLWxvYWRpbmdcIiApO1xuXHRcdFx0XHRcdFx0cGFuZWwucmVtb3ZlQXR0ciggXCJhcmlhLWJ1c3lcIiApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGpxWEhSID09PSB0aGF0LnhociApIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHRoYXQueGhyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIDEgKTtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFRPRE86IFJlbW92ZSB0aGlzIGZ1bmN0aW9uIGluIDEuMTAgd2hlbiBhamF4T3B0aW9ucyBpcyByZW1vdmVkXG5cdF9hamF4U2V0dGluZ3M6IGZ1bmN0aW9uKCBhbmNob3IsIGV2ZW50LCBldmVudERhdGEgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHJldHVybiB7XG5cdFx0XHR1cmw6IGFuY2hvci5hdHRyKCBcImhyZWZcIiApLFxuXHRcdFx0YmVmb3JlU2VuZDogZnVuY3Rpb24oIGpxWEhSLCBzZXR0aW5ncyApIHtcblx0XHRcdFx0cmV0dXJuIHRoYXQuX3RyaWdnZXIoIFwiYmVmb3JlTG9hZFwiLCBldmVudCxcblx0XHRcdFx0XHQkLmV4dGVuZCggeyBqcVhIUiA6IGpxWEhSLCBhamF4U2V0dGluZ3M6IHNldHRpbmdzIH0sIGV2ZW50RGF0YSApICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSxcblxuXHRfZ2V0UGFuZWxGb3JUYWI6IGZ1bmN0aW9uKCB0YWIgKSB7XG5cdFx0dmFyIGlkID0gJCggdGFiICkuYXR0ciggXCJhcmlhLWNvbnRyb2xzXCIgKTtcblx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LmZpbmQoIHRoaXMuX3Nhbml0aXplU2VsZWN0b3IoIFwiI1wiICsgaWQgKSApO1xuXHR9XG59KTtcblxuLy8gREVQUkVDQVRFRFxuaWYgKCAkLnVpQmFja0NvbXBhdCAhPT0gZmFsc2UgKSB7XG5cblx0Ly8gaGVscGVyIG1ldGhvZCBmb3IgYSBsb3Qgb2YgdGhlIGJhY2sgY29tcGF0IGV4dGVuc2lvbnNcblx0JC51aS50YWJzLnByb3RvdHlwZS5fdWkgPSBmdW5jdGlvbiggdGFiLCBwYW5lbCApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dGFiOiB0YWIsXG5cdFx0XHRwYW5lbDogcGFuZWwsXG5cdFx0XHRpbmRleDogdGhpcy5hbmNob3JzLmluZGV4KCB0YWIgKVxuXHRcdH07XG5cdH07XG5cblx0Ly8gdXJsIG1ldGhvZFxuXHQkLndpZGdldCggXCJ1aS50YWJzXCIsICQudWkudGFicywge1xuXHRcdHVybDogZnVuY3Rpb24oIGluZGV4LCB1cmwgKSB7XG5cdFx0XHR0aGlzLmFuY2hvcnMuZXEoIGluZGV4ICkuYXR0ciggXCJocmVmXCIsIHVybCApO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gVE9ETzogUmVtb3ZlIF9hamF4U2V0dGluZ3MoKSBtZXRob2Qgd2hlbiByZW1vdmluZyB0aGlzIGV4dGVuc2lvblxuXHQvLyBhamF4T3B0aW9ucyBhbmQgY2FjaGUgb3B0aW9uc1xuXHQkLndpZGdldCggXCJ1aS50YWJzXCIsICQudWkudGFicywge1xuXHRcdG9wdGlvbnM6IHtcblx0XHRcdGFqYXhPcHRpb25zOiBudWxsLFxuXHRcdFx0Y2FjaGU6IGZhbHNlXG5cdFx0fSxcblxuXHRcdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblxuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0XHR0aGlzLl9vbih7IHRhYnNiZWZvcmVsb2FkOiBmdW5jdGlvbiggZXZlbnQsIHVpICkge1xuXHRcdFx0XHQvLyB0YWIgaXMgYWxyZWFkeSBjYWNoZWRcblx0XHRcdFx0aWYgKCAkLmRhdGEoIHVpLnRhYlsgMCBdLCBcImNhY2hlLnRhYnNcIiApICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dWkuanFYSFIuc3VjY2VzcyhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoYXQub3B0aW9ucy5jYWNoZSApIHtcblx0XHRcdFx0XHRcdCQuZGF0YSggdWkudGFiWyAwIF0sIFwiY2FjaGUudGFic1wiLCB0cnVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH19KTtcblx0XHR9LFxuXG5cdFx0X2FqYXhTZXR0aW5nczogZnVuY3Rpb24oIGFuY2hvciwgZXZlbnQsIHVpICkge1xuXHRcdFx0dmFyIGFqYXhPcHRpb25zID0gdGhpcy5vcHRpb25zLmFqYXhPcHRpb25zO1xuXHRcdFx0cmV0dXJuICQuZXh0ZW5kKCB7fSwgYWpheE9wdGlvbnMsIHtcblx0XHRcdFx0ZXJyb3I6IGZ1bmN0aW9uKCB4aHIsIHN0YXR1cyApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Ly8gUGFzc2luZyBpbmRleCBhdm9pZCBhIHJhY2UgY29uZGl0aW9uIHdoZW4gdGhpcyBtZXRob2QgaXNcblx0XHRcdFx0XHRcdC8vIGNhbGxlZCBhZnRlciB0aGUgdXNlciBoYXMgc2VsZWN0ZWQgYW5vdGhlciB0YWIuXG5cdFx0XHRcdFx0XHQvLyBQYXNzIHRoZSBhbmNob3IgdGhhdCBpbml0aWF0ZWQgdGhpcyByZXF1ZXN0IGFsbG93c1xuXHRcdFx0XHRcdFx0Ly8gbG9hZEVycm9yIHRvIG1hbmlwdWxhdGUgdGhlIHRhYiBjb250ZW50IHBhbmVsIHZpYSAkKGEuaGFzaClcblx0XHRcdFx0XHRcdGFqYXhPcHRpb25zLmVycm9yKFxuXHRcdFx0XHRcdFx0XHR4aHIsIHN0YXR1cywgdWkudGFiLmNsb3Nlc3QoIFwibGlcIiApLmluZGV4KCksIHVpLnRhYlsgMCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoICggZXJyb3IgKSB7fVxuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzLl9zdXBlckFwcGx5KCBhcmd1bWVudHMgKSApO1xuXHRcdH0sXG5cblx0XHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdC8vIHJlc2V0IGNhY2hlIGlmIHN3aXRjaGluZyBmcm9tIGNhY2hlZCB0byBub3QgY2FjaGVkXG5cdFx0XHRpZiAoIGtleSA9PT0gXCJjYWNoZVwiICYmIHZhbHVlID09PSBmYWxzZSApIHtcblx0XHRcdFx0dGhpcy5hbmNob3JzLnJlbW92ZURhdGEoIFwiY2FjaGUudGFic1wiICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXHRcdH0sXG5cblx0XHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmFuY2hvcnMucmVtb3ZlRGF0YSggXCJjYWNoZS50YWJzXCIgKTtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0fSxcblxuXHRcdHVybDogZnVuY3Rpb24oIGluZGV4ICl7XG5cdFx0XHR0aGlzLmFuY2hvcnMuZXEoIGluZGV4ICkucmVtb3ZlRGF0YSggXCJjYWNoZS50YWJzXCIgKTtcblx0XHRcdHRoaXMuX3N1cGVyQXBwbHkoIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gYWJvcnQgbWV0aG9kXG5cdCQud2lkZ2V0KCBcInVpLnRhYnNcIiwgJC51aS50YWJzLCB7XG5cdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCB0aGlzLnhociApIHtcblx0XHRcdFx0dGhpcy54aHIuYWJvcnQoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdC8vIHNwaW5uZXJcblx0JC53aWRnZXQoIFwidWkudGFic1wiLCAkLnVpLnRhYnMsIHtcblx0XHRvcHRpb25zOiB7XG5cdFx0XHRzcGlubmVyOiBcIjxlbT5Mb2FkaW5nJiM4MjMwOzwvZW0+XCJcblx0XHR9LFxuXHRcdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHRcdHRoaXMuX29uKHtcblx0XHRcdFx0dGFic2JlZm9yZWxvYWQ6IGZ1bmN0aW9uKCBldmVudCwgdWkgKSB7XG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmVhY3QgdG8gbmVzdGVkIHRhYnMgb3IgdGFicyB0aGF0IGRvbid0IHVzZSBhIHNwaW5uZXJcblx0XHRcdFx0XHRpZiAoIGV2ZW50LnRhcmdldCAhPT0gdGhpcy5lbGVtZW50WyAwIF0gfHxcblx0XHRcdFx0XHRcdFx0IXRoaXMub3B0aW9ucy5zcGlubmVyICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBzcGFuID0gdWkudGFiLmZpbmQoIFwic3BhblwiICksXG5cdFx0XHRcdFx0XHRodG1sID0gc3Bhbi5odG1sKCk7XG5cdFx0XHRcdFx0c3Bhbi5odG1sKCB0aGlzLm9wdGlvbnMuc3Bpbm5lciApO1xuXHRcdFx0XHRcdHVpLmpxWEhSLmNvbXBsZXRlKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3Bhbi5odG1sKCBodG1sICk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gZW5hYmxlL2Rpc2FibGUgZXZlbnRzXG5cdCQud2lkZ2V0KCBcInVpLnRhYnNcIiwgJC51aS50YWJzLCB7XG5cdFx0b3B0aW9uczoge1xuXHRcdFx0ZW5hYmxlOiBudWxsLFxuXHRcdFx0ZGlzYWJsZTogbnVsbFxuXHRcdH0sXG5cblx0XHRlbmFibGU6IGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHR0cmlnZ2VyO1xuXG5cdFx0XHRpZiAoIGluZGV4ICYmIG9wdGlvbnMuZGlzYWJsZWQgPT09IHRydWUgfHxcblx0XHRcdFx0XHQoICQuaXNBcnJheSggb3B0aW9ucy5kaXNhYmxlZCApICYmICQuaW5BcnJheSggaW5kZXgsIG9wdGlvbnMuZGlzYWJsZWQgKSAhPT0gLTEgKSApIHtcblx0XHRcdFx0dHJpZ2dlciA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3N1cGVyQXBwbHkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRpZiAoIHRyaWdnZXIgKSB7XG5cdFx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiZW5hYmxlXCIsIG51bGwsIHRoaXMuX3VpKCB0aGlzLmFuY2hvcnNbIGluZGV4IF0sIHRoaXMucGFuZWxzWyBpbmRleCBdICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0ZGlzYWJsZTogZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdHRyaWdnZXI7XG5cblx0XHRcdGlmICggaW5kZXggJiYgb3B0aW9ucy5kaXNhYmxlZCA9PT0gZmFsc2UgfHxcblx0XHRcdFx0XHQoICQuaXNBcnJheSggb3B0aW9ucy5kaXNhYmxlZCApICYmICQuaW5BcnJheSggaW5kZXgsIG9wdGlvbnMuZGlzYWJsZWQgKSA9PT0gLTEgKSApIHtcblx0XHRcdFx0dHJpZ2dlciA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3N1cGVyQXBwbHkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRpZiAoIHRyaWdnZXIgKSB7XG5cdFx0XHRcdHRoaXMuX3RyaWdnZXIoIFwiZGlzYWJsZVwiLCBudWxsLCB0aGlzLl91aSggdGhpcy5hbmNob3JzWyBpbmRleCBdLCB0aGlzLnBhbmVsc1sgaW5kZXggXSApICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBhZGQvcmVtb3ZlIG1ldGhvZHMgYW5kIGV2ZW50c1xuXHQkLndpZGdldCggXCJ1aS50YWJzXCIsICQudWkudGFicywge1xuXHRcdG9wdGlvbnM6IHtcblx0XHRcdGFkZDogbnVsbCxcblx0XHRcdHJlbW92ZTogbnVsbCxcblx0XHRcdHRhYlRlbXBsYXRlOiBcIjxsaT48YSBocmVmPScje2hyZWZ9Jz48c3Bhbj4je2xhYmVsfTwvc3Bhbj48L2E+PC9saT5cIlxuXHRcdH0sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uKCB1cmwsIGxhYmVsLCBpbmRleCApIHtcblx0XHRcdGlmICggaW5kZXggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0aW5kZXggPSB0aGlzLmFuY2hvcnMubGVuZ3RoO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZG9JbnNlcnRBZnRlciwgcGFuZWwsXG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdGxpID0gJCggb3B0aW9ucy50YWJUZW1wbGF0ZVxuXHRcdFx0XHRcdC5yZXBsYWNlKCAvI1xce2hyZWZcXH0vZywgdXJsIClcblx0XHRcdFx0XHQucmVwbGFjZSggLyNcXHtsYWJlbFxcfS9nLCBsYWJlbCApICksXG5cdFx0XHRcdGlkID0gIXVybC5pbmRleE9mKCBcIiNcIiApID9cblx0XHRcdFx0XHR1cmwucmVwbGFjZSggXCIjXCIsIFwiXCIgKSA6XG5cdFx0XHRcdFx0dGhpcy5fdGFiSWQoIGxpICk7XG5cblx0XHRcdGxpLmFkZENsYXNzKCBcInVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLXRvcFwiICkuZGF0YSggXCJ1aS10YWJzLWRlc3Ryb3lcIiwgdHJ1ZSApO1xuXHRcdFx0bGkuYXR0ciggXCJhcmlhLWNvbnRyb2xzXCIsIGlkICk7XG5cblx0XHRcdGRvSW5zZXJ0QWZ0ZXIgPSBpbmRleCA+PSB0aGlzLnRhYnMubGVuZ3RoO1xuXG5cdFx0XHQvLyB0cnkgdG8gZmluZCBhbiBleGlzdGluZyBlbGVtZW50IGJlZm9yZSBjcmVhdGluZyBhIG5ldyBvbmVcblx0XHRcdHBhbmVsID0gdGhpcy5lbGVtZW50LmZpbmQoIFwiI1wiICsgaWQgKTtcblx0XHRcdGlmICggIXBhbmVsLmxlbmd0aCApIHtcblx0XHRcdFx0cGFuZWwgPSB0aGlzLl9jcmVhdGVQYW5lbCggaWQgKTtcblx0XHRcdFx0aWYgKCBkb0luc2VydEFmdGVyICkge1xuXHRcdFx0XHRcdGlmICggaW5kZXggPiAwICkge1xuXHRcdFx0XHRcdFx0cGFuZWwuaW5zZXJ0QWZ0ZXIoIHRoaXMucGFuZWxzLmVxKCAtMSApICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHBhbmVsLmFwcGVuZFRvKCB0aGlzLmVsZW1lbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFuZWwuaW5zZXJ0QmVmb3JlKCB0aGlzLnBhbmVsc1sgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwYW5lbC5hZGRDbGFzcyggXCJ1aS10YWJzLXBhbmVsIHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1ib3R0b21cIiApLmhpZGUoKTtcblxuXHRcdFx0aWYgKCBkb0luc2VydEFmdGVyICkge1xuXHRcdFx0XHRsaS5hcHBlbmRUbyggdGhpcy50YWJsaXN0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsaS5pbnNlcnRCZWZvcmUoIHRoaXMudGFic1sgaW5kZXggXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRvcHRpb25zLmRpc2FibGVkID0gJC5tYXAoIG9wdGlvbnMuZGlzYWJsZWQsIGZ1bmN0aW9uKCBuICkge1xuXHRcdFx0XHRyZXR1cm4gbiA+PSBpbmRleCA/ICsrbiA6IG47XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0XHRpZiAoIHRoaXMudGFicy5sZW5ndGggPT09IDEgJiYgb3B0aW9ucy5hY3RpdmUgPT09IGZhbHNlICkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbiggXCJhY3RpdmVcIiwgMCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl90cmlnZ2VyKCBcImFkZFwiLCBudWxsLCB0aGlzLl91aSggdGhpcy5hbmNob3JzWyBpbmRleCBdLCB0aGlzLnBhbmVsc1sgaW5kZXggXSApICk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHRpbmRleCA9IHRoaXMuX2dldEluZGV4KCBpbmRleCApO1xuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdHRhYiA9IHRoaXMudGFicy5lcSggaW5kZXggKS5yZW1vdmUoKSxcblx0XHRcdFx0cGFuZWwgPSB0aGlzLl9nZXRQYW5lbEZvclRhYiggdGFiICkucmVtb3ZlKCk7XG5cblx0XHRcdC8vIElmIHNlbGVjdGVkIHRhYiB3YXMgcmVtb3ZlZCBmb2N1cyB0YWIgdG8gdGhlIHJpZ2h0IG9yXG5cdFx0XHQvLyBpbiBjYXNlIHRoZSBsYXN0IHRhYiB3YXMgcmVtb3ZlZCB0aGUgdGFiIHRvIHRoZSBsZWZ0LlxuXHRcdFx0Ly8gV2UgY2hlY2sgZm9yIG1vcmUgdGhhbiAyIHRhYnMsIGJlY2F1c2UgaWYgdGhlcmUgYXJlIG9ubHkgMixcblx0XHRcdC8vIHRoZW4gd2hlbiB3ZSByZW1vdmUgdGhpcyB0YWIsIHRoZXJlIHdpbGwgb25seSBiZSBvbmUgdGFiIGxlZnRcblx0XHRcdC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gZGV0ZWN0IHdoaWNoIHRhYiB0byBhY3RpdmF0ZS5cblx0XHRcdGlmICggdGFiLmhhc0NsYXNzKCBcInVpLXRhYnMtYWN0aXZlXCIgKSAmJiB0aGlzLmFuY2hvcnMubGVuZ3RoID4gMiApIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZhdGUoIGluZGV4ICsgKCBpbmRleCArIDEgPCB0aGlzLmFuY2hvcnMubGVuZ3RoID8gMSA6IC0xICkgKTtcblx0XHRcdH1cblxuXHRcdFx0b3B0aW9ucy5kaXNhYmxlZCA9ICQubWFwKFxuXHRcdFx0XHQkLmdyZXAoIG9wdGlvbnMuZGlzYWJsZWQsIGZ1bmN0aW9uKCBuICkge1xuXHRcdFx0XHRcdHJldHVybiBuICE9PSBpbmRleDtcblx0XHRcdFx0fSksXG5cdFx0XHRcdGZ1bmN0aW9uKCBuICkge1xuXHRcdFx0XHRcdHJldHVybiBuID49IGluZGV4ID8gLS1uIDogbjtcblx0XHRcdFx0fSk7XG5cblx0XHRcdHRoaXMucmVmcmVzaCgpO1xuXG5cdFx0XHR0aGlzLl90cmlnZ2VyKCBcInJlbW92ZVwiLCBudWxsLCB0aGlzLl91aSggdGFiLmZpbmQoIFwiYVwiIClbIDAgXSwgcGFuZWxbIDAgXSApICk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdH0pO1xuXG5cdC8vIGxlbmd0aCBtZXRob2Rcblx0JC53aWRnZXQoIFwidWkudGFic1wiLCAkLnVpLnRhYnMsIHtcblx0XHRsZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYW5jaG9ycy5sZW5ndGg7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBwYW5lbCBpZHMgKGlkUHJlZml4IG9wdGlvbiArIHRpdGxlIGF0dHJpYnV0ZSlcblx0JC53aWRnZXQoIFwidWkudGFic1wiLCAkLnVpLnRhYnMsIHtcblx0XHRvcHRpb25zOiB7XG5cdFx0XHRpZFByZWZpeDogXCJ1aS10YWJzLVwiXG5cdFx0fSxcblxuXHRcdF90YWJJZDogZnVuY3Rpb24oIHRhYiApIHtcblx0XHRcdHZhciBhID0gdGFiLmlzKCBcImxpXCIgKSA/IHRhYi5maW5kKCBcImFbaHJlZl1cIiApIDogdGFiO1xuXHRcdFx0YSA9IGFbMF07XG5cdFx0XHRyZXR1cm4gJCggYSApLmNsb3Nlc3QoIFwibGlcIiApLmF0dHIoIFwiYXJpYS1jb250cm9sc1wiICkgfHxcblx0XHRcdFx0YS50aXRsZSAmJiBhLnRpdGxlLnJlcGxhY2UoIC9cXHMvZywgXCJfXCIgKS5yZXBsYWNlKCAvW15cXHdcXHUwMGMwLVxcdUZGRkZcXC1dL2csIFwiXCIgKSB8fFxuXHRcdFx0XHR0aGlzLm9wdGlvbnMuaWRQcmVmaXggKyBnZXROZXh0VGFiSWQoKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIF9jcmVhdGVQYW5lbCBtZXRob2Rcblx0JC53aWRnZXQoIFwidWkudGFic1wiLCAkLnVpLnRhYnMsIHtcblx0XHRvcHRpb25zOiB7XG5cdFx0XHRwYW5lbFRlbXBsYXRlOiBcIjxkaXY+PC9kaXY+XCJcblx0XHR9LFxuXG5cdFx0X2NyZWF0ZVBhbmVsOiBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHRyZXR1cm4gJCggdGhpcy5vcHRpb25zLnBhbmVsVGVtcGxhdGUgKVxuXHRcdFx0XHQuYXR0ciggXCJpZFwiLCBpZCApXG5cdFx0XHRcdC5hZGRDbGFzcyggXCJ1aS10YWJzLXBhbmVsIHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1ib3R0b21cIiApXG5cdFx0XHRcdC5kYXRhKCBcInVpLXRhYnMtZGVzdHJveVwiLCB0cnVlICk7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBzZWxlY3RlZCBvcHRpb25cblx0JC53aWRnZXQoIFwidWkudGFic1wiLCAkLnVpLnRhYnMsIHtcblx0XHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXHRcdFx0aWYgKCBvcHRpb25zLmFjdGl2ZSA9PT0gbnVsbCAmJiBvcHRpb25zLnNlbGVjdGVkICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdG9wdGlvbnMuYWN0aXZlID0gb3B0aW9ucy5zZWxlY3RlZCA9PT0gLTEgPyBmYWxzZSA6IG9wdGlvbnMuc2VsZWN0ZWQ7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdFx0b3B0aW9ucy5zZWxlY3RlZCA9IG9wdGlvbnMuYWN0aXZlO1xuXHRcdFx0aWYgKCBvcHRpb25zLnNlbGVjdGVkID09PSBmYWxzZSApIHtcblx0XHRcdFx0b3B0aW9ucy5zZWxlY3RlZCA9IC0xO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdGlmICgga2V5ICE9PSBcInNlbGVjdGVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0XHRcdHRoaXMuX3N1cGVyKCBcImFjdGl2ZVwiLCB2YWx1ZSA9PT0gLTEgPyBmYWxzZSA6IHZhbHVlICk7XG5cdFx0XHRvcHRpb25zLnNlbGVjdGVkID0gb3B0aW9ucy5hY3RpdmU7XG5cdFx0XHRpZiAoIG9wdGlvbnMuc2VsZWN0ZWQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRvcHRpb25zLnNlbGVjdGVkID0gLTE7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9ldmVudEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fc3VwZXJBcHBseSggYXJndW1lbnRzICk7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc2VsZWN0ZWQgPSB0aGlzLm9wdGlvbnMuYWN0aXZlO1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2VsZWN0ZWQgPT09IGZhbHNlICkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMuc2VsZWN0ZWQgPSAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdC8vIHNob3cgYW5kIHNlbGVjdCBldmVudFxuXHQkLndpZGdldCggXCJ1aS50YWJzXCIsICQudWkudGFicywge1xuXHRcdG9wdGlvbnM6IHtcblx0XHRcdHNob3c6IG51bGwsXG5cdFx0XHRzZWxlY3Q6IG51bGxcblx0XHR9LFxuXHRcdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fc3VwZXIoKTtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmFjdGl2ZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdHRoaXMuX3RyaWdnZXIoIFwic2hvd1wiLCBudWxsLCB0aGlzLl91aShcblx0XHRcdFx0XHR0aGlzLmFjdGl2ZS5maW5kKCBcIi51aS10YWJzLWFuY2hvclwiIClbIDAgXSxcblx0XHRcdFx0XHR0aGlzLl9nZXRQYW5lbEZvclRhYiggdGhpcy5hY3RpdmUgKVsgMCBdICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdF90cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZXZlbnQsIGRhdGEgKSB7XG5cdFx0XHR2YXIgdGFiLCBwYW5lbCxcblx0XHRcdFx0cmV0ID0gdGhpcy5fc3VwZXJBcHBseSggYXJndW1lbnRzICk7XG5cblx0XHRcdGlmICggIXJldCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiYmVmb3JlQWN0aXZhdGVcIiApIHtcblx0XHRcdFx0dGFiID0gZGF0YS5uZXdUYWIubGVuZ3RoID8gZGF0YS5uZXdUYWIgOiBkYXRhLm9sZFRhYjtcblx0XHRcdFx0cGFuZWwgPSBkYXRhLm5ld1BhbmVsLmxlbmd0aCA/IGRhdGEubmV3UGFuZWwgOiBkYXRhLm9sZFBhbmVsO1xuXHRcdFx0XHRyZXQgPSB0aGlzLl9zdXBlciggXCJzZWxlY3RcIiwgZXZlbnQsIHtcblx0XHRcdFx0XHR0YWI6IHRhYi5maW5kKCBcIi51aS10YWJzLWFuY2hvclwiIClbIDBdLFxuXHRcdFx0XHRcdHBhbmVsOiBwYW5lbFsgMCBdLFxuXHRcdFx0XHRcdGluZGV4OiB0YWIuY2xvc2VzdCggXCJsaVwiICkuaW5kZXgoKVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiYWN0aXZhdGVcIiAmJiBkYXRhLm5ld1RhYi5sZW5ndGggKSB7XG5cdFx0XHRcdHJldCA9IHRoaXMuX3N1cGVyKCBcInNob3dcIiwgZXZlbnQsIHtcblx0XHRcdFx0XHR0YWI6IGRhdGEubmV3VGFiLmZpbmQoIFwiLnVpLXRhYnMtYW5jaG9yXCIgKVsgMCBdLFxuXHRcdFx0XHRcdHBhbmVsOiBkYXRhLm5ld1BhbmVsWyAwIF0sXG5cdFx0XHRcdFx0aW5kZXg6IGRhdGEubmV3VGFiLmNsb3Nlc3QoIFwibGlcIiApLmluZGV4KClcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gc2VsZWN0IG1ldGhvZFxuXHQkLndpZGdldCggXCJ1aS50YWJzXCIsICQudWkudGFicywge1xuXHRcdHNlbGVjdDogZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0aW5kZXggPSB0aGlzLl9nZXRJbmRleCggaW5kZXggKTtcblx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5jb2xsYXBzaWJsZSAmJiB0aGlzLm9wdGlvbnMuc2VsZWN0ZWQgIT09IC0xICkge1xuXHRcdFx0XHRcdGluZGV4ID0gdGhpcy5vcHRpb25zLnNlbGVjdGVkO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5hbmNob3JzLmVxKCBpbmRleCApLnRyaWdnZXIoIHRoaXMub3B0aW9ucy5ldmVudCArIHRoaXMuZXZlbnROYW1lc3BhY2UgKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIGNvb2tpZSBvcHRpb25cblx0KGZ1bmN0aW9uKCkge1xuXG5cdHZhciBsaXN0SWQgPSAwO1xuXG5cdCQud2lkZ2V0KCBcInVpLnRhYnNcIiwgJC51aS50YWJzLCB7XG5cdFx0b3B0aW9uczoge1xuXHRcdFx0Y29va2llOiBudWxsIC8vIGUuZy4geyBleHBpcmVzOiA3LCBwYXRoOiAnLycsIGRvbWFpbjogJ2pxdWVyeS5jb20nLCBzZWN1cmU6IHRydWUgfVxuXHRcdH0sXG5cdFx0X2NyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0YWN0aXZlO1xuXHRcdFx0aWYgKCBvcHRpb25zLmFjdGl2ZSA9PSBudWxsICYmIG9wdGlvbnMuY29va2llICkge1xuXHRcdFx0XHRhY3RpdmUgPSBwYXJzZUludCggdGhpcy5fY29va2llKCksIDEwICk7XG5cdFx0XHRcdGlmICggYWN0aXZlID09PSAtMSApIHtcblx0XHRcdFx0XHRhY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcHRpb25zLmFjdGl2ZSA9IGFjdGl2ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0fSxcblx0XHRfY29va2llOiBmdW5jdGlvbiggYWN0aXZlICkge1xuXHRcdFx0dmFyIGNvb2tpZSA9IFsgdGhpcy5jb29raWUgfHxcblx0XHRcdFx0KCB0aGlzLmNvb2tpZSA9IHRoaXMub3B0aW9ucy5jb29raWUubmFtZSB8fCBcInVpLXRhYnMtXCIgKyAoKytsaXN0SWQpICkgXTtcblx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29va2llLnB1c2goIGFjdGl2ZSA9PT0gZmFsc2UgPyAtMSA6IGFjdGl2ZSApO1xuXHRcdFx0XHRjb29raWUucHVzaCggdGhpcy5vcHRpb25zLmNvb2tpZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICQuY29va2llLmFwcGx5KCBudWxsLCBjb29raWUgKTtcblx0XHR9LFxuXHRcdF9yZWZyZXNoOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3N1cGVyKCk7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5jb29raWUgKSB7XG5cdFx0XHRcdHRoaXMuX2Nvb2tpZSggdGhpcy5vcHRpb25zLmFjdGl2ZSwgdGhpcy5vcHRpb25zLmNvb2tpZSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0X2V2ZW50SGFuZGxlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlckFwcGx5KCBhcmd1bWVudHMgKTtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmNvb2tpZSApIHtcblx0XHRcdFx0dGhpcy5fY29va2llKCB0aGlzLm9wdGlvbnMuYWN0aXZlLCB0aGlzLm9wdGlvbnMuY29va2llICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9zdXBlcigpO1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuY29va2llICkge1xuXHRcdFx0XHR0aGlzLl9jb29raWUoIG51bGwsIHRoaXMub3B0aW9ucy5jb29raWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdH0pKCk7XG5cblx0Ly8gbG9hZCBldmVudFxuXHQkLndpZGdldCggXCJ1aS50YWJzXCIsICQudWkudGFicywge1xuXHRcdF90cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZXZlbnQsIGRhdGEgKSB7XG5cdFx0XHR2YXIgX2RhdGEgPSAkLmV4dGVuZCgge30sIGRhdGEgKTtcblx0XHRcdGlmICggdHlwZSA9PT0gXCJsb2FkXCIgKSB7XG5cdFx0XHRcdF9kYXRhLnBhbmVsID0gX2RhdGEucGFuZWxbIDAgXTtcblx0XHRcdFx0X2RhdGEudGFiID0gX2RhdGEudGFiLmZpbmQoIFwiLnVpLXRhYnMtYW5jaG9yXCIgKVsgMCBdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX3N1cGVyKCB0eXBlLCBldmVudCwgX2RhdGEgKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIGZ4IG9wdGlvblxuXHQvLyBUaGUgbmV3IGFuaW1hdGlvbiBvcHRpb25zIChzaG93LCBoaWRlKSBjb25mbGljdCB3aXRoIHRoZSBvbGQgc2hvdyBjYWxsYmFjay5cblx0Ly8gVGhlIG9sZCBmeCBvcHRpb24gd2lucyBvdmVyIHNob3cvaGlkZSBhbnl3YXkgKGFsd2F5cyBmYXZvciBiYWNrLWNvbXBhdCkuXG5cdC8vIElmIGEgdXNlciB3YW50cyB0byB1c2UgdGhlIG5ldyBhbmltYXRpb24gQVBJLCB0aGV5IG11c3QgZ2l2ZSB1cCB0aGUgb2xkIEFQSS5cblx0JC53aWRnZXQoIFwidWkudGFic1wiLCAkLnVpLnRhYnMsIHtcblx0XHRvcHRpb25zOiB7XG5cdFx0XHRmeDogbnVsbCAvLyBlLmcuIHsgaGVpZ2h0OiBcInRvZ2dsZVwiLCBvcGFjaXR5OiBcInRvZ2dsZVwiLCBkdXJhdGlvbjogMjAwIH1cblx0XHR9LFxuXG5cdFx0X2dldEZ4OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBoaWRlLCBzaG93LFxuXHRcdFx0XHRmeCA9IHRoaXMub3B0aW9ucy5meDtcblxuXHRcdFx0aWYgKCBmeCApIHtcblx0XHRcdFx0aWYgKCAkLmlzQXJyYXkoIGZ4ICkgKSB7XG5cdFx0XHRcdFx0aGlkZSA9IGZ4WyAwIF07XG5cdFx0XHRcdFx0c2hvdyA9IGZ4WyAxIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aGlkZSA9IHNob3cgPSBmeDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZnggPyB7IHNob3c6IHNob3csIGhpZGU6IGhpZGUgfSA6IG51bGw7XG5cdFx0fSxcblxuXHRcdF90b2dnbGU6IGZ1bmN0aW9uKCBldmVudCwgZXZlbnREYXRhICkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHR0b1Nob3cgPSBldmVudERhdGEubmV3UGFuZWwsXG5cdFx0XHRcdHRvSGlkZSA9IGV2ZW50RGF0YS5vbGRQYW5lbCxcblx0XHRcdFx0ZnggPSB0aGlzLl9nZXRGeCgpO1xuXG5cdFx0XHRpZiAoICFmeCApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3N1cGVyKCBldmVudCwgZXZlbnREYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdHRoYXQucnVubmluZyA9IHRydWU7XG5cblx0XHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuXHRcdFx0XHR0aGF0LnJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdFx0dGhhdC5fdHJpZ2dlciggXCJhY3RpdmF0ZVwiLCBldmVudCwgZXZlbnREYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHNob3coKSB7XG5cdFx0XHRcdGV2ZW50RGF0YS5uZXdUYWIuY2xvc2VzdCggXCJsaVwiICkuYWRkQ2xhc3MoIFwidWktdGFicy1hY3RpdmUgdWktc3RhdGUtYWN0aXZlXCIgKTtcblxuXHRcdFx0XHRpZiAoIHRvU2hvdy5sZW5ndGggJiYgZnguc2hvdyApIHtcblx0XHRcdFx0XHR0b1Nob3dcblx0XHRcdFx0XHRcdC5hbmltYXRlKCBmeC5zaG93LCBmeC5zaG93LmR1cmF0aW9uLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRvU2hvdy5zaG93KCk7XG5cdFx0XHRcdFx0Y29tcGxldGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzdGFydCBvdXQgYnkgaGlkaW5nLCB0aGVuIHNob3dpbmcsIHRoZW4gY29tcGxldGluZ1xuXHRcdFx0aWYgKCB0b0hpZGUubGVuZ3RoICYmIGZ4LmhpZGUgKSB7XG5cdFx0XHRcdHRvSGlkZS5hbmltYXRlKCBmeC5oaWRlLCBmeC5oaWRlLmR1cmF0aW9uLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRldmVudERhdGEub2xkVGFiLmNsb3Nlc3QoIFwibGlcIiApLnJlbW92ZUNsYXNzKCBcInVpLXRhYnMtYWN0aXZlIHVpLXN0YXRlLWFjdGl2ZVwiICk7XG5cdFx0XHRcdFx0c2hvdygpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV2ZW50RGF0YS5vbGRUYWIuY2xvc2VzdCggXCJsaVwiICkucmVtb3ZlQ2xhc3MoIFwidWktdGFicy1hY3RpdmUgdWktc3RhdGUtYWN0aXZlXCIgKTtcblx0XHRcdFx0dG9IaWRlLmhpZGUoKTtcblx0XHRcdFx0c2hvdygpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbn0pKCBqUXVlcnkgKTtcbihmdW5jdGlvbiggJCApIHtcblxudmFyIGluY3JlbWVudHMgPSAwO1xuXG5mdW5jdGlvbiBhZGREZXNjcmliZWRCeSggZWxlbSwgaWQgKSB7XG5cdHZhciBkZXNjcmliZWRieSA9IChlbGVtLmF0dHIoIFwiYXJpYS1kZXNjcmliZWRieVwiICkgfHwgXCJcIikuc3BsaXQoIC9cXHMrLyApO1xuXHRkZXNjcmliZWRieS5wdXNoKCBpZCApO1xuXHRlbGVtXG5cdFx0LmRhdGEoIFwidWktdG9vbHRpcC1pZFwiLCBpZCApXG5cdFx0LmF0dHIoIFwiYXJpYS1kZXNjcmliZWRieVwiLCAkLnRyaW0oIGRlc2NyaWJlZGJ5LmpvaW4oIFwiIFwiICkgKSApO1xufVxuXG5mdW5jdGlvbiByZW1vdmVEZXNjcmliZWRCeSggZWxlbSApIHtcblx0dmFyIGlkID0gZWxlbS5kYXRhKCBcInVpLXRvb2x0aXAtaWRcIiApLFxuXHRcdGRlc2NyaWJlZGJ5ID0gKGVsZW0uYXR0ciggXCJhcmlhLWRlc2NyaWJlZGJ5XCIgKSB8fCBcIlwiKS5zcGxpdCggL1xccysvICksXG5cdFx0aW5kZXggPSAkLmluQXJyYXkoIGlkLCBkZXNjcmliZWRieSApO1xuXHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRkZXNjcmliZWRieS5zcGxpY2UoIGluZGV4LCAxICk7XG5cdH1cblxuXHRlbGVtLnJlbW92ZURhdGEoIFwidWktdG9vbHRpcC1pZFwiICk7XG5cdGRlc2NyaWJlZGJ5ID0gJC50cmltKCBkZXNjcmliZWRieS5qb2luKCBcIiBcIiApICk7XG5cdGlmICggZGVzY3JpYmVkYnkgKSB7XG5cdFx0ZWxlbS5hdHRyKCBcImFyaWEtZGVzY3JpYmVkYnlcIiwgZGVzY3JpYmVkYnkgKTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHIoIFwiYXJpYS1kZXNjcmliZWRieVwiICk7XG5cdH1cbn1cblxuJC53aWRnZXQoIFwidWkudG9vbHRpcFwiLCB7XG5cdHZlcnNpb246IFwiMS45LjJcIixcblx0b3B0aW9uczoge1xuXHRcdGNvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICQoIHRoaXMgKS5hdHRyKCBcInRpdGxlXCIgKTtcblx0XHR9LFxuXHRcdGhpZGU6IHRydWUsXG5cdFx0Ly8gRGlzYWJsZWQgZWxlbWVudHMgaGF2ZSBpbmNvbnNpc3RlbnQgYmVoYXZpb3IgYWNyb3NzIGJyb3dzZXJzICgjODY2MSlcblx0XHRpdGVtczogXCJbdGl0bGVdOm5vdChbZGlzYWJsZWRdKVwiLFxuXHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRteTogXCJsZWZ0IHRvcCsxNVwiLFxuXHRcdFx0YXQ6IFwibGVmdCBib3R0b21cIixcblx0XHRcdGNvbGxpc2lvbjogXCJmbGlwZml0IGZsaXBcIlxuXHRcdH0sXG5cdFx0c2hvdzogdHJ1ZSxcblx0XHR0b29sdGlwQ2xhc3M6IG51bGwsXG5cdFx0dHJhY2s6IGZhbHNlLFxuXG5cdFx0Ly8gY2FsbGJhY2tzXG5cdFx0Y2xvc2U6IG51bGwsXG5cdFx0b3BlbjogbnVsbFxuXHR9LFxuXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX29uKHtcblx0XHRcdG1vdXNlb3ZlcjogXCJvcGVuXCIsXG5cdFx0XHRmb2N1c2luOiBcIm9wZW5cIlxuXHRcdH0pO1xuXG5cdFx0Ly8gSURzIG9mIGdlbmVyYXRlZCB0b29sdGlwcywgbmVlZGVkIGZvciBkZXN0cm95XG5cdFx0dGhpcy50b29sdGlwcyA9IHt9O1xuXHRcdC8vIElEcyBvZiBwYXJlbnQgdG9vbHRpcHMgd2hlcmUgd2UgcmVtb3ZlZCB0aGUgdGl0bGUgYXR0cmlidXRlXG5cdFx0dGhpcy5wYXJlbnRzID0ge307XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kaXNhYmxlZCApIHtcblx0XHRcdHRoaXMuX2Rpc2FibGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0aWYgKCBrZXkgPT09IFwiZGlzYWJsZWRcIiApIHtcblx0XHRcdHRoaXNbIHZhbHVlID8gXCJfZGlzYWJsZVwiIDogXCJfZW5hYmxlXCIgXSgpO1xuXHRcdFx0dGhpcy5vcHRpb25zWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0Ly8gZGlzYWJsZSBlbGVtZW50IHN0eWxlIGNoYW5nZXNcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBrZXkgPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0JC5lYWNoKCB0aGlzLnRvb2x0aXBzLCBmdW5jdGlvbiggaWQsIGVsZW1lbnQgKSB7XG5cdFx0XHRcdHRoYXQuX3VwZGF0ZUNvbnRlbnQoIGVsZW1lbnQgKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRfZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0Ly8gY2xvc2Ugb3BlbiB0b29sdGlwc1xuXHRcdCQuZWFjaCggdGhpcy50b29sdGlwcywgZnVuY3Rpb24oIGlkLCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIGV2ZW50ID0gJC5FdmVudCggXCJibHVyXCIgKTtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBlbGVtZW50WzBdO1xuXHRcdFx0dGhhdC5jbG9zZSggZXZlbnQsIHRydWUgKTtcblx0XHR9KTtcblxuXHRcdC8vIHJlbW92ZSB0aXRsZSBhdHRyaWJ1dGVzIHRvIHByZXZlbnQgbmF0aXZlIHRvb2x0aXBzXG5cdFx0dGhpcy5lbGVtZW50LmZpbmQoIHRoaXMub3B0aW9ucy5pdGVtcyApLmFuZFNlbGYoKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSAkKCB0aGlzICk7XG5cdFx0XHRpZiAoIGVsZW1lbnQuaXMoIFwiW3RpdGxlXVwiICkgKSB7XG5cdFx0XHRcdGVsZW1lbnRcblx0XHRcdFx0XHQuZGF0YSggXCJ1aS10b29sdGlwLXRpdGxlXCIsIGVsZW1lbnQuYXR0ciggXCJ0aXRsZVwiICkgKVxuXHRcdFx0XHRcdC5hdHRyKCBcInRpdGxlXCIsIFwiXCIgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRfZW5hYmxlOiBmdW5jdGlvbigpIHtcblx0XHQvLyByZXN0b3JlIHRpdGxlIGF0dHJpYnV0ZXNcblx0XHR0aGlzLmVsZW1lbnQuZmluZCggdGhpcy5vcHRpb25zLml0ZW1zICkuYW5kU2VsZigpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9ICQoIHRoaXMgKTtcblx0XHRcdGlmICggZWxlbWVudC5kYXRhKCBcInVpLXRvb2x0aXAtdGl0bGVcIiApICkge1xuXHRcdFx0XHRlbGVtZW50LmF0dHIoIFwidGl0bGVcIiwgZWxlbWVudC5kYXRhKCBcInVpLXRvb2x0aXAtdGl0bGVcIiApICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0b3BlbjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdHRhcmdldCA9ICQoIGV2ZW50ID8gZXZlbnQudGFyZ2V0IDogdGhpcy5lbGVtZW50IClcblx0XHRcdFx0Ly8gd2UgbmVlZCBjbG9zZXN0IGhlcmUgZHVlIHRvIG1vdXNlb3ZlciBidWJibGluZyxcblx0XHRcdFx0Ly8gYnV0IGFsd2F5cyBwb2ludGluZyBhdCB0aGUgc2FtZSBldmVudCB0YXJnZXRcblx0XHRcdFx0LmNsb3Nlc3QoIHRoaXMub3B0aW9ucy5pdGVtcyApO1xuXG5cdFx0Ly8gTm8gZWxlbWVudCB0byBzaG93IGEgdG9vbHRpcCBmb3Igb3IgdGhlIHRvb2x0aXAgaXMgYWxyZWFkeSBvcGVuXG5cdFx0aWYgKCAhdGFyZ2V0Lmxlbmd0aCB8fCB0YXJnZXQuZGF0YSggXCJ1aS10b29sdGlwLWlkXCIgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRhcmdldC5hdHRyKCBcInRpdGxlXCIgKSApIHtcblx0XHRcdHRhcmdldC5kYXRhKCBcInVpLXRvb2x0aXAtdGl0bGVcIiwgdGFyZ2V0LmF0dHIoIFwidGl0bGVcIiApICk7XG5cdFx0fVxuXG5cdFx0dGFyZ2V0LmRhdGEoIFwidWktdG9vbHRpcC1vcGVuXCIsIHRydWUgKTtcblxuXHRcdC8vIGtpbGwgcGFyZW50IHRvb2x0aXBzLCBjdXN0b20gb3IgbmF0aXZlLCBmb3IgaG92ZXJcblx0XHRpZiAoIGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IFwibW91c2VvdmVyXCIgKSB7XG5cdFx0XHR0YXJnZXQucGFyZW50cygpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBwYXJlbnQgPSAkKCB0aGlzICksXG5cdFx0XHRcdFx0Ymx1ckV2ZW50O1xuXHRcdFx0XHRpZiAoIHBhcmVudC5kYXRhKCBcInVpLXRvb2x0aXAtb3BlblwiICkgKSB7XG5cdFx0XHRcdFx0Ymx1ckV2ZW50ID0gJC5FdmVudCggXCJibHVyXCIgKTtcblx0XHRcdFx0XHRibHVyRXZlbnQudGFyZ2V0ID0gYmx1ckV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuXHRcdFx0XHRcdHRoYXQuY2xvc2UoIGJsdXJFdmVudCwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggcGFyZW50LmF0dHIoIFwidGl0bGVcIiApICkge1xuXHRcdFx0XHRcdHBhcmVudC51bmlxdWVJZCgpO1xuXHRcdFx0XHRcdHRoYXQucGFyZW50c1sgdGhpcy5pZCBdID0ge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogdGhpcyxcblx0XHRcdFx0XHRcdHRpdGxlOiBwYXJlbnQuYXR0ciggXCJ0aXRsZVwiIClcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHBhcmVudC5hdHRyKCBcInRpdGxlXCIsIFwiXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlQ29udGVudCggdGFyZ2V0LCBldmVudCApO1xuXHR9LFxuXG5cdF91cGRhdGVDb250ZW50OiBmdW5jdGlvbiggdGFyZ2V0LCBldmVudCApIHtcblx0XHR2YXIgY29udGVudCxcblx0XHRcdGNvbnRlbnRPcHRpb24gPSB0aGlzLm9wdGlvbnMuY29udGVudCxcblx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0ZXZlbnRUeXBlID0gZXZlbnQgPyBldmVudC50eXBlIDogbnVsbDtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRlbnRPcHRpb24gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fb3BlbiggZXZlbnQsIHRhcmdldCwgY29udGVudE9wdGlvbiApO1xuXHRcdH1cblxuXHRcdGNvbnRlbnQgPSBjb250ZW50T3B0aW9uLmNhbGwoIHRhcmdldFswXSwgZnVuY3Rpb24oIHJlc3BvbnNlICkge1xuXHRcdFx0Ly8gaWdub3JlIGFzeW5jIHJlc3BvbnNlIGlmIHRvb2x0aXAgd2FzIGNsb3NlZCBhbHJlYWR5XG5cdFx0XHRpZiAoICF0YXJnZXQuZGF0YSggXCJ1aS10b29sdGlwLW9wZW5cIiApICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBJRSBtYXkgaW5zdGFudGx5IHNlcnZlIGEgY2FjaGVkIHJlc3BvbnNlIGZvciBhamF4IHJlcXVlc3RzXG5cdFx0XHQvLyBkZWxheSB0aGlzIGNhbGwgdG8gX29wZW4gc28gdGhlIG90aGVyIGNhbGwgdG8gX29wZW4gcnVucyBmaXJzdFxuXHRcdFx0dGhhdC5fZGVsYXkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIGpRdWVyeSBjcmVhdGVzIGEgc3BlY2lhbCBldmVudCBmb3IgZm9jdXNpbiB3aGVuIGl0IGRvZXNuJ3Rcblx0XHRcdFx0Ly8gZXhpc3QgbmF0aXZlbHkuIFRvIGltcHJvdmUgcGVyZm9ybWFuY2UsIHRoZSBuYXRpdmUgZXZlbnRcblx0XHRcdFx0Ly8gb2JqZWN0IGlzIHJldXNlZCBhbmQgdGhlIHR5cGUgaXMgY2hhbmdlZC4gVGhlcmVmb3JlLCB3ZSBjYW4ndFxuXHRcdFx0XHQvLyByZWx5IG9uIHRoZSB0eXBlIGJlaW5nIGNvcnJlY3QgYWZ0ZXIgdGhlIGV2ZW50IGZpbmlzaGVkXG5cdFx0XHRcdC8vIGJ1YmJsaW5nLCBzbyB3ZSBzZXQgaXQgYmFjayB0byB0aGUgcHJldmlvdXMgdmFsdWUuICgjODc0MClcblx0XHRcdFx0aWYgKCBldmVudCApIHtcblx0XHRcdFx0XHRldmVudC50eXBlID0gZXZlbnRUeXBlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX29wZW4oIGV2ZW50LCB0YXJnZXQsIHJlc3BvbnNlICk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRpZiAoIGNvbnRlbnQgKSB7XG5cdFx0XHR0aGlzLl9vcGVuKCBldmVudCwgdGFyZ2V0LCBjb250ZW50ICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vcGVuOiBmdW5jdGlvbiggZXZlbnQsIHRhcmdldCwgY29udGVudCApIHtcblx0XHR2YXIgdG9vbHRpcCwgZXZlbnRzLCBkZWxheWVkU2hvdyxcblx0XHRcdHBvc2l0aW9uT3B0aW9uID0gJC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnMucG9zaXRpb24gKTtcblxuXHRcdGlmICggIWNvbnRlbnQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ29udGVudCBjYW4gYmUgdXBkYXRlZCBtdWx0aXBsZSB0aW1lcy4gSWYgdGhlIHRvb2x0aXAgYWxyZWFkeVxuXHRcdC8vIGV4aXN0cywgdGhlbiBqdXN0IHVwZGF0ZSB0aGUgY29udGVudCBhbmQgYmFpbC5cblx0XHR0b29sdGlwID0gdGhpcy5fZmluZCggdGFyZ2V0ICk7XG5cdFx0aWYgKCB0b29sdGlwLmxlbmd0aCApIHtcblx0XHRcdHRvb2x0aXAuZmluZCggXCIudWktdG9vbHRpcC1jb250ZW50XCIgKS5odG1sKCBjb250ZW50ICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gaWYgd2UgaGF2ZSBhIHRpdGxlLCBjbGVhciBpdCB0byBwcmV2ZW50IHRoZSBuYXRpdmUgdG9vbHRpcFxuXHRcdC8vIHdlIGhhdmUgdG8gY2hlY2sgZmlyc3QgdG8gYXZvaWQgZGVmaW5pbmcgYSB0aXRsZSBpZiBub25lIGV4aXN0c1xuXHRcdC8vICh3ZSBkb24ndCB3YW50IHRvIGNhdXNlIGFuIGVsZW1lbnQgdG8gc3RhcnQgbWF0Y2hpbmcgW3RpdGxlXSlcblx0XHQvL1xuXHRcdC8vIFdlIHVzZSByZW1vdmVBdHRyIG9ubHkgZm9yIGtleSBldmVudHMsIHRvIGFsbG93IElFIHRvIGV4cG9ydCB0aGUgY29ycmVjdFxuXHRcdC8vIGFjY2Vzc2libGUgYXR0cmlidXRlcy4gRm9yIG1vdXNlIGV2ZW50cywgc2V0IHRvIGVtcHR5IHN0cmluZyB0byBhdm9pZFxuXHRcdC8vIG5hdGl2ZSB0b29sdGlwIHNob3dpbmcgdXAgKGhhcHBlbnMgb25seSB3aGVuIHJlbW92aW5nIGluc2lkZSBtb3VzZW92ZXIpLlxuXHRcdGlmICggdGFyZ2V0LmlzKCBcIlt0aXRsZV1cIiApICkge1xuXHRcdFx0aWYgKCBldmVudCAmJiBldmVudC50eXBlID09PSBcIm1vdXNlb3ZlclwiICkge1xuXHRcdFx0XHR0YXJnZXQuYXR0ciggXCJ0aXRsZVwiLCBcIlwiICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXQucmVtb3ZlQXR0ciggXCJ0aXRsZVwiICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dG9vbHRpcCA9IHRoaXMuX3Rvb2x0aXAoIHRhcmdldCApO1xuXHRcdGFkZERlc2NyaWJlZEJ5KCB0YXJnZXQsIHRvb2x0aXAuYXR0ciggXCJpZFwiICkgKTtcblx0XHR0b29sdGlwLmZpbmQoIFwiLnVpLXRvb2x0aXAtY29udGVudFwiICkuaHRtbCggY29udGVudCApO1xuXG5cdFx0ZnVuY3Rpb24gcG9zaXRpb24oIGV2ZW50ICkge1xuXHRcdFx0cG9zaXRpb25PcHRpb24ub2YgPSBldmVudDtcblx0XHRcdGlmICggdG9vbHRpcC5pcyggXCI6aGlkZGVuXCIgKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dG9vbHRpcC5wb3NpdGlvbiggcG9zaXRpb25PcHRpb24gKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMudHJhY2sgJiYgZXZlbnQgJiYgL15tb3VzZS8udGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0dGhpcy5fb24oIHRoaXMuZG9jdW1lbnQsIHtcblx0XHRcdFx0bW91c2Vtb3ZlOiBwb3NpdGlvblxuXHRcdFx0fSk7XG5cdFx0XHQvLyB0cmlnZ2VyIG9uY2UgdG8gb3ZlcnJpZGUgZWxlbWVudC1yZWxhdGl2ZSBwb3NpdGlvbmluZ1xuXHRcdFx0cG9zaXRpb24oIGV2ZW50ICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRvb2x0aXAucG9zaXRpb24oICQuZXh0ZW5kKHtcblx0XHRcdFx0b2Y6IHRhcmdldFxuXHRcdFx0fSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uICkgKTtcblx0XHR9XG5cblx0XHR0b29sdGlwLmhpZGUoKTtcblxuXHRcdHRoaXMuX3Nob3coIHRvb2x0aXAsIHRoaXMub3B0aW9ucy5zaG93ICk7XG5cdFx0Ly8gSGFuZGxlIHRyYWNraW5nIHRvb2x0aXBzIHRoYXQgYXJlIHNob3duIHdpdGggYSBkZWxheSAoIzg2NDQpLiBBcyBzb29uXG5cdFx0Ly8gYXMgdGhlIHRvb2x0aXAgaXMgdmlzaWJsZSwgcG9zaXRpb24gdGhlIHRvb2x0aXAgdXNpbmcgdGhlIG1vc3QgcmVjZW50XG5cdFx0Ly8gZXZlbnQuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2hvdyAmJiB0aGlzLm9wdGlvbnMuc2hvdy5kZWxheSApIHtcblx0XHRcdGRlbGF5ZWRTaG93ID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdG9vbHRpcC5pcyggXCI6dmlzaWJsZVwiICkgKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24oIHBvc2l0aW9uT3B0aW9uLm9mICk7XG5cdFx0XHRcdFx0Y2xlYXJJbnRlcnZhbCggZGVsYXllZFNob3cgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgJC5meC5pbnRlcnZhbCApO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RyaWdnZXIoIFwib3BlblwiLCBldmVudCwgeyB0b29sdGlwOiB0b29sdGlwIH0gKTtcblxuXHRcdGV2ZW50cyA9IHtcblx0XHRcdGtleXVwOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggZXZlbnQua2V5Q29kZSA9PT0gJC51aS5rZXlDb2RlLkVTQ0FQRSApIHtcblx0XHRcdFx0XHR2YXIgZmFrZUV2ZW50ID0gJC5FdmVudChldmVudCk7XG5cdFx0XHRcdFx0ZmFrZUV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0YXJnZXRbMF07XG5cdFx0XHRcdFx0dGhpcy5jbG9zZSggZmFrZUV2ZW50LCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVUb29sdGlwKCB0b29sdGlwICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRpZiAoICFldmVudCB8fCBldmVudC50eXBlID09PSBcIm1vdXNlb3ZlclwiICkge1xuXHRcdFx0ZXZlbnRzLm1vdXNlbGVhdmUgPSBcImNsb3NlXCI7XG5cdFx0fVxuXHRcdGlmICggIWV2ZW50IHx8IGV2ZW50LnR5cGUgPT09IFwiZm9jdXNpblwiICkge1xuXHRcdFx0ZXZlbnRzLmZvY3Vzb3V0ID0gXCJjbG9zZVwiO1xuXHRcdH1cblx0XHR0aGlzLl9vbiggdHJ1ZSwgdGFyZ2V0LCBldmVudHMgKTtcblx0fSxcblxuXHRjbG9zZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdHRhcmdldCA9ICQoIGV2ZW50ID8gZXZlbnQuY3VycmVudFRhcmdldCA6IHRoaXMuZWxlbWVudCApLFxuXHRcdFx0dG9vbHRpcCA9IHRoaXMuX2ZpbmQoIHRhcmdldCApO1xuXG5cdFx0Ly8gZGlzYWJsaW5nIGNsb3NlcyB0aGUgdG9vbHRpcCwgc28gd2UgbmVlZCB0byB0cmFjayB3aGVuIHdlJ3JlIGNsb3Npbmdcblx0XHQvLyB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wIGluIGNhc2UgdGhlIHRvb2x0aXAgYmVjb21lcyBkaXNhYmxlZCBvbiBjbG9zZVxuXHRcdGlmICggdGhpcy5jbG9zaW5nICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIG9ubHkgc2V0IHRpdGxlIGlmIHdlIGhhZCBvbmUgYmVmb3JlIChzZWUgY29tbWVudCBpbiBfb3BlbigpKVxuXHRcdGlmICggdGFyZ2V0LmRhdGEoIFwidWktdG9vbHRpcC10aXRsZVwiICkgKSB7XG5cdFx0XHR0YXJnZXQuYXR0ciggXCJ0aXRsZVwiLCB0YXJnZXQuZGF0YSggXCJ1aS10b29sdGlwLXRpdGxlXCIgKSApO1xuXHRcdH1cblxuXHRcdHJlbW92ZURlc2NyaWJlZEJ5KCB0YXJnZXQgKTtcblxuXHRcdHRvb2x0aXAuc3RvcCggdHJ1ZSApO1xuXHRcdHRoaXMuX2hpZGUoIHRvb2x0aXAsIHRoaXMub3B0aW9ucy5oaWRlLCBmdW5jdGlvbigpIHtcblx0XHRcdHRoYXQuX3JlbW92ZVRvb2x0aXAoICQoIHRoaXMgKSApO1xuXHRcdH0pO1xuXG5cdFx0dGFyZ2V0LnJlbW92ZURhdGEoIFwidWktdG9vbHRpcC1vcGVuXCIgKTtcblx0XHR0aGlzLl9vZmYoIHRhcmdldCwgXCJtb3VzZWxlYXZlIGZvY3Vzb3V0IGtleXVwXCIgKTtcblx0XHQvLyBSZW1vdmUgJ3JlbW92ZScgYmluZGluZyBvbmx5IG9uIGRlbGVnYXRlZCB0YXJnZXRzXG5cdFx0aWYgKCB0YXJnZXRbMF0gIT09IHRoaXMuZWxlbWVudFswXSApIHtcblx0XHRcdHRoaXMuX29mZiggdGFyZ2V0LCBcInJlbW92ZVwiICk7XG5cdFx0fVxuXHRcdHRoaXMuX29mZiggdGhpcy5kb2N1bWVudCwgXCJtb3VzZW1vdmVcIiApO1xuXG5cdFx0aWYgKCBldmVudCAmJiBldmVudC50eXBlID09PSBcIm1vdXNlbGVhdmVcIiApIHtcblx0XHRcdCQuZWFjaCggdGhpcy5wYXJlbnRzLCBmdW5jdGlvbiggaWQsIHBhcmVudCApIHtcblx0XHRcdFx0JCggcGFyZW50LmVsZW1lbnQgKS5hdHRyKCBcInRpdGxlXCIsIHBhcmVudC50aXRsZSApO1xuXHRcdFx0XHRkZWxldGUgdGhhdC5wYXJlbnRzWyBpZCBdO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jbG9zaW5nID0gdHJ1ZTtcblx0XHR0aGlzLl90cmlnZ2VyKCBcImNsb3NlXCIsIGV2ZW50LCB7IHRvb2x0aXA6IHRvb2x0aXAgfSApO1xuXHRcdHRoaXMuY2xvc2luZyA9IGZhbHNlO1xuXHR9LFxuXG5cdF90b29sdGlwOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR2YXIgaWQgPSBcInVpLXRvb2x0aXAtXCIgKyBpbmNyZW1lbnRzKyssXG5cdFx0XHR0b29sdGlwID0gJCggXCI8ZGl2PlwiIClcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdGlkOiBpZCxcblx0XHRcdFx0XHRyb2xlOiBcInRvb2x0aXBcIlxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYWRkQ2xhc3MoIFwidWktdG9vbHRpcCB1aS13aWRnZXQgdWktY29ybmVyLWFsbCB1aS13aWRnZXQtY29udGVudCBcIiArXG5cdFx0XHRcdFx0KCB0aGlzLm9wdGlvbnMudG9vbHRpcENsYXNzIHx8IFwiXCIgKSApO1xuXHRcdCQoIFwiPGRpdj5cIiApXG5cdFx0XHQuYWRkQ2xhc3MoIFwidWktdG9vbHRpcC1jb250ZW50XCIgKVxuXHRcdFx0LmFwcGVuZFRvKCB0b29sdGlwICk7XG5cdFx0dG9vbHRpcC5hcHBlbmRUbyggdGhpcy5kb2N1bWVudFswXS5ib2R5ICk7XG5cdFx0aWYgKCAkLmZuLmJnaWZyYW1lICkge1xuXHRcdFx0dG9vbHRpcC5iZ2lmcmFtZSgpO1xuXHRcdH1cblx0XHR0aGlzLnRvb2x0aXBzWyBpZCBdID0gZWxlbWVudDtcblx0XHRyZXR1cm4gdG9vbHRpcDtcblx0fSxcblxuXHRfZmluZDogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgaWQgPSB0YXJnZXQuZGF0YSggXCJ1aS10b29sdGlwLWlkXCIgKTtcblx0XHRyZXR1cm4gaWQgPyAkKCBcIiNcIiArIGlkICkgOiAkKCk7XG5cdH0sXG5cblx0X3JlbW92ZVRvb2x0aXA6IGZ1bmN0aW9uKCB0b29sdGlwICkge1xuXHRcdHRvb2x0aXAucmVtb3ZlKCk7XG5cdFx0ZGVsZXRlIHRoaXMudG9vbHRpcHNbIHRvb2x0aXAuYXR0ciggXCJpZFwiICkgXTtcblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0Ly8gY2xvc2Ugb3BlbiB0b29sdGlwc1xuXHRcdCQuZWFjaCggdGhpcy50b29sdGlwcywgZnVuY3Rpb24oIGlkLCBlbGVtZW50ICkge1xuXHRcdFx0Ly8gRGVsZWdhdGUgdG8gY2xvc2UgbWV0aG9kIHRvIGhhbmRsZSBjb21tb24gY2xlYW51cFxuXHRcdFx0dmFyIGV2ZW50ID0gJC5FdmVudCggXCJibHVyXCIgKTtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBlbGVtZW50WzBdO1xuXHRcdFx0dGhhdC5jbG9zZSggZXZlbnQsIHRydWUgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIGltbWVkaWF0ZWx5OyBkZXN0cm95aW5nIGFuIG9wZW4gdG9vbHRpcCBkb2Vzbid0IHVzZSB0aGVcblx0XHRcdC8vIGhpZGUgYW5pbWF0aW9uXG5cdFx0XHQkKCBcIiNcIiArIGlkICkucmVtb3ZlKCk7XG5cblx0XHRcdC8vIFJlc3RvcmUgdGhlIHRpdGxlXG5cdFx0XHRpZiAoIGVsZW1lbnQuZGF0YSggXCJ1aS10b29sdGlwLXRpdGxlXCIgKSApIHtcblx0XHRcdFx0ZWxlbWVudC5hdHRyKCBcInRpdGxlXCIsIGVsZW1lbnQuZGF0YSggXCJ1aS10b29sdGlwLXRpdGxlXCIgKSApO1xuXHRcdFx0XHRlbGVtZW50LnJlbW92ZURhdGEoIFwidWktdG9vbHRpcC10aXRsZVwiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG59KCBqUXVlcnkgKSApO1xuIiwiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYxLjcuMlxuICogaHR0cDovL2pxdWVyeS5jb20vXG4gKlxuICogQ29weXJpZ2h0IDIwMTEsIEpvaG4gUmVzaWdcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBvciBHUEwgVmVyc2lvbiAyIGxpY2Vuc2VzLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cDovL3NpenpsZWpzLmNvbS9cbiAqIENvcHlyaWdodCAyMDExLCBUaGUgRG9qbyBGb3VuZGF0aW9uXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlULCBCU0QsIGFuZCBHUEwgTGljZW5zZXMuXG4gKlxuICogRGF0ZTogV2VkIE1hciAyMSAxMjo0NjozNCAyMDEyIC0wNzAwXG4gKi9cbihmdW5jdGlvbiggd2luZG93LCB1bmRlZmluZWQgKSB7XG5cbi8vIFVzZSB0aGUgY29ycmVjdCBkb2N1bWVudCBhY2NvcmRpbmdseSB3aXRoIHdpbmRvdyBhcmd1bWVudCAoc2FuZGJveClcbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcblx0bmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcixcblx0bG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG52YXIgalF1ZXJ5ID0gKGZ1bmN0aW9uKCkge1xuXG4vLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxudmFyIGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCwgcm9vdGpRdWVyeSApO1xuXHR9LFxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kLFxuXG5cdC8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxuXHRyb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzIG9yIElEIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHRxdWlja0V4cHIgPSAvXig/OlteIzxdKig8W1xcd1xcV10rPilbXj5dKiR8IyhbXFx3XFwtXSopJCkvLFxuXG5cdC8vIENoZWNrIGlmIGEgc3RyaW5nIGhhcyBhIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlciBpbiBpdFxuXHRybm90d2hpdGUgPSAvXFxTLyxcblxuXHQvLyBVc2VkIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlXG5cdHRyaW1MZWZ0ID0gL15cXHMrLyxcblx0dHJpbVJpZ2h0ID0gL1xccyskLyxcblxuXHQvLyBNYXRjaCBhIHN0YW5kYWxvbmUgdGFnXG5cdHJzaW5nbGVUYWcgPSAvXjwoXFx3KylcXHMqXFwvPz4oPzo8XFwvXFwxPik/JC8sXG5cblx0Ly8gSlNPTiBSZWdFeHBcblx0cnZhbGlkY2hhcnMgPSAvXltcXF0sOnt9XFxzXSokLyxcblx0cnZhbGlkZXNjYXBlID0gL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbMC05YS1mQS1GXXs0fSkvZyxcblx0cnZhbGlkdG9rZW5zID0gL1wiW15cIlxcXFxcXG5cXHJdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nLFxuXHRydmFsaWRicmFjZXMgPSAvKD86Xnw6fCwpKD86XFxzKlxcWykrL2csXG5cblx0Ly8gVXNlcmFnZW50IFJlZ0V4cFxuXHRyd2Via2l0ID0gLyh3ZWJraXQpWyBcXC9dKFtcXHcuXSspLyxcblx0cm9wZXJhID0gLyhvcGVyYSkoPzouKnZlcnNpb24pP1sgXFwvXShbXFx3Ll0rKS8sXG5cdHJtc2llID0gLyhtc2llKSAoW1xcdy5dKykvLFxuXHRybW96aWxsYSA9IC8obW96aWxsYSkoPzouKj8gcnY6KFtcXHcuXSspKT8vLFxuXG5cdC8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xuXHRyZGFzaEFscGhhID0gLy0oW2Etel18WzAtOV0pL2lnLFxuXHRybXNQcmVmaXggPSAvXi1tcy0vLFxuXG5cdC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcblx0ZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcblx0XHRyZXR1cm4gKCBsZXR0ZXIgKyBcIlwiICkudG9VcHBlckNhc2UoKTtcblx0fSxcblxuXHQvLyBLZWVwIGEgVXNlckFnZW50IHN0cmluZyBmb3IgdXNlIHdpdGggalF1ZXJ5LmJyb3dzZXJcblx0dXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcblxuXHQvLyBGb3IgbWF0Y2hpbmcgdGhlIGVuZ2luZSBhbmQgdmVyc2lvbiBvZiB0aGUgYnJvd3NlclxuXHRicm93c2VyTWF0Y2gsXG5cblx0Ly8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG5cdHJlYWR5TGlzdCxcblxuXHQvLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlclxuXHRET01Db250ZW50TG9hZGVkLFxuXG5cdC8vIFNhdmUgYSByZWZlcmVuY2UgdG8gc29tZSBjb3JlIG1ldGhvZHNcblx0dG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuXHRoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuXHRwdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2gsXG5cdHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuXHR0cmltID0gU3RyaW5nLnByb3RvdHlwZS50cmltLFxuXHRpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YsXG5cblx0Ly8gW1tDbGFzc11dIC0+IHR5cGUgcGFpcnNcblx0Y2xhc3MydHlwZSA9IHt9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXHRpbml0OiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3RqUXVlcnkgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtLCByZXQsIGRvYztcblxuXHRcdC8vIEhhbmRsZSAkKFwiXCIpLCAkKG51bGwpLCBvciAkKHVuZGVmaW5lZClcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSAkKERPTUVsZW1lbnQpXG5cdFx0aWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXMuY29udGV4dCA9IHRoaXNbMF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIFRoZSBib2R5IGVsZW1lbnQgb25seSBleGlzdHMgb25jZSwgb3B0aW1pemUgZmluZGluZyBpdFxuXHRcdGlmICggc2VsZWN0b3IgPT09IFwiYm9keVwiICYmICFjb250ZXh0ICYmIGRvY3VtZW50LmJvZHkgKSB7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBkb2N1bWVudDtcblx0XHRcdHRoaXNbMF0gPSBkb2N1bWVudC5ib2R5O1xuXHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Ly8gQXJlIHdlIGRlYWxpbmcgd2l0aCBIVE1MIHN0cmluZyBvciBhbiBJRD9cblx0XHRcdGlmICggc2VsZWN0b3IuY2hhckF0KDApID09PSBcIjxcIiAmJiBzZWxlY3Rvci5jaGFyQXQoIHNlbGVjdG9yLmxlbmd0aCAtIDEgKSA9PT0gXCI+XCIgJiYgc2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBWZXJpZnkgYSBtYXRjaCwgYW5kIHRoYXQgbm8gY29udGV4dCB3YXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKG1hdGNoWzFdIHx8ICFjb250ZXh0KSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsxXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbMF0gOiBjb250ZXh0O1xuXHRcdFx0XHRcdGRvYyA9ICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQgKTtcblxuXHRcdFx0XHRcdC8vIElmIGEgc2luZ2xlIHN0cmluZyBpcyBwYXNzZWQgaW4gYW5kIGl0J3MgYSBzaW5nbGUgdGFnXG5cdFx0XHRcdFx0Ly8ganVzdCBkbyBhIGNyZWF0ZUVsZW1lbnQgYW5kIHNraXAgdGhlIHJlc3Rcblx0XHRcdFx0XHRyZXQgPSByc2luZ2xlVGFnLmV4ZWMoIHNlbGVjdG9yICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCApIHtcblx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdFx0c2VsZWN0b3IgPSBbIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIHJldFsxXSApIF07XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5mbi5hdHRyLmNhbGwoIHNlbGVjdG9yLCBjb250ZXh0LCB0cnVlICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNlbGVjdG9yID0gWyBkb2MuY3JlYXRlRWxlbWVudCggcmV0WzFdICkgXTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXQgPSBqUXVlcnkuYnVpbGRGcmFnbWVudCggWyBtYXRjaFsxXSBdLCBbIGRvYyBdICk7XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9ICggcmV0LmNhY2hlYWJsZSA/IGpRdWVyeS5jbG9uZShyZXQuZnJhZ21lbnQpIDogcmV0LmZyYWdtZW50ICkuY2hpbGROb2Rlcztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCB0aGlzLCBzZWxlY3RvciApO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChcIiNpZFwiKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbMl0gKTtcblxuXHRcdFx0XHRcdC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXG5cdFx0XHRcdFx0Ly8gbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAjNjk2M1xuXHRcdFx0XHRcdGlmICggZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgSUUgYW5kIE9wZXJhIHJldHVybiBpdGVtc1xuXHRcdFx0XHRcdFx0Ly8gYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgIT09IG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcm9vdGpRdWVyeS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIHdlIGluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0XHR0aGlzWzBdID0gZWxlbTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLmNvbnRleHQgPSBkb2N1bWVudDtcblx0XHRcdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3RqUXVlcnkgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3RqUXVlcnkucmVhZHkoIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3Rvci5zZWxlY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yLnNlbGVjdG9yO1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gc2VsZWN0b3IuY29udGV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fSxcblxuXHQvLyBTdGFydCB3aXRoIGFuIGVtcHR5IHNlbGVjdG9yXG5cdHNlbGVjdG9yOiBcIlwiLFxuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiBcIjEuNy4yXCIsXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHQvLyBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRzaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5sZW5ndGg7XG5cdH0sXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMsIDAgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblx0XHRyZXR1cm4gbnVtID09IG51bGwgP1xuXG5cdFx0XHQvLyBSZXR1cm4gYSAnY2xlYW4nIGFycmF5XG5cdFx0XHR0aGlzLnRvQXJyYXkoKSA6XG5cblx0XHRcdC8vIFJldHVybiBqdXN0IHRoZSBvYmplY3Rcblx0XHRcdCggbnVtIDwgMCA/IHRoaXNbIHRoaXMubGVuZ3RoICsgbnVtIF0gOiB0aGlzWyBudW0gXSApO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zLCBuYW1lLCBzZWxlY3RvciApIHtcblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBlbGVtcyApICkge1xuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LCBlbGVtcyApO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0cmV0LmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cblx0XHRpZiAoIG5hbWUgPT09IFwiZmluZFwiICkge1xuXHRcdFx0cmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciArICggdGhpcy5zZWxlY3RvciA/IFwiIFwiIDogXCJcIiApICsgc2VsZWN0b3I7XG5cdFx0fSBlbHNlIGlmICggbmFtZSApIHtcblx0XHRcdHJldC5zZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IgKyBcIi5cIiArIG5hbWUgKyBcIihcIiArIHNlbGVjdG9yICsgXCIpXCI7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdC8vIChZb3UgY2FuIHNlZWQgdGhlIGFyZ3VtZW50cyB3aXRoIGFuIGFycmF5IG9mIGFyZ3MsIGJ1dCB0aGlzIGlzXG5cdC8vIG9ubHkgdXNlZCBpbnRlcm5hbGx5Lilcblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrLCBhcmdzICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2ssIGFyZ3MgKTtcblx0fSxcblxuXHRyZWFkeTogZnVuY3Rpb24oIGZuICkge1xuXHRcdC8vIEF0dGFjaCB0aGUgbGlzdGVuZXJzXG5cdFx0alF1ZXJ5LmJpbmRSZWFkeSgpO1xuXG5cdFx0Ly8gQWRkIHRoZSBjYWxsYmFja1xuXHRcdHJlYWR5TGlzdC5hZGQoIGZuICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0aSA9ICtpO1xuXHRcdHJldHVybiBpID09PSAtMSA/XG5cdFx0XHR0aGlzLnNsaWNlKCBpICkgOlxuXHRcdFx0dGhpcy5zbGljZSggaSwgaSArIDEgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICksXG5cdFx0XHRcInNsaWNlXCIsIHNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiLFwiKSApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCh0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSkpO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKG51bGwpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IFtdLnNvcnQsXG5cdHNwbGljZTogW10uc3BsaWNlXG59O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5qUXVlcnkuZm4uaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuXHRcdC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHRpID0gMjtcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKHRhcmdldCkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBleHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBsZW5ndGggPT09IGkgKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHQtLWk7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAob3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdKSAhPSBudWxsICkge1xuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0galF1ZXJ5LmlzQXJyYXkoY29weSkpICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSApIHtcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNBcnJheShzcmMpID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdG5vQ29uZmxpY3Q6IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRcdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHRcdHdpbmRvdy4kID0gXyQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0sXG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSG9sZCAob3IgcmVsZWFzZSkgdGhlIHJlYWR5IGV2ZW50XG5cdGhvbGRSZWFkeTogZnVuY3Rpb24oIGhvbGQgKSB7XG5cdFx0aWYgKCBob2xkICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cdFx0Ly8gRWl0aGVyIGEgcmVsZWFzZWQgaG9sZCBvciBhbiBET01yZWFkeS9sb2FkIGV2ZW50IGFuZCBub3QgeWV0IHJlYWR5XG5cdFx0aWYgKCAod2FpdCA9PT0gdHJ1ZSAmJiAhLS1qUXVlcnkucmVhZHlXYWl0KSB8fCAod2FpdCAhPT0gdHJ1ZSAmJiAhalF1ZXJ5LmlzUmVhZHkpICkge1xuXHRcdFx0Ly8gTWFrZSBzdXJlIGJvZHkgZXhpc3RzLCBhdCBsZWFzdCwgaW4gY2FzZSBJRSBnZXRzIGEgbGl0dGxlIG92ZXJ6ZWFsb3VzICh0aWNrZXQgIzU0NDMpLlxuXHRcdFx0aWYgKCAhZG9jdW1lbnQuYm9keSApIHtcblx0XHRcdFx0cmV0dXJuIHNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSwgMSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRcdHJlYWR5TGlzdC5maXJlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblxuXHRcdFx0Ly8gVHJpZ2dlciBhbnkgYm91bmQgcmVhZHkgZXZlbnRzXG5cdFx0XHRpZiAoIGpRdWVyeS5mbi50cmlnZ2VyICkge1xuXHRcdFx0XHRqUXVlcnkoIGRvY3VtZW50ICkudHJpZ2dlciggXCJyZWFkeVwiICkub2ZmKCBcInJlYWR5XCIgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0YmluZFJlYWR5OiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHJlYWR5TGlzdCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRyZWFkeUxpc3QgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKTtcblxuXHRcdC8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkIGFmdGVyIHRoZVxuXHRcdC8vIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG5cdFx0aWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgKSB7XG5cdFx0XHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0XHRcdHJldHVybiBzZXRUaW1lb3V0KCBqUXVlcnkucmVhZHksIDEgKTtcblx0XHR9XG5cblx0XHQvLyBNb3ppbGxhLCBPcGVyYSBhbmQgd2Via2l0IG5pZ2h0bGllcyBjdXJyZW50bHkgc3VwcG9ydCB0aGlzIGV2ZW50XG5cdFx0aWYgKCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIERPTUNvbnRlbnRMb2FkZWQsIGZhbHNlICk7XG5cblx0XHRcdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGpRdWVyeS5yZWFkeSwgZmFsc2UgKTtcblxuXHRcdC8vIElmIElFIGV2ZW50IG1vZGVsIGlzIHVzZWRcblx0XHR9IGVsc2UgaWYgKCBkb2N1bWVudC5hdHRhY2hFdmVudCApIHtcblx0XHRcdC8vIGVuc3VyZSBmaXJpbmcgYmVmb3JlIG9ubG9hZCxcblx0XHRcdC8vIG1heWJlIGxhdGUgYnV0IHNhZmUgYWxzbyBmb3IgaWZyYW1lc1xuXHRcdFx0ZG9jdW1lbnQuYXR0YWNoRXZlbnQoIFwib25yZWFkeXN0YXRlY2hhbmdlXCIsIERPTUNvbnRlbnRMb2FkZWQgKTtcblxuXHRcdFx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0XHRcdHdpbmRvdy5hdHRhY2hFdmVudCggXCJvbmxvYWRcIiwgalF1ZXJ5LnJlYWR5ICk7XG5cblx0XHRcdC8vIElmIElFIGFuZCBub3QgYSBmcmFtZVxuXHRcdFx0Ly8gY29udGludWFsbHkgY2hlY2sgdG8gc2VlIGlmIHRoZSBkb2N1bWVudCBpcyByZWFkeVxuXHRcdFx0dmFyIHRvcGxldmVsID0gZmFsc2U7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRvcGxldmVsID0gd2luZG93LmZyYW1lRWxlbWVudCA9PSBudWxsO1xuXHRcdFx0fSBjYXRjaChlKSB7fVxuXG5cdFx0XHRpZiAoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCAmJiB0b3BsZXZlbCApIHtcblx0XHRcdFx0ZG9TY3JvbGxDaGVjaygpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBTZWUgdGVzdC91bml0L2NvcmUuanMgZm9yIGRldGFpbHMgY29uY2VybmluZyBpc0Z1bmN0aW9uLlxuXHQvLyBTaW5jZSB2ZXJzaW9uIDEuMywgRE9NIG1ldGhvZHMgYW5kIGZ1bmN0aW9ucyBsaWtlIGFsZXJ0XG5cdC8vIGFyZW4ndCBzdXBwb3J0ZWQuIFRoZXkgcmV0dXJuIGZhbHNlIG9uIElFICgjMjk2OCkuXG5cdGlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS50eXBlKG9iaikgPT09IFwiZnVuY3Rpb25cIjtcblx0fSxcblxuXHRpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS50eXBlKG9iaikgPT09IFwiYXJyYXlcIjtcblx0fSxcblxuXHRpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09IG9iai53aW5kb3c7XG5cdH0sXG5cblx0aXNOdW1lcmljOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiAhaXNOYU4oIHBhcnNlRmxvYXQob2JqKSApICYmIGlzRmluaXRlKCBvYmogKTtcblx0fSxcblxuXHR0eXBlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBvYmogPT0gbnVsbCA/XG5cdFx0XHRTdHJpbmcoIG9iaiApIDpcblx0XHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwob2JqKSBdIHx8IFwib2JqZWN0XCI7XG5cdH0sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHQvLyBNdXN0IGJlIGFuIE9iamVjdC5cblx0XHQvLyBCZWNhdXNlIG9mIElFLCB3ZSBhbHNvIGhhdmUgdG8gY2hlY2sgdGhlIHByZXNlbmNlIG9mIHRoZSBjb25zdHJ1Y3RvciBwcm9wZXJ0eS5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBET00gbm9kZXMgYW5kIHdpbmRvdyBvYmplY3RzIGRvbid0IHBhc3MgdGhyb3VnaCwgYXMgd2VsbFxuXHRcdGlmICggIW9iaiB8fCBqUXVlcnkudHlwZShvYmopICE9PSBcIm9iamVjdFwiIHx8IG9iai5ub2RlVHlwZSB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBOb3Qgb3duIGNvbnN0cnVjdG9yIHByb3BlcnR5IG11c3QgYmUgT2JqZWN0XG5cdFx0XHRpZiAoIG9iai5jb25zdHJ1Y3RvciAmJlxuXHRcdFx0XHQhaGFzT3duLmNhbGwob2JqLCBcImNvbnN0cnVjdG9yXCIpICYmXG5cdFx0XHRcdCFoYXNPd24uY2FsbChvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCBcImlzUHJvdG90eXBlT2ZcIikgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdC8vIElFOCw5IFdpbGwgdGhyb3cgZXhjZXB0aW9ucyBvbiBjZXJ0YWluIGhvc3Qgb2JqZWN0cyAjOTg5N1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIE93biBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhdGVkIGZpcnN0bHksIHNvIHRvIHNwZWVkIHVwLFxuXHRcdC8vIGlmIGxhc3Qgb25lIGlzIG93biwgdGhlbiBhbGwgcHJvcGVydGllcyBhcmUgb3duLlxuXG5cdFx0dmFyIGtleTtcblx0XHRmb3IgKCBrZXkgaW4gb2JqICkge31cblxuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCB8fCBoYXNPd24uY2FsbCggb2JqLCBrZXkgKTtcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdGZvciAoIHZhciBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRwYXJzZUpTT046IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdGlmICggdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgfHwgIWRhdGEgKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgbGVhZGluZy90cmFpbGluZyB3aGl0ZXNwYWNlIGlzIHJlbW92ZWQgKElFIGNhbid0IGhhbmRsZSBpdClcblx0XHRkYXRhID0galF1ZXJ5LnRyaW0oIGRhdGEgKTtcblxuXHRcdC8vIEF0dGVtcHQgdG8gcGFyc2UgdXNpbmcgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdFxuXHRcdGlmICggd2luZG93LkpTT04gJiYgd2luZG93LkpTT04ucGFyc2UgKSB7XG5cdFx0XHRyZXR1cm4gd2luZG93LkpTT04ucGFyc2UoIGRhdGEgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhlIGluY29taW5nIGRhdGEgaXMgYWN0dWFsIEpTT05cblx0XHQvLyBMb2dpYyBib3Jyb3dlZCBmcm9tIGh0dHA6Ly9qc29uLm9yZy9qc29uMi5qc1xuXHRcdGlmICggcnZhbGlkY2hhcnMudGVzdCggZGF0YS5yZXBsYWNlKCBydmFsaWRlc2NhcGUsIFwiQFwiIClcblx0XHRcdC5yZXBsYWNlKCBydmFsaWR0b2tlbnMsIFwiXVwiIClcblx0XHRcdC5yZXBsYWNlKCBydmFsaWRicmFjZXMsIFwiXCIpKSApIHtcblxuXHRcdFx0cmV0dXJuICggbmV3IEZ1bmN0aW9uKCBcInJldHVybiBcIiArIGRhdGEgKSApKCk7XG5cblx0XHR9XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgSlNPTjogXCIgKyBkYXRhICk7XG5cdH0sXG5cblx0Ly8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xuXHRwYXJzZVhNTDogZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiB8fCAhZGF0YSApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHR2YXIgeG1sLCB0bXA7XG5cdFx0dHJ5IHtcblx0XHRcdGlmICggd2luZG93LkRPTVBhcnNlciApIHsgLy8gU3RhbmRhcmRcblx0XHRcdFx0dG1wID0gbmV3IERPTVBhcnNlcigpO1xuXHRcdFx0XHR4bWwgPSB0bXAucGFyc2VGcm9tU3RyaW5nKCBkYXRhICwgXCJ0ZXh0L3htbFwiICk7XG5cdFx0XHR9IGVsc2UgeyAvLyBJRVxuXHRcdFx0XHR4bWwgPSBuZXcgQWN0aXZlWE9iamVjdCggXCJNaWNyb3NvZnQuWE1MRE9NXCIgKTtcblx0XHRcdFx0eG1sLmFzeW5jID0gXCJmYWxzZVwiO1xuXHRcdFx0XHR4bWwubG9hZFhNTCggZGF0YSApO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2goIGUgKSB7XG5cdFx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggIXhtbCB8fCAheG1sLmRvY3VtZW50RWxlbWVudCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdFx0fVxuXHRcdHJldHVybiB4bWw7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHQvLyBXb3JrYXJvdW5kcyBiYXNlZCBvbiBmaW5kaW5ncyBieSBKaW0gRHJpc2NvbGxcblx0Ly8gaHR0cDovL3dlYmxvZ3MuamF2YS5uZXQvYmxvZy9kcmlzY29sbC9hcmNoaXZlLzIwMDkvMDkvMDgvZXZhbC1qYXZhc2NyaXB0LWdsb2JhbC1jb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdGlmICggZGF0YSAmJiBybm90d2hpdGUudGVzdCggZGF0YSApICkge1xuXHRcdFx0Ly8gV2UgdXNlIGV4ZWNTY3JpcHQgb24gSW50ZXJuZXQgRXhwbG9yZXJcblx0XHRcdC8vIFdlIHVzZSBhbiBhbm9ueW1vdXMgZnVuY3Rpb24gc28gdGhhdCBjb250ZXh0IGlzIHdpbmRvd1xuXHRcdFx0Ly8gcmF0aGVyIHRoYW4galF1ZXJ5IGluIEZpcmVmb3hcblx0XHRcdCggd2luZG93LmV4ZWNTY3JpcHQgfHwgZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0XHRcdHdpbmRvd1sgXCJldmFsXCIgXS5jYWxsKCB3aW5kb3csIGRhdGEgKTtcblx0XHRcdH0gKSggZGF0YSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5hbWUudG9VcHBlckNhc2UoKTtcblx0fSxcblxuXHQvLyBhcmdzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmplY3QsIGNhbGxiYWNrLCBhcmdzICkge1xuXHRcdHZhciBuYW1lLCBpID0gMCxcblx0XHRcdGxlbmd0aCA9IG9iamVjdC5sZW5ndGgsXG5cdFx0XHRpc09iaiA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0Z1bmN0aW9uKCBvYmplY3QgKTtcblxuXHRcdGlmICggYXJncyApIHtcblx0XHRcdGlmICggaXNPYmogKSB7XG5cdFx0XHRcdGZvciAoIG5hbWUgaW4gb2JqZWN0ICkge1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2suYXBwbHkoIG9iamVjdFsgbmFtZSBdLCBhcmdzICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2suYXBwbHkoIG9iamVjdFsgaSsrIF0sIGFyZ3MgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEEgc3BlY2lhbCwgZmFzdCwgY2FzZSBmb3IgdGhlIG1vc3QgY29tbW9uIHVzZSBvZiBlYWNoXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggaXNPYmogKSB7XG5cdFx0XHRcdGZvciAoIG5hbWUgaW4gb2JqZWN0ICkge1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqZWN0WyBuYW1lIF0sIG5hbWUsIG9iamVjdFsgbmFtZSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqZWN0WyBpIF0sIGksIG9iamVjdFsgaSsrIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqZWN0O1xuXHR9LFxuXG5cdC8vIFVzZSBuYXRpdmUgU3RyaW5nLnRyaW0gZnVuY3Rpb24gd2hlcmV2ZXIgcG9zc2libGVcblx0dHJpbTogdHJpbSA/XG5cdFx0ZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdHRyaW0uY2FsbCggdGV4dCApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHVzZSBvdXIgb3duIHRyaW1taW5nIGZ1bmN0aW9uYWxpdHlcblx0XHRmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0dGV4dC50b1N0cmluZygpLnJlcGxhY2UoIHRyaW1MZWZ0LCBcIlwiICkucmVwbGFjZSggdHJpbVJpZ2h0LCBcIlwiICk7XG5cdFx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFycmF5LCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnJheSAhPSBudWxsICkge1xuXHRcdFx0Ly8gVGhlIHdpbmRvdywgc3RyaW5ncyAoYW5kIGZ1bmN0aW9ucykgYWxzbyBoYXZlICdsZW5ndGgnXG5cdFx0XHQvLyBUd2Vha2VkIGxvZ2ljIHNsaWdodGx5IHRvIGhhbmRsZSBCbGFja2JlcnJ5IDQuNyBSZWdFeHAgaXNzdWVzICM2OTMwXG5cdFx0XHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBhcnJheSApO1xuXG5cdFx0XHRpZiAoIGFycmF5Lmxlbmd0aCA9PSBudWxsIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGUgPT09IFwicmVnZXhwXCIgfHwgalF1ZXJ5LmlzV2luZG93KCBhcnJheSApICkge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyYXkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LCBhcnJheSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFycmF5LCBpICkge1xuXHRcdHZhciBsZW47XG5cblx0XHRpZiAoIGFycmF5ICkge1xuXHRcdFx0aWYgKCBpbmRleE9mICkge1xuXHRcdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBhcnJheSwgZWxlbSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRsZW4gPSBhcnJheS5sZW5ndGg7XG5cdFx0XHRpID0gaSA/IGkgPCAwID8gTWF0aC5tYXgoIDAsIGxlbiArIGkgKSA6IGkgOiAwO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Ly8gU2tpcCBhY2Nlc3NpbmcgaW4gc3BhcnNlIGFycmF5c1xuXHRcdFx0XHRpZiAoIGkgaW4gYXJyYXkgJiYgYXJyYXlbIGkgXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGkgPSBmaXJzdC5sZW5ndGgsXG5cdFx0XHRqID0gMDtcblxuXHRcdGlmICggdHlwZW9mIHNlY29uZC5sZW5ndGggPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRmb3IgKCB2YXIgbCA9IHNlY29uZC5sZW5ndGg7IGogPCBsOyBqKysgKSB7XG5cdFx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHdoaWxlICggc2Vjb25kW2pdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaisrIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnYgKSB7XG5cdFx0dmFyIHJldCA9IFtdLCByZXRWYWw7XG5cdFx0aW52ID0gISFpbnY7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGxlbmd0aCA9IGVsZW1zLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0cmV0VmFsID0gISFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBpbnYgIT09IHJldFZhbCApIHtcblx0XHRcdFx0cmV0LnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgdmFsdWUsIGtleSwgcmV0ID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdC8vIGpxdWVyeSBvYmplY3RzIGFyZSB0cmVhdGVkIGFzIGFycmF5c1xuXHRcdFx0aXNBcnJheSA9IGVsZW1zIGluc3RhbmNlb2YgalF1ZXJ5IHx8IGxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgKCAoIGxlbmd0aCA+IDAgJiYgZWxlbXNbIDAgXSAmJiBlbGVtc1sgbGVuZ3RoIC0xIF0gKSB8fCBsZW5ndGggPT09IDAgfHwgalF1ZXJ5LmlzQXJyYXkoIGVsZW1zICkgKSA7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXJcblx0XHRpZiAoIGlzQXJyYXkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldFsgcmV0Lmxlbmd0aCBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGtleSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGtleSBdLCBrZXksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXRbIHJldC5sZW5ndGggXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiByZXQuY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG5cdC8vIGFyZ3VtZW50cy5cblx0cHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dmFyIHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0XHRjb250ZXh0ID0gZm47XG5cdFx0XHRmbiA9IHRtcDtcblx0XHR9XG5cblx0XHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHRcdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFNpbXVsYXRlZCBiaW5kXG5cdFx0dmFyIGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKSxcblx0XHRcdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCwgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0XHRcdH07XG5cblx0XHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0XHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgcHJveHkuZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdFx0cmV0dXJuIHByb3h5O1xuXHR9LFxuXG5cdC8vIE11dGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgdG8gYSBjb2xsZWN0aW9uXG5cdC8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHBhc3MgKSB7XG5cdFx0dmFyIGV4ZWMsXG5cdFx0XHRidWxrID0ga2V5ID09IG51bGwsXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0XHRpZiAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRcdGpRdWVyeS5hY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5W2ldLCAxLCBlbXB0eUdldCwgdmFsdWUgKTtcblx0XHRcdH1cblx0XHRcdGNoYWluYWJsZSA9IDE7XG5cblx0XHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQvLyBPcHRpb25hbGx5LCBmdW5jdGlvbiB2YWx1ZXMgZ2V0IGV4ZWN1dGVkIGlmIGV4ZWMgaXMgdHJ1ZVxuXHRcdFx0ZXhlYyA9IHBhc3MgPT09IHVuZGVmaW5lZCAmJiBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdFx0aWYgKCBidWxrICkge1xuXHRcdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgb25seSBpdGVyYXRlIHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0XHRpZiAoIGV4ZWMgKSB7XG5cdFx0XHRcdFx0ZXhlYyA9IGZuO1xuXHRcdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZXhlYy5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB0aGV5IHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdFx0Zm4gPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZm4gKSB7XG5cdFx0XHRcdGZvciAoOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0Zm4oIGVsZW1zW2ldLCBrZXksIGV4ZWMgPyB2YWx1ZS5jYWxsKCBlbGVtc1tpXSwgaSwgZm4oIGVsZW1zW2ldLCBrZXkgKSApIDogdmFsdWUsIHBhc3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjaGFpbmFibGUgPSAxO1xuXHRcdH1cblxuXHRcdHJldHVybiBjaGFpbmFibGUgP1xuXHRcdFx0ZWxlbXMgOlxuXG5cdFx0XHQvLyBHZXRzXG5cdFx0XHRidWxrID9cblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMgKSA6XG5cdFx0XHRcdGxlbmd0aCA/IGZuKCBlbGVtc1swXSwga2V5ICkgOiBlbXB0eUdldDtcblx0fSxcblxuXHRub3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAoIG5ldyBEYXRlKCkgKS5nZXRUaW1lKCk7XG5cdH0sXG5cblx0Ly8gVXNlIG9mIGpRdWVyeS5icm93c2VyIGlzIGZyb3duZWQgdXBvbi5cblx0Ly8gTW9yZSBkZXRhaWxzOiBodHRwOi8vZG9jcy5qcXVlcnkuY29tL1V0aWxpdGllcy9qUXVlcnkuYnJvd3NlclxuXHR1YU1hdGNoOiBmdW5jdGlvbiggdWEgKSB7XG5cdFx0dWEgPSB1YS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0dmFyIG1hdGNoID0gcndlYmtpdC5leGVjKCB1YSApIHx8XG5cdFx0XHRyb3BlcmEuZXhlYyggdWEgKSB8fFxuXHRcdFx0cm1zaWUuZXhlYyggdWEgKSB8fFxuXHRcdFx0dWEuaW5kZXhPZihcImNvbXBhdGlibGVcIikgPCAwICYmIHJtb3ppbGxhLmV4ZWMoIHVhICkgfHxcblx0XHRcdFtdO1xuXG5cdFx0cmV0dXJuIHsgYnJvd3NlcjogbWF0Y2hbMV0gfHwgXCJcIiwgdmVyc2lvbjogbWF0Y2hbMl0gfHwgXCIwXCIgfTtcblx0fSxcblxuXHRzdWI6IGZ1bmN0aW9uKCkge1xuXHRcdGZ1bmN0aW9uIGpRdWVyeVN1Yiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0XHRyZXR1cm4gbmV3IGpRdWVyeVN1Yi5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHRcdH1cblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCBqUXVlcnlTdWIsIHRoaXMgKTtcblx0XHRqUXVlcnlTdWIuc3VwZXJjbGFzcyA9IHRoaXM7XG5cdFx0alF1ZXJ5U3ViLmZuID0galF1ZXJ5U3ViLnByb3RvdHlwZSA9IHRoaXMoKTtcblx0XHRqUXVlcnlTdWIuZm4uY29uc3RydWN0b3IgPSBqUXVlcnlTdWI7XG5cdFx0alF1ZXJ5U3ViLnN1YiA9IHRoaXMuc3ViO1xuXHRcdGpRdWVyeVN1Yi5mbi5pbml0ID0gZnVuY3Rpb24gaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIGNvbnRleHQgJiYgY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSAmJiAhKGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnlTdWIpICkge1xuXHRcdFx0XHRjb250ZXh0ID0galF1ZXJ5U3ViKCBjb250ZXh0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBqUXVlcnkuZm4uaW5pdC5jYWxsKCB0aGlzLCBzZWxlY3RvciwgY29udGV4dCwgcm9vdGpRdWVyeVN1YiApO1xuXHRcdH07XG5cdFx0alF1ZXJ5U3ViLmZuLmluaXQucHJvdG90eXBlID0galF1ZXJ5U3ViLmZuO1xuXHRcdHZhciByb290alF1ZXJ5U3ViID0galF1ZXJ5U3ViKGRvY3VtZW50KTtcblx0XHRyZXR1cm4galF1ZXJ5U3ViO1xuXHR9LFxuXG5cdGJyb3dzZXI6IHt9XG59KTtcblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaChcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3RcIi5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKGksIG5hbWUpIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59KTtcblxuYnJvd3Nlck1hdGNoID0galF1ZXJ5LnVhTWF0Y2goIHVzZXJBZ2VudCApO1xuaWYgKCBicm93c2VyTWF0Y2guYnJvd3NlciApIHtcblx0alF1ZXJ5LmJyb3dzZXJbIGJyb3dzZXJNYXRjaC5icm93c2VyIF0gPSB0cnVlO1xuXHRqUXVlcnkuYnJvd3Nlci52ZXJzaW9uID0gYnJvd3Nlck1hdGNoLnZlcnNpb247XG59XG5cbi8vIERlcHJlY2F0ZWQsIHVzZSBqUXVlcnkuYnJvd3Nlci53ZWJraXQgaW5zdGVhZFxuaWYgKCBqUXVlcnkuYnJvd3Nlci53ZWJraXQgKSB7XG5cdGpRdWVyeS5icm93c2VyLnNhZmFyaSA9IHRydWU7XG59XG5cbi8vIElFIGRvZXNuJ3QgbWF0Y2ggbm9uLWJyZWFraW5nIHNwYWNlcyB3aXRoIFxcc1xuaWYgKCBybm90d2hpdGUudGVzdCggXCJcXHhBMFwiICkgKSB7XG5cdHRyaW1MZWZ0ID0gL15bXFxzXFx4QTBdKy87XG5cdHRyaW1SaWdodCA9IC9bXFxzXFx4QTBdKyQvO1xufVxuXG4vLyBBbGwgalF1ZXJ5IG9iamVjdHMgc2hvdWxkIHBvaW50IGJhY2sgdG8gdGhlc2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoZG9jdW1lbnQpO1xuXG4vLyBDbGVhbnVwIGZ1bmN0aW9ucyBmb3IgdGhlIGRvY3VtZW50IHJlYWR5IG1ldGhvZFxuaWYgKCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICkge1xuXHRET01Db250ZW50TG9hZGVkID0gZnVuY3Rpb24oKSB7XG5cdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIERPTUNvbnRlbnRMb2FkZWQsIGZhbHNlICk7XG5cdFx0alF1ZXJ5LnJlYWR5KCk7XG5cdH07XG5cbn0gZWxzZSBpZiAoIGRvY3VtZW50LmF0dGFjaEV2ZW50ICkge1xuXHRET01Db250ZW50TG9hZGVkID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gTWFrZSBzdXJlIGJvZHkgZXhpc3RzLCBhdCBsZWFzdCwgaW4gY2FzZSBJRSBnZXRzIGEgbGl0dGxlIG92ZXJ6ZWFsb3VzICh0aWNrZXQgIzU0NDMpLlxuXHRcdGlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiICkge1xuXHRcdFx0ZG9jdW1lbnQuZGV0YWNoRXZlbnQoIFwib25yZWFkeXN0YXRlY2hhbmdlXCIsIERPTUNvbnRlbnRMb2FkZWQgKTtcblx0XHRcdGpRdWVyeS5yZWFkeSgpO1xuXHRcdH1cblx0fTtcbn1cblxuLy8gVGhlIERPTSByZWFkeSBjaGVjayBmb3IgSW50ZXJuZXQgRXhwbG9yZXJcbmZ1bmN0aW9uIGRvU2Nyb2xsQ2hlY2soKSB7XG5cdGlmICggalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dHJ5IHtcblx0XHQvLyBJZiBJRSBpcyB1c2VkLCB1c2UgdGhlIHRyaWNrIGJ5IERpZWdvIFBlcmluaVxuXHRcdC8vIGh0dHA6Ly9qYXZhc2NyaXB0Lm53Ym94LmNvbS9JRUNvbnRlbnRMb2FkZWQvXG5cdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsKFwibGVmdFwiKTtcblx0fSBjYXRjaChlKSB7XG5cdFx0c2V0VGltZW91dCggZG9TY3JvbGxDaGVjaywgMSApO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIGFuZCBleGVjdXRlIGFueSB3YWl0aW5nIGZ1bmN0aW9uc1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxucmV0dXJuIGpRdWVyeTtcblxufSkoKTtcblxuXG4vLyBTdHJpbmcgdG8gT2JqZWN0IGZsYWdzIGZvcm1hdCBjYWNoZVxudmFyIGZsYWdzQ2FjaGUgPSB7fTtcblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIGZsYWdzIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzIGFuZCBzdG9yZSBpbiBjYWNoZVxuZnVuY3Rpb24gY3JlYXRlRmxhZ3MoIGZsYWdzICkge1xuXHR2YXIgb2JqZWN0ID0gZmxhZ3NDYWNoZVsgZmxhZ3MgXSA9IHt9LFxuXHRcdGksIGxlbmd0aDtcblx0ZmxhZ3MgPSBmbGFncy5zcGxpdCggL1xccysvICk7XG5cdGZvciAoIGkgPSAwLCBsZW5ndGggPSBmbGFncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRvYmplY3RbIGZsYWdzW2ldIF0gPSB0cnVlO1xuXHR9XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0ZmxhZ3M6XHRhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBmbGFncyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzXG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBmbGFnczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBmbGFncyApIHtcblxuXHQvLyBDb252ZXJ0IGZsYWdzIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0ZmxhZ3MgPSBmbGFncyA/ICggZmxhZ3NDYWNoZVsgZmxhZ3MgXSB8fCBjcmVhdGVGbGFncyggZmxhZ3MgKSApIDoge307XG5cblx0dmFyIC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXHRcdC8vIFN0YWNrIG9mIGZpcmUgY2FsbHMgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRzdGFjayA9IFtdLFxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSAoZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0cylcblx0XHRtZW1vcnksXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXHRcdC8vIEZpcnN0IGNhbGxiYWNrIHRvIGZpcmUgKHVzZWQgaW50ZXJuYWxseSBieSBhZGQgYW5kIGZpcmVXaXRoKVxuXHRcdGZpcmluZ1N0YXJ0LFxuXHRcdC8vIEVuZCBvZiB0aGUgbG9vcCB3aGVuIGZpcmluZ1xuXHRcdGZpcmluZ0xlbmd0aCxcblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSByZW1vdmUgaWYgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4LFxuXHRcdC8vIEFkZCBvbmUgb3Igc2V2ZXJhbCBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRhZGQgPSBmdW5jdGlvbiggYXJncyApIHtcblx0XHRcdHZhciBpLFxuXHRcdFx0XHRsZW5ndGgsXG5cdFx0XHRcdGVsZW0sXG5cdFx0XHRcdHR5cGUsXG5cdFx0XHRcdGFjdHVhbDtcblx0XHRcdGZvciAoIGkgPSAwLCBsZW5ndGggPSBhcmdzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRlbGVtID0gYXJnc1sgaSBdO1xuXHRcdFx0XHR0eXBlID0galF1ZXJ5LnR5cGUoIGVsZW0gKTtcblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFycmF5XCIgKSB7XG5cdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdGFkZCggZWxlbSApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHRcdFx0Ly8gQWRkIGlmIG5vdCBpbiB1bmlxdWUgbW9kZSBhbmQgY2FsbGJhY2sgaXMgbm90IGluXG5cdFx0XHRcdFx0aWYgKCAhZmxhZ3MudW5pcXVlIHx8ICFzZWxmLmhhcyggZWxlbSApICkge1xuXHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0bWVtb3J5ID0gIWZsYWdzLm1lbW9yeSB8fCBbIGNvbnRleHQsIGFyZ3MgXTtcblx0XHRcdGZpcmVkID0gdHJ1ZTtcblx0XHRcdGZpcmluZyA9IHRydWU7XG5cdFx0XHRmaXJpbmdJbmRleCA9IGZpcmluZ1N0YXJ0IHx8IDA7XG5cdFx0XHRmaXJpbmdTdGFydCA9IDA7XG5cdFx0XHRmaXJpbmdMZW5ndGggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdGZvciAoIDsgbGlzdCAmJiBmaXJpbmdJbmRleCA8IGZpcmluZ0xlbmd0aDsgZmlyaW5nSW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBjb250ZXh0LCBhcmdzICkgPT09IGZhbHNlICYmIGZsYWdzLnN0b3BPbkZhbHNlICkge1xuXHRcdFx0XHRcdG1lbW9yeSA9IHRydWU7IC8vIE1hcmsgYXMgaGFsdGVkXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRpZiAoICFmbGFncy5vbmNlICkge1xuXHRcdFx0XHRcdGlmICggc3RhY2sgJiYgc3RhY2subGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gc3RhY2suc2hpZnQoKTtcblx0XHRcdFx0XHRcdHNlbGYuZmlyZVdpdGgoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICggbWVtb3J5ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdHNlbGYuZGlzYWJsZSgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRhZGQoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdC8vIERvIHdlIG5lZWQgdG8gYWRkIHRoZSBjYWxsYmFja3MgdG8gdGhlXG5cdFx0XHRcdFx0Ly8gY3VycmVudCBmaXJpbmcgYmF0Y2g/XG5cdFx0XHRcdFx0aWYgKCBmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdMZW5ndGggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHQvLyBXaXRoIG1lbW9yeSwgaWYgd2UncmUgbm90IGZpcmluZyB0aGVuXG5cdFx0XHRcdFx0Ly8gd2Ugc2hvdWxkIGNhbGwgcmlnaHQgYXdheSwgdW5sZXNzIHByZXZpb3VzXG5cdFx0XHRcdFx0Ly8gZmlyaW5nIHdhcyBoYWx0ZWQgKHN0b3BPbkZhbHNlKVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG1lbW9yeSAmJiBtZW1vcnkgIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdTdGFydCA9IGxlbmd0aDtcblx0XHRcdFx0XHRcdGZpcmUoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRhcmdJbmRleCA9IDAsXG5cdFx0XHRcdFx0XHRhcmdMZW5ndGggPSBhcmdzLmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKCA7IGFyZ0luZGV4IDwgYXJnTGVuZ3RoIDsgYXJnSW5kZXgrKyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggYXJnc1sgYXJnSW5kZXggXSA9PT0gbGlzdFsgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmdJbmRleCBhbmQgZmlyaW5nTGVuZ3RoXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGkgPD0gZmlyaW5nTGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaXJpbmdMZW5ndGgtLTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpIDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGktLSwgMSApO1xuXHRcdFx0XHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgc29tZSB1bmljaXR5IHByb3BlcnR5IHRoZW5cblx0XHRcdFx0XHRcdFx0XHQvLyB3ZSBvbmx5IG5lZWQgdG8gZG8gdGhpcyBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBmbGFncy51bmlxdWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gQ29udHJvbCBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0XG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0XHRcdGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aWYgKCBmbiA9PT0gbGlzdFsgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBIYXZlIHRoZSBsaXN0IGRvIG5vdGhpbmcgYW55bW9yZVxuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxpc3QgPSBzdGFjayA9IG1lbW9yeSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gSXMgaXQgZGlzYWJsZWQ/XG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cdFx0XHQvLyBMb2NrIHRoZSBsaXN0IGluIGl0cyBjdXJyZW50IHN0YXRlXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c3RhY2sgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdGlmICggIW1lbW9yeSB8fCBtZW1vcnkgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0c2VsZi5kaXNhYmxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gSXMgaXQgbG9ja2VkP1xuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFzdGFjaztcblx0XHRcdH0sXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggc3RhY2sgKSB7XG5cdFx0XHRcdFx0aWYgKCBmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFmbGFncy5vbmNlICkge1xuXHRcdFx0XHRcdFx0XHRzdGFjay5wdXNoKCBbIGNvbnRleHQsIGFyZ3MgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICEoIGZsYWdzLm9uY2UgJiYgbWVtb3J5ICkgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCBjb250ZXh0LCBhcmdzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5cblxudmFyIC8vIFN0YXRpYyByZWZlcmVuY2UgdG8gc2xpY2Vcblx0c2xpY2VEZWZlcnJlZCA9IFtdLnNsaWNlO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIGRvbmVMaXN0ID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRmYWlsTGlzdCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0cHJvZ3Jlc3NMaXN0ID0galF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdGxpc3RzID0ge1xuXHRcdFx0XHRyZXNvbHZlOiBkb25lTGlzdCxcblx0XHRcdFx0cmVqZWN0OiBmYWlsTGlzdCxcblx0XHRcdFx0bm90aWZ5OiBwcm9ncmVzc0xpc3Rcblx0XHRcdH0sXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRkb25lOiBkb25lTGlzdC5hZGQsXG5cdFx0XHRcdGZhaWw6IGZhaWxMaXN0LmFkZCxcblx0XHRcdFx0cHJvZ3Jlc3M6IHByb2dyZXNzTGlzdC5hZGQsXG5cblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBEZXByZWNhdGVkXG5cdFx0XHRcdGlzUmVzb2x2ZWQ6IGRvbmVMaXN0LmZpcmVkLFxuXHRcdFx0XHRpc1JlamVjdGVkOiBmYWlsTGlzdC5maXJlZCxcblxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggZG9uZUNhbGxiYWNrcywgZmFpbENhbGxiYWNrcywgcHJvZ3Jlc3NDYWxsYmFja3MgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggZG9uZUNhbGxiYWNrcyApLmZhaWwoIGZhaWxDYWxsYmFja3MgKS5wcm9ncmVzcyggcHJvZ3Jlc3NDYWxsYmFja3MgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lLmFwcGx5KCBkZWZlcnJlZCwgYXJndW1lbnRzICkuZmFpbC5hcHBseSggZGVmZXJyZWQsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZChmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCgge1xuXHRcdFx0XHRcdFx0XHRkb25lOiBbIGZuRG9uZSwgXCJyZXNvbHZlXCIgXSxcblx0XHRcdFx0XHRcdFx0ZmFpbDogWyBmbkZhaWwsIFwicmVqZWN0XCIgXSxcblx0XHRcdFx0XHRcdFx0cHJvZ3Jlc3M6IFsgZm5Qcm9ncmVzcywgXCJub3RpZnlcIiBdXG5cdFx0XHRcdFx0XHR9LCBmdW5jdGlvbiggaGFuZGxlciwgZGF0YSApIHtcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0gZGF0YVsgMCBdLFxuXHRcdFx0XHRcdFx0XHRcdGFjdGlvbiA9IGRhdGFbIDEgXSxcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZDtcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgaGFuZGxlciBdKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKS50aGVuKCBuZXdEZWZlci5yZXNvbHZlLCBuZXdEZWZlci5yZWplY3QsIG5ld0RlZmVyLm5vdGlmeSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIGFjdGlvbiArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gbmV3RGVmZXIgOiB0aGlzLCBbIHJldHVybmVkIF0gKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgaGFuZGxlciBdKCBuZXdEZWZlclsgYWN0aW9uIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0b2JqID0gcHJvbWlzZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGtleSBpbiBwcm9taXNlICkge1xuXHRcdFx0XHRcdFx0XHRvYmpbIGtleSBdID0gcHJvbWlzZVsga2V5IF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHByb21pc2UucHJvbWlzZSh7fSksXG5cdFx0XHRrZXk7XG5cblx0XHRmb3IgKCBrZXkgaW4gbGlzdHMgKSB7XG5cdFx0XHRkZWZlcnJlZFsga2V5IF0gPSBsaXN0c1sga2V5IF0uZmlyZTtcblx0XHRcdGRlZmVycmVkWyBrZXkgKyBcIldpdGhcIiBdID0gbGlzdHNbIGtleSBdLmZpcmVXaXRoO1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdGRlZmVycmVkLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3RhdGUgPSBcInJlc29sdmVkXCI7XG5cdFx0fSwgZmFpbExpc3QuZGlzYWJsZSwgcHJvZ3Jlc3NMaXN0LmxvY2sgKS5mYWlsKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0YXRlID0gXCJyZWplY3RlZFwiO1xuXHRcdH0sIGRvbmVMaXN0LmRpc2FibGUsIHByb2dyZXNzTGlzdC5sb2NrICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBmaXJzdFBhcmFtICkge1xuXHRcdHZhciBhcmdzID0gc2xpY2VEZWZlcnJlZC5jYWxsKCBhcmd1bWVudHMsIDAgKSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gYXJncy5sZW5ndGgsXG5cdFx0XHRwVmFsdWVzID0gbmV3IEFycmF5KCBsZW5ndGggKSxcblx0XHRcdGNvdW50ID0gbGVuZ3RoLFxuXHRcdFx0cENvdW50ID0gbGVuZ3RoLFxuXHRcdFx0ZGVmZXJyZWQgPSBsZW5ndGggPD0gMSAmJiBmaXJzdFBhcmFtICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBmaXJzdFBhcmFtLnByb21pc2UgKSA/XG5cdFx0XHRcdGZpcnN0UGFyYW0gOlxuXHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdHByb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlKCk7XG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZUZ1bmMoIGkgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlRGVmZXJyZWQuY2FsbCggYXJndW1lbnRzLCAwICkgOiB2YWx1ZTtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGRlZmVycmVkLCBhcmdzICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHByb2dyZXNzRnVuYyggaSApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHBWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2VEZWZlcnJlZC5jYWxsKCBhcmd1bWVudHMsIDAgKSA6IHZhbHVlO1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBwcm9taXNlLCBwVmFsdWVzICk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRpZiAoIGxlbmd0aCA+IDEgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBhcmdzWyBpIF0gJiYgYXJnc1sgaSBdLnByb21pc2UgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIGFyZ3NbIGkgXS5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0YXJnc1sgaSBdLnByb21pc2UoKS50aGVuKCByZXNvbHZlRnVuYyhpKSwgZGVmZXJyZWQucmVqZWN0LCBwcm9ncmVzc0Z1bmMoaSkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQtLWNvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFjb3VudCApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGRlZmVycmVkLCBhcmdzICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICggZGVmZXJyZWQgIT09IGZpcnN0UGFyYW0gKSB7XG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZGVmZXJyZWQsIGxlbmd0aCA/IFsgZmlyc3RQYXJhbSBdIDogW10gKTtcblx0XHR9XG5cdFx0cmV0dXJuIHByb21pc2U7XG5cdH1cbn0pO1xuXG5cblxuXG5qUXVlcnkuc3VwcG9ydCA9IChmdW5jdGlvbigpIHtcblxuXHR2YXIgc3VwcG9ydCxcblx0XHRhbGwsXG5cdFx0YSxcblx0XHRzZWxlY3QsXG5cdFx0b3B0LFxuXHRcdGlucHV0LFxuXHRcdGZyYWdtZW50LFxuXHRcdHRkcyxcblx0XHRldmVudHMsXG5cdFx0ZXZlbnROYW1lLFxuXHRcdGksXG5cdFx0aXNTdXBwb3J0ZWQsXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXHQvLyBQcmVsaW1pbmFyeSB0ZXN0c1xuXHRkaXYuc2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIsIFwidFwiKTtcblx0ZGl2LmlubmVySFRNTCA9IFwiICAgPGxpbmsvPjx0YWJsZT48L3RhYmxlPjxhIGhyZWY9Jy9hJyBzdHlsZT0ndG9wOjFweDtmbG9hdDpsZWZ0O29wYWNpdHk6LjU1Oyc+YTwvYT48aW5wdXQgdHlwZT0nY2hlY2tib3gnLz5cIjtcblxuXHRhbGwgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiKlwiICk7XG5cdGEgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiYVwiIClbIDAgXTtcblxuXHQvLyBDYW4ndCBnZXQgYmFzaWMgdGVzdCBzdXBwb3J0XG5cdGlmICggIWFsbCB8fCAhYWxsLmxlbmd0aCB8fCAhYSApIHtcblx0XHRyZXR1cm4ge307XG5cdH1cblxuXHQvLyBGaXJzdCBiYXRjaCBvZiBzdXBwb3J0cyB0ZXN0c1xuXHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICk7XG5cdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSApO1xuXHRpbnB1dCA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJpbnB1dFwiIClbIDAgXTtcblxuXHRzdXBwb3J0ID0ge1xuXHRcdC8vIElFIHN0cmlwcyBsZWFkaW5nIHdoaXRlc3BhY2Ugd2hlbiAuaW5uZXJIVE1MIGlzIHVzZWRcblx0XHRsZWFkaW5nV2hpdGVzcGFjZTogKCBkaXYuZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gMyApLFxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGJvZHkgZWxlbWVudHMgYXJlbid0IGF1dG9tYXRpY2FsbHkgaW5zZXJ0ZWRcblx0XHQvLyBJRSB3aWxsIGluc2VydCB0aGVtIGludG8gZW1wdHkgdGFibGVzXG5cdFx0dGJvZHk6ICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0Ym9keVwiKS5sZW5ndGgsXG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBsaW5rIGVsZW1lbnRzIGdldCBzZXJpYWxpemVkIGNvcnJlY3RseSBieSBpbm5lckhUTUxcblx0XHQvLyBUaGlzIHJlcXVpcmVzIGEgd3JhcHBlciBlbGVtZW50IGluIElFXG5cdFx0aHRtbFNlcmlhbGl6ZTogISFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsaW5rXCIpLmxlbmd0aCxcblxuXHRcdC8vIEdldCB0aGUgc3R5bGUgaW5mb3JtYXRpb24gZnJvbSBnZXRBdHRyaWJ1dGVcblx0XHQvLyAoSUUgdXNlcyAuY3NzVGV4dCBpbnN0ZWFkKVxuXHRcdHN0eWxlOiAvdG9wLy50ZXN0KCBhLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpICksXG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBVUkxzIGFyZW4ndCBtYW5pcHVsYXRlZFxuXHRcdC8vIChJRSBub3JtYWxpemVzIGl0IGJ5IGRlZmF1bHQpXG5cdFx0aHJlZk5vcm1hbGl6ZWQ6ICggYS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIi9hXCIgKSxcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IGVsZW1lbnQgb3BhY2l0eSBleGlzdHNcblx0XHQvLyAoSUUgdXNlcyBmaWx0ZXIgaW5zdGVhZClcblx0XHQvLyBVc2UgYSByZWdleCB0byB3b3JrIGFyb3VuZCBhIFdlYktpdCBpc3N1ZS4gU2VlICM1MTQ1XG5cdFx0b3BhY2l0eTogL14wLjU1Ly50ZXN0KCBhLnN0eWxlLm9wYWNpdHkgKSxcblxuXHRcdC8vIFZlcmlmeSBzdHlsZSBmbG9hdCBleGlzdGVuY2Vcblx0XHQvLyAoSUUgdXNlcyBzdHlsZUZsb2F0IGluc3RlYWQgb2YgY3NzRmxvYXQpXG5cdFx0Y3NzRmxvYXQ6ICEhYS5zdHlsZS5jc3NGbG9hdCxcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IGlmIG5vIHZhbHVlIGlzIHNwZWNpZmllZCBmb3IgYSBjaGVja2JveFxuXHRcdC8vIHRoYXQgaXQgZGVmYXVsdHMgdG8gXCJvblwiLlxuXHRcdC8vIChXZWJLaXQgZGVmYXVsdHMgdG8gXCJcIiBpbnN0ZWFkKVxuXHRcdGNoZWNrT246ICggaW5wdXQudmFsdWUgPT09IFwib25cIiApLFxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgYSBzZWxlY3RlZC1ieS1kZWZhdWx0IG9wdGlvbiBoYXMgYSB3b3JraW5nIHNlbGVjdGVkIHByb3BlcnR5LlxuXHRcdC8vIChXZWJLaXQgZGVmYXVsdHMgdG8gZmFsc2UgaW5zdGVhZCBvZiB0cnVlLCBJRSB0b28sIGlmIGl0J3MgaW4gYW4gb3B0Z3JvdXApXG5cdFx0b3B0U2VsZWN0ZWQ6IG9wdC5zZWxlY3RlZCxcblxuXHRcdC8vIFRlc3Qgc2V0QXR0cmlidXRlIG9uIGNhbWVsQ2FzZSBjbGFzcy4gSWYgaXQgd29ya3MsIHdlIG5lZWQgYXR0ckZpeGVzIHdoZW4gZG9pbmcgZ2V0L3NldEF0dHJpYnV0ZSAoaWU2LzcpXG5cdFx0Z2V0U2V0QXR0cmlidXRlOiBkaXYuY2xhc3NOYW1lICE9PSBcInRcIixcblxuXHRcdC8vIFRlc3RzIGZvciBlbmN0eXBlIHN1cHBvcnQgb24gYSBmb3JtKCM2NzQzKVxuXHRcdGVuY3R5cGU6ICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIikuZW5jdHlwZSxcblxuXHRcdC8vIE1ha2VzIHN1cmUgY2xvbmluZyBhbiBodG1sNSBlbGVtZW50IGRvZXMgbm90IGNhdXNlIHByb2JsZW1zXG5cdFx0Ly8gV2hlcmUgb3V0ZXJIVE1MIGlzIHVuZGVmaW5lZCwgdGhpcyBzdGlsbCB3b3Jrc1xuXHRcdGh0bWw1Q2xvbmU6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJuYXZcIikuY2xvbmVOb2RlKCB0cnVlICkub3V0ZXJIVE1MICE9PSBcIjw6bmF2PjwvOm5hdj5cIixcblxuXHRcdC8vIFdpbGwgYmUgZGVmaW5lZCBsYXRlclxuXHRcdHN1Ym1pdEJ1YmJsZXM6IHRydWUsXG5cdFx0Y2hhbmdlQnViYmxlczogdHJ1ZSxcblx0XHRmb2N1c2luQnViYmxlczogZmFsc2UsXG5cdFx0ZGVsZXRlRXhwYW5kbzogdHJ1ZSxcblx0XHRub0Nsb25lRXZlbnQ6IHRydWUsXG5cdFx0aW5saW5lQmxvY2tOZWVkc0xheW91dDogZmFsc2UsXG5cdFx0c2hyaW5rV3JhcEJsb2NrczogZmFsc2UsXG5cdFx0cmVsaWFibGVNYXJnaW5SaWdodDogdHJ1ZSxcblx0XHRwaXhlbE1hcmdpbjogdHJ1ZVxuXHR9O1xuXG5cdC8vIGpRdWVyeS5ib3hNb2RlbCBERVBSRUNBVEVEIGluIDEuMywgdXNlIGpRdWVyeS5zdXBwb3J0LmJveE1vZGVsIGluc3RlYWRcblx0alF1ZXJ5LmJveE1vZGVsID0gc3VwcG9ydC5ib3hNb2RlbCA9IChkb2N1bWVudC5jb21wYXRNb2RlID09PSBcIkNTUzFDb21wYXRcIik7XG5cblx0Ly8gTWFrZSBzdXJlIGNoZWNrZWQgc3RhdHVzIGlzIHByb3Blcmx5IGNsb25lZFxuXHRpbnB1dC5jaGVja2VkID0gdHJ1ZTtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9IGlucHV0LmNsb25lTm9kZSggdHJ1ZSApLmNoZWNrZWQ7XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIG9wdGlvbnMgaW5zaWRlIGRpc2FibGVkIHNlbGVjdHMgYXJlbid0IG1hcmtlZCBhcyBkaXNhYmxlZFxuXHQvLyAoV2ViS2l0IG1hcmtzIHRoZW0gYXMgZGlzYWJsZWQpXG5cdHNlbGVjdC5kaXNhYmxlZCA9IHRydWU7XG5cdHN1cHBvcnQub3B0RGlzYWJsZWQgPSAhb3B0LmRpc2FibGVkO1xuXG5cdC8vIFRlc3QgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZGVsZXRlIGFuIGV4cGFuZG8gZnJvbSBhbiBlbGVtZW50XG5cdC8vIEZhaWxzIGluIEludGVybmV0IEV4cGxvcmVyXG5cdHRyeSB7XG5cdFx0ZGVsZXRlIGRpdi50ZXN0O1xuXHR9IGNhdGNoKCBlICkge1xuXHRcdHN1cHBvcnQuZGVsZXRlRXhwYW5kbyA9IGZhbHNlO1xuXHR9XG5cblx0aWYgKCAhZGl2LmFkZEV2ZW50TGlzdGVuZXIgJiYgZGl2LmF0dGFjaEV2ZW50ICYmIGRpdi5maXJlRXZlbnQgKSB7XG5cdFx0ZGl2LmF0dGFjaEV2ZW50KCBcIm9uY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBDbG9uaW5nIGEgbm9kZSBzaG91bGRuJ3QgY29weSBvdmVyIGFueVxuXHRcdFx0Ly8gYm91bmQgZXZlbnQgaGFuZGxlcnMgKElFIGRvZXMgdGhpcylcblx0XHRcdHN1cHBvcnQubm9DbG9uZUV2ZW50ID0gZmFsc2U7XG5cdFx0fSk7XG5cdFx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLmZpcmVFdmVudCggXCJvbmNsaWNrXCIgKTtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGEgcmFkaW8gbWFpbnRhaW5zIGl0cyB2YWx1ZVxuXHQvLyBhZnRlciBiZWluZyBhcHBlbmRlZCB0byB0aGUgRE9NXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwicmFkaW9cIik7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcblxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiKTtcblxuXHQvLyAjMTEyMTcgLSBXZWJLaXQgbG9zZXMgY2hlY2sgd2hlbiB0aGUgbmFtZSBpcyBhZnRlciB0aGUgY2hlY2tlZCBhdHRyaWJ1dGVcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cdGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRmcmFnbWVudC5hcHBlbmRDaGlsZCggZGl2Lmxhc3RDaGlsZCApO1xuXG5cdC8vIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBmcmFnbWVudC5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBDaGVjayBpZiBhIGRpc2Nvbm5lY3RlZCBjaGVja2JveCB3aWxsIHJldGFpbiBpdHMgY2hlY2tlZFxuXHQvLyB2YWx1ZSBvZiB0cnVlIGFmdGVyIGFwcGVuZGVkIHRvIHRoZSBET00gKElFNi83KVxuXHRzdXBwb3J0LmFwcGVuZENoZWNrZWQgPSBpbnB1dC5jaGVja2VkO1xuXG5cdGZyYWdtZW50LnJlbW92ZUNoaWxkKCBpbnB1dCApO1xuXHRmcmFnbWVudC5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0Ly8gVGVjaG5pcXVlIGZyb20gSnVyaXkgWmF5dHNldlxuXHQvLyBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS9kZXRlY3RpbmctZXZlbnQtc3VwcG9ydC13aXRob3V0LWJyb3dzZXItc25pZmZpbmcvXG5cdC8vIFdlIG9ubHkgY2FyZSBhYm91dCB0aGUgY2FzZSB3aGVyZSBub24tc3RhbmRhcmQgZXZlbnQgc3lzdGVtc1xuXHQvLyBhcmUgdXNlZCwgbmFtZWx5IGluIElFLiBTaG9ydC1jaXJjdWl0aW5nIGhlcmUgaGVscHMgdXMgdG9cblx0Ly8gYXZvaWQgYW4gZXZhbCBjYWxsIChpbiBzZXRBdHRyaWJ1dGUpIHdoaWNoIGNhbiBjYXVzZSBDU1Bcblx0Ly8gdG8gZ28gaGF5d2lyZS4gU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9TZWN1cml0eS9DU1Bcblx0aWYgKCBkaXYuYXR0YWNoRXZlbnQgKSB7XG5cdFx0Zm9yICggaSBpbiB7XG5cdFx0XHRzdWJtaXQ6IDEsXG5cdFx0XHRjaGFuZ2U6IDEsXG5cdFx0XHRmb2N1c2luOiAxXG5cdFx0fSkge1xuXHRcdFx0ZXZlbnROYW1lID0gXCJvblwiICsgaTtcblx0XHRcdGlzU3VwcG9ydGVkID0gKCBldmVudE5hbWUgaW4gZGl2ICk7XG5cdFx0XHRpZiAoICFpc1N1cHBvcnRlZCApIHtcblx0XHRcdFx0ZGl2LnNldEF0dHJpYnV0ZSggZXZlbnROYW1lLCBcInJldHVybjtcIiApO1xuXHRcdFx0XHRpc1N1cHBvcnRlZCA9ICggdHlwZW9mIGRpdlsgZXZlbnROYW1lIF0gPT09IFwiZnVuY3Rpb25cIiApO1xuXHRcdFx0fVxuXHRcdFx0c3VwcG9ydFsgaSArIFwiQnViYmxlc1wiIF0gPSBpc1N1cHBvcnRlZDtcblx0XHR9XG5cdH1cblxuXHRmcmFnbWVudC5yZW1vdmVDaGlsZCggZGl2ICk7XG5cblx0Ly8gTnVsbCBlbGVtZW50cyB0byBhdm9pZCBsZWFrcyBpbiBJRVxuXHRmcmFnbWVudCA9IHNlbGVjdCA9IG9wdCA9IGRpdiA9IGlucHV0ID0gbnVsbDtcblxuXHQvLyBSdW4gdGVzdHMgdGhhdCBuZWVkIGEgYm9keSBhdCBkb2MgcmVhZHlcblx0alF1ZXJ5KGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb250YWluZXIsIG91dGVyLCBpbm5lciwgdGFibGUsIHRkLCBvZmZzZXRTdXBwb3J0LFxuXHRcdFx0bWFyZ2luRGl2LCBjb25NYXJnaW5Ub3AsIHN0eWxlLCBodG1sLCBwb3NpdGlvblRvcExlZnRXaWR0aEhlaWdodCxcblx0XHRcdHBhZGRpbmdNYXJnaW5Cb3JkZXJWaXNpYmlsaXR5LCBwYWRkaW5nTWFyZ2luQm9yZGVyLFxuXHRcdFx0Ym9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXTtcblxuXHRcdGlmICggIWJvZHkgKSB7XG5cdFx0XHQvLyBSZXR1cm4gZm9yIGZyYW1lc2V0IGRvY3MgdGhhdCBkb24ndCBoYXZlIGEgYm9keVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbk1hcmdpblRvcCA9IDE7XG5cdFx0cGFkZGluZ01hcmdpbkJvcmRlciA9IFwicGFkZGluZzowO21hcmdpbjowO2JvcmRlcjpcIjtcblx0XHRwb3NpdGlvblRvcExlZnRXaWR0aEhlaWdodCA9IFwicG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3dpZHRoOjFweDtoZWlnaHQ6MXB4O1wiO1xuXHRcdHBhZGRpbmdNYXJnaW5Cb3JkZXJWaXNpYmlsaXR5ID0gcGFkZGluZ01hcmdpbkJvcmRlciArIFwiMDt2aXNpYmlsaXR5OmhpZGRlbjtcIjtcblx0XHRzdHlsZSA9IFwic3R5bGU9J1wiICsgcG9zaXRpb25Ub3BMZWZ0V2lkdGhIZWlnaHQgKyBwYWRkaW5nTWFyZ2luQm9yZGVyICsgXCI1cHggc29saWQgIzAwMDtcIjtcblx0XHRodG1sID0gXCI8ZGl2IFwiICsgc3R5bGUgKyBcImRpc3BsYXk6YmxvY2s7Jz48ZGl2IHN0eWxlPSdcIiArIHBhZGRpbmdNYXJnaW5Cb3JkZXIgKyBcIjA7ZGlzcGxheTpibG9jaztvdmVyZmxvdzpoaWRkZW47Jz48L2Rpdj48L2Rpdj5cIiArXG5cdFx0XHRcIjx0YWJsZSBcIiArIHN0eWxlICsgXCInIGNlbGxwYWRkaW5nPScwJyBjZWxsc3BhY2luZz0nMCc+XCIgK1xuXHRcdFx0XCI8dHI+PHRkPjwvdGQ+PC90cj48L3RhYmxlPlwiO1xuXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IHBhZGRpbmdNYXJnaW5Cb3JkZXJWaXNpYmlsaXR5ICsgXCJ3aWR0aDowO2hlaWdodDowO3Bvc2l0aW9uOnN0YXRpYzt0b3A6MDttYXJnaW4tdG9wOlwiICsgY29uTWFyZ2luVG9wICsgXCJweFwiO1xuXHRcdGJvZHkuaW5zZXJ0QmVmb3JlKCBjb250YWluZXIsIGJvZHkuZmlyc3RDaGlsZCApO1xuXG5cdFx0Ly8gQ29uc3RydWN0IHRoZSB0ZXN0IGVsZW1lbnRcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0XHQvLyBDaGVjayBpZiB0YWJsZSBjZWxscyBzdGlsbCBoYXZlIG9mZnNldFdpZHRoL0hlaWdodCB3aGVuIHRoZXkgYXJlIHNldFxuXHRcdC8vIHRvIGRpc3BsYXk6bm9uZSBhbmQgdGhlcmUgYXJlIHN0aWxsIG90aGVyIHZpc2libGUgdGFibGUgY2VsbHMgaW4gYVxuXHRcdC8vIHRhYmxlIHJvdzsgaWYgc28sIG9mZnNldFdpZHRoL0hlaWdodCBhcmUgbm90IHJlbGlhYmxlIGZvciB1c2Ugd2hlblxuXHRcdC8vIGRldGVybWluaW5nIGlmIGFuIGVsZW1lbnQgaGFzIGJlZW4gaGlkZGVuIGRpcmVjdGx5IHVzaW5nXG5cdFx0Ly8gZGlzcGxheTpub25lIChpdCBpcyBzdGlsbCBzYWZlIHRvIHVzZSBvZmZzZXRzIGlmIGEgcGFyZW50IGVsZW1lbnQgaXNcblx0XHQvLyBoaWRkZW47IGRvbiBzYWZldHkgZ29nZ2xlcyBhbmQgc2VlIGJ1ZyAjNDUxMiBmb3IgbW9yZSBpbmZvcm1hdGlvbikuXG5cdFx0Ly8gKG9ubHkgSUUgOCBmYWlscyB0aGlzIHRlc3QpXG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiPHRhYmxlPjx0cj48dGQgc3R5bGU9J1wiICsgcGFkZGluZ01hcmdpbkJvcmRlciArIFwiMDtkaXNwbGF5Om5vbmUnPjwvdGQ+PHRkPnQ8L3RkPjwvdHI+PC90YWJsZT5cIjtcblx0XHR0ZHMgPSBkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwidGRcIiApO1xuXHRcdGlzU3VwcG9ydGVkID0gKCB0ZHNbIDAgXS5vZmZzZXRIZWlnaHQgPT09IDAgKTtcblxuXHRcdHRkc1sgMCBdLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdHRkc1sgMSBdLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuXHRcdC8vIENoZWNrIGlmIGVtcHR5IHRhYmxlIGNlbGxzIHN0aWxsIGhhdmUgb2Zmc2V0V2lkdGgvSGVpZ2h0XG5cdFx0Ly8gKElFIDw9IDggZmFpbCB0aGlzIHRlc3QpXG5cdFx0c3VwcG9ydC5yZWxpYWJsZUhpZGRlbk9mZnNldHMgPSBpc1N1cHBvcnRlZCAmJiAoIHRkc1sgMCBdLm9mZnNldEhlaWdodCA9PT0gMCApO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgZGl2IHdpdGggZXhwbGljaXQgd2lkdGggYW5kIG5vIG1hcmdpbi1yaWdodCBpbmNvcnJlY3RseVxuXHRcdC8vIGdldHMgY29tcHV0ZWQgbWFyZ2luLXJpZ2h0IGJhc2VkIG9uIHdpZHRoIG9mIGNvbnRhaW5lci4gRm9yIG1vcmVcblx0XHQvLyBpbmZvIHNlZSBidWcgIzMzMzNcblx0XHQvLyBGYWlscyBpbiBXZWJLaXQgYmVmb3JlIEZlYiAyMDExIG5pZ2h0bGllc1xuXHRcdC8vIFdlYktpdCBCdWcgMTMzNDMgLSBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgd3JvbmcgdmFsdWUgZm9yIG1hcmdpbi1yaWdodFxuXHRcdGlmICggd2luZG93LmdldENvbXB1dGVkU3R5bGUgKSB7XG5cdFx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRcdG1hcmdpbkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblx0XHRcdG1hcmdpbkRpdi5zdHlsZS53aWR0aCA9IFwiMFwiO1xuXHRcdFx0bWFyZ2luRGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCIwXCI7XG5cdFx0XHRkaXYuc3R5bGUud2lkdGggPSBcIjJweFwiO1xuXHRcdFx0ZGl2LmFwcGVuZENoaWxkKCBtYXJnaW5EaXYgKTtcblx0XHRcdHN1cHBvcnQucmVsaWFibGVNYXJnaW5SaWdodCA9XG5cdFx0XHRcdCggcGFyc2VJbnQoICggd2luZG93LmdldENvbXB1dGVkU3R5bGUoIG1hcmdpbkRpdiwgbnVsbCApIHx8IHsgbWFyZ2luUmlnaHQ6IDAgfSApLm1hcmdpblJpZ2h0LCAxMCApIHx8IDAgKSA9PT0gMDtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiBkaXYuc3R5bGUuem9vbSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdC8vIENoZWNrIGlmIG5hdGl2ZWx5IGJsb2NrLWxldmVsIGVsZW1lbnRzIGFjdCBsaWtlIGlubGluZS1ibG9ja1xuXHRcdFx0Ly8gZWxlbWVudHMgd2hlbiBzZXR0aW5nIHRoZWlyIGRpc3BsYXkgdG8gJ2lubGluZScgYW5kIGdpdmluZ1xuXHRcdFx0Ly8gdGhlbSBsYXlvdXRcblx0XHRcdC8vIChJRSA8IDggZG9lcyB0aGlzKVxuXHRcdFx0ZGl2LmlubmVySFRNTCA9IFwiXCI7XG5cdFx0XHRkaXYuc3R5bGUud2lkdGggPSBkaXYuc3R5bGUucGFkZGluZyA9IFwiMXB4XCI7XG5cdFx0XHRkaXYuc3R5bGUuYm9yZGVyID0gMDtcblx0XHRcdGRpdi5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0XHRkaXYuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lXCI7XG5cdFx0XHRkaXYuc3R5bGUuem9vbSA9IDE7XG5cdFx0XHRzdXBwb3J0LmlubGluZUJsb2NrTmVlZHNMYXlvdXQgPSAoIGRpdi5vZmZzZXRXaWR0aCA9PT0gMyApO1xuXG5cdFx0XHQvLyBDaGVjayBpZiBlbGVtZW50cyB3aXRoIGxheW91dCBzaHJpbmstd3JhcCB0aGVpciBjaGlsZHJlblxuXHRcdFx0Ly8gKElFIDYgZG9lcyB0aGlzKVxuXHRcdFx0ZGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdFx0XHRkaXYuc3R5bGUub3ZlcmZsb3cgPSBcInZpc2libGVcIjtcblx0XHRcdGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgc3R5bGU9J3dpZHRoOjVweDsnPjwvZGl2PlwiO1xuXHRcdFx0c3VwcG9ydC5zaHJpbmtXcmFwQmxvY2tzID0gKCBkaXYub2Zmc2V0V2lkdGggIT09IDMgKTtcblx0XHR9XG5cblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9IHBvc2l0aW9uVG9wTGVmdFdpZHRoSGVpZ2h0ICsgcGFkZGluZ01hcmdpbkJvcmRlclZpc2liaWxpdHk7XG5cdFx0ZGl2LmlubmVySFRNTCA9IGh0bWw7XG5cblx0XHRvdXRlciA9IGRpdi5maXJzdENoaWxkO1xuXHRcdGlubmVyID0gb3V0ZXIuZmlyc3RDaGlsZDtcblx0XHR0ZCA9IG91dGVyLm5leHRTaWJsaW5nLmZpcnN0Q2hpbGQuZmlyc3RDaGlsZDtcblxuXHRcdG9mZnNldFN1cHBvcnQgPSB7XG5cdFx0XHRkb2VzTm90QWRkQm9yZGVyOiAoIGlubmVyLm9mZnNldFRvcCAhPT0gNSApLFxuXHRcdFx0ZG9lc0FkZEJvcmRlckZvclRhYmxlQW5kQ2VsbHM6ICggdGQub2Zmc2V0VG9wID09PSA1IClcblx0XHR9O1xuXG5cdFx0aW5uZXIuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG5cdFx0aW5uZXIuc3R5bGUudG9wID0gXCIyMHB4XCI7XG5cblx0XHQvLyBzYWZhcmkgc3VidHJhY3RzIHBhcmVudCBib3JkZXIgd2lkdGggaGVyZSB3aGljaCBpcyA1cHhcblx0XHRvZmZzZXRTdXBwb3J0LmZpeGVkUG9zaXRpb24gPSAoIGlubmVyLm9mZnNldFRvcCA9PT0gMjAgfHwgaW5uZXIub2Zmc2V0VG9wID09PSAxNSApO1xuXHRcdGlubmVyLnN0eWxlLnBvc2l0aW9uID0gaW5uZXIuc3R5bGUudG9wID0gXCJcIjtcblxuXHRcdG91dGVyLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRvdXRlci5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblxuXHRcdG9mZnNldFN1cHBvcnQuc3VidHJhY3RzQm9yZGVyRm9yT3ZlcmZsb3dOb3RWaXNpYmxlID0gKCBpbm5lci5vZmZzZXRUb3AgPT09IC01ICk7XG5cdFx0b2Zmc2V0U3VwcG9ydC5kb2VzTm90SW5jbHVkZU1hcmdpbkluQm9keU9mZnNldCA9ICggYm9keS5vZmZzZXRUb3AgIT09IGNvbk1hcmdpblRvcCApO1xuXG5cdFx0aWYgKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSApIHtcblx0XHRcdGRpdi5zdHlsZS5tYXJnaW5Ub3AgPSBcIjElXCI7XG5cdFx0XHRzdXBwb3J0LnBpeGVsTWFyZ2luID0gKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2LCBudWxsICkgfHwgeyBtYXJnaW5Ub3A6IDAgfSApLm1hcmdpblRvcCAhPT0gXCIxJVwiO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIGNvbnRhaW5lci5zdHlsZS56b29tICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0Y29udGFpbmVyLnN0eWxlLnpvb20gPSAxO1xuXHRcdH1cblxuXHRcdGJvZHkucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXHRcdG1hcmdpbkRpdiA9IGRpdiA9IGNvbnRhaW5lciA9IG51bGw7XG5cblx0XHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCBvZmZzZXRTdXBwb3J0ICk7XG5cdH0pO1xuXG5cdHJldHVybiBzdXBwb3J0O1xufSkoKTtcblxuXG5cblxudmFyIHJicmFjZSA9IC9eKD86XFx7LipcXH18XFxbLipcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvKFtBLVpdKS9nO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Y2FjaGU6IHt9LFxuXG5cdC8vIFBsZWFzZSB1c2Ugd2l0aCBjYXV0aW9uXG5cdHV1aWQ6IDAsXG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdC8vIE5vbi1kaWdpdHMgcmVtb3ZlZCB0byBtYXRjaCByaW5saW5lalF1ZXJ5XG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIGpRdWVyeS5mbi5qcXVlcnkgKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gVGhlIGZvbGxvd2luZyBlbGVtZW50cyB0aHJvdyB1bmNhdGNoYWJsZSBleGNlcHRpb25zIGlmIHlvdVxuXHQvLyBhdHRlbXB0IHRvIGFkZCBleHBhbmRvIHByb3BlcnRpZXMgdG8gdGhlbS5cblx0bm9EYXRhOiB7XG5cdFx0XCJlbWJlZFwiOiB0cnVlLFxuXHRcdC8vIEJhbiBhbGwgb2JqZWN0cyBleGNlcHQgZm9yIEZsYXNoICh3aGljaCBoYW5kbGUgZXhwYW5kb3MpXG5cdFx0XCJvYmplY3RcIjogXCJjbHNpZDpEMjdDREI2RS1BRTZELTExY2YtOTZCOC00NDQ1NTM1NDAwMDBcIixcblx0XHRcImFwcGxldFwiOiB0cnVlXG5cdH0sXG5cblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0ZWxlbSA9IGVsZW0ubm9kZVR5cGUgPyBqUXVlcnkuY2FjaGVbIGVsZW1balF1ZXJ5LmV4cGFuZG9dIF0gOiBlbGVtWyBqUXVlcnkuZXhwYW5kbyBdO1xuXHRcdHJldHVybiAhIWVsZW0gJiYgIWlzRW1wdHlEYXRhT2JqZWN0KCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEsIHB2dCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0XHRpZiAoICFqUXVlcnkuYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBwcml2YXRlQ2FjaGUsIHRoaXNDYWNoZSwgcmV0LFxuXHRcdFx0aW50ZXJuYWxLZXkgPSBqUXVlcnkuZXhwYW5kbyxcblx0XHRcdGdldEJ5TmFtZSA9IHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiLFxuXG5cdFx0XHQvLyBXZSBoYXZlIHRvIGhhbmRsZSBET00gbm9kZXMgYW5kIEpTIG9iamVjdHMgZGlmZmVyZW50bHkgYmVjYXVzZSBJRTYtN1xuXHRcdFx0Ly8gY2FuJ3QgR0Mgb2JqZWN0IHJlZmVyZW5jZXMgcHJvcGVybHkgYWNyb3NzIHRoZSBET00tSlMgYm91bmRhcnlcblx0XHRcdGlzTm9kZSA9IGVsZW0ubm9kZVR5cGUsXG5cblx0XHRcdC8vIE9ubHkgRE9NIG5vZGVzIG5lZWQgdGhlIGdsb2JhbCBqUXVlcnkgY2FjaGU7IEpTIG9iamVjdCBkYXRhIGlzXG5cdFx0XHQvLyBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgb2JqZWN0IHNvIEdDIGNhbiBvY2N1ciBhdXRvbWF0aWNhbGx5XG5cdFx0XHRjYWNoZSA9IGlzTm9kZSA/IGpRdWVyeS5jYWNoZSA6IGVsZW0sXG5cblx0XHRcdC8vIE9ubHkgZGVmaW5pbmcgYW4gSUQgZm9yIEpTIG9iamVjdHMgaWYgaXRzIGNhY2hlIGFscmVhZHkgZXhpc3RzIGFsbG93c1xuXHRcdFx0Ly8gdGhlIGNvZGUgdG8gc2hvcnRjdXQgb24gdGhlIHNhbWUgcGF0aCBhcyBhIERPTSBub2RlIHdpdGggbm8gY2FjaGVcblx0XHRcdGlkID0gaXNOb2RlID8gZWxlbVsgaW50ZXJuYWxLZXkgXSA6IGVsZW1bIGludGVybmFsS2V5IF0gJiYgaW50ZXJuYWxLZXksXG5cdFx0XHRpc0V2ZW50cyA9IG5hbWUgPT09IFwiZXZlbnRzXCI7XG5cblx0XHQvLyBBdm9pZCBkb2luZyBhbnkgbW9yZSB3b3JrIHRoYW4gd2UgbmVlZCB0byB3aGVuIHRyeWluZyB0byBnZXQgZGF0YSBvbiBhblxuXHRcdC8vIG9iamVjdCB0aGF0IGhhcyBubyBkYXRhIGF0IGFsbFxuXHRcdGlmICggKCFpZCB8fCAhY2FjaGVbaWRdIHx8ICghaXNFdmVudHMgJiYgIXB2dCAmJiAhY2FjaGVbaWRdLmRhdGEpKSAmJiBnZXRCeU5hbWUgJiYgZGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggIWlkICkge1xuXHRcdFx0Ly8gT25seSBET00gbm9kZXMgbmVlZCBhIG5ldyB1bmlxdWUgSUQgZm9yIGVhY2ggZWxlbWVudCBzaW5jZSB0aGVpciBkYXRhXG5cdFx0XHQvLyBlbmRzIHVwIGluIHRoZSBnbG9iYWwgY2FjaGVcblx0XHRcdGlmICggaXNOb2RlICkge1xuXHRcdFx0XHRlbGVtWyBpbnRlcm5hbEtleSBdID0gaWQgPSArK2pRdWVyeS51dWlkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWQgPSBpbnRlcm5hbEtleTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFjYWNoZVsgaWQgXSApIHtcblx0XHRcdGNhY2hlWyBpZCBdID0ge307XG5cblx0XHRcdC8vIEF2b2lkcyBleHBvc2luZyBqUXVlcnkgbWV0YWRhdGEgb24gcGxhaW4gSlMgb2JqZWN0cyB3aGVuIHRoZSBvYmplY3Rcblx0XHRcdC8vIGlzIHNlcmlhbGl6ZWQgdXNpbmcgSlNPTi5zdHJpbmdpZnlcblx0XHRcdGlmICggIWlzTm9kZSApIHtcblx0XHRcdFx0Y2FjaGVbIGlkIF0udG9KU09OID0galF1ZXJ5Lm5vb3A7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW4gb2JqZWN0IGNhbiBiZSBwYXNzZWQgdG8galF1ZXJ5LmRhdGEgaW5zdGVhZCBvZiBhIGtleS92YWx1ZSBwYWlyOyB0aGlzIGdldHNcblx0XHQvLyBzaGFsbG93IGNvcGllZCBvdmVyIG9udG8gdGhlIGV4aXN0aW5nIGNhY2hlXG5cdFx0aWYgKCB0eXBlb2YgbmFtZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRcdFx0aWYgKCBwdnQgKSB7XG5cdFx0XHRcdGNhY2hlWyBpZCBdID0galF1ZXJ5LmV4dGVuZCggY2FjaGVbIGlkIF0sIG5hbWUgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhY2hlWyBpZCBdLmRhdGEgPSBqUXVlcnkuZXh0ZW5kKCBjYWNoZVsgaWQgXS5kYXRhLCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cHJpdmF0ZUNhY2hlID0gdGhpc0NhY2hlID0gY2FjaGVbIGlkIF07XG5cblx0XHQvLyBqUXVlcnkgZGF0YSgpIGlzIHN0b3JlZCBpbiBhIHNlcGFyYXRlIG9iamVjdCBpbnNpZGUgdGhlIG9iamVjdCdzIGludGVybmFsIGRhdGFcblx0XHQvLyBjYWNoZSBpbiBvcmRlciB0byBhdm9pZCBrZXkgY29sbGlzaW9ucyBiZXR3ZWVuIGludGVybmFsIGRhdGEgYW5kIHVzZXItZGVmaW5lZFxuXHRcdC8vIGRhdGEuXG5cdFx0aWYgKCAhcHZ0ICkge1xuXHRcdFx0aWYgKCAhdGhpc0NhY2hlLmRhdGEgKSB7XG5cdFx0XHRcdHRoaXNDYWNoZS5kYXRhID0ge307XG5cdFx0XHR9XG5cblx0XHRcdHRoaXNDYWNoZSA9IHRoaXNDYWNoZS5kYXRhO1xuXHRcdH1cblxuXHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpc0NhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICkgXSA9IGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlcnMgc2hvdWxkIG5vdCBhdHRlbXB0IHRvIGluc3BlY3QgdGhlIGludGVybmFsIGV2ZW50cyBvYmplY3QgdXNpbmcgalF1ZXJ5LmRhdGEsXG5cdFx0Ly8gaXQgaXMgdW5kb2N1bWVudGVkIGFuZCBzdWJqZWN0IHRvIGNoYW5nZS4gQnV0IGRvZXMgYW55b25lIGxpc3Rlbj8gTm8uXG5cdFx0aWYgKCBpc0V2ZW50cyAmJiAhdGhpc0NhY2hlWyBuYW1lIF0gKSB7XG5cdFx0XHRyZXR1cm4gcHJpdmF0ZUNhY2hlLmV2ZW50cztcblx0XHR9XG5cblx0XHQvLyBDaGVjayBmb3IgYm90aCBjb252ZXJ0ZWQtdG8tY2FtZWwgYW5kIG5vbi1jb252ZXJ0ZWQgZGF0YSBwcm9wZXJ0eSBuYW1lc1xuXHRcdC8vIElmIGEgZGF0YSBwcm9wZXJ0eSB3YXMgc3BlY2lmaWVkXG5cdFx0aWYgKCBnZXRCeU5hbWUgKSB7XG5cblx0XHRcdC8vIEZpcnN0IFRyeSB0byBmaW5kIGFzLWlzIHByb3BlcnR5IGRhdGFcblx0XHRcdHJldCA9IHRoaXNDYWNoZVsgbmFtZSBdO1xuXG5cdFx0XHQvLyBUZXN0IGZvciBudWxsfHVuZGVmaW5lZCBwcm9wZXJ0eSBkYXRhXG5cdFx0XHRpZiAoIHJldCA9PSBudWxsICkge1xuXG5cdFx0XHRcdC8vIFRyeSB0byBmaW5kIHRoZSBjYW1lbENhc2VkIHByb3BlcnR5XG5cdFx0XHRcdHJldCA9IHRoaXNDYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApIF07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldCA9IHRoaXNDYWNoZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBwdnQgLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdFx0aWYgKCAhalF1ZXJ5LmFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdGhpc0NhY2hlLCBpLCBsLFxuXG5cdFx0XHQvLyBSZWZlcmVuY2UgdG8gaW50ZXJuYWwgZGF0YSBjYWNoZSBrZXlcblx0XHRcdGludGVybmFsS2V5ID0galF1ZXJ5LmV4cGFuZG8sXG5cblx0XHRcdGlzTm9kZSA9IGVsZW0ubm9kZVR5cGUsXG5cblx0XHRcdC8vIFNlZSBqUXVlcnkuZGF0YSBmb3IgbW9yZSBpbmZvcm1hdGlvblxuXHRcdFx0Y2FjaGUgPSBpc05vZGUgPyBqUXVlcnkuY2FjaGUgOiBlbGVtLFxuXG5cdFx0XHQvLyBTZWUgalF1ZXJ5LmRhdGEgZm9yIG1vcmUgaW5mb3JtYXRpb25cblx0XHRcdGlkID0gaXNOb2RlID8gZWxlbVsgaW50ZXJuYWxLZXkgXSA6IGludGVybmFsS2V5O1xuXG5cdFx0Ly8gSWYgdGhlcmUgaXMgYWxyZWFkeSBubyBjYWNoZSBlbnRyeSBmb3IgdGhpcyBvYmplY3QsIHRoZXJlIGlzIG5vXG5cdFx0Ly8gcHVycG9zZSBpbiBjb250aW51aW5nXG5cdFx0aWYgKCAhY2FjaGVbIGlkIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuYW1lICkge1xuXG5cdFx0XHR0aGlzQ2FjaGUgPSBwdnQgPyBjYWNoZVsgaWQgXSA6IGNhY2hlWyBpZCBdLmRhdGE7XG5cblx0XHRcdGlmICggdGhpc0NhY2hlICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBuYW1lcyBmb3IgZGF0YSBrZXlzXG5cdFx0XHRcdGlmICggIWpRdWVyeS5pc0FycmF5KCBuYW1lICkgKSB7XG5cblx0XHRcdFx0XHQvLyB0cnkgdGhlIHN0cmluZyBhcyBhIGtleSBiZWZvcmUgYW55IG1hbmlwdWxhdGlvblxuXHRcdFx0XHRcdGlmICggbmFtZSBpbiB0aGlzQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gWyBuYW1lIF07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gc3BsaXQgdGhlIGNhbWVsIGNhc2VkIHZlcnNpb24gYnkgc3BhY2VzIHVubGVzcyBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzXG5cdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApO1xuXHRcdFx0XHRcdFx0aWYgKCBuYW1lIGluIHRoaXNDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IFsgbmFtZSBdO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IG5hbWUuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBuYW1lLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpc0NhY2hlWyBuYW1lW2ldIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBubyBkYXRhIGxlZnQgaW4gdGhlIGNhY2hlLCB3ZSB3YW50IHRvIGNvbnRpbnVlXG5cdFx0XHRcdC8vIGFuZCBsZXQgdGhlIGNhY2hlIG9iamVjdCBpdHNlbGYgZ2V0IGRlc3Ryb3llZFxuXHRcdFx0XHRpZiAoICEoIHB2dCA/IGlzRW1wdHlEYXRhT2JqZWN0IDogalF1ZXJ5LmlzRW1wdHlPYmplY3QgKSggdGhpc0NhY2hlICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2VlIGpRdWVyeS5kYXRhIGZvciBtb3JlIGluZm9ybWF0aW9uXG5cdFx0aWYgKCAhcHZ0ICkge1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBpZCBdLmRhdGE7XG5cblx0XHRcdC8vIERvbid0IGRlc3Ryb3kgdGhlIHBhcmVudCBjYWNoZSB1bmxlc3MgdGhlIGludGVybmFsIGRhdGEgb2JqZWN0XG5cdFx0XHQvLyBoYWQgYmVlbiB0aGUgb25seSB0aGluZyBsZWZ0IGluIGl0XG5cdFx0XHRpZiAoICFpc0VtcHR5RGF0YU9iamVjdChjYWNoZVsgaWQgXSkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBCcm93c2VycyB0aGF0IGZhaWwgZXhwYW5kbyBkZWxldGlvbiBhbHNvIHJlZnVzZSB0byBkZWxldGUgZXhwYW5kb3Mgb25cblx0XHQvLyB0aGUgd2luZG93LCBidXQgaXQgd2lsbCBhbGxvdyBpdCBvbiBhbGwgb3RoZXIgSlMgb2JqZWN0czsgb3RoZXIgYnJvd3NlcnNcblx0XHQvLyBkb24ndCBjYXJlXG5cdFx0Ly8gRW5zdXJlIHRoYXQgYGNhY2hlYCBpcyBub3QgYSB3aW5kb3cgb2JqZWN0ICMxMDA4MFxuXHRcdGlmICggalF1ZXJ5LnN1cHBvcnQuZGVsZXRlRXhwYW5kbyB8fCAhY2FjaGUuc2V0SW50ZXJ2YWwgKSB7XG5cdFx0XHRkZWxldGUgY2FjaGVbIGlkIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhY2hlWyBpZCBdID0gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBXZSBkZXN0cm95ZWQgdGhlIGNhY2hlIGFuZCBuZWVkIHRvIGVsaW1pbmF0ZSB0aGUgZXhwYW5kbyBvbiB0aGUgbm9kZSB0byBhdm9pZFxuXHRcdC8vIGZhbHNlIGxvb2t1cHMgaW4gdGhlIGNhY2hlIGZvciBlbnRyaWVzIHRoYXQgbm8gbG9uZ2VyIGV4aXN0XG5cdFx0aWYgKCBpc05vZGUgKSB7XG5cdFx0XHQvLyBJRSBkb2VzIG5vdCBhbGxvdyB1cyB0byBkZWxldGUgZXhwYW5kbyBwcm9wZXJ0aWVzIGZyb20gbm9kZXMsXG5cdFx0XHQvLyBub3IgZG9lcyBpdCBoYXZlIGEgcmVtb3ZlQXR0cmlidXRlIGZ1bmN0aW9uIG9uIERvY3VtZW50IG5vZGVzO1xuXHRcdFx0Ly8gd2UgbXVzdCBoYW5kbGUgYWxsIG9mIHRoZXNlIGNhc2VzXG5cdFx0XHRpZiAoIGpRdWVyeS5zdXBwb3J0LmRlbGV0ZUV4cGFuZG8gKSB7XG5cdFx0XHRcdGRlbGV0ZSBlbGVtWyBpbnRlcm5hbEtleSBdO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbS5yZW1vdmVBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBpbnRlcm5hbEtleSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgaW50ZXJuYWxLZXkgXSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGF0YSggZWxlbSwgbmFtZSwgZGF0YSwgdHJ1ZSApO1xuXHR9LFxuXG5cdC8vIEEgbWV0aG9kIGZvciBkZXRlcm1pbmluZyBpZiBhIERPTSBub2RlIGNhbiBoYW5kbGUgdGhlIGRhdGEgZXhwYW5kb1xuXHRhY2NlcHREYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZU5hbWUgKSB7XG5cdFx0XHR2YXIgbWF0Y2ggPSBqUXVlcnkubm9EYXRhWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0cmV0dXJuICEobWF0Y2ggPT09IHRydWUgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc2lkXCIpICE9PSBtYXRjaCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIHBhcnRzLCBwYXJ0LCBhdHRyLCBuYW1lLCBsLFxuXHRcdFx0ZWxlbSA9IHRoaXNbMF0sXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGEgPSBudWxsO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBqUXVlcnkuZGF0YSggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhalF1ZXJ5Ll9kYXRhKCBlbGVtLCBcInBhcnNlZEF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRhdHRyID0gZWxlbS5hdHRyaWJ1dGVzO1xuXHRcdFx0XHRcdGZvciAoIGwgPSBhdHRyLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyW2ldLm5hbWU7XG5cblx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc3Vic3RyaW5nKDUpICk7XG5cblx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRqUXVlcnkuX2RhdGEoIGVsZW0sIFwicGFyc2VkQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRhdGEoIHRoaXMsIGtleSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cGFydHMgPSBrZXkuc3BsaXQoIFwiLlwiLCAyICk7XG5cdFx0cGFydHNbMV0gPSBwYXJ0c1sxXSA/IFwiLlwiICsgcGFydHNbMV0gOiBcIlwiO1xuXHRcdHBhcnQgPSBwYXJ0c1sxXSArIFwiIVwiO1xuXG5cdFx0cmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRkYXRhID0gdGhpcy50cmlnZ2VySGFuZGxlciggXCJnZXREYXRhXCIgKyBwYXJ0LCBbIHBhcnRzWzBdIF0gKTtcblxuXHRcdFx0XHQvLyBUcnkgdG8gZmV0Y2ggYW55IGludGVybmFsbHkgc3RvcmVkIGRhdGEgZmlyc3Rcblx0XHRcdFx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRkYXRhID0galF1ZXJ5LmRhdGEoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkICYmIHBhcnRzWzFdID9cblx0XHRcdFx0XHR0aGlzLmRhdGEoIHBhcnRzWzBdICkgOlxuXHRcdFx0XHRcdGRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdHBhcnRzWzFdID0gdmFsdWU7XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cblx0XHRcdFx0c2VsZi50cmlnZ2VySGFuZGxlciggXCJzZXREYXRhXCIgKyBwYXJ0LCBwYXJ0cyApO1xuXHRcdFx0XHRqUXVlcnkuZGF0YSggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0XHRzZWxmLnRyaWdnZXJIYW5kbGVyKCBcImNoYW5nZURhdGFcIiArIHBhcnQsIHBhcnRzICk7XG5cdFx0XHR9KTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIGZhbHNlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZURhdGEoIHRoaXMsIGtleSApO1xuXHRcdH0pO1xuXHR9XG59KTtcblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdHZhciBuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQxXCIgKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGRhdGEgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6XG5cdFx0XHRcdGRhdGEgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDpcblx0XHRcdFx0ZGF0YSA9PT0gXCJudWxsXCIgPyBudWxsIDpcblx0XHRcdFx0alF1ZXJ5LmlzTnVtZXJpYyggZGF0YSApID8gK2RhdGEgOlxuXHRcdFx0XHRcdHJicmFjZS50ZXN0KCBkYXRhICkgPyBqUXVlcnkucGFyc2VKU09OKCBkYXRhICkgOlxuXHRcdFx0XHRcdGRhdGE7XG5cdFx0XHR9IGNhdGNoKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRqUXVlcnkuZGF0YSggZWxlbSwga2V5LCBkYXRhICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuLy8gY2hlY2tzIGEgY2FjaGUgb2JqZWN0IGZvciBlbXB0aW5lc3NcbmZ1bmN0aW9uIGlzRW1wdHlEYXRhT2JqZWN0KCBvYmogKSB7XG5cdGZvciAoIHZhciBuYW1lIGluIG9iaiApIHtcblxuXHRcdC8vIGlmIHRoZSBwdWJsaWMgZGF0YSBvYmplY3QgaXMgZW1wdHksIHRoZSBwcml2YXRlIGlzIHN0aWxsIGVtcHR5XG5cdFx0aWYgKCBuYW1lID09PSBcImRhdGFcIiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb2JqW25hbWVdICkgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0aWYgKCBuYW1lICE9PSBcInRvSlNPTlwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufVxuXG5cblxuXG5mdW5jdGlvbiBoYW5kbGVRdWV1ZU1hcmtEZWZlciggZWxlbSwgdHlwZSwgc3JjICkge1xuXHR2YXIgZGVmZXJEYXRhS2V5ID0gdHlwZSArIFwiZGVmZXJcIixcblx0XHRxdWV1ZURhdGFLZXkgPSB0eXBlICsgXCJxdWV1ZVwiLFxuXHRcdG1hcmtEYXRhS2V5ID0gdHlwZSArIFwibWFya1wiLFxuXHRcdGRlZmVyID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCBkZWZlckRhdGFLZXkgKTtcblx0aWYgKCBkZWZlciAmJlxuXHRcdCggc3JjID09PSBcInF1ZXVlXCIgfHwgIWpRdWVyeS5fZGF0YShlbGVtLCBxdWV1ZURhdGFLZXkpICkgJiZcblx0XHQoIHNyYyA9PT0gXCJtYXJrXCIgfHwgIWpRdWVyeS5fZGF0YShlbGVtLCBtYXJrRGF0YUtleSkgKSApIHtcblx0XHQvLyBHaXZlIHJvb20gZm9yIGhhcmQtY29kZWQgY2FsbGJhY2tzIHRvIGZpcmUgZmlyc3Rcblx0XHQvLyBhbmQgZXZlbnR1YWxseSBtYXJrL3F1ZXVlIHNvbWV0aGluZyBlbHNlIG9uIHRoZSBlbGVtZW50XG5cdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFqUXVlcnkuX2RhdGEoIGVsZW0sIHF1ZXVlRGF0YUtleSApICYmXG5cdFx0XHRcdCFqUXVlcnkuX2RhdGEoIGVsZW0sIG1hcmtEYXRhS2V5ICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVEYXRhKCBlbGVtLCBkZWZlckRhdGFLZXksIHRydWUgKTtcblx0XHRcdFx0ZGVmZXIuZmlyZSgpO1xuXHRcdFx0fVxuXHRcdH0sIDAgKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblxuXHRfbWFyazogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwibWFya1wiO1xuXHRcdFx0alF1ZXJ5Ll9kYXRhKCBlbGVtLCB0eXBlLCAoalF1ZXJ5Ll9kYXRhKCBlbGVtLCB0eXBlICkgfHwgMCkgKyAxICk7XG5cdFx0fVxuXHR9LFxuXG5cdF91bm1hcms6IGZ1bmN0aW9uKCBmb3JjZSwgZWxlbSwgdHlwZSApIHtcblx0XHRpZiAoIGZvcmNlICE9PSB0cnVlICkge1xuXHRcdFx0dHlwZSA9IGVsZW07XG5cdFx0XHRlbGVtID0gZm9yY2U7XG5cdFx0XHRmb3JjZSA9IGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0XHR2YXIga2V5ID0gdHlwZSArIFwibWFya1wiLFxuXHRcdFx0XHRjb3VudCA9IGZvcmNlID8gMCA6ICggKGpRdWVyeS5fZGF0YSggZWxlbSwga2V5ICkgfHwgMSkgLSAxICk7XG5cdFx0XHRpZiAoIGNvdW50ICkge1xuXHRcdFx0XHRqUXVlcnkuX2RhdGEoIGVsZW0sIGtleSwgY291bnQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVEYXRhKCBlbGVtLCBrZXksIHRydWUgKTtcblx0XHRcdFx0aGFuZGxlUXVldWVNYXJrRGVmZXIoIGVsZW0sIHR5cGUsIFwibWFya1wiICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXEgfHwgalF1ZXJ5LmlzQXJyYXkoZGF0YSkgKSB7XG5cdFx0XHRcdFx0cSA9IGpRdWVyeS5fZGF0YSggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheShkYXRhKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHEucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IHt9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0alF1ZXJ5Ll9kYXRhKCBlbGVtLCB0eXBlICsgXCIucnVuXCIsIGhvb2tzICk7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH0sIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhcXVldWUubGVuZ3RoICkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZURhdGEoIGVsZW0sIHR5cGUgKyBcInF1ZXVlIFwiICsgdHlwZSArIFwiLnJ1blwiLCB0cnVlICk7XG5cdFx0XHRoYW5kbGVRdWV1ZU1hcmtEZWZlciggZWxlbSwgdHlwZSwgXCJxdWV1ZVwiICk7XG5cdFx0fVxuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWzBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbMF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9KTtcblx0fSxcblx0Ly8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuXHQvLyBodHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5cdGRlbGF5OiBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0XHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0XHR2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmplY3QgKSB7XG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iamVjdCA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0dmFyIGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gZWxlbWVudHMubGVuZ3RoLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXJEYXRhS2V5ID0gdHlwZSArIFwiZGVmZXJcIixcblx0XHRcdHF1ZXVlRGF0YUtleSA9IHR5cGUgKyBcInF1ZXVlXCIsXG5cdFx0XHRtYXJrRGF0YUtleSA9IHR5cGUgKyBcIm1hcmtcIixcblx0XHRcdHRtcDtcblx0XHRmdW5jdGlvbiByZXNvbHZlKCkge1xuXHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlKCBpLS0gKSB7XG5cdFx0XHRpZiAoKCB0bXAgPSBqUXVlcnkuZGF0YSggZWxlbWVudHNbIGkgXSwgZGVmZXJEYXRhS2V5LCB1bmRlZmluZWQsIHRydWUgKSB8fFxuXHRcdFx0XHRcdCggalF1ZXJ5LmRhdGEoIGVsZW1lbnRzWyBpIF0sIHF1ZXVlRGF0YUtleSwgdW5kZWZpbmVkLCB0cnVlICkgfHxcblx0XHRcdFx0XHRcdGpRdWVyeS5kYXRhKCBlbGVtZW50c1sgaSBdLCBtYXJrRGF0YUtleSwgdW5kZWZpbmVkLCB0cnVlICkgKSAmJlxuXHRcdFx0XHRcdGpRdWVyeS5kYXRhKCBlbGVtZW50c1sgaSBdLCBkZWZlckRhdGFLZXksIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCB0cnVlICkgKSkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqZWN0ICk7XG5cdH1cbn0pO1xuXG5cblxuXG52YXIgcmNsYXNzID0gL1tcXG5cXHRcXHJdL2csXG5cdHJzcGFjZSA9IC9cXHMrLyxcblx0cnJldHVybiA9IC9cXHIvZyxcblx0cnR5cGUgPSAvXig/OmJ1dHRvbnxpbnB1dCkkL2ksXG5cdHJmb2N1c2FibGUgPSAvXig/OmJ1dHRvbnxpbnB1dHxvYmplY3R8c2VsZWN0fHRleHRhcmVhKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eYSg/OnJlYSk/JC9pLFxuXHRyYm9vbGVhbiA9IC9eKD86YXV0b2ZvY3VzfGF1dG9wbGF5fGFzeW5jfGNoZWNrZWR8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWR8c2VsZWN0ZWQpJC9pLFxuXHRnZXRTZXRBdHRyaWJ1dGUgPSBqUXVlcnkuc3VwcG9ydC5nZXRTZXRBdHRyaWJ1dGUsXG5cdG5vZGVIb29rLCBib29sSG9vaywgZml4U3BlY2lmaWVkO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBqUXVlcnkuYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBqUXVlcnkuYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gdHJ5L2NhdGNoIGhhbmRsZXMgY2FzZXMgd2hlcmUgSUUgYmFsa3MgKHN1Y2ggYXMgcmVtb3ZpbmcgYSBwcm9wZXJ0eSBvbiB3aW5kb3cpXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0aGlzWyBuYW1lIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzWyBuYW1lIF07XG5cdFx0XHR9IGNhdGNoKCBlICkge31cblx0XHR9KTtcblx0fSxcblxuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc05hbWVzLCBpLCBsLCBlbGVtLFxuXHRcdFx0c2V0Q2xhc3MsIGMsIGNsO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKHRoaXMsIGosIHRoaXMuY2xhc3NOYW1lKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjbGFzc05hbWVzID0gdmFsdWUuc3BsaXQoIHJzcGFjZSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRpZiAoICFlbGVtLmNsYXNzTmFtZSAmJiBjbGFzc05hbWVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHRcdGVsZW0uY2xhc3NOYW1lID0gdmFsdWU7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2V0Q2xhc3MgPSBcIiBcIiArIGVsZW0uY2xhc3NOYW1lICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGZvciAoIGMgPSAwLCBjbCA9IGNsYXNzTmFtZXMubGVuZ3RoOyBjIDwgY2w7IGMrKyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhfnNldENsYXNzLmluZGV4T2YoIFwiIFwiICsgY2xhc3NOYW1lc1sgYyBdICsgXCIgXCIgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRDbGFzcyArPSBjbGFzc05hbWVzWyBjIF0gKyBcIiBcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxlbS5jbGFzc05hbWUgPSBqUXVlcnkudHJpbSggc2V0Q2xhc3MgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc05hbWVzLCBpLCBsLCBlbGVtLCBjbGFzc05hbWUsIGMsIGNsO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKHRoaXMsIGosIHRoaXMuY2xhc3NOYW1lKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y2xhc3NOYW1lcyA9ICggdmFsdWUgfHwgXCJcIiApLnNwbGl0KCByc3BhY2UgKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgZWxlbS5jbGFzc05hbWUgKSB7XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSA9IChcIiBcIiArIGVsZW0uY2xhc3NOYW1lICsgXCIgXCIpLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKTtcblx0XHRcdFx0XHRcdGZvciAoIGMgPSAwLCBjbCA9IGNsYXNzTmFtZXMubGVuZ3RoOyBjIDwgY2w7IGMrKyApIHtcblx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lID0gY2xhc3NOYW1lLnJlcGxhY2UoXCIgXCIgKyBjbGFzc05hbWVzWyBjIF0gKyBcIiBcIiwgXCIgXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxlbS5jbGFzc05hbWUgPSBqUXVlcnkudHJpbSggY2xhc3NOYW1lICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZWxlbS5jbGFzc05hbWUgPSBcIlwiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlLFxuXHRcdFx0aXNCb29sID0gdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIjtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyggdmFsdWUuY2FsbCh0aGlzLCBpLCB0aGlzLmNsYXNzTmFtZSwgc3RhdGVWYWwpLCBzdGF0ZVZhbCApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0Ly8gdG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSxcblx0XHRcdFx0XHRpID0gMCxcblx0XHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVZhbCxcblx0XHRcdFx0XHRjbGFzc05hbWVzID0gdmFsdWUuc3BsaXQoIHJzcGFjZSApO1xuXG5cdFx0XHRcdHdoaWxlICggKGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdKSApIHtcblx0XHRcdFx0XHQvLyBjaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwZXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRzdGF0ZSA9IGlzQm9vbCA/IHN0YXRlIDogIXNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdHNlbGZbIHN0YXRlID8gXCJhZGRDbGFzc1wiIDogXCJyZW1vdmVDbGFzc1wiIF0oIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5jbGFzc05hbWUgKSB7XG5cdFx0XHRcdFx0Ly8gc3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGpRdWVyeS5fZGF0YSggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIHRoaXMuY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB0b2dnbGUgd2hvbGUgY2xhc3NOYW1lXG5cdFx0XHRcdHRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID8gXCJcIiA6IGpRdWVyeS5fZGF0YSggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGlmICggdGhpc1tpXS5ub2RlVHlwZSA9PT0gMSAmJiAoXCIgXCIgKyB0aGlzW2ldLmNsYXNzTmFtZSArIFwiIFwiKS5yZXBsYWNlKHJjbGFzcywgXCIgXCIpLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgaXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWzBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHQvLyBoYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdFx0cmV0LnJlcGxhY2UocnJldHVybiwgXCJcIikgOlxuXHRcdFx0XHRcdC8vIGhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRcdHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSh0aGlzKSwgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBzZWxmLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXHRcdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKHZhbCwgZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoXCJzZXRcIiBpbiBob29rcykgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdC8vIGF0dHJpYnV0ZXMudmFsdWUgaXMgdW5kZWZpbmVkIGluIEJsYWNrYmVycnkgNC43IGJ1dFxuXHRcdFx0XHQvLyB1c2VzIC52YWx1ZS4gU2VlICM2OTMyXG5cdFx0XHRcdHZhciB2YWwgPSBlbGVtLmF0dHJpYnV0ZXMudmFsdWU7XG5cdFx0XHRcdHJldHVybiAhdmFsIHx8IHZhbC5zcGVjaWZpZWQgPyBlbGVtLnZhbHVlIDogZWxlbS50ZXh0O1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIGksIG1heCwgb3B0aW9uLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdHZhbHVlcyA9IFtdLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIjtcblxuXHRcdFx0XHQvLyBOb3RoaW5nIHdhcyBzZWxlY3RlZFxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCAmJiAoalF1ZXJ5LnN1cHBvcnQub3B0RGlzYWJsZWQgPyAhb3B0aW9uLmRpc2FibGVkIDogb3B0aW9uLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09PSBudWxsKSAmJlxuXHRcdFx0XHRcdFx0XHQoIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8ICFqUXVlcnkubm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGaXhlcyBCdWcgIzI1NTEgLS0gc2VsZWN0LnZhbCgpIGJyb2tlbiBpbiBJRSBhZnRlciBmb3JtLnJlc2V0KClcblx0XHRcdFx0aWYgKCBvbmUgJiYgIXZhbHVlcy5sZW5ndGggJiYgb3B0aW9ucy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeSggb3B0aW9uc1sgaW5kZXggXSApLnZhbCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHRqUXVlcnkoZWxlbSkuZmluZChcIm9wdGlvblwiKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KHRoaXMpLnZhbCgpLCB2YWx1ZXMgKSA+PSAwO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoICF2YWx1ZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGF0dHJGbjoge1xuXHRcdHZhbDogdHJ1ZSxcblx0XHRjc3M6IHRydWUsXG5cdFx0aHRtbDogdHJ1ZSxcblx0XHR0ZXh0OiB0cnVlLFxuXHRcdGRhdGE6IHRydWUsXG5cdFx0d2lkdGg6IHRydWUsXG5cdFx0aGVpZ2h0OiB0cnVlLFxuXHRcdG9mZnNldDogdHJ1ZVxuXHR9LFxuXG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgcGFzcyApIHtcblx0XHR2YXIgcmV0LCBob29rcywgbm90eG1sLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gZG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBwYXNzICYmIG5hbWUgaW4galF1ZXJ5LmF0dHJGbiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkoIGVsZW0gKVsgbmFtZSBdKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0bm90eG1sID0gblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApO1xuXG5cdFx0Ly8gQWxsIGF0dHJpYnV0ZXMgYXJlIGxvd2VyY2FzZVxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5vdHhtbCApIHtcblx0XHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSB8fCAoIHJib29sZWFuLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogbm9kZUhvb2sgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fSBlbHNlIGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJiBub3R4bWwgJiYgKHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIFwiXCIgKyB2YWx1ZSApO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIG5vdHhtbCAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkpICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldCA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0XHRyZXR1cm4gcmV0ID09PSBudWxsID9cblx0XHRcdFx0dW5kZWZpbmVkIDpcblx0XHRcdFx0cmV0O1xuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3BOYW1lLCBhdHRyTmFtZXMsIG5hbWUsIGwsIGlzQm9vbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCB2YWx1ZSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUudG9Mb3dlckNhc2UoKS5zcGxpdCggcnNwYWNlICk7XG5cdFx0XHRsID0gYXR0ck5hbWVzLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRuYW1lID0gYXR0ck5hbWVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBuYW1lICkge1xuXHRcdFx0XHRcdHByb3BOYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdGlzQm9vbCA9IHJib29sZWFuLnRlc3QoIG5hbWUgKTtcblxuXHRcdFx0XHRcdC8vIFNlZSAjOTY5OSBmb3IgZXhwbGFuYXRpb24gb2YgdGhpcyBhcHByb2FjaCAoc2V0dGluZyBmaXJzdCwgdGhlbiByZW1vdmFsKVxuXHRcdFx0XHRcdC8vIERvIG5vdCBkbyB0aGlzIGZvciBib29sZWFuIGF0dHJpYnV0ZXMgKHNlZSAjMTA4NzApXG5cdFx0XHRcdFx0aWYgKCAhaXNCb29sICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmF0dHIoIGVsZW0sIG5hbWUsIFwiXCIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIGdldFNldEF0dHJpYnV0ZSA/IG5hbWUgOiBwcm9wTmFtZSApO1xuXG5cdFx0XHRcdFx0Ly8gU2V0IGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdG8gZmFsc2UgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuXHRcdFx0XHRcdGlmICggaXNCb29sICYmIHByb3BOYW1lIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBwcm9wTmFtZSBdID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHQvLyBXZSBjYW4ndCBhbGxvdyB0aGUgdHlwZSBwcm9wZXJ0eSB0byBiZSBjaGFuZ2VkIChzaW5jZSBpdCBjYXVzZXMgcHJvYmxlbXMgaW4gSUUpXG5cdFx0XHRcdGlmICggcnR5cGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXJyb3IoIFwidHlwZSBwcm9wZXJ0eSBjYW4ndCBiZSBjaGFuZ2VkXCIgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggIWpRdWVyeS5zdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJiBqUXVlcnkubm9kZU5hbWUoZWxlbSwgXCJpbnB1dFwiKSApIHtcblx0XHRcdFx0XHQvLyBTZXR0aW5nIHRoZSB0eXBlIG9uIGEgcmFkaW8gYnV0dG9uIGFmdGVyIHRoZSB2YWx1ZSByZXNldHMgdGhlIHZhbHVlIGluIElFNi05XG5cdFx0XHRcdFx0Ly8gUmVzZXQgdmFsdWUgdG8gaXQncyBkZWZhdWx0IGluIGNhc2UgdHlwZSBpcyBzZXQgYWZ0ZXIgdmFsdWVcblx0XHRcdFx0XHQvLyBUaGlzIGlzIGZvciBlbGVtZW50IGNyZWF0aW9uXG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvLyBVc2UgdGhlIHZhbHVlIHByb3BlcnR5IGZvciBiYWNrIGNvbXBhdFxuXHRcdC8vIFVzZSB0aGUgbm9kZUhvb2sgZm9yIGJ1dHRvbiBlbGVtZW50cyBpbiBJRTYvNyAoIzE5NTQpXG5cdFx0dmFsdWU6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0XHRcdGlmICggbm9kZUhvb2sgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImJ1dHRvblwiICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGVIb29rLmdldCggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBuYW1lIGluIGVsZW0gP1xuXHRcdFx0XHRcdGVsZW0udmFsdWUgOlxuXHRcdFx0XHRcdG51bGw7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0XHRcdGlmICggbm9kZUhvb2sgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImJ1dHRvblwiICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGVIb29rLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBEb2VzIG5vdCByZXR1cm4gc28gdGhhdCBzZXRBdHRyaWJ1dGUgaXMgYWxzbyB1c2VkXG5cdFx0XHRcdGVsZW0udmFsdWUgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdHRhYmluZGV4OiBcInRhYkluZGV4XCIsXG5cdFx0cmVhZG9ubHk6IFwicmVhZE9ubHlcIixcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCIsXG5cdFx0bWF4bGVuZ3RoOiBcIm1heExlbmd0aFwiLFxuXHRcdGNlbGxzcGFjaW5nOiBcImNlbGxTcGFjaW5nXCIsXG5cdFx0Y2VsbHBhZGRpbmc6IFwiY2VsbFBhZGRpbmdcIixcblx0XHRyb3dzcGFuOiBcInJvd1NwYW5cIixcblx0XHRjb2xzcGFuOiBcImNvbFNwYW5cIixcblx0XHR1c2VtYXA6IFwidXNlTWFwXCIsXG5cdFx0ZnJhbWVib3JkZXI6IFwiZnJhbWVCb3JkZXJcIixcblx0XHRjb250ZW50ZWRpdGFibGU6IFwiY29udGVudEVkaXRhYmxlXCJcblx0fSxcblxuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsIG5vdHhtbCxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIGRvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5vdHhtbCA9IG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKTtcblxuXHRcdGlmICggbm90eG1sICkge1xuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkpICE9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHR2YXIgYXR0cmlidXRlTm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcInRhYmluZGV4XCIpO1xuXG5cdFx0XHRcdHJldHVybiBhdHRyaWJ1dGVOb2RlICYmIGF0dHJpYnV0ZU5vZGUuc3BlY2lmaWVkID9cblx0XHRcdFx0XHRwYXJzZUludCggYXR0cmlidXRlTm9kZS52YWx1ZSwgMTAgKSA6XG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHwgcmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiYgZWxlbS5ocmVmID9cblx0XHRcdFx0XHRcdDAgOlxuXHRcdFx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIEFkZCB0aGUgdGFiSW5kZXggcHJvcEhvb2sgdG8gYXR0ckhvb2tzIGZvciBiYWNrLWNvbXBhdCAoZGlmZmVyZW50IGNhc2UgaXMgaW50ZW50aW9uYWwpXG5qUXVlcnkuYXR0ckhvb2tzLnRhYmluZGV4ID0galF1ZXJ5LnByb3BIb29rcy50YWJJbmRleDtcblxuLy8gSG9vayBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHQvLyBBbGlnbiBib29sZWFuIGF0dHJpYnV0ZXMgd2l0aCBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXNcblx0XHQvLyBGYWxsIGJhY2sgdG8gYXR0cmlidXRlIHByZXNlbmNlIHdoZXJlIHNvbWUgYm9vbGVhbnMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHR2YXIgYXR0ck5vZGUsXG5cdFx0XHRwcm9wZXJ0eSA9IGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lICk7XG5cdFx0cmV0dXJuIHByb3BlcnR5ID09PSB0cnVlIHx8IHR5cGVvZiBwcm9wZXJ0eSAhPT0gXCJib29sZWFuXCIgJiYgKCBhdHRyTm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSApICYmIGF0dHJOb2RlLm5vZGVWYWx1ZSAhPT0gZmFsc2UgP1xuXHRcdFx0bmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdHVuZGVmaW5lZDtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0dmFyIHByb3BOYW1lO1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gdmFsdWUgaXMgdHJ1ZSBzaW5jZSB3ZSBrbm93IGF0IHRoaXMgcG9pbnQgaXQncyB0eXBlIGJvb2xlYW4gYW5kIG5vdCBmYWxzZVxuXHRcdFx0Ly8gU2V0IGJvb2xlYW4gYXR0cmlidXRlcyB0byB0aGUgc2FtZSBuYW1lIGFuZCBzZXQgdGhlIERPTSBwcm9wZXJ0eVxuXHRcdFx0cHJvcE5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRpZiAoIHByb3BOYW1lIGluIGVsZW0gKSB7XG5cdFx0XHRcdC8vIE9ubHkgc2V0IHRoZSBJREwgc3BlY2lmaWNhbGx5IGlmIGl0IGFscmVhZHkgZXhpc3RzIG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdGVsZW1bIHByb3BOYW1lIF0gPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG4vLyBJRTYvNyBkbyBub3Qgc3VwcG9ydCBnZXR0aW5nL3NldHRpbmcgc29tZSBhdHRyaWJ1dGVzIHdpdGggZ2V0L3NldEF0dHJpYnV0ZVxuaWYgKCAhZ2V0U2V0QXR0cmlidXRlICkge1xuXG5cdGZpeFNwZWNpZmllZCA9IHtcblx0XHRuYW1lOiB0cnVlLFxuXHRcdGlkOiB0cnVlLFxuXHRcdGNvb3JkczogdHJ1ZVxuXHR9O1xuXG5cdC8vIFVzZSB0aGlzIGZvciBhbnkgYXR0cmlidXRlIGluIElFNi83XG5cdC8vIFRoaXMgZml4ZXMgYWxtb3N0IGV2ZXJ5IElFNi83IGlzc3VlXG5cdG5vZGVIb29rID0galF1ZXJ5LnZhbEhvb2tzLmJ1dHRvbiA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdFx0dmFyIHJldDtcblx0XHRcdHJldCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApO1xuXHRcdFx0cmV0dXJuIHJldCAmJiAoIGZpeFNwZWNpZmllZFsgbmFtZSBdID8gcmV0Lm5vZGVWYWx1ZSAhPT0gXCJcIiA6IHJldC5zcGVjaWZpZWQgKSA/XG5cdFx0XHRcdHJldC5ub2RlVmFsdWUgOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRcdC8vIFNldCB0aGUgZXhpc3Rpbmcgb3IgY3JlYXRlIGEgbmV3IGF0dHJpYnV0ZSBub2RlXG5cdFx0XHR2YXIgcmV0ID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICk7XG5cdFx0XHRpZiAoICFyZXQgKSB7XG5cdFx0XHRcdHJldCA9IGRvY3VtZW50LmNyZWF0ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZU5vZGUoIHJldCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICggcmV0Lm5vZGVWYWx1ZSA9IHZhbHVlICsgXCJcIiApO1xuXHRcdH1cblx0fTtcblxuXHQvLyBBcHBseSB0aGUgbm9kZUhvb2sgdG8gdGFiaW5kZXhcblx0alF1ZXJ5LmF0dHJIb29rcy50YWJpbmRleC5zZXQgPSBub2RlSG9vay5zZXQ7XG5cblx0Ly8gU2V0IHdpZHRoIGFuZCBoZWlnaHQgdG8gYXV0byBpbnN0ZWFkIG9mIDAgb24gZW1wdHkgc3RyaW5nKCBCdWcgIzgxNTAgKVxuXHQvLyBUaGlzIGlzIGZvciByZW1vdmFsc1xuXHRqUXVlcnkuZWFjaChbIFwid2lkdGhcIiwgXCJoZWlnaHRcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0XHRqUXVlcnkuYXR0ckhvb2tzWyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lIF0sIHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcIlwiICkge1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBcImF1dG9cIiApO1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblxuXHQvLyBTZXQgY29udGVudGVkaXRhYmxlIHRvIGZhbHNlIG9uIHJlbW92YWxzKCMxMDQyOSlcblx0Ly8gU2V0dGluZyB0byBlbXB0eSBzdHJpbmcgdGhyb3dzIGFuIGVycm9yIGFzIGFuIGludmFsaWQgdmFsdWVcblx0alF1ZXJ5LmF0dHJIb29rcy5jb250ZW50ZWRpdGFibGUgPSB7XG5cdFx0Z2V0OiBub2RlSG9vay5nZXQsXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBcIlwiICkge1xuXHRcdFx0XHR2YWx1ZSA9IFwiZmFsc2VcIjtcblx0XHRcdH1cblx0XHRcdG5vZGVIb29rLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKTtcblx0XHR9XG5cdH07XG59XG5cblxuLy8gU29tZSBhdHRyaWJ1dGVzIHJlcXVpcmUgYSBzcGVjaWFsIGNhbGwgb24gSUVcbmlmICggIWpRdWVyeS5zdXBwb3J0LmhyZWZOb3JtYWxpemVkICkge1xuXHRqUXVlcnkuZWFjaChbIFwiaHJlZlwiLCBcInNyY1wiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdFx0alF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmV0ID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIDIgKTtcblx0XHRcdFx0cmV0dXJuIHJldCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbmlmICggIWpRdWVyeS5zdXBwb3J0LnN0eWxlICkge1xuXHRqUXVlcnkuYXR0ckhvb2tzLnN0eWxlID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBSZXR1cm4gdW5kZWZpbmVkIGluIHRoZSBjYXNlIG9mIGVtcHR5IHN0cmluZ1xuXHRcdFx0Ly8gTm9ybWFsaXplIHRvIGxvd2VyY2FzZSBzaW5jZSBJRSB1cHBlcmNhc2VzIGNzcyBwcm9wZXJ0eSBuYW1lc1xuXHRcdFx0cmV0dXJuIGVsZW0uc3R5bGUuY3NzVGV4dC50b0xvd2VyQ2FzZSgpIHx8IHVuZGVmaW5lZDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuICggZWxlbS5zdHlsZS5jc3NUZXh0ID0gXCJcIiArIHZhbHVlICk7XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBTYWZhcmkgbWlzLXJlcG9ydHMgdGhlIGRlZmF1bHQgc2VsZWN0ZWQgcHJvcGVydHkgb2YgYW4gb3B0aW9uXG4vLyBBY2Nlc3NpbmcgdGhlIHBhcmVudCdzIHNlbGVjdGVkSW5kZXggcHJvcGVydHkgZml4ZXMgaXRcbmlmICggIWpRdWVyeS5zdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0galF1ZXJ5LmV4dGVuZCggalF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCwge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgaXQgYWxzbyB3b3JrcyB3aXRoIG9wdGdyb3Vwcywgc2VlICM1NzAxXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gSUU2LzcgY2FsbCBlbmN0eXBlIGVuY29kaW5nXG5pZiAoICFqUXVlcnkuc3VwcG9ydC5lbmN0eXBlICkge1xuXHRqUXVlcnkucHJvcEZpeC5lbmN0eXBlID0gXCJlbmNvZGluZ1wiO1xufVxuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxuaWYgKCAhalF1ZXJ5LnN1cHBvcnQuY2hlY2tPbiApIHtcblx0alF1ZXJ5LmVhY2goWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBpbiBXZWJraXQgXCJcIiBpcyByZXR1cm5lZCBpbnN0ZWFkIG9mIFwib25cIiBpZiBhIHZhbHVlIGlzbid0IHNwZWNpZmllZFxuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG59XG5qUXVlcnkuZWFjaChbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IGpRdWVyeS5leHRlbmQoIGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLCB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KGVsZW0pLnZhbCgpLCB2YWx1ZSApID49IDAgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufSk7XG5cblxuXG5cbnZhciByZm9ybUVsZW1zID0gL14oPzp0ZXh0YXJlYXxpbnB1dHxzZWxlY3QpJC9pLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteXFwuXSopPyg/OlxcLiguKykpPyQvLFxuXHRyaG92ZXJIYWNrID0gLyg/Ol58XFxzKWhvdmVyKFxcLlxcUyspP1xcYi8sXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfGNvbnRleHRtZW51KXxjbGljay8sXG5cdHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRycXVpY2tJcyA9IC9eKFxcdyopKD86IyhbXFx3XFwtXSspKT8oPzpcXC4oW1xcd1xcLV0rKSk/JC8sXG5cdHF1aWNrUGFyc2UgPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIHF1aWNrID0gcnF1aWNrSXMuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRpZiAoIHF1aWNrICkge1xuXHRcdFx0Ly8gICAwICAxICAgIDIgICAzXG5cdFx0XHQvLyBbIF8sIHRhZywgaWQsIGNsYXNzIF1cblx0XHRcdHF1aWNrWzFdID0gKCBxdWlja1sxXSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHF1aWNrWzNdID0gcXVpY2tbM10gJiYgbmV3IFJlZ0V4cCggXCIoPzpefFxcXFxzKVwiICsgcXVpY2tbM10gKyBcIig/OlxcXFxzfCQpXCIgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHF1aWNrO1xuXHR9LFxuXHRxdWlja0lzID0gZnVuY3Rpb24oIGVsZW0sIG0gKSB7XG5cdFx0dmFyIGF0dHJzID0gZWxlbS5hdHRyaWJ1dGVzIHx8IHt9O1xuXHRcdHJldHVybiAoXG5cdFx0XHQoIW1bMV0gfHwgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBtWzFdKSAmJlxuXHRcdFx0KCFtWzJdIHx8IChhdHRycy5pZCB8fCB7fSkudmFsdWUgPT09IG1bMl0pICYmXG5cdFx0XHQoIW1bM10gfHwgbVszXS50ZXN0KCAoYXR0cnNbIFwiY2xhc3NcIiBdIHx8IHt9KS52YWx1ZSApKVxuXHRcdCk7XG5cdH0sXG5cdGhvdmVySGFjayA9IGZ1bmN0aW9uKCBldmVudHMgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ldmVudC5zcGVjaWFsLmhvdmVyID8gZXZlbnRzIDogZXZlbnRzLnJlcGxhY2UoIHJob3ZlckhhY2ssIFwibW91c2VlbnRlciQxIG1vdXNlbGVhdmUkMVwiICk7XG5cdH07XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGVsZW1EYXRhLCBldmVudEhhbmRsZSwgZXZlbnRzLFxuXHRcdFx0dCwgdG5zLCB0eXBlLCBuYW1lc3BhY2VzLCBoYW5kbGVPYmosXG5cdFx0XHRoYW5kbGVPYmpJbiwgcXVpY2ssIGhhbmRsZXJzLCBzcGVjaWFsO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChhbGxvdyBwbGFpbiBvYmplY3RzIHRobylcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhdHlwZXMgfHwgIWhhbmRsZXIgfHwgIShlbGVtRGF0YSA9IGpRdWVyeS5fZGF0YSggZWxlbSApKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHM7XG5cdFx0aWYgKCAhZXZlbnRzICkge1xuXHRcdFx0ZWxlbURhdGEuZXZlbnRzID0gZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlO1xuXHRcdGlmICggIWV2ZW50SGFuZGxlICkge1xuXHRcdFx0ZWxlbURhdGEuaGFuZGxlID0gZXZlbnRIYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoIWUgfHwgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlKSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBldmVudEhhbmRsZS5lbGVtLCBhcmd1bWVudHMgKSA6XG5cdFx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHRcdC8vIEFkZCBlbGVtIGFzIGEgcHJvcGVydHkgb2YgdGhlIGhhbmRsZSBmbiB0byBwcmV2ZW50IGEgbWVtb3J5IGxlYWsgd2l0aCBJRSBub24tbmF0aXZlIGV2ZW50c1xuXHRcdFx0ZXZlbnRIYW5kbGUuZWxlbSA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdC8vIGpRdWVyeSguLi4pLmJpbmQoXCJtb3VzZW92ZXIgbW91c2VvdXRcIiwgZm4pO1xuXHRcdHR5cGVzID0galF1ZXJ5LnRyaW0oIGhvdmVySGFjayh0eXBlcykgKS5zcGxpdCggXCIgXCIgKTtcblx0XHRmb3IgKCB0ID0gMDsgdCA8IHR5cGVzLmxlbmd0aDsgdCsrICkge1xuXG5cdFx0XHR0bnMgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1t0XSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IHRuc1sxXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRuc1syXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IHRuc1sxXSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdHF1aWNrOiBzZWxlY3RvciAmJiBxdWlja1BhcnNlKCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbihcIi5cIilcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0aWYgKCAhaGFuZGxlcnMgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lci9hdHRhY2hFdmVudCBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHwgc3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHQvLyBCaW5kIHRoZSBnbG9iYWwgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSwgZmFsc2UgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGVsZW0uYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmF0dGFjaEV2ZW50KCBcIm9uXCIgKyB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE51bGxpZnkgZWxlbSB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcyBpbiBJRVxuXHRcdGVsZW0gPSBudWxsO1xuXHR9LFxuXG5cdGdsb2JhbDoge30sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgZWxlbURhdGEgPSBqUXVlcnkuaGFzRGF0YSggZWxlbSApICYmIGpRdWVyeS5fZGF0YSggZWxlbSApLFxuXHRcdFx0dCwgdG5zLCB0eXBlLCBvcmlnVHlwZSwgbmFtZXNwYWNlcywgb3JpZ0NvdW50LFxuXHRcdFx0aiwgZXZlbnRzLCBzcGVjaWFsLCBoYW5kbGUsIGV2ZW50VHlwZSwgaGFuZGxlT2JqO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgIShldmVudHMgPSBlbGVtRGF0YS5ldmVudHMpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9IGpRdWVyeS50cmltKCBob3ZlckhhY2soIHR5cGVzIHx8IFwiXCIgKSApLnNwbGl0KFwiIFwiKTtcblx0XHRmb3IgKCB0ID0gMDsgdCA8IHR5cGVzLmxlbmd0aDsgdCsrICkge1xuXHRcdFx0dG5zID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbdF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRuc1sxXTtcblx0XHRcdG5hbWVzcGFjZXMgPSB0bnNbMl07XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3I/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRldmVudFR5cGUgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdG9yaWdDb3VudCA9IGV2ZW50VHlwZS5sZW5ndGg7XG5cdFx0XHRuYW1lc3BhY2VzID0gbmFtZXNwYWNlcyA/IG5ldyBSZWdFeHAoXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuc3BsaXQoXCIuXCIpLnNvcnQoKS5qb2luKFwiXFxcXC4oPzouKlxcXFwuKT9cIikgKyBcIihcXFxcLnwkKVwiKSA6IG51bGw7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdGZvciAoIGogPSAwOyBqIDwgZXZlbnRUeXBlLmxlbmd0aDsgaisrICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudFR5cGVbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0ICggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0ICggIW5hbWVzcGFjZXMgfHwgbmFtZXNwYWNlcy50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCAoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0ZXZlbnRUeXBlLnNwbGljZSggai0tLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGV2ZW50VHlwZS5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIGV2ZW50VHlwZS5sZW5ndGggPT09IDAgJiYgb3JpZ0NvdW50ICE9PSBldmVudFR5cGUubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8IHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcyApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRoYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGU7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmVsZW0gPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyByZW1vdmVEYXRhIGFsc28gY2hlY2tzIGZvciBlbXB0aW5lc3MgYW5kIGNsZWFycyB0aGUgZXhwYW5kbyBpZiBlbXB0eVxuXHRcdFx0Ly8gc28gdXNlIGl0IGluc3RlYWQgb2YgZGVsZXRlXG5cdFx0XHRqUXVlcnkucmVtb3ZlRGF0YSggZWxlbSwgWyBcImV2ZW50c1wiLCBcImhhbmRsZVwiIF0sIHRydWUgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gRXZlbnRzIHRoYXQgYXJlIHNhZmUgdG8gc2hvcnQtY2lyY3VpdCBpZiBubyBoYW5kbGVycyBhcmUgYXR0YWNoZWQuXG5cdC8vIE5hdGl2ZSBET00gZXZlbnRzIHNob3VsZCBub3QgYmUgYWRkZWQsIHRoZXkgbWF5IGhhdmUgaW5saW5lIGhhbmRsZXJzLlxuXHRjdXN0b21FdmVudDoge1xuXHRcdFwiZ2V0RGF0YVwiOiB0cnVlLFxuXHRcdFwic2V0RGF0YVwiOiB0cnVlLFxuXHRcdFwiY2hhbmdlRGF0YVwiOiB0cnVlXG5cdH0sXG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0gJiYgKGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRXZlbnQgb2JqZWN0IG9yIGV2ZW50IHR5cGVcblx0XHR2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gW10sXG5cdFx0XHRjYWNoZSwgZXhjbHVzaXZlLCBpLCBjdXIsIG9sZCwgb250eXBlLCBzcGVjaWFsLCBoYW5kbGUsIGV2ZW50UGF0aCwgYnViYmxlVHlwZTtcblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIhXCIgKSA+PSAwICkge1xuXHRcdFx0Ly8gRXhjbHVzaXZlIGV2ZW50cyB0cmlnZ2VyIG9ubHkgZm9yIHRoZSBleGFjdCBldmVudCAobm8gbmFtZXNwYWNlcylcblx0XHRcdHR5cGUgPSB0eXBlLnNsaWNlKDAsIC0xKTtcblx0XHRcdGV4Y2x1c2l2ZSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPj0gMCApIHtcblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KFwiLlwiKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cblx0XHRpZiAoICghZWxlbSB8fCBqUXVlcnkuZXZlbnQuY3VzdG9tRXZlbnRbIHR5cGUgXSkgJiYgIWpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSApIHtcblx0XHRcdC8vIE5vIGpRdWVyeSBoYW5kbGVycyBmb3IgdGhpcyBldmVudCB0eXBlLCBhbmQgaXQgY2FuJ3QgaGF2ZSBpbmxpbmUgaGFuZGxlcnNcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gRXZlbnQsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiID9cblx0XHRcdC8vIGpRdWVyeS5FdmVudCBvYmplY3Rcblx0XHRcdGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID8gZXZlbnQgOlxuXHRcdFx0Ly8gT2JqZWN0IGxpdGVyYWxcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIGV2ZW50ICkgOlxuXHRcdFx0Ly8gSnVzdCB0aGUgZXZlbnQgdHlwZSAoc3RyaW5nKVxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSApO1xuXG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gdHJ1ZTtcblx0XHRldmVudC5leGNsdXNpdmUgPSBleGNsdXNpdmU7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZV9yZSA9IGV2ZW50Lm5hbWVzcGFjZT8gbmV3IFJlZ0V4cChcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwuKT9cIikgKyBcIihcXFxcLnwkKVwiKSA6IG51bGw7XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCA/IFwib25cIiArIHR5cGUgOiBcIlwiO1xuXG5cdFx0Ly8gSGFuZGxlIGEgZ2xvYmFsIHRyaWdnZXJcblx0XHRpZiAoICFlbGVtICkge1xuXG5cdFx0XHQvLyBUT0RPOiBTdG9wIHRhdW50aW5nIHRoZSBkYXRhIGNhY2hlOyByZW1vdmUgZ2xvYmFsIGV2ZW50cyBhbmQgYWx3YXlzIGF0dGFjaCB0byBkb2N1bWVudFxuXHRcdFx0Y2FjaGUgPSBqUXVlcnkuY2FjaGU7XG5cdFx0XHRmb3IgKCBpIGluIGNhY2hlICkge1xuXHRcdFx0XHRpZiAoIGNhY2hlWyBpIF0uZXZlbnRzICYmIGNhY2hlWyBpIF0uZXZlbnRzWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGV2ZW50LCBkYXRhLCBjYWNoZVsgaSBdLmhhbmRsZS5lbGVtLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgIT0gbnVsbCA/IGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSA6IFtdO1xuXHRcdGRhdGEudW5zaGlmdCggZXZlbnQgKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRldmVudFBhdGggPSBbWyBlbGVtLCBzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGUgXV07XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRjdXIgPSByZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApID8gZWxlbSA6IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdG9sZCA9IG51bGw7XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKFsgY3VyLCBidWJibGVUeXBlIF0pO1xuXHRcdFx0XHRvbGQgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCBvbGQgJiYgb2xkID09PSBlbGVtLm93bmVyRG9jdW1lbnQgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKFsgb2xkLmRlZmF1bHRWaWV3IHx8IG9sZC5wYXJlbnRXaW5kb3cgfHwgd2luZG93LCBidWJibGVUeXBlIF0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRmb3IgKCBpID0gMDsgaSA8IGV2ZW50UGF0aC5sZW5ndGggJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCk7IGkrKyApIHtcblxuXHRcdFx0Y3VyID0gZXZlbnRQYXRoW2ldWzBdO1xuXHRcdFx0ZXZlbnQudHlwZSA9IGV2ZW50UGF0aFtpXVsxXTtcblxuXHRcdFx0aGFuZGxlID0gKCBqUXVlcnkuX2RhdGEoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJiBqUXVlcnkuX2RhdGEoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBOb3RlIHRoYXQgdGhpcyBpcyBhIGJhcmUgSlMgZnVuY3Rpb24gYW5kIG5vdCBhIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGpRdWVyeS5hY2NlcHREYXRhKCBjdXIgKSAmJiBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoIXNwZWNpYWwuX2RlZmF1bHQgfHwgc3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZWxlbS5vd25lckRvY3VtZW50LCBkYXRhICkgPT09IGZhbHNlKSAmJlxuXHRcdFx0XHQhKHR5cGUgPT09IFwiY2xpY2tcIiAmJiBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiYVwiICkpICYmIGpRdWVyeS5hY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBDYW4ndCB1c2UgYW4gLmlzRnVuY3Rpb24oKSBjaGVjayBoZXJlIGJlY2F1c2UgSUU2LzcgZmFpbHMgdGhhdCB0ZXN0LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdC8vIElFPDkgZGllcyBvbiBmb2N1cy9ibHVyIHRvIGhpZGRlbiBlbGVtZW50ICgjMTQ4Nilcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgZWxlbVsgdHlwZSBdICYmICgodHlwZSAhPT0gXCJmb2N1c1wiICYmIHR5cGUgIT09IFwiYmx1clwiKSB8fCBldmVudC50YXJnZXQub2Zmc2V0V2lkdGggIT09IDApICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHRvbGQgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggb2xkICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggb2xkICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBvbGQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0ZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBldmVudCB8fCB3aW5kb3cuZXZlbnQgKTtcblxuXHRcdHZhciBoYW5kbGVycyA9ICggKGpRdWVyeS5fZGF0YSggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSksXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGFyZ3MgPSBbXS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDAgKSxcblx0XHRcdHJ1bl9hbGwgPSAhZXZlbnQuZXhjbHVzaXZlICYmICFldmVudC5uYW1lc3BhY2UsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fSxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0aSwgaiwgY3VyLCBqcWN1ciwgcmV0LCBzZWxNYXRjaCwgbWF0Y2hlZCwgbWF0Y2hlcywgaGFuZGxlT2JqLCBzZWwsIHJlbGF0ZWQ7XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbMF0gPSBldmVudDtcblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzIHRoYXQgc2hvdWxkIHJ1biBpZiB0aGVyZSBhcmUgZGVsZWdhdGVkIGV2ZW50c1xuXHRcdC8vIEF2b2lkIG5vbi1sZWZ0LWNsaWNrIGJ1YmJsaW5nIGluIEZpcmVmb3ggKCMzODYxKVxuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJiAhKGV2ZW50LmJ1dHRvbiAmJiBldmVudC50eXBlID09PSBcImNsaWNrXCIpICkge1xuXG5cdFx0XHQvLyBQcmVnZW5lcmF0ZSBhIHNpbmdsZSBqUXVlcnkgb2JqZWN0IGZvciByZXVzZSB3aXRoIC5pcygpXG5cdFx0XHRqcWN1ciA9IGpRdWVyeSh0aGlzKTtcblx0XHRcdGpxY3VyLmNvbnRleHQgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcztcblxuXHRcdFx0Zm9yICggY3VyID0gZXZlbnQudGFyZ2V0OyBjdXIgIT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGV2ZW50cyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1KVxuXHRcdFx0XHRpZiAoIGN1ci5kaXNhYmxlZCAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRzZWxNYXRjaCA9IHt9O1xuXHRcdFx0XHRcdG1hdGNoZXMgPSBbXTtcblx0XHRcdFx0XHRqcWN1clswXSA9IGN1cjtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3I7XG5cblx0XHRcdFx0XHRcdGlmICggc2VsTWF0Y2hbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdHNlbE1hdGNoWyBzZWwgXSA9IChcblx0XHRcdFx0XHRcdFx0XHRoYW5kbGVPYmoucXVpY2sgPyBxdWlja0lzKCBjdXIsIGhhbmRsZU9iai5xdWljayApIDoganFjdXIuaXMoIHNlbCApXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIHNlbE1hdGNoWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKHsgZWxlbTogY3VyLCBtYXRjaGVzOiBtYXRjaGVzIH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRpZiAoIGhhbmRsZXJzLmxlbmd0aCA+IGRlbGVnYXRlQ291bnQgKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCh7IGVsZW06IHRoaXMsIG1hdGNoZXM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSk7XG5cdFx0fVxuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRmb3IgKCBpID0gMDsgaSA8IGhhbmRsZXJRdWV1ZS5sZW5ndGggJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCk7IGkrKyApIHtcblx0XHRcdG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkgXTtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGZvciAoIGogPSAwOyBqIDwgbWF0Y2hlZC5tYXRjaGVzLmxlbmd0aCAmJiAhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKTsgaisrICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBtYXRjaGVkLm1hdGNoZXNbIGogXTtcblxuXHRcdFx0XHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgYmUgbm9uLWV4Y2x1c2l2ZSBhbmQgaGF2ZSBubyBuYW1lc3BhY2UsIG9yXG5cdFx0XHRcdC8vIDIpIGhhdmUgbmFtZXNwYWNlKHMpIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuXHRcdFx0XHRpZiAoIHJ1bl9hbGwgfHwgKCFldmVudC5uYW1lc3BhY2UgJiYgIWhhbmRsZU9iai5uYW1lc3BhY2UpIHx8IGV2ZW50Lm5hbWVzcGFjZV9yZSAmJiBldmVudC5uYW1lc3BhY2VfcmUudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblxuXHRcdFx0XHRcdHJldCA9ICggKGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSkuaGFuZGxlIHx8IGhhbmRsZU9iai5oYW5kbGVyIClcblx0XHRcdFx0XHRcdFx0LmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRldmVudC5yZXN1bHQgPSByZXQ7XG5cdFx0XHRcdFx0XHRpZiAoIHJldCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIEluY2x1ZGVzIHNvbWUgZXZlbnQgcHJvcHMgc2hhcmVkIGJ5IEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50XG5cdC8vICoqKiBhdHRyQ2hhbmdlIGF0dHJOYW1lIHJlbGF0ZWROb2RlIHNyY0VsZW1lbnQgIGFyZSBub3Qgbm9ybWFsaXplZCwgbm9uLVczQywgZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIGluIDEuOCAqKipcblx0cHJvcHM6IFwiYXR0ckNoYW5nZSBhdHRyTmFtZSByZWxhdGVkTm9kZSBzcmNFbGVtZW50IGFsdEtleSBidWJibGVzIGNhbmNlbGFibGUgY3RybEtleSBjdXJyZW50VGFyZ2V0IGV2ZW50UGhhc2UgbWV0YUtleSByZWxhdGVkVGFyZ2V0IHNoaWZ0S2V5IHRhcmdldCB0aW1lU3RhbXAgdmlldyB3aGljaFwiLnNwbGl0KFwiIFwiKSxcblxuXHRmaXhIb29rczoge30sXG5cblx0a2V5SG9va3M6IHtcblx0XHRwcm9wczogXCJjaGFyIGNoYXJDb2RlIGtleSBrZXlDb2RlXCIuc3BsaXQoXCIgXCIpLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50LndoaWNoID0gb3JpZ2luYWwuY2hhckNvZGUgIT0gbnVsbCA/IG9yaWdpbmFsLmNoYXJDb2RlIDogb3JpZ2luYWwua2V5Q29kZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblx0fSxcblxuXHRtb3VzZUhvb2tzOiB7XG5cdFx0cHJvcHM6IFwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIGZyb21FbGVtZW50IG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XCIuc3BsaXQoXCIgXCIpLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblx0XHRcdHZhciBldmVudERvYywgZG9jLCBib2R5LFxuXHRcdFx0XHRidXR0b24gPSBvcmlnaW5hbC5idXR0b24sXG5cdFx0XHRcdGZyb21FbGVtZW50ID0gb3JpZ2luYWwuZnJvbUVsZW1lbnQ7XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG1pc3NpbmcgYW5kIGNsaWVudFgvWSBhdmFpbGFibGVcblx0XHRcdGlmICggZXZlbnQucGFnZVggPT0gbnVsbCAmJiBvcmlnaW5hbC5jbGllbnRYICE9IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50RG9jID0gZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG5cdFx0XHRcdGRvYyA9IGV2ZW50RG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdFx0Ym9keSA9IGV2ZW50RG9jLmJvZHk7XG5cblx0XHRcdFx0ZXZlbnQucGFnZVggPSBvcmlnaW5hbC5jbGllbnRYICsgKCBkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCApIC0gKCBkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCApO1xuXHRcdFx0XHRldmVudC5wYWdlWSA9IG9yaWdpbmFsLmNsaWVudFkgKyAoIGRvYyAmJiBkb2Muc2Nyb2xsVG9wICB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wICB8fCAwICkgLSAoIGRvYyAmJiBkb2MuY2xpZW50VG9wICB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wICB8fCAwICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCByZWxhdGVkVGFyZ2V0LCBpZiBuZWNlc3Nhcnlcblx0XHRcdGlmICggIWV2ZW50LnJlbGF0ZWRUYXJnZXQgJiYgZnJvbUVsZW1lbnQgKSB7XG5cdFx0XHRcdGV2ZW50LnJlbGF0ZWRUYXJnZXQgPSBmcm9tRWxlbWVudCA9PT0gZXZlbnQudGFyZ2V0ID8gb3JpZ2luYWwudG9FbGVtZW50IDogZnJvbUVsZW1lbnQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRcdC8vIE5vdGU6IGJ1dHRvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28gZG9uJ3QgdXNlIGl0XG5cdFx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0ZXZlbnQud2hpY2ggPSAoIGJ1dHRvbiAmIDEgPyAxIDogKCBidXR0b24gJiAyID8gMyA6ICggYnV0dG9uICYgNCA/IDIgOiAwICkgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gQ3JlYXRlIGEgd3JpdGFibGUgY29weSBvZiB0aGUgZXZlbnQgb2JqZWN0IGFuZCBub3JtYWxpemUgc29tZSBwcm9wZXJ0aWVzXG5cdFx0dmFyIGksIHByb3AsXG5cdFx0XHRvcmlnaW5hbEV2ZW50ID0gZXZlbnQsXG5cdFx0XHRmaXhIb29rID0galF1ZXJ5LmV2ZW50LmZpeEhvb2tzWyBldmVudC50eXBlIF0gfHwge30sXG5cdFx0XHRjb3B5ID0gZml4SG9vay5wcm9wcyA/IHRoaXMucHJvcHMuY29uY2F0KCBmaXhIb29rLnByb3BzICkgOiB0aGlzLnByb3BzO1xuXG5cdFx0ZXZlbnQgPSBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblxuXHRcdGZvciAoIGkgPSBjb3B5Lmxlbmd0aDsgaTsgKSB7XG5cdFx0XHRwcm9wID0gY29weVsgLS1pIF07XG5cdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ2luYWxFdmVudFsgcHJvcCBdO1xuXHRcdH1cblxuXHRcdC8vIEZpeCB0YXJnZXQgcHJvcGVydHksIGlmIG5lY2Vzc2FyeSAoIzE5MjUsIElFIDYvNy84ICYgU2FmYXJpMilcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBvcmlnaW5hbEV2ZW50LnNyY0VsZW1lbnQgfHwgZG9jdW1lbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsIFNhZmFyaSlcblx0XHRpZiAoIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PT0gMyApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdC8vIEZvciBtb3VzZS9rZXkgZXZlbnRzOyBhZGQgbWV0YUtleSBpZiBpdCdzIG5vdCB0aGVyZSAoIzMzNjgsIElFNi83LzgpXG5cdFx0aWYgKCBldmVudC5tZXRhS2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRldmVudC5tZXRhS2V5ID0gZXZlbnQuY3RybEtleTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZml4SG9vay5maWx0ZXI/IGZpeEhvb2suZmlsdGVyKCBldmVudCwgb3JpZ2luYWxFdmVudCApIDogZXZlbnQ7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdHJlYWR5OiB7XG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhlIHJlYWR5IGV2ZW50IGlzIHNldHVwXG5cdFx0XHRzZXR1cDogalF1ZXJ5LmJpbmRSZWFkeVxuXHRcdH0sXG5cblx0XHRsb2FkOiB7XG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cblx0XHRmb2N1czoge1xuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxuXHRcdH0sXG5cdFx0Ymx1cjoge1xuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkge1xuXHRcdFx0XHQvLyBXZSBvbmx5IHdhbnQgdG8gZG8gdGhpcyBzcGVjaWFsIGNhc2Ugb24gd2luZG93c1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggdGhpcyApICkge1xuXHRcdFx0XHRcdHRoaXMub25iZWZvcmV1bmxvYWQgPSBldmVudEhhbmRsZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9uYmVmb3JldW5sb2FkID09PSBldmVudEhhbmRsZSApIHtcblx0XHRcdFx0XHR0aGlzLm9uYmVmb3JldW5sb2FkID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50LCBidWJibGUgKSB7XG5cdFx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lLlxuXHRcdC8vIEZha2Ugb3JpZ2luYWxFdmVudCB0byBhdm9pZCBkb25vcidzIHN0b3BQcm9wYWdhdGlvbiwgYnV0IGlmIHRoZVxuXHRcdC8vIHNpbXVsYXRlZCBldmVudCBwcmV2ZW50cyBkZWZhdWx0IHRoZW4gd2UgZG8gdGhlIHNhbWUgb24gdGhlIGRvbm9yLlxuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0eyB0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZSxcblx0XHRcdFx0b3JpZ2luYWxFdmVudDoge31cblx0XHRcdH1cblx0XHQpO1xuXHRcdGlmICggYnViYmxlICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmNhbGwoIGVsZW0sIGUgKTtcblx0XHR9XG5cdFx0aWYgKCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH1cbn07XG5cbi8vIFNvbWUgcGx1Z2lucyBhcmUgdXNpbmcsIGJ1dCBpdCdzIHVuZG9jdW1lbnRlZC9kZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQuXG4vLyBUaGUgMS43IHNwZWNpYWwgZXZlbnQgaW50ZXJmYWNlIHNob3VsZCBwcm92aWRlIGFsbCB0aGUgaG9va3MgbmVlZGVkIG5vdy5cbmpRdWVyeS5ldmVudC5oYW5kbGUgPSBqUXVlcnkuZXZlbnQuZGlzcGF0Y2g7XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIgP1xuXHRmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXHRcdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUsIGZhbHNlICk7XG5cdFx0fVxuXHR9IDpcblx0ZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblx0XHRpZiAoIGVsZW0uZGV0YWNoRXZlbnQgKSB7XG5cdFx0XHRlbGVtLmRldGFjaEV2ZW50KCBcIm9uXCIgKyB0eXBlLCBoYW5kbGUgKTtcblx0XHR9XG5cdH07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQpICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9ICggc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHwgc3JjLnJldHVyblZhbHVlID09PSBmYWxzZSB8fFxuXHRcdFx0c3JjLmdldFByZXZlbnREZWZhdWx0ICYmIHNyYy5nZXRQcmV2ZW50RGVmYXVsdCgpICkgPyByZXR1cm5UcnVlIDogcmV0dXJuRmFsc2U7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgalF1ZXJ5Lm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cdFx0aWYgKCAhZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBpZiBwcmV2ZW50RGVmYXVsdCBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuXHRcdGlmICggZS5wcmV2ZW50RGVmYXVsdCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblxuXHRcdC8vIG90aGVyd2lzZSBzZXQgdGhlIHJldHVyblZhbHVlIHByb3BlcnR5IG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byBmYWxzZSAoSUUpXG5cdFx0fSBlbHNlIHtcblx0XHRcdGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblx0XHRpZiAoICFlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQvLyBpZiBzdG9wUHJvcGFnYXRpb24gZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcblx0XHRpZiAoIGUuc3RvcFByb3BhZ2F0aW9uICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdFx0Ly8gb3RoZXJ3aXNlIHNldCB0aGUgY2FuY2VsQnViYmxlIHByb3BlcnR5IG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byB0cnVlIChJRSlcblx0XHRlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fSxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2Vcbn07XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xualF1ZXJ5LmVhY2goe1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmosXG5cdFx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRyZXQ7XG5cblx0XHRcdC8vIEZvciBtb3VzZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkpICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0pO1xuXG4vLyBJRSBzdWJtaXQgZGVsZWdhdGlvblxuaWYgKCAhalF1ZXJ5LnN1cHBvcnQuc3VibWl0QnViYmxlcyApIHtcblxuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbC5zdWJtaXQgPSB7XG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gT25seSBuZWVkIHRoaXMgZm9yIGRlbGVnYXRlZCBmb3JtIHN1Ym1pdCBldmVudHNcblx0XHRcdGlmICggalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImZvcm1cIiApICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExhenktYWRkIGEgc3VibWl0IGhhbmRsZXIgd2hlbiBhIGRlc2NlbmRhbnQgZm9ybSBtYXkgcG90ZW50aWFsbHkgYmUgc3VibWl0dGVkXG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCBcImNsaWNrLl9zdWJtaXQga2V5cHJlc3MuX3N1Ym1pdFwiLCBmdW5jdGlvbiggZSApIHtcblx0XHRcdFx0Ly8gTm9kZSBuYW1lIGNoZWNrIGF2b2lkcyBhIFZNTC1yZWxhdGVkIGNyYXNoIGluIElFICgjOTgwNylcblx0XHRcdFx0dmFyIGVsZW0gPSBlLnRhcmdldCxcblx0XHRcdFx0XHRmb3JtID0galF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSB8fCBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiYnV0dG9uXCIgKSA/IGVsZW0uZm9ybSA6IHVuZGVmaW5lZDtcblx0XHRcdFx0aWYgKCBmb3JtICYmICFmb3JtLl9zdWJtaXRfYXR0YWNoZWQgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZm9ybSwgXCJzdWJtaXQuX3N1Ym1pdFwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRldmVudC5fc3VibWl0X2J1YmJsZSA9IHRydWU7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Zm9ybS5fc3VibWl0X2F0dGFjaGVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHQvLyByZXR1cm4gdW5kZWZpbmVkIHNpbmNlIHdlIGRvbid0IG5lZWQgYW4gZXZlbnQgbGlzdGVuZXJcblx0XHR9LFxuXHRcdFxuXHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0Ly8gSWYgZm9ybSB3YXMgc3VibWl0dGVkIGJ5IHRoZSB1c2VyLCBidWJibGUgdGhlIGV2ZW50IHVwIHRoZSB0cmVlXG5cdFx0XHRpZiAoIGV2ZW50Ll9zdWJtaXRfYnViYmxlICkge1xuXHRcdFx0XHRkZWxldGUgZXZlbnQuX3N1Ym1pdF9idWJibGU7XG5cdFx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICYmICFldmVudC5pc1RyaWdnZXIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBcInN1Ym1pdFwiLCB0aGlzLnBhcmVudE5vZGUsIGV2ZW50LCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gT25seSBuZWVkIHRoaXMgZm9yIGRlbGVnYXRlZCBmb3JtIHN1Ym1pdCBldmVudHNcblx0XHRcdGlmICggalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImZvcm1cIiApICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBkZWxlZ2F0ZWQgaGFuZGxlcnM7IGNsZWFuRGF0YSBldmVudHVhbGx5IHJlYXBzIHN1Ym1pdCBoYW5kbGVycyBhdHRhY2hlZCBhYm92ZVxuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgXCIuX3N1Ym1pdFwiICk7XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBJRSBjaGFuZ2UgZGVsZWdhdGlvbiBhbmQgY2hlY2tib3gvcmFkaW8gZml4XG5pZiAoICFqUXVlcnkuc3VwcG9ydC5jaGFuZ2VCdWJibGVzICkge1xuXG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsLmNoYW5nZSA9IHtcblxuXHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0aWYgKCByZm9ybUVsZW1zLnRlc3QoIHRoaXMubm9kZU5hbWUgKSApIHtcblx0XHRcdFx0Ly8gSUUgZG9lc24ndCBmaXJlIGNoYW5nZSBvbiBhIGNoZWNrL3JhZGlvIHVudGlsIGJsdXI7IHRyaWdnZXIgaXQgb24gY2xpY2tcblx0XHRcdFx0Ly8gYWZ0ZXIgYSBwcm9wZXJ0eWNoYW5nZS4gRWF0IHRoZSBibHVyLWNoYW5nZSBpbiBzcGVjaWFsLmNoYW5nZS5oYW5kbGUuXG5cdFx0XHRcdC8vIFRoaXMgc3RpbGwgZmlyZXMgb25jaGFuZ2UgYSBzZWNvbmQgdGltZSBmb3IgY2hlY2svcmFkaW8gYWZ0ZXIgYmx1ci5cblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiB8fCB0aGlzLnR5cGUgPT09IFwicmFkaW9cIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCBcInByb3BlcnR5Y2hhbmdlLl9jaGFuZ2VcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdFx0aWYgKCBldmVudC5vcmlnaW5hbEV2ZW50LnByb3BlcnR5TmFtZSA9PT0gXCJjaGVja2VkXCIgKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2p1c3RfY2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgXCJjbGljay5fY2hhbmdlXCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRcdGlmICggdGhpcy5fanVzdF9jaGFuZ2VkICYmICFldmVudC5pc1RyaWdnZXIgKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2p1c3RfY2hhbmdlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIFwiY2hhbmdlXCIsIHRoaXMsIGV2ZW50LCB0cnVlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRGVsZWdhdGVkIGV2ZW50OyBsYXp5LWFkZCBhIGNoYW5nZSBoYW5kbGVyIG9uIGRlc2NlbmRhbnQgaW5wdXRzXG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCBcImJlZm9yZWFjdGl2YXRlLl9jaGFuZ2VcIiwgZnVuY3Rpb24oIGUgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gZS50YXJnZXQ7XG5cblx0XHRcdFx0aWYgKCByZm9ybUVsZW1zLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJiAhZWxlbS5fY2hhbmdlX2F0dGFjaGVkICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGVsZW0sIFwiY2hhbmdlLl9jaGFuZ2VcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgJiYgIWV2ZW50LmlzU2ltdWxhdGVkICYmICFldmVudC5pc1RyaWdnZXIgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggXCJjaGFuZ2VcIiwgdGhpcy5wYXJlbnROb2RlLCBldmVudCwgdHJ1ZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGVsZW0uX2NoYW5nZV9hdHRhY2hlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBlbGVtID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0XHQvLyBTd2FsbG93IG5hdGl2ZSBjaGFuZ2UgZXZlbnRzIGZyb20gY2hlY2tib3gvcmFkaW8sIHdlIGFscmVhZHkgdHJpZ2dlcmVkIHRoZW0gYWJvdmVcblx0XHRcdGlmICggdGhpcyAhPT0gZWxlbSB8fCBldmVudC5pc1NpbXVsYXRlZCB8fCBldmVudC5pc1RyaWdnZXIgfHwgKGVsZW0udHlwZSAhPT0gXCJyYWRpb1wiICYmIGVsZW0udHlwZSAhPT0gXCJjaGVja2JveFwiKSApIHtcblx0XHRcdFx0cmV0dXJuIGV2ZW50LmhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgXCIuX2NoYW5nZVwiICk7XG5cblx0XHRcdHJldHVybiByZm9ybUVsZW1zLnRlc3QoIHRoaXMubm9kZU5hbWUgKTtcblx0XHR9XG5cdH07XG59XG5cbi8vIENyZWF0ZSBcImJ1YmJsaW5nXCIgZm9jdXMgYW5kIGJsdXIgZXZlbnRzXG5pZiAoICFqUXVlcnkuc3VwcG9ydC5mb2N1c2luQnViYmxlcyApIHtcblx0alF1ZXJ5LmVhY2goeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBhdHRhY2hlcyA9IDAsXG5cdFx0XHRoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApLCB0cnVlICk7XG5cdFx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGF0dGFjaGVzKysgPT09IDAgKSB7XG5cdFx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIC0tYXR0YWNoZXMgPT09IDAgKSB7XG5cdFx0XHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgLypJTlRFUk5BTCovIG9uZSApIHtcblx0XHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdFx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7IC8vICYmIHNlbGVjdG9yICE9IG51bGxcblx0XHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9uKCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXHRcdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRcdGZuID0gZGF0YTtcblx0XHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0XHRvcmlnRm4gPSBmbjtcblx0XHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdH07XG5cdFx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHRcdH0pO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHR2YXIgaGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/IGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6IGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB2YXIgdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9KTtcblx0fSxcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0bGl2ZTogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRqUXVlcnkoIHRoaXMuY29udGV4dCApLm9uKCB0eXBlcywgdGhpcy5zZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0ZGllOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdGpRdWVyeSggdGhpcy5jb250ZXh0ICkub2ZmKCB0eXBlcywgdGhpcy5zZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PSAxPyB0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDogdGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciwgZm4gKTtcblx0fSxcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9KTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdGlmICggdGhpc1swXSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpc1swXSwgdHJ1ZSApO1xuXHRcdH1cblx0fSxcblxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHQvLyBTYXZlIHJlZmVyZW5jZSB0byBhcmd1bWVudHMgZm9yIGFjY2VzcyBpbiBjbG9zdXJlXG5cdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHR0b2dnbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQvLyBGaWd1cmUgb3V0IHdoaWNoIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcblx0XHRcdFx0dmFyIGxhc3RUb2dnbGUgPSAoIGpRdWVyeS5fZGF0YSggdGhpcywgXCJsYXN0VG9nZ2xlXCIgKyBmbi5ndWlkICkgfHwgMCApICUgaTtcblx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCB0aGlzLCBcImxhc3RUb2dnbGVcIiArIGZuLmd1aWQsIGxhc3RUb2dnbGUgKyAxICk7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgY2xpY2tzIHN0b3Bcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0XHQvLyBhbmQgZXhlY3V0ZSB0aGUgZnVuY3Rpb25cblx0XHRcdFx0cmV0dXJuIGFyZ3NbIGxhc3RUb2dnbGUgXS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgfHwgZmFsc2U7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gbGluayBhbGwgdGhlIGZ1bmN0aW9ucywgc28gYW55IG9mIHRoZW0gY2FuIHVuYmluZCB0aGlzIGNsaWNrIGhhbmRsZXJcblx0XHR0b2dnbGVyLmd1aWQgPSBndWlkO1xuXHRcdHdoaWxlICggaSA8IGFyZ3MubGVuZ3RoICkge1xuXHRcdFx0YXJnc1sgaSsrIF0uZ3VpZCA9IGd1aWQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuY2xpY2soIHRvZ2dsZXIgKTtcblx0fSxcblxuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZWFjaCggKFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yIGNvbnRleHRtZW51XCIpLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0aWYgKCBmbiA9PSBudWxsICkge1xuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG5cblx0aWYgKCBqUXVlcnkuYXR0ckZuICkge1xuXHRcdGpRdWVyeS5hdHRyRm5bIG5hbWUgXSA9IHRydWU7XG5cdH1cblxuXHRpZiAoIHJrZXlFdmVudC50ZXN0KCBuYW1lICkgKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmZpeEhvb2tzWyBuYW1lIF0gPSBqUXVlcnkuZXZlbnQua2V5SG9va3M7XG5cdH1cblxuXHRpZiAoIHJtb3VzZUV2ZW50LnRlc3QoIG5hbWUgKSApIHtcblx0XHRqUXVlcnkuZXZlbnQuZml4SG9va3NbIG5hbWUgXSA9IGpRdWVyeS5ldmVudC5tb3VzZUhvb2tzO1xuXHR9XG59KTtcblxuXG5cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmVcbiAqICBDb3B5cmlnaHQgMjAxMSwgVGhlIERvam8gRm91bmRhdGlvblxuICogIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQsIEJTRCwgYW5kIEdQTCBMaWNlbnNlcy5cbiAqICBNb3JlIGluZm9ybWF0aW9uOiBodHRwOi8vc2l6emxlanMuY29tL1xuICovXG4oZnVuY3Rpb24oKXtcblxudmFyIGNodW5rZXIgPSAvKCg/OlxcKCg/OlxcKFteKCldK1xcKXxbXigpXSspK1xcKXxcXFsoPzpcXFtbXlxcW1xcXV0qXFxdfFsnXCJdW14nXCJdKlsnXCJdfFteXFxbXFxdJ1wiXSspK1xcXXxcXFxcLnxbXiA+K34sKFxcW1xcXFxdKykrfFs+K35dKShcXHMqLFxccyopPygoPzoufFxccnxcXG4pKikvZyxcblx0ZXhwYW5kbyA9IFwic2l6Y2FjaGVcIiArIChNYXRoLnJhbmRvbSgpICsgJycpLnJlcGxhY2UoJy4nLCAnJyksXG5cdGRvbmUgPSAwLFxuXHR0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG5cdGhhc0R1cGxpY2F0ZSA9IGZhbHNlLFxuXHRiYXNlSGFzRHVwbGljYXRlID0gdHJ1ZSxcblx0ckJhY2tzbGFzaCA9IC9cXFxcL2csXG5cdHJSZXR1cm4gPSAvXFxyXFxuL2csXG5cdHJOb25Xb3JkID0gL1xcVy87XG5cbi8vIEhlcmUgd2UgY2hlY2sgaWYgdGhlIEphdmFTY3JpcHQgZW5naW5lIGlzIHVzaW5nIHNvbWUgc29ydCBvZlxuLy8gb3B0aW1pemF0aW9uIHdoZXJlIGl0IGRvZXMgbm90IGFsd2F5cyBjYWxsIG91ciBjb21wYXJpc2lvblxuLy8gZnVuY3Rpb24uIElmIHRoYXQgaXMgdGhlIGNhc2UsIGRpc2NhcmQgdGhlIGhhc0R1cGxpY2F0ZSB2YWx1ZS5cbi8vICAgVGh1cyBmYXIgdGhhdCBpbmNsdWRlcyBHb29nbGUgQ2hyb21lLlxuWzAsIDBdLnNvcnQoZnVuY3Rpb24oKSB7XG5cdGJhc2VIYXNEdXBsaWNhdGUgPSBmYWxzZTtcblx0cmV0dXJuIDA7XG59KTtcblxudmFyIFNpenpsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdHZhciBvcmlnQ29udGV4dCA9IGNvbnRleHQ7XG5cblx0aWYgKCBjb250ZXh0Lm5vZGVUeXBlICE9PSAxICYmIGNvbnRleHQubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0aWYgKCAhc2VsZWN0b3IgfHwgdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0dmFyIG0sIHNldCwgY2hlY2tTZXQsIGV4dHJhLCByZXQsIGN1ciwgcG9wLCBpLFxuXHRcdHBydW5lID0gdHJ1ZSxcblx0XHRjb250ZXh0WE1MID0gU2l6emxlLmlzWE1MKCBjb250ZXh0ICksXG5cdFx0cGFydHMgPSBbXSxcblx0XHRzb0ZhciA9IHNlbGVjdG9yO1xuXG5cdC8vIFJlc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgY2h1bmtlciByZWdleHAgKHN0YXJ0IGZyb20gaGVhZClcblx0ZG8ge1xuXHRcdGNodW5rZXIuZXhlYyggXCJcIiApO1xuXHRcdG0gPSBjaHVua2VyLmV4ZWMoIHNvRmFyICk7XG5cblx0XHRpZiAoIG0gKSB7XG5cdFx0XHRzb0ZhciA9IG1bM107XG5cblx0XHRcdHBhcnRzLnB1c2goIG1bMV0gKTtcblxuXHRcdFx0aWYgKCBtWzJdICkge1xuXHRcdFx0XHRleHRyYSA9IG1bM107XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fSB3aGlsZSAoIG0gKTtcblxuXHRpZiAoIHBhcnRzLmxlbmd0aCA+IDEgJiYgb3JpZ1BPUy5leGVjKCBzZWxlY3RvciApICkge1xuXG5cdFx0aWYgKCBwYXJ0cy5sZW5ndGggPT09IDIgJiYgRXhwci5yZWxhdGl2ZVsgcGFydHNbMF0gXSApIHtcblx0XHRcdHNldCA9IHBvc1Byb2Nlc3MoIHBhcnRzWzBdICsgcGFydHNbMV0sIGNvbnRleHQsIHNlZWQgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZXQgPSBFeHByLnJlbGF0aXZlWyBwYXJ0c1swXSBdID9cblx0XHRcdFx0WyBjb250ZXh0IF0gOlxuXHRcdFx0XHRTaXp6bGUoIHBhcnRzLnNoaWZ0KCksIGNvbnRleHQgKTtcblxuXHRcdFx0d2hpbGUgKCBwYXJ0cy5sZW5ndGggKSB7XG5cdFx0XHRcdHNlbGVjdG9yID0gcGFydHMuc2hpZnQoKTtcblxuXHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHNlbGVjdG9yIF0gKSB7XG5cdFx0XHRcdFx0c2VsZWN0b3IgKz0gcGFydHMuc2hpZnQoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNldCA9IHBvc1Byb2Nlc3MoIHNlbGVjdG9yLCBzZXQsIHNlZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0fSBlbHNlIHtcblx0XHQvLyBUYWtlIGEgc2hvcnRjdXQgYW5kIHNldCB0aGUgY29udGV4dCBpZiB0aGUgcm9vdCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdC8vIChidXQgbm90IGlmIGl0J2xsIGJlIGZhc3RlciBpZiB0aGUgaW5uZXIgc2VsZWN0b3IgaXMgYW4gSUQpXG5cdFx0aWYgKCAhc2VlZCAmJiBwYXJ0cy5sZW5ndGggPiAxICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgIWNvbnRleHRYTUwgJiZcblx0XHRcdFx0RXhwci5tYXRjaC5JRC50ZXN0KHBhcnRzWzBdKSAmJiAhRXhwci5tYXRjaC5JRC50ZXN0KHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdKSApIHtcblxuXHRcdFx0cmV0ID0gU2l6emxlLmZpbmQoIHBhcnRzLnNoaWZ0KCksIGNvbnRleHQsIGNvbnRleHRYTUwgKTtcblx0XHRcdGNvbnRleHQgPSByZXQuZXhwciA/XG5cdFx0XHRcdFNpenpsZS5maWx0ZXIoIHJldC5leHByLCByZXQuc2V0IClbMF0gOlxuXHRcdFx0XHRyZXQuc2V0WzBdO1xuXHRcdH1cblxuXHRcdGlmICggY29udGV4dCApIHtcblx0XHRcdHJldCA9IHNlZWQgP1xuXHRcdFx0XHR7IGV4cHI6IHBhcnRzLnBvcCgpLCBzZXQ6IG1ha2VBcnJheShzZWVkKSB9IDpcblx0XHRcdFx0U2l6emxlLmZpbmQoIHBhcnRzLnBvcCgpLCBwYXJ0cy5sZW5ndGggPT09IDEgJiYgKHBhcnRzWzBdID09PSBcIn5cIiB8fCBwYXJ0c1swXSA9PT0gXCIrXCIpICYmIGNvbnRleHQucGFyZW50Tm9kZSA/IGNvbnRleHQucGFyZW50Tm9kZSA6IGNvbnRleHQsIGNvbnRleHRYTUwgKTtcblxuXHRcdFx0c2V0ID0gcmV0LmV4cHIgP1xuXHRcdFx0XHRTaXp6bGUuZmlsdGVyKCByZXQuZXhwciwgcmV0LnNldCApIDpcblx0XHRcdFx0cmV0LnNldDtcblxuXHRcdFx0aWYgKCBwYXJ0cy5sZW5ndGggPiAwICkge1xuXHRcdFx0XHRjaGVja1NldCA9IG1ha2VBcnJheSggc2V0ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBydW5lID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHdoaWxlICggcGFydHMubGVuZ3RoICkge1xuXHRcdFx0XHRjdXIgPSBwYXJ0cy5wb3AoKTtcblx0XHRcdFx0cG9wID0gY3VyO1xuXG5cdFx0XHRcdGlmICggIUV4cHIucmVsYXRpdmVbIGN1ciBdICkge1xuXHRcdFx0XHRcdGN1ciA9IFwiXCI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cG9wID0gcGFydHMucG9wKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHBvcCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHBvcCA9IGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRFeHByLnJlbGF0aXZlWyBjdXIgXSggY2hlY2tTZXQsIHBvcCwgY29udGV4dFhNTCApO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGNoZWNrU2V0ID0gcGFydHMgPSBbXTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICFjaGVja1NldCApIHtcblx0XHRjaGVja1NldCA9IHNldDtcblx0fVxuXG5cdGlmICggIWNoZWNrU2V0ICkge1xuXHRcdFNpenpsZS5lcnJvciggY3VyIHx8IHNlbGVjdG9yICk7XG5cdH1cblxuXHRpZiAoIHRvU3RyaW5nLmNhbGwoY2hlY2tTZXQpID09PSBcIltvYmplY3QgQXJyYXldXCIgKSB7XG5cdFx0aWYgKCAhcHJ1bmUgKSB7XG5cdFx0XHRyZXN1bHRzLnB1c2guYXBwbHkoIHJlc3VsdHMsIGNoZWNrU2V0ICk7XG5cblx0XHR9IGVsc2UgaWYgKCBjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRmb3IgKCBpID0gMDsgY2hlY2tTZXRbaV0gIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNoZWNrU2V0W2ldICYmIChjaGVja1NldFtpXSA9PT0gdHJ1ZSB8fCBjaGVja1NldFtpXS5ub2RlVHlwZSA9PT0gMSAmJiBTaXp6bGUuY29udGFpbnMoY29udGV4dCwgY2hlY2tTZXRbaV0pKSApIHtcblx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIHNldFtpXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSA9IDA7IGNoZWNrU2V0W2ldICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjaGVja1NldFtpXSAmJiBjaGVja1NldFtpXS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIHNldFtpXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cdFx0bWFrZUFycmF5KCBjaGVja1NldCwgcmVzdWx0cyApO1xuXHR9XG5cblx0aWYgKCBleHRyYSApIHtcblx0XHRTaXp6bGUoIGV4dHJhLCBvcmlnQ29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xuXHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdGlmICggc29ydE9yZGVyICkge1xuXHRcdGhhc0R1cGxpY2F0ZSA9IGJhc2VIYXNEdXBsaWNhdGU7XG5cdFx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRcdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdFx0Zm9yICggdmFyIGkgPSAxOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCByZXN1bHRzW2ldID09PSByZXN1bHRzWyBpIC0gMSBdICkge1xuXHRcdFx0XHRcdHJlc3VsdHMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgc2V0ICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBzZXQgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggbm9kZSwgZXhwciApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgW25vZGVdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5maW5kID0gZnVuY3Rpb24oIGV4cHIsIGNvbnRleHQsIGlzWE1MICkge1xuXHR2YXIgc2V0LCBpLCBsZW4sIG1hdGNoLCB0eXBlLCBsZWZ0O1xuXG5cdGlmICggIWV4cHIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0Zm9yICggaSA9IDAsIGxlbiA9IEV4cHIub3JkZXIubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0dHlwZSA9IEV4cHIub3JkZXJbaV07XG5cblx0XHRpZiAoIChtYXRjaCA9IEV4cHIubGVmdE1hdGNoWyB0eXBlIF0uZXhlYyggZXhwciApKSApIHtcblx0XHRcdGxlZnQgPSBtYXRjaFsxXTtcblx0XHRcdG1hdGNoLnNwbGljZSggMSwgMSApO1xuXG5cdFx0XHRpZiAoIGxlZnQuc3Vic3RyKCBsZWZ0Lmxlbmd0aCAtIDEgKSAhPT0gXCJcXFxcXCIgKSB7XG5cdFx0XHRcdG1hdGNoWzFdID0gKG1hdGNoWzFdIHx8IFwiXCIpLnJlcGxhY2UoIHJCYWNrc2xhc2gsIFwiXCIgKTtcblx0XHRcdFx0c2V0ID0gRXhwci5maW5kWyB0eXBlIF0oIG1hdGNoLCBjb250ZXh0LCBpc1hNTCApO1xuXG5cdFx0XHRcdGlmICggc2V0ICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0ZXhwciA9IGV4cHIucmVwbGFjZSggRXhwci5tYXRjaFsgdHlwZSBdLCBcIlwiICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoICFzZXQgKSB7XG5cdFx0c2V0ID0gdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCIqXCIgKSA6XG5cdFx0XHRbXTtcblx0fVxuXG5cdHJldHVybiB7IHNldDogc2V0LCBleHByOiBleHByIH07XG59O1xuXG5TaXp6bGUuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIHNldCwgaW5wbGFjZSwgbm90ICkge1xuXHR2YXIgbWF0Y2gsIGFueUZvdW5kLFxuXHRcdHR5cGUsIGZvdW5kLCBpdGVtLCBmaWx0ZXIsIGxlZnQsXG5cdFx0aSwgcGFzcyxcblx0XHRvbGQgPSBleHByLFxuXHRcdHJlc3VsdCA9IFtdLFxuXHRcdGN1ckxvb3AgPSBzZXQsXG5cdFx0aXNYTUxGaWx0ZXIgPSBzZXQgJiYgc2V0WzBdICYmIFNpenpsZS5pc1hNTCggc2V0WzBdICk7XG5cblx0d2hpbGUgKCBleHByICYmIHNldC5sZW5ndGggKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gRXhwci5sZWZ0TWF0Y2hbIHR5cGUgXS5leGVjKCBleHByICkpICE9IG51bGwgJiYgbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdGZpbHRlciA9IEV4cHIuZmlsdGVyWyB0eXBlIF07XG5cdFx0XHRcdGxlZnQgPSBtYXRjaFsxXTtcblxuXHRcdFx0XHRhbnlGb3VuZCA9IGZhbHNlO1xuXG5cdFx0XHRcdG1hdGNoLnNwbGljZSgxLDEpO1xuXG5cdFx0XHRcdGlmICggbGVmdC5zdWJzdHIoIGxlZnQubGVuZ3RoIC0gMSApID09PSBcIlxcXFxcIiApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggY3VyTG9vcCA9PT0gcmVzdWx0ICkge1xuXHRcdFx0XHRcdHJlc3VsdCA9IFtdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBFeHByLnByZUZpbHRlclsgdHlwZSBdICkge1xuXHRcdFx0XHRcdG1hdGNoID0gRXhwci5wcmVGaWx0ZXJbIHR5cGUgXSggbWF0Y2gsIGN1ckxvb3AsIGlucGxhY2UsIHJlc3VsdCwgbm90LCBpc1hNTEZpbHRlciApO1xuXG5cdFx0XHRcdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRcdFx0XHRhbnlGb3VuZCA9IGZvdW5kID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgKGl0ZW0gPSBjdXJMb29wW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGl0ZW0gKSB7XG5cdFx0XHRcdFx0XHRcdGZvdW5kID0gZmlsdGVyKCBpdGVtLCBtYXRjaCwgaSwgY3VyTG9vcCApO1xuXHRcdFx0XHRcdFx0XHRwYXNzID0gbm90IF4gZm91bmQ7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBpbnBsYWNlICYmIGZvdW5kICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBwYXNzICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0YW55Rm91bmQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1ckxvb3BbaV0gPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggcGFzcyApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQucHVzaCggaXRlbSApO1xuXHRcdFx0XHRcdFx0XHRcdGFueUZvdW5kID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZm91bmQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRpZiAoICFpbnBsYWNlICkge1xuXHRcdFx0XHRcdFx0Y3VyTG9vcCA9IHJlc3VsdDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRleHByID0gZXhwci5yZXBsYWNlKCBFeHByLm1hdGNoWyB0eXBlIF0sIFwiXCIgKTtcblxuXHRcdFx0XHRcdGlmICggIWFueUZvdW5kICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSW1wcm9wZXIgZXhwcmVzc2lvblxuXHRcdGlmICggZXhwciA9PT0gb2xkICkge1xuXHRcdFx0aWYgKCBhbnlGb3VuZCA9PSBudWxsICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIGV4cHIgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0b2xkID0gZXhwcjtcblx0fVxuXG5cdHJldHVybiBjdXJMb29wO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJlaXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xudmFyIGdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgIHZhciBpLCBub2RlLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZSxcblx0XHRyZXQgPSBcIlwiO1xuXG5cdGlmICggbm9kZVR5cGUgKSB7XG5cdFx0aWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0XHQvLyBVc2UgdGV4dENvbnRlbnQgfHwgaW5uZXJUZXh0IGZvciBlbGVtZW50c1xuXHRcdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIGVsZW0uaW5uZXJUZXh0ID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0Ly8gUmVwbGFjZSBJRSdzIGNhcnJpYWdlIHJldHVybnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJUZXh0LnJlcGxhY2UoIHJSZXR1cm4sICcnICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBUcmF2ZXJzZSBpdCdzIGNoaWxkcmVuXG5cdFx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nKSB7XG5cdFx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHRcdH1cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0Zm9yICggaSA9IDA7IChub2RlID0gZWxlbVtpXSk7IGkrKyApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgIT09IDggKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXQ7XG59O1xuXG52YXIgRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cdG9yZGVyOiBbIFwiSURcIiwgXCJOQU1FXCIsIFwiVEFHXCIgXSxcblxuXHRtYXRjaDoge1xuXHRcdElEOiAvIygoPzpbXFx3XFx1MDBjMC1cXHVGRkZGXFwtXXxcXFxcLikrKS8sXG5cdFx0Q0xBU1M6IC9cXC4oKD86W1xcd1xcdTAwYzAtXFx1RkZGRlxcLV18XFxcXC4pKykvLFxuXHRcdE5BTUU6IC9cXFtuYW1lPVsnXCJdKigoPzpbXFx3XFx1MDBjMC1cXHVGRkZGXFwtXXxcXFxcLikrKVsnXCJdKlxcXS8sXG5cdFx0QVRUUjogL1xcW1xccyooKD86W1xcd1xcdTAwYzAtXFx1RkZGRlxcLV18XFxcXC4pKylcXHMqKD86KFxcUz89KVxccyooPzooWydcIl0pKC4qPylcXDN8KCM/KD86W1xcd1xcdTAwYzAtXFx1RkZGRlxcLV18XFxcXC4pKil8KXwpXFxzKlxcXS8sXG5cdFx0VEFHOiAvXigoPzpbXFx3XFx1MDBjMC1cXHVGRkZGXFwqXFwtXXxcXFxcLikrKS8sXG5cdFx0Q0hJTEQ6IC86KG9ubHl8bnRofGxhc3R8Zmlyc3QpLWNoaWxkKD86XFwoXFxzKihldmVufG9kZHwoPzpbK1xcLV0/XFxkK3woPzpbK1xcLV0/XFxkKik/blxccyooPzpbK1xcLV1cXHMqXFxkKyk/KSlcXHMqXFwpKT8vLFxuXHRcdFBPUzogLzoobnRofGVxfGd0fGx0fGZpcnN0fGxhc3R8ZXZlbnxvZGQpKD86XFwoKFxcZCopXFwpKT8oPz1bXlxcLV18JCkvLFxuXHRcdFBTRVVETzogLzooKD86W1xcd1xcdTAwYzAtXFx1RkZGRlxcLV18XFxcXC4pKykoPzpcXCgoWydcIl0/KSgoPzpcXChbXlxcKV0rXFwpfFteXFwoXFwpXSopKylcXDJcXCkpPy9cblx0fSxcblxuXHRsZWZ0TWF0Y2g6IHt9LFxuXG5cdGF0dHJNYXA6IHtcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCIsXG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCJcblx0fSxcblxuXHRhdHRySGFuZGxlOiB7XG5cdFx0aHJlZjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwiaHJlZlwiICk7XG5cdFx0fSxcblx0XHR0eXBlOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIitcIjogZnVuY3Rpb24oY2hlY2tTZXQsIHBhcnQpe1xuXHRcdFx0dmFyIGlzUGFydFN0ciA9IHR5cGVvZiBwYXJ0ID09PSBcInN0cmluZ1wiLFxuXHRcdFx0XHRpc1RhZyA9IGlzUGFydFN0ciAmJiAhck5vbldvcmQudGVzdCggcGFydCApLFxuXHRcdFx0XHRpc1BhcnRTdHJOb3RUYWcgPSBpc1BhcnRTdHIgJiYgIWlzVGFnO1xuXG5cdFx0XHRpZiAoIGlzVGFnICkge1xuXHRcdFx0XHRwYXJ0ID0gcGFydC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGVja1NldC5sZW5ndGgsIGVsZW07IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSBjaGVja1NldFtpXSkgKSB7XG5cdFx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW0ucHJldmlvdXNTaWJsaW5nKSAmJiBlbGVtLm5vZGVUeXBlICE9PSAxICkge31cblxuXHRcdFx0XHRcdGNoZWNrU2V0W2ldID0gaXNQYXJ0U3RyTm90VGFnIHx8IGVsZW0gJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBwYXJ0ID9cblx0XHRcdFx0XHRcdGVsZW0gfHwgZmFsc2UgOlxuXHRcdFx0XHRcdFx0ZWxlbSA9PT0gcGFydDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzUGFydFN0ck5vdFRhZyApIHtcblx0XHRcdFx0U2l6emxlLmZpbHRlciggcGFydCwgY2hlY2tTZXQsIHRydWUgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0XCI+XCI6IGZ1bmN0aW9uKCBjaGVja1NldCwgcGFydCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRpc1BhcnRTdHIgPSB0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIixcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSBjaGVja1NldC5sZW5ndGg7XG5cblx0XHRcdGlmICggaXNQYXJ0U3RyICYmICFyTm9uV29yZC50ZXN0KCBwYXJ0ICkgKSB7XG5cdFx0XHRcdHBhcnQgPSBwYXJ0LnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGVsZW0gPSBjaGVja1NldFtpXTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdFx0XHRjaGVja1NldFtpXSA9IHBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBwYXJ0ID8gcGFyZW50IDogZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRlbGVtID0gY2hlY2tTZXRbaV07XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRjaGVja1NldFtpXSA9IGlzUGFydFN0ciA/XG5cdFx0XHRcdFx0XHRcdGVsZW0ucGFyZW50Tm9kZSA6XG5cdFx0XHRcdFx0XHRcdGVsZW0ucGFyZW50Tm9kZSA9PT0gcGFydDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGlzUGFydFN0ciApIHtcblx0XHRcdFx0XHRTaXp6bGUuZmlsdGVyKCBwYXJ0LCBjaGVja1NldCwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdFwiXCI6IGZ1bmN0aW9uKGNoZWNrU2V0LCBwYXJ0LCBpc1hNTCl7XG5cdFx0XHR2YXIgbm9kZUNoZWNrLFxuXHRcdFx0XHRkb25lTmFtZSA9IGRvbmUrKyxcblx0XHRcdFx0Y2hlY2tGbiA9IGRpckNoZWNrO1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBwYXJ0ID09PSBcInN0cmluZ1wiICYmICFyTm9uV29yZC50ZXN0KCBwYXJ0ICkgKSB7XG5cdFx0XHRcdHBhcnQgPSBwYXJ0LnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdG5vZGVDaGVjayA9IHBhcnQ7XG5cdFx0XHRcdGNoZWNrRm4gPSBkaXJOb2RlQ2hlY2s7XG5cdFx0XHR9XG5cblx0XHRcdGNoZWNrRm4oIFwicGFyZW50Tm9kZVwiLCBwYXJ0LCBkb25lTmFtZSwgY2hlY2tTZXQsIG5vZGVDaGVjaywgaXNYTUwgKTtcblx0XHR9LFxuXG5cdFx0XCJ+XCI6IGZ1bmN0aW9uKCBjaGVja1NldCwgcGFydCwgaXNYTUwgKSB7XG5cdFx0XHR2YXIgbm9kZUNoZWNrLFxuXHRcdFx0XHRkb25lTmFtZSA9IGRvbmUrKyxcblx0XHRcdFx0Y2hlY2tGbiA9IGRpckNoZWNrO1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBwYXJ0ID09PSBcInN0cmluZ1wiICYmICFyTm9uV29yZC50ZXN0KCBwYXJ0ICkgKSB7XG5cdFx0XHRcdHBhcnQgPSBwYXJ0LnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdG5vZGVDaGVjayA9IHBhcnQ7XG5cdFx0XHRcdGNoZWNrRm4gPSBkaXJOb2RlQ2hlY2s7XG5cdFx0XHR9XG5cblx0XHRcdGNoZWNrRm4oIFwicHJldmlvdXNTaWJsaW5nXCIsIHBhcnQsIGRvbmVOYW1lLCBjaGVja1NldCwgbm9kZUNoZWNrLCBpc1hNTCApO1xuXHRcdH1cblx0fSxcblxuXHRmaW5kOiB7XG5cdFx0SUQ6IGZ1bmN0aW9uKCBtYXRjaCwgY29udGV4dCwgaXNYTUwgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmICFpc1hNTCApIHtcblx0XHRcdFx0dmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKG1hdGNoWzFdKTtcblx0XHRcdFx0Ly8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcblx0XHRcdFx0Ly8gbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAjNjk2M1xuXHRcdFx0XHRyZXR1cm4gbSAmJiBtLnBhcmVudE5vZGUgPyBbbV0gOiBbXTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0TkFNRTogZnVuY3Rpb24oIG1hdGNoLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0dmFyIHJldCA9IFtdLFxuXHRcdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBtYXRjaFsxXSApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHJlc3VsdHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggcmVzdWx0c1tpXS5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpID09PSBtYXRjaFsxXSApIHtcblx0XHRcdFx0XHRcdHJldC5wdXNoKCByZXN1bHRzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBudWxsIDogcmV0O1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRUQUc6IGZ1bmN0aW9uKCBtYXRjaCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBtYXRjaFsxXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0cHJlRmlsdGVyOiB7XG5cdFx0Q0xBU1M6IGZ1bmN0aW9uKCBtYXRjaCwgY3VyTG9vcCwgaW5wbGFjZSwgcmVzdWx0LCBub3QsIGlzWE1MICkge1xuXHRcdFx0bWF0Y2ggPSBcIiBcIiArIG1hdGNoWzFdLnJlcGxhY2UoIHJCYWNrc2xhc2gsIFwiXCIgKSArIFwiIFwiO1xuXG5cdFx0XHRpZiAoIGlzWE1MICkge1xuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgZWxlbTsgKGVsZW0gPSBjdXJMb29wW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0XHRpZiAoIG5vdCBeIChlbGVtLmNsYXNzTmFtZSAmJiAoXCIgXCIgKyBlbGVtLmNsYXNzTmFtZSArIFwiIFwiKS5yZXBsYWNlKC9bXFx0XFxuXFxyXS9nLCBcIiBcIikuaW5kZXhPZihtYXRjaCkgPj0gMCkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFpbnBsYWNlICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggaW5wbGFjZSApIHtcblx0XHRcdFx0XHRcdGN1ckxvb3BbaV0gPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cblx0XHRJRDogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0cmV0dXJuIG1hdGNoWzFdLnJlcGxhY2UoIHJCYWNrc2xhc2gsIFwiXCIgKTtcblx0XHR9LFxuXG5cdFx0VEFHOiBmdW5jdGlvbiggbWF0Y2gsIGN1ckxvb3AgKSB7XG5cdFx0XHRyZXR1cm4gbWF0Y2hbMV0ucmVwbGFjZSggckJhY2tzbGFzaCwgXCJcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0fSxcblxuXHRcdENISUxEOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRpZiAoIG1hdGNoWzFdID09PSBcIm50aFwiICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzJdLnJlcGxhY2UoL15cXCt8XFxzKi9nLCAnJyk7XG5cblx0XHRcdFx0Ly8gcGFyc2UgZXF1YXRpb25zIGxpa2UgJ2V2ZW4nLCAnb2RkJywgJzUnLCAnMm4nLCAnM24rMicsICc0bi0xJywgJy1uKzYnXG5cdFx0XHRcdHZhciB0ZXN0ID0gLygtPykoXFxkKikoPzpuKFsrXFwtXT9cXGQqKSk/Ly5leGVjKFxuXHRcdFx0XHRcdG1hdGNoWzJdID09PSBcImV2ZW5cIiAmJiBcIjJuXCIgfHwgbWF0Y2hbMl0gPT09IFwib2RkXCIgJiYgXCIybisxXCIgfHxcblx0XHRcdFx0XHQhL1xcRC8udGVzdCggbWF0Y2hbMl0gKSAmJiBcIjBuK1wiICsgbWF0Y2hbMl0gfHwgbWF0Y2hbMl0pO1xuXG5cdFx0XHRcdC8vIGNhbGN1bGF0ZSB0aGUgbnVtYmVycyAoZmlyc3QpbisobGFzdCkgaW5jbHVkaW5nIGlmIHRoZXkgYXJlIG5lZ2F0aXZlXG5cdFx0XHRcdG1hdGNoWzJdID0gKHRlc3RbMV0gKyAodGVzdFsyXSB8fCAxKSkgLSAwO1xuXHRcdFx0XHRtYXRjaFszXSA9IHRlc3RbM10gLSAwO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRPRE86IE1vdmUgdG8gbm9ybWFsIGNhY2hpbmcgc3lzdGVtXG5cdFx0XHRtYXRjaFswXSA9IGRvbmUrKztcblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRBVFRSOiBmdW5jdGlvbiggbWF0Y2gsIGN1ckxvb3AsIGlucGxhY2UsIHJlc3VsdCwgbm90LCBpc1hNTCApIHtcblx0XHRcdHZhciBuYW1lID0gbWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCByQmFja3NsYXNoLCBcIlwiICk7XG5cblx0XHRcdGlmICggIWlzWE1MICYmIEV4cHIuYXR0ck1hcFtuYW1lXSApIHtcblx0XHRcdFx0bWF0Y2hbMV0gPSBFeHByLmF0dHJNYXBbbmFtZV07XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSBpZiBhbiB1bi1xdW90ZWQgdmFsdWUgd2FzIHVzZWRcblx0XHRcdG1hdGNoWzRdID0gKCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggckJhY2tzbGFzaCwgXCJcIiApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzRdID0gXCIgXCIgKyBtYXRjaFs0XSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFBTRVVETzogZnVuY3Rpb24oIG1hdGNoLCBjdXJMb29wLCBpbnBsYWNlLCByZXN1bHQsIG5vdCApIHtcblx0XHRcdGlmICggbWF0Y2hbMV0gPT09IFwibm90XCIgKSB7XG5cdFx0XHRcdC8vIElmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGNvbXBsZXggZXhwcmVzc2lvbiwgb3IgYSBzaW1wbGUgb25lXG5cdFx0XHRcdGlmICggKCBjaHVua2VyLmV4ZWMobWF0Y2hbM10pIHx8IFwiXCIgKS5sZW5ndGggPiAxIHx8IC9eXFx3Ly50ZXN0KG1hdGNoWzNdKSApIHtcblx0XHRcdFx0XHRtYXRjaFszXSA9IFNpenpsZShtYXRjaFszXSwgbnVsbCwgbnVsbCwgY3VyTG9vcCk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgcmV0ID0gU2l6emxlLmZpbHRlcihtYXRjaFszXSwgY3VyTG9vcCwgaW5wbGFjZSwgdHJ1ZSBeIG5vdCk7XG5cblx0XHRcdFx0XHRpZiAoICFpbnBsYWNlICkge1xuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2guYXBwbHkoIHJlc3VsdCwgcmV0ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIEV4cHIubWF0Y2guUE9TLnRlc3QoIG1hdGNoWzBdICkgfHwgRXhwci5tYXRjaC5DSElMRC50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRQT1M6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoLnVuc2hpZnQoIHRydWUgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXJzOiB7XG5cdFx0ZW5hYmxlZDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgJiYgZWxlbS50eXBlICE9PSBcImhpZGRlblwiO1xuXHRcdH0sXG5cblx0XHRkaXNhYmxlZDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Y2hlY2tlZDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5jaGVja2VkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHRzZWxlY3RlZDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICEhZWxlbS5maXJzdENoaWxkO1xuXHRcdH0sXG5cblx0XHRlbXB0eTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIWVsZW0uZmlyc3RDaGlsZDtcblx0XHR9LFxuXG5cdFx0aGFzOiBmdW5jdGlvbiggZWxlbSwgaSwgbWF0Y2ggKSB7XG5cdFx0XHRyZXR1cm4gISFTaXp6bGUoIG1hdGNoWzNdLCBlbGVtICkubGVuZ3RoO1xuXHRcdH0sXG5cblx0XHRoZWFkZXI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICgvaFxcZC9pKS50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdHRleHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSwgdHlwZSA9IGVsZW0udHlwZTtcblx0XHRcdC8vIElFNiBhbmQgNyB3aWxsIG1hcCBlbGVtLnR5cGUgdG8gJ3RleHQnIGZvciBuZXcgSFRNTDUgdHlwZXMgKHNlYXJjaCwgZXRjKVxuXHRcdFx0Ly8gdXNlIGdldEF0dHJpYnV0ZSBpbnN0ZWFkIHRvIHRlc3QgdGhpcyBjYXNlXG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiYgXCJ0ZXh0XCIgPT09IHR5cGUgJiYgKCBhdHRyID09PSB0eXBlIHx8IGF0dHIgPT09IG51bGwgKTtcblx0XHR9LFxuXG5cdFx0cmFkaW86IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmIFwicmFkaW9cIiA9PT0gZWxlbS50eXBlO1xuXHRcdH0sXG5cblx0XHRjaGVja2JveDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiYgXCJjaGVja2JveFwiID09PSBlbGVtLnR5cGU7XG5cdFx0fSxcblxuXHRcdGZpbGU6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmIFwiZmlsZVwiID09PSBlbGVtLnR5cGU7XG5cdFx0fSxcblxuXHRcdHBhc3N3b3JkOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJiBcInBhc3N3b3JkXCIgPT09IGVsZW0udHlwZTtcblx0XHR9LFxuXG5cdFx0c3VibWl0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgXCJzdWJtaXRcIiA9PT0gZWxlbS50eXBlO1xuXHRcdH0sXG5cblx0XHRpbWFnZTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiYgXCJpbWFnZVwiID09PSBlbGVtLnR5cGU7XG5cdFx0fSxcblxuXHRcdHJlc2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgXCJyZXNldFwiID09PSBlbGVtLnR5cGU7XG5cdFx0fSxcblxuXHRcdGJ1dHRvbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgXCJidXR0b25cIiA9PT0gZWxlbS50eXBlIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdGlucHV0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoL2lucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24vaSkudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRmb2N1czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZWxlbS5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdFx0fVxuXHR9LFxuXHRzZXRGaWx0ZXJzOiB7XG5cdFx0Zmlyc3Q6IGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGkgPT09IDA7XG5cdFx0fSxcblxuXHRcdGxhc3Q6IGZ1bmN0aW9uKCBlbGVtLCBpLCBtYXRjaCwgYXJyYXkgKSB7XG5cdFx0XHRyZXR1cm4gaSA9PT0gYXJyYXkubGVuZ3RoIC0gMTtcblx0XHR9LFxuXG5cdFx0ZXZlbjogZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gaSAlIDIgPT09IDA7XG5cdFx0fSxcblxuXHRcdG9kZDogZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gaSAlIDIgPT09IDE7XG5cdFx0fSxcblxuXHRcdGx0OiBmdW5jdGlvbiggZWxlbSwgaSwgbWF0Y2ggKSB7XG5cdFx0XHRyZXR1cm4gaSA8IG1hdGNoWzNdIC0gMDtcblx0XHR9LFxuXG5cdFx0Z3Q6IGZ1bmN0aW9uKCBlbGVtLCBpLCBtYXRjaCApIHtcblx0XHRcdHJldHVybiBpID4gbWF0Y2hbM10gLSAwO1xuXHRcdH0sXG5cblx0XHRudGg6IGZ1bmN0aW9uKCBlbGVtLCBpLCBtYXRjaCApIHtcblx0XHRcdHJldHVybiBtYXRjaFszXSAtIDAgPT09IGk7XG5cdFx0fSxcblxuXHRcdGVxOiBmdW5jdGlvbiggZWxlbSwgaSwgbWF0Y2ggKSB7XG5cdFx0XHRyZXR1cm4gbWF0Y2hbM10gLSAwID09PSBpO1xuXHRcdH1cblx0fSxcblx0ZmlsdGVyOiB7XG5cdFx0UFNFVURPOiBmdW5jdGlvbiggZWxlbSwgbWF0Y2gsIGksIGFycmF5ICkge1xuXHRcdFx0dmFyIG5hbWUgPSBtYXRjaFsxXSxcblx0XHRcdFx0ZmlsdGVyID0gRXhwci5maWx0ZXJzWyBuYW1lIF07XG5cblx0XHRcdGlmICggZmlsdGVyICkge1xuXHRcdFx0XHRyZXR1cm4gZmlsdGVyKCBlbGVtLCBpLCBtYXRjaCwgYXJyYXkgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbmFtZSA9PT0gXCJjb250YWluc1wiICkge1xuXHRcdFx0XHRyZXR1cm4gKGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dChbIGVsZW0gXSkgfHwgXCJcIikuaW5kZXhPZihtYXRjaFszXSkgPj0gMDtcblxuXHRcdFx0fSBlbHNlIGlmICggbmFtZSA9PT0gXCJub3RcIiApIHtcblx0XHRcdFx0dmFyIG5vdCA9IG1hdGNoWzNdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMCwgbCA9IG5vdC5sZW5ndGg7IGogPCBsOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBub3Rbal0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRDSElMRDogZnVuY3Rpb24oIGVsZW0sIG1hdGNoICkge1xuXHRcdFx0dmFyIGZpcnN0LCBsYXN0LFxuXHRcdFx0XHRkb25lTmFtZSwgcGFyZW50LCBjYWNoZSxcblx0XHRcdFx0Y291bnQsIGRpZmYsXG5cdFx0XHRcdHR5cGUgPSBtYXRjaFsxXSxcblx0XHRcdFx0bm9kZSA9IGVsZW07XG5cblx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cdFx0XHRcdGNhc2UgXCJvbmx5XCI6XG5cdFx0XHRcdGNhc2UgXCJmaXJzdFwiOlxuXHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZykgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZmlyc3RcIiApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXG5cdFx0XHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdFx0XHRjYXNlIFwibGFzdFwiOlxuXHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdGNhc2UgXCJudGhcIjpcblx0XHRcdFx0XHRmaXJzdCA9IG1hdGNoWzJdO1xuXHRcdFx0XHRcdGxhc3QgPSBtYXRjaFszXTtcblxuXHRcdFx0XHRcdGlmICggZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGRvbmVOYW1lID0gbWF0Y2hbMF07XG5cdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgJiYgKHBhcmVudFsgZXhwYW5kbyBdICE9PSBkb25lTmFtZSB8fCAhZWxlbS5ub2RlSW5kZXgpICkge1xuXHRcdFx0XHRcdFx0Y291bnQgPSAwO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBub2RlID0gcGFyZW50LmZpcnN0Q2hpbGQ7IG5vZGU7IG5vZGUgPSBub2RlLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlSW5kZXggPSArK2NvdW50O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHBhcmVudFsgZXhwYW5kbyBdID0gZG9uZU5hbWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZGlmZiA9IGVsZW0ubm9kZUluZGV4IC0gbGFzdDtcblxuXHRcdFx0XHRcdGlmICggZmlyc3QgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gMDtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdElEOiBmdW5jdGlvbiggZWxlbSwgbWF0Y2ggKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBtYXRjaDtcblx0XHR9LFxuXG5cdFx0VEFHOiBmdW5jdGlvbiggZWxlbSwgbWF0Y2ggKSB7XG5cdFx0XHRyZXR1cm4gKG1hdGNoID09PSBcIipcIiAmJiBlbGVtLm5vZGVUeXBlID09PSAxKSB8fCAhIWVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBtYXRjaDtcblx0XHR9LFxuXG5cdFx0Q0xBU1M6IGZ1bmN0aW9uKCBlbGVtLCBtYXRjaCApIHtcblx0XHRcdHJldHVybiAoXCIgXCIgKyAoZWxlbS5jbGFzc05hbWUgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSkgKyBcIiBcIilcblx0XHRcdFx0LmluZGV4T2YoIG1hdGNoICkgPiAtMTtcblx0XHR9LFxuXG5cdFx0QVRUUjogZnVuY3Rpb24oIGVsZW0sIG1hdGNoICkge1xuXHRcdFx0dmFyIG5hbWUgPSBtYXRjaFsxXSxcblx0XHRcdFx0cmVzdWx0ID0gU2l6emxlLmF0dHIgP1xuXHRcdFx0XHRcdFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICkgOlxuXHRcdFx0XHRcdEV4cHIuYXR0ckhhbmRsZVsgbmFtZSBdID9cblx0XHRcdFx0XHRFeHByLmF0dHJIYW5kbGVbIG5hbWUgXSggZWxlbSApIDpcblx0XHRcdFx0XHRlbGVtWyBuYW1lIF0gIT0gbnVsbCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSxcblx0XHRcdFx0dmFsdWUgPSByZXN1bHQgKyBcIlwiLFxuXHRcdFx0XHR0eXBlID0gbWF0Y2hbMl0sXG5cdFx0XHRcdGNoZWNrID0gbWF0Y2hbNF07XG5cblx0XHRcdHJldHVybiByZXN1bHQgPT0gbnVsbCA/XG5cdFx0XHRcdHR5cGUgPT09IFwiIT1cIiA6XG5cdFx0XHRcdCF0eXBlICYmIFNpenpsZS5hdHRyID9cblx0XHRcdFx0cmVzdWx0ICE9IG51bGwgOlxuXHRcdFx0XHR0eXBlID09PSBcIj1cIiA/XG5cdFx0XHRcdHZhbHVlID09PSBjaGVjayA6XG5cdFx0XHRcdHR5cGUgPT09IFwiKj1cIiA/XG5cdFx0XHRcdHZhbHVlLmluZGV4T2YoY2hlY2spID49IDAgOlxuXHRcdFx0XHR0eXBlID09PSBcIn49XCIgP1xuXHRcdFx0XHQoXCIgXCIgKyB2YWx1ZSArIFwiIFwiKS5pbmRleE9mKGNoZWNrKSA+PSAwIDpcblx0XHRcdFx0IWNoZWNrID9cblx0XHRcdFx0dmFsdWUgJiYgcmVzdWx0ICE9PSBmYWxzZSA6XG5cdFx0XHRcdHR5cGUgPT09IFwiIT1cIiA/XG5cdFx0XHRcdHZhbHVlICE9PSBjaGVjayA6XG5cdFx0XHRcdHR5cGUgPT09IFwiXj1cIiA/XG5cdFx0XHRcdHZhbHVlLmluZGV4T2YoY2hlY2spID09PSAwIDpcblx0XHRcdFx0dHlwZSA9PT0gXCIkPVwiID9cblx0XHRcdFx0dmFsdWUuc3Vic3RyKHZhbHVlLmxlbmd0aCAtIGNoZWNrLmxlbmd0aCkgPT09IGNoZWNrIDpcblx0XHRcdFx0dHlwZSA9PT0gXCJ8PVwiID9cblx0XHRcdFx0dmFsdWUgPT09IGNoZWNrIHx8IHZhbHVlLnN1YnN0cigwLCBjaGVjay5sZW5ndGggKyAxKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdGZhbHNlO1xuXHRcdH0sXG5cblx0XHRQT1M6IGZ1bmN0aW9uKCBlbGVtLCBtYXRjaCwgaSwgYXJyYXkgKSB7XG5cdFx0XHR2YXIgbmFtZSA9IG1hdGNoWzJdLFxuXHRcdFx0XHRmaWx0ZXIgPSBFeHByLnNldEZpbHRlcnNbIG5hbWUgXTtcblxuXHRcdFx0aWYgKCBmaWx0ZXIgKSB7XG5cdFx0XHRcdHJldHVybiBmaWx0ZXIoIGVsZW0sIGksIG1hdGNoLCBhcnJheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxudmFyIG9yaWdQT1MgPSBFeHByLm1hdGNoLlBPUyxcblx0ZmVzY2FwZSA9IGZ1bmN0aW9uKGFsbCwgbnVtKXtcblx0XHRyZXR1cm4gXCJcXFxcXCIgKyAobnVtIC0gMCArIDEpO1xuXHR9O1xuXG5mb3IgKCB2YXIgdHlwZSBpbiBFeHByLm1hdGNoICkge1xuXHRFeHByLm1hdGNoWyB0eXBlIF0gPSBuZXcgUmVnRXhwKCBFeHByLm1hdGNoWyB0eXBlIF0uc291cmNlICsgKC8oPyFbXlxcW10qXFxdKSg/IVteXFwoXSpcXCkpLy5zb3VyY2UpICk7XG5cdEV4cHIubGVmdE1hdGNoWyB0eXBlIF0gPSBuZXcgUmVnRXhwKCAvKF4oPzoufFxccnxcXG4pKj8pLy5zb3VyY2UgKyBFeHByLm1hdGNoWyB0eXBlIF0uc291cmNlLnJlcGxhY2UoL1xcXFwoXFxkKykvZywgZmVzY2FwZSkgKTtcbn1cbi8vIEV4cG9zZSBvcmlnUE9TXG4vLyBcImdsb2JhbFwiIGFzIGluIHJlZ2FyZGxlc3Mgb2YgcmVsYXRpb24gdG8gYnJhY2tldHMvcGFyZW5zXG5FeHByLm1hdGNoLmdsb2JhbFBPUyA9IG9yaWdQT1M7XG5cbnZhciBtYWtlQXJyYXkgPSBmdW5jdGlvbiggYXJyYXksIHJlc3VsdHMgKSB7XG5cdGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFycmF5LCAwICk7XG5cblx0aWYgKCByZXN1bHRzICkge1xuXHRcdHJlc3VsdHMucHVzaC5hcHBseSggcmVzdWx0cywgYXJyYXkgKTtcblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdHJldHVybiBhcnJheTtcbn07XG5cbi8vIFBlcmZvcm0gYSBzaW1wbGUgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRoZSBicm93c2VyIGlzIGNhcGFibGUgb2Zcbi8vIGNvbnZlcnRpbmcgYSBOb2RlTGlzdCB0byBhbiBhcnJheSB1c2luZyBidWlsdGluIG1ldGhvZHMuXG4vLyBBbHNvIHZlcmlmaWVzIHRoYXQgdGhlIHJldHVybmVkIGFycmF5IGhvbGRzIERPTSBub2Rlc1xuLy8gKHdoaWNoIGlzIG5vdCB0aGUgY2FzZSBpbiB0aGUgQmxhY2tiZXJyeSBicm93c2VyKVxudHJ5IHtcblx0QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jaGlsZE5vZGVzLCAwIClbMF0ubm9kZVR5cGU7XG5cbi8vIFByb3ZpZGUgYSBmYWxsYmFjayBtZXRob2QgaWYgaXQgZG9lcyBub3Qgd29ya1xufSBjYXRjaCggZSApIHtcblx0bWFrZUFycmF5ID0gZnVuY3Rpb24oIGFycmF5LCByZXN1bHRzICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIHRvU3RyaW5nLmNhbGwoYXJyYXkpID09PSBcIltvYmplY3QgQXJyYXldXCIgKSB7XG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggcmV0LCBhcnJheSApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggdHlwZW9mIGFycmF5Lmxlbmd0aCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0Zm9yICggdmFyIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIGFycmF5W2ldICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggOyBhcnJheVtpXTsgaSsrICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCBhcnJheVtpXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn1cblxudmFyIHNvcnRPcmRlciwgc2libGluZ0NoZWNrO1xuXG5pZiAoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApIHtcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdGlmICggIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gfHwgIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb24gKSB7XG5cdFx0XHRyZXR1cm4gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA/IC0xIDogMTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSAmIDQgPyAtMSA6IDE7XG5cdH07XG5cbn0gZWxzZSB7XG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIFRoZSBub2RlcyBhcmUgaWRlbnRpY2FsLCB3ZSBjYW4gZXhpdCBlYXJseVxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblxuXHRcdC8vIEZhbGxiYWNrIHRvIHVzaW5nIHNvdXJjZUluZGV4IChpbiBJRSkgaWYgaXQncyBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRcdH0gZWxzZSBpZiAoIGEuc291cmNlSW5kZXggJiYgYi5zb3VyY2VJbmRleCApIHtcblx0XHRcdHJldHVybiBhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblx0XHR9XG5cblx0XHR2YXIgYWwsIGJsLFxuXHRcdFx0YXAgPSBbXSxcblx0XHRcdGJwID0gW10sXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRjdXIgPSBhdXA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzIChvciBpZGVudGljYWwpIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0aWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblxuXHRcdC8vIElmIG5vIHBhcmVudHMgd2VyZSBmb3VuZCB0aGVuIHRoZSBub2RlcyBhcmUgZGlzY29ubmVjdGVkXG5cdFx0fSBlbHNlIGlmICggIWF1cCApIHtcblx0XHRcdHJldHVybiAtMTtcblxuXHRcdH0gZWxzZSBpZiAoICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UgdGhleSdyZSBzb21ld2hlcmUgZWxzZSBpbiB0aGUgdHJlZSBzbyB3ZSBuZWVkXG5cdFx0Ly8gdG8gYnVpbGQgdXAgYSBmdWxsIGxpc3Qgb2YgdGhlIHBhcmVudE5vZGVzIGZvciBjb21wYXJpc29uXG5cdFx0d2hpbGUgKCBjdXIgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdGN1ciA9IGJ1cDtcblxuXHRcdHdoaWxlICggY3VyICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHR9XG5cblx0XHRhbCA9IGFwLmxlbmd0aDtcblx0XHRibCA9IGJwLmxlbmd0aDtcblxuXHRcdC8vIFN0YXJ0IHdhbGtpbmcgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYWwgJiYgaSA8IGJsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFwW2ldICE9PSBicFtpXSApIHtcblx0XHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gV2UgZW5kZWQgc29tZXBsYWNlIHVwIHRoZSB0cmVlIHNvIGRvIGEgc2libGluZyBjaGVja1xuXHRcdHJldHVybiBpID09PSBhbCA/XG5cdFx0XHRzaWJsaW5nQ2hlY2soIGEsIGJwW2ldLCAtMSApIDpcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGIsIDEgKTtcblx0fTtcblxuXHRzaWJsaW5nQ2hlY2sgPSBmdW5jdGlvbiggYSwgYiwgcmV0ICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0dmFyIGN1ciA9IGEubmV4dFNpYmxpbmc7XG5cblx0XHR3aGlsZSAoIGN1ciApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cblx0XHRcdGN1ciA9IGN1ci5uZXh0U2libGluZztcblx0XHR9XG5cblx0XHRyZXR1cm4gMTtcblx0fTtcbn1cblxuLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBicm93c2VyIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZSB3aGVuXG4vLyBxdWVyeWluZyBieSBnZXRFbGVtZW50QnlJZCAoYW5kIHByb3ZpZGUgYSB3b3JrYXJvdW5kKVxuKGZ1bmN0aW9uKCl7XG5cdC8vIFdlJ3JlIGdvaW5nIHRvIGluamVjdCBhIGZha2UgaW5wdXQgZWxlbWVudCB3aXRoIGEgc3BlY2lmaWVkIG5hbWVcblx0dmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuXHRcdGlkID0gXCJzY3JpcHRcIiArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCksXG5cdFx0cm9vdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXHRmb3JtLmlubmVySFRNTCA9IFwiPGEgbmFtZT0nXCIgKyBpZCArIFwiJy8+XCI7XG5cblx0Ly8gSW5qZWN0IGl0IGludG8gdGhlIHJvb3QgZWxlbWVudCwgY2hlY2sgaXRzIHN0YXR1cywgYW5kIHJlbW92ZSBpdCBxdWlja2x5XG5cdHJvb3QuaW5zZXJ0QmVmb3JlKCBmb3JtLCByb290LmZpcnN0Q2hpbGQgKTtcblxuXHQvLyBUaGUgd29ya2Fyb3VuZCBoYXMgdG8gZG8gYWRkaXRpb25hbCBjaGVja3MgYWZ0ZXIgYSBnZXRFbGVtZW50QnlJZFxuXHQvLyBXaGljaCBzbG93cyB0aGluZ3MgZG93biBmb3Igb3RoZXIgYnJvd3NlcnMgKGhlbmNlIHRoZSBicmFuY2hpbmcpXG5cdGlmICggZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIGlkICkgKSB7XG5cdFx0RXhwci5maW5kLklEID0gZnVuY3Rpb24oIG1hdGNoLCBjb250ZXh0LCBpc1hNTCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgIWlzWE1MICkge1xuXHRcdFx0XHR2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQobWF0Y2hbMV0pO1xuXG5cdFx0XHRcdHJldHVybiBtID9cblx0XHRcdFx0XHRtLmlkID09PSBtYXRjaFsxXSB8fCB0eXBlb2YgbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmIG0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpLm5vZGVWYWx1ZSA9PT0gbWF0Y2hbMV0gP1xuXHRcdFx0XHRcdFx0W21dIDpcblx0XHRcdFx0XHRcdHVuZGVmaW5lZCA6XG5cdFx0XHRcdFx0W107XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdEV4cHIuZmlsdGVyLklEID0gZnVuY3Rpb24oIGVsZW0sIG1hdGNoICkge1xuXHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiBub2RlICYmIG5vZGUubm9kZVZhbHVlID09PSBtYXRjaDtcblx0XHR9O1xuXHR9XG5cblx0cm9vdC5yZW1vdmVDaGlsZCggZm9ybSApO1xuXG5cdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdHJvb3QgPSBmb3JtID0gbnVsbDtcbn0pKCk7XG5cbihmdW5jdGlvbigpe1xuXHQvLyBDaGVjayB0byBzZWUgaWYgdGhlIGJyb3dzZXIgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdC8vIHdoZW4gZG9pbmcgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpXG5cblx0Ly8gQ3JlYXRlIGEgZmFrZSBlbGVtZW50XG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblxuXHQvLyBNYWtlIHN1cmUgbm8gY29tbWVudHMgYXJlIGZvdW5kXG5cdGlmICggZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGggPiAwICkge1xuXHRcdEV4cHIuZmluZC5UQUcgPSBmdW5jdGlvbiggbWF0Y2gsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgcmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIG1hdGNoWzFdICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggbWF0Y2hbMV0gPT09IFwiKlwiICkge1xuXHRcdFx0XHR2YXIgdG1wID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyByZXN1bHRzW2ldOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCByZXN1bHRzW2ldLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIHJlc3VsdHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHRzID0gdG1wO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGFuIGF0dHJpYnV0ZSByZXR1cm5zIG5vcm1hbGl6ZWQgaHJlZiBhdHRyaWJ1dGVzXG5cdGRpdi5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblxuXHRpZiAoIGRpdi5maXJzdENoaWxkICYmIHR5cGVvZiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgIT09IFwiI1wiICkge1xuXG5cdFx0RXhwci5hdHRySGFuZGxlLmhyZWYgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJocmVmXCIsIDIgKTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0ZGl2ID0gbnVsbDtcbn0pKCk7XG5cbmlmICggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApIHtcblx0KGZ1bmN0aW9uKCl7XG5cdFx0dmFyIG9sZFNpenpsZSA9IFNpenpsZSxcblx0XHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG5cdFx0XHRpZCA9IFwiX19zaXp6bGVfX1wiO1xuXG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiPHAgY2xhc3M9J1RFU1QnPjwvcD5cIjtcblxuXHRcdC8vIFNhZmFyaSBjYW4ndCBoYW5kbGUgdXBwZXJjYXNlIG9yIHVuaWNvZGUgY2hhcmFjdGVycyB3aGVuXG5cdFx0Ly8gaW4gcXVpcmtzIG1vZGUuXG5cdFx0aWYgKCBkaXYucXVlcnlTZWxlY3RvckFsbCAmJiBkaXYucXVlcnlTZWxlY3RvckFsbChcIi5URVNUXCIpLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRTaXp6bGUgPSBmdW5jdGlvbiggcXVlcnksIGNvbnRleHQsIGV4dHJhLCBzZWVkICkge1xuXHRcdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRcdC8vIE9ubHkgdXNlIHF1ZXJ5U2VsZWN0b3JBbGwgb24gbm9uLVhNTCBkb2N1bWVudHNcblx0XHRcdC8vIChJRCBzZWxlY3RvcnMgZG9uJ3Qgd29yayBpbiBub24tSFRNTCBkb2N1bWVudHMpXG5cdFx0XHRpZiAoICFzZWVkICYmICFTaXp6bGUuaXNYTUwoY29udGV4dCkgKSB7XG5cdFx0XHRcdC8vIFNlZSBpZiB3ZSBmaW5kIGEgc2VsZWN0b3IgdG8gc3BlZWQgdXBcblx0XHRcdFx0dmFyIG1hdGNoID0gL14oXFx3KyQpfF5cXC4oW1xcd1xcLV0rJCl8XiMoW1xcd1xcLV0rJCkvLmV4ZWMoIHF1ZXJ5ICk7XG5cblx0XHRcdFx0aWYgKCBtYXRjaCAmJiAoY29udGV4dC5ub2RlVHlwZSA9PT0gMSB8fCBjb250ZXh0Lm5vZGVUeXBlID09PSA5KSApIHtcblx0XHRcdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiVEFHXCIpXG5cdFx0XHRcdFx0aWYgKCBtYXRjaFsxXSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBtYWtlQXJyYXkoIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHF1ZXJ5ICksIGV4dHJhICk7XG5cblx0XHRcdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiLkNMQVNTXCIpXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gJiYgRXhwci5maW5kLkNMQVNTICYmIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBtYWtlQXJyYXkoIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbWF0Y2hbMl0gKSwgZXh0cmEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGNvbnRleHQubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0Ly8gU3BlZWQtdXA6IFNpenpsZShcImJvZHlcIilcblx0XHRcdFx0XHQvLyBUaGUgYm9keSBlbGVtZW50IG9ubHkgZXhpc3RzIG9uY2UsIG9wdGltaXplIGZpbmRpbmcgaXRcblx0XHRcdFx0XHRpZiAoIHF1ZXJ5ID09PSBcImJvZHlcIiAmJiBjb250ZXh0LmJvZHkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbWFrZUFycmF5KCBbIGNvbnRleHQuYm9keSBdLCBleHRyYSApO1xuXG5cdFx0XHRcdFx0Ly8gU3BlZWQtdXA6IFNpenpsZShcIiNJRFwiKVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoICYmIG1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtYXRjaFszXSApO1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xuXHRcdFx0XHRcdFx0Ly8gbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAjNjk2M1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIElFIGFuZCBPcGVyYSByZXR1cm4gaXRlbXNcblx0XHRcdFx0XHRcdFx0Ly8gYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIG1ha2VBcnJheSggWyBlbGVtIF0sIGV4dHJhICk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG1ha2VBcnJheSggW10sIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHJldHVybiBtYWtlQXJyYXkoIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbChxdWVyeSksIGV4dHJhICk7XG5cdFx0XHRcdFx0fSBjYXRjaChxc2FFcnJvcikge31cblxuXHRcdFx0XHQvLyBxU0Egd29ya3Mgc3RyYW5nZWx5IG9uIEVsZW1lbnQtcm9vdGVkIHF1ZXJpZXNcblx0XHRcdFx0Ly8gV2UgY2FuIHdvcmsgYXJvdW5kIHRoaXMgYnkgc3BlY2lmeWluZyBhbiBleHRyYSBJRCBvbiB0aGUgcm9vdFxuXHRcdFx0XHQvLyBhbmQgd29ya2luZyB1cCBmcm9tIHRoZXJlIChUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhlIHRlY2huaXF1ZSlcblx0XHRcdFx0Ly8gSUUgOCBkb2Vzbid0IHdvcmsgb24gb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZVR5cGUgPT09IDEgJiYgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXHRcdFx0XHRcdHZhciBvbGRDb250ZXh0ID0gY29udGV4dCxcblx0XHRcdFx0XHRcdG9sZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSxcblx0XHRcdFx0XHRcdG5pZCA9IG9sZCB8fCBpZCxcblx0XHRcdFx0XHRcdGhhc1BhcmVudCA9IGNvbnRleHQucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdHJlbGF0aXZlSGllcmFyY2h5U2VsZWN0b3IgPSAvXlxccypbK35dLy50ZXN0KCBxdWVyeSApO1xuXG5cdFx0XHRcdFx0aWYgKCAhb2xkICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgbmlkICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCAvJy9nLCBcIlxcXFwkJlwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggcmVsYXRpdmVIaWVyYXJjaHlTZWxlY3RvciAmJiBoYXNQYXJlbnQgKSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZWxhdGl2ZUhpZXJhcmNoeVNlbGVjdG9yIHx8IGhhc1BhcmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG1ha2VBcnJheSggY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZD0nXCIgKyBuaWQgKyBcIiddIFwiICsgcXVlcnkgKSwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gY2F0Y2gocHNldWRvRXJyb3IpIHtcblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0aWYgKCAhb2xkICkge1xuXHRcdFx0XHRcdFx0XHRvbGRDb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvbGRTaXp6bGUocXVlcnksIGNvbnRleHQsIGV4dHJhLCBzZWVkKTtcblx0XHR9O1xuXG5cdFx0Zm9yICggdmFyIHByb3AgaW4gb2xkU2l6emxlICkge1xuXHRcdFx0U2l6emxlWyBwcm9wIF0gPSBvbGRTaXp6bGVbIHByb3AgXTtcblx0XHR9XG5cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGRpdiA9IG51bGw7XG5cdH0pKCk7XG59XG5cbihmdW5jdGlvbigpe1xuXHR2YXIgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHRtYXRjaGVzID0gaHRtbC5tYXRjaGVzU2VsZWN0b3IgfHwgaHRtbC5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgaHRtbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgaHRtbC5tc01hdGNoZXNTZWxlY3RvcjtcblxuXHRpZiAoIG1hdGNoZXMgKSB7XG5cdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSBmYWlscyB0aGlzKVxuXHRcdHZhciBkaXNjb25uZWN0ZWRNYXRjaCA9ICFtYXRjaGVzLmNhbGwoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSwgXCJkaXZcIiApLFxuXHRcdFx0cHNldWRvV29ya3MgPSBmYWxzZTtcblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgXCJbdGVzdCE9JyddOnNpenpsZVwiICk7XG5cblx0XHR9IGNhdGNoKCBwc2V1ZG9FcnJvciApIHtcblx0XHRcdHBzZXVkb1dvcmtzID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRTaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIG5vZGUsIGV4cHIgKSB7XG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0XHRcdGV4cHIgPSBleHByLnJlcGxhY2UoL1xcPVxccyooW14nXCJcXF1dKilcXHMqXFxdL2csIFwiPSckMSddXCIpO1xuXG5cdFx0XHRpZiAoICFTaXp6bGUuaXNYTUwoIG5vZGUgKSApIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAoIHBzZXVkb1dvcmtzIHx8ICFFeHByLm1hdGNoLlBTRVVETy50ZXN0KCBleHByICkgJiYgIS8hPS8udGVzdCggZXhwciApICkge1xuXHRcdFx0XHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggbm9kZSwgZXhwciApO1xuXG5cdFx0XHRcdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRcdFx0XHRpZiAoIHJldCB8fCAhZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDksIHNvIGNoZWNrIGZvciB0aGF0XG5cdFx0XHRcdFx0XHRcdFx0bm9kZS5kb2N1bWVudCAmJiBub2RlLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2goZSkge31cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIFNpenpsZShleHByLCBudWxsLCBudWxsLCBbbm9kZV0pLmxlbmd0aCA+IDA7XG5cdFx0fTtcblx0fVxufSkoKTtcblxuKGZ1bmN0aW9uKCl7XG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG5cdGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgY2xhc3M9J3Rlc3QgZSc+PC9kaXY+PGRpdiBjbGFzcz0ndGVzdCc+PC9kaXY+XCI7XG5cblx0Ly8gT3BlcmEgY2FuJ3QgZmluZCBhIHNlY29uZCBjbGFzc25hbWUgKGluIDkuNilcblx0Ly8gQWxzbywgbWFrZSBzdXJlIHRoYXQgZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSBhY3R1YWxseSBleGlzdHNcblx0aWYgKCAhZGl2LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgfHwgZGl2LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJlXCIpLmxlbmd0aCA9PT0gMCApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTYWZhcmkgY2FjaGVzIGNsYXNzIGF0dHJpYnV0ZXMsIGRvZXNuJ3QgY2F0Y2ggY2hhbmdlcyAoaW4gMy4yKVxuXHRkaXYubGFzdENoaWxkLmNsYXNzTmFtZSA9IFwiZVwiO1xuXG5cdGlmICggZGl2LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJlXCIpLmxlbmd0aCA9PT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRFeHByLm9yZGVyLnNwbGljZSgxLCAwLCBcIkNMQVNTXCIpO1xuXHRFeHByLmZpbmQuQ0xBU1MgPSBmdW5jdGlvbiggbWF0Y2gsIGNvbnRleHQsIGlzWE1MICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKG1hdGNoWzFdKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0ZGl2ID0gbnVsbDtcbn0pKCk7XG5cbmZ1bmN0aW9uIGRpck5vZGVDaGVjayggZGlyLCBjdXIsIGRvbmVOYW1lLCBjaGVja1NldCwgbm9kZUNoZWNrLCBpc1hNTCApIHtcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hlY2tTZXQubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdHZhciBlbGVtID0gY2hlY2tTZXRbaV07XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR2YXIgbWF0Y2ggPSBmYWxzZTtcblxuXHRcdFx0ZWxlbSA9IGVsZW1bZGlyXTtcblxuXHRcdFx0d2hpbGUgKCBlbGVtICkge1xuXHRcdFx0XHRpZiAoIGVsZW1bIGV4cGFuZG8gXSA9PT0gZG9uZU5hbWUgKSB7XG5cdFx0XHRcdFx0bWF0Y2ggPSBjaGVja1NldFtlbGVtLnNpenNldF07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWlzWE1MICl7XG5cdFx0XHRcdFx0ZWxlbVsgZXhwYW5kbyBdID0gZG9uZU5hbWU7XG5cdFx0XHRcdFx0ZWxlbS5zaXpzZXQgPSBpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGN1ciApIHtcblx0XHRcdFx0XHRtYXRjaCA9IGVsZW07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlbGVtID0gZWxlbVtkaXJdO1xuXHRcdFx0fVxuXG5cdFx0XHRjaGVja1NldFtpXSA9IG1hdGNoO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkaXJDaGVjayggZGlyLCBjdXIsIGRvbmVOYW1lLCBjaGVja1NldCwgbm9kZUNoZWNrLCBpc1hNTCApIHtcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hlY2tTZXQubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdHZhciBlbGVtID0gY2hlY2tTZXRbaV07XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR2YXIgbWF0Y2ggPSBmYWxzZTtcblxuXHRcdFx0ZWxlbSA9IGVsZW1bZGlyXTtcblxuXHRcdFx0d2hpbGUgKCBlbGVtICkge1xuXHRcdFx0XHRpZiAoIGVsZW1bIGV4cGFuZG8gXSA9PT0gZG9uZU5hbWUgKSB7XG5cdFx0XHRcdFx0bWF0Y2ggPSBjaGVja1NldFtlbGVtLnNpenNldF07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBleHBhbmRvIF0gPSBkb25lTmFtZTtcblx0XHRcdFx0XHRcdGVsZW0uc2l6c2V0ID0gaTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBjdXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0gPT09IGN1ciApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2ggPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIFNpenpsZS5maWx0ZXIoIGN1ciwgW2VsZW1dICkubGVuZ3RoID4gMCApIHtcblx0XHRcdFx0XHRcdG1hdGNoID0gZWxlbTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVsZW0gPSBlbGVtW2Rpcl07XG5cdFx0XHR9XG5cblx0XHRcdGNoZWNrU2V0W2ldID0gbWF0Y2g7XG5cdFx0fVxuXHR9XG59XG5cbmlmICggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zICkge1xuXHRTaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRyZXR1cm4gYSAhPT0gYiAmJiAoYS5jb250YWlucyA/IGEuY29udGFpbnMoYikgOiB0cnVlKTtcblx0fTtcblxufSBlbHNlIGlmICggZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICkge1xuXHRTaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRyZXR1cm4gISEoYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSAmIDE2KTtcblx0fTtcblxufSBlbHNlIHtcblx0U2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG5TaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuXHQvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IChlbGVtID8gZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gOiAwKS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbnZhciBwb3NQcm9jZXNzID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCBzZWVkICkge1xuXHR2YXIgbWF0Y2gsXG5cdFx0dG1wU2V0ID0gW10sXG5cdFx0bGF0ZXIgPSBcIlwiLFxuXHRcdHJvb3QgPSBjb250ZXh0Lm5vZGVUeXBlID8gW2NvbnRleHRdIDogY29udGV4dDtcblxuXHQvLyBQb3NpdGlvbiBzZWxlY3RvcnMgbXVzdCBiZSBkb25lIGFmdGVyIHRoZSBmaWx0ZXJcblx0Ly8gQW5kIHNvIG11c3QgOm5vdChwb3NpdGlvbmFsKSBzbyB3ZSBtb3ZlIGFsbCBQU0VVRE9zIHRvIHRoZSBlbmRcblx0d2hpbGUgKCAobWF0Y2ggPSBFeHByLm1hdGNoLlBTRVVETy5leGVjKCBzZWxlY3RvciApKSApIHtcblx0XHRsYXRlciArPSBtYXRjaFswXTtcblx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoIEV4cHIubWF0Y2guUFNFVURPLCBcIlwiICk7XG5cdH1cblxuXHRzZWxlY3RvciA9IEV4cHIucmVsYXRpdmVbc2VsZWN0b3JdID8gc2VsZWN0b3IgKyBcIipcIiA6IHNlbGVjdG9yO1xuXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHJvb3QubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIHJvb3RbaV0sIHRtcFNldCwgc2VlZCApO1xuXHR9XG5cblx0cmV0dXJuIFNpenpsZS5maWx0ZXIoIGxhdGVyLCB0bXBTZXQgKTtcbn07XG5cbi8vIEVYUE9TRVxuLy8gT3ZlcnJpZGUgc2l6emxlIGF0dHJpYnV0ZSByZXRyaWV2YWxcblNpenpsZS5hdHRyID0galF1ZXJ5LmF0dHI7XG5TaXp6bGUuc2VsZWN0b3JzLmF0dHJNYXAgPSB7fTtcbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xualF1ZXJ5LmV4cHJbXCI6XCJdID0galF1ZXJ5LmV4cHIuZmlsdGVycztcbmpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5cblxufSkoKTtcblxuXG52YXIgcnVudGlsID0gL1VudGlsJC8sXG5cdHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2VW50aWx8cHJldkFsbCkvLFxuXHQvLyBOb3RlOiBUaGlzIFJlZ0V4cCBzaG91bGQgYmUgaW1wcm92ZWQsIG9yIGxpa2VseSBwdWxsZWQgZnJvbSBTaXp6bGVcblx0cm11bHRpc2VsZWN0b3IgPSAvLC8sXG5cdGlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvLFxuXHRzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcblx0UE9TID0galF1ZXJ5LmV4cHIubWF0Y2guZ2xvYmFsUE9TLFxuXHQvLyBtZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdGksIGw7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIHJldCA9IHRoaXMucHVzaFN0YWNrKCBcIlwiLCBcImZpbmRcIiwgc2VsZWN0b3IgKSxcblx0XHRcdGxlbmd0aCwgbiwgcjtcblxuXHRcdGZvciAoIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRsZW5ndGggPSByZXQubGVuZ3RoO1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCB0aGlzW2ldLCByZXQgKTtcblxuXHRcdFx0aWYgKCBpID4gMCApIHtcblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIHJlc3VsdHMgYXJlIHVuaXF1ZVxuXHRcdFx0XHRmb3IgKCBuID0gbGVuZ3RoOyBuIDwgcmV0Lmxlbmd0aDsgbisrICkge1xuXHRcdFx0XHRcdGZvciAoIHIgPSAwOyByIDwgbGVuZ3RoOyByKysgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHJldFtyXSA9PT0gcmV0W25dICkge1xuXHRcdFx0XHRcdFx0XHRyZXQuc3BsaWNlKG4tLSwgMSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQgKTtcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbaV0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KHRoaXMsIHNlbGVjdG9yLCBmYWxzZSksIFwibm90XCIsIHNlbGVjdG9yKTtcblx0fSxcblxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyh0aGlzLCBzZWxlY3RvciwgdHJ1ZSksIFwiZmlsdGVyXCIsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISFzZWxlY3RvciAmJiAoXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbCBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdFx0UE9TLnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IsIHRoaXMuY29udGV4dCApLmluZGV4KCB0aGlzWzBdICkgPj0gMCA6XG5cdFx0XHRcdFx0alF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIHRoaXMgKS5sZW5ndGggPiAwIDpcblx0XHRcdFx0dGhpcy5maWx0ZXIoIHNlbGVjdG9yICkubGVuZ3RoID4gMCApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIHJldCA9IFtdLCBpLCBsLCBjdXIgPSB0aGlzWzBdO1xuXG5cdFx0Ly8gQXJyYXkgKGRlcHJlY2F0ZWQgYXMgb2YgalF1ZXJ5IDEuNylcblx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdHZhciBsZXZlbCA9IDE7XG5cblx0XHRcdHdoaWxlICggY3VyICYmIGN1ci5vd25lckRvY3VtZW50ICYmIGN1ciAhPT0gY29udGV4dCApIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBzZWxlY3RvcnMubGVuZ3RoOyBpKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGpRdWVyeSggY3VyICkuaXMoIHNlbGVjdG9yc1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0XHRyZXQucHVzaCh7IHNlbGVjdG9yOiBzZWxlY3RvcnNbIGkgXSwgZWxlbTogY3VyLCBsZXZlbDogbGV2ZWwgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHRcdGxldmVsKys7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0Ly8gU3RyaW5nXG5cdFx0dmFyIHBvcyA9IFBPUy50ZXN0KCBzZWxlY3RvcnMgKSB8fCB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvcnMsIGNvbnRleHQgfHwgdGhpcy5jb250ZXh0ICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Zm9yICggaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGN1ciA9IHRoaXNbaV07XG5cblx0XHRcdHdoaWxlICggY3VyICkge1xuXHRcdFx0XHRpZiAoIHBvcyA/IHBvcy5pbmRleChjdXIpID4gLTEgOiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoY3VyLCBzZWxlY3RvcnMpICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0XHRcdGlmICggIWN1ciB8fCAhY3VyLm93bmVyRG9jdW1lbnQgfHwgY3VyID09PSBjb250ZXh0IHx8IGN1ci5ub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXQgPSByZXQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWUoIHJldCApIDogcmV0O1xuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQsIFwiY2xvc2VzdFwiLCBzZWxlY3RvcnMgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluXG5cdC8vIHRoZSBtYXRjaGVkIHNldCBvZiBlbGVtZW50c1xuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWzBdICYmIHRoaXNbMF0ucGFyZW50Tm9kZSApID8gdGhpcy5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gaW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5pbkFycmF5KCB0aGlzWzBdLCBqUXVlcnkoIGVsZW0gKSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBqUXVlcnkuaW5BcnJheShcblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWzBdIDogZWxlbSwgdGhpcyApO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHZhciBzZXQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgOlxuXHRcdFx0XHRqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciAmJiBzZWxlY3Rvci5ub2RlVHlwZSA/IFsgc2VsZWN0b3IgXSA6IHNlbGVjdG9yICksXG5cdFx0XHRhbGwgPSBqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIHNldCApO1xuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBpc0Rpc2Nvbm5lY3RlZCggc2V0WzBdICkgfHwgaXNEaXNjb25uZWN0ZWQoIGFsbFswXSApID9cblx0XHRcdGFsbCA6XG5cdFx0XHRqUXVlcnkudW5pcXVlKCBhbGwgKSApO1xuXHR9LFxuXG5cdGFuZFNlbGY6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggdGhpcy5wcmV2T2JqZWN0ICk7XG5cdH1cbn0pO1xuXG4vLyBBIHBhaW5mdWxseSBzaW1wbGUgY2hlY2sgdG8gc2VlIGlmIGFuIGVsZW1lbnQgaXMgZGlzY29ubmVjdGVkXG4vLyBmcm9tIGEgZG9jdW1lbnQgKHNob3VsZCBiZSBpbXByb3ZlZCwgd2hlcmUgZmVhc2libGUpLlxuZnVuY3Rpb24gaXNEaXNjb25uZWN0ZWQoIG5vZGUgKSB7XG5cdHJldHVybiAhbm9kZSB8fCAhbm9kZS5wYXJlbnROb2RlIHx8IG5vZGUucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMTE7XG59XG5cbmpRdWVyeS5lYWNoKHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkubnRoKCBlbGVtLCAyLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5udGgoIGVsZW0sIDIsIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuc2libGluZyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnNpYmxpbmcoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpZnJhbWVcIiApID9cblx0XHRcdGVsZW0uY29udGVudERvY3VtZW50IHx8IGVsZW0uY29udGVudFdpbmRvdy5kb2N1bWVudCA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCAhcnVudGlsLnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5sZW5ndGggPiAxICYmICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gPyBqUXVlcnkudW5pcXVlKCByZXQgKSA6IHJldDtcblxuXHRcdGlmICggKHRoaXMubGVuZ3RoID4gMSB8fCBybXVsdGlzZWxlY3Rvci50ZXN0KCBzZWxlY3RvciApKSAmJiBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0cmV0ID0gcmV0LnJldmVyc2UoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCwgbmFtZSwgc2xpY2UuY2FsbCggYXJndW1lbnRzICkuam9pbihcIixcIikgKTtcblx0fTtcbn0pO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0ZmlsdGVyOiBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0XHRpZiAoIG5vdCApIHtcblx0XHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1zLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoZWxlbXNbMF0sIGV4cHIpID8gWyBlbGVtc1swXSBdIDogW10gOlxuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlcyhleHByLCBlbGVtcyk7XG5cdH0sXG5cblx0ZGlyOiBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdFx0Y3VyID0gZWxlbVsgZGlyIF07XG5cblx0XHR3aGlsZSAoIGN1ciAmJiBjdXIubm9kZVR5cGUgIT09IDkgJiYgKHVudGlsID09PSB1bmRlZmluZWQgfHwgY3VyLm5vZGVUeXBlICE9PSAxIHx8ICFqUXVlcnkoIGN1ciApLmlzKCB1bnRpbCApKSApIHtcblx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0fVxuXHRcdFx0Y3VyID0gY3VyW2Rpcl07XG5cdFx0fVxuXHRcdHJldHVybiBtYXRjaGVkO1xuXHR9LFxuXG5cdG50aDogZnVuY3Rpb24oIGN1ciwgcmVzdWx0LCBkaXIsIGVsZW0gKSB7XG5cdFx0cmVzdWx0ID0gcmVzdWx0IHx8IDE7XG5cdFx0dmFyIG51bSA9IDA7XG5cblx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyW2Rpcl0gKSB7XG5cdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiArK251bSA9PT0gcmVzdWx0ICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY3VyO1xuXHR9LFxuXG5cdHNpYmxpbmc6IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHRcdHZhciByID0gW107XG5cblx0XHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRcdHIucHVzaCggbiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByO1xuXHR9XG59KTtcblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwga2VlcCApIHtcblxuXHQvLyBDYW4ndCBwYXNzIG51bGwgb3IgdW5kZWZpbmVkIHRvIGluZGV4T2YgaW4gRmlyZWZveCA0XG5cdC8vIFNldCB0byAwIHRvIHNraXAgc3RyaW5nIGNoZWNrXG5cdHF1YWxpZmllciA9IHF1YWxpZmllciB8fCAwO1xuXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcChlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHR2YXIgcmV0VmFsID0gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdFx0cmV0dXJuIHJldFZhbCA9PT0ga2VlcDtcblx0XHR9KTtcblxuXHR9IGVsc2UgaWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApID09PSBrZWVwO1xuXHRcdH0pO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBxdWFsaWZpZXIgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0dmFyIGZpbHRlcmVkID0galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdFx0fSk7XG5cblx0XHRpZiAoIGlzU2ltcGxlLnRlc3QoIHF1YWxpZmllciApICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5maWx0ZXIocXVhbGlmaWVyLCBmaWx0ZXJlZCwgIWtlZXApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRxdWFsaWZpZXIgPSBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGZpbHRlcmVkICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRyZXR1cm4gKCBqUXVlcnkuaW5BcnJheSggZWxlbSwgcXVhbGlmaWVyICkgPj0gMCApID09PSBrZWVwO1xuXHR9KTtcbn1cblxuXG5cblxuZnVuY3Rpb24gY3JlYXRlU2FmZUZyYWdtZW50KCBkb2N1bWVudCApIHtcblx0dmFyIGxpc3QgPSBub2RlTmFtZXMuc3BsaXQoIFwifFwiICksXG5cdHNhZmVGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG5cdGlmICggc2FmZUZyYWcuY3JlYXRlRWxlbWVudCApIHtcblx0XHR3aGlsZSAoIGxpc3QubGVuZ3RoICkge1xuXHRcdFx0c2FmZUZyYWcuY3JlYXRlRWxlbWVudChcblx0XHRcdFx0bGlzdC5wb3AoKVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHNhZmVGcmFnO1xufVxuXG52YXIgbm9kZU5hbWVzID0gXCJhYmJyfGFydGljbGV8YXNpZGV8YXVkaW98YmRpfGNhbnZhc3xkYXRhfGRhdGFsaXN0fGRldGFpbHN8ZmlnY2FwdGlvbnxmaWd1cmV8Zm9vdGVyfFwiICtcblx0XHRcImhlYWRlcnxoZ3JvdXB8bWFya3xtZXRlcnxuYXZ8b3V0cHV0fHByb2dyZXNzfHNlY3Rpb258c3VtbWFyeXx0aW1lfHZpZGVvXCIsXG5cdHJpbmxpbmVqUXVlcnkgPSAvIGpRdWVyeVxcZCs9XCIoPzpcXGQrfG51bGwpXCIvZyxcblx0cmxlYWRpbmdXaGl0ZXNwYWNlID0gL15cXHMrLyxcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzpdKylbXj5dKilcXC8+L2lnLFxuXHRydGFnTmFtZSA9IC88KFtcXHc6XSspLyxcblx0cnRib2R5ID0gLzx0Ym9keS9pLFxuXHRyaHRtbCA9IC88fCYjP1xcdys7Lyxcblx0cm5vSW5uZXJodG1sID0gLzwoPzpzY3JpcHR8c3R5bGUpL2ksXG5cdHJub2NhY2hlID0gLzwoPzpzY3JpcHR8b2JqZWN0fGVtYmVkfG9wdGlvbnxzdHlsZSkvaSxcblx0cm5vc2hpbWNhY2hlID0gbmV3IFJlZ0V4cChcIjwoPzpcIiArIG5vZGVOYW1lcyArIFwiKVtcXFxccy8+XVwiLCBcImlcIiksXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJzY3JpcHRUeXBlID0gL1xcLyhqYXZhfGVjbWEpc2NyaXB0L2ksXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8XFwtXFwtKS8sXG5cdHdyYXBNYXAgPSB7XG5cdFx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cdFx0bGVnZW5kOiBbIDEsIFwiPGZpZWxkc2V0PlwiLCBcIjwvZmllbGRzZXQ+XCIgXSxcblx0XHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdFx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHRcdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0XHRjb2w6IFsgMiwgXCI8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHRcdGFyZWE6IFsgMSwgXCI8bWFwPlwiLCBcIjwvbWFwPlwiIF0sXG5cdFx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG5cdH0sXG5cdHNhZmVGcmFnbWVudCA9IGNyZWF0ZVNhZmVGcmFnbWVudCggZG9jdW1lbnQgKTtcblxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG4vLyBJRSBjYW4ndCBzZXJpYWxpemUgPGxpbms+IGFuZCA8c2NyaXB0PiB0YWdzIG5vcm1hbGx5XG5pZiAoICFqUXVlcnkuc3VwcG9ydC5odG1sU2VyaWFsaXplICkge1xuXHR3cmFwTWFwLl9kZWZhdWx0ID0gWyAxLCBcImRpdjxkaXY+XCIsIFwiPC9kaXY+XCIgXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggKCB0aGlzWzBdICYmIHRoaXNbMF0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApLmNyZWF0ZVRleHROb2RlKCB2YWx1ZSApICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0alF1ZXJ5KHRoaXMpLndyYXBBbGwoIGh0bWwuY2FsbCh0aGlzLCBpKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzWzBdICkge1xuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHZhciB3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWzBdLm93bmVyRG9jdW1lbnQgKS5lcSgwKS5jbG9uZSh0cnVlKTtcblxuXHRcdFx0aWYgKCB0aGlzWzBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0Q2hpbGQgJiYgZWxlbS5maXJzdENoaWxkLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0pLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XG5cdFx0XHRcdGpRdWVyeSh0aGlzKS53cmFwSW5uZXIoIGh0bWwuY2FsbCh0aGlzLCBpKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaSkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCh0aGlzLCBpKSA6IGh0bWwgKTtcblx0XHR9KTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnBhcmVudCgpLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiYm9keVwiICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHRcdH1cblx0XHR9KS5lbmQoKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywgdHJ1ZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHRoaXMuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIHRydWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHR0aGlzLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXNbMF0gJiYgdGhpc1swXS5wYXJlbnROb2RlICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCBmYWxzZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR2YXIgc2V0ID0galF1ZXJ5LmNsZWFuKCBhcmd1bWVudHMgKTtcblx0XHRcdHNldC5wdXNoLmFwcGx5KCBzZXQsIHRoaXMudG9BcnJheSgpICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNldCwgXCJiZWZvcmVcIiwgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXNbMF0gJiYgdGhpc1swXS5wYXJlbnROb2RlICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCBmYWxzZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR2YXIgc2V0ID0gdGhpcy5wdXNoU3RhY2soIHRoaXMsIFwiYWZ0ZXJcIiwgYXJndW1lbnRzICk7XG5cdFx0XHRzZXQucHVzaC5hcHBseSggc2V0LCBqUXVlcnkuY2xlYW4oYXJndW1lbnRzKSApO1xuXHRcdFx0cmV0dXJuIHNldDtcblx0XHR9XG5cdH0sXG5cblx0Ly8ga2VlcERhdGEgaXMgZm9yIGludGVybmFsIHVzZSBvbmx5LS1kbyBub3QgZG9jdW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHRcdGZvciAoIHZhciBpID0gMCwgZWxlbTsgKGVsZW0gPSB0aGlzW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoICFzZWxlY3RvciB8fCBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgWyBlbGVtIF0gKS5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIWtlZXBEYXRhICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgKTtcblx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICggdmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0Q2hpbGQgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQ2hpbGQoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBqUXVlcnkuYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbMF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDEgP1xuXHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MLnJlcGxhY2UoIHJpbmxpbmVqUXVlcnksIFwiXCIgKSA6XG5cdFx0XHRcdFx0bnVsbDtcblx0XHRcdH1cblxuXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0KCBqUXVlcnkuc3VwcG9ydC5sZWFkaW5nV2hpdGVzcGFjZSB8fCAhcmxlYWRpbmdXaGl0ZXNwYWNlLnRlc3QoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFtcIlwiLCBcIlwiXSApWzFdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzW2ldIHx8IHt9O1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcIipcIiApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2goZSkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRpZiAoIHRoaXNbMF0gJiYgdGhpc1swXS5wYXJlbnROb2RlICkge1xuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGVsZW1lbnRzIGFyZSByZW1vdmVkIGZyb20gdGhlIERPTSBiZWZvcmUgdGhleSBhcmUgaW5zZXJ0ZWRcblx0XHRcdC8vIHRoaXMgY2FuIGhlbHAgZml4IHJlcGxhY2luZyBhIHBhcmVudCB3aXRoIGNoaWxkIGVsZW1lbnRzXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSh0aGlzKSwgb2xkID0gc2VsZi5odG1sKCk7XG5cdFx0XHRcdFx0c2VsZi5yZXBsYWNlV2l0aCggdmFsdWUuY2FsbCggdGhpcywgaSwgb2xkICkgKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggdmFsdWUgKS5kZXRhY2goKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5leHQgPSB0aGlzLm5leHRTaWJsaW5nLFxuXHRcdFx0XHRcdHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmUoKTtcblxuXHRcdFx0XHRpZiAoIG5leHQgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5KG5leHQpLmJlZm9yZSggdmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRqUXVlcnkocGFyZW50KS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5sZW5ndGggP1xuXHRcdFx0XHR0aGlzLnB1c2hTdGFjayggalF1ZXJ5KGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlKCkgOiB2YWx1ZSksIFwicmVwbGFjZVdpdGhcIiwgdmFsdWUgKSA6XG5cdFx0XHRcdHRoaXM7XG5cdFx0fVxuXHR9LFxuXG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZSggc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRkb21NYW5pcDogZnVuY3Rpb24oIGFyZ3MsIHRhYmxlLCBjYWxsYmFjayApIHtcblx0XHR2YXIgcmVzdWx0cywgZmlyc3QsIGZyYWdtZW50LCBwYXJlbnQsXG5cdFx0XHR2YWx1ZSA9IGFyZ3NbMF0sXG5cdFx0XHRzY3JpcHRzID0gW107XG5cblx0XHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0XHRpZiAoICFqUXVlcnkuc3VwcG9ydC5jaGVja0Nsb25lICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkodGhpcykuZG9tTWFuaXAoIGFyZ3MsIHRhYmxlLCBjYWxsYmFjaywgdHJ1ZSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbih2YWx1ZSkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkodGhpcyk7XG5cdFx0XHRcdGFyZ3NbMF0gPSB2YWx1ZS5jYWxsKHRoaXMsIGksIHRhYmxlID8gc2VsZi5odG1sKCkgOiB1bmRlZmluZWQpO1xuXHRcdFx0XHRzZWxmLmRvbU1hbmlwKCBhcmdzLCB0YWJsZSwgY2FsbGJhY2sgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICggdGhpc1swXSApIHtcblx0XHRcdHBhcmVudCA9IHZhbHVlICYmIHZhbHVlLnBhcmVudE5vZGU7XG5cblx0XHRcdC8vIElmIHdlJ3JlIGluIGEgZnJhZ21lbnQsIGp1c3QgdXNlIHRoYXQgaW5zdGVhZCBvZiBidWlsZGluZyBhIG5ldyBvbmVcblx0XHRcdGlmICggalF1ZXJ5LnN1cHBvcnQucGFyZW50Tm9kZSAmJiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09PSAxMSAmJiBwYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRyZXN1bHRzID0geyBmcmFnbWVudDogcGFyZW50IH07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdHMgPSBqUXVlcnkuYnVpbGRGcmFnbWVudCggYXJncywgdGhpcywgc2NyaXB0cyApO1xuXHRcdFx0fVxuXG5cdFx0XHRmcmFnbWVudCA9IHJlc3VsdHMuZnJhZ21lbnQ7XG5cblx0XHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdGZpcnN0ID0gZnJhZ21lbnQgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGZpcnN0ICkge1xuXHRcdFx0XHR0YWJsZSA9IHRhYmxlICYmIGpRdWVyeS5ub2RlTmFtZSggZmlyc3QsIFwidHJcIiApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoLCBsYXN0SW5kZXggPSBsIC0gMTsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKFxuXHRcdFx0XHRcdFx0dGFibGUgP1xuXHRcdFx0XHRcdFx0XHRyb290KHRoaXNbaV0sIGZpcnN0KSA6XG5cdFx0XHRcdFx0XHRcdHRoaXNbaV0sXG5cdFx0XHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSBkbyBub3QgbGVhayBtZW1vcnkgYnkgaW5hZHZlcnRlbnRseSBkaXNjYXJkaW5nXG5cdFx0XHRcdFx0XHQvLyB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgKHdoaWNoIG1pZ2h0IGhhdmUgYXR0YWNoZWQgZGF0YSkgaW5zdGVhZCBvZlxuXHRcdFx0XHRcdFx0Ly8gdXNpbmcgaXQ7IGluIGFkZGl0aW9uLCB1c2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IG9iamVjdCBmb3IgdGhlIGxhc3Rcblx0XHRcdFx0XHRcdC8vIGl0ZW0gaW5zdGVhZCBvZiBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXAgYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseVxuXHRcdFx0XHRcdFx0Ly8gaW4gY2VydGFpbiBzaXR1YXRpb25zIChCdWcgIzgwNzApLlxuXHRcdFx0XHRcdFx0Ly8gRnJhZ21lbnRzIGZyb20gdGhlIGZyYWdtZW50IGNhY2hlIG11c3QgYWx3YXlzIGJlIGNsb25lZCBhbmQgbmV2ZXIgdXNlZFxuXHRcdFx0XHRcdFx0Ly8gaW4gcGxhY2UuXG5cdFx0XHRcdFx0XHRyZXN1bHRzLmNhY2hlYWJsZSB8fCAoIGwgPiAxICYmIGkgPCBsYXN0SW5kZXggKSA/XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbG9uZSggZnJhZ21lbnQsIHRydWUsIHRydWUgKSA6XG5cdFx0XHRcdFx0XHRcdGZyYWdtZW50XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggc2NyaXB0cywgZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLnNyYyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5hamF4KHtcblx0XHRcdFx0XHRcdFx0dHlwZTogXCJHRVRcIixcblx0XHRcdFx0XHRcdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0dXJsOiBlbGVtLnNyYyxcblx0XHRcdFx0XHRcdFx0YXN5bmM6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIlxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCAoIGVsZW0udGV4dCB8fCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJIVE1MIHx8IFwiXCIgKS5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiLyokMCovXCIgKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSk7XG5cbmZ1bmN0aW9uIHJvb3QoIGVsZW0sIGN1ciApIHtcblx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZShlbGVtLCBcInRhYmxlXCIpID9cblx0XHQoZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpWzBdIHx8XG5cdFx0ZWxlbS5hcHBlbmRDaGlsZChlbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRib2R5XCIpKSkgOlxuXHRcdGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxIHx8ICFqUXVlcnkuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHR5cGUsIGksIGwsXG5cdFx0b2xkRGF0YSA9IGpRdWVyeS5fZGF0YSggc3JjICksXG5cdFx0Y3VyRGF0YSA9IGpRdWVyeS5fZGF0YSggZGVzdCwgb2xkRGF0YSApLFxuXHRcdGV2ZW50cyA9IG9sZERhdGEuZXZlbnRzO1xuXG5cdGlmICggZXZlbnRzICkge1xuXHRcdGRlbGV0ZSBjdXJEYXRhLmhhbmRsZTtcblx0XHRjdXJEYXRhLmV2ZW50cyA9IHt9O1xuXG5cdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIG1ha2UgdGhlIGNsb25lZCBwdWJsaWMgZGF0YSBvYmplY3QgYSBjb3B5IGZyb20gdGhlIG9yaWdpbmFsXG5cdGlmICggY3VyRGF0YS5kYXRhICkge1xuXHRcdGN1ckRhdGEuZGF0YSA9IGpRdWVyeS5leHRlbmQoIHt9LCBjdXJEYXRhLmRhdGEgKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjbG9uZUZpeEF0dHJpYnV0ZXMoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lO1xuXG5cdC8vIFdlIGRvIG5vdCBuZWVkIHRvIGRvIGFueXRoaW5nIGZvciBub24tRWxlbWVudHNcblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIGNsZWFyQXR0cmlidXRlcyByZW1vdmVzIHRoZSBhdHRyaWJ1dGVzLCB3aGljaCB3ZSBkb24ndCB3YW50LFxuXHQvLyBidXQgYWxzbyByZW1vdmVzIHRoZSBhdHRhY2hFdmVudCBldmVudHMsIHdoaWNoIHdlICpkbyogd2FudFxuXHRpZiAoIGRlc3QuY2xlYXJBdHRyaWJ1dGVzICkge1xuXHRcdGRlc3QuY2xlYXJBdHRyaWJ1dGVzKCk7XG5cdH1cblxuXHQvLyBtZXJnZUF0dHJpYnV0ZXMsIGluIGNvbnRyYXN0LCBvbmx5IG1lcmdlcyBiYWNrIG9uIHRoZVxuXHQvLyBvcmlnaW5hbCBhdHRyaWJ1dGVzLCBub3QgdGhlIGV2ZW50c1xuXHRpZiAoIGRlc3QubWVyZ2VBdHRyaWJ1dGVzICkge1xuXHRcdGRlc3QubWVyZ2VBdHRyaWJ1dGVzKCBzcmMgKTtcblx0fVxuXG5cdG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIElFNi04IGZhaWwgdG8gY2xvbmUgY2hpbGRyZW4gaW5zaWRlIG9iamVjdCBlbGVtZW50cyB0aGF0IHVzZVxuXHQvLyB0aGUgcHJvcHJpZXRhcnkgY2xhc3NpZCBhdHRyaWJ1dGUgdmFsdWUgKHJhdGhlciB0aGFuIHRoZSB0eXBlXG5cdC8vIGF0dHJpYnV0ZSkgdG8gaWRlbnRpZnkgdGhlIHR5cGUgb2YgY29udGVudCB0byBkaXNwbGF5XG5cdGlmICggbm9kZU5hbWUgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0ZGVzdC5vdXRlckhUTUwgPSBzcmMub3V0ZXJIVE1MO1xuXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgKHNyYy50eXBlID09PSBcImNoZWNrYm94XCIgfHwgc3JjLnR5cGUgPT09IFwicmFkaW9cIikgKSB7XG5cdFx0Ly8gSUU2LTggZmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveFxuXHRcdC8vIG9yIHJhZGlvIGJ1dHRvbi4gV29yc2UsIElFNi03IGZhaWwgdG8gZ2l2ZSB0aGUgY2xvbmVkIGVsZW1lbnRcblx0XHQvLyBhIGNoZWNrZWQgYXBwZWFyYW5jZSBpZiB0aGUgZGVmYXVsdENoZWNrZWQgdmFsdWUgaXNuJ3QgYWxzbyBzZXRcblx0XHRpZiAoIHNyYy5jaGVja2VkICkge1xuXHRcdFx0ZGVzdC5kZWZhdWx0Q2hlY2tlZCA9IGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXHRcdH1cblxuXHRcdC8vIElFNi03IGdldCBjb25mdXNlZCBhbmQgZW5kIHVwIHNldHRpbmcgdGhlIHZhbHVlIG9mIGEgY2xvbmVkXG5cdFx0Ly8gY2hlY2tib3gvcmFkaW8gYnV0dG9uIHRvIGFuIGVtcHR5IHN0cmluZyBpbnN0ZWFkIG9mIFwib25cIlxuXHRcdGlmICggZGVzdC52YWx1ZSAhPT0gc3JjLnZhbHVlICkge1xuXHRcdFx0ZGVzdC52YWx1ZSA9IHNyYy52YWx1ZTtcblx0XHR9XG5cblx0Ly8gSUU2LTggZmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWRcblx0Ly8gc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwib3B0aW9uXCIgKSB7XG5cdFx0ZGVzdC5zZWxlY3RlZCA9IHNyYy5kZWZhdWx0U2VsZWN0ZWQ7XG5cblx0Ly8gSUU2LTggZmFpbHMgdG8gc2V0IHRoZSBkZWZhdWx0VmFsdWUgdG8gdGhlIGNvcnJlY3QgdmFsdWUgd2hlblxuXHQvLyBjbG9uaW5nIG90aGVyIHR5cGVzIG9mIGlucHV0IGZpZWxkc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXG5cdC8vIElFIGJsYW5rcyBjb250ZW50cyB3aGVuIGNsb25pbmcgc2NyaXB0c1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJzY3JpcHRcIiAmJiBkZXN0LnRleHQgIT09IHNyYy50ZXh0ICkge1xuXHRcdGRlc3QudGV4dCA9IHNyYy50ZXh0O1xuXHR9XG5cblx0Ly8gRXZlbnQgZGF0YSBnZXRzIHJlZmVyZW5jZWQgaW5zdGVhZCBvZiBjb3BpZWQgaWYgdGhlIGV4cGFuZG9cblx0Ly8gZ2V0cyBjb3BpZWQgdG9vXG5cdGRlc3QucmVtb3ZlQXR0cmlidXRlKCBqUXVlcnkuZXhwYW5kbyApO1xuXG5cdC8vIENsZWFyIGZsYWdzIGZvciBidWJibGluZyBzcGVjaWFsIGNoYW5nZS9zdWJtaXQgZXZlbnRzLCB0aGV5IG11c3Rcblx0Ly8gYmUgcmVhdHRhY2hlZCB3aGVuIHRoZSBuZXdseSBjbG9uZWQgZXZlbnRzIGFyZSBmaXJzdCBhY3RpdmF0ZWRcblx0ZGVzdC5yZW1vdmVBdHRyaWJ1dGUoIFwiX3N1Ym1pdF9hdHRhY2hlZFwiICk7XG5cdGRlc3QucmVtb3ZlQXR0cmlidXRlKCBcIl9jaGFuZ2VfYXR0YWNoZWRcIiApO1xufVxuXG5qUXVlcnkuYnVpbGRGcmFnbWVudCA9IGZ1bmN0aW9uKCBhcmdzLCBub2Rlcywgc2NyaXB0cyApIHtcblx0dmFyIGZyYWdtZW50LCBjYWNoZWFibGUsIGNhY2hlcmVzdWx0cywgZG9jLFxuXHRmaXJzdCA9IGFyZ3NbIDAgXTtcblxuXHQvLyBub2RlcyBtYXkgY29udGFpbiBlaXRoZXIgYW4gZXhwbGljaXQgZG9jdW1lbnQgb2JqZWN0LFxuXHQvLyBhIGpRdWVyeSBjb2xsZWN0aW9uIG9yIGNvbnRleHQgb2JqZWN0LlxuXHQvLyBJZiBub2Rlc1swXSBjb250YWlucyBhIHZhbGlkIG9iamVjdCB0byBhc3NpZ24gdG8gZG9jXG5cdGlmICggbm9kZXMgJiYgbm9kZXNbMF0gKSB7XG5cdFx0ZG9jID0gbm9kZXNbMF0ub3duZXJEb2N1bWVudCB8fCBub2Rlc1swXTtcblx0fVxuXG5cdC8vIEVuc3VyZSB0aGF0IGFuIGF0dHIgb2JqZWN0IGRvZXNuJ3QgaW5jb3JyZWN0bHkgc3RhbmQgaW4gYXMgYSBkb2N1bWVudCBvYmplY3Rcblx0Ly8gQ2hyb21lIGFuZCBGaXJlZm94IHNlZW0gdG8gYWxsb3cgdGhpcyB0byBvY2N1ciBhbmQgd2lsbCB0aHJvdyBleGNlcHRpb25cblx0Ly8gRml4ZXMgIzg5NTBcblx0aWYgKCAhZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQgKSB7XG5cdFx0ZG9jID0gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBPbmx5IGNhY2hlIFwic21hbGxcIiAoMS8yIEtCKSBIVE1MIHN0cmluZ3MgdGhhdCBhcmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBtYWluIGRvY3VtZW50XG5cdC8vIENsb25pbmcgb3B0aW9ucyBsb3NlcyB0aGUgc2VsZWN0ZWQgc3RhdGUsIHNvIGRvbid0IGNhY2hlIHRoZW1cblx0Ly8gSUUgNiBkb2Vzbid0IGxpa2UgaXQgd2hlbiB5b3UgcHV0IDxvYmplY3Q+IG9yIDxlbWJlZD4gZWxlbWVudHMgaW4gYSBmcmFnbWVudFxuXHQvLyBBbHNvLCBXZWJLaXQgZG9lcyBub3QgY2xvbmUgJ2NoZWNrZWQnIGF0dHJpYnV0ZXMgb24gY2xvbmVOb2RlLCBzbyBkb24ndCBjYWNoZVxuXHQvLyBMYXN0bHksIElFNiw3LDggd2lsbCBub3QgY29ycmVjdGx5IHJldXNlIGNhY2hlZCBmcmFnbWVudHMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSB1bmtub3duIGVsZW1zICMxMDUwMVxuXHRpZiAoIGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBmaXJzdCA9PT0gXCJzdHJpbmdcIiAmJiBmaXJzdC5sZW5ndGggPCA1MTIgJiYgZG9jID09PSBkb2N1bWVudCAmJlxuXHRcdGZpcnN0LmNoYXJBdCgwKSA9PT0gXCI8XCIgJiYgIXJub2NhY2hlLnRlc3QoIGZpcnN0ICkgJiZcblx0XHQoalF1ZXJ5LnN1cHBvcnQuY2hlY2tDbG9uZSB8fCAhcmNoZWNrZWQudGVzdCggZmlyc3QgKSkgJiZcblx0XHQoalF1ZXJ5LnN1cHBvcnQuaHRtbDVDbG9uZSB8fCAhcm5vc2hpbWNhY2hlLnRlc3QoIGZpcnN0ICkpICkge1xuXG5cdFx0Y2FjaGVhYmxlID0gdHJ1ZTtcblxuXHRcdGNhY2hlcmVzdWx0cyA9IGpRdWVyeS5mcmFnbWVudHNbIGZpcnN0IF07XG5cdFx0aWYgKCBjYWNoZXJlc3VsdHMgJiYgY2FjaGVyZXN1bHRzICE9PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBjYWNoZXJlc3VsdHM7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhZnJhZ21lbnQgKSB7XG5cdFx0ZnJhZ21lbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdGpRdWVyeS5jbGVhbiggYXJncywgZG9jLCBmcmFnbWVudCwgc2NyaXB0cyApO1xuXHR9XG5cblx0aWYgKCBjYWNoZWFibGUgKSB7XG5cdFx0alF1ZXJ5LmZyYWdtZW50c1sgZmlyc3QgXSA9IGNhY2hlcmVzdWx0cyA/IGZyYWdtZW50IDogMTtcblx0fVxuXG5cdHJldHVybiB7IGZyYWdtZW50OiBmcmFnbWVudCwgY2FjaGVhYmxlOiBjYWNoZWFibGUgfTtcbn07XG5cbmpRdWVyeS5mcmFnbWVudHMgPSB7fTtcblxualF1ZXJ5LmVhY2goe1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0cGFyZW50ID0gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpc1swXS5wYXJlbnROb2RlO1xuXG5cdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09PSAxMSAmJiBwYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgJiYgaW5zZXJ0Lmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGluc2VydFsgb3JpZ2luYWwgXSggdGhpc1swXSApO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5zZXJ0Lmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0dmFyIGVsZW1zID0gKCBpID4gMCA/IHRoaXMuY2xvbmUodHJ1ZSkgOiB0aGlzICkuZ2V0KCk7XG5cdFx0XHRcdGpRdWVyeSggaW5zZXJ0W2ldIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cdFx0XHRcdHJldCA9IHJldC5jb25jYXQoIGVsZW1zICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0LCBuYW1lLCBpbnNlcnQuc2VsZWN0b3IgKTtcblx0XHR9XG5cdH07XG59KTtcblxuZnVuY3Rpb24gZ2V0QWxsKCBlbGVtICkge1xuXHRpZiAoIHR5cGVvZiBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldHVybiBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBlbGVtLnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0dXJuIGVsZW0ucXVlcnlTZWxlY3RvckFsbCggXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBbXTtcblx0fVxufVxuXG4vLyBVc2VkIGluIGNsZWFuLCBmaXhlcyB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcGVydHlcbmZ1bmN0aW9uIGZpeERlZmF1bHRDaGVja2VkKCBlbGVtICkge1xuXHRpZiAoIGVsZW0udHlwZSA9PT0gXCJjaGVja2JveFwiIHx8IGVsZW0udHlwZSA9PT0gXCJyYWRpb1wiICkge1xuXHRcdGVsZW0uZGVmYXVsdENoZWNrZWQgPSBlbGVtLmNoZWNrZWQ7XG5cdH1cbn1cbi8vIEZpbmRzIGFsbCBpbnB1dHMgYW5kIHBhc3NlcyB0aGVtIHRvIGZpeERlZmF1bHRDaGVja2VkXG5mdW5jdGlvbiBmaW5kSW5wdXRzKCBlbGVtICkge1xuXHR2YXIgbm9kZU5hbWUgPSAoIGVsZW0ubm9kZU5hbWUgfHwgXCJcIiApLnRvTG93ZXJDYXNlKCk7XG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiApIHtcblx0XHRmaXhEZWZhdWx0Q2hlY2tlZCggZWxlbSApO1xuXHQvLyBTa2lwIHNjcmlwdHMsIGdldCBvdGhlciBjaGlsZHJlblxuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSAhPT0gXCJzY3JpcHRcIiAmJiB0eXBlb2YgZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRqUXVlcnkuZ3JlcCggZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpLCBmaXhEZWZhdWx0Q2hlY2tlZCApO1xuXHR9XG59XG5cbi8vIERlcml2ZWQgRnJvbTogaHR0cDovL3d3dy5pZWNzcy5jb20vc2hpbXByb3ZlL2phdmFzY3JpcHQvc2hpbXByb3ZlLjEtMC0xLmpzXG5mdW5jdGlvbiBzaGltQ2xvbmVOb2RlKCBlbGVtICkge1xuXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXHRzYWZlRnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdGRpdi5pbm5lckhUTUwgPSBlbGVtLm91dGVySFRNTDtcblx0cmV0dXJuIGRpdi5maXJzdENoaWxkO1xufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgc3JjRWxlbWVudHMsXG5cdFx0XHRkZXN0RWxlbWVudHMsXG5cdFx0XHRpLFxuXHRcdFx0Ly8gSUU8PTggZG9lcyBub3QgcHJvcGVybHkgY2xvbmUgZGV0YWNoZWQsIHVua25vd24gZWxlbWVudCBub2Rlc1xuXHRcdFx0Y2xvbmUgPSBqUXVlcnkuc3VwcG9ydC5odG1sNUNsb25lIHx8IGpRdWVyeS5pc1hNTERvYyhlbGVtKSB8fCAhcm5vc2hpbWNhY2hlLnRlc3QoIFwiPFwiICsgZWxlbS5ub2RlTmFtZSArIFwiPlwiICkgP1xuXHRcdFx0XHRlbGVtLmNsb25lTm9kZSggdHJ1ZSApIDpcblx0XHRcdFx0c2hpbUNsb25lTm9kZSggZWxlbSApO1xuXG5cdFx0aWYgKCAoIWpRdWVyeS5zdXBwb3J0Lm5vQ2xvbmVFdmVudCB8fCAhalF1ZXJ5LnN1cHBvcnQubm9DbG9uZUNoZWNrZWQpICYmXG5cdFx0XHRcdChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExKSAmJiAhalF1ZXJ5LmlzWE1MRG9jKGVsZW0pICkge1xuXHRcdFx0Ly8gSUUgY29waWVzIGV2ZW50cyBib3VuZCB2aWEgYXR0YWNoRXZlbnQgd2hlbiB1c2luZyBjbG9uZU5vZGUuXG5cdFx0XHQvLyBDYWxsaW5nIGRldGFjaEV2ZW50IG9uIHRoZSBjbG9uZSB3aWxsIGFsc28gcmVtb3ZlIHRoZSBldmVudHNcblx0XHRcdC8vIGZyb20gdGhlIG9yaWdpbmFsLiBJbiBvcmRlciB0byBnZXQgYXJvdW5kIHRoaXMsIHdlIHVzZSBzb21lXG5cdFx0XHQvLyBwcm9wcmlldGFyeSBtZXRob2RzIHRvIGNsZWFyIHRoZSBldmVudHMuIFRoYW5rcyB0byBNb29Ub29sc1xuXHRcdFx0Ly8gZ3V5cyBmb3IgdGhpcyBob3RuZXNzLlxuXG5cdFx0XHRjbG9uZUZpeEF0dHJpYnV0ZXMoIGVsZW0sIGNsb25lICk7XG5cblx0XHRcdC8vIFVzaW5nIFNpenpsZSBoZXJlIGlzIGNyYXp5IHNsb3csIHNvIHdlIHVzZSBnZXRFbGVtZW50c0J5VGFnTmFtZSBpbnN0ZWFkXG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHQvLyBXZWlyZCBpdGVyYXRpb24gYmVjYXVzZSBJRSB3aWxsIHJlcGxhY2UgdGhlIGxlbmd0aCBwcm9wZXJ0eVxuXHRcdFx0Ly8gd2l0aCBhbiBlbGVtZW50IGlmIHlvdSBhcmUgY2xvbmluZyB0aGUgYm9keSBhbmQgb25lIG9mIHRoZVxuXHRcdFx0Ly8gZWxlbWVudHMgb24gdGhlIHBhZ2UgaGFzIGEgbmFtZSBvciBpZCBvZiBcImxlbmd0aFwiXG5cdFx0XHRmb3IgKCBpID0gMDsgc3JjRWxlbWVudHNbaV07ICsraSApIHtcblx0XHRcdFx0Ly8gRW5zdXJlIHRoYXQgdGhlIGRlc3RpbmF0aW9uIG5vZGUgaXMgbm90IG51bGw7IEZpeGVzICM5NTg3XG5cdFx0XHRcdGlmICggZGVzdEVsZW1lbnRzW2ldICkge1xuXHRcdFx0XHRcdGNsb25lRml4QXR0cmlidXRlcyggc3JjRWxlbWVudHNbaV0sIGRlc3RFbGVtZW50c1tpXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IHNyY0VsZW1lbnRzW2ldOyArK2kgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzW2ldLCBkZXN0RWxlbWVudHNbaV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNyY0VsZW1lbnRzID0gZGVzdEVsZW1lbnRzID0gbnVsbDtcblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbjogZnVuY3Rpb24oIGVsZW1zLCBjb250ZXh0LCBmcmFnbWVudCwgc2NyaXB0cyApIHtcblx0XHR2YXIgY2hlY2tTY3JpcHRUeXBlLCBzY3JpcHQsIGosXG5cdFx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyAhY29udGV4dC5jcmVhdGVFbGVtZW50IGZhaWxzIGluIElFIHdpdGggYW4gZXJyb3IgYnV0IHJldHVybnMgdHlwZW9mICdvYmplY3QnXG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5jcmVhdGVFbGVtZW50ID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0Y29udGV4dCA9IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0WzBdICYmIGNvbnRleHRbMF0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGVsZW07IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdGVsZW0gKz0gXCJcIjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBzdHJpbmcgaW50byBET00gbm9kZXNcblx0XHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEZpeCBcIlhIVE1MXCItc3R5bGUgdGFncyBpbiBhbGwgYnJvd3NlcnNcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5yZXBsYWNlKHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIik7XG5cblx0XHRcdFx0XHQvLyBUcmltIHdoaXRlc3BhY2UsIG90aGVyd2lzZSBpbmRleE9mIHdvbid0IHdvcmsgYXMgZXhwZWN0ZWRcblx0XHRcdFx0XHR2YXIgdGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgW1wiXCIsIFwiXCJdIClbMV0udG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0LFxuXHRcdFx0XHRcdFx0ZGVwdGggPSB3cmFwWzBdLFxuXHRcdFx0XHRcdFx0ZGl2ID0gY29udGV4dC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuXHRcdFx0XHRcdFx0c2FmZUNoaWxkTm9kZXMgPSBzYWZlRnJhZ21lbnQuY2hpbGROb2Rlcyxcblx0XHRcdFx0XHRcdHJlbW92ZTtcblxuXHRcdFx0XHRcdC8vIEFwcGVuZCB3cmFwcGVyIGVsZW1lbnQgdG8gdW5rbm93biBlbGVtZW50IHNhZmUgZG9jIGZyYWdtZW50XG5cdFx0XHRcdFx0aWYgKCBjb250ZXh0ID09PSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgZnJhZ21lbnQgd2UndmUgYWxyZWFkeSBjcmVhdGVkIGZvciB0aGlzIGRvY3VtZW50XG5cdFx0XHRcdFx0XHRzYWZlRnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBVc2UgYSBmcmFnbWVudCBjcmVhdGVkIHdpdGggdGhlIG93bmVyIGRvY3VtZW50XG5cdFx0XHRcdFx0XHRjcmVhdGVTYWZlRnJhZ21lbnQoIGNvbnRleHQgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gR28gdG8gaHRtbCBhbmQgYmFjaywgdGhlbiBwZWVsIG9mZiBleHRyYSB3cmFwcGVyc1xuXHRcdFx0XHRcdGRpdi5pbm5lckhUTUwgPSB3cmFwWzFdICsgZWxlbSArIHdyYXBbMl07XG5cblx0XHRcdFx0XHQvLyBNb3ZlIHRvIHRoZSByaWdodCBkZXB0aFxuXHRcdFx0XHRcdHdoaWxlICggZGVwdGgtLSApIHtcblx0XHRcdFx0XHRcdGRpdiA9IGRpdi5sYXN0Q2hpbGQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUmVtb3ZlIElFJ3MgYXV0b2luc2VydGVkIDx0Ym9keT4gZnJvbSB0YWJsZSBmcmFnbWVudHNcblx0XHRcdFx0XHRpZiAoICFqUXVlcnkuc3VwcG9ydC50Ym9keSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3RyaW5nIHdhcyBhIDx0YWJsZT4sICptYXkqIGhhdmUgc3B1cmlvdXMgPHRib2R5PlxuXHRcdFx0XHRcdFx0dmFyIGhhc0JvZHkgPSBydGJvZHkudGVzdChlbGVtKSxcblx0XHRcdFx0XHRcdFx0dGJvZHkgPSB0YWcgPT09IFwidGFibGVcIiAmJiAhaGFzQm9keSA/XG5cdFx0XHRcdFx0XHRcdFx0ZGl2LmZpcnN0Q2hpbGQgJiYgZGl2LmZpcnN0Q2hpbGQuY2hpbGROb2RlcyA6XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdHJpbmcgd2FzIGEgYmFyZSA8dGhlYWQ+IG9yIDx0Zm9vdD5cblx0XHRcdFx0XHRcdFx0XHR3cmFwWzFdID09PSBcIjx0YWJsZT5cIiAmJiAhaGFzQm9keSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRkaXYuY2hpbGROb2RlcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRbXTtcblxuXHRcdFx0XHRcdFx0Zm9yICggaiA9IHRib2R5Lmxlbmd0aCAtIDE7IGogPj0gMCA7IC0taiApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkubm9kZU5hbWUoIHRib2R5WyBqIF0sIFwidGJvZHlcIiApICYmICF0Ym9keVsgaiBdLmNoaWxkTm9kZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRcdHRib2R5WyBqIF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGJvZHlbIGogXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gSUUgY29tcGxldGVseSBraWxscyBsZWFkaW5nIHdoaXRlc3BhY2Ugd2hlbiBpbm5lckhUTUwgaXMgdXNlZFxuXHRcdFx0XHRcdGlmICggIWpRdWVyeS5zdXBwb3J0LmxlYWRpbmdXaGl0ZXNwYWNlICYmIHJsZWFkaW5nV2hpdGVzcGFjZS50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0XHRkaXYuaW5zZXJ0QmVmb3JlKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBybGVhZGluZ1doaXRlc3BhY2UuZXhlYyhlbGVtKVswXSApLCBkaXYuZmlyc3RDaGlsZCApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSBkaXYuY2hpbGROb2RlcztcblxuXHRcdFx0XHRcdC8vIENsZWFyIGVsZW1lbnRzIGZyb20gRG9jdW1lbnRGcmFnbWVudCAoc2FmZUZyYWdtZW50IG9yIG90aGVyd2lzZSlcblx0XHRcdFx0XHQvLyB0byBhdm9pZCBob2FyZGluZyBlbGVtZW50cy4gRml4ZXMgIzExMzU2XG5cdFx0XHRcdFx0aWYgKCBkaXYgKSB7XG5cdFx0XHRcdFx0XHRkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZGl2ICk7XG5cblx0XHRcdFx0XHRcdC8vIEd1YXJkIGFnYWluc3QgLTEgaW5kZXggZXhjZXB0aW9ucyBpbiBGRjMuNlxuXHRcdFx0XHRcdFx0aWYgKCBzYWZlQ2hpbGROb2Rlcy5sZW5ndGggPiAwICkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmUgPSBzYWZlQ2hpbGROb2Rlc1sgc2FmZUNoaWxkTm9kZXMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggcmVtb3ZlICYmIHJlbW92ZS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlbW92ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCByZW1vdmUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNldHMgZGVmYXVsdENoZWNrZWQgZm9yIGFueSByYWRpb3MgYW5kIGNoZWNrYm94ZXNcblx0XHRcdC8vIGFib3V0IHRvIGJlIGFwcGVuZGVkIHRvIHRoZSBET00gaW4gSUUgNi83ICgjODA2MClcblx0XHRcdHZhciBsZW47XG5cdFx0XHRpZiAoICFqUXVlcnkuc3VwcG9ydC5hcHBlbmRDaGVja2VkICkge1xuXHRcdFx0XHRpZiAoIGVsZW1bMF0gJiYgdHlwZW9mIChsZW4gPSBlbGVtLmxlbmd0aCkgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRcdGZpbmRJbnB1dHMoIGVsZW1bal0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZmluZElucHV0cyggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSApIHtcblx0XHRcdFx0cmV0LnB1c2goIGVsZW0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldCA9IGpRdWVyeS5tZXJnZSggcmV0LCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmcmFnbWVudCApIHtcblx0XHRcdGNoZWNrU2NyaXB0VHlwZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gIWVsZW0udHlwZSB8fCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgKTtcblx0XHRcdH07XG5cdFx0XHRmb3IgKCBpID0gMDsgcmV0W2ldOyBpKysgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IHJldFtpXTtcblx0XHRcdFx0aWYgKCBzY3JpcHRzICYmIGpRdWVyeS5ub2RlTmFtZSggc2NyaXB0LCBcInNjcmlwdFwiICkgJiYgKCFzY3JpcHQudHlwZSB8fCByc2NyaXB0VHlwZS50ZXN0KCBzY3JpcHQudHlwZSApKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIHNjcmlwdC5wYXJlbnROb2RlID8gc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApIDogc2NyaXB0ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIHNjcmlwdC5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHZhciBqc1RhZ3MgPSBqUXVlcnkuZ3JlcCggc2NyaXB0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInNjcmlwdFwiICksIGNoZWNrU2NyaXB0VHlwZSApO1xuXG5cdFx0XHRcdFx0XHRyZXQuc3BsaWNlLmFwcGx5KCByZXQsIFtpICsgMSwgMF0uY29uY2F0KCBqc1RhZ3MgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZCggc2NyaXB0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBpZCxcblx0XHRcdGNhY2hlID0galF1ZXJ5LmNhY2hlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0ZGVsZXRlRXhwYW5kbyA9IGpRdWVyeS5zdXBwb3J0LmRlbGV0ZUV4cGFuZG87XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGVsZW07IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlTmFtZSAmJiBqUXVlcnkubm9EYXRhW2VsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0gKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZCA9IGVsZW1bIGpRdWVyeS5leHBhbmRvIF07XG5cblx0XHRcdGlmICggaWQgKSB7XG5cdFx0XHRcdGRhdGEgPSBjYWNoZVsgaWQgXTtcblxuXHRcdFx0XHRpZiAoIGRhdGEgJiYgZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggdmFyIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTnVsbCB0aGUgRE9NIHJlZmVyZW5jZSB0byBhdm9pZCBJRTYvNy84IGxlYWsgKCM3MDU0KVxuXHRcdFx0XHRcdGlmICggZGF0YS5oYW5kbGUgKSB7XG5cdFx0XHRcdFx0XHRkYXRhLmhhbmRsZS5lbGVtID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGRlbGV0ZUV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGVsZW1bIGpRdWVyeS5leHBhbmRvIF07XG5cblx0XHRcdFx0fSBlbHNlIGlmICggZWxlbS5yZW1vdmVBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIGpRdWVyeS5leHBhbmRvICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGlkIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuXG5cblxudmFyIHJhbHBoYSA9IC9hbHBoYVxcKFteKV0qXFwpL2ksXG5cdHJvcGFjaXR5ID0gL29wYWNpdHk9KFteKV0qKS8sXG5cdC8vIGZpeGVkIGZvciBJRTksIHNlZSAjODM0NlxuXHRydXBwZXIgPSAvKFtBLVpdfF5tcykvZyxcblx0cm51bSA9IC9eW1xcLStdPyg/OlxcZCpcXC4pP1xcZCskL2ksXG5cdHJudW1ub25weCA9IC9eLT8oPzpcXGQqXFwuKT9cXGQrKD8hcHgpW15cXGRcXHNdKyQvaSxcblx0cnJlbE51bSA9IC9eKFtcXC0rXSk9KFtcXC0rLlxcZGVdKykvLFxuXHRybWFyZ2luID0gL15tYXJnaW4vLFxuXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXG5cdC8vIG9yZGVyIGlzIGltcG9ydGFudCFcblx0Y3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF0sXG5cblx0Y3VyQ1NTLFxuXG5cdGdldENvbXB1dGVkU3R5bGUsXG5cdGN1cnJlbnRTdHlsZTtcblxualF1ZXJ5LmZuLmNzcyA9IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0cmV0dXJuIGpRdWVyeS5hY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcbn07XG5cbmpRdWVyeS5leHRlbmQoe1xuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLnN0eWxlLm9wYWNpdHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRXhjbHVkZSB0aGUgZm9sbG93aW5nIGNzcyBwcm9wZXJ0aWVzIHRvIGFkZCBweFxuXHRjc3NOdW1iZXI6IHtcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7XG5cdFx0Ly8gbm9ybWFsaXplIGZsb2F0IGNzcyBwcm9wZXJ0eVxuXHRcdFwiZmxvYXRcIjogalF1ZXJ5LnN1cHBvcnQuY3NzRmxvYXQgPyBcImNzc0Zsb2F0XCIgOiBcInN0eWxlRmxvYXRcIlxuXHR9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlLCBob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHwgb3JpZ05hbWU7XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBjb252ZXJ0IHJlbGF0aXZlIG51bWJlciBzdHJpbmdzICgrPSBvciAtPSkgdG8gcmVsYXRpdmUgbnVtYmVycy4gIzczNDVcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAocmV0ID0gcnJlbE51bS5leGVjKCB2YWx1ZSApKSApIHtcblx0XHRcdFx0dmFsdWUgPSAoICsoIHJldFsxXSArIDEpICogK3JldFsyXSApICsgcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApICk7XG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgTmFOIGFuZCBudWxsIHZhbHVlcyBhcmVuJ3Qgc2V0LiBTZWU6ICM3MTE2XG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdHlwZSA9PT0gXCJudW1iZXJcIiAmJiBpc05hTiggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgJ3B4JyB0byB0aGUgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSApIHtcblx0XHRcdFx0dmFsdWUgKz0gXCJweFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoXCJzZXRcIiBpbiBob29rcykgfHwgKHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQvLyBXcmFwcGVkIHRvIHByZXZlbnQgSUUgZnJvbSB0aHJvd2luZyBlcnJvcnMgd2hlbiAnaW52YWxpZCcgdmFsdWVzIGFyZSBwcm92aWRlZFxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzU1MDlcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdH0gY2F0Y2goZSkge31cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSApIHtcblx0XHR2YXIgcmV0LCBob29rcztcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICk7XG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gfHwgbmFtZTtcblxuXHRcdC8vIGNzc0Zsb2F0IG5lZWRzIGEgc3BlY2lhbCB0cmVhdG1lbnRcblx0XHRpZiAoIG5hbWUgPT09IFwiY3NzRmxvYXRcIiApIHtcblx0XHRcdG5hbWUgPSBcImZsb2F0XCI7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdH0gZWxzZSBpZiAoIGN1ckNTUyApIHtcblx0XHRcdHJldHVybiBjdXJDU1MoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQSBtZXRob2QgZm9yIHF1aWNrbHkgc3dhcHBpbmcgaW4vb3V0IENTUyBwcm9wZXJ0aWVzIHRvIGdldCBjb3JyZWN0IGNhbGN1bGF0aW9uc1xuXHRzd2FwOiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIG9sZCA9IHt9LFxuXHRcdFx0cmV0LCBuYW1lO1xuXG5cdFx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0cmV0ID0gY2FsbGJhY2suY2FsbCggZWxlbSApO1xuXG5cdFx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fVxufSk7XG5cbi8vIERFUFJFQ0FURUQgaW4gMS4zLCBVc2UgalF1ZXJ5LmNzcygpIGluc3RlYWRcbmpRdWVyeS5jdXJDU1MgPSBqUXVlcnkuY3NzO1xuXG5pZiAoIGRvY3VtZW50LmRlZmF1bHRWaWV3ICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUgKSB7XG5cdGdldENvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHR2YXIgcmV0LCBkZWZhdWx0VmlldywgY29tcHV0ZWRTdHlsZSwgd2lkdGgsXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKCBydXBwZXIsIFwiLSQxXCIgKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAoZGVmYXVsdFZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmXG5cdFx0XHRcdChjb21wdXRlZFN0eWxlID0gZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSwgbnVsbCApKSApIHtcblxuXHRcdFx0cmV0ID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICk7XG5cdFx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBXZWJLaXQgdXNlcyBcImNvbXB1dGVkIHZhbHVlIChwZXJjZW50YWdlIGlmIHNwZWNpZmllZClcIiBpbnN0ZWFkIG9mIFwidXNlZCB2YWx1ZVwiIGZvciBtYXJnaW5zXG5cdFx0Ly8gd2hpY2ggaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzogaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIWpRdWVyeS5zdXBwb3J0LnBpeGVsTWFyZ2luICYmIGNvbXB1dGVkU3R5bGUgJiYgcm1hcmdpbi50ZXN0KCBuYW1lICkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICkge1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWRTdHlsZS53aWR0aDtcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn1cblxuaWYgKCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY3VycmVudFN0eWxlICkge1xuXHRjdXJyZW50U3R5bGUgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHR2YXIgbGVmdCwgcnNMZWZ0LCB1bmNvbXB1dGVkLFxuXHRcdFx0cmV0ID0gZWxlbS5jdXJyZW50U3R5bGUgJiYgZWxlbS5jdXJyZW50U3R5bGVbIG5hbWUgXSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdC8vIEF2b2lkIHNldHRpbmcgcmV0IHRvIGVtcHR5IHN0cmluZyBoZXJlXG5cdFx0Ly8gc28gd2UgZG9uJ3QgZGVmYXVsdCB0byBhdXRvXG5cdFx0aWYgKCByZXQgPT0gbnVsbCAmJiBzdHlsZSAmJiAodW5jb21wdXRlZCA9IHN0eWxlWyBuYW1lIF0pICkge1xuXHRcdFx0cmV0ID0gdW5jb21wdXRlZDtcblx0XHR9XG5cblx0XHQvLyBGcm9tIHRoZSBhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXG5cdFx0Ly8gaHR0cDovL2VyaWsuZWFlLm5ldC9hcmNoaXZlcy8yMDA3LzA3LzI3LzE4LjU0LjE1LyNjb21tZW50LTEwMjI5MVxuXG5cdFx0Ly8gSWYgd2UncmUgbm90IGRlYWxpbmcgd2l0aCBhIHJlZ3VsYXIgcGl4ZWwgbnVtYmVyXG5cdFx0Ly8gYnV0IGEgbnVtYmVyIHRoYXQgaGFzIGEgd2VpcmQgZW5kaW5nLCB3ZSBuZWVkIHRvIGNvbnZlcnQgaXQgdG8gcGl4ZWxzXG5cdFx0aWYgKCBybnVtbm9ucHgudGVzdCggcmV0ICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdGxlZnQgPSBzdHlsZS5sZWZ0O1xuXHRcdFx0cnNMZWZ0ID0gZWxlbS5ydW50aW1lU3R5bGUgJiYgZWxlbS5ydW50aW1lU3R5bGUubGVmdDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0aWYgKCByc0xlZnQgKSB7XG5cdFx0XHRcdGVsZW0ucnVudGltZVN0eWxlLmxlZnQgPSBlbGVtLmN1cnJlbnRTdHlsZS5sZWZ0O1xuXHRcdFx0fVxuXHRcdFx0c3R5bGUubGVmdCA9IG5hbWUgPT09IFwiZm9udFNpemVcIiA/IFwiMWVtXCIgOiByZXQ7XG5cdFx0XHRyZXQgPSBzdHlsZS5waXhlbExlZnQgKyBcInB4XCI7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLmxlZnQgPSBsZWZ0O1xuXHRcdFx0aWYgKCByc0xlZnQgKSB7XG5cdFx0XHRcdGVsZW0ucnVudGltZVN0eWxlLmxlZnQgPSByc0xlZnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiYXV0b1wiIDogcmV0O1xuXHR9O1xufVxuXG5jdXJDU1MgPSBnZXRDb21wdXRlZFN0eWxlIHx8IGN1cnJlbnRTdHlsZTtcblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBvZmZzZXQgcHJvcGVydHlcblx0dmFyIHZhbCA9IG5hbWUgPT09IFwid2lkdGhcIiA/IGVsZW0ub2Zmc2V0V2lkdGggOiBlbGVtLm9mZnNldEhlaWdodCxcblx0XHRpID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0bGVuID0gNDtcblxuXHRpZiAoIHZhbCA+IDAgKSB7XG5cdFx0aWYgKCBleHRyYSAhPT0gXCJib3JkZXJcIiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSArPSAyICkge1xuXHRcdFx0XHRpZiAoICFleHRyYSApIHtcblx0XHRcdFx0XHR2YWwgLT0gcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSApICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRcdHZhbCArPSBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKCBlbGVtLCBleHRyYSArIGNzc0V4cGFuZFsgaSBdICkgKSB8fCAwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbCAtPSBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIgKSApIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsICsgXCJweFwiO1xuXHR9XG5cblx0Ly8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG5cdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSApO1xuXHRpZiAoIHZhbCA8IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0dmFsID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHR9XG5cblx0Ly8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cblx0aWYgKCBybnVtbm9ucHgudGVzdCh2YWwpICkge1xuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiwgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXG5cdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cblx0Ly8gQWRkIHBhZGRpbmcsIGJvcmRlciwgbWFyZ2luXG5cdGlmICggZXh0cmEgKSB7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpICs9IDIgKSB7XG5cdFx0XHR2YWwgKz0gcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSApICkgfHwgMDtcblx0XHRcdGlmICggZXh0cmEgIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHR2YWwgKz0gcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiICkgKSB8fCAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBleHRyYSA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0dmFsICs9IHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoIGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kWyBpIF0pICkgfHwgMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZWFjaChbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm9mZnNldFdpZHRoICE9PSAwICkge1xuXHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuc3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiBybnVtLnRlc3QoIHZhbHVlICkgP1xuXHRcdFx0XHR2YWx1ZSArIFwicHhcIiA6XG5cdFx0XHRcdHZhbHVlO1xuXHRcdH1cblx0fTtcbn0pO1xuXG5pZiAoICFqUXVlcnkuc3VwcG9ydC5vcGFjaXR5ICkge1xuXHRqUXVlcnkuY3NzSG9va3Mub3BhY2l0eSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdC8vIElFIHVzZXMgZmlsdGVycyBmb3Igb3BhY2l0eVxuXHRcdFx0cmV0dXJuIHJvcGFjaXR5LnRlc3QoIChjb21wdXRlZCAmJiBlbGVtLmN1cnJlbnRTdHlsZSA/IGVsZW0uY3VycmVudFN0eWxlLmZpbHRlciA6IGVsZW0uc3R5bGUuZmlsdGVyKSB8fCBcIlwiICkgP1xuXHRcdFx0XHQoIHBhcnNlRmxvYXQoIFJlZ0V4cC4kMSApIC8gMTAwICkgKyBcIlwiIDpcblx0XHRcdFx0Y29tcHV0ZWQgPyBcIjFcIiA6IFwiXCI7XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRcdFx0Y3VycmVudFN0eWxlID0gZWxlbS5jdXJyZW50U3R5bGUsXG5cdFx0XHRcdG9wYWNpdHkgPSBqUXVlcnkuaXNOdW1lcmljKCB2YWx1ZSApID8gXCJhbHBoYShvcGFjaXR5PVwiICsgdmFsdWUgKiAxMDAgKyBcIilcIiA6IFwiXCIsXG5cdFx0XHRcdGZpbHRlciA9IGN1cnJlbnRTdHlsZSAmJiBjdXJyZW50U3R5bGUuZmlsdGVyIHx8IHN0eWxlLmZpbHRlciB8fCBcIlwiO1xuXG5cdFx0XHQvLyBJRSBoYXMgdHJvdWJsZSB3aXRoIG9wYWNpdHkgaWYgaXQgZG9lcyBub3QgaGF2ZSBsYXlvdXRcblx0XHRcdC8vIEZvcmNlIGl0IGJ5IHNldHRpbmcgdGhlIHpvb20gbGV2ZWxcblx0XHRcdHN0eWxlLnpvb20gPSAxO1xuXG5cdFx0XHQvLyBpZiBzZXR0aW5nIG9wYWNpdHkgdG8gMSwgYW5kIG5vIG90aGVyIGZpbHRlcnMgZXhpc3QgLSBhdHRlbXB0IHRvIHJlbW92ZSBmaWx0ZXIgYXR0cmlidXRlICM2NjUyXG5cdFx0XHRpZiAoIHZhbHVlID49IDEgJiYgalF1ZXJ5LnRyaW0oIGZpbHRlci5yZXBsYWNlKCByYWxwaGEsIFwiXCIgKSApID09PSBcIlwiICkge1xuXG5cdFx0XHRcdC8vIFNldHRpbmcgc3R5bGUuZmlsdGVyIHRvIG51bGwsIFwiXCIgJiBcIiBcIiBzdGlsbCBsZWF2ZSBcImZpbHRlcjpcIiBpbiB0aGUgY3NzVGV4dFxuXHRcdFx0XHQvLyBpZiBcImZpbHRlcjpcIiBpcyBwcmVzZW50IGF0IGFsbCwgY2xlYXJUeXBlIGlzIGRpc2FibGVkLCB3ZSB3YW50IHRvIGF2b2lkIHRoaXNcblx0XHRcdFx0Ly8gc3R5bGUucmVtb3ZlQXR0cmlidXRlIGlzIElFIE9ubHksIGJ1dCBzbyBhcHBhcmVudGx5IGlzIHRoaXMgY29kZSBwYXRoLi4uXG5cdFx0XHRcdHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSggXCJmaWx0ZXJcIiApO1xuXG5cdFx0XHRcdC8vIGlmIHRoZXJlIHRoZXJlIGlzIG5vIGZpbHRlciBzdHlsZSBhcHBsaWVkIGluIGEgY3NzIHJ1bGUsIHdlIGFyZSBkb25lXG5cdFx0XHRcdGlmICggY3VycmVudFN0eWxlICYmICFjdXJyZW50U3R5bGUuZmlsdGVyICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBvdGhlcndpc2UsIHNldCBuZXcgZmlsdGVyIHZhbHVlc1xuXHRcdFx0c3R5bGUuZmlsdGVyID0gcmFscGhhLnRlc3QoIGZpbHRlciApID9cblx0XHRcdFx0ZmlsdGVyLnJlcGxhY2UoIHJhbHBoYSwgb3BhY2l0eSApIDpcblx0XHRcdFx0ZmlsdGVyICsgXCIgXCIgKyBvcGFjaXR5O1xuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5KGZ1bmN0aW9uKCkge1xuXHQvLyBUaGlzIGhvb2sgY2Fubm90IGJlIGFkZGVkIHVudGlsIERPTSByZWFkeSBiZWNhdXNlIHRoZSBzdXBwb3J0IHRlc3Rcblx0Ly8gZm9yIGl0IGlzIG5vdCBydW4gdW50aWwgYWZ0ZXIgRE9NIHJlYWR5XG5cdGlmICggIWpRdWVyeS5zdXBwb3J0LnJlbGlhYmxlTWFyZ2luUmlnaHQgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzLm1hcmdpblJpZ2h0ID0ge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdC8vIFdlYktpdCBCdWcgMTMzNDMgLSBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgd3JvbmcgdmFsdWUgZm9yIG1hcmdpbi1yaWdodFxuXHRcdFx0XHQvLyBXb3JrIGFyb3VuZCBieSB0ZW1wb3JhcmlseSBzZXR0aW5nIGVsZW1lbnQgZGlzcGxheSB0byBpbmxpbmUtYmxvY2tcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5zd2FwKCBlbGVtLCB7IFwiZGlzcGxheVwiOiBcImlubGluZS1ibG9ja1wiIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbi1yaWdodFwiICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnN0eWxlLm1hcmdpblJpZ2h0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSk7XG5cbmlmICggalF1ZXJ5LmV4cHIgJiYgalF1ZXJ5LmV4cHIuZmlsdGVycyApIHtcblx0alF1ZXJ5LmV4cHIuZmlsdGVycy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgd2lkdGggPSBlbGVtLm9mZnNldFdpZHRoLFxuXHRcdFx0aGVpZ2h0ID0gZWxlbS5vZmZzZXRIZWlnaHQ7XG5cblx0XHRyZXR1cm4gKCB3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDAgKSB8fCAoIWpRdWVyeS5zdXBwb3J0LnJlbGlhYmxlSGlkZGVuT2Zmc2V0cyAmJiAoKGVsZW0uc3R5bGUgJiYgZWxlbS5zdHlsZS5kaXNwbGF5KSB8fCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApKSA9PT0gXCJub25lXCIpO1xuXHR9O1xuXG5cdGpRdWVyeS5leHByLmZpbHRlcnMudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAhalF1ZXJ5LmV4cHIuZmlsdGVycy5oaWRkZW4oIGVsZW0gKTtcblx0fTtcbn1cblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goe1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpLFxuXG5cdFx0XHRcdC8vIGFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KFwiIFwiKSA6IFsgdmFsdWUgXSxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fTtcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG59KTtcblxuXG5cblxudmFyIHIyMCA9IC8lMjAvZyxcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopXFxyPyQvbWcsIC8vIElFIGxlYXZlcyBhbiBcXHIgY2hhcmFjdGVyIGF0IEVPTFxuXHRyaW5wdXQgPSAvXig/OmNvbG9yfGRhdGV8ZGF0ZXRpbWV8ZGF0ZXRpbWUtbG9jYWx8ZW1haWx8aGlkZGVufG1vbnRofG51bWJlcnxwYXNzd29yZHxyYW5nZXxzZWFyY2h8dGVsfHRleHR8dGltZXx1cmx8d2VlaykkL2ksXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcFxcLXN0b3JhZ2V8LitcXC1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblx0cnF1ZXJ5ID0gL1xcPy8sXG5cdHJzY3JpcHQgPSAvPHNjcmlwdFxcYltePF0qKD86KD8hPFxcL3NjcmlwdD4pPFtePF0qKSo8XFwvc2NyaXB0Pi9naSxcblx0cnNlbGVjdFRleHRhcmVhID0gL14oPzpzZWxlY3R8dGV4dGFyZWEpL2ksXG5cdHJzcGFjZXNBamF4ID0gL1xccysvLFxuXHRydHMgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJ1cmwgPSAvXihbXFx3XFwrXFwuXFwtXSs6KSg/OlxcL1xcLyhbXlxcLz8jOl0qKSg/OjooXFxkKykpPyk/LyxcblxuXHQvLyBLZWVwIGEgY29weSBvZiB0aGUgb2xkIGxvYWQgbWV0aG9kXG5cdF9sb2FkID0galF1ZXJ5LmZuLmxvYWQsXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gRG9jdW1lbnQgbG9jYXRpb25cblx0YWpheExvY2F0aW9uLFxuXG5cdC8vIERvY3VtZW50IGxvY2F0aW9uIHNlZ21lbnRzXG5cdGFqYXhMb2NQYXJ0cyxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBbXCIqL1wiXSArIFtcIipcIl07XG5cbi8vICM4MTM4LCBJRSBtYXkgdGhyb3cgYW4gZXhjZXB0aW9uIHdoZW4gYWNjZXNzaW5nXG4vLyBhIGZpZWxkIGZyb20gd2luZG93LmxvY2F0aW9uIGlmIGRvY3VtZW50LmRvbWFpbiBoYXMgYmVlbiBzZXRcbnRyeSB7XG5cdGFqYXhMb2NhdGlvbiA9IGxvY2F0aW9uLmhyZWY7XG59IGNhdGNoKCBlICkge1xuXHQvLyBVc2UgdGhlIGhyZWYgYXR0cmlidXRlIG9mIGFuIEEgZWxlbWVudFxuXHQvLyBzaW5jZSBJRSB3aWxsIG1vZGlmeSBpdCBnaXZlbiBkb2N1bWVudC5sb2NhdGlvblxuXHRhamF4TG9jYXRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRhamF4TG9jYXRpb24uaHJlZiA9IFwiXCI7XG5cdGFqYXhMb2NhdGlvbiA9IGFqYXhMb2NhdGlvbi5ocmVmO1xufVxuXG4vLyBTZWdtZW50IGxvY2F0aW9uIGludG8gcGFydHNcbmFqYXhMb2NQYXJ0cyA9IHJ1cmwuZXhlYyggYWpheExvY2F0aW9uLnRvTG93ZXJDYXNlKCkgKSB8fCBbXTtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkuc3BsaXQoIHJzcGFjZXNBamF4ICksXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBkYXRhVHlwZXMubGVuZ3RoLFxuXHRcdFx0XHRkYXRhVHlwZSxcblx0XHRcdFx0bGlzdCxcblx0XHRcdFx0cGxhY2VCZWZvcmU7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSBdO1xuXHRcdFx0XHQvLyBXZSBjb250cm9sIGlmIHdlJ3JlIGFza2VkIHRvIGFkZCBiZWZvcmVcblx0XHRcdFx0Ly8gYW55IGV4aXN0aW5nIGVsZW1lbnRcblx0XHRcdFx0cGxhY2VCZWZvcmUgPSAvXlxcKy8udGVzdCggZGF0YVR5cGUgKTtcblx0XHRcdFx0aWYgKCBwbGFjZUJlZm9yZSApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnN1YnN0ciggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QgPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW107XG5cdFx0XHRcdC8vIHRoZW4gd2UgYWRkIHRvIHRoZSBzdHJ1Y3R1cmUgYWNjb3JkaW5nbHlcblx0XHRcdFx0bGlzdFsgcGxhY2VCZWZvcmUgPyBcInVuc2hpZnRcIiA6IFwicHVzaFwiIF0oIGZ1bmMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUixcblx0XHRkYXRhVHlwZSAvKiBpbnRlcm5hbCAqLywgaW5zcGVjdGVkIC8qIGludGVybmFsICovICkge1xuXG5cdGRhdGFUeXBlID0gZGF0YVR5cGUgfHwgb3B0aW9ucy5kYXRhVHlwZXNbIDAgXTtcblx0aW5zcGVjdGVkID0gaW5zcGVjdGVkIHx8IHt9O1xuXG5cdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cblx0dmFyIGxpc3QgPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0sXG5cdFx0aSA9IDAsXG5cdFx0bGVuZ3RoID0gbGlzdCA/IGxpc3QubGVuZ3RoIDogMCxcblx0XHRleGVjdXRlT25seSA9ICggc3RydWN0dXJlID09PSBwcmVmaWx0ZXJzICksXG5cdFx0c2VsZWN0aW9uO1xuXG5cdGZvciAoIDsgaSA8IGxlbmd0aCAmJiAoIGV4ZWN1dGVPbmx5IHx8ICFzZWxlY3Rpb24gKTsgaSsrICkge1xuXHRcdHNlbGVjdGlvbiA9IGxpc3RbIGkgXSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdC8vIElmIHdlIGdvdCByZWRpcmVjdGVkIHRvIGFub3RoZXIgZGF0YVR5cGVcblx0XHQvLyB3ZSB0cnkgdGhlcmUgaWYgZXhlY3V0aW5nIG9ubHkgYW5kIG5vdCBkb25lIGFscmVhZHlcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3Rpb24gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoICFleGVjdXRlT25seSB8fCBpbnNwZWN0ZWRbIHNlbGVjdGlvbiBdICkge1xuXHRcdFx0XHRzZWxlY3Rpb24gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBzZWxlY3Rpb24gKTtcblx0XHRcdFx0c2VsZWN0aW9uID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoXG5cdFx0XHRcdFx0XHRzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIsIHNlbGVjdGlvbiwgaW5zcGVjdGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vIElmIHdlJ3JlIG9ubHkgZXhlY3V0aW5nIG9yIG5vdGhpbmcgd2FzIHNlbGVjdGVkXG5cdC8vIHdlIHRyeSB0aGUgY2F0Y2hhbGwgZGF0YVR5cGUgaWYgbm90IGRvbmUgYWxyZWFkeVxuXHRpZiAoICggZXhlY3V0ZU9ubHkgfHwgIXNlbGVjdGlvbiApICYmICFpbnNwZWN0ZWRbIFwiKlwiIF0gKSB7XG5cdFx0c2VsZWN0aW9uID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoXG5cdFx0XHRcdHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiwgXCIqXCIsIGluc3BlY3RlZCApO1xuXHR9XG5cdC8vIHVubmVjZXNzYXJ5IHdoZW4gb25seSBleGVjdXRpbmcgKHByZWZpbHRlcnMpXG5cdC8vIGJ1dCBpdCdsbCBiZSBpZ25vcmVkIGJ5IHRoZSBjYWxsZXIgaW4gdGhhdCBjYXNlXG5cdHJldHVybiBzZWxlY3Rpb247XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cbn1cblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGxvYWQ6IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCB0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiICYmIF9sb2FkICkge1xuXHRcdFx0cmV0dXJuIF9sb2FkLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuXHRcdC8vIERvbid0IGRvIGEgcmVxdWVzdCBpZiBubyBlbGVtZW50cyBhcmUgYmVpbmcgcmVxdWVzdGVkXG5cdFx0fSBlbHNlIGlmICggIXRoaXMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dmFyIG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXHRcdGlmICggb2ZmID49IDAgKSB7XG5cdFx0XHR2YXIgc2VsZWN0b3IgPSB1cmwuc2xpY2UoIG9mZiwgdXJsLmxlbmd0aCApO1xuXHRcdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0XHR9XG5cblx0XHQvLyBEZWZhdWx0IHRvIGEgR0VUIHJlcXVlc3Rcblx0XHR2YXIgdHlwZSA9IFwiR0VUXCI7XG5cblx0XHQvLyBJZiB0aGUgc2Vjb25kIHBhcmFtZXRlciB3YXMgcHJvdmlkZWRcblx0XHRpZiAoIHBhcmFtcyApIHtcblx0XHRcdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cdFx0XHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdFx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRcdHBhcmFtcyA9IGpRdWVyeS5wYXJhbSggcGFyYW1zLCBqUXVlcnkuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsICk7XG5cdFx0XHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHQvLyBSZXF1ZXN0IHRoZSByZW1vdGUgZG9jdW1lbnRcblx0XHRqUXVlcnkuYWpheCh7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXMsXG5cdFx0XHQvLyBDb21wbGV0ZSBjYWxsYmFjayAocmVzcG9uc2VUZXh0IGlzIHVzZWQgaW50ZXJuYWxseSlcblx0XHRcdGNvbXBsZXRlOiBmdW5jdGlvbigganFYSFIsIHN0YXR1cywgcmVzcG9uc2VUZXh0ICkge1xuXHRcdFx0XHQvLyBTdG9yZSB0aGUgcmVzcG9uc2UgYXMgc3BlY2lmaWVkIGJ5IHRoZSBqcVhIUiBvYmplY3Rcblx0XHRcdFx0cmVzcG9uc2VUZXh0ID0ganFYSFIucmVzcG9uc2VUZXh0O1xuXHRcdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBpbmplY3QgdGhlIEhUTUwgaW50byBhbGwgdGhlIG1hdGNoZWQgZWxlbWVudHNcblx0XHRcdFx0aWYgKCBqcVhIUi5pc1Jlc29sdmVkKCkgKSB7XG5cdFx0XHRcdFx0Ly8gIzQ4MjU6IEdldCB0aGUgYWN0dWFsIHJlc3BvbnNlIGluIGNhc2Vcblx0XHRcdFx0XHQvLyBhIGRhdGFGaWx0ZXIgaXMgcHJlc2VudCBpbiBhamF4U2V0dGluZ3Ncblx0XHRcdFx0XHRqcVhIUi5kb25lKGZ1bmN0aW9uKCByICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2VUZXh0ID0gcjtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHQvLyBTZWUgaWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkXG5cdFx0XHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cdFx0XHRcdFx0XHQvLyBDcmVhdGUgYSBkdW1teSBkaXYgdG8gaG9sZCB0aGUgcmVzdWx0c1xuXHRcdFx0XHRcdFx0alF1ZXJ5KFwiPGRpdj5cIilcblx0XHRcdFx0XHRcdFx0Ly8gaW5qZWN0IHRoZSBjb250ZW50cyBvZiB0aGUgZG9jdW1lbnQgaW4sIHJlbW92aW5nIHRoZSBzY3JpcHRzXG5cdFx0XHRcdFx0XHRcdC8vIHRvIGF2b2lkIGFueSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9ycyBpbiBJRVxuXHRcdFx0XHRcdFx0XHQuYXBwZW5kKHJlc3BvbnNlVGV4dC5yZXBsYWNlKHJzY3JpcHQsIFwiXCIpKVxuXG5cdFx0XHRcdFx0XHRcdC8vIExvY2F0ZSB0aGUgc3BlY2lmaWVkIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdC5maW5kKHNlbGVjdG9yKSA6XG5cblx0XHRcdFx0XHRcdC8vIElmIG5vdCwganVzdCBpbmplY3QgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0c2VsZi5lYWNoKCBjYWxsYmFjaywgWyByZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggdGhpcy5lbGVtZW50cyApIDogdGhpcztcblx0XHR9KVxuXHRcdC5maWx0ZXIoZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIXRoaXMuZGlzYWJsZWQgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgcnNlbGVjdFRleHRhcmVhLnRlc3QoIHRoaXMubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJpbnB1dC50ZXN0KCB0aGlzLnR5cGUgKSApO1xuXHRcdH0pXG5cdFx0Lm1hcChmdW5jdGlvbiggaSwgZWxlbSApe1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRyZXR1cm4gdmFsID09IG51bGwgP1xuXHRcdFx0XHRudWxsIDpcblx0XHRcdFx0alF1ZXJ5LmlzQXJyYXkoIHZhbCApID9cblx0XHRcdFx0XHRqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwsIGkgKXtcblx0XHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9KS5nZXQoKTtcblx0fVxufSk7XG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggXCJhamF4U3RhcnQgYWpheFN0b3AgYWpheENvbXBsZXRlIGFqYXhFcnJvciBhamF4U3VjY2VzcyBhamF4U2VuZFwiLnNwbGl0KCBcIiBcIiApLCBmdW5jdGlvbiggaSwgbyApe1xuXHRqUXVlcnkuZm5bIG8gXSA9IGZ1bmN0aW9uKCBmICl7XG5cdFx0cmV0dXJuIHRoaXMub24oIG8sIGYgKTtcblx0fTtcbn0pO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cdFx0Ly8gc2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KHtcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGVcblx0XHR9KTtcblx0fTtcbn0pO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0aWYgKCBzZXR0aW5ncyApIHtcblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0c2V0dGluZ3MgPSB0YXJnZXQ7XG5cdFx0XHR0YXJnZXQgPSBqUXVlcnkuYWpheFNldHRpbmdzO1xuXHRcdH1cblx0XHRhamF4RXh0ZW5kKCB0YXJnZXQsIHNldHRpbmdzICk7XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGFqYXhMb2NhdGlvbixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBhamF4TG9jUGFydHNbIDEgXSApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCIsXG5cdFx0XHRcIipcIjogYWxsVHlwZXNcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL3htbC8sXG5cdFx0XHRodG1sOiAvaHRtbC8sXG5cdFx0XHRqc29uOiAvanNvbi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIlxuXHRcdH0sXG5cblx0XHQvLyBMaXN0IG9mIGRhdGEgY29udmVydGVyc1xuXHRcdC8vIDEpIGtleSBmb3JtYXQgaXMgXCJzb3VyY2VfdHlwZSBkZXN0aW5hdGlvbl90eXBlXCIgKGEgc2luZ2xlIHNwYWNlIGluLWJldHdlZW4pXG5cdFx0Ly8gMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZCBmb3Igc291cmNlX3R5cGVcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogd2luZG93LlN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBqUXVlcnkucGFyc2VKU09OLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0Y29udGV4dDogdHJ1ZSxcblx0XHRcdHVybDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50c1xuXHRcdFx0Ly8gSXQncyB0aGUgY2FsbGJhY2tDb250ZXh0IGlmIG9uZSB3YXMgcHJvdmlkZWQgaW4gdGhlIG9wdGlvbnNcblx0XHRcdC8vIGFuZCBpZiBpdCdzIGEgRE9NIG5vZGUgb3IgYSBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gY2FsbGJhY2tDb250ZXh0ICE9PSBzICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSApID9cblx0XHRcdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOiBqUXVlcnkuZXZlbnQsXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblx0XHRcdC8vIGlmTW9kaWZpZWQga2V5XG5cdFx0XHRpZk1vZGlmaWVkS2V5LFxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cdFx0XHQvLyB0cmFuc3BvcnRcblx0XHRcdHRyYW5zcG9ydCxcblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cdFx0XHQvLyBDcm9zcy1kb21haW4gZGV0ZWN0aW9uIHZhcnNcblx0XHRcdHBhcnRzLFxuXHRcdFx0Ly8gVGhlIGpxWEhSIHN0YXRlXG5cdFx0XHRzdGF0ZSA9IDAsXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblxuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdHZhciBsbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlID09PSAyID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG1hdGNoO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggIXN0YXRlICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHN0YXR1c1RleHQgfHwgXCJhYm9ydFwiO1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBzdGF0dXNUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIHN0YXR1c1RleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdC8vIEl0IGlzIGRlZmluZWQgaGVyZSBiZWNhdXNlIGpzbGludCBjb21wbGFpbnMgaWYgaXQgaXMgZGVjbGFyZWRcblx0XHQvLyBhdCB0aGUgZW5kIG9mIHRoZSBmdW5jdGlvbiAod2hpY2ggd291bGQgYmUgbW9yZSBsb2dpY2FsIGFuZCByZWFkYWJsZSlcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblxuXHRcdFx0Ly8gQ2FsbGVkIG9uY2Vcblx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdGUgaXMgXCJkb25lXCIgbm93XG5cdFx0XHRzdGF0ZSA9IDI7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdHZhciBpc1N1Y2Nlc3MsXG5cdFx0XHRcdHN1Y2Nlc3MsXG5cdFx0XHRcdGVycm9yLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dCxcblx0XHRcdFx0cmVzcG9uc2UgPSByZXNwb25zZXMgPyBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkgOiB1bmRlZmluZWQsXG5cdFx0XHRcdGxhc3RNb2RpZmllZCxcblx0XHRcdFx0ZXRhZztcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cblx0XHRcdFx0XHRpZiAoICggbGFzdE1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICkgKSApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGlmTW9kaWZpZWRLZXkgXSA9IGxhc3RNb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCAoIGV0YWcgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJFdGFnXCIgKSApICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGlmTW9kaWZpZWRLZXkgXSA9IGV0YWc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0c3VjY2VzcyA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwic3VjY2Vzc1wiO1xuXHRcdFx0XHRcdFx0aXNTdWNjZXNzID0gdHJ1ZTtcblx0XHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRcdC8vIFdlIGhhdmUgYSBwYXJzZXJlcnJvclxuXHRcdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwicGFyc2VyZXJyb3JcIjtcblx0XHRcdFx0XHRcdGVycm9yID0gZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdlIGV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0XG5cdFx0XHRcdC8vIHRoZW4gbm9ybWFsaXplIHN0YXR1c1RleHQgYW5kIHN0YXR1cyBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggIXN0YXR1c1RleHQgfHwgc3RhdHVzICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSBcIlwiICsgKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKTtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4XCIgKyAoIGlzU3VjY2VzcyA/IFwiU3VjY2Vzc1wiIDogXCJFcnJvclwiICksXG5cdFx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblx0XHRqcVhIUi5zdWNjZXNzID0ganFYSFIuZG9uZTtcblx0XHRqcVhIUi5lcnJvciA9IGpxWEhSLmZhaWw7XG5cdFx0anFYSFIuY29tcGxldGUgPSBjb21wbGV0ZURlZmVycmVkLmFkZDtcblxuXHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0anFYSFIuc3RhdHVzQ29kZSA9IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0dmFyIHRtcDtcblx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0Zm9yICggdG1wIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIHRtcCBdID0gWyBzdGF0dXNDb2RlW3RtcF0sIG1hcFt0bXBdIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRtcCA9IG1hcFsganFYSFIuc3RhdHVzIF07XG5cdFx0XHRcdFx0anFYSFIudGhlbiggdG1wLCB0bXAgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdC8vIFJlbW92ZSBoYXNoIGNoYXJhY3RlciAoIzc1MzE6IGFuZCBzdHJpbmcgcHJvbW90aW9uKVxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKCM1ODY2OiBJRTcgaXNzdWUgd2l0aCBwcm90b2NvbC1sZXNzIHVybHMpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsICkgKyBcIlwiICkucmVwbGFjZSggcmhhc2gsIFwiXCIgKS5yZXBsYWNlKCBycHJvdG9jb2wsIGFqYXhMb2NQYXJ0c1sgMSBdICsgXCIvL1wiICk7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSBqUXVlcnkudHJpbSggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkuc3BsaXQoIHJzcGFjZXNBamF4ICk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgYSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlclxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0cGFydHMgPSBydXJsLmV4ZWMoIHMudXJsLnRvTG93ZXJDYXNlKCkgKTtcblx0XHRcdHMuY3Jvc3NEb21haW4gPSAhISggcGFydHMgJiZcblx0XHRcdFx0KCBwYXJ0c1sgMSBdICE9IGFqYXhMb2NQYXJ0c1sgMSBdIHx8IHBhcnRzWyAyIF0gIT0gYWpheExvY1BhcnRzWyAyIF0gfHxcblx0XHRcdFx0XHQoIHBhcnRzWyAzIF0gfHwgKCBwYXJ0c1sgMSBdID09PSBcImh0dHA6XCIgPyA4MCA6IDQ0MyApICkgIT1cblx0XHRcdFx0XHRcdCggYWpheExvY1BhcnRzWyAzIF0gfHwgKCBhamF4TG9jUGFydHNbIDEgXSA9PT0gXCJodHRwOlwiID8gODAgOiA0NDMgKSApIClcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHRmaXJlR2xvYmFscyA9IHMuZ2xvYmFsO1xuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgKSB7XG5cdFx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR2V0IGlmTW9kaWZpZWRLZXkgYmVmb3JlIGFkZGluZyB0aGUgYW50aS1jYWNoZSBwYXJhbWV0ZXJcblx0XHRcdGlmTW9kaWZpZWRLZXkgPSBzLnVybDtcblxuXHRcdFx0Ly8gQWRkIGFudGktY2FjaGUgaW4gdXJsIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHR2YXIgdHMgPSBqUXVlcnkubm93KCksXG5cdFx0XHRcdFx0Ly8gdHJ5IHJlcGxhY2luZyBfPSBpZiBpdCBpcyB0aGVyZVxuXHRcdFx0XHRcdHJldCA9IHMudXJsLnJlcGxhY2UoIHJ0cywgXCIkMV89XCIgKyB0cyApO1xuXG5cdFx0XHRcdC8vIGlmIG5vdGhpbmcgd2FzIHJlcGxhY2VkLCBhZGQgdGltZXN0YW1wIHRvIHRoZSBlbmRcblx0XHRcdFx0cy51cmwgPSByZXQgKyAoICggcmV0ID09PSBzLnVybCApID8gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArIHRzIDogXCJcIiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZk1vZGlmaWVkS2V5ID0gaWZNb2RpZmllZEtleSB8fCBzLnVybDtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgaWZNb2RpZmllZEtleSBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGlmTW9kaWZpZWRLZXkgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgaWZNb2RpZmllZEtleSBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGlmTW9kaWZpZWRLZXkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1swXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1swXSBdICsgKCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiYgKCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBzdGF0ZSA9PT0gMiApICkge1xuXHRcdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5XG5cdFx0XHRcdGpxWEhSLmFib3J0KCk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGZvciAoIGkgaW4geyBzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDEgfSApIHtcblx0XHRcdGpxWEhSWyBpIF0oIHNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzdGF0ZSA9IDE7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHQvLyBQcm9wYWdhdGUgZXhjZXB0aW9uIGFzIGVycm9yIGlmIG5vdCBkb25lXG5cdFx0XHRcdGlmICggc3RhdGUgPCAyICkge1xuXHRcdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHRcdC8vIFNpbXBseSByZXRocm93IG90aGVyd2lzZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Ly8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcblx0Ly8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5cdHBhcmFtOiBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdFx0dmFyIHMgPSBbXSxcblx0XHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSA/IHZhbHVlKCkgOiB2YWx1ZTtcblx0XHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBTZXQgdHJhZGl0aW9uYWwgdG8gdHJ1ZSBmb3IgalF1ZXJ5IDw9IDEuMy4yIGJlaGF2aW9yLlxuXHRcdGlmICggdHJhZGl0aW9uYWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRyYWRpdGlvbmFsID0galF1ZXJ5LmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbDtcblx0XHR9XG5cblx0XHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cdFx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHRcdH0pO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRcdGZvciAoIHZhciBwcmVmaXggaW4gYSApIHtcblx0XHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdFx0cmV0dXJuIHMuam9pbiggXCImXCIgKS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIG9iaiApICkge1xuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJZiBhcnJheSBpdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHNcblx0XHRcdFx0Ly8gbnVtZXJpYyBpbmRleCB0byByZXNvbHZlIGRlc2VyaWFsaXphdGlvbiBhbWJpZ3VpdHkgaXNzdWVzLlxuXHRcdFx0XHQvLyBOb3RlIHRoYXQgcmFjayAoYXMgb2YgMS4wLjApIGNhbid0IGN1cnJlbnRseSBkZXNlcmlhbGl6ZVxuXHRcdFx0XHQvLyBuZXN0ZWQgYXJyYXlzIHByb3Blcmx5LCBhbmQgYXR0ZW1wdGluZyB0byBkbyBzbyBtYXkgY2F1c2Vcblx0XHRcdFx0Ly8gYSBzZXJ2ZXIgZXJyb3IuIFBvc3NpYmxlIGZpeGVzIGFyZSB0byBtb2RpZnkgcmFjaydzXG5cdFx0XHRcdC8vIGRlc2VyaWFsaXphdGlvbiBhbGdvcml0aG0gb3IgdG8gcHJvdmlkZSBhbiBvcHRpb24gb3IgZmxhZ1xuXHRcdFx0XHQvLyB0byBmb3JjZSBhcnJheSBzZXJpYWxpemF0aW9uIHRvIGJlIHNoYWxsb3cuXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgPyBpIDogXCJcIiApICsgXCJdXCIsIHYsIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCB2YXIgbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBUaGlzIGlzIHN0aWxsIG9uIHRoZSBqUXVlcnkgb2JqZWN0Li4uIGZvciBub3dcbi8vIFdhbnQgdG8gbW92ZSB0aGlzIHRvIGpRdWVyeS5hamF4IHNvbWUgZGF5XG5qUXVlcnkuZXh0ZW5kKHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge31cblxufSk7XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gc2V0cyBhbGwgcmVzcG9uc2VYWFggZmllbGRzIGFjY29yZGluZ2x5XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcyxcblx0XHRyZXNwb25zZUZpZWxkcyA9IHMucmVzcG9uc2VGaWVsZHMsXG5cdFx0Y3QsXG5cdFx0dHlwZSxcblx0XHRmaW5hbERhdGFUeXBlLFxuXHRcdGZpcnN0RGF0YVR5cGU7XG5cblx0Ly8gRmlsbCByZXNwb25zZVhYWCBmaWVsZHNcblx0Zm9yICggdHlwZSBpbiByZXNwb25zZUZpZWxkcyApIHtcblx0XHRpZiAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0anFYSFJbIHJlc3BvbnNlRmllbGRzW3R5cGVdIF0gPSByZXNwb25zZXNbIHR5cGUgXTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJjb250ZW50LXR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWzBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8vIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSApIHtcblxuXHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRpZiAoIHMuZGF0YUZpbHRlciApIHtcblx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0fVxuXG5cdHZhciBkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcyxcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cdFx0aSxcblx0XHRrZXksXG5cdFx0bGVuZ3RoID0gZGF0YVR5cGVzLmxlbmd0aCxcblx0XHR0bXAsXG5cdFx0Ly8gQ3VycmVudCBhbmQgcHJldmlvdXMgZGF0YVR5cGVzXG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlc1sgMCBdLFxuXHRcdHByZXYsXG5cdFx0Ly8gQ29udmVyc2lvbiBleHByZXNzaW9uXG5cdFx0Y29udmVyc2lvbixcblx0XHQvLyBDb252ZXJzaW9uIGZ1bmN0aW9uXG5cdFx0Y29udixcblx0XHQvLyBDb252ZXJzaW9uIGZ1bmN0aW9ucyAodHJhbnNpdGl2ZSBjb252ZXJzaW9uKVxuXHRcdGNvbnYxLFxuXHRcdGNvbnYyO1xuXG5cdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBjaGFpblxuXHRmb3IgKCBpID0gMTsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwXG5cdFx0Ly8gd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0XHRpZiAoIGkgPT09IDEgKSB7XG5cdFx0XHRmb3IgKCBrZXkgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0Y29udmVydGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBHZXQgdGhlIGRhdGFUeXBlc1xuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXNbIGkgXTtcblxuXHRcdC8vIElmIGN1cnJlbnQgaXMgYXV0byBkYXRhVHlwZSwgdXBkYXRlIGl0IHRvIHByZXZcblx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXHRcdFx0Y3VycmVudCA9IHByZXY7XG5cdFx0Ly8gSWYgbm8gYXV0byBhbmQgZGF0YVR5cGVzIGFyZSBhY3R1YWxseSBkaWZmZXJlbnRcblx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBHZXQgdGhlIGNvbnZlcnRlclxuXHRcdFx0Y29udmVyc2lvbiA9IHByZXYgKyBcIiBcIiArIGN1cnJlbnQ7XG5cdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udmVyc2lvbiBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUgaXMgbm8gZGlyZWN0IGNvbnZlcnRlciwgc2VhcmNoIHRyYW5zaXRpdmVseVxuXHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0Y29udjIgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdGZvciAoIGNvbnYxIGluIGNvbnZlcnRlcnMgKSB7XG5cdFx0XHRcdFx0dG1wID0gY29udjEuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0aWYgKCB0bXBbIDAgXSA9PT0gcHJldiB8fCB0bXBbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdFx0XHRjb252MiA9IGNvbnZlcnRlcnNbIHRtcFsxXSArIFwiIFwiICsgY3VycmVudCBdO1xuXHRcdFx0XHRcdFx0aWYgKCBjb252MiApIHtcblx0XHRcdFx0XHRcdFx0Y29udjEgPSBjb252ZXJ0ZXJzWyBjb252MSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYxID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252Mjtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udjIgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnYxO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgd2UgZm91bmQgbm8gY29udmVydGVyLCBkaXNwYXRjaCBhbiBlcnJvclxuXHRcdFx0aWYgKCAhKCBjb252IHx8IGNvbnYyICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBjb252ZXJzaW9uLnJlcGxhY2UoXCIgXCIsXCIgdG8gXCIpICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiBmb3VuZCBjb252ZXJ0ZXIgaXMgbm90IGFuIGVxdWl2YWxlbmNlXG5cdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cdFx0XHRcdC8vIENvbnZlcnQgd2l0aCAxIG9yIDIgY29udmVydGVycyBhY2NvcmRpbmdseVxuXHRcdFx0XHRyZXNwb25zZSA9IGNvbnYgPyBjb252KCByZXNwb25zZSApIDogY29udjIoIGNvbnYxKHJlc3BvbnNlKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVzcG9uc2U7XG59XG5cblxuXG5cbnZhciBqc2MgPSBqUXVlcnkubm93KCksXG5cdGpzcmUgPSAvKFxcPSlcXD8oJnwkKXxcXD9cXD8vaTtcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCh7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBqc2MrKyApO1xuXHR9XG59KTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdERhdGEgPSAoIHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgKSAmJiAvXmFwcGxpY2F0aW9uXFwveFxcLXd3d1xcLWZvcm1cXC11cmxlbmNvZGVkLy50ZXN0KCBzLmNvbnRlbnRUeXBlICk7XG5cblx0aWYgKCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgfHxcblx0XHRzLmpzb25wICE9PSBmYWxzZSAmJiAoIGpzcmUudGVzdCggcy51cmwgKSB8fFxuXHRcdFx0XHRpbnNwZWN0RGF0YSAmJiBqc3JlLnRlc3QoIHMuZGF0YSApICkgKSB7XG5cblx0XHR2YXIgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0XHRqc29ucENhbGxiYWNrID0gcy5qc29ucENhbGxiYWNrID1cblx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID8gcy5qc29ucENhbGxiYWNrKCkgOiBzLmpzb25wQ2FsbGJhY2ssXG5cdFx0XHRwcmV2aW91cyA9IHdpbmRvd1sganNvbnBDYWxsYmFjayBdLFxuXHRcdFx0dXJsID0gcy51cmwsXG5cdFx0XHRkYXRhID0gcy5kYXRhLFxuXHRcdFx0cmVwbGFjZSA9IFwiJDFcIiArIGpzb25wQ2FsbGJhY2sgKyBcIiQyXCI7XG5cblx0XHRpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0dXJsID0gdXJsLnJlcGxhY2UoIGpzcmUsIHJlcGxhY2UgKTtcblx0XHRcdGlmICggcy51cmwgPT09IHVybCApIHtcblx0XHRcdFx0aWYgKCBpbnNwZWN0RGF0YSApIHtcblx0XHRcdFx0XHRkYXRhID0gZGF0YS5yZXBsYWNlKCBqc3JlLCByZXBsYWNlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBzLmRhdGEgPT09IGRhdGEgKSB7XG5cdFx0XHRcdFx0Ly8gQWRkIGNhbGxiYWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0dXJsICs9ICgvXFw/Ly50ZXN0KCB1cmwgKSA/IFwiJlwiIDogXCI/XCIpICsgcy5qc29ucCArIFwiPVwiICsganNvbnBDYWxsYmFjaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHMudXJsID0gdXJsO1xuXHRcdHMuZGF0YSA9IGRhdGE7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0d2luZG93WyBqc29ucENhbGxiYWNrIF0gPSBmdW5jdGlvbiggcmVzcG9uc2UgKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IFsgcmVzcG9uc2UgXTtcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb25cblx0XHRqcVhIUi5hbHdheXMoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBTZXQgY2FsbGJhY2sgYmFjayB0byBwcmV2aW91cyB2YWx1ZVxuXHRcdFx0d2luZG93WyBqc29ucENhbGxiYWNrIF0gPSBwcmV2aW91cztcblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcHJldmlvdXMgKSApIHtcblx0XHRcdFx0d2luZG93WyBqc29ucENhbGxiYWNrIF0oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbXCJzY3JpcHQganNvblwiXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvcigganNvbnBDYWxsYmFjayArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBmb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0pO1xuXG5cblxuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCh7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL2phdmFzY3JpcHR8ZWNtYXNjcmlwdC9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBnbG9iYWxcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHRcdHMuZ2xvYmFsID0gZmFsc2U7XG5cdH1cbn0pO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbihzKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cblx0XHR2YXIgc2NyaXB0LFxuXHRcdFx0aGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiaGVhZFwiIClbMF0gfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNhbGxiYWNrICkge1xuXG5cdFx0XHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdFx0XHRzY3JpcHQuYXN5bmMgPSBcImFzeW5jXCI7XG5cblx0XHRcdFx0aWYgKCBzLnNjcmlwdENoYXJzZXQgKSB7XG5cdFx0XHRcdFx0c2NyaXB0LmNoYXJzZXQgPSBzLnNjcmlwdENoYXJzZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY3JpcHQuc3JjID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gQXR0YWNoIGhhbmRsZXJzIGZvciBhbGwgYnJvd3NlcnNcblx0XHRcdFx0c2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiggXywgaXNBYm9ydCApIHtcblxuXHRcdFx0XHRcdGlmICggaXNBYm9ydCB8fCAhc2NyaXB0LnJlYWR5U3RhdGUgfHwgL2xvYWRlZHxjb21wbGV0ZS8udGVzdCggc2NyaXB0LnJlYWR5U3RhdGUgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIG1lbW9yeSBsZWFrIGluIElFXG5cdFx0XHRcdFx0XHRzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSB0aGUgc2NyaXB0XG5cdFx0XHRcdFx0XHRpZiAoIGhlYWQgJiYgc2NyaXB0LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRcdGhlYWQucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBEZXJlZmVyZW5jZSB0aGUgc2NyaXB0XG5cdFx0XHRcdFx0XHRzY3JpcHQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRcdC8vIENhbGxiYWNrIGlmIG5vdCBhYm9ydFxuXHRcdFx0XHRcdFx0aWYgKCAhaXNBYm9ydCApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soIDIwMCwgXCJzdWNjZXNzXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdC8vIFVzZSBpbnNlcnRCZWZvcmUgaW5zdGVhZCBvZiBhcHBlbmRDaGlsZCAgdG8gY2lyY3VtdmVudCBhbiBJRTYgYnVnLlxuXHRcdFx0XHQvLyBUaGlzIGFyaXNlcyB3aGVuIGEgYmFzZSBub2RlIGlzIHVzZWQgKCMyNzA5IGFuZCAjNDM3OCkuXG5cdFx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKCBzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHNjcmlwdCApIHtcblx0XHRcdFx0XHRzY3JpcHQub25sb2FkKCAwLCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59KTtcblxuXG5cblxudmFyIC8vICM1MjgwOiBJbnRlcm5ldCBFeHBsb3JlciB3aWxsIGtlZXAgY29ubmVjdGlvbnMgYWxpdmUgaWYgd2UgZG9uJ3QgYWJvcnQgb24gdW5sb2FkXG5cdHhock9uVW5sb2FkQWJvcnQgPSB3aW5kb3cuQWN0aXZlWE9iamVjdCA/IGZ1bmN0aW9uKCkge1xuXHRcdC8vIEFib3J0IGFsbCBwZW5kaW5nIHJlcXVlc3RzXG5cdFx0Zm9yICggdmFyIGtleSBpbiB4aHJDYWxsYmFja3MgKSB7XG5cdFx0XHR4aHJDYWxsYmFja3NbIGtleSBdKCAwLCAxICk7XG5cdFx0fVxuXHR9IDogZmFsc2UsXG5cdHhocklkID0gMCxcblx0eGhyQ2FsbGJhY2tzO1xuXG4vLyBGdW5jdGlvbnMgdG8gY3JlYXRlIHhocnNcbmZ1bmN0aW9uIGNyZWF0ZVN0YW5kYXJkWEhSKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2goIGUgKSB7fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVBY3RpdmVYSFIoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdCggXCJNaWNyb3NvZnQuWE1MSFRUUFwiICk7XG5cdH0gY2F0Y2goIGUgKSB7fVxufVxuXG4vLyBDcmVhdGUgdGhlIHJlcXVlc3Qgb2JqZWN0XG4vLyAoVGhpcyBpcyBzdGlsbCBhdHRhY2hlZCB0byBhamF4U2V0dGluZ3MgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IHdpbmRvdy5BY3RpdmVYT2JqZWN0ID9cblx0LyogTWljcm9zb2Z0IGZhaWxlZCB0byBwcm9wZXJseVxuXHQgKiBpbXBsZW1lbnQgdGhlIFhNTEh0dHBSZXF1ZXN0IGluIElFNyAoY2FuJ3QgcmVxdWVzdCBsb2NhbCBmaWxlcyksXG5cdCAqIHNvIHdlIHVzZSB0aGUgQWN0aXZlWE9iamVjdCB3aGVuIGl0IGlzIGF2YWlsYWJsZVxuXHQgKiBBZGRpdGlvbmFsbHkgWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIGluIElFNy9JRTggc29cblx0ICogd2UgbmVlZCBhIGZhbGxiYWNrLlxuXHQgKi9cblx0ZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLmlzTG9jYWwgJiYgY3JlYXRlU3RhbmRhcmRYSFIoKSB8fCBjcmVhdGVBY3RpdmVYSFIoKTtcblx0fSA6XG5cdC8vIEZvciBhbGwgb3RoZXIgYnJvd3NlcnMsIHVzZSB0aGUgc3RhbmRhcmQgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0XG5cdGNyZWF0ZVN0YW5kYXJkWEhSO1xuXG4vLyBEZXRlcm1pbmUgc3VwcG9ydCBwcm9wZXJ0aWVzXG4oZnVuY3Rpb24oIHhociApIHtcblx0alF1ZXJ5LmV4dGVuZCggalF1ZXJ5LnN1cHBvcnQsIHtcblx0XHRhamF4OiAhIXhocixcblx0XHRjb3JzOiAhIXhociAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyIClcblx0fSk7XG59KSggalF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKSApO1xuXG4vLyBDcmVhdGUgdHJhbnNwb3J0IGlmIHRoZSBicm93c2VyIGNhbiBwcm92aWRlIGFuIHhoclxuaWYgKCBqUXVlcnkuc3VwcG9ydC5hamF4ICkge1xuXG5cdGpRdWVyeS5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uKCBzICkge1xuXHRcdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0XHRpZiAoICFzLmNyb3NzRG9tYWluIHx8IGpRdWVyeS5zdXBwb3J0LmNvcnMgKSB7XG5cblx0XHRcdHZhciBjYWxsYmFjaztcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXG5cdFx0XHRcdFx0Ly8gR2V0IGEgbmV3IHhoclxuXHRcdFx0XHRcdHZhciB4aHIgPSBzLnhocigpLFxuXHRcdFx0XHRcdFx0aGFuZGxlLFxuXHRcdFx0XHRcdFx0aTtcblxuXHRcdFx0XHRcdC8vIE9wZW4gdGhlIHNvY2tldFxuXHRcdFx0XHRcdC8vIFBhc3NpbmcgbnVsbCB1c2VybmFtZSwgZ2VuZXJhdGVzIGEgbG9naW4gcG9wdXAgb24gT3BlcmEgKCMyODY1KVxuXHRcdFx0XHRcdGlmICggcy51c2VybmFtZSApIHtcblx0XHRcdFx0XHRcdHhoci5vcGVuKCBzLnR5cGUsIHMudXJsLCBzLmFzeW5jLCBzLnVzZXJuYW1lLCBzLnBhc3N3b3JkICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHhoci5vcGVuKCBzLnR5cGUsIHMudXJsLCBzLmFzeW5jICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRcdGlmICggcy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBpIGluIHMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0XHR4aHJbIGkgXSA9IHMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRcdGlmICggcy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBzLm1pbWVUeXBlICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0XHRpZiAoICFzLmNyb3NzRG9tYWluICYmICFoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSApIHtcblx0XHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmVlZCBhbiBleHRyYSB0cnkvY2F0Y2ggZm9yIGNyb3NzIGRvbWFpbiByZXF1ZXN0cyBpbiBGaXJlZm94IDNcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBjYXRjaCggXyApIHt9XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0XG5cdFx0XHRcdFx0Ly8gVGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uIHdoaWNoIGlzIGFjdHVhbGx5XG5cdFx0XHRcdFx0Ly8gaGFuZGxlZCBpbiBqUXVlcnkuYWpheCAoc28gbm8gdHJ5L2NhdGNoIGhlcmUpXG5cdFx0XHRcdFx0eGhyLnNlbmQoICggcy5oYXNDb250ZW50ICYmIHMuZGF0YSApIHx8IG51bGwgKTtcblxuXHRcdFx0XHRcdC8vIExpc3RlbmVyXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggXywgaXNBYm9ydCApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHN0YXR1cyxcblx0XHRcdFx0XHRcdFx0c3RhdHVzVGV4dCxcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXHRcdFx0XHRcdFx0XHRyZXNwb25zZXMsXG5cdFx0XHRcdFx0XHRcdHhtbDtcblxuXHRcdFx0XHRcdFx0Ly8gRmlyZWZveCB0aHJvd3MgZXhjZXB0aW9ucyB3aGVuIGFjY2Vzc2luZyBwcm9wZXJ0aWVzXG5cdFx0XHRcdFx0XHQvLyBvZiBhbiB4aHIgd2hlbiBhIG5ldHdvcmsgZXJyb3Igb2NjdXJlZFxuXHRcdFx0XHRcdFx0Ly8gaHR0cDovL2hlbHBmdWwua25vYnMtZGlhbHMuY29tL2luZGV4LnBocC9Db21wb25lbnRfcmV0dXJuZWRfZmFpbHVyZV9jb2RlOl8weDgwMDQwMTExXyhOU19FUlJPUl9OT1RfQVZBSUxBQkxFKVxuXHRcdFx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdFx0XHQvLyBXYXMgbmV2ZXIgY2FsbGVkIGFuZCBpcyBhYm9ydGVkIG9yIGNvbXBsZXRlXG5cdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgJiYgKCBpc0Fib3J0IHx8IHhoci5yZWFkeVN0YXRlID09PSA0ICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGNhbGxlZCBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBEbyBub3Qga2VlcCBhcyBhY3RpdmUgYW55bW9yZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGpRdWVyeS5ub29wO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB4aHJPblVubG9hZEFib3J0ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWxldGUgeGhyQ2FsbGJhY2tzWyBoYW5kbGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJZiBpdCdzIGFuIGFib3J0XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Fib3J0ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gQWJvcnQgaXQgbWFudWFsbHkgaWYgbmVlZGVkXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlICE9PSA0ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdHVzID0geGhyLnN0YXR1cztcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlcyA9IHt9O1xuXHRcdFx0XHRcdFx0XHRcdFx0eG1sID0geGhyLnJlc3BvbnNlWE1MO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBDb25zdHJ1Y3QgcmVzcG9uc2UgbGlzdFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB4bWwgJiYgeG1sLmRvY3VtZW50RWxlbWVudCAvKiAjNDk1OCAqLyApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VzLnhtbCA9IHhtbDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiByZXF1ZXN0aW5nIGJpbmFyeSBkYXRhLCBJRTYtOSB3aWxsIHRocm93IGFuIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gb24gYW55IGF0dGVtcHQgdG8gYWNjZXNzIHJlc3BvbnNlVGV4dCAoIzExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VzLnRleHQgPSB4aHIucmVzcG9uc2VUZXh0O1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCggXyApIHtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlyZWZveCB0aHJvd3MgYW4gZXhjZXB0aW9uIHdoZW4gYWNjZXNzaW5nXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBzdGF0dXNUZXh0IGZvciBmYXVsdHkgY3Jvc3MtZG9tYWluIHJlcXVlc3RzXG5cdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdGF0dXNUZXh0ID0geGhyLnN0YXR1c1RleHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoKCBlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBXZSBub3JtYWxpemUgd2l0aCBXZWJraXQgZ2l2aW5nIGFuIGVtcHR5IHN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiXCI7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbHRlciBzdGF0dXMgZm9yIG5vbiBzdGFuZGFyZCBiZWhhdmlvcnNcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHJlcXVlc3QgaXMgbG9jYWwgYW5kIHdlIGhhdmUgZGF0YTogYXNzdW1lIGEgc3VjY2Vzc1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gKHN1Y2Nlc3Mgd2l0aCBubyBkYXRhIHdvbid0IGdldCBub3RpZmllZCwgdGhhdCdzIHRoZSBiZXN0IHdlXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBjYW4gZG8gZ2l2ZW4gY3VycmVudCBpbXBsZW1lbnRhdGlvbnMpXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICFzdGF0dXMgJiYgcy5pc0xvY2FsICYmICFzLmNyb3NzRG9tYWluICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdGF0dXMgPSByZXNwb25zZXMudGV4dCA/IDIwMCA6IDQwNDtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFIC0gIzE0NTA6IHNvbWV0aW1lcyByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDEyMjMgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0YXR1cyA9IDIwNDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gY2F0Y2goIGZpcmVmb3hBY2Nlc3NFeGNlcHRpb24gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggIWlzQWJvcnQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIC0xLCBmaXJlZm94QWNjZXNzRXhjZXB0aW9uICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gQ2FsbCBjb21wbGV0ZSBpZiBuZWVkZWRcblx0XHRcdFx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggc3RhdHVzLCBzdGF0dXNUZXh0LCByZXNwb25zZXMsIHJlc3BvbnNlSGVhZGVycyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHQvLyBpZiB3ZSdyZSBpbiBzeW5jIG1vZGUgb3IgaXQncyBpbiBjYWNoZVxuXHRcdFx0XHRcdC8vIGFuZCBoYXMgYmVlbiByZXRyaWV2ZWQgZGlyZWN0bHkgKElFNiAmIElFNylcblx0XHRcdFx0XHQvLyB3ZSBuZWVkIHRvIG1hbnVhbGx5IGZpcmUgdGhlIGNhbGxiYWNrXG5cdFx0XHRcdFx0aWYgKCAhcy5hc3luYyB8fCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGhhbmRsZSA9ICsreGhySWQ7XG5cdFx0XHRcdFx0XHRpZiAoIHhock9uVW5sb2FkQWJvcnQgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWN0aXZlIHhocnMgY2FsbGJhY2tzIGxpc3QgaWYgbmVlZGVkXG5cdFx0XHRcdFx0XHRcdC8vIGFuZCBhdHRhY2ggdGhlIHVubG9hZCBoYW5kbGVyXG5cdFx0XHRcdFx0XHRcdGlmICggIXhockNhbGxiYWNrcyApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHJDYWxsYmFja3MgPSB7fTtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnVubG9hZCggeGhyT25VbmxvYWRBYm9ydCApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdC8vIEFkZCB0byBsaXN0IG9mIGFjdGl2ZSB4aHJzIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHR4aHJDYWxsYmFja3NbIGhhbmRsZSBdID0gY2FsbGJhY2s7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gY2FsbGJhY2s7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2soMCwxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHR9KTtcbn1cblxuXG5cblxudmFyIGVsZW1kaXNwbGF5ID0ge30sXG5cdGlmcmFtZSwgaWZyYW1lRG9jLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cmZ4bnVtID0gL14oWytcXC1dPSk/KFtcXGQrLlxcLV0rKShbYS16JV0qKSQvaSxcblx0dGltZXJJZCxcblx0ZnhBdHRycyA9IFtcblx0XHQvLyBoZWlnaHQgYW5pbWF0aW9uc1xuXHRcdFsgXCJoZWlnaHRcIiwgXCJtYXJnaW5Ub3BcIiwgXCJtYXJnaW5Cb3R0b21cIiwgXCJwYWRkaW5nVG9wXCIsIFwicGFkZGluZ0JvdHRvbVwiIF0sXG5cdFx0Ly8gd2lkdGggYW5pbWF0aW9uc1xuXHRcdFsgXCJ3aWR0aFwiLCBcIm1hcmdpbkxlZnRcIiwgXCJtYXJnaW5SaWdodFwiLCBcInBhZGRpbmdMZWZ0XCIsIFwicGFkZGluZ1JpZ2h0XCIgXSxcblx0XHQvLyBvcGFjaXR5IGFuaW1hdGlvbnNcblx0XHRbIFwib3BhY2l0eVwiIF1cblx0XSxcblx0ZnhOb3c7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRzaG93OiBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVsZW0sIGRpc3BsYXk7XG5cblx0XHRpZiAoIHNwZWVkIHx8IHNwZWVkID09PSAwICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggZ2VuRngoXCJzaG93XCIsIDMpLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IHRoaXMubGVuZ3RoOyBpIDwgajsgaSsrICkge1xuXHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggZWxlbS5zdHlsZSApIHtcblx0XHRcdFx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXG5cdFx0XHRcdFx0Ly8gUmVzZXQgdGhlIGlubGluZSBkaXNwbGF5IG9mIHRoaXMgZWxlbWVudCB0byBsZWFybiBpZiBpdCBpc1xuXHRcdFx0XHRcdC8vIGJlaW5nIGhpZGRlbiBieSBjYXNjYWRlZCBydWxlcyBvciBub3Rcblx0XHRcdFx0XHRpZiAoICFqUXVlcnkuX2RhdGEoZWxlbSwgXCJvbGRkaXNwbGF5XCIpICYmIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU2V0IGVsZW1lbnRzIHdoaWNoIGhhdmUgYmVlbiBvdmVycmlkZGVuIHdpdGggZGlzcGxheTogbm9uZVxuXHRcdFx0XHRcdC8vIGluIGEgc3R5bGVzaGVldCB0byB3aGF0ZXZlciB0aGUgZGVmYXVsdCBicm93c2VyIHN0eWxlIGlzXG5cdFx0XHRcdFx0Ly8gZm9yIHN1Y2ggYW4gZWxlbWVudFxuXHRcdFx0XHRcdGlmICggKGRpc3BsYXkgPT09IFwiXCIgJiYgalF1ZXJ5LmNzcyhlbGVtLCBcImRpc3BsYXlcIikgPT09IFwibm9uZVwiKSB8fFxuXHRcdFx0XHRcdFx0IWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZWxlbSApICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCBlbGVtLCBcIm9sZGRpc3BsYXlcIiwgZGVmYXVsdERpc3BsYXkoZWxlbS5ub2RlTmFtZSkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIG1vc3Qgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3Bcblx0XHRcdC8vIHRvIGF2b2lkIHRoZSBjb25zdGFudCByZWZsb3dcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgajsgaSsrICkge1xuXHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggZWxlbS5zdHlsZSApIHtcblx0XHRcdFx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXG5cdFx0XHRcdFx0aWYgKCBkaXNwbGF5ID09PSBcIlwiIHx8IGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0galF1ZXJ5Ll9kYXRhKCBlbGVtLCBcIm9sZGRpc3BsYXlcIiApIHx8IFwiXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fSxcblxuXHRoaWRlOiBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBzcGVlZCB8fCBzcGVlZCA9PT0gMCApIHtcblx0XHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIGdlbkZ4KFwiaGlkZVwiLCAzKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBlbGVtLCBkaXNwbGF5LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0aiA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCBqOyBpKysgKSB7XG5cdFx0XHRcdGVsZW0gPSB0aGlzW2ldO1xuXHRcdFx0XHRpZiAoIGVsZW0uc3R5bGUgKSB7XG5cdFx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cblx0XHRcdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICYmICFqUXVlcnkuX2RhdGEoIGVsZW0sIFwib2xkZGlzcGxheVwiICkgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuX2RhdGEoIGVsZW0sIFwib2xkZGlzcGxheVwiLCBkaXNwbGF5ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcFxuXHRcdFx0Ly8gdG8gYXZvaWQgdGhlIGNvbnN0YW50IHJlZmxvd1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBqOyBpKysgKSB7XG5cdFx0XHRcdGlmICggdGhpc1tpXS5zdHlsZSApIHtcblx0XHRcdFx0XHR0aGlzW2ldLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdH0sXG5cblx0Ly8gU2F2ZSB0aGUgb2xkIHRvZ2dsZSBmdW5jdGlvblxuXHRfdG9nZ2xlOiBqUXVlcnkuZm4udG9nZ2xlLFxuXG5cdHRvZ2dsZTogZnVuY3Rpb24oIGZuLCBmbjIsIGNhbGxiYWNrICkge1xuXHRcdHZhciBib29sID0gdHlwZW9mIGZuID09PSBcImJvb2xlYW5cIjtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oZm4pICYmIGpRdWVyeS5pc0Z1bmN0aW9uKGZuMikgKSB7XG5cdFx0XHR0aGlzLl90b2dnbGUuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXG5cdFx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCB8fCBib29sICkge1xuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgc3RhdGUgPSBib29sID8gZm4gOiBqUXVlcnkodGhpcykuaXMoXCI6aGlkZGVuXCIpO1xuXHRcdFx0XHRqUXVlcnkodGhpcylbIHN0YXRlID8gXCJzaG93XCIgOiBcImhpZGVcIiBdKCk7XG5cdFx0XHR9KTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFuaW1hdGUoZ2VuRngoXCJ0b2dnbGVcIiwgMyksIGZuLCBmbjIsIGNhbGxiYWNrKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKFwiOmhpZGRlblwiKS5jc3MoXCJvcGFjaXR5XCIsIDApLnNob3coKS5lbmQoKVxuXHRcdFx0XHRcdC5hbmltYXRlKHtvcGFjaXR5OiB0b30sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKTtcblx0fSxcblxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIG9wdGFsbC5jb21wbGV0ZSwgWyBmYWxzZSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gRG8gbm90IGNoYW5nZSByZWZlcmVuY2VkIHByb3BlcnRpZXMgYXMgcGVyLXByb3BlcnR5IGVhc2luZyB3aWxsIGJlIGxvc3Rcblx0XHRwcm9wID0galF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKTtcblxuXHRcdGZ1bmN0aW9uIGRvQW5pbWF0aW9uKCkge1xuXHRcdFx0Ly8gWFhYICd0aGlzJyBkb2VzIG5vdCBhbHdheXMgaGF2ZSBhIG5vZGVOYW1lIHdoZW4gcnVubmluZyB0aGVcblx0XHRcdC8vIHRlc3Qgc3VpdGVcblxuXHRcdFx0aWYgKCBvcHRhbGwucXVldWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRqUXVlcnkuX21hcmsoIHRoaXMgKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIG9wdCA9IGpRdWVyeS5leHRlbmQoIHt9LCBvcHRhbGwgKSxcblx0XHRcdFx0aXNFbGVtZW50ID0gdGhpcy5ub2RlVHlwZSA9PT0gMSxcblx0XHRcdFx0aGlkZGVuID0gaXNFbGVtZW50ICYmIGpRdWVyeSh0aGlzKS5pcyhcIjpoaWRkZW5cIiksXG5cdFx0XHRcdG5hbWUsIHZhbCwgcCwgZSwgaG9va3MsIHJlcGxhY2UsXG5cdFx0XHRcdHBhcnRzLCBzdGFydCwgZW5kLCB1bml0LFxuXHRcdFx0XHRtZXRob2Q7XG5cblx0XHRcdC8vIHdpbGwgc3RvcmUgcGVyIHByb3BlcnR5IGVhc2luZyBhbmQgYmUgdXNlZCB0byBkZXRlcm1pbmUgd2hlbiBhbiBhbmltYXRpb24gaXMgY29tcGxldGVcblx0XHRcdG9wdC5hbmltYXRlZFByb3BlcnRpZXMgPSB7fTtcblxuXHRcdFx0Ly8gZmlyc3QgcGFzcyBvdmVyIHByb3BlcnR5cyB0byBleHBhbmQgLyBub3JtYWxpemVcblx0XHRcdGZvciAoIHAgaW4gcHJvcCApIHtcblx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIHAgKTtcblx0XHRcdFx0aWYgKCBwICE9PSBuYW1lICkge1xuXHRcdFx0XHRcdHByb3BbIG5hbWUgXSA9IHByb3BbIHAgXTtcblx0XHRcdFx0XHRkZWxldGUgcHJvcFsgcCBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCAoIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gKSAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0XHRcdHJlcGxhY2UgPSBob29rcy5leHBhbmQoIHByb3BbIG5hbWUgXSApO1xuXHRcdFx0XHRcdGRlbGV0ZSBwcm9wWyBuYW1lIF07XG5cblx0XHRcdFx0XHQvLyBub3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29udCBvdmVyd3JpdGUga2V5cyBhbHJlYWR5IHByZXNlbnQuXG5cdFx0XHRcdFx0Ly8gYWxzbyAtIHJldXNpbmcgJ3AnIGZyb20gYWJvdmUgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRcdFx0Zm9yICggcCBpbiByZXBsYWNlICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhICggcCBpbiBwcm9wICkgKSB7XG5cdFx0XHRcdFx0XHRcdHByb3BbIHAgXSA9IHJlcGxhY2VbIHAgXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbmFtZSBpbiBwcm9wICkge1xuXHRcdFx0XHR2YWwgPSBwcm9wWyBuYW1lIF07XG5cdFx0XHRcdC8vIGVhc2luZyByZXNvbHV0aW9uOiBwZXIgcHJvcGVydHkgPiBvcHQuc3BlY2lhbEVhc2luZyA+IG9wdC5lYXNpbmcgPiAnc3dpbmcnIChkZWZhdWx0KVxuXHRcdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0XHRvcHQuYW5pbWF0ZWRQcm9wZXJ0aWVzWyBuYW1lIF0gPSB2YWxbIDEgXTtcblx0XHRcdFx0XHR2YWwgPSBwcm9wWyBuYW1lIF0gPSB2YWxbIDAgXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvcHQuYW5pbWF0ZWRQcm9wZXJ0aWVzWyBuYW1lIF0gPSBvcHQuc3BlY2lhbEVhc2luZyAmJiBvcHQuc3BlY2lhbEVhc2luZ1sgbmFtZSBdIHx8IG9wdC5lYXNpbmcgfHwgJ3N3aW5nJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdmFsID09PSBcImhpZGVcIiAmJiBoaWRkZW4gfHwgdmFsID09PSBcInNob3dcIiAmJiAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHJldHVybiBvcHQuY29tcGxldGUuY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpc0VsZW1lbnQgJiYgKCBuYW1lID09PSBcImhlaWdodFwiIHx8IG5hbWUgPT09IFwid2lkdGhcIiApICkge1xuXHRcdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG5vdGhpbmcgc25lYWtzIG91dFxuXHRcdFx0XHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3Rcblx0XHRcdFx0XHQvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcblx0XHRcdFx0XHQvLyBvdmVyZmxvd1kgYXJlIHNldCB0byB0aGUgc2FtZSB2YWx1ZVxuXHRcdFx0XHRcdG9wdC5vdmVyZmxvdyA9IFsgdGhpcy5zdHlsZS5vdmVyZmxvdywgdGhpcy5zdHlsZS5vdmVyZmxvd1gsIHRoaXMuc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHRcdFx0XHQvLyBTZXQgZGlzcGxheSBwcm9wZXJ0eSB0byBpbmxpbmUtYmxvY2sgZm9yIGhlaWdodC93aWR0aFxuXHRcdFx0XHRcdC8vIGFuaW1hdGlvbnMgb24gaW5saW5lIGVsZW1lbnRzIHRoYXQgYXJlIGhhdmluZyB3aWR0aC9oZWlnaHQgYW5pbWF0ZWRcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jc3MoIHRoaXMsIFwiZGlzcGxheVwiICkgPT09IFwiaW5saW5lXCIgJiZcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNzcyggdGhpcywgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdFx0XHQvLyBpbmxpbmUtbGV2ZWwgZWxlbWVudHMgYWNjZXB0IGlubGluZS1ibG9jaztcblx0XHRcdFx0XHRcdC8vIGJsb2NrLWxldmVsIGVsZW1lbnRzIG5lZWQgdG8gYmUgaW5saW5lIHdpdGggbGF5b3V0XG5cdFx0XHRcdFx0XHRpZiAoICFqUXVlcnkuc3VwcG9ydC5pbmxpbmVCbG9ja05lZWRzTGF5b3V0IHx8IGRlZmF1bHREaXNwbGF5KCB0aGlzLm5vZGVOYW1lICkgPT09IFwiaW5saW5lXCIgKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc3R5bGUuem9vbSA9IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggb3B0Lm92ZXJmbG93ICE9IG51bGwgKSB7XG5cdFx0XHRcdHRoaXMuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBwIGluIHByb3AgKSB7XG5cdFx0XHRcdGUgPSBuZXcgalF1ZXJ5LmZ4KCB0aGlzLCBvcHQsIHAgKTtcblx0XHRcdFx0dmFsID0gcHJvcFsgcCBdO1xuXG5cdFx0XHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsICkgKSB7XG5cblx0XHRcdFx0XHQvLyBUcmFja3Mgd2hldGhlciB0byBzaG93IG9yIGhpZGUgYmFzZWQgb24gcHJpdmF0ZVxuXHRcdFx0XHRcdC8vIGRhdGEgYXR0YWNoZWQgdG8gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRtZXRob2QgPSBqUXVlcnkuX2RhdGEoIHRoaXMsIFwidG9nZ2xlXCIgKyBwICkgfHwgKCB2YWwgPT09IFwidG9nZ2xlXCIgPyBoaWRkZW4gPyBcInNob3dcIiA6IFwiaGlkZVwiIDogMCApO1xuXHRcdFx0XHRcdGlmICggbWV0aG9kICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCB0aGlzLCBcInRvZ2dsZVwiICsgcCwgbWV0aG9kID09PSBcInNob3dcIiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKTtcblx0XHRcdFx0XHRcdGVbIG1ldGhvZCBdKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGVbIHZhbCBdKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFydHMgPSByZnhudW0uZXhlYyggdmFsICk7XG5cdFx0XHRcdFx0c3RhcnQgPSBlLmN1cigpO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJ0cyApIHtcblx0XHRcdFx0XHRcdGVuZCA9IHBhcnNlRmxvYXQoIHBhcnRzWzJdICk7XG5cdFx0XHRcdFx0XHR1bml0ID0gcGFydHNbM10gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwIF0gPyBcIlwiIDogXCJweFwiICk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIG5lZWQgdG8gY29tcHV0ZSBzdGFydGluZyB2YWx1ZVxuXHRcdFx0XHRcdFx0aWYgKCB1bml0ICE9PSBcInB4XCIgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggdGhpcywgcCwgKGVuZCB8fCAxKSArIHVuaXQpO1xuXHRcdFx0XHRcdFx0XHRzdGFydCA9ICggKGVuZCB8fCAxKSAvIGUuY3VyKCkgKSAqIHN0YXJ0O1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIHRoaXMsIHAsIHN0YXJ0ICsgdW5pdCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIElmIGEgKz0vLT0gdG9rZW4gd2FzIHByb3ZpZGVkLCB3ZSdyZSBkb2luZyBhIHJlbGF0aXZlIGFuaW1hdGlvblxuXHRcdFx0XHRcdFx0aWYgKCBwYXJ0c1sxXSApIHtcblx0XHRcdFx0XHRcdFx0ZW5kID0gKCAocGFydHNbIDEgXSA9PT0gXCItPVwiID8gLTEgOiAxKSAqIGVuZCApICsgc3RhcnQ7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGUuY3VzdG9tKCBzdGFydCwgZW5kLCB1bml0ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZS5jdXN0b20oIHN0YXJ0LCB2YWwsIFwiXCIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIEpTIHN0cmljdCBjb21wbGlhbmNlXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0aGFkVGltZXJzID0gZmFsc2UsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBqUXVlcnkuX2RhdGEoIHRoaXMgKTtcblxuXHRcdFx0Ly8gY2xlYXIgbWFya2VyIGNvdW50ZXJzIGlmIHdlIGtub3cgdGhleSB3b24ndCBiZVxuXHRcdFx0aWYgKCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5Ll91bm1hcmsoIHRydWUsIHRoaXMgKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gc3RvcFF1ZXVlKCBlbGVtLCBkYXRhLCBpbmRleCApIHtcblx0XHRcdFx0dmFyIGhvb2tzID0gZGF0YVsgaW5kZXggXTtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZURhdGEoIGVsZW0sIGluZGV4LCB0cnVlICk7XG5cdFx0XHRcdGhvb2tzLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0eXBlID09IG51bGwgKSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBpbmRleC5pbmRleE9mKFwiLnJ1blwiKSA9PT0gaW5kZXgubGVuZ3RoIC0gNCApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggdGhpcywgZGF0YSwgaW5kZXggKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIGRhdGFbIGluZGV4ID0gdHlwZSArIFwiLnJ1blwiIF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICl7XG5cdFx0XHRcdHN0b3BRdWV1ZSggdGhpcywgZGF0YSwgaW5kZXggKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiAodHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXG5cdFx0XHRcdFx0XHQvLyBmb3JjZSB0aGUgbmV4dCBzdGVwIHRvIGJlIHRoZSBsYXN0XG5cdFx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0oIHRydWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLnNhdmVTdGF0ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRoYWRUaW1lcnMgPSB0cnVlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gc3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZFxuXHRcdFx0Ly8gdGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaCB3aWxsIGRlcXVldWVcblx0XHRcdC8vIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kXG5cdFx0XHRpZiAoICEoIGdvdG9FbmQgJiYgaGFkVGltZXJzICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxufSk7XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHRzZXRUaW1lb3V0KCBjbGVhckZ4Tm93LCAwICk7XG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyRnhOb3coKSB7XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIG51bSApIHtcblx0dmFyIG9iaiA9IHt9O1xuXG5cdGpRdWVyeS5lYWNoKCBmeEF0dHJzLmNvbmNhdC5hcHBseShbXSwgZnhBdHRycy5zbGljZSggMCwgbnVtICkpLCBmdW5jdGlvbigpIHtcblx0XHRvYmpbIHRoaXMgXSA9IHR5cGU7XG5cdH0pO1xuXG5cdHJldHVybiBvYmo7XG59XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIsIDEgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiLCAxICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiwgMSApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0pO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0c3BlZWQ6IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0XHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHRcdH07XG5cblx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZngub2ZmID8gMCA6IHR5cGVvZiBvcHQuZHVyYXRpb24gPT09IFwibnVtYmVyXCIgPyBvcHQuZHVyYXRpb24gOlxuXHRcdFx0b3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgPyBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXSA6IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cblx0XHQvLyBub3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0XHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0XHR9XG5cblx0XHQvLyBRdWV1ZWluZ1xuXHRcdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0XHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbiggbm9Vbm1hcmsgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdFx0fSBlbHNlIGlmICggbm9Vbm1hcmsgIT09IGZhbHNlICkge1xuXHRcdFx0XHRqUXVlcnkuX3VubWFyayggdGhpcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRyZXR1cm4gb3B0O1xuXHR9LFxuXG5cdGVhc2luZzoge1xuXHRcdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0XHRyZXR1cm4gcDtcblx0XHR9LFxuXHRcdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRcdHJldHVybiAoIC1NYXRoLmNvcyggcCpNYXRoLlBJICkgLyAyICkgKyAwLjU7XG5cdFx0fVxuXHR9LFxuXG5cdHRpbWVyczogW10sXG5cblx0Zng6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wICkge1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXG5cdFx0b3B0aW9ucy5vcmlnID0gb3B0aW9ucy5vcmlnIHx8IHt9O1xuXHR9XG5cbn0pO1xuXG5qUXVlcnkuZngucHJvdG90eXBlID0ge1xuXHQvLyBTaW1wbGUgZnVuY3Rpb24gZm9yIHNldHRpbmcgYSBzdHlsZSB2YWx1ZVxuXHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0KCBqUXVlcnkuZnguc3RlcFsgdGhpcy5wcm9wIF0gfHwgalF1ZXJ5LmZ4LnN0ZXAuX2RlZmF1bHQgKSggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgY3VycmVudCBzaXplXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCB0aGlzLmVsZW1bIHRoaXMucHJvcCBdICE9IG51bGwgJiYgKCF0aGlzLmVsZW0uc3R5bGUgfHwgdGhpcy5lbGVtLnN0eWxlWyB0aGlzLnByb3AgXSA9PSBudWxsKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVsZW1bIHRoaXMucHJvcCBdO1xuXHRcdH1cblxuXHRcdHZhciBwYXJzZWQsXG5cdFx0XHRyID0galF1ZXJ5LmNzcyggdGhpcy5lbGVtLCB0aGlzLnByb3AgKTtcblx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMCxcblx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzIGlzLFxuXHRcdC8vIHNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0LlxuXHRcdHJldHVybiBpc05hTiggcGFyc2VkID0gcGFyc2VGbG9hdCggciApICkgPyAhciB8fCByID09PSBcImF1dG9cIiA/IDAgOiByIDogcGFyc2VkO1xuXHR9LFxuXG5cdC8vIFN0YXJ0IGFuIGFuaW1hdGlvbiBmcm9tIG9uZSBudW1iZXIgdG8gYW5vdGhlclxuXHRjdXN0b206IGZ1bmN0aW9uKCBmcm9tLCB0bywgdW5pdCApIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRmeCA9IGpRdWVyeS5meDtcblxuXHRcdHRoaXMuc3RhcnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKTtcblx0XHR0aGlzLmVuZCA9IHRvO1xuXHRcdHRoaXMubm93ID0gdGhpcy5zdGFydCA9IGZyb207XG5cdFx0dGhpcy5wb3MgPSB0aGlzLnN0YXRlID0gMDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8IHRoaXMudW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHRoaXMucHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXG5cdFx0ZnVuY3Rpb24gdCggZ290b0VuZCApIHtcblx0XHRcdHJldHVybiBzZWxmLnN0ZXAoIGdvdG9FbmQgKTtcblx0XHR9XG5cblx0XHR0LnF1ZXVlID0gdGhpcy5vcHRpb25zLnF1ZXVlO1xuXHRcdHQuZWxlbSA9IHRoaXMuZWxlbTtcblx0XHR0LnNhdmVTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBqUXVlcnkuX2RhdGEoIHNlbGYuZWxlbSwgXCJmeHNob3dcIiArIHNlbGYucHJvcCApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGlmICggc2VsZi5vcHRpb25zLmhpZGUgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCBzZWxmLmVsZW0sIFwiZnhzaG93XCIgKyBzZWxmLnByb3AsIHNlbGYuc3RhcnQgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggc2VsZi5vcHRpb25zLnNob3cgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Ll9kYXRhKCBzZWxmLmVsZW0sIFwiZnhzaG93XCIgKyBzZWxmLnByb3AsIHNlbGYuZW5kICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0aWYgKCB0KCkgJiYgalF1ZXJ5LnRpbWVycy5wdXNoKHQpICYmICF0aW1lcklkICkge1xuXHRcdFx0dGltZXJJZCA9IHNldEludGVydmFsKCBmeC50aWNrLCBmeC5pbnRlcnZhbCApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBTaW1wbGUgJ3Nob3cnIGZ1bmN0aW9uXG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkYXRhU2hvdyA9IGpRdWVyeS5fZGF0YSggdGhpcy5lbGVtLCBcImZ4c2hvd1wiICsgdGhpcy5wcm9wICk7XG5cblx0XHQvLyBSZW1lbWJlciB3aGVyZSB3ZSBzdGFydGVkLCBzbyB0aGF0IHdlIGNhbiBnbyBiYWNrIHRvIGl0IGxhdGVyXG5cdFx0dGhpcy5vcHRpb25zLm9yaWdbIHRoaXMucHJvcCBdID0gZGF0YVNob3cgfHwgalF1ZXJ5LnN0eWxlKCB0aGlzLmVsZW0sIHRoaXMucHJvcCApO1xuXHRcdHRoaXMub3B0aW9ucy5zaG93ID0gdHJ1ZTtcblxuXHRcdC8vIEJlZ2luIHRoZSBhbmltYXRpb25cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSBzdGFydCBhdCBhIHNtYWxsIHdpZHRoL2hlaWdodCB0byBhdm9pZCBhbnkgZmxhc2ggb2YgY29udGVudFxuXHRcdGlmICggZGF0YVNob3cgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdC8vIFRoaXMgc2hvdyBpcyBwaWNraW5nIHVwIHdoZXJlIGEgcHJldmlvdXMgaGlkZSBvciBzaG93IGxlZnQgb2ZmXG5cdFx0XHR0aGlzLmN1c3RvbSggdGhpcy5jdXIoKSwgZGF0YVNob3cgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jdXN0b20oIHRoaXMucHJvcCA9PT0gXCJ3aWR0aFwiIHx8IHRoaXMucHJvcCA9PT0gXCJoZWlnaHRcIiA/IDEgOiAwLCB0aGlzLmN1cigpICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RhcnQgYnkgc2hvd2luZyB0aGUgZWxlbWVudFxuXHRcdGpRdWVyeSggdGhpcy5lbGVtICkuc2hvdygpO1xuXHR9LFxuXG5cdC8vIFNpbXBsZSAnaGlkZScgZnVuY3Rpb25cblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gUmVtZW1iZXIgd2hlcmUgd2Ugc3RhcnRlZCwgc28gdGhhdCB3ZSBjYW4gZ28gYmFjayB0byBpdCBsYXRlclxuXHRcdHRoaXMub3B0aW9ucy5vcmlnWyB0aGlzLnByb3AgXSA9IGpRdWVyeS5fZGF0YSggdGhpcy5lbGVtLCBcImZ4c2hvd1wiICsgdGhpcy5wcm9wICkgfHwgalF1ZXJ5LnN0eWxlKCB0aGlzLmVsZW0sIHRoaXMucHJvcCApO1xuXHRcdHRoaXMub3B0aW9ucy5oaWRlID0gdHJ1ZTtcblxuXHRcdC8vIEJlZ2luIHRoZSBhbmltYXRpb25cblx0XHR0aGlzLmN1c3RvbSggdGhpcy5jdXIoKSwgMCApO1xuXHR9LFxuXG5cdC8vIEVhY2ggc3RlcCBvZiBhbiBhbmltYXRpb25cblx0c3RlcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHAsIG4sIGNvbXBsZXRlLFxuXHRcdFx0dCA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkb25lID0gdHJ1ZSxcblx0XHRcdGVsZW0gPSB0aGlzLmVsZW0sXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKCBnb3RvRW5kIHx8IHQgPj0gb3B0aW9ucy5kdXJhdGlvbiArIHRoaXMuc3RhcnRUaW1lICkge1xuXHRcdFx0dGhpcy5ub3cgPSB0aGlzLmVuZDtcblx0XHRcdHRoaXMucG9zID0gdGhpcy5zdGF0ZSA9IDE7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0XHRvcHRpb25zLmFuaW1hdGVkUHJvcGVydGllc1sgdGhpcy5wcm9wIF0gPSB0cnVlO1xuXG5cdFx0XHRmb3IgKCBwIGluIG9wdGlvbnMuYW5pbWF0ZWRQcm9wZXJ0aWVzICkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuYW5pbWF0ZWRQcm9wZXJ0aWVzWyBwIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0ZG9uZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZG9uZSApIHtcblx0XHRcdFx0Ly8gUmVzZXQgdGhlIG92ZXJmbG93XG5cdFx0XHRcdGlmICggb3B0aW9ucy5vdmVyZmxvdyAhPSBudWxsICYmICFqUXVlcnkuc3VwcG9ydC5zaHJpbmtXcmFwQmxvY2tzICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LmVhY2goIFsgXCJcIiwgXCJYXCIsIFwiWVwiIF0sIGZ1bmN0aW9uKCBpbmRleCwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnN0eWxlWyBcIm92ZXJmbG93XCIgKyB2YWx1ZSBdID0gb3B0aW9ucy5vdmVyZmxvd1sgaW5kZXggXTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhpZGUgdGhlIGVsZW1lbnQgaWYgdGhlIFwiaGlkZVwiIG9wZXJhdGlvbiB3YXMgZG9uZVxuXHRcdFx0XHRpZiAoIG9wdGlvbnMuaGlkZSApIHtcblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5oaWRlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNldCB0aGUgcHJvcGVydGllcywgaWYgdGhlIGl0ZW0gaGFzIGJlZW4gaGlkZGVuIG9yIHNob3duXG5cdFx0XHRcdGlmICggb3B0aW9ucy5oaWRlIHx8IG9wdGlvbnMuc2hvdyApIHtcblx0XHRcdFx0XHRmb3IgKCBwIGluIG9wdGlvbnMuYW5pbWF0ZWRQcm9wZXJ0aWVzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwLCBvcHRpb25zLm9yaWdbIHAgXSApO1xuXHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZURhdGEoIGVsZW0sIFwiZnhzaG93XCIgKyBwLCB0cnVlICk7XG5cdFx0XHRcdFx0XHQvLyBUb2dnbGUgZGF0YSBpcyBubyBsb25nZXIgbmVlZGVkXG5cdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRGF0YSggZWxlbSwgXCJ0b2dnbGVcIiArIHAsIHRydWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBjb21wbGV0ZSBmdW5jdGlvblxuXHRcdFx0XHQvLyBpbiB0aGUgZXZlbnQgdGhhdCB0aGUgY29tcGxldGUgZnVuY3Rpb24gdGhyb3dzIGFuIGV4Y2VwdGlvblxuXHRcdFx0XHQvLyB3ZSBtdXN0IGVuc3VyZSBpdCB3b24ndCBiZSBjYWxsZWQgdHdpY2UuICM1Njg0XG5cblx0XHRcdFx0Y29tcGxldGUgPSBvcHRpb25zLmNvbXBsZXRlO1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlICkge1xuXG5cdFx0XHRcdFx0b3B0aW9ucy5jb21wbGV0ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGNvbXBsZXRlLmNhbGwoIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gY2xhc3NpY2FsIGVhc2luZyBjYW5ub3QgYmUgdXNlZCB3aXRoIGFuIEluZmluaXR5IGR1cmF0aW9uXG5cdFx0XHRpZiAoIG9wdGlvbnMuZHVyYXRpb24gPT0gSW5maW5pdHkgKSB7XG5cdFx0XHRcdHRoaXMubm93ID0gdDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG4gPSB0IC0gdGhpcy5zdGFydFRpbWU7XG5cdFx0XHRcdHRoaXMuc3RhdGUgPSBuIC8gb3B0aW9ucy5kdXJhdGlvbjtcblxuXHRcdFx0XHQvLyBQZXJmb3JtIHRoZSBlYXNpbmcgZnVuY3Rpb24sIGRlZmF1bHRzIHRvIHN3aW5nXG5cdFx0XHRcdHRoaXMucG9zID0galF1ZXJ5LmVhc2luZ1sgb3B0aW9ucy5hbmltYXRlZFByb3BlcnRpZXNbdGhpcy5wcm9wXSBdKCB0aGlzLnN0YXRlLCBuLCAwLCAxLCBvcHRpb25zLmR1cmF0aW9uICk7XG5cdFx0XHRcdHRoaXMubm93ID0gdGhpcy5zdGFydCArICggKHRoaXMuZW5kIC0gdGhpcy5zdGFydCkgKiB0aGlzLnBvcyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUGVyZm9ybSB0aGUgbmV4dCBzdGVwIG9mIHRoZSBhbmltYXRpb25cblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn07XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5meCwge1xuXHR0aWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGltZXIsXG5cdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXHRcdFx0Ly8gQ2hlY2tzIHRoZSB0aW1lciBoYXMgbm90IGFscmVhZHkgYmVlbiByZW1vdmVkXG5cdFx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdFx0fVxuXHR9LFxuXG5cdGludGVydmFsOiAxMyxcblxuXHRzdG9wOiBmdW5jdGlvbigpIHtcblx0XHRjbGVhckludGVydmFsKCB0aW1lcklkICk7XG5cdFx0dGltZXJJZCA9IG51bGw7XG5cdH0sXG5cblx0c3BlZWRzOiB7XG5cdFx0c2xvdzogNjAwLFxuXHRcdGZhc3Q6IDIwMCxcblx0XHQvLyBEZWZhdWx0IHNwZWVkXG5cdFx0X2RlZmF1bHQ6IDQwMFxuXHR9LFxuXG5cdHN0ZXA6IHtcblx0XHRvcGFjaXR5OiBmdW5jdGlvbiggZnggKSB7XG5cdFx0XHRqUXVlcnkuc3R5bGUoIGZ4LmVsZW0sIFwib3BhY2l0eVwiLCBmeC5ub3cgKTtcblx0XHR9LFxuXG5cdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBmeCApIHtcblx0XHRcdGlmICggZnguZWxlbS5zdHlsZSAmJiBmeC5lbGVtLnN0eWxlWyBmeC5wcm9wIF0gIT0gbnVsbCApIHtcblx0XHRcdFx0ZnguZWxlbS5zdHlsZVsgZngucHJvcCBdID0gZngubm93ICsgZngudW5pdDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZ4LmVsZW1bIGZ4LnByb3AgXSA9IGZ4Lm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBFbnN1cmUgcHJvcHMgdGhhdCBjYW4ndCBiZSBuZWdhdGl2ZSBkb24ndCBnbyB0aGVyZSBvbiB1bmRlcnNob290IGVhc2luZ1xualF1ZXJ5LmVhY2goIGZ4QXR0cnMuY29uY2F0LmFwcGx5KCBbXSwgZnhBdHRycyApLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0Ly8gZXhjbHVkZSBtYXJnaW5Ub3AsIG1hcmdpbkxlZnQsIG1hcmdpbkJvdHRvbSBhbmQgbWFyZ2luUmlnaHQgZnJvbSB0aGlzIGxpc3Rcblx0aWYgKCBwcm9wLmluZGV4T2YoIFwibWFyZ2luXCIgKSApIHtcblx0XHRqUXVlcnkuZnguc3RlcFsgcHJvcCBdID0gZnVuY3Rpb24oIGZ4ICkge1xuXHRcdFx0alF1ZXJ5LnN0eWxlKCBmeC5lbGVtLCBwcm9wLCBNYXRoLm1heCgwLCBmeC5ub3cpICsgZngudW5pdCApO1xuXHRcdH07XG5cdH1cbn0pO1xuXG5pZiAoIGpRdWVyeS5leHByICYmIGpRdWVyeS5leHByLmZpbHRlcnMgKSB7XG5cdGpRdWVyeS5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdFx0fSkubGVuZ3RoO1xuXHR9O1xufVxuXG4vLyBUcnkgdG8gcmVzdG9yZSB0aGUgZGVmYXVsdCBkaXNwbGF5IHZhbHVlIG9mIGFuIGVsZW1lbnRcbmZ1bmN0aW9uIGRlZmF1bHREaXNwbGF5KCBub2RlTmFtZSApIHtcblxuXHRpZiAoICFlbGVtZGlzcGxheVsgbm9kZU5hbWUgXSApIHtcblxuXHRcdHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSxcblx0XHRcdGVsZW0gPSBqUXVlcnkoIFwiPFwiICsgbm9kZU5hbWUgKyBcIj5cIiApLmFwcGVuZFRvKCBib2R5ICksXG5cdFx0XHRkaXNwbGF5ID0gZWxlbS5jc3MoIFwiZGlzcGxheVwiICk7XG5cdFx0ZWxlbS5yZW1vdmUoKTtcblxuXHRcdC8vIElmIHRoZSBzaW1wbGUgd2F5IGZhaWxzLFxuXHRcdC8vIGdldCBlbGVtZW50J3MgcmVhbCBkZWZhdWx0IGRpc3BsYXkgYnkgYXR0YWNoaW5nIGl0IHRvIGEgdGVtcCBpZnJhbWVcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiIHx8IGRpc3BsYXkgPT09IFwiXCIgKSB7XG5cdFx0XHQvLyBObyBpZnJhbWUgdG8gdXNlIHlldCwgc28gY3JlYXRlIGl0XG5cdFx0XHRpZiAoICFpZnJhbWUgKSB7XG5cdFx0XHRcdGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaWZyYW1lXCIgKTtcblx0XHRcdFx0aWZyYW1lLmZyYW1lQm9yZGVyID0gaWZyYW1lLndpZHRoID0gaWZyYW1lLmhlaWdodCA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdGJvZHkuYXBwZW5kQ2hpbGQoIGlmcmFtZSApO1xuXG5cdFx0XHQvLyBDcmVhdGUgYSBjYWNoZWFibGUgY29weSBvZiB0aGUgaWZyYW1lIGRvY3VtZW50IG9uIGZpcnN0IGNhbGwuXG5cdFx0XHQvLyBJRSBhbmQgT3BlcmEgd2lsbCBhbGxvdyB1cyB0byByZXVzZSB0aGUgaWZyYW1lRG9jIHdpdGhvdXQgcmUtd3JpdGluZyB0aGUgZmFrZSBIVE1MXG5cdFx0XHQvLyBkb2N1bWVudCB0byBpdDsgV2ViS2l0ICYgRmlyZWZveCB3b24ndCBhbGxvdyByZXVzaW5nIHRoZSBpZnJhbWUgZG9jdW1lbnQuXG5cdFx0XHRpZiAoICFpZnJhbWVEb2MgfHwgIWlmcmFtZS5jcmVhdGVFbGVtZW50ICkge1xuXHRcdFx0XHRpZnJhbWVEb2MgPSAoIGlmcmFtZS5jb250ZW50V2luZG93IHx8IGlmcmFtZS5jb250ZW50RG9jdW1lbnQgKS5kb2N1bWVudDtcblx0XHRcdFx0aWZyYW1lRG9jLndyaXRlKCAoIGpRdWVyeS5zdXBwb3J0LmJveE1vZGVsID8gXCI8IWRvY3R5cGUgaHRtbD5cIiA6IFwiXCIgKSArIFwiPGh0bWw+PGJvZHk+XCIgKTtcblx0XHRcdFx0aWZyYW1lRG9jLmNsb3NlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0gPSBpZnJhbWVEb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKTtcblxuXHRcdFx0aWZyYW1lRG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblxuXHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRib2R5LnJlbW92ZUNoaWxkKCBpZnJhbWUgKTtcblx0XHR9XG5cblx0XHQvLyBTdG9yZSB0aGUgY29ycmVjdCBkZWZhdWx0IGRpc3BsYXlcblx0XHRlbGVtZGlzcGxheVsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF07XG59XG5cblxuXG5cbnZhciBnZXRPZmZzZXQsXG5cdHJ0YWJsZSA9IC9edCg/OmFibGV8ZHxoKSQvaSxcblx0cnJvb3QgPSAvXig/OmJvZHl8aHRtbCkkL2k7XG5cbmlmICggXCJnZXRCb3VuZGluZ0NsaWVudFJlY3RcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdGdldE9mZnNldCA9IGZ1bmN0aW9uKCBlbGVtLCBkb2MsIGRvY0VsZW0sIGJveCApIHtcblx0XHR0cnkge1xuXHRcdFx0Ym94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR9IGNhdGNoKGUpIHt9XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UncmUgbm90IGRlYWxpbmcgd2l0aCBhIGRpc2Nvbm5lY3RlZCBET00gbm9kZVxuXHRcdGlmICggIWJveCB8fCAhalF1ZXJ5LmNvbnRhaW5zKCBkb2NFbGVtLCBlbGVtICkgKSB7XG5cdFx0XHRyZXR1cm4gYm94ID8geyB0b3A6IGJveC50b3AsIGxlZnQ6IGJveC5sZWZ0IH0gOiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdHZhciBib2R5ID0gZG9jLmJvZHksXG5cdFx0XHR3aW4gPSBnZXRXaW5kb3coIGRvYyApLFxuXHRcdFx0Y2xpZW50VG9wICA9IGRvY0VsZW0uY2xpZW50VG9wICB8fCBib2R5LmNsaWVudFRvcCAgfHwgMCxcblx0XHRcdGNsaWVudExlZnQgPSBkb2NFbGVtLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDAsXG5cdFx0XHRzY3JvbGxUb3AgID0gd2luLnBhZ2VZT2Zmc2V0IHx8IGpRdWVyeS5zdXBwb3J0LmJveE1vZGVsICYmIGRvY0VsZW0uc2Nyb2xsVG9wICB8fCBib2R5LnNjcm9sbFRvcCxcblx0XHRcdHNjcm9sbExlZnQgPSB3aW4ucGFnZVhPZmZzZXQgfHwgalF1ZXJ5LnN1cHBvcnQuYm94TW9kZWwgJiYgZG9jRWxlbS5zY3JvbGxMZWZ0IHx8IGJvZHkuc2Nyb2xsTGVmdCxcblx0XHRcdHRvcCAgPSBib3gudG9wICArIHNjcm9sbFRvcCAgLSBjbGllbnRUb3AsXG5cdFx0XHRsZWZ0ID0gYm94LmxlZnQgKyBzY3JvbGxMZWZ0IC0gY2xpZW50TGVmdDtcblxuXHRcdHJldHVybiB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH07XG5cdH07XG5cbn0gZWxzZSB7XG5cdGdldE9mZnNldCA9IGZ1bmN0aW9uKCBlbGVtLCBkb2MsIGRvY0VsZW0gKSB7XG5cdFx0dmFyIGNvbXB1dGVkU3R5bGUsXG5cdFx0XHRvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCxcblx0XHRcdHByZXZPZmZzZXRQYXJlbnQgPSBlbGVtLFxuXHRcdFx0Ym9keSA9IGRvYy5ib2R5LFxuXHRcdFx0ZGVmYXVsdFZpZXcgPSBkb2MuZGVmYXVsdFZpZXcsXG5cdFx0XHRwcmV2Q29tcHV0ZWRTdHlsZSA9IGRlZmF1bHRWaWV3ID8gZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSwgbnVsbCApIDogZWxlbS5jdXJyZW50U3R5bGUsXG5cdFx0XHR0b3AgPSBlbGVtLm9mZnNldFRvcCxcblx0XHRcdGxlZnQgPSBlbGVtLm9mZnNldExlZnQ7XG5cblx0XHR3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtICE9PSBib2R5ICYmIGVsZW0gIT09IGRvY0VsZW0gKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5zdXBwb3J0LmZpeGVkUG9zaXRpb24gJiYgcHJldkNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09IFwiZml4ZWRcIiApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdGNvbXB1dGVkU3R5bGUgPSBkZWZhdWx0VmlldyA/IGRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWxlbSwgbnVsbCkgOiBlbGVtLmN1cnJlbnRTdHlsZTtcblx0XHRcdHRvcCAgLT0gZWxlbS5zY3JvbGxUb3A7XG5cdFx0XHRsZWZ0IC09IGVsZW0uc2Nyb2xsTGVmdDtcblxuXHRcdFx0aWYgKCBlbGVtID09PSBvZmZzZXRQYXJlbnQgKSB7XG5cdFx0XHRcdHRvcCAgKz0gZWxlbS5vZmZzZXRUb3A7XG5cdFx0XHRcdGxlZnQgKz0gZWxlbS5vZmZzZXRMZWZ0O1xuXG5cdFx0XHRcdGlmICggalF1ZXJ5LnN1cHBvcnQuZG9lc05vdEFkZEJvcmRlciAmJiAhKGpRdWVyeS5zdXBwb3J0LmRvZXNBZGRCb3JkZXJGb3JUYWJsZUFuZENlbGxzICYmIHJ0YWJsZS50ZXN0KGVsZW0ubm9kZU5hbWUpKSApIHtcblx0XHRcdFx0XHR0b3AgICs9IHBhcnNlRmxvYXQoIGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGggICkgfHwgMDtcblx0XHRcdFx0XHRsZWZ0ICs9IHBhcnNlRmxvYXQoIGNvbXB1dGVkU3R5bGUuYm9yZGVyTGVmdFdpZHRoICkgfHwgMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHByZXZPZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQ7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGpRdWVyeS5zdXBwb3J0LnN1YnRyYWN0c0JvcmRlckZvck92ZXJmbG93Tm90VmlzaWJsZSAmJiBjb21wdXRlZFN0eWxlLm92ZXJmbG93ICE9PSBcInZpc2libGVcIiApIHtcblx0XHRcdFx0dG9wICArPSBwYXJzZUZsb2F0KCBjb21wdXRlZFN0eWxlLmJvcmRlclRvcFdpZHRoICApIHx8IDA7XG5cdFx0XHRcdGxlZnQgKz0gcGFyc2VGbG9hdCggY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGggKSB8fCAwO1xuXHRcdFx0fVxuXG5cdFx0XHRwcmV2Q29tcHV0ZWRTdHlsZSA9IGNvbXB1dGVkU3R5bGU7XG5cdFx0fVxuXG5cdFx0aWYgKCBwcmV2Q29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gXCJyZWxhdGl2ZVwiIHx8IHByZXZDb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0dG9wICArPSBib2R5Lm9mZnNldFRvcDtcblx0XHRcdGxlZnQgKz0gYm9keS5vZmZzZXRMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LnN1cHBvcnQuZml4ZWRQb3NpdGlvbiAmJiBwcmV2Q29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkge1xuXHRcdFx0dG9wICArPSBNYXRoLm1heCggZG9jRWxlbS5zY3JvbGxUb3AsIGJvZHkuc2Nyb2xsVG9wICk7XG5cdFx0XHRsZWZ0ICs9IE1hdGgubWF4KCBkb2NFbGVtLnNjcm9sbExlZnQsIGJvZHkuc2Nyb2xsTGVmdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH07XG5cdH07XG59XG5cbmpRdWVyeS5mbi5vZmZzZXQgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHR9KTtcblx0fVxuXG5cdHZhciBlbGVtID0gdGhpc1swXSxcblx0XHRkb2MgPSBlbGVtICYmIGVsZW0ub3duZXJEb2N1bWVudDtcblxuXHRpZiAoICFkb2MgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRpZiAoIGVsZW0gPT09IGRvYy5ib2R5ICkge1xuXHRcdHJldHVybiBqUXVlcnkub2Zmc2V0LmJvZHlPZmZzZXQoIGVsZW0gKTtcblx0fVxuXG5cdHJldHVybiBnZXRPZmZzZXQoIGVsZW0sIGRvYywgZG9jLmRvY3VtZW50RWxlbWVudCApO1xufTtcblxualF1ZXJ5Lm9mZnNldCA9IHtcblxuXHRib2R5T2Zmc2V0OiBmdW5jdGlvbiggYm9keSApIHtcblx0XHR2YXIgdG9wID0gYm9keS5vZmZzZXRUb3AsXG5cdFx0XHRsZWZ0ID0gYm9keS5vZmZzZXRMZWZ0O1xuXG5cdFx0aWYgKCBqUXVlcnkuc3VwcG9ydC5kb2VzTm90SW5jbHVkZU1hcmdpbkluQm9keU9mZnNldCApIHtcblx0XHRcdHRvcCAgKz0gcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyhib2R5LCBcIm1hcmdpblRvcFwiKSApIHx8IDA7XG5cdFx0XHRsZWZ0ICs9IHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoYm9keSwgXCJtYXJnaW5MZWZ0XCIpICkgfHwgMDtcblx0XHR9XG5cblx0XHRyZXR1cm4geyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9O1xuXHR9LFxuXG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICk7XG5cblx0XHQvLyBzZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCksXG5cdFx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICksXG5cdFx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKSxcblx0XHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJiBqUXVlcnkuaW5BcnJheShcImF1dG9cIiwgW2N1ckNTU1RvcCwgY3VyQ1NTTGVmdF0pID4gLTEsXG5cdFx0XHRwcm9wcyA9IHt9LCBjdXJQb3NpdGlvbiA9IHt9LCBjdXJUb3AsIGN1ckxlZnQ7XG5cblx0XHQvLyBuZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlciB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBjdXJPZmZzZXQgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWzBdICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIGVsZW0gPSB0aGlzWzBdLFxuXG5cdFx0Ly8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcblx0XHRvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpLFxuXG5cdFx0Ly8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuXHRcdG9mZnNldCAgICAgICA9IHRoaXMub2Zmc2V0KCksXG5cdFx0cGFyZW50T2Zmc2V0ID0gcnJvb3QudGVzdChvZmZzZXRQYXJlbnRbMF0ubm9kZU5hbWUpID8geyB0b3A6IDAsIGxlZnQ6IDAgfSA6IG9mZnNldFBhcmVudC5vZmZzZXQoKTtcblxuXHRcdC8vIFN1YnRyYWN0IGVsZW1lbnQgbWFyZ2luc1xuXHRcdC8vIG5vdGU6IHdoZW4gYW4gZWxlbWVudCBoYXMgbWFyZ2luOiBhdXRvIHRoZSBvZmZzZXRMZWZ0IGFuZCBtYXJnaW5MZWZ0XG5cdFx0Ly8gYXJlIHRoZSBzYW1lIGluIFNhZmFyaSBjYXVzaW5nIG9mZnNldC5sZWZ0IHRvIGluY29ycmVjdGx5IGJlIDBcblx0XHRvZmZzZXQudG9wICAtPSBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKGVsZW0sIFwibWFyZ2luVG9wXCIpICkgfHwgMDtcblx0XHRvZmZzZXQubGVmdCAtPSBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKGVsZW0sIFwibWFyZ2luTGVmdFwiKSApIHx8IDA7XG5cblx0XHQvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcblx0XHRwYXJlbnRPZmZzZXQudG9wICArPSBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKG9mZnNldFBhcmVudFswXSwgXCJib3JkZXJUb3BXaWR0aFwiKSApIHx8IDA7XG5cdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0gcGFyc2VGbG9hdCggalF1ZXJ5LmNzcyhvZmZzZXRQYXJlbnRbMF0sIFwiYm9yZGVyTGVmdFdpZHRoXCIpICkgfHwgMDtcblxuXHRcdC8vIFN1YnRyYWN0IHRoZSB0d28gb2Zmc2V0c1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6ICBvZmZzZXQudG9wICAtIHBhcmVudE9mZnNldC50b3AsXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0XG5cdFx0fTtcblx0fSxcblxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCB8fCBkb2N1bWVudC5ib2R5O1xuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgKCFycm9vdC50ZXN0KG9mZnNldFBhcmVudC5ub2RlTmFtZSkgJiYgalF1ZXJ5LmNzcyhvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIikgPT09IFwic3RhdGljXCIpICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudDtcblx0XHR9KTtcblx0fVxufSk7XG5cblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCgge3Njcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCJ9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gL1kvLnRlc3QoIHByb3AgKTtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXHRcdFx0dmFyIHdpbiA9IGdldFdpbmRvdyggZWxlbSApO1xuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gKHByb3AgaW4gd2luKSA/IHdpblsgcHJvcCBdIDpcblx0XHRcdFx0XHRqUXVlcnkuc3VwcG9ydC5ib3hNb2RlbCAmJiB3aW4uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBtZXRob2QgXSB8fFxuXHRcdFx0XHRcdFx0d2luLmRvY3VtZW50LmJvZHlbIG1ldGhvZCBdIDpcblx0XHRcdFx0XHRlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogalF1ZXJ5KCB3aW4gKS5zY3JvbGxMZWZ0KCksXG5cdFx0XHRcdFx0IHRvcCA/IHZhbCA6IGpRdWVyeSggd2luICkuc2Nyb2xsVG9wKClcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGgsIG51bGwgKTtcblx0fTtcbn0pO1xuXG5mdW5jdGlvbiBnZXRXaW5kb3coIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSA/XG5cdFx0ZWxlbSA6XG5cdFx0ZWxlbS5ub2RlVHlwZSA9PT0gOSA/XG5cdFx0XHRlbGVtLmRlZmF1bHRWaWV3IHx8IGVsZW0ucGFyZW50V2luZG93IDpcblx0XHRcdGZhbHNlO1xufVxuXG5cblxuXG4vLyBDcmVhdGUgd2lkdGgsIGhlaWdodCwgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0dmFyIGNsaWVudFByb3AgPSBcImNsaWVudFwiICsgbmFtZSxcblx0XHRzY3JvbGxQcm9wID0gXCJzY3JvbGxcIiArIG5hbWUsXG5cdFx0b2Zmc2V0UHJvcCA9IFwib2Zmc2V0XCIgKyBuYW1lO1xuXG5cdC8vIGlubmVySGVpZ2h0IGFuZCBpbm5lcldpZHRoXG5cdGpRdWVyeS5mblsgXCJpbm5lclwiICsgbmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWzBdO1xuXHRcdHJldHVybiBlbGVtID9cblx0XHRcdGVsZW0uc3R5bGUgP1xuXHRcdFx0cGFyc2VGbG9hdCggalF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgXCJwYWRkaW5nXCIgKSApIDpcblx0XHRcdHRoaXNbIHR5cGUgXSgpIDpcblx0XHRcdG51bGw7XG5cdH07XG5cblx0Ly8gb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGhcblx0alF1ZXJ5LmZuWyBcIm91dGVyXCIgKyBuYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1swXTtcblx0XHRyZXR1cm4gZWxlbSA/XG5cdFx0XHRlbGVtLnN0eWxlID9cblx0XHRcdHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIG1hcmdpbiA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICkgKSA6XG5cdFx0XHR0aGlzWyB0eXBlIF0oKSA6XG5cdFx0XHRudWxsO1xuXHR9O1xuXG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBqUXVlcnkuYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgZG9jLCBkb2NFbGVtUHJvcCwgb3JpZywgcmV0O1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHQvLyAzcmQgY29uZGl0aW9uIGFsbG93cyBOb2tpYSBzdXBwb3J0LCBhcyBpdCBzdXBwb3J0cyB0aGUgZG9jRWxlbSBwcm9wIGJ1dCBub3QgQ1NTMUNvbXBhdFxuXHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50O1xuXHRcdFx0XHRkb2NFbGVtUHJvcCA9IGRvYy5kb2N1bWVudEVsZW1lbnRbIGNsaWVudFByb3AgXTtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5zdXBwb3J0LmJveE1vZGVsICYmIGRvY0VsZW1Qcm9wIHx8XG5cdFx0XHRcdFx0ZG9jLmJvZHkgJiYgZG9jLmJvZHlbIGNsaWVudFByb3AgXSB8fCBkb2NFbGVtUHJvcDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0sIHdoaWNoZXZlciBpcyBncmVhdGVyXG5cdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdC8vIHdoZW4gYSB3aW5kb3cgPiBkb2N1bWVudCwgSUU2IHJlcG9ydHMgYSBvZmZzZXRbV2lkdGgvSGVpZ2h0XSA+IGNsaWVudFtXaWR0aC9IZWlnaHRdXG5cdFx0XHRcdC8vIHNvIHdlIGNhbid0IHVzZSBtYXgsIGFzIGl0J2xsIGNob29zZSB0aGUgaW5jb3JyZWN0IG9mZnNldFtXaWR0aC9IZWlnaHRdXG5cdFx0XHRcdC8vIGluc3RlYWQgd2UgdXNlIHRoZSBjb3JyZWN0IGNsaWVudFtXaWR0aC9IZWlnaHRdXG5cdFx0XHRcdC8vIHN1cHBvcnQ6SUU2XG5cdFx0XHRcdGlmICggZG9jWyBjbGllbnRQcm9wIF0gPj0gZG9jWyBzY3JvbGxQcm9wIF0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRvY1sgY2xpZW50UHJvcCBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdGVsZW0uYm9keVsgc2Nyb2xsUHJvcCBdLCBkb2NbIHNjcm9sbFByb3AgXSxcblx0XHRcdFx0XHRlbGVtLmJvZHlbIG9mZnNldFByb3AgXSwgZG9jWyBvZmZzZXRQcm9wIF1cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRvcmlnID0galF1ZXJ5LmNzcyggZWxlbSwgdHlwZSApO1xuXHRcdFx0XHRyZXQgPSBwYXJzZUZsb2F0KCBvcmlnICk7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuaXNOdW1lcmljKCByZXQgKSA/IHJldCA6IG9yaWc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRqUXVlcnkoIGVsZW0gKS5jc3MoIHR5cGUsIHZhbHVlICk7XG5cdFx0fSwgdHlwZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGgsIG51bGwgKTtcblx0fTtcbn0pO1xuXG5cblxuXG4vLyBFeHBvc2UgalF1ZXJ5IHRvIHRoZSBnbG9iYWwgb2JqZWN0XG53aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG5cbi8vIEV4cG9zZSBqUXVlcnkgYXMgYW4gQU1EIG1vZHVsZSwgYnV0IG9ubHkgZm9yIEFNRCBsb2FkZXJzIHRoYXRcbi8vIHVuZGVyc3RhbmQgdGhlIGlzc3VlcyB3aXRoIGxvYWRpbmcgbXVsdGlwbGUgdmVyc2lvbnMgb2YgalF1ZXJ5XG4vLyBpbiBhIHBhZ2UgdGhhdCBhbGwgbWlnaHQgY2FsbCBkZWZpbmUoKS4gVGhlIGxvYWRlciB3aWxsIGluZGljYXRlXG4vLyB0aGV5IGhhdmUgc3BlY2lhbCBhbGxvd2FuY2VzIGZvciBtdWx0aXBsZSBqUXVlcnkgdmVyc2lvbnMgYnlcbi8vIHNwZWNpZnlpbmcgZGVmaW5lLmFtZC5qUXVlcnkgPSB0cnVlLiBSZWdpc3RlciBhcyBhIG5hbWVkIG1vZHVsZSxcbi8vIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXIgZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSxcbi8vIGJ1dCBub3QgdXNlIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXQgdW5kZXJzdGFuZHMgYW5vbnltb3VzXG4vLyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdCB3YXkgdG8gcmVnaXN0ZXIuXG4vLyBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZSBkZXJpdmVkIGZyb21cbi8vIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlIGZpbGUgbmFtZS5cbi8vIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHMgdG8gY2FsbFxuLy8gbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgJiYgZGVmaW5lLmFtZC5qUXVlcnkgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpRdWVyeTsgfSApO1xufVxuXG5cblxufSkoIHdpbmRvdyApOyIsIi8qXG4gICAgaHR0cDovL3d3dy5KU09OLm9yZy9qc29uMi5qc1xuICAgIDIwMDktMDYtMjlcblxuICAgIFB1YmxpYyBEb21haW4uXG5cbiAgICBOTyBXQVJSQU5UWSBFWFBSRVNTRUQgT1IgSU1QTElFRC4gVVNFIEFUIFlPVVIgT1dOIFJJU0suXG5cbiAgICBTZWUgaHR0cDovL3d3dy5KU09OLm9yZy9qcy5odG1sXG5cbiAgICBUaGlzIGZpbGUgY3JlYXRlcyBhIGdsb2JhbCBKU09OIG9iamVjdCBjb250YWluaW5nIHR3byBtZXRob2RzOiBzdHJpbmdpZnlcbiAgICBhbmQgcGFyc2UuXG5cbiAgICAgICAgSlNPTi5zdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSlcbiAgICAgICAgICAgIHZhbHVlICAgICAgIGFueSBKYXZhU2NyaXB0IHZhbHVlLCB1c3VhbGx5IGFuIG9iamVjdCBvciBhcnJheS5cblxuICAgICAgICAgICAgcmVwbGFjZXIgICAgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgZGV0ZXJtaW5lcyBob3cgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgYXJlIHN0cmluZ2lmaWVkIGZvciBvYmplY3RzLiBJdCBjYW4gYmUgYVxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cblxuICAgICAgICAgICAgc3BhY2UgICAgICAgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgb2YgbmVzdGVkIHN0cnVjdHVyZXMuIElmIGl0IGlzIG9taXR0ZWQsIHRoZSB0ZXh0IHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlIHBhY2tlZCB3aXRob3V0IGV4dHJhIHdoaXRlc3BhY2UuIElmIGl0IGlzIGEgbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXQgd2lsbCBzcGVjaWZ5IHRoZSBudW1iZXIgb2Ygc3BhY2VzIHRvIGluZGVudCBhdCBlYWNoXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbC4gSWYgaXQgaXMgYSBzdHJpbmcgKHN1Y2ggYXMgJ1xcdCcgb3IgJyZuYnNwOycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXQgY29udGFpbnMgdGhlIGNoYXJhY3RlcnMgdXNlZCB0byBpbmRlbnQgYXQgZWFjaCBsZXZlbC5cblxuICAgICAgICAgICAgVGhpcyBtZXRob2QgcHJvZHVjZXMgYSBKU09OIHRleHQgZnJvbSBhIEphdmFTY3JpcHQgdmFsdWUuXG5cbiAgICAgICAgICAgIFdoZW4gYW4gb2JqZWN0IHZhbHVlIGlzIGZvdW5kLCBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIGEgdG9KU09OXG4gICAgICAgICAgICBtZXRob2QsIGl0cyB0b0pTT04gbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGFuZCB0aGUgcmVzdWx0IHdpbGwgYmVcbiAgICAgICAgICAgIHN0cmluZ2lmaWVkLiBBIHRvSlNPTiBtZXRob2QgZG9lcyBub3Qgc2VyaWFsaXplOiBpdCByZXR1cm5zIHRoZVxuICAgICAgICAgICAgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIG5hbWUvdmFsdWUgcGFpciB0aGF0IHNob3VsZCBiZSBzZXJpYWxpemVkLFxuICAgICAgICAgICAgb3IgdW5kZWZpbmVkIGlmIG5vdGhpbmcgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSB0b0pTT04gbWV0aG9kXG4gICAgICAgICAgICB3aWxsIGJlIHBhc3NlZCB0aGUga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgdmFsdWUsIGFuZCB0aGlzIHdpbGwgYmVcbiAgICAgICAgICAgIGJvdW5kIHRvIHRoZSBvYmplY3QgaG9sZGluZyB0aGUga2V5LlxuXG4gICAgICAgICAgICBGb3IgZXhhbXBsZSwgdGhpcyB3b3VsZCBzZXJpYWxpemUgRGF0ZXMgYXMgSVNPIHN0cmluZ3MuXG5cbiAgICAgICAgICAgICAgICBEYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGYobikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9ybWF0IGludGVnZXJzIHRvIGhhdmUgYXQgbGVhc3QgdHdvIGRpZ2l0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuIDogbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFVUQ0Z1bGxZZWFyKCkgICArICctJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0RhdGUoKSkgICAgICArICdUJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0hvdXJzKCkpICAgICArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01pbnV0ZXMoKSkgICArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ1NlY29uZHMoKSkgICArICdaJztcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWwgcmVwbGFjZXIgbWV0aG9kLiBJdCB3aWxsIGJlIHBhc3NlZCB0aGVcbiAgICAgICAgICAgIGtleSBhbmQgdmFsdWUgb2YgZWFjaCBtZW1iZXIsIHdpdGggdGhpcyBib3VuZCB0byB0aGUgY29udGFpbmluZ1xuICAgICAgICAgICAgb2JqZWN0LiBUaGUgdmFsdWUgdGhhdCBpcyByZXR1cm5lZCBmcm9tIHlvdXIgbWV0aG9kIHdpbGwgYmVcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQuIElmIHlvdXIgbWV0aG9kIHJldHVybnMgdW5kZWZpbmVkLCB0aGVuIHRoZSBtZW1iZXIgd2lsbFxuICAgICAgICAgICAgYmUgZXhjbHVkZWQgZnJvbSB0aGUgc2VyaWFsaXphdGlvbi5cblxuICAgICAgICAgICAgSWYgdGhlIHJlcGxhY2VyIHBhcmFtZXRlciBpcyBhbiBhcnJheSBvZiBzdHJpbmdzLCB0aGVuIGl0IHdpbGwgYmVcbiAgICAgICAgICAgIHVzZWQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlIHNlcmlhbGl6ZWQuIEl0IGZpbHRlcnMgdGhlIHJlc3VsdHNcbiAgICAgICAgICAgIHN1Y2ggdGhhdCBvbmx5IG1lbWJlcnMgd2l0aCBrZXlzIGxpc3RlZCBpbiB0aGUgcmVwbGFjZXIgYXJyYXkgYXJlXG4gICAgICAgICAgICBzdHJpbmdpZmllZC5cblxuICAgICAgICAgICAgVmFsdWVzIHRoYXQgZG8gbm90IGhhdmUgSlNPTiByZXByZXNlbnRhdGlvbnMsIHN1Y2ggYXMgdW5kZWZpbmVkIG9yXG4gICAgICAgICAgICBmdW5jdGlvbnMsIHdpbGwgbm90IGJlIHNlcmlhbGl6ZWQuIFN1Y2ggdmFsdWVzIGluIG9iamVjdHMgd2lsbCBiZVxuICAgICAgICAgICAgZHJvcHBlZDsgaW4gYXJyYXlzIHRoZXkgd2lsbCBiZSByZXBsYWNlZCB3aXRoIG51bGwuIFlvdSBjYW4gdXNlXG4gICAgICAgICAgICBhIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIHJlcGxhY2UgdGhvc2Ugd2l0aCBKU09OIHZhbHVlcy5cbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHVuZGVmaW5lZCkgcmV0dXJucyB1bmRlZmluZWQuXG5cbiAgICAgICAgICAgIFRoZSBvcHRpb25hbCBzcGFjZSBwYXJhbWV0ZXIgcHJvZHVjZXMgYSBzdHJpbmdpZmljYXRpb24gb2YgdGhlXG4gICAgICAgICAgICB2YWx1ZSB0aGF0IGlzIGZpbGxlZCB3aXRoIGxpbmUgYnJlYWtzIGFuZCBpbmRlbnRhdGlvbiB0byBtYWtlIGl0XG4gICAgICAgICAgICBlYXNpZXIgdG8gcmVhZC5cblxuICAgICAgICAgICAgSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG5vbi1lbXB0eSBzdHJpbmcsIHRoZW4gdGhhdCBzdHJpbmcgd2lsbFxuICAgICAgICAgICAgYmUgdXNlZCBmb3IgaW5kZW50YXRpb24uIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIHRoZW5cbiAgICAgICAgICAgIHRoZSBpbmRlbnRhdGlvbiB3aWxsIGJlIHRoYXQgbWFueSBzcGFjZXMuXG5cbiAgICAgICAgICAgIEV4YW1wbGU6XG5cbiAgICAgICAgICAgIHRleHQgPSBKU09OLnN0cmluZ2lmeShbJ2UnLCB7cGx1cmlidXM6ICd1bnVtJ31dKTtcbiAgICAgICAgICAgIC8vIHRleHQgaXMgJ1tcImVcIix7XCJwbHVyaWJ1c1wiOlwidW51bVwifV0nXG5cblxuICAgICAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KFsnZScsIHtwbHVyaWJ1czogJ3VudW0nfV0sIG51bGwsICdcXHQnKTtcbiAgICAgICAgICAgIC8vIHRleHQgaXMgJ1tcXG5cXHRcImVcIixcXG5cXHR7XFxuXFx0XFx0XCJwbHVyaWJ1c1wiOiBcInVudW1cIlxcblxcdH1cXG5dJ1xuXG4gICAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW25ldyBEYXRlKCldLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2tleV0gaW5zdGFuY2VvZiBEYXRlID9cbiAgICAgICAgICAgICAgICAgICAgJ0RhdGUoJyArIHRoaXNba2V5XSArICcpJyA6IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB0ZXh0IGlzICdbXCJEYXRlKC0tLWN1cnJlbnQgdGltZS0tLSlcIl0nXG5cblxuICAgICAgICBKU09OLnBhcnNlKHRleHQsIHJldml2ZXIpXG4gICAgICAgICAgICBUaGlzIG1ldGhvZCBwYXJzZXMgYSBKU09OIHRleHQgdG8gcHJvZHVjZSBhbiBvYmplY3Qgb3IgYXJyYXkuXG4gICAgICAgICAgICBJdCBjYW4gdGhyb3cgYSBTeW50YXhFcnJvciBleGNlcHRpb24uXG5cbiAgICAgICAgICAgIFRoZSBvcHRpb25hbCByZXZpdmVyIHBhcmFtZXRlciBpcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGZpbHRlciBhbmRcbiAgICAgICAgICAgIHRyYW5zZm9ybSB0aGUgcmVzdWx0cy4gSXQgcmVjZWl2ZXMgZWFjaCBvZiB0aGUga2V5cyBhbmQgdmFsdWVzLFxuICAgICAgICAgICAgYW5kIGl0cyByZXR1cm4gdmFsdWUgaXMgdXNlZCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbiAgICAgICAgICAgIElmIGl0IHJldHVybnMgd2hhdCBpdCByZWNlaXZlZCwgdGhlbiB0aGUgc3RydWN0dXJlIGlzIG5vdCBtb2RpZmllZC5cbiAgICAgICAgICAgIElmIGl0IHJldHVybnMgdW5kZWZpbmVkIHRoZW4gdGhlIG1lbWJlciBpcyBkZWxldGVkLlxuXG4gICAgICAgICAgICBFeGFtcGxlOlxuXG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgdGV4dC4gVmFsdWVzIHRoYXQgbG9vayBsaWtlIElTTyBkYXRlIHN0cmluZ3Mgd2lsbFxuICAgICAgICAgICAgLy8gYmUgY29udmVydGVkIHRvIERhdGUgb2JqZWN0cy5cblxuICAgICAgICAgICAgbXlEYXRhID0gSlNPTi5wYXJzZSh0ZXh0LCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBhO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPVxuL14oXFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KVQoXFxkezJ9KTooXFxkezJ9KTooXFxkezJ9KD86XFwuXFxkKik/KVokLy5leGVjKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygrYVsxXSwgK2FbMl0gLSAxLCArYVszXSwgK2FbNF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgK2FbNV0sICthWzZdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG15RGF0YSA9IEpTT04ucGFyc2UoJ1tcIkRhdGUoMDkvMDkvMjAwMSlcIl0nLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBkO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgwLCA1KSA9PT0gJ0RhdGUoJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2xpY2UoLTEpID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IG5ldyBEYXRlKHZhbHVlLnNsaWNlKDUsIC0xKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgVGhpcyBpcyBhIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbi4gWW91IGFyZSBmcmVlIHRvIGNvcHksIG1vZGlmeSwgb3JcbiAgICByZWRpc3RyaWJ1dGUuXG5cbiAgICBUaGlzIGNvZGUgc2hvdWxkIGJlIG1pbmlmaWVkIGJlZm9yZSBkZXBsb3ltZW50LlxuICAgIFNlZSBodHRwOi8vamF2YXNjcmlwdC5jcm9ja2ZvcmQuY29tL2pzbWluLmh0bWxcblxuICAgIFVTRSBZT1VSIE9XTiBDT1BZLiBJVCBJUyBFWFRSRU1FTFkgVU5XSVNFIFRPIExPQUQgQ09ERSBGUk9NIFNFUlZFUlMgWU9VIERPXG4gICAgTk9UIENPTlRST0wuXG4qL1xuXG4vKmpzbGludCBldmlsOiB0cnVlICovXG5cbi8qbWVtYmVycyBcIlwiLCBcIlxcYlwiLCBcIlxcdFwiLCBcIlxcblwiLCBcIlxcZlwiLCBcIlxcclwiLCBcIlxcXCJcIiwgSlNPTiwgXCJcXFxcXCIsIGFwcGx5LFxuICAgIGNhbGwsIGNoYXJDb2RlQXQsIGdldFVUQ0RhdGUsIGdldFVUQ0Z1bGxZZWFyLCBnZXRVVENIb3VycyxcbiAgICBnZXRVVENNaW51dGVzLCBnZXRVVENNb250aCwgZ2V0VVRDU2Vjb25kcywgaGFzT3duUHJvcGVydHksIGpvaW4sXG4gICAgbGFzdEluZGV4LCBsZW5ndGgsIHBhcnNlLCBwcm90b3R5cGUsIHB1c2gsIHJlcGxhY2UsIHNsaWNlLCBzdHJpbmdpZnksXG4gICAgdGVzdCwgdG9KU09OLCB0b1N0cmluZywgdmFsdWVPZlxuKi9cblxuLy8gQ3JlYXRlIGEgSlNPTiBvYmplY3Qgb25seSBpZiBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC4gV2UgY3JlYXRlIHRoZVxuLy8gbWV0aG9kcyBpbiBhIGNsb3N1cmUgdG8gYXZvaWQgY3JlYXRpbmcgZ2xvYmFsIHZhcmlhYmxlcy5cblxudmFyIEpTT04gPSBKU09OIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgZnVuY3Rpb24gZihuKSB7XG4gICAgICAgIC8vIEZvcm1hdCBpbnRlZ2VycyB0byBoYXZlIGF0IGxlYXN0IHR3byBkaWdpdHMuXG4gICAgICAgIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuIDogbjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIERhdGUucHJvdG90eXBlLnRvSlNPTiAhPT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHRoaXMudmFsdWVPZigpKSA/XG4gICAgICAgICAgICAgICAgICAgdGhpcy5nZXRVVENGdWxsWWVhcigpICAgKyAnLScgK1xuICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0RhdGUoKSkgICAgICArICdUJyArXG4gICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENIb3VycygpKSAgICAgKyAnOicgK1xuICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDTWludXRlcygpKSAgICsgJzonICtcbiAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ1NlY29uZHMoKSkgICArICdaJyA6IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgU3RyaW5nLnByb3RvdHlwZS50b0pTT04gPVxuICAgICAgICBOdW1iZXIucHJvdG90eXBlLnRvSlNPTiA9XG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgY3ggPSAvW1xcdTAwMDBcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICAgICAgZXNjYXBhYmxlID0gL1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4OWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICAgICAgZ2FwLFxuICAgICAgICBpbmRlbnQsXG4gICAgICAgIG1ldGEgPSB7ICAgIC8vIHRhYmxlIG9mIGNoYXJhY3RlciBzdWJzdGl0dXRpb25zXG4gICAgICAgICAgICAnXFxiJzogJ1xcXFxiJyxcbiAgICAgICAgICAgICdcXHQnOiAnXFxcXHQnLFxuICAgICAgICAgICAgJ1xcbic6ICdcXFxcbicsXG4gICAgICAgICAgICAnXFxmJzogJ1xcXFxmJyxcbiAgICAgICAgICAgICdcXHInOiAnXFxcXHInLFxuICAgICAgICAgICAgJ1wiJyA6ICdcXFxcXCInLFxuICAgICAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXG4gICAgICAgIH0sXG4gICAgICAgIHJlcDtcblxuXG4gICAgZnVuY3Rpb24gcXVvdGUoc3RyaW5nKSB7XG5cbi8vIElmIHRoZSBzdHJpbmcgY29udGFpbnMgbm8gY29udHJvbCBjaGFyYWN0ZXJzLCBubyBxdW90ZSBjaGFyYWN0ZXJzLCBhbmQgbm9cbi8vIGJhY2tzbGFzaCBjaGFyYWN0ZXJzLCB0aGVuIHdlIGNhbiBzYWZlbHkgc2xhcCBzb21lIHF1b3RlcyBhcm91bmQgaXQuXG4vLyBPdGhlcndpc2Ugd2UgbXVzdCBhbHNvIHJlcGxhY2UgdGhlIG9mZmVuZGluZyBjaGFyYWN0ZXJzIHdpdGggc2FmZSBlc2NhcGVcbi8vIHNlcXVlbmNlcy5cblxuICAgICAgICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIGVzY2FwYWJsZS50ZXN0KHN0cmluZykgP1xuICAgICAgICAgICAgJ1wiJyArIHN0cmluZy5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJyA/IGMgOlxuICAgICAgICAgICAgICAgICAgICAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgICAgIH0pICsgJ1wiJyA6XG4gICAgICAgICAgICAnXCInICsgc3RyaW5nICsgJ1wiJztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHN0cihrZXksIGhvbGRlcikge1xuXG4vLyBQcm9kdWNlIGEgc3RyaW5nIGZyb20gaG9sZGVyW2tleV0uXG5cbiAgICAgICAgdmFyIGksICAgICAgICAgIC8vIFRoZSBsb29wIGNvdW50ZXIuXG4gICAgICAgICAgICBrLCAgICAgICAgICAvLyBUaGUgbWVtYmVyIGtleS5cbiAgICAgICAgICAgIHYsICAgICAgICAgIC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgICBtaW5kID0gZ2FwLFxuICAgICAgICAgICAgcGFydGlhbCxcbiAgICAgICAgICAgIHZhbHVlID0gaG9sZGVyW2tleV07XG5cbi8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oa2V5KTtcbiAgICAgICAgfVxuXG4vLyBJZiB3ZSB3ZXJlIGNhbGxlZCB3aXRoIGEgcmVwbGFjZXIgZnVuY3Rpb24sIHRoZW4gY2FsbCB0aGUgcmVwbGFjZXIgdG9cbi8vIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHJlcC5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICByZXR1cm4gcXVvdGUodmFsdWUpO1xuXG4gICAgICAgIGNhc2UgJ251bWJlcic6XG5cbi8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gRW5jb2RlIG5vbi1maW5pdGUgbnVtYmVycyBhcyBudWxsLlxuXG4gICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6ICdudWxsJztcblxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgY2FzZSAnbnVsbCc6XG5cbi8vIElmIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4gb3IgbnVsbCwgY29udmVydCBpdCB0byBhIHN0cmluZy4gTm90ZTpcbi8vIHR5cGVvZiBudWxsIGRvZXMgbm90IHByb2R1Y2UgJ251bGwnLiBUaGUgY2FzZSBpcyBpbmNsdWRlZCBoZXJlIGluXG4vLyB0aGUgcmVtb3RlIGNoYW5jZSB0aGF0IHRoaXMgZ2V0cyBmaXhlZCBzb21lZGF5LlxuXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcblxuLy8gSWYgdGhlIHR5cGUgaXMgJ29iamVjdCcsIHdlIG1pZ2h0IGJlIGRlYWxpbmcgd2l0aCBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgb3Jcbi8vIG51bGwuXG5cbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcblxuLy8gRHVlIHRvIGEgc3BlY2lmaWNhdGlvbiBibHVuZGVyIGluIEVDTUFTY3JpcHQsIHR5cGVvZiBudWxsIGlzICdvYmplY3QnLFxuLy8gc28gd2F0Y2ggb3V0IGZvciB0aGF0IGNhc2UuXG5cbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICAgICAgfVxuXG4vLyBNYWtlIGFuIGFycmF5IHRvIGhvbGQgdGhlIHBhcnRpYWwgcmVzdWx0cyBvZiBzdHJpbmdpZnlpbmcgdGhpcyBvYmplY3QgdmFsdWUuXG5cbiAgICAgICAgICAgIGdhcCArPSBpbmRlbnQ7XG4gICAgICAgICAgICBwYXJ0aWFsID0gW107XG5cbi8vIElzIHRoZSB2YWx1ZSBhbiBhcnJheT9cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG5cbi8vIFRoZSB2YWx1ZSBpcyBhbiBhcnJheS4gU3RyaW5naWZ5IGV2ZXJ5IGVsZW1lbnQuIFVzZSBudWxsIGFzIGEgcGxhY2Vob2xkZXJcbi8vIGZvciBub24tSlNPTiB2YWx1ZXMuXG5cbiAgICAgICAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWxbaV0gPSBzdHIoaSwgdmFsdWUpIHx8ICdudWxsJztcbiAgICAgICAgICAgICAgICB9XG5cbi8vIEpvaW4gYWxsIG9mIHRoZSBlbGVtZW50cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLCBhbmQgd3JhcCB0aGVtIGluXG4vLyBicmFja2V0cy5cblxuICAgICAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICdbXScgOlxuICAgICAgICAgICAgICAgICAgICBnYXAgPyAnW1xcbicgKyBnYXAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5kICsgJ10nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ1snICsgcGFydGlhbC5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cblxuLy8gSWYgdGhlIHJlcGxhY2VyIGlzIGFuIGFycmF5LCB1c2UgaXQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlIHN0cmluZ2lmaWVkLlxuXG4gICAgICAgICAgICBpZiAocmVwICYmIHR5cGVvZiByZXAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcmVwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IHJlcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcblxuLy8gT3RoZXJ3aXNlLCBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG5cbiAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4vLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4vLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cblxuICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ3t9JyA6XG4gICAgICAgICAgICAgICAgZ2FwID8gJ3tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5kICsgJ30nIDogJ3snICsgcGFydGlhbC5qb2luKCcsJykgKyAnfSc7XG4gICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICB9XG5cbi8vIElmIHRoZSBKU09OIG9iamVjdCBkb2VzIG5vdCB5ZXQgaGF2ZSBhIHN0cmluZ2lmeSBtZXRob2QsIGdpdmUgaXQgb25lLlxuXG4gICAgaWYgKHR5cGVvZiBKU09OLnN0cmluZ2lmeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBKU09OLnN0cmluZ2lmeSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XG5cbi8vIFRoZSBzdHJpbmdpZnkgbWV0aG9kIHRha2VzIGEgdmFsdWUgYW5kIGFuIG9wdGlvbmFsIHJlcGxhY2VyLCBhbmQgYW4gb3B0aW9uYWxcbi8vIHNwYWNlIHBhcmFtZXRlciwgYW5kIHJldHVybnMgYSBKU09OIHRleHQuIFRoZSByZXBsYWNlciBjYW4gYmUgYSBmdW5jdGlvblxuLy8gdGhhdCBjYW4gcmVwbGFjZSB2YWx1ZXMsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCB3aWxsIHNlbGVjdCB0aGUga2V5cy5cbi8vIEEgZGVmYXVsdCByZXBsYWNlciBtZXRob2QgY2FuIGJlIHByb3ZpZGVkLiBVc2Ugb2YgdGhlIHNwYWNlIHBhcmFtZXRlciBjYW5cbi8vIHByb2R1Y2UgdGV4dCB0aGF0IGlzIG1vcmUgZWFzaWx5IHJlYWRhYmxlLlxuXG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGdhcCA9ICcnO1xuICAgICAgICAgICAgaW5kZW50ID0gJyc7XG5cbi8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIG1ha2UgYW4gaW5kZW50IHN0cmluZyBjb250YWluaW5nIHRoYXRcbi8vIG1hbnkgc3BhY2VzLlxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGFjZTsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCArPSAnICc7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGluZGVudCBzdHJpbmcuXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGluZGVudCA9IHNwYWNlO1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGVyZSBpcyBhIHJlcGxhY2VyLCBpdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkuXG4vLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yLlxuXG4gICAgICAgICAgICByZXAgPSByZXBsYWNlcjtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlciAmJiB0eXBlb2YgcmVwbGFjZXIgIT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiByZXBsYWNlciAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXBsYWNlci5sZW5ndGggIT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlNPTi5zdHJpbmdpZnknKTtcbiAgICAgICAgICAgIH1cblxuLy8gTWFrZSBhIGZha2Ugcm9vdCBvYmplY3QgY29udGFpbmluZyBvdXIgdmFsdWUgdW5kZXIgdGhlIGtleSBvZiAnJy5cbi8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHN0cmluZ2lmeWluZyB0aGUgdmFsdWUuXG5cbiAgICAgICAgICAgIHJldHVybiBzdHIoJycsIHsnJzogdmFsdWV9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cblxuLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgcGFyc2UgbWV0aG9kLCBnaXZlIGl0IG9uZS5cblxuICAgIGlmICh0eXBlb2YgSlNPTi5wYXJzZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBKU09OLnBhcnNlID0gZnVuY3Rpb24gKHRleHQsIHJldml2ZXIpIHtcblxuLy8gVGhlIHBhcnNlIG1ldGhvZCB0YWtlcyBhIHRleHQgYW5kIGFuIG9wdGlvbmFsIHJldml2ZXIgZnVuY3Rpb24sIGFuZCByZXR1cm5zXG4vLyBhIEphdmFTY3JpcHQgdmFsdWUgaWYgdGhlIHRleHQgaXMgYSB2YWxpZCBKU09OIHRleHQuXG5cbiAgICAgICAgICAgIHZhciBqO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB3YWxrKGhvbGRlciwga2V5KSB7XG5cbi8vIFRoZSB3YWxrIG1ldGhvZCBpcyB1c2VkIHRvIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIHJlc3VsdGluZyBzdHJ1Y3R1cmUgc29cbi8vIHRoYXQgbW9kaWZpY2F0aW9ucyBjYW4gYmUgbWFkZS5cblxuICAgICAgICAgICAgICAgIHZhciBrLCB2LCB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB3YWxrKHZhbHVlLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXZpdmVyLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuXG4vLyBQYXJzaW5nIGhhcHBlbnMgaW4gZm91ciBzdGFnZXMuIEluIHRoZSBmaXJzdCBzdGFnZSwgd2UgcmVwbGFjZSBjZXJ0YWluXG4vLyBVbmljb2RlIGNoYXJhY3RlcnMgd2l0aCBlc2NhcGUgc2VxdWVuY2VzLiBKYXZhU2NyaXB0IGhhbmRsZXMgbWFueSBjaGFyYWN0ZXJzXG4vLyBpbmNvcnJlY3RseSwgZWl0aGVyIHNpbGVudGx5IGRlbGV0aW5nIHRoZW0sIG9yIHRyZWF0aW5nIHRoZW0gYXMgbGluZSBlbmRpbmdzLlxuXG4gICAgICAgICAgICBjeC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaWYgKGN4LnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKGN4LCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx1JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4vLyBJbiB0aGUgc2Vjb25kIHN0YWdlLCB3ZSBydW4gdGhlIHRleHQgYWdhaW5zdCByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbG9va1xuLy8gZm9yIG5vbi1KU09OIHBhdHRlcm5zLiBXZSBhcmUgZXNwZWNpYWxseSBjb25jZXJuZWQgd2l0aCAnKCknIGFuZCAnbmV3J1xuLy8gYmVjYXVzZSB0aGV5IGNhbiBjYXVzZSBpbnZvY2F0aW9uLCBhbmQgJz0nIGJlY2F1c2UgaXQgY2FuIGNhdXNlIG11dGF0aW9uLlxuLy8gQnV0IGp1c3QgdG8gYmUgc2FmZSwgd2Ugd2FudCB0byByZWplY3QgYWxsIHVuZXhwZWN0ZWQgZm9ybXMuXG5cbi8vIFdlIHNwbGl0IHRoZSBzZWNvbmQgc3RhZ2UgaW50byA0IHJlZ2V4cCBvcGVyYXRpb25zIGluIG9yZGVyIHRvIHdvcmsgYXJvdW5kXG4vLyBjcmlwcGxpbmcgaW5lZmZpY2llbmNpZXMgaW4gSUUncyBhbmQgU2FmYXJpJ3MgcmVnZXhwIGVuZ2luZXMuIEZpcnN0IHdlXG4vLyByZXBsYWNlIHRoZSBKU09OIGJhY2tzbGFzaCBwYWlycyB3aXRoICdAJyAoYSBub24tSlNPTiBjaGFyYWN0ZXIpLiBTZWNvbmQsIHdlXG4vLyByZXBsYWNlIGFsbCBzaW1wbGUgdmFsdWUgdG9rZW5zIHdpdGggJ10nIGNoYXJhY3RlcnMuIFRoaXJkLCB3ZSBkZWxldGUgYWxsXG4vLyBvcGVuIGJyYWNrZXRzIHRoYXQgZm9sbG93IGEgY29sb24gb3IgY29tbWEgb3IgdGhhdCBiZWdpbiB0aGUgdGV4dC4gRmluYWxseSxcbi8vIHdlIGxvb2sgdG8gc2VlIHRoYXQgdGhlIHJlbWFpbmluZyBjaGFyYWN0ZXJzIGFyZSBvbmx5IHdoaXRlc3BhY2Ugb3IgJ10nIG9yXG4vLyAnLCcgb3IgJzonIG9yICd7JyBvciAnfScuIElmIHRoYXQgaXMgc28sIHRoZW4gdGhlIHRleHQgaXMgc2FmZSBmb3IgZXZhbC5cblxuICAgICAgICAgICAgaWYgKC9eW1xcXSw6e31cXHNdKiQvLlxudGVzdCh0ZXh0LnJlcGxhY2UoL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbMC05YS1mQS1GXXs0fSkvZywgJ0AnKS5cbnJlcGxhY2UoL1wiW15cIlxcXFxcXG5cXHJdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nLCAnXScpLlxucmVwbGFjZSgvKD86Xnw6fCwpKD86XFxzKlxcWykrL2csICcnKSkpIHtcblxuLy8gSW4gdGhlIHRoaXJkIHN0YWdlIHdlIHVzZSB0aGUgZXZhbCBmdW5jdGlvbiB0byBjb21waWxlIHRoZSB0ZXh0IGludG8gYVxuLy8gSmF2YVNjcmlwdCBzdHJ1Y3R1cmUuIFRoZSAneycgb3BlcmF0b3IgaXMgc3ViamVjdCB0byBhIHN5bnRhY3RpYyBhbWJpZ3VpdHlcbi8vIGluIEphdmFTY3JpcHQ6IGl0IGNhbiBiZWdpbiBhIGJsb2NrIG9yIGFuIG9iamVjdCBsaXRlcmFsLiBXZSB3cmFwIHRoZSB0ZXh0XG4vLyBpbiBwYXJlbnMgdG8gZWxpbWluYXRlIHRoZSBhbWJpZ3VpdHkuXG5cbiAgICAgICAgICAgICAgICBqID0gZXZhbCgnKCcgKyB0ZXh0ICsgJyknKTtcblxuLy8gSW4gdGhlIG9wdGlvbmFsIGZvdXJ0aCBzdGFnZSwgd2UgcmVjdXJzaXZlbHkgd2FsayB0aGUgbmV3IHN0cnVjdHVyZSwgcGFzc2luZ1xuLy8gZWFjaCBuYW1lL3ZhbHVlIHBhaXIgdG8gYSByZXZpdmVyIGZ1bmN0aW9uIGZvciBwb3NzaWJsZSB0cmFuc2Zvcm1hdGlvbi5cblxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgICAgIHdhbGsoeycnOiBqfSwgJycpIDogajtcbiAgICAgICAgICAgIH1cblxuLy8gSWYgdGhlIHRleHQgaXMgbm90IEpTT04gcGFyc2VhYmxlLCB0aGVuIGEgU3ludGF4RXJyb3IgaXMgdGhyb3duLlxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0pTT04ucGFyc2UnKTtcbiAgICAgICAgfTtcbiAgICB9XG59KCkpO1xuIiwiLypcbiAqIGpzVHJlZSAoY3VzdG9tIHZlcnNpb24gZm9yIFNpbHZlclN0cmlwZTogMS4wLXJjMyArIG1pbm9yIGJ1Z2ZpeGVzKVxuICogaHR0cDovL2pzdHJlZS5jb20vXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwIEl2YW4gQm96aGFub3YgKHZha2F0YS5jb20pXG4gKlxuICogTGljZW5zZWQgc2FtZSBhcyBqcXVlcnkgLSB1bmRlciB0aGUgdGVybXMgb2YgZWl0aGVyIHRoZSBNSVQgTGljZW5zZSBvciB0aGUgR1BMIFZlcnNpb24gMiBMaWNlbnNlXG4gKiAgIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKiAgIGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwuaHRtbFxuICpcbiAqICREYXRlOiAyMDExLTAyLTA5IDAxOjE3OjE0ICswMjAwICjRgdGALCAwOSDRhNC10LLRgCAyMDExKSAkXG4gKiAkUmV2aXNpb246IDIzNiAkXG4gKi9cblxuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgb25ldmFyOiB0cnVlLCB1bmRlZjogdHJ1ZSwgYml0d2lzZTogdHJ1ZSwgc3RyaWN0OiB0cnVlICovXG4vKmdsb2JhbCB3aW5kb3cgOiBmYWxzZSwgY2xlYXJJbnRlcnZhbDogZmFsc2UsIGNsZWFyVGltZW91dDogZmFsc2UsIGRvY3VtZW50OiBmYWxzZSwgc2V0SW50ZXJ2YWw6IGZhbHNlLCBzZXRUaW1lb3V0OiBmYWxzZSwgalF1ZXJ5OiBmYWxzZSwgbmF2aWdhdG9yOiBmYWxzZSwgWFNMVFByb2Nlc3NvcjogZmFsc2UsIERPTVBhcnNlcjogZmFsc2UsIFhNTFNlcmlhbGl6ZXI6IGZhbHNlKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIHRvcCB3cmFwcGVyIHRvIHByZXZlbnQgbXVsdGlwbGUgaW5jbHVzaW9uIChpcyB0aGlzIE9LPylcbihmdW5jdGlvbiAoKSB7IGlmKGpRdWVyeSAmJiBqUXVlcnkuanN0cmVlKSB7IHJldHVybjsgfVxuXHR2YXIgaXNfaWU2ID0gZmFsc2UsIGlzX2llNyA9IGZhbHNlLCBpc19mZjIgPSBmYWxzZTtcblxuLyogXG4gKiBqc1RyZWUgY29yZVxuICovXG4oZnVuY3Rpb24gKCQpIHtcblx0Ly8gQ29tbW9uIGZ1bmN0aW9ucyBub3QgcmVsYXRlZCB0byBqc1RyZWUgXG5cdC8vIGRlY2lkZWQgdG8gbW92ZSB0aGVtIHRvIGEgYHZha2F0YWAgXCJuYW1lc3BhY2VcIlxuXHQkLnZha2F0YSA9IHt9O1xuXHQvLyBDU1MgcmVsYXRlZCBmdW5jdGlvbnNcblx0JC52YWthdGEuY3NzID0ge1xuXHRcdGdldF9jc3MgOiBmdW5jdGlvbihydWxlX25hbWUsIGRlbGV0ZV9mbGFnLCBzaGVldCkge1xuXHRcdFx0cnVsZV9uYW1lID0gcnVsZV9uYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR2YXIgY3NzX3J1bGVzID0gc2hlZXQuY3NzUnVsZXMgfHwgc2hlZXQucnVsZXMsXG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRpZihjc3NfcnVsZXMubGVuZ3RoICYmIGogPiBjc3NfcnVsZXMubGVuZ3RoICsgNSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0aWYoY3NzX3J1bGVzW2pdLnNlbGVjdG9yVGV4dCAmJiBjc3NfcnVsZXNbal0uc2VsZWN0b3JUZXh0LnRvTG93ZXJDYXNlKCkgPT0gcnVsZV9uYW1lKSB7XG5cdFx0XHRcdFx0aWYoZGVsZXRlX2ZsYWcgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdGlmKHNoZWV0LnJlbW92ZVJ1bGUpIHsgc2hlZXQucmVtb3ZlUnVsZShqKTsgfVxuXHRcdFx0XHRcdFx0aWYoc2hlZXQuZGVsZXRlUnVsZSkgeyBzaGVldC5kZWxldGVSdWxlKGopOyB9XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7IHJldHVybiBjc3NfcnVsZXNbal07IH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKGNzc19ydWxlc1srK2pdKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFkZF9jc3MgOiBmdW5jdGlvbihydWxlX25hbWUsIHNoZWV0KSB7XG5cdFx0XHRpZigkLmpzdHJlZS5jc3MuZ2V0X2NzcyhydWxlX25hbWUsIGZhbHNlLCBzaGVldCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRpZihzaGVldC5pbnNlcnRSdWxlKSB7IHNoZWV0Lmluc2VydFJ1bGUocnVsZV9uYW1lICsgJyB7IH0nLCAwKTsgfSBlbHNlIHsgc2hlZXQuYWRkUnVsZShydWxlX25hbWUsIG51bGwsIDApOyB9XG5cdFx0XHRyZXR1cm4gJC52YWthdGEuY3NzLmdldF9jc3MocnVsZV9uYW1lKTtcblx0XHR9LFxuXHRcdHJlbW92ZV9jc3MgOiBmdW5jdGlvbihydWxlX25hbWUsIHNoZWV0KSB7IFxuXHRcdFx0cmV0dXJuICQudmFrYXRhLmNzcy5nZXRfY3NzKHJ1bGVfbmFtZSwgdHJ1ZSwgc2hlZXQpOyBcblx0XHR9LFxuXHRcdGFkZF9zaGVldCA6IGZ1bmN0aW9uKG9wdHMpIHtcblx0XHQgIC8vIE1PRElGSUVEIGlzY2hvbW1lci9TaWx2ZXJTdHJpcGU6IGFkZF9zaGVldCBzaWduaWZpY2FudGx5IHNsb3dzIGRvd24gcmVuZGVyaW5nLFxuXHRcdCAgLy8gd2UncmUgbG9hZGluZyBhbGwgcmVxdWlyZWQgQ1NTIGRpcmVjdGx5IHJhdGhlciB0aGFuIGFkZGluZyBpdCBpbmxpbmVcblx0XHQgIFxuICAgICAgLy8gdmFyIHRtcCA9IGZhbHNlLCBpc19uZXcgPSB0cnVlO1xuICAgICAgLy8gaWYob3B0cy5zdHIpIHtcbiAgICAgIC8vICBpZihvcHRzLnRpdGxlKSB7IHRtcCA9ICQoXCJzdHlsZVtpZD0nXCIgKyBvcHRzLnRpdGxlICsgXCItc3R5bGVzaGVldCddXCIpWzBdOyB9XG4gICAgICAvLyAgaWYodG1wKSB7IGlzX25ldyA9IGZhbHNlOyB9XG4gICAgICAvLyAgZWxzZSB7XG4gICAgICAvLyAgICB0bXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAvLyAgICB0bXAuc2V0QXR0cmlidXRlKCd0eXBlJyxcInRleHQvY3NzXCIpO1xuICAgICAgLy8gICAgaWYob3B0cy50aXRsZSkgeyB0bXAuc2V0QXR0cmlidXRlKFwiaWRcIiwgb3B0cy50aXRsZSArIFwiLXN0eWxlc2hlZXRcIik7IH1cbiAgICAgIC8vICB9XG4gICAgICAvLyAgaWYodG1wLnN0eWxlU2hlZXQpIHtcbiAgICAgIC8vICAgIGlmKGlzX25ldykgeyBcbiAgICAgIC8vICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKHRtcCk7IFxuICAgICAgLy8gICAgICB0bXAuc3R5bGVTaGVldC5jc3NUZXh0ID0gb3B0cy5zdHI7IFxuICAgICAgLy8gICAgfVxuICAgICAgLy8gICAgZWxzZSB7XG4gICAgICAvLyAgICAgIHRtcC5zdHlsZVNoZWV0LmNzc1RleHQgPSB0bXAuc3R5bGVTaGVldC5jc3NUZXh0ICsgXCIgXCIgKyBvcHRzLnN0cjsgXG4gICAgICAvLyAgICB9XG4gICAgICAvLyAgfVxuICAgICAgLy8gIGVsc2Uge1xuICAgICAgLy8gICAgdG1wLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG9wdHMuc3RyKSk7XG4gICAgICAvLyAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kQ2hpbGQodG1wKTtcbiAgICAgIC8vICB9XG4gICAgICAvLyAgcmV0dXJuIHRtcC5zaGVldCB8fCB0bXAuc3R5bGVTaGVldDtcbiAgICAgIC8vIH1cbiAgICAgIC8vIGlmKG9wdHMudXJsKSB7XG4gICAgICAvLyAgaWYoZG9jdW1lbnQuY3JlYXRlU3R5bGVTaGVldCkge1xuICAgICAgLy8gICAgdHJ5IHsgdG1wID0gZG9jdW1lbnQuY3JlYXRlU3R5bGVTaGVldChvcHRzLnVybCk7IH0gY2F0Y2ggKGUpIHsgfVxuICAgICAgLy8gIH1cbiAgICAgIC8vICBlbHNlIHtcbiAgICAgIC8vICAgIHRtcCAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAvLyAgICB0bXAucmVsICAgPSAnc3R5bGVzaGVldCc7XG4gICAgICAvLyAgICB0bXAudHlwZSAgPSAndGV4dC9jc3MnO1xuICAgICAgLy8gICAgdG1wLm1lZGlhID0gXCJhbGxcIjtcbiAgICAgIC8vICAgIHRtcC5ocmVmICA9IG9wdHMudXJsO1xuICAgICAgLy8gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKHRtcCk7XG4gICAgICAvLyAgICByZXR1cm4gdG1wLnN0eWxlU2hlZXQ7XG4gICAgICAvLyAgfVxuICAgICAgLy8gfVxuXHRcdH1cblx0fTtcblxuXHQvLyBwcml2YXRlIHZhcmlhYmxlcyBcblx0dmFyIGluc3RhbmNlcyA9IFtdLFx0XHRcdC8vIGluc3RhbmNlIGFycmF5ICh1c2VkIGJ5ICQuanN0cmVlLnJlZmVyZW5jZS9jcmVhdGUvZm9jdXNlZClcblx0XHRmb2N1c2VkX2luc3RhbmNlID0gLTEsXHQvLyB0aGUgaW5kZXggaW4gdGhlIGluc3RhbmNlIGFycmF5IG9mIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBpbnN0YW5jZVxuXHRcdHBsdWdpbnMgPSB7fSxcdFx0XHQvLyBsaXN0IG9mIGluY2x1ZGVkIHBsdWdpbnNcblx0XHRwcmVwYXJlZF9tb3ZlID0ge307XHRcdC8vIGZvciB0aGUgbW92ZV9ub2RlIGZ1bmN0aW9uXG5cblx0Ly8galF1ZXJ5IHBsdWdpbiB3cmFwcGVyICh0aGFua3MgdG8ganF1ZXJ5IFVJIHdpZGdldCBmdW5jdGlvbilcblx0JC5mbi5qc3RyZWUgPSBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcblx0XHR2YXIgaXNNZXRob2RDYWxsID0gKHR5cGVvZiBzZXR0aW5ncyA9PSAnc3RyaW5nJyksIC8vIGlzIHRoaXMgYSBtZXRob2QgY2FsbCBsaWtlICQoKS5qc3RyZWUoXCJvcGVuX25vZGVcIilcblx0XHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBcblx0XHRcdHJldHVyblZhbHVlID0gdGhpcztcblxuXHRcdC8vIGlmIGEgbWV0aG9kIGNhbGwgZXhlY3V0ZSB0aGUgbWV0aG9kIG9uIGFsbCBzZWxlY3RlZCBpbnN0YW5jZXNcblx0XHRpZihpc01ldGhvZENhbGwpIHtcblx0XHRcdGlmKHNldHRpbmdzLnN1YnN0cmluZygwLCAxKSA9PSAnXycpIHsgcmV0dXJuIHJldHVyblZhbHVlOyB9XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpbnN0YW5jZSA9IGluc3RhbmNlc1skLmRhdGEodGhpcywgXCJqc3RyZWVfaW5zdGFuY2VfaWRcIildLFxuXHRcdFx0XHRcdG1ldGhvZFZhbHVlID0gKGluc3RhbmNlICYmICQuaXNGdW5jdGlvbihpbnN0YW5jZVtzZXR0aW5nc10pKSA/IGluc3RhbmNlW3NldHRpbmdzXS5hcHBseShpbnN0YW5jZSwgYXJncykgOiBpbnN0YW5jZTtcblx0XHRcdFx0XHRpZih0eXBlb2YgbWV0aG9kVmFsdWUgIT09IFwidW5kZWZpbmVkXCIgJiYgKHNldHRpbmdzLmluZGV4T2YoXCJpc19cIikgPT09IDAgfHwgKG1ldGhvZFZhbHVlICE9PSB0cnVlICYmIG1ldGhvZFZhbHVlICE9PSBmYWxzZSkpKSB7IHJldHVyblZhbHVlID0gbWV0aG9kVmFsdWU7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBleHRlbmQgc2V0dGluZ3MgYW5kIGFsbG93IGZvciBtdWx0aXBsZSBoYXNoZXMgYW5kICQuZGF0YVxuXHRcdFx0XHR2YXIgaW5zdGFuY2VfaWQgPSAkLmRhdGEodGhpcywgXCJqc3RyZWVfaW5zdGFuY2VfaWRcIiksXG5cdFx0XHRcdFx0YSA9IFtdLFxuXHRcdFx0XHRcdGIgPSBzZXR0aW5ncyA/ICQuZXh0ZW5kKHt9LCB0cnVlLCBzZXR0aW5ncykgOiB7fSxcblx0XHRcdFx0XHRjID0gJCh0aGlzKSwgXG5cdFx0XHRcdFx0cyA9IGZhbHNlLCBcblx0XHRcdFx0XHR0ID0gW107XG5cdFx0XHRcdGEgPSBhLmNvbmNhdChhcmdzKTtcblx0XHRcdFx0aWYoYy5kYXRhKFwianN0cmVlXCIpKSB7IGEucHVzaChjLmRhdGEoXCJqc3RyZWVcIikpOyB9XG5cdFx0XHRcdGIgPSBhLmxlbmd0aCA/ICQuZXh0ZW5kLmFwcGx5KG51bGwsIFt0cnVlLCBiXS5jb25jYXQoYSkpIDogYjtcblxuXHRcdFx0XHQvLyBpZiBhbiBpbnN0YW5jZSBhbHJlYWR5IGV4aXN0cywgZGVzdHJveSBpdCBmaXJzdFxuXHRcdFx0XHRpZih0eXBlb2YgaW5zdGFuY2VfaWQgIT09IFwidW5kZWZpbmVkXCIgJiYgaW5zdGFuY2VzW2luc3RhbmNlX2lkXSkgeyBpbnN0YW5jZXNbaW5zdGFuY2VfaWRdLmRlc3Ryb3koKTsgfVxuXHRcdFx0XHQvLyBwdXNoIGEgbmV3IGVtcHR5IG9iamVjdCB0byB0aGUgaW5zdGFuY2VzIGFycmF5XG5cdFx0XHRcdGluc3RhbmNlX2lkID0gcGFyc2VJbnQoaW5zdGFuY2VzLnB1c2goe30pLDEwKSAtIDE7XG5cdFx0XHRcdC8vIHN0b3JlIHRoZSBqc3RyZWUgaW5zdGFuY2UgaWQgdG8gdGhlIGNvbnRhaW5lciBlbGVtZW50XG5cdFx0XHRcdCQuZGF0YSh0aGlzLCBcImpzdHJlZV9pbnN0YW5jZV9pZFwiLCBpbnN0YW5jZV9pZCk7XG5cdFx0XHRcdC8vIGNsZWFuIHVwIGFsbCBwbHVnaW5zXG5cdFx0XHRcdGIucGx1Z2lucyA9ICQuaXNBcnJheShiLnBsdWdpbnMpID8gYi5wbHVnaW5zIDogJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5zbGljZSgpO1xuXHRcdFx0XHRiLnBsdWdpbnMudW5zaGlmdChcImNvcmVcIik7XG5cdFx0XHRcdC8vIG9ubHkgdW5pcXVlIHBsdWdpbnNcblx0XHRcdFx0Yi5wbHVnaW5zID0gYi5wbHVnaW5zLnNvcnQoKS5qb2luKFwiLCxcIikucmVwbGFjZSgvKCx8XikoW14sXSspKCwsXFwyKSsoLHwkKS9nLFwiJDEkMiQ0XCIpLnJlcGxhY2UoLywsKy9nLFwiLFwiKS5yZXBsYWNlKC8sJC8sXCJcIikuc3BsaXQoXCIsXCIpO1xuXG5cdFx0XHRcdC8vIGV4dGVuZCBkZWZhdWx0cyB3aXRoIHBhc3NlZCBkYXRhXG5cdFx0XHRcdHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgJC5qc3RyZWUuZGVmYXVsdHMsIGIpO1xuXHRcdFx0XHRzLnBsdWdpbnMgPSBiLnBsdWdpbnM7XG5cdFx0XHRcdCQuZWFjaChwbHVnaW5zLCBmdW5jdGlvbiAoaSwgdmFsKSB7IFxuXHRcdFx0XHRcdGlmKCQuaW5BcnJheShpLCBzLnBsdWdpbnMpID09PSAtMSkgeyBzW2ldID0gbnVsbDsgZGVsZXRlIHNbaV07IH0gXG5cdFx0XHRcdFx0ZWxzZSB7IHQucHVzaChpKTsgfVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cy5wbHVnaW5zID0gdDtcblxuXHRcdFx0XHQvLyBwdXNoIHRoZSBuZXcgb2JqZWN0IHRvIHRoZSBpbnN0YW5jZXMgYXJyYXkgKGF0IHRoZSBzYW1lIHRpbWUgc2V0IHRoZSBkZWZhdWx0IGNsYXNzZXMgdG8gdGhlIGNvbnRhaW5lcikgYW5kIGluaXRcblx0XHRcdFx0aW5zdGFuY2VzW2luc3RhbmNlX2lkXSA9IG5ldyAkLmpzdHJlZS5faW5zdGFuY2UoaW5zdGFuY2VfaWQsICQodGhpcykuYWRkQ2xhc3MoXCJqc3RyZWUganN0cmVlLVwiICsgaW5zdGFuY2VfaWQpLCBzKTsgXG5cdFx0XHRcdC8vIGluaXQgYWxsIGFjdGl2YXRlZCBwbHVnaW5zIGZvciB0aGlzIGluc3RhbmNlXG5cdFx0XHRcdCQuZWFjaChpbnN0YW5jZXNbaW5zdGFuY2VfaWRdLl9nZXRfc2V0dGluZ3MoKS5wbHVnaW5zLCBmdW5jdGlvbiAoaSwgdmFsKSB7IGluc3RhbmNlc1tpbnN0YW5jZV9pZF0uZGF0YVt2YWxdID0ge307IH0pO1xuXHRcdFx0XHQkLmVhY2goaW5zdGFuY2VzW2luc3RhbmNlX2lkXS5fZ2V0X3NldHRpbmdzKCkucGx1Z2lucywgZnVuY3Rpb24gKGksIHZhbCkgeyBpZihwbHVnaW5zW3ZhbF0pIHsgcGx1Z2luc1t2YWxdLl9faW5pdC5hcHBseShpbnN0YW5jZXNbaW5zdGFuY2VfaWRdKTsgfSB9KTtcblx0XHRcdFx0Ly8gaW5pdGlhbGl6ZSB0aGUgaW5zdGFuY2Vcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHsgaWYoaW5zdGFuY2VzW2luc3RhbmNlX2lkXSkgeyBpbnN0YW5jZXNbaW5zdGFuY2VfaWRdLmluaXQoKTsgfSB9LCAwKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHQvLyByZXR1cm4gdGhlIGpxdWVyeSBzZWxlY3Rpb24gKG9yIGlmIGl0IHdhcyBhIG1ldGhvZCBjYWxsIHRoYXQgcmV0dXJuZWQgYSB2YWx1ZSAtIHRoZSByZXR1cm5lZCB2YWx1ZSlcblx0XHRyZXR1cm4gcmV0dXJuVmFsdWU7XG5cdH07XG5cdC8vIG9iamVjdCB0byBzdG9yZSBleHBvc2VkIGZ1bmN0aW9ucyBhbmQgb2JqZWN0c1xuXHQkLmpzdHJlZSA9IHtcblx0XHRkZWZhdWx0cyA6IHtcblx0XHRcdHBsdWdpbnMgOiBbXVxuXHRcdH0sXG5cdFx0X2ZvY3VzZWQgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnN0YW5jZXNbZm9jdXNlZF9pbnN0YW5jZV0gfHwgbnVsbDsgfSxcblx0XHRfcmVmZXJlbmNlIDogZnVuY3Rpb24gKG5lZWRsZSkgeyBcblx0XHRcdC8vIGdldCBieSBpbnN0YW5jZSBpZFxuXHRcdFx0aWYoaW5zdGFuY2VzW25lZWRsZV0pIHsgcmV0dXJuIGluc3RhbmNlc1tuZWVkbGVdOyB9XG5cdFx0XHQvLyBnZXQgYnkgRE9NIChpZiBzdGlsbCBubyBsdWNrIC0gcmV0dXJuIG51bGxcblx0XHRcdHZhciBvID0gJChuZWVkbGUpOyBcblx0XHRcdGlmKCFvLmxlbmd0aCAmJiB0eXBlb2YgbmVlZGxlID09PSBcInN0cmluZ1wiKSB7IG8gPSAkKFwiI1wiICsgbmVlZGxlKTsgfVxuXHRcdFx0aWYoIW8ubGVuZ3RoKSB7IHJldHVybiBudWxsOyB9XG5cdFx0XHRyZXR1cm4gaW5zdGFuY2VzW28uY2xvc2VzdChcIi5qc3RyZWVcIikuZGF0YShcImpzdHJlZV9pbnN0YW5jZV9pZFwiKV0gfHwgbnVsbDsgXG5cdFx0fSxcblx0XHRfaW5zdGFuY2UgOiBmdW5jdGlvbiAoaW5kZXgsIGNvbnRhaW5lciwgc2V0dGluZ3MpIHsgXG5cdFx0XHQvLyBmb3IgcGx1Z2lucyB0byBzdG9yZSBkYXRhIGluXG5cdFx0XHR0aGlzLmRhdGEgPSB7IGNvcmUgOiB7fSB9O1xuXHRcdFx0dGhpcy5nZXRfc2V0dGluZ3NcdD0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJC5leHRlbmQodHJ1ZSwge30sIHNldHRpbmdzKTsgfTtcblx0XHRcdHRoaXMuX2dldF9zZXR0aW5nc1x0PSBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXR0aW5nczsgfTtcblx0XHRcdHRoaXMuZ2V0X2luZGV4XHRcdD0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXg7IH07XG5cdFx0XHR0aGlzLmdldF9jb250YWluZXJcdD0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udGFpbmVyOyB9O1xuXHRcdFx0dGhpcy5nZXRfY29udGFpbmVyX3VsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udGFpbmVyLmNoaWxkcmVuKFwidWw6ZXEoMClcIik7IH07XG5cdFx0XHR0aGlzLl9zZXRfc2V0dGluZ3NcdD0gZnVuY3Rpb24gKHMpIHsgXG5cdFx0XHRcdHNldHRpbmdzID0gJC5leHRlbmQodHJ1ZSwge30sIHNldHRpbmdzLCBzKTtcblx0XHRcdH07XG5cdFx0fSxcblx0XHRfZm4gOiB7IH0sXG5cdFx0cGx1Z2luIDogZnVuY3Rpb24gKHBuYW1lLCBwZGF0YSkge1xuXHRcdFx0cGRhdGEgPSAkLmV4dGVuZCh7fSwge1xuXHRcdFx0XHRfX2luaXRcdFx0OiAkLm5vb3AsIFxuXHRcdFx0XHRfX2Rlc3Ryb3lcdDogJC5ub29wLFxuXHRcdFx0XHRfZm5cdFx0XHQ6IHt9LFxuXHRcdFx0XHRkZWZhdWx0c1x0OiBmYWxzZVxuXHRcdFx0fSwgcGRhdGEpO1xuXHRcdFx0cGx1Z2luc1twbmFtZV0gPSBwZGF0YTtcblxuXHRcdFx0JC5qc3RyZWUuZGVmYXVsdHNbcG5hbWVdID0gcGRhdGEuZGVmYXVsdHM7XG5cdFx0XHQkLmVhY2gocGRhdGEuX2ZuLCBmdW5jdGlvbiAoaSwgdmFsKSB7XG5cdFx0XHRcdHZhbC5wbHVnaW5cdFx0PSBwbmFtZTtcblx0XHRcdFx0dmFsLm9sZFx0XHRcdD0gJC5qc3RyZWUuX2ZuW2ldO1xuXHRcdFx0XHQkLmpzdHJlZS5fZm5baV0gPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIHJzbHQsXG5cdFx0XHRcdFx0XHRmdW5jID0gdmFsLFxuXHRcdFx0XHRcdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG5cdFx0XHRcdFx0XHRldm50ID0gbmV3ICQuRXZlbnQoXCJiZWZvcmUuanN0cmVlXCIpLFxuXHRcdFx0XHRcdFx0cmxiayA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYodGhpcy5kYXRhLmNvcmUubG9ja2VkID09PSB0cnVlICYmIGkgIT09IFwidW5sb2NrXCIgJiYgaSAhPT0gXCJpc19sb2NrZWRcIikgeyByZXR1cm47IH1cblxuXHRcdFx0XHRcdC8vIENoZWNrIGlmIGZ1bmN0aW9uIGJlbG9uZ3MgdG8gdGhlIGluY2x1ZGVkIHBsdWdpbnMgb2YgdGhpcyBpbnN0YW5jZVxuXHRcdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRcdGlmKGZ1bmMgJiYgZnVuYy5wbHVnaW4gJiYgJC5pbkFycmF5KGZ1bmMucGx1Z2luLCB0aGlzLl9nZXRfc2V0dGluZ3MoKS5wbHVnaW5zKSAhPT0gLTEpIHsgYnJlYWs7IH1cblx0XHRcdFx0XHRcdGZ1bmMgPSBmdW5jLm9sZDtcblx0XHRcdFx0XHR9IHdoaWxlKGZ1bmMpO1xuXHRcdFx0XHRcdGlmKCFmdW5jKSB7IHJldHVybjsgfVxuXG5cdFx0XHRcdFx0Ly8gY29udGV4dCBhbmQgZnVuY3Rpb24gdG8gdHJpZ2dlciBldmVudHMsIHRoZW4gZmluYWxseSBjYWxsIHRoZSBmdW5jdGlvblxuXHRcdFx0XHRcdGlmKGkuaW5kZXhPZihcIl9cIikgPT09IDApIHtcblx0XHRcdFx0XHRcdHJzbHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHJzbHQgPSB0aGlzLmdldF9jb250YWluZXIoKS50cmlnZ2VySGFuZGxlcihldm50LCB7IFwiZnVuY1wiIDogaSwgXCJpbnN0XCIgOiB0aGlzLCBcImFyZ3NcIiA6IGFyZ3MsIFwicGx1Z2luXCIgOiBmdW5jLnBsdWdpbiB9KTtcblx0XHRcdFx0XHRcdGlmKHJzbHQgPT09IGZhbHNlKSB7IHJldHVybjsgfVxuXHRcdFx0XHRcdFx0aWYodHlwZW9mIHJzbHQgIT09IFwidW5kZWZpbmVkXCIpIHsgYXJncyA9IHJzbHQ7IH1cblxuXHRcdFx0XHRcdFx0cnNsdCA9IGZ1bmMuYXBwbHkoXG5cdFx0XHRcdFx0XHRcdCQuZXh0ZW5kKHt9LCB0aGlzLCB7IFxuXHRcdFx0XHRcdFx0XHRcdF9fY2FsbGJhY2sgOiBmdW5jdGlvbiAoZGF0YSkgeyBcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpLnRyaWdnZXJIYW5kbGVyKCBpICsgJy5qc3RyZWUnLCB7IFwiaW5zdFwiIDogdGhpcywgXCJhcmdzXCIgOiBhcmdzLCBcInJzbHRcIiA6IGRhdGEsIFwicmxia1wiIDogcmxiayB9KTtcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdF9fcm9sbGJhY2sgOiBmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHRcdFx0XHRcdFx0cmxiayA9IHRoaXMuZ2V0X3JvbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmxiaztcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdF9fY2FsbF9vbGQgOiBmdW5jdGlvbiAocmVwbGFjZV9hcmd1bWVudHMpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmdW5jLm9sZC5hcHBseSh0aGlzLCAocmVwbGFjZV9hcmd1bWVudHMgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpIDogYXJncyApICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KSwgYXJncyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gcmV0dXJuIHRoZSByZXN1bHRcblx0XHRcdFx0XHRyZXR1cm4gcnNsdDtcblx0XHRcdFx0fTtcblx0XHRcdFx0JC5qc3RyZWUuX2ZuW2ldLm9sZCA9IHZhbC5vbGQ7XG5cdFx0XHRcdCQuanN0cmVlLl9mbltpXS5wbHVnaW4gPSBwbmFtZTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0cm9sbGJhY2sgOiBmdW5jdGlvbiAocmIpIHtcblx0XHRcdGlmKHJiKSB7XG5cdFx0XHRcdGlmKCEkLmlzQXJyYXkocmIpKSB7IHJiID0gWyByYiBdOyB9XG5cdFx0XHRcdCQuZWFjaChyYiwgZnVuY3Rpb24gKGksIHZhbCkge1xuXHRcdFx0XHRcdGluc3RhbmNlc1t2YWwuaV0uc2V0X3JvbGxiYWNrKHZhbC5oLCB2YWwuZCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0Ly8gc2V0IHRoZSBwcm90b3R5cGUgZm9yIGFsbCBpbnN0YW5jZXNcblx0JC5qc3RyZWUuX2ZuID0gJC5qc3RyZWUuX2luc3RhbmNlLnByb3RvdHlwZSA9IHt9O1xuXG5cdC8vIGxvYWQgdGhlIGNzcyB3aGVuIERPTSBpcyByZWFkeVxuXHQkKGZ1bmN0aW9uKCkge1xuXHRcdC8vIGNvZGUgaXMgY29waWVkIGZyb20galF1ZXJ5ICgkLmJyb3dzZXIgaXMgZGVwcmVjYXRlZCArIHRoZXJlIGlzIGEgYnVnIGluIElFKVxuXHRcdHZhciB1ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0diA9ICh1Lm1hdGNoKCAvLis/KD86cnZ8aXR8cmF8aWUpW1xcLzogXShbXFxkLl0rKS8gKSB8fCBbMCwnMCddKVsxXSxcblx0XHRcdGNzc19zdHJpbmcgPSAnJyArIFxuXHRcdFx0XHQnLmpzdHJlZSB1bCwgLmpzdHJlZSBsaSB7IGRpc3BsYXk6YmxvY2s7IG1hcmdpbjowIDAgMCAwOyBwYWRkaW5nOjAgMCAwIDA7IGxpc3Qtc3R5bGUtdHlwZTpub25lOyB9ICcgKyBcblx0XHRcdFx0Jy5qc3RyZWUgbGkgeyBkaXNwbGF5OmJsb2NrOyBtaW4taGVpZ2h0OjE4cHg7IGxpbmUtaGVpZ2h0OjE4cHg7IHdoaXRlLXNwYWNlOm5vd3JhcDsgbWFyZ2luLWxlZnQ6MThweDsgbWluLXdpZHRoOjE4cHg7IH0gJyArIFxuXHRcdFx0XHQnLmpzdHJlZS1ydGwgbGkgeyBtYXJnaW4tbGVmdDowOyBtYXJnaW4tcmlnaHQ6MThweDsgfSAnICsgXG5cdFx0XHRcdCcuanN0cmVlID4gdWwgPiBsaSB7IG1hcmdpbi1sZWZ0OjBweDsgfSAnICsgXG5cdFx0XHRcdCcuanN0cmVlLXJ0bCA+IHVsID4gbGkgeyBtYXJnaW4tcmlnaHQ6MHB4OyB9ICcgKyBcblx0XHRcdFx0Jy5qc3RyZWUgaW5zIHsgZGlzcGxheTppbmxpbmUtYmxvY2s7IHRleHQtZGVjb3JhdGlvbjpub25lOyB3aWR0aDoxOHB4OyBoZWlnaHQ6MThweDsgbWFyZ2luOjAgMCAwIDA7IHBhZGRpbmc6MDsgfSAnICsgXG5cdFx0XHRcdCcuanN0cmVlIGEgeyBkaXNwbGF5OmlubGluZS1ibG9jazsgbGluZS1oZWlnaHQ6MTZweDsgaGVpZ2h0OjE2cHg7IGNvbG9yOmJsYWNrOyB3aGl0ZS1zcGFjZTpub3dyYXA7IHRleHQtZGVjb3JhdGlvbjpub25lOyBwYWRkaW5nOjFweCAycHg7IG1hcmdpbjowOyB9ICcgKyBcblx0XHRcdFx0Jy5qc3RyZWUgYTpmb2N1cyB7IG91dGxpbmU6IG5vbmU7IH0gJyArIFxuXHRcdFx0XHQnLmpzdHJlZSBhID4gaW5zIHsgaGVpZ2h0OjE2cHg7IHdpZHRoOjE2cHg7IH0gJyArIFxuXHRcdFx0XHQnLmpzdHJlZSBhID4gLmpzdHJlZS1pY29uIHsgbWFyZ2luLXJpZ2h0OjNweDsgfSAnICsgXG5cdFx0XHRcdCcuanN0cmVlLXJ0bCBhID4gLmpzdHJlZS1pY29uIHsgbWFyZ2luLWxlZnQ6M3B4OyBtYXJnaW4tcmlnaHQ6MDsgfSAnICsgXG5cdFx0XHRcdCdsaS5qc3RyZWUtb3BlbiA+IHVsIHsgZGlzcGxheTpibG9jazsgfSAnICsgXG5cdFx0XHRcdCdsaS5qc3RyZWUtY2xvc2VkID4gdWwgeyBkaXNwbGF5Om5vbmU7IH0gJztcblx0XHQvLyBDb3JyZWN0IElFIDYgKGRvZXMgbm90IHN1cHBvcnQgdGhlID4gQ1NTIHNlbGVjdG9yKVxuXHRcdGlmKC9tc2llLy50ZXN0KHUpICYmIHBhcnNlSW50KHYsIDEwKSA9PSA2KSB7IFxuXHRcdFx0aXNfaWU2ID0gdHJ1ZTtcblxuXHRcdFx0Ly8gZml4IGltYWdlIGZsaWNrZXIgYW5kIGxhY2sgb2YgY2FjaGluZ1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJCYWNrZ3JvdW5kSW1hZ2VDYWNoZVwiLCBmYWxzZSwgdHJ1ZSk7XG5cdFx0XHR9IGNhdGNoIChlcnIpIHsgfVxuXG5cdFx0XHRjc3Nfc3RyaW5nICs9ICcnICsgXG5cdFx0XHRcdCcuanN0cmVlIGxpIHsgaGVpZ2h0OjE4cHg7IG1hcmdpbi1sZWZ0OjA7IG1hcmdpbi1yaWdodDowOyB9ICcgKyBcblx0XHRcdFx0Jy5qc3RyZWUgbGkgbGkgeyBtYXJnaW4tbGVmdDoxOHB4OyB9ICcgKyBcblx0XHRcdFx0Jy5qc3RyZWUtcnRsIGxpIGxpIHsgbWFyZ2luLWxlZnQ6MHB4OyBtYXJnaW4tcmlnaHQ6MThweDsgfSAnICsgXG5cdFx0XHRcdCdsaS5qc3RyZWUtb3BlbiB1bCB7IGRpc3BsYXk6YmxvY2s7IH0gJyArIFxuXHRcdFx0XHQnbGkuanN0cmVlLWNsb3NlZCB1bCB7IGRpc3BsYXk6bm9uZSAhaW1wb3J0YW50OyB9ICcgKyBcblx0XHRcdFx0Jy5qc3RyZWUgbGkgYSB7IGRpc3BsYXk6aW5saW5lOyBib3JkZXItd2lkdGg6MCAhaW1wb3J0YW50OyBwYWRkaW5nOjBweCAycHggIWltcG9ydGFudDsgfSAnICsgXG5cdFx0XHRcdCcuanN0cmVlIGxpIGEgaW5zIHsgaGVpZ2h0OjE2cHg7IHdpZHRoOjE2cHg7IG1hcmdpbi1yaWdodDozcHg7IH0gJyArIFxuXHRcdFx0XHQnLmpzdHJlZS1ydGwgbGkgYSBpbnMgeyBtYXJnaW4tcmlnaHQ6MHB4OyBtYXJnaW4tbGVmdDozcHg7IH0gJztcblx0XHR9XG5cdFx0Ly8gQ29ycmVjdCBJRSA3IChzaGlmdHMgYW5jaG9yIG5vZGVzIG9uaG92ZXIpXG5cdFx0aWYoL21zaWUvLnRlc3QodSkgJiYgcGFyc2VJbnQodiwgMTApID09IDcpIHsgXG5cdFx0XHRpc19pZTcgPSB0cnVlO1xuXHRcdFx0Y3NzX3N0cmluZyArPSAnLmpzdHJlZSBsaSBhIHsgYm9yZGVyLXdpZHRoOjAgIWltcG9ydGFudDsgcGFkZGluZzowcHggMnB4ICFpbXBvcnRhbnQ7IH0gJztcblx0XHR9XG5cdFx0Ly8gY29ycmVjdCBmZjIgbGFjayBvZiBkaXNwbGF5OmlubGluZS1ibG9ja1xuXHRcdGlmKCEvY29tcGF0aWJsZS8udGVzdCh1KSAmJiAvbW96aWxsYS8udGVzdCh1KSAmJiBwYXJzZUZsb2F0KHYsIDEwKSA8IDEuOSkge1xuXHRcdFx0aXNfZmYyID0gdHJ1ZTtcblx0XHRcdGNzc19zdHJpbmcgKz0gJycgKyBcblx0XHRcdFx0Jy5qc3RyZWUgaW5zIHsgZGlzcGxheTotbW96LWlubGluZS1ib3g7IH0gJyArIFxuXHRcdFx0XHQnLmpzdHJlZSBsaSB7IGxpbmUtaGVpZ2h0OjEycHg7IH0gJyArIC8vIFdIWT8/XG5cdFx0XHRcdCcuanN0cmVlIGEgeyBkaXNwbGF5Oi1tb3otaW5saW5lLWJveDsgfSAnICsgXG5cdFx0XHRcdCcuanN0cmVlIC5qc3RyZWUtbm8taWNvbnMgLmpzdHJlZS1jaGVja2JveCB7IGRpc3BsYXk6LW1vei1pbmxpbmUtc3RhY2sgIWltcG9ydGFudDsgfSAnO1xuXHRcdFx0XHQvKiB0aGlzIHNob3VsZG4ndCBiZSBoZXJlIGFzIGl0IGlzIHRoZW1lIHNwZWNpZmljICovXG5cdFx0fVxuXHRcdC8vIHRoZSBkZWZhdWx0IHN0eWxlc2hlZXRcblx0XHQkLnZha2F0YS5jc3MuYWRkX3NoZWV0KHsgc3RyIDogY3NzX3N0cmluZywgdGl0bGUgOiBcImpzdHJlZVwiIH0pO1xuXHR9KTtcblxuXHQvLyBjb3JlIGZ1bmN0aW9ucyAob3BlbiwgY2xvc2UsIGNyZWF0ZSwgdXBkYXRlLCBkZWxldGUpXG5cdCQuanN0cmVlLnBsdWdpbihcImNvcmVcIiwge1xuXHRcdF9faW5pdCA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuZGF0YS5jb3JlLmxvY2tlZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5kYXRhLmNvcmUudG9fb3BlbiA9IHRoaXMuZ2V0X3NldHRpbmdzKCkuY29yZS5pbml0aWFsbHlfb3Blbjtcblx0XHRcdHRoaXMuZGF0YS5jb3JlLnRvX2xvYWQgPSB0aGlzLmdldF9zZXR0aW5ncygpLmNvcmUuaW5pdGlhbGx5X2xvYWQ7XG5cdFx0fSxcblx0XHRkZWZhdWx0cyA6IHsgXG5cdFx0XHRodG1sX3RpdGxlc1x0OiBmYWxzZSxcblx0XHRcdGFuaW1hdGlvblx0OiA1MDAsXG5cdFx0XHRpbml0aWFsbHlfb3BlbiA6IFtdLFxuXHRcdFx0aW5pdGlhbGx5X2xvYWQgOiBbXSxcblx0XHRcdG9wZW5fcGFyZW50cyA6IHRydWUsXG5cdFx0XHRub3RpZnlfcGx1Z2lucyA6IHRydWUsXG5cdFx0XHRydGxcdFx0XHQ6IGZhbHNlLFxuXHRcdFx0bG9hZF9vcGVuXHQ6IGZhbHNlLFxuXHRcdFx0c3RyaW5nc1x0XHQ6IHtcblx0XHRcdFx0bG9hZGluZ1x0XHQ6IFwiTG9hZGluZyAuLi5cIixcblx0XHRcdFx0bmV3X25vZGVcdDogXCJOZXcgbm9kZVwiLFxuXHRcdFx0XHRtdWx0aXBsZV9zZWxlY3Rpb24gOiBcIk11bHRpcGxlIHNlbGVjdGlvblwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRfZm4gOiB7IFxuXHRcdFx0aW5pdFx0OiBmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHR0aGlzLnNldF9mb2N1cygpOyBcblx0XHRcdFx0aWYodGhpcy5fZ2V0X3NldHRpbmdzKCkuY29yZS5ydGwpIHtcblx0XHRcdFx0XHR0aGlzLmdldF9jb250YWluZXIoKS5hZGRDbGFzcyhcImpzdHJlZS1ydGxcIikuY3NzKFwiZGlyZWN0aW9uXCIsIFwicnRsXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpLmh0bWwoXCI8dWw+PGxpIGNsYXNzPSdqc3RyZWUtbGFzdCBqc3RyZWUtbGVhZic+PGlucz4mIzE2MDs8L2lucz48YSBjbGFzcz0nanN0cmVlLWxvYWRpbmcnIGhyZWY9JyMnPjxpbnMgY2xhc3M9J2pzdHJlZS1pY29uJz4mIzE2MDs8L2lucz5cIiArIHRoaXMuX2dldF9zdHJpbmcoXCJsb2FkaW5nXCIpICsgXCI8L2E+PC9saT48L3VsPlwiKTtcblx0XHRcdFx0dGhpcy5kYXRhLmNvcmUubGlfaGVpZ2h0ID0gdGhpcy5nZXRfY29udGFpbmVyX3VsKCkuZmluZChcImxpLmpzdHJlZS1jbG9zZWQsIGxpLmpzdHJlZS1sZWFmXCIpLmVxKDApLmhlaWdodCgpIHx8IDE4O1xuXG5cdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpXG5cdFx0XHRcdFx0LmRlbGVnYXRlKFwibGkgPiBpbnNcIiwgXCJjbGljay5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRyZ3QgPSAkKGV2ZW50LnRhcmdldCk7XG5cdFx0XHRcdFx0XHRcdC8vIGlmKHRyZ3QuaXMoXCJpbnNcIikgJiYgZXZlbnQucGFnZVkgLSB0cmd0Lm9mZnNldCgpLnRvcCA8IHRoaXMuZGF0YS5jb3JlLmxpX2hlaWdodCkgeyB0aGlzLnRvZ2dsZV9ub2RlKHRyZ3QpOyB9XG5cdFx0XHRcdFx0XHRcdHRoaXMudG9nZ2xlX25vZGUodHJndCk7XG5cdFx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0XHQuYmluZChcIm1vdXNlZG93bi5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHRcdFx0XHR0aGlzLnNldF9mb2N1cygpOyAvLyBUaGlzIHVzZWQgdG8gYmUgc2V0VGltZW91dChzZXRfZm9jdXMsMCkgLSB3aHk/XG5cdFx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0XHQuYmluZChcImRibGNsaWNrLmpzdHJlZVwiLCBmdW5jdGlvbiAoZXZlbnQpIHsgXG5cdFx0XHRcdFx0XHR2YXIgc2VsO1xuXHRcdFx0XHRcdFx0aWYoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGRvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSkgeyBkb2N1bWVudC5zZWxlY3Rpb24uZW1wdHkoKTsgfVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcblx0XHRcdFx0XHRcdFx0XHRzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRcdFx0XHRcdFx0dHJ5IHsgXG5cdFx0XHRcdFx0XHRcdFx0XHRzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRzZWwuY29sbGFwc2UoKTtcblx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIpIHsgfVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmKHRoaXMuX2dldF9zZXR0aW5ncygpLmNvcmUubm90aWZ5X3BsdWdpbnMpIHtcblx0XHRcdFx0XHR0aGlzLmdldF9jb250YWluZXIoKVxuXHRcdFx0XHRcdFx0LmJpbmQoXCJsb2FkX25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHsgXG5cdFx0XHRcdFx0XHRcdFx0dmFyIG8gPSB0aGlzLl9nZXRfbm9kZShkYXRhLnJzbHQub2JqKSxcblx0XHRcdFx0XHRcdFx0XHRcdHQgPSB0aGlzO1xuXHRcdFx0XHRcdFx0XHRcdGlmKG8gPT09IC0xKSB7IG8gPSB0aGlzLmdldF9jb250YWluZXJfdWwoKTsgfVxuXHRcdFx0XHRcdFx0XHRcdGlmKCFvLmxlbmd0aCkgeyByZXR1cm47IH1cblx0XHRcdFx0XHRcdFx0XHRvLmZpbmQoXCJsaVwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciB0aCA9ICQodGhpcyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZih0aC5kYXRhKFwianN0cmVlXCIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCQuZWFjaCh0aC5kYXRhKFwianN0cmVlXCIpLCBmdW5jdGlvbiAocGx1Z2luLCB2YWx1ZXMpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZih0LmRhdGFbcGx1Z2luXSAmJiAkLmlzRnVuY3Rpb24odFtcIl9cIiArIHBsdWdpbiArIFwiX25vdGlmeVwiXSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRbXCJfXCIgKyBwbHVnaW4gKyBcIl9ub3RpZnlcIl0uY2FsbCh0LCB0aCwgdmFsdWVzKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodGhpcy5fZ2V0X3NldHRpbmdzKCkuY29yZS5sb2FkX29wZW4pIHtcblx0XHRcdFx0XHR0aGlzLmdldF9jb250YWluZXIoKVxuXHRcdFx0XHRcdFx0LmJpbmQoXCJsb2FkX25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHsgXG5cdFx0XHRcdFx0XHRcdFx0dmFyIG8gPSB0aGlzLl9nZXRfbm9kZShkYXRhLnJzbHQub2JqKSxcblx0XHRcdFx0XHRcdFx0XHRcdHQgPSB0aGlzO1xuXHRcdFx0XHRcdFx0XHRcdGlmKG8gPT09IC0xKSB7IG8gPSB0aGlzLmdldF9jb250YWluZXJfdWwoKTsgfVxuXHRcdFx0XHRcdFx0XHRcdGlmKCFvLmxlbmd0aCkgeyByZXR1cm47IH1cblx0XHRcdFx0XHRcdFx0XHRvLmZpbmQoXCJsaS5qc3RyZWUtb3Blbjpub3QoOmhhcyh1bCkpXCIpLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dC5sb2FkX25vZGUodGhpcywgJC5ub29wLCAkLm5vb3ApO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKCk7XG5cdFx0XHRcdHRoaXMubG9hZF9ub2RlKC0xLCBmdW5jdGlvbiAoKSB7IHRoaXMubG9hZGVkKCk7IHRoaXMucmVsb2FkX25vZGVzKCk7IH0pO1xuXHRcdFx0fSxcblx0XHRcdGRlc3Ryb3lcdDogZnVuY3Rpb24gKCkgeyBcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0biA9IHRoaXMuZ2V0X2luZGV4KCksXG5cdFx0XHRcdFx0cyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLFxuXHRcdFx0XHRcdF90aGlzID0gdGhpcztcblxuXHRcdFx0XHQkLmVhY2gocy5wbHVnaW5zLCBmdW5jdGlvbiAoaSwgdmFsKSB7XG5cdFx0XHRcdFx0dHJ5IHsgcGx1Z2luc1t2YWxdLl9fZGVzdHJveS5hcHBseShfdGhpcyk7IH0gY2F0Y2goZXJyKSB7IH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjaygpO1xuXHRcdFx0XHQvLyBzZXQgZm9jdXMgdG8gYW5vdGhlciBpbnN0YW5jZSBpZiB0aGlzIG9uZSBpcyBmb2N1c2VkXG5cdFx0XHRcdGlmKHRoaXMuaXNfZm9jdXNlZCgpKSB7IFxuXHRcdFx0XHRcdGZvcihpIGluIGluc3RhbmNlcykgeyBcblx0XHRcdFx0XHRcdGlmKGluc3RhbmNlcy5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpICE9IG4pIHsgXG5cdFx0XHRcdFx0XHRcdGluc3RhbmNlc1tpXS5zZXRfZm9jdXMoKTsgXG5cdFx0XHRcdFx0XHRcdGJyZWFrOyBcblx0XHRcdFx0XHRcdH0gXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlmIG5vIG90aGVyIGluc3RhbmNlIGZvdW5kXG5cdFx0XHRcdGlmKG4gPT09IGZvY3VzZWRfaW5zdGFuY2UpIHsgZm9jdXNlZF9pbnN0YW5jZSA9IC0xOyB9XG5cdFx0XHRcdC8vIHJlbW92ZSBhbGwgdHJhY2VzIG9mIGpzdHJlZSBpbiB0aGUgRE9NIChvbmx5IHRoZSBvbmVzIHNldCB1c2luZyBqc3RyZWUqKSBhbmQgY2xlYW5zIGFsbCBldmVudHNcblx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKClcblx0XHRcdFx0XHQudW5iaW5kKFwiLmpzdHJlZVwiKVxuXHRcdFx0XHRcdC51bmRlbGVnYXRlKFwiLmpzdHJlZVwiKVxuXHRcdFx0XHRcdC5yZW1vdmVEYXRhKFwianN0cmVlX2luc3RhbmNlX2lkXCIpXG5cdFx0XHRcdFx0LmZpbmQoXCJbY2xhc3NePSdqc3RyZWUnXVwiKVxuXHRcdFx0XHRcdFx0LmFuZFNlbGYoKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNsYXNzTmFtZS5yZXBsYWNlKC9qc3RyZWVbXiBdKnwkL2lnLCcnKTsgfSk7XG5cdFx0XHRcdCQoZG9jdW1lbnQpXG5cdFx0XHRcdFx0LnVuYmluZChcIi5qc3RyZWUtXCIgKyBuKVxuXHRcdFx0XHRcdC51bmRlbGVnYXRlKFwiLmpzdHJlZS1cIiArIG4pO1xuXHRcdFx0XHQvLyByZW1vdmUgdGhlIGFjdHVhbCBkYXRhXG5cdFx0XHRcdGluc3RhbmNlc1tuXSA9IG51bGw7XG5cdFx0XHRcdGRlbGV0ZSBpbnN0YW5jZXNbbl07XG5cdFx0XHR9LFxuXG5cdFx0XHRfY29yZV9ub3RpZnkgOiBmdW5jdGlvbiAobiwgZGF0YSkge1xuXHRcdFx0XHRpZihkYXRhLm9wZW5lZCkge1xuXHRcdFx0XHRcdHRoaXMub3Blbl9ub2RlKG4sIGZhbHNlLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0bG9jayA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5kYXRhLmNvcmUubG9ja2VkID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5hZGRDbGFzcyhcImpzdHJlZS1sb2NrZWRcIikuY3NzKFwib3BhY2l0eVwiLFwiMC43XCIpO1xuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soe30pO1xuXHRcdFx0fSxcblx0XHRcdHVubG9jayA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5kYXRhLmNvcmUubG9ja2VkID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpLmNoaWxkcmVuKFwidWxcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbG9ja2VkXCIpLmNzcyhcIm9wYWNpdHlcIixcIjFcIik7XG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjayh7fSk7XG5cdFx0XHR9LFxuXHRcdFx0aXNfbG9ja2VkIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kYXRhLmNvcmUubG9ja2VkOyB9LFxuXHRcdFx0c2F2ZV9vcGVuZWQgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0XHRcdHRoaXMuZGF0YS5jb3JlLnRvX29wZW4gPSBbXTtcblx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyX3VsKCkuZmluZChcImxpLmpzdHJlZS1vcGVuXCIpLmVhY2goZnVuY3Rpb24gKCkgeyBcblx0XHRcdFx0XHRpZih0aGlzLmlkKSB7IF90aGlzLmRhdGEuY29yZS50b19vcGVuLnB1c2goXCIjXCIgKyB0aGlzLmlkLnRvU3RyaW5nKCkucmVwbGFjZSgvXiMvLFwiXCIpLnJlcGxhY2UoL1xcXFxcXC8vZyxcIi9cIikucmVwbGFjZSgvXFwvL2csXCJcXFxcXFwvXCIpLnJlcGxhY2UoL1xcXFxcXC4vZyxcIi5cIikucmVwbGFjZSgvXFwuL2csXCJcXFxcLlwiKS5yZXBsYWNlKC9cXDovZyxcIlxcXFw6XCIpKTsgfVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKF90aGlzLmRhdGEuY29yZS50b19vcGVuKTtcblx0XHRcdH0sXG5cdFx0XHRzYXZlX2xvYWRlZCA6IGZ1bmN0aW9uICgpIHsgfSxcblx0XHRcdHJlbG9hZF9ub2RlcyA6IGZ1bmN0aW9uIChpc19jYWxsYmFjaykge1xuXHRcdFx0XHR2YXIgX3RoaXMgPSB0aGlzLFxuXHRcdFx0XHRcdGRvbmUgPSB0cnVlLFxuXHRcdFx0XHRcdGN1cnJlbnQgPSBbXSxcblx0XHRcdFx0XHRyZW1haW5pbmcgPSBbXTtcblx0XHRcdFx0aWYoIWlzX2NhbGxiYWNrKSB7IFxuXHRcdFx0XHRcdHRoaXMuZGF0YS5jb3JlLnJlb3BlbiA9IGZhbHNlOyBcblx0XHRcdFx0XHR0aGlzLmRhdGEuY29yZS5yZWZyZXNoaW5nID0gdHJ1ZTsgXG5cdFx0XHRcdFx0dGhpcy5kYXRhLmNvcmUudG9fb3BlbiA9ICQubWFwKCQubWFrZUFycmF5KHRoaXMuZGF0YS5jb3JlLnRvX29wZW4pLCBmdW5jdGlvbiAobikgeyByZXR1cm4gXCIjXCIgKyBuLnRvU3RyaW5nKCkucmVwbGFjZSgvXiMvLFwiXCIpLnJlcGxhY2UoL1xcXFxcXC8vZyxcIi9cIikucmVwbGFjZSgvXFwvL2csXCJcXFxcXFwvXCIpLnJlcGxhY2UoL1xcXFxcXC4vZyxcIi5cIikucmVwbGFjZSgvXFwuL2csXCJcXFxcLlwiKS5yZXBsYWNlKC9cXDovZyxcIlxcXFw6XCIpOyB9KTtcblx0XHRcdFx0XHR0aGlzLmRhdGEuY29yZS50b19sb2FkID0gJC5tYXAoJC5tYWtlQXJyYXkodGhpcy5kYXRhLmNvcmUudG9fbG9hZCksIGZ1bmN0aW9uIChuKSB7IHJldHVybiBcIiNcIiArIG4udG9TdHJpbmcoKS5yZXBsYWNlKC9eIy8sXCJcIikucmVwbGFjZSgvXFxcXFxcLy9nLFwiL1wiKS5yZXBsYWNlKC9cXC8vZyxcIlxcXFxcXC9cIikucmVwbGFjZSgvXFxcXFxcLi9nLFwiLlwiKS5yZXBsYWNlKC9cXC4vZyxcIlxcXFwuXCIpLnJlcGxhY2UoL1xcOi9nLFwiXFxcXDpcIik7IH0pO1xuXHRcdFx0XHRcdGlmKHRoaXMuZGF0YS5jb3JlLnRvX29wZW4ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEuY29yZS50b19sb2FkID0gdGhpcy5kYXRhLmNvcmUudG9fbG9hZC5jb25jYXQodGhpcy5kYXRhLmNvcmUudG9fb3Blbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHRoaXMuZGF0YS5jb3JlLnRvX2xvYWQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0JC5lYWNoKHRoaXMuZGF0YS5jb3JlLnRvX2xvYWQsIGZ1bmN0aW9uIChpLCB2YWwpIHtcblx0XHRcdFx0XHRcdGlmKHZhbCA9PSBcIiNcIikgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdFx0XHRcdFx0aWYoJCh2YWwpLmxlbmd0aCkgeyBjdXJyZW50LnB1c2godmFsKTsgfVxuXHRcdFx0XHRcdFx0ZWxzZSB7IHJlbWFpbmluZy5wdXNoKHZhbCk7IH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRpZihjdXJyZW50Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0dGhpcy5kYXRhLmNvcmUudG9fbG9hZCA9IHJlbWFpbmluZztcblx0XHRcdFx0XHRcdCQuZWFjaChjdXJyZW50LCBmdW5jdGlvbiAoaSwgdmFsKSB7IFxuXHRcdFx0XHRcdFx0XHRpZighX3RoaXMuX2lzX2xvYWRlZCh2YWwpKSB7XG5cdFx0XHRcdFx0XHRcdFx0X3RoaXMubG9hZF9ub2RlKHZhbCwgZnVuY3Rpb24gKCkgeyBfdGhpcy5yZWxvYWRfbm9kZXModHJ1ZSk7IH0sIGZ1bmN0aW9uICgpIHsgX3RoaXMucmVsb2FkX25vZGVzKHRydWUpOyB9KTtcblx0XHRcdFx0XHRcdFx0XHRkb25lID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZih0aGlzLmRhdGEuY29yZS50b19vcGVuLmxlbmd0aCkge1xuXHRcdFx0XHRcdCQuZWFjaCh0aGlzLmRhdGEuY29yZS50b19vcGVuLCBmdW5jdGlvbiAoaSwgdmFsKSB7XG5cdFx0XHRcdFx0XHRfdGhpcy5vcGVuX25vZGUodmFsLCBmYWxzZSwgdHJ1ZSk7IFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGRvbmUpIHsgXG5cdFx0XHRcdFx0Ly8gVE9ETzogZmluZCBhIG1vcmUgZWxlZ2FudCBhcHByb2FjaCB0byBzeW5jcm9uaXppbmcgcmV0dXJuaW5nIHJlcXVlc3RzXG5cdFx0XHRcdFx0aWYodGhpcy5kYXRhLmNvcmUucmVvcGVuKSB7IGNsZWFyVGltZW91dCh0aGlzLmRhdGEuY29yZS5yZW9wZW4pOyB9XG5cdFx0XHRcdFx0dGhpcy5kYXRhLmNvcmUucmVvcGVuID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IF90aGlzLl9fY2FsbGJhY2soe30sIF90aGlzKTsgfSwgNTApO1xuXHRcdFx0XHRcdHRoaXMuZGF0YS5jb3JlLnJlZnJlc2hpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHR0aGlzLnJlb3BlbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVvcGVuIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdFx0XHRpZih0aGlzLmRhdGEuY29yZS50b19vcGVuLmxlbmd0aCkge1xuXHRcdFx0XHRcdCQuZWFjaCh0aGlzLmRhdGEuY29yZS50b19vcGVuLCBmdW5jdGlvbiAoaSwgdmFsKSB7XG5cdFx0XHRcdFx0XHRfdGhpcy5vcGVuX25vZGUodmFsLCBmYWxzZSwgdHJ1ZSk7IFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjayh7fSk7XG5cdFx0XHR9LFxuXHRcdFx0cmVmcmVzaCA6IGZ1bmN0aW9uIChvYmosIHNfY2FsbCwgZV9jYWxsKSB7XG5cdFx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0XHRcdHRoaXMuc2F2ZV9vcGVuZWQoKTtcblx0XHRcdFx0aWYoIW9iaikgeyBvYmogPSAtMTsgfVxuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRpZighb2JqKSB7IG9iaiA9IC0xOyB9XG5cdFx0XHRcdGlmKG9iaiAhPT0gLTEpIHsgb2JqLmNoaWxkcmVuKFwiVUxcIikucmVtb3ZlKCk7IH1cblx0XHRcdFx0ZWxzZSB7IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmVtcHR5KCk7IH1cblx0XHRcdFx0dGhpcy5sb2FkX25vZGUoXG5cdFx0XHRcdFx0b2JqLCBcblx0XHRcdFx0XHRmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHRcdFx0X3RoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiBvYmp9KTsgXG5cdFx0XHRcdFx0XHRfdGhpcy5yZWxvYWRfbm9kZXMoKTsgXG5cdFx0XHRcdFx0XHRpZihzX2NhbGwpIHNfY2FsbC5jYWxsKHRoaXMpOyBcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGVfY2FsbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSxcblx0XHRcdC8vIER1bW15IGZ1bmN0aW9uIHRvIGZpcmUgYWZ0ZXIgdGhlIGZpcnN0IGxvYWQgKHNvIHRoYXQgdGhlcmUgaXMgYSBqc3RyZWUubG9hZGVkIGV2ZW50KVxuXHRcdFx0bG9hZGVkXHQ6IGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjaygpOyBcblx0XHRcdH0sXG5cdFx0XHQvLyBkZWFsIHdpdGggZm9jdXNcblx0XHRcdHNldF9mb2N1c1x0OiBmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHRpZih0aGlzLmlzX2ZvY3VzZWQoKSkgeyByZXR1cm47IH1cblx0XHRcdFx0dmFyIGYgPSAkLmpzdHJlZS5fZm9jdXNlZCgpO1xuXHRcdFx0XHRpZihmKSB7IGYudW5zZXRfZm9jdXMoKTsgfVxuXG5cdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpLmFkZENsYXNzKFwianN0cmVlLWZvY3VzZWRcIik7IFxuXHRcdFx0XHRmb2N1c2VkX2luc3RhbmNlID0gdGhpcy5nZXRfaW5kZXgoKTsgXG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjaygpO1xuXHRcdFx0fSxcblx0XHRcdGlzX2ZvY3VzZWRcdDogZnVuY3Rpb24gKCkgeyBcblx0XHRcdFx0cmV0dXJuIGZvY3VzZWRfaW5zdGFuY2UgPT0gdGhpcy5nZXRfaW5kZXgoKTsgXG5cdFx0XHR9LFxuXHRcdFx0dW5zZXRfZm9jdXNcdDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZih0aGlzLmlzX2ZvY3VzZWQoKSkge1xuXHRcdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpLnJlbW92ZUNsYXNzKFwianN0cmVlLWZvY3VzZWRcIik7IFxuXHRcdFx0XHRcdGZvY3VzZWRfaW5zdGFuY2UgPSAtMTsgXG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKCk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyB0cmF2ZXJzZVxuXHRcdFx0X2dldF9ub2RlXHRcdDogZnVuY3Rpb24gKG9iaikgeyBcblx0XHRcdFx0dmFyICRvYmogPSAkKG9iaiwgdGhpcy5nZXRfY29udGFpbmVyKCkpOyBcblx0XHRcdFx0aWYoJG9iai5pcyhcIi5qc3RyZWVcIikgfHwgb2JqID09IC0xKSB7IHJldHVybiAtMTsgfSBcblx0XHRcdFx0JG9iaiA9ICRvYmouY2xvc2VzdChcImxpXCIsIHRoaXMuZ2V0X2NvbnRhaW5lcigpKTsgXG5cdFx0XHRcdHJldHVybiAkb2JqLmxlbmd0aCA/ICRvYmogOiBmYWxzZTsgXG5cdFx0XHR9LFxuXHRcdFx0X2dldF9uZXh0XHRcdDogZnVuY3Rpb24gKG9iaiwgc3RyaWN0KSB7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdGlmKG9iaiA9PT0gLTEpIHsgcmV0dXJuIHRoaXMuZ2V0X2NvbnRhaW5lcigpLmZpbmQoXCI+IHVsID4gbGk6Zmlyc3QtY2hpbGRcIik7IH1cblx0XHRcdFx0aWYoIW9iai5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdGlmKHN0cmljdCkgeyByZXR1cm4gKG9iai5uZXh0QWxsKFwibGlcIikuc2l6ZSgpID4gMCkgPyBvYmoubmV4dEFsbChcImxpOmVxKDApXCIpIDogZmFsc2U7IH1cblxuXHRcdFx0XHRpZihvYmouaGFzQ2xhc3MoXCJqc3RyZWUtb3BlblwiKSkgeyByZXR1cm4gb2JqLmZpbmQoXCJsaTplcSgwKVwiKTsgfVxuXHRcdFx0XHRlbHNlIGlmKG9iai5uZXh0QWxsKFwibGlcIikuc2l6ZSgpID4gMCkgeyByZXR1cm4gb2JqLm5leHRBbGwoXCJsaTplcSgwKVwiKTsgfVxuXHRcdFx0XHRlbHNlIHsgcmV0dXJuIG9iai5wYXJlbnRzVW50aWwoXCIuanN0cmVlXCIsXCJsaVwiKS5uZXh0KFwibGlcIikuZXEoMCk7IH1cblx0XHRcdH0sXG5cdFx0XHRfZ2V0X3ByZXZcdFx0OiBmdW5jdGlvbiAob2JqLCBzdHJpY3QpIHtcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0aWYob2JqID09PSAtMSkgeyByZXR1cm4gdGhpcy5nZXRfY29udGFpbmVyKCkuZmluZChcIj4gdWwgPiBsaTpsYXN0LWNoaWxkXCIpOyB9XG5cdFx0XHRcdGlmKCFvYmoubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRpZihzdHJpY3QpIHsgcmV0dXJuIChvYmoucHJldkFsbChcImxpXCIpLmxlbmd0aCA+IDApID8gb2JqLnByZXZBbGwoXCJsaTplcSgwKVwiKSA6IGZhbHNlOyB9XG5cblx0XHRcdFx0aWYob2JqLnByZXYoXCJsaVwiKS5sZW5ndGgpIHtcblx0XHRcdFx0XHRvYmogPSBvYmoucHJldihcImxpXCIpLmVxKDApO1xuXHRcdFx0XHRcdHdoaWxlKG9iai5oYXNDbGFzcyhcImpzdHJlZS1vcGVuXCIpKSB7IG9iaiA9IG9iai5jaGlsZHJlbihcInVsOmVxKDApXCIpLmNoaWxkcmVuKFwibGk6bGFzdFwiKTsgfVxuXHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7IHZhciBvID0gb2JqLnBhcmVudHNVbnRpbChcIi5qc3RyZWVcIixcImxpOmVxKDApXCIpOyByZXR1cm4gby5sZW5ndGggPyBvIDogZmFsc2U7IH1cblx0XHRcdH0sXG5cdFx0XHRfZ2V0X3BhcmVudFx0XHQ6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0aWYob2JqID09IC0xIHx8ICFvYmoubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHR2YXIgbyA9IG9iai5wYXJlbnRzVW50aWwoXCIuanN0cmVlXCIsIFwibGk6ZXEoMClcIik7XG5cdFx0XHRcdHJldHVybiBvLmxlbmd0aCA/IG8gOiAtMTtcblx0XHRcdH0sXG5cdFx0XHRfZ2V0X2NoaWxkcmVuXHQ6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0aWYob2JqID09PSAtMSkgeyByZXR1cm4gdGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bDplcSgwKVwiKS5jaGlsZHJlbihcImxpXCIpOyB9XG5cdFx0XHRcdGlmKCFvYmoubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRyZXR1cm4gb2JqLmNoaWxkcmVuKFwidWw6ZXEoMClcIikuY2hpbGRyZW4oXCJsaVwiKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRfcGF0aFx0XHQ6IGZ1bmN0aW9uIChvYmosIGlkX21vZGUpIHtcblx0XHRcdFx0dmFyIHAgPSBbXSxcblx0XHRcdFx0XHRfdGhpcyA9IHRoaXM7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdGlmKG9iaiA9PT0gLTEgfHwgIW9iaiB8fCAhb2JqLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0b2JqLnBhcmVudHNVbnRpbChcIi5qc3RyZWVcIiwgXCJsaVwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRwLnB1c2goIGlkX21vZGUgPyB0aGlzLmlkIDogX3RoaXMuZ2V0X3RleHQodGhpcykgKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHAucmV2ZXJzZSgpO1xuXHRcdFx0XHRwLnB1c2goIGlkX21vZGUgPyBvYmouYXR0cihcImlkXCIpIDogdGhpcy5nZXRfdGV4dChvYmopICk7XG5cdFx0XHRcdHJldHVybiBwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gc3RyaW5nIGZ1bmN0aW9uc1xuXHRcdFx0X2dldF9zdHJpbmcgOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9nZXRfc2V0dGluZ3MoKS5jb3JlLnN0cmluZ3Nba2V5XSB8fCBrZXk7XG5cdFx0XHR9LFxuXG5cdFx0XHRpc19vcGVuXHRcdDogZnVuY3Rpb24gKG9iaikgeyBvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopOyByZXR1cm4gb2JqICYmIG9iaiAhPT0gLTEgJiYgb2JqLmhhc0NsYXNzKFwianN0cmVlLW9wZW5cIik7IH0sXG5cdFx0XHRpc19jbG9zZWRcdDogZnVuY3Rpb24gKG9iaikgeyBvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopOyByZXR1cm4gb2JqICYmIG9iaiAhPT0gLTEgJiYgb2JqLmhhc0NsYXNzKFwianN0cmVlLWNsb3NlZFwiKTsgfSxcblx0XHRcdGlzX2xlYWZcdFx0OiBmdW5jdGlvbiAob2JqKSB7IG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7IHJldHVybiBvYmogJiYgb2JqICE9PSAtMSAmJiBvYmouaGFzQ2xhc3MoXCJqc3RyZWUtbGVhZlwiKTsgfSxcblx0XHRcdGNvcnJlY3Rfc3RhdGVcdDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRpZighb2JqIHx8IG9iaiA9PT0gLTEpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdG9iai5yZW1vdmVDbGFzcyhcImpzdHJlZS1jbG9zZWQganN0cmVlLW9wZW5cIikuYWRkQ2xhc3MoXCJqc3RyZWUtbGVhZlwiKS5jaGlsZHJlbihcInVsXCIpLnJlbW92ZSgpO1xuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogb2JqIH0pO1xuXHRcdFx0fSxcblx0XHRcdC8vIG9wZW4vY2xvc2Vcblx0XHRcdG9wZW5fbm9kZVx0OiBmdW5jdGlvbiAob2JqLCBjYWxsYmFjaywgc2tpcF9hbmltYXRpb24pIHtcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0aWYoIW9iai5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdGlmKCFvYmouaGFzQ2xhc3MoXCJqc3RyZWUtY2xvc2VkXCIpKSB7IGlmKGNhbGxiYWNrKSB7IGNhbGxiYWNrLmNhbGwoKTsgfSByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0dmFyIHMgPSBza2lwX2FuaW1hdGlvbiB8fCBpc19pZTYgPyAwIDogdGhpcy5fZ2V0X3NldHRpbmdzKCkuY29yZS5hbmltYXRpb24sXG5cdFx0XHRcdFx0dCA9IHRoaXM7XG5cdFx0XHRcdGlmKCF0aGlzLl9pc19sb2FkZWQob2JqKSkge1xuXHRcdFx0XHRcdG9iai5jaGlsZHJlbihcImFcIikuYWRkQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKTtcblx0XHRcdFx0XHR0aGlzLmxvYWRfbm9kZShvYmosIGZ1bmN0aW9uICgpIHsgdC5vcGVuX25vZGUob2JqLCBjYWxsYmFjaywgc2tpcF9hbmltYXRpb24pOyB9LCBjYWxsYmFjayk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYodGhpcy5fZ2V0X3NldHRpbmdzKCkuY29yZS5vcGVuX3BhcmVudHMpIHtcblx0XHRcdFx0XHRcdG9iai5wYXJlbnRzVW50aWwoXCIuanN0cmVlXCIsXCIuanN0cmVlLWNsb3NlZFwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0dC5vcGVuX25vZGUodGhpcywgZmFsc2UsIHRydWUpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHMpIHsgb2JqLmNoaWxkcmVuKFwidWxcIikuY3NzKFwiZGlzcGxheVwiLFwibm9uZVwiKTsgfVxuXHRcdFx0XHRcdG9iai5yZW1vdmVDbGFzcyhcImpzdHJlZS1jbG9zZWRcIikuYWRkQ2xhc3MoXCJqc3RyZWUtb3BlblwiKS5jaGlsZHJlbihcImFcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKTtcblx0XHRcdFx0XHRpZihzKSB7IG9iai5jaGlsZHJlbihcInVsXCIpLnN0b3AodHJ1ZSwgdHJ1ZSkuc2xpZGVEb3duKHMsIGZ1bmN0aW9uICgpIHsgdGhpcy5zdHlsZS5kaXNwbGF5ID0gXCJcIjsgdC5hZnRlcl9vcGVuKG9iaik7IH0pOyB9XG5cdFx0XHRcdFx0ZWxzZSB7IHQuYWZ0ZXJfb3BlbihvYmopOyB9XG5cdFx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHsgXCJvYmpcIiA6IG9iaiB9KTtcblx0XHRcdFx0XHRpZihjYWxsYmFjaykgeyBjYWxsYmFjay5jYWxsKCk7IH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGFmdGVyX29wZW5cdDogZnVuY3Rpb24gKG9iaikgeyB0aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogb2JqIH0pOyB9LFxuXHRcdFx0Y2xvc2Vfbm9kZVx0OiBmdW5jdGlvbiAob2JqLCBza2lwX2FuaW1hdGlvbikge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHR2YXIgcyA9IHNraXBfYW5pbWF0aW9uIHx8IGlzX2llNiA/IDAgOiB0aGlzLl9nZXRfc2V0dGluZ3MoKS5jb3JlLmFuaW1hdGlvbixcblx0XHRcdFx0XHR0ID0gdGhpcztcblx0XHRcdFx0aWYoIW9iai5sZW5ndGggfHwgIW9iai5oYXNDbGFzcyhcImpzdHJlZS1vcGVuXCIpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRpZihzKSB7IG9iai5jaGlsZHJlbihcInVsXCIpLmF0dHIoXCJzdHlsZVwiLFwiZGlzcGxheTpibG9jayAhaW1wb3J0YW50XCIpOyB9XG5cdFx0XHRcdG9iai5yZW1vdmVDbGFzcyhcImpzdHJlZS1vcGVuXCIpLmFkZENsYXNzKFwianN0cmVlLWNsb3NlZFwiKTtcblx0XHRcdFx0aWYocykgeyBvYmouY2hpbGRyZW4oXCJ1bFwiKS5zdG9wKHRydWUsIHRydWUpLnNsaWRlVXAocywgZnVuY3Rpb24gKCkgeyB0aGlzLnN0eWxlLmRpc3BsYXkgPSBcIlwiOyB0LmFmdGVyX2Nsb3NlKG9iaik7IH0pOyB9XG5cdFx0XHRcdGVsc2UgeyB0LmFmdGVyX2Nsb3NlKG9iaik7IH1cblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHsgXCJvYmpcIiA6IG9iaiB9KTtcblx0XHRcdH0sXG5cdFx0XHRhZnRlcl9jbG9zZVx0OiBmdW5jdGlvbiAob2JqKSB7IHRoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiBvYmogfSk7IH0sXG5cdFx0XHR0b2dnbGVfbm9kZVx0OiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdGlmKG9iai5oYXNDbGFzcyhcImpzdHJlZS1jbG9zZWRcIikpIHsgcmV0dXJuIHRoaXMub3Blbl9ub2RlKG9iaik7IH1cblx0XHRcdFx0aWYob2JqLmhhc0NsYXNzKFwianN0cmVlLW9wZW5cIikpIHsgcmV0dXJuIHRoaXMuY2xvc2Vfbm9kZShvYmopOyB9XG5cdFx0XHR9LFxuXHRcdFx0b3Blbl9hbGxcdDogZnVuY3Rpb24gKG9iaiwgZG9fYW5pbWF0aW9uLCBvcmlnaW5hbF9vYmopIHtcblx0XHRcdFx0b2JqID0gb2JqID8gdGhpcy5fZ2V0X25vZGUob2JqKSA6IC0xO1xuXHRcdFx0XHRpZighb2JqIHx8IG9iaiA9PT0gLTEpIHsgb2JqID0gdGhpcy5nZXRfY29udGFpbmVyX3VsKCk7IH1cblx0XHRcdFx0aWYob3JpZ2luYWxfb2JqKSB7IFxuXHRcdFx0XHRcdG9iaiA9IG9iai5maW5kKFwibGkuanN0cmVlLWNsb3NlZFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRvcmlnaW5hbF9vYmogPSBvYmo7XG5cdFx0XHRcdFx0aWYob2JqLmlzKFwiLmpzdHJlZS1jbG9zZWRcIikpIHsgb2JqID0gb2JqLmZpbmQoXCJsaS5qc3RyZWUtY2xvc2VkXCIpLmFuZFNlbGYoKTsgfVxuXHRcdFx0XHRcdGVsc2UgeyBvYmogPSBvYmouZmluZChcImxpLmpzdHJlZS1jbG9zZWRcIik7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdFx0XHRvYmouZWFjaChmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHRcdHZhciBfX3RoaXMgPSB0aGlzOyBcblx0XHRcdFx0XHRpZighX3RoaXMuX2lzX2xvYWRlZCh0aGlzKSkgeyBfdGhpcy5vcGVuX25vZGUodGhpcywgZnVuY3Rpb24oKSB7IF90aGlzLm9wZW5fYWxsKF9fdGhpcywgZG9fYW5pbWF0aW9uLCBvcmlnaW5hbF9vYmopOyB9LCAhZG9fYW5pbWF0aW9uKTsgfVxuXHRcdFx0XHRcdGVsc2UgeyBfdGhpcy5vcGVuX25vZGUodGhpcywgZmFsc2UsICFkb19hbmltYXRpb24pOyB9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQvLyBzbyB0aGF0IGNhbGxiYWNrIGlzIGZpcmVkIEFGVEVSIGFsbCBub2RlcyBhcmUgb3BlblxuXHRcdFx0XHRpZihvcmlnaW5hbF9vYmouZmluZCgnbGkuanN0cmVlLWNsb3NlZCcpLmxlbmd0aCA9PT0gMCkgeyB0aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogb3JpZ2luYWxfb2JqIH0pOyB9XG5cdFx0XHR9LFxuXHRcdFx0Y2xvc2VfYWxsXHQ6IGZ1bmN0aW9uIChvYmosIGRvX2FuaW1hdGlvbikge1xuXHRcdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdFx0XHRvYmogPSBvYmogPyB0aGlzLl9nZXRfbm9kZShvYmopIDogdGhpcy5nZXRfY29udGFpbmVyKCk7XG5cdFx0XHRcdGlmKCFvYmogfHwgb2JqID09PSAtMSkgeyBvYmogPSB0aGlzLmdldF9jb250YWluZXJfdWwoKTsgfVxuXHRcdFx0XHRvYmouZmluZChcImxpLmpzdHJlZS1vcGVuXCIpLmFuZFNlbGYoKS5lYWNoKGZ1bmN0aW9uICgpIHsgX3RoaXMuY2xvc2Vfbm9kZSh0aGlzLCAhZG9fYW5pbWF0aW9uKTsgfSk7XG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiBvYmogfSk7XG5cdFx0XHR9LFxuXHRcdFx0Y2xlYW5fbm9kZVx0OiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdG9iaiA9IG9iaiAmJiBvYmogIT0gLTEgPyAkKG9iaikgOiB0aGlzLmdldF9jb250YWluZXJfdWwoKTtcblx0XHRcdFx0b2JqID0gb2JqLmlzKFwibGlcIikgPyBvYmouZmluZChcImxpXCIpLmFuZFNlbGYoKSA6IG9iai5maW5kKFwibGlcIik7XG5cdFx0XHRcdG9iai5yZW1vdmVDbGFzcyhcImpzdHJlZS1sYXN0XCIpXG5cdFx0XHRcdFx0LmZpbHRlcihcImxpOmxhc3QtY2hpbGRcIikuYWRkQ2xhc3MoXCJqc3RyZWUtbGFzdFwiKS5lbmQoKVxuXHRcdFx0XHRcdC5maWx0ZXIoXCI6aGFzKGxpKVwiKVxuXHRcdFx0XHRcdFx0Lm5vdChcIi5qc3RyZWUtb3BlblwiKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1sZWFmXCIpLmFkZENsYXNzKFwianN0cmVlLWNsb3NlZFwiKTtcblx0XHRcdFx0b2JqLm5vdChcIi5qc3RyZWUtb3BlbiwgLmpzdHJlZS1jbG9zZWRcIikuYWRkQ2xhc3MoXCJqc3RyZWUtbGVhZlwiKS5jaGlsZHJlbihcInVsXCIpLnJlbW92ZSgpO1xuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogb2JqIH0pO1xuXHRcdFx0fSxcblx0XHRcdC8vIHJvbGxiYWNrXG5cdFx0XHRnZXRfcm9sbGJhY2sgOiBmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soKTtcblx0XHRcdFx0cmV0dXJuIHsgaSA6IHRoaXMuZ2V0X2luZGV4KCksIGggOiB0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcInVsXCIpLmNsb25lKHRydWUpLCBkIDogdGhpcy5kYXRhIH07IFxuXHRcdFx0fSxcblx0XHRcdHNldF9yb2xsYmFjayA6IGZ1bmN0aW9uIChodG1sLCBkYXRhKSB7XG5cdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpLmVtcHR5KCkuYXBwZW5kKGh0bWwpO1xuXHRcdFx0XHR0aGlzLmRhdGEgPSBkYXRhO1xuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soKTtcblx0XHRcdH0sXG5cdFx0XHQvLyBEdW1teSBmdW5jdGlvbnMgdG8gYmUgb3ZlcndyaXR0ZW4gYnkgYW55IGRhdGFzdG9yZSBwbHVnaW4gaW5jbHVkZWRcblx0XHRcdGxvYWRfbm9kZVx0OiBmdW5jdGlvbiAob2JqLCBzX2NhbGwsIGVfY2FsbCkgeyB0aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogb2JqIH0pOyB9LFxuXHRcdFx0X2lzX2xvYWRlZFx0OiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0cnVlOyB9LFxuXG5cdFx0XHQvLyBCYXNpYyBvcGVyYXRpb25zOiBjcmVhdGVcblx0XHRcdGNyZWF0ZV9ub2RlXHQ6IGZ1bmN0aW9uIChvYmosIHBvc2l0aW9uLCBqcywgY2FsbGJhY2ssIGlzX2xvYWRlZCkge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRwb3NpdGlvbiA9IHR5cGVvZiBwb3NpdGlvbiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwibGFzdFwiIDogcG9zaXRpb247XG5cdFx0XHRcdHZhciBkID0gJChcIjxsaSAvPlwiKSxcblx0XHRcdFx0XHRzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkuY29yZSxcblx0XHRcdFx0XHR0bXA7XG5cblx0XHRcdFx0aWYob2JqICE9PSAtMSAmJiAhb2JqLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0aWYoIWlzX2xvYWRlZCAmJiAhdGhpcy5faXNfbG9hZGVkKG9iaikpIHsgdGhpcy5sb2FkX25vZGUob2JqLCBmdW5jdGlvbiAoKSB7IHRoaXMuY3JlYXRlX25vZGUob2JqLCBwb3NpdGlvbiwganMsIGNhbGxiYWNrLCB0cnVlKTsgfSk7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0XHRcdHRoaXMuX19yb2xsYmFjaygpO1xuXG5cdFx0XHRcdGlmKHR5cGVvZiBqcyA9PT0gXCJzdHJpbmdcIikgeyBqcyA9IHsgXCJkYXRhXCIgOiBqcyB9OyB9XG5cdFx0XHRcdGlmKCFqcykgeyBqcyA9IHt9OyB9XG5cdFx0XHRcdGlmKGpzLmF0dHIpIHsgZC5hdHRyKGpzLmF0dHIpOyB9XG5cdFx0XHRcdGlmKGpzLm1ldGFkYXRhKSB7IGQuZGF0YShqcy5tZXRhZGF0YSk7IH1cblx0XHRcdFx0aWYoanMuc3RhdGUpIHsgZC5hZGRDbGFzcyhcImpzdHJlZS1cIiArIGpzLnN0YXRlKTsgfVxuXHRcdFx0XHRpZighanMuZGF0YSkgeyBqcy5kYXRhID0gdGhpcy5fZ2V0X3N0cmluZyhcIm5ld19ub2RlXCIpOyB9XG5cdFx0XHRcdGlmKCEkLmlzQXJyYXkoanMuZGF0YSkpIHsgdG1wID0ganMuZGF0YTsganMuZGF0YSA9IFtdOyBqcy5kYXRhLnB1c2godG1wKTsgfVxuXHRcdFx0XHQkLmVhY2goanMuZGF0YSwgZnVuY3Rpb24gKGksIG0pIHtcblx0XHRcdFx0XHR0bXAgPSAkKFwiPGEgLz5cIik7XG5cdFx0XHRcdFx0aWYoJC5pc0Z1bmN0aW9uKG0pKSB7IG0gPSBtLmNhbGwodGhpcywganMpOyB9XG5cdFx0XHRcdFx0aWYodHlwZW9mIG0gPT0gXCJzdHJpbmdcIikgeyB0bXAuYXR0cignaHJlZicsJyMnKVsgcy5odG1sX3RpdGxlcyA/IFwiaHRtbFwiIDogXCJ0ZXh0XCIgXShtKTsgfVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYoIW0uYXR0cikgeyBtLmF0dHIgPSB7fTsgfVxuXHRcdFx0XHRcdFx0aWYoIW0uYXR0ci5ocmVmKSB7IG0uYXR0ci5ocmVmID0gJyMnOyB9XG5cdFx0XHRcdFx0XHR0bXAuYXR0cihtLmF0dHIpWyBzLmh0bWxfdGl0bGVzID8gXCJodG1sXCIgOiBcInRleHRcIiBdKG0udGl0bGUpO1xuXHRcdFx0XHRcdFx0aWYobS5sYW5ndWFnZSkgeyB0bXAuYWRkQ2xhc3MobS5sYW5ndWFnZSk7IH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dG1wLnByZXBlbmQoXCI8aW5zIGNsYXNzPSdqc3RyZWUtaWNvbic+JiMxNjA7PC9pbnM+XCIpO1xuXHRcdFx0XHRcdGlmKCFtLmljb24gJiYganMuaWNvbikgeyBtLmljb24gPSBqcy5pY29uOyB9XG5cdFx0XHRcdFx0aWYobS5pY29uKSB7IFxuXHRcdFx0XHRcdFx0aWYobS5pY29uLmluZGV4T2YoXCIvXCIpID09PSAtMSkgeyB0bXAuY2hpbGRyZW4oXCJpbnNcIikuYWRkQ2xhc3MobS5pY29uKTsgfVxuXHRcdFx0XHRcdFx0ZWxzZSB7IHRtcC5jaGlsZHJlbihcImluc1wiKS5jc3MoXCJiYWNrZ3JvdW5kXCIsXCJ1cmwoJ1wiICsgbS5pY29uICsgXCInKSBjZW50ZXIgY2VudGVyIG5vLXJlcGVhdFwiKTsgfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkLmFwcGVuZCh0bXApO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0ZC5wcmVwZW5kKFwiPGlucyBjbGFzcz0nanN0cmVlLWljb24nPiYjMTYwOzwvaW5zPlwiKTtcblx0XHRcdFx0aWYob2JqID09PSAtMSkge1xuXHRcdFx0XHRcdG9iaiA9IHRoaXMuZ2V0X2NvbnRhaW5lcigpO1xuXHRcdFx0XHRcdGlmKHBvc2l0aW9uID09PSBcImJlZm9yZVwiKSB7IHBvc2l0aW9uID0gXCJmaXJzdFwiOyB9XG5cdFx0XHRcdFx0aWYocG9zaXRpb24gPT09IFwiYWZ0ZXJcIikgeyBwb3NpdGlvbiA9IFwibGFzdFwiOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3dpdGNoKHBvc2l0aW9uKSB7XG5cdFx0XHRcdFx0Y2FzZSBcImJlZm9yZVwiOiBvYmouYmVmb3JlKGQpOyB0bXAgPSB0aGlzLl9nZXRfcGFyZW50KG9iaik7IGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJhZnRlclwiIDogb2JqLmFmdGVyKGQpOyAgdG1wID0gdGhpcy5fZ2V0X3BhcmVudChvYmopOyBicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiaW5zaWRlXCI6XG5cdFx0XHRcdFx0Y2FzZSBcImZpcnN0XCIgOlxuXHRcdFx0XHRcdFx0aWYoIW9iai5jaGlsZHJlbihcInVsXCIpLmxlbmd0aCkgeyBvYmouYXBwZW5kKFwiPHVsIC8+XCIpOyB9XG5cdFx0XHRcdFx0XHRvYmouY2hpbGRyZW4oXCJ1bFwiKS5wcmVwZW5kKGQpO1xuXHRcdFx0XHRcdFx0dG1wID0gb2JqO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcImxhc3RcIjpcblx0XHRcdFx0XHRcdGlmKCFvYmouY2hpbGRyZW4oXCJ1bFwiKS5sZW5ndGgpIHsgb2JqLmFwcGVuZChcIjx1bCAvPlwiKTsgfVxuXHRcdFx0XHRcdFx0b2JqLmNoaWxkcmVuKFwidWxcIikuYXBwZW5kKGQpO1xuXHRcdFx0XHRcdFx0dG1wID0gb2JqO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGlmKCFvYmouY2hpbGRyZW4oXCJ1bFwiKS5sZW5ndGgpIHsgb2JqLmFwcGVuZChcIjx1bCAvPlwiKTsgfVxuXHRcdFx0XHRcdFx0aWYoIXBvc2l0aW9uKSB7IHBvc2l0aW9uID0gMDsgfVxuXHRcdFx0XHRcdFx0dG1wID0gb2JqLmNoaWxkcmVuKFwidWxcIikuY2hpbGRyZW4oXCJsaVwiKS5lcShwb3NpdGlvbik7XG5cdFx0XHRcdFx0XHRpZih0bXAubGVuZ3RoKSB7IHRtcC5iZWZvcmUoZCk7IH1cblx0XHRcdFx0XHRcdGVsc2UgeyBvYmouY2hpbGRyZW4oXCJ1bFwiKS5hcHBlbmQoZCk7IH1cblx0XHRcdFx0XHRcdHRtcCA9IG9iajtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHRtcCA9PT0gLTEgfHwgdG1wLmdldCgwKSA9PT0gdGhpcy5nZXRfY29udGFpbmVyKCkuZ2V0KDApKSB7IHRtcCA9IC0xOyB9XG5cdFx0XHRcdHRoaXMuY2xlYW5fbm9kZSh0bXApO1xuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogZCwgXCJwYXJlbnRcIiA6IHRtcCB9KTtcblx0XHRcdFx0aWYoY2FsbGJhY2spIHsgY2FsbGJhY2suY2FsbCh0aGlzLCBkKTsgfVxuXHRcdFx0XHRyZXR1cm4gZDtcblx0XHRcdH0sXG5cdFx0XHQvLyBCYXNpYyBvcGVyYXRpb25zOiByZW5hbWUgKGRlYWwgd2l0aCB0ZXh0KVxuXHRcdFx0Z2V0X3RleHRcdDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRpZighb2JqLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0dmFyIHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5jb3JlLmh0bWxfdGl0bGVzO1xuXHRcdFx0XHRvYmogPSBvYmouY2hpbGRyZW4oXCJhOmVxKDApXCIpO1xuXHRcdFx0XHRpZihzKSB7XG5cdFx0XHRcdFx0b2JqID0gb2JqLmNsb25lKCk7XG5cdFx0XHRcdFx0b2JqLmNoaWxkcmVuKFwiSU5TXCIpLnJlbW92ZSgpO1xuXHRcdFx0XHRcdHJldHVybiBvYmouaHRtbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdG9iaiA9IG9iai5jb250ZW50cygpLmZpbHRlcihmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubm9kZVR5cGUgPT0gMzsgfSlbMF07XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiA/IG9iai5ub2RlVmFsdWUgOiAnJztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHNldF90ZXh0XHQ6IGZ1bmN0aW9uIChvYmosIHZhbCkge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRpZighb2JqLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0b2JqID0gb2JqLmNoaWxkcmVuKFwiYTplcSgwKVwiKTtcblx0XHRcdFx0aWYodGhpcy5fZ2V0X3NldHRpbmdzKCkuY29yZS5odG1sX3RpdGxlcykge1xuXHRcdFx0XHRcdHZhciB0bXAgPSBvYmouY2hpbGRyZW4oXCJJTlNcIikuY2xvbmUoKTtcblx0XHRcdFx0XHRvYmouaHRtbCh2YWwpLnByZXBlbmQodG1wKTtcblx0XHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogb2JqLCBcIm5hbWVcIiA6IHZhbCB9KTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRvYmogPSBvYmouY29udGVudHMoKS5maWx0ZXIoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm5vZGVUeXBlID09IDM7IH0pWzBdO1xuXHRcdFx0XHRcdHRoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiBvYmosIFwibmFtZVwiIDogdmFsIH0pO1xuXHRcdFx0XHRcdHJldHVybiAob2JqLm5vZGVWYWx1ZSA9IHZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZW5hbWVfbm9kZSA6IGZ1bmN0aW9uIChvYmosIHZhbCkge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHR0aGlzLl9fcm9sbGJhY2soKTtcblx0XHRcdFx0aWYob2JqICYmIG9iai5sZW5ndGggJiYgdGhpcy5zZXRfdGV4dC5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSkgeyB0aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogb2JqLCBcIm5hbWVcIiA6IHZhbCB9KTsgfVxuXHRcdFx0fSxcblx0XHRcdC8vIEJhc2ljIG9wZXJhdGlvbnM6IGRlbGV0aW5nIG5vZGVzXG5cdFx0XHRkZWxldGVfbm9kZSA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0aWYoIW9iai5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdHRoaXMuX19yb2xsYmFjaygpO1xuXHRcdFx0XHR2YXIgcCA9IHRoaXMuX2dldF9wYXJlbnQob2JqKSwgcHJldiA9ICQoW10pLCB0ID0gdGhpcztcblx0XHRcdFx0b2JqLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHByZXYgPSBwcmV2LmFkZCh0Ll9nZXRfcHJldih0aGlzKSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRvYmogPSBvYmouZGV0YWNoKCk7XG5cdFx0XHRcdGlmKHAgIT09IC0xICYmIHAuZmluZChcIj4gdWwgPiBsaVwiKS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRwLnJlbW92ZUNsYXNzKFwianN0cmVlLW9wZW4ganN0cmVlLWNsb3NlZFwiKS5hZGRDbGFzcyhcImpzdHJlZS1sZWFmXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuY2xlYW5fbm9kZShwKTtcblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHsgXCJvYmpcIiA6IG9iaiwgXCJwcmV2XCIgOiBwcmV2LCBcInBhcmVudFwiIDogcCB9KTtcblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH0sXG5cdFx0XHRwcmVwYXJlX21vdmUgOiBmdW5jdGlvbiAobywgciwgcG9zLCBjYiwgaXNfY2IpIHtcblx0XHRcdFx0dmFyIHAgPSB7fTtcblxuXHRcdFx0XHRwLm90ID0gJC5qc3RyZWUuX3JlZmVyZW5jZShvKSB8fCB0aGlzO1xuXHRcdFx0XHRwLm8gPSBwLm90Ll9nZXRfbm9kZShvKTtcblx0XHRcdFx0cC5yID0gciA9PT0gLSAxID8gLTEgOiB0aGlzLl9nZXRfbm9kZShyKTtcblx0XHRcdFx0cC5wID0gKHR5cGVvZiBwb3MgPT09IFwidW5kZWZpbmVkXCIgfHwgcG9zID09PSBmYWxzZSkgPyBcImxhc3RcIiA6IHBvczsgLy8gVE9ETzogbW92ZSB0byBhIHNldHRpbmdcblx0XHRcdFx0aWYoIWlzX2NiICYmIHByZXBhcmVkX21vdmUubyAmJiBwcmVwYXJlZF9tb3ZlLm9bMF0gPT09IHAub1swXSAmJiBwcmVwYXJlZF9tb3ZlLnJbMF0gPT09IHAuclswXSAmJiBwcmVwYXJlZF9tb3ZlLnAgPT09IHAucCkge1xuXHRcdFx0XHRcdHRoaXMuX19jYWxsYmFjayhwcmVwYXJlZF9tb3ZlKTtcblx0XHRcdFx0XHRpZihjYikgeyBjYi5jYWxsKHRoaXMsIHByZXBhcmVkX21vdmUpOyB9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHAub3QgPSAkLmpzdHJlZS5fcmVmZXJlbmNlKHAubykgfHwgdGhpcztcblx0XHRcdFx0cC5ydCA9ICQuanN0cmVlLl9yZWZlcmVuY2UocC5yKSB8fCB0aGlzOyAvLyByID09PSAtMSA/IHAub3QgOiAkLmpzdHJlZS5fcmVmZXJlbmNlKHAucikgfHwgdGhpc1xuXHRcdFx0XHRpZihwLnIgPT09IC0xIHx8ICFwLnIpIHtcblx0XHRcdFx0XHRwLmNyID0gLTE7XG5cdFx0XHRcdFx0c3dpdGNoKHAucCkge1xuXHRcdFx0XHRcdFx0Y2FzZSBcImZpcnN0XCI6XG5cdFx0XHRcdFx0XHRjYXNlIFwiYmVmb3JlXCI6XG5cdFx0XHRcdFx0XHRjYXNlIFwiaW5zaWRlXCI6XG5cdFx0XHRcdFx0XHRcdHAuY3AgPSAwOyBcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiYWZ0ZXJcIjpcblx0XHRcdFx0XHRcdGNhc2UgXCJsYXN0XCI6XG5cdFx0XHRcdFx0XHRcdHAuY3AgPSBwLnJ0LmdldF9jb250YWluZXIoKS5maW5kKFwiID4gdWwgPiBsaVwiKS5sZW5ndGg7IFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdHAuY3AgPSBwLnA7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZighL14oYmVmb3JlfGFmdGVyKSQvLnRlc3QocC5wKSAmJiAhdGhpcy5faXNfbG9hZGVkKHAucikpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmxvYWRfbm9kZShwLnIsIGZ1bmN0aW9uICgpIHsgdGhpcy5wcmVwYXJlX21vdmUobywgciwgcG9zLCBjYiwgdHJ1ZSk7IH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzd2l0Y2gocC5wKSB7XG5cdFx0XHRcdFx0XHRjYXNlIFwiYmVmb3JlXCI6XG5cdFx0XHRcdFx0XHRcdHAuY3AgPSBwLnIuaW5kZXgoKTtcblx0XHRcdFx0XHRcdFx0cC5jciA9IHAucnQuX2dldF9wYXJlbnQocC5yKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiYWZ0ZXJcIjpcblx0XHRcdFx0XHRcdFx0cC5jcCA9IHAuci5pbmRleCgpICsgMTtcblx0XHRcdFx0XHRcdFx0cC5jciA9IHAucnQuX2dldF9wYXJlbnQocC5yKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIFwiaW5zaWRlXCI6XG5cdFx0XHRcdFx0XHRjYXNlIFwiZmlyc3RcIjpcblx0XHRcdFx0XHRcdFx0cC5jcCA9IDA7XG5cdFx0XHRcdFx0XHRcdHAuY3IgPSBwLnI7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcImxhc3RcIjpcblx0XHRcdFx0XHRcdFx0cC5jcCA9IHAuci5maW5kKFwiID4gdWwgPiBsaVwiKS5sZW5ndGg7IFxuXHRcdFx0XHRcdFx0XHRwLmNyID0gcC5yO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGRlZmF1bHQ6IFxuXHRcdFx0XHRcdFx0XHRwLmNwID0gcC5wO1xuXHRcdFx0XHRcdFx0XHRwLmNyID0gcC5yO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cC5ucCA9IHAuY3IgPT0gLTEgPyBwLnJ0LmdldF9jb250YWluZXIoKSA6IHAuY3I7XG5cdFx0XHRcdHAub3AgPSBwLm90Ll9nZXRfcGFyZW50KHAubyk7XG5cdFx0XHRcdHAuY29wID0gcC5vLmluZGV4KCk7XG5cdFx0XHRcdGlmKHAub3AgPT09IC0xKSB7IHAub3AgPSBwLm90ID8gcC5vdC5nZXRfY29udGFpbmVyKCkgOiB0aGlzLmdldF9jb250YWluZXIoKTsgfVxuXHRcdFx0XHRpZighL14oYmVmb3JlfGFmdGVyKSQvLnRlc3QocC5wKSAmJiBwLm9wICYmIHAubnAgJiYgcC5vcFswXSA9PT0gcC5ucFswXSAmJiBwLm8uaW5kZXgoKSA8IHAuY3ApIHsgcC5jcCsrOyB9XG5cdFx0XHRcdC8vaWYocC5wID09PSBcImJlZm9yZVwiICYmIHAub3AgJiYgcC5ucCAmJiBwLm9wWzBdID09PSBwLm5wWzBdICYmIHAuby5pbmRleCgpIDwgcC5jcCkgeyBwLmNwLS07IH1cblx0XHRcdFx0cC5vciA9IHAubnAuZmluZChcIiA+IHVsID4gbGk6bnRoLWNoaWxkKFwiICsgKHAuY3AgKyAxKSArIFwiKVwiKTtcblx0XHRcdFx0cHJlcGFyZWRfbW92ZSA9IHA7XG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjayhwcmVwYXJlZF9tb3ZlKTtcblx0XHRcdFx0aWYoY2IpIHsgY2IuY2FsbCh0aGlzLCBwcmVwYXJlZF9tb3ZlKTsgfVxuXHRcdFx0fSxcblx0XHRcdGNoZWNrX21vdmUgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBvYmogPSBwcmVwYXJlZF9tb3ZlLCByZXQgPSB0cnVlLCByID0gb2JqLnIgPT09IC0xID8gdGhpcy5nZXRfY29udGFpbmVyKCkgOiBvYmoucjtcblx0XHRcdFx0aWYoIW9iaiB8fCAhb2JqLm8gfHwgb2JqLm9yWzBdID09PSBvYmoub1swXSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0aWYoIW9iai5jeSkge1xuXHRcdFx0XHRcdGlmKG9iai5vcCAmJiBvYmoubnAgJiYgb2JqLm9wWzBdID09PSBvYmoubnBbMF0gJiYgb2JqLmNwIC0gMSA9PT0gb2JqLm8uaW5kZXgoKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0XHRvYmouby5lYWNoKGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdFx0XHRpZihyLnBhcmVudHNVbnRpbChcIi5qc3RyZWVcIiwgXCJsaVwiKS5hbmRTZWxmKCkuaW5kZXgodGhpcykgIT09IC0xKSB7IHJldCA9IGZhbHNlOyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fSxcblx0XHRcdG1vdmVfbm9kZSA6IGZ1bmN0aW9uIChvYmosIHJlZiwgcG9zaXRpb24sIGlzX2NvcHksIGlzX3ByZXBhcmVkLCBza2lwX2NoZWNrKSB7XG5cdFx0XHRcdGlmKCFpc19wcmVwYXJlZCkgeyBcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5wcmVwYXJlX21vdmUob2JqLCByZWYsIHBvc2l0aW9uLCBmdW5jdGlvbiAocCkge1xuXHRcdFx0XHRcdFx0dGhpcy5tb3ZlX25vZGUocCwgZmFsc2UsIGZhbHNlLCBpc19jb3B5LCB0cnVlLCBza2lwX2NoZWNrKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihpc19jb3B5KSB7IFxuXHRcdFx0XHRcdHByZXBhcmVkX21vdmUuY3kgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFza2lwX2NoZWNrICYmICF0aGlzLmNoZWNrX21vdmUoKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdFx0XHR0aGlzLl9fcm9sbGJhY2soKTtcblx0XHRcdFx0dmFyIG8gPSBmYWxzZTtcblx0XHRcdFx0aWYoaXNfY29weSkge1xuXHRcdFx0XHRcdG8gPSBvYmouby5jbG9uZSh0cnVlKTtcblx0XHRcdFx0XHRvLmZpbmQoXCIqW2lkXVwiKS5hbmRTZWxmKCkuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRpZih0aGlzLmlkKSB7IHRoaXMuaWQgPSBcImNvcHlfXCIgKyB0aGlzLmlkOyB9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7IG8gPSBvYmoubzsgfVxuXG5cdFx0XHRcdGlmKG9iai5vci5sZW5ndGgpIHsgb2JqLm9yLmJlZm9yZShvKTsgfVxuXHRcdFx0XHRlbHNlIHsgXG5cdFx0XHRcdFx0aWYoIW9iai5ucC5jaGlsZHJlbihcInVsXCIpLmxlbmd0aCkgeyAkKFwiPHVsIC8+XCIpLmFwcGVuZFRvKG9iai5ucCk7IH1cblx0XHRcdFx0XHRvYmoubnAuY2hpbGRyZW4oXCJ1bDplcSgwKVwiKS5hcHBlbmQobyk7IFxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHsgXG5cdFx0XHRcdFx0b2JqLm90LmNsZWFuX25vZGUob2JqLm9wKTtcblx0XHRcdFx0XHRvYmoucnQuY2xlYW5fbm9kZShvYmoubnApO1xuXHRcdFx0XHRcdGlmKCFvYmoub3AuZmluZChcIj4gdWwgPiBsaVwiKS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdG9iai5vcC5yZW1vdmVDbGFzcyhcImpzdHJlZS1vcGVuIGpzdHJlZS1jbG9zZWRcIikuYWRkQ2xhc3MoXCJqc3RyZWUtbGVhZlwiKS5jaGlsZHJlbihcInVsXCIpLnJlbW92ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAoZSkgeyB9XG5cblx0XHRcdFx0aWYoaXNfY29weSkgeyBcblx0XHRcdFx0XHRwcmVwYXJlZF9tb3ZlLmN5ID0gdHJ1ZTtcblx0XHRcdFx0XHRwcmVwYXJlZF9tb3ZlLm9jID0gbzsgXG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHByZXBhcmVkX21vdmUpO1xuXHRcdFx0XHRyZXR1cm4gcHJlcGFyZWRfbW92ZTtcblx0XHRcdH0sXG5cdFx0XHRfZ2V0X21vdmUgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcmVwYXJlZF9tb3ZlOyB9XG5cdFx0fVxuXHR9KTtcbn0pKGpRdWVyeSk7XG4vLyovXG5cbi8qIFxuICoganNUcmVlIHVpIHBsdWdpblxuICogVGhpcyBwbHVnaW5zIGhhbmRsZXMgc2VsZWN0aW5nL2Rlc2VsZWN0aW5nL2hvdmVyaW5nL2RlaG92ZXJpbmcgbm9kZXNcbiAqL1xuKGZ1bmN0aW9uICgkKSB7XG5cdHZhciBzY3JvbGxiYXJfd2lkdGgsIGUxLCBlMjtcblx0JChmdW5jdGlvbigpIHtcblx0XHRpZiAoL21zaWUvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKSkge1xuXHRcdFx0ZTEgPSAkKCc8dGV4dGFyZWEgY29scz1cIjEwXCIgcm93cz1cIjJcIj48L3RleHRhcmVhPicpLmNzcyh7IHBvc2l0aW9uOiAnYWJzb2x1dGUnLCB0b3A6IC0xMDAwLCBsZWZ0OiAwIH0pLmFwcGVuZFRvKCdib2R5Jyk7XG5cdFx0XHRlMiA9ICQoJzx0ZXh0YXJlYSBjb2xzPVwiMTBcIiByb3dzPVwiMlwiIHN0eWxlPVwib3ZlcmZsb3c6IGhpZGRlbjtcIj48L3RleHRhcmVhPicpLmNzcyh7IHBvc2l0aW9uOiAnYWJzb2x1dGUnLCB0b3A6IC0xMDAwLCBsZWZ0OiAwIH0pLmFwcGVuZFRvKCdib2R5Jyk7XG5cdFx0XHRzY3JvbGxiYXJfd2lkdGggPSBlMS53aWR0aCgpIC0gZTIud2lkdGgoKTtcblx0XHRcdGUxLmFkZChlMikucmVtb3ZlKCk7XG5cdFx0fSBcblx0XHRlbHNlIHtcblx0XHRcdGUxID0gJCgnPGRpdiAvPicpLmNzcyh7IHdpZHRoOiAxMDAsIGhlaWdodDogMTAwLCBvdmVyZmxvdzogJ2F1dG8nLCBwb3NpdGlvbjogJ2Fic29sdXRlJywgdG9wOiAtMTAwMCwgbGVmdDogMCB9KVxuXHRcdFx0XHRcdC5wcmVwZW5kVG8oJ2JvZHknKS5hcHBlbmQoJzxkaXYgLz4nKS5maW5kKCdkaXYnKS5jc3MoeyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6IDIwMCB9KTtcblx0XHRcdHNjcm9sbGJhcl93aWR0aCA9IDEwMCAtIGUxLndpZHRoKCk7XG5cdFx0XHRlMS5wYXJlbnQoKS5yZW1vdmUoKTtcblx0XHR9XG5cdH0pO1xuXHQkLmpzdHJlZS5wbHVnaW4oXCJ1aVwiLCB7XG5cdFx0X19pbml0IDogZnVuY3Rpb24gKCkgeyBcblx0XHRcdHRoaXMuZGF0YS51aS5zZWxlY3RlZCA9ICQoKTsgXG5cdFx0XHR0aGlzLmRhdGEudWkubGFzdF9zZWxlY3RlZCA9IGZhbHNlOyBcblx0XHRcdHRoaXMuZGF0YS51aS5ob3ZlcmVkID0gbnVsbDtcblx0XHRcdHRoaXMuZGF0YS51aS50b19zZWxlY3QgPSB0aGlzLmdldF9zZXR0aW5ncygpLnVpLmluaXRpYWxseV9zZWxlY3Q7XG5cblx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpXG5cdFx0XHRcdC5kZWxlZ2F0ZShcImFcIiwgXCJjbGljay5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0LmJsdXIoKTtcblx0XHRcdFx0XHRcdGlmKCEkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmhhc0NsYXNzKFwianN0cmVlLWxvYWRpbmdcIikpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZWxlY3Rfbm9kZShldmVudC5jdXJyZW50VGFyZ2V0LCB0cnVlLCBldmVudCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5kZWxlZ2F0ZShcImFcIiwgXCJtb3VzZWVudGVyLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0XHRcdFx0aWYoISQoZXZlbnQuY3VycmVudFRhcmdldCkuaGFzQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmhvdmVyX25vZGUoZXZlbnQudGFyZ2V0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmRlbGVnYXRlKFwiYVwiLCBcIm1vdXNlbGVhdmUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0XHRcdFx0XHRpZighJChldmVudC5jdXJyZW50VGFyZ2V0KS5oYXNDbGFzcyhcImpzdHJlZS1sb2FkaW5nXCIpKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZGVob3Zlcl9ub2RlKGV2ZW50LnRhcmdldCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwicmVvcGVuLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdFx0XHR0aGlzLnJlc2VsZWN0KCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwiZ2V0X3JvbGxiYWNrLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdFx0XHR0aGlzLmRlaG92ZXJfbm9kZSgpO1xuXHRcdFx0XHRcdFx0dGhpcy5zYXZlX3NlbGVjdGVkKCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwic2V0X3JvbGxiYWNrLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdFx0XHR0aGlzLnJlc2VsZWN0KCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwiY2xvc2Vfbm9kZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHsgXG5cdFx0XHRcdFx0XHR2YXIgcyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLnVpLFxuXHRcdFx0XHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShkYXRhLnJzbHQub2JqKSxcblx0XHRcdFx0XHRcdFx0Y2xrID0gKG9iaiAmJiBvYmoubGVuZ3RoKSA/IG9iai5jaGlsZHJlbihcInVsXCIpLmZpbmQoXCJhLmpzdHJlZS1jbGlja2VkXCIpIDogJCgpLFxuXHRcdFx0XHRcdFx0XHRfdGhpcyA9IHRoaXM7XG5cdFx0XHRcdFx0XHRpZihzLnNlbGVjdGVkX3BhcmVudF9jbG9zZSA9PT0gZmFsc2UgfHwgIWNsay5sZW5ndGgpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdFx0XHRjbGsuZWFjaChmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHRcdFx0XHRfdGhpcy5kZXNlbGVjdF9ub2RlKHRoaXMpO1xuXHRcdFx0XHRcdFx0XHRpZihzLnNlbGVjdGVkX3BhcmVudF9jbG9zZSA9PT0gXCJzZWxlY3RfcGFyZW50XCIpIHsgX3RoaXMuc2VsZWN0X25vZGUob2JqKTsgfVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwiZGVsZXRlX25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7IFxuXHRcdFx0XHRcdFx0dmFyIHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS51aS5zZWxlY3RfcHJldl9vbl9kZWxldGUsXG5cdFx0XHRcdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKGRhdGEucnNsdC5vYmopLFxuXHRcdFx0XHRcdFx0XHRjbGsgPSAob2JqICYmIG9iai5sZW5ndGgpID8gb2JqLmZpbmQoXCJhLmpzdHJlZS1jbGlja2VkXCIpIDogW10sXG5cdFx0XHRcdFx0XHRcdF90aGlzID0gdGhpcztcblx0XHRcdFx0XHRcdGNsay5lYWNoKGZ1bmN0aW9uICgpIHsgX3RoaXMuZGVzZWxlY3Rfbm9kZSh0aGlzKTsgfSk7XG5cdFx0XHRcdFx0XHRpZihzICYmIGNsay5sZW5ndGgpIHsgXG5cdFx0XHRcdFx0XHRcdGRhdGEucnNsdC5wcmV2LmVhY2goZnVuY3Rpb24gKCkgeyBcblx0XHRcdFx0XHRcdFx0XHRpZih0aGlzLnBhcmVudE5vZGUpIHsgX3RoaXMuc2VsZWN0X25vZGUodGhpcyk7IHJldHVybiBmYWxzZTsgLyogaWYgcmV0dXJuIGZhbHNlIGlzIHJlbW92ZWQgYWxsIHByZXYgbm9kZXMgd2lsbCBiZSBzZWxlY3RlZCAqL31cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwibW92ZV9ub2RlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChldmVudCwgZGF0YSkgeyBcblx0XHRcdFx0XHRcdGlmKGRhdGEucnNsdC5jeSkgeyBcblx0XHRcdFx0XHRcdFx0ZGF0YS5yc2x0Lm9jLmZpbmQoXCJhLmpzdHJlZS1jbGlja2VkXCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLWNsaWNrZWRcIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdH0sXG5cdFx0ZGVmYXVsdHMgOiB7XG5cdFx0XHRzZWxlY3RfbGltaXQgOiAtMSwgLy8gMCwgMSwgMiAuLi4gb3IgLTEgZm9yIHVubGltaXRlZFxuXHRcdFx0c2VsZWN0X211bHRpcGxlX21vZGlmaWVyIDogXCJjdHJsXCIsIC8vIG9uLCBvciBjdHJsLCBzaGlmdCwgYWx0XG5cdFx0XHRzZWxlY3RfcmFuZ2VfbW9kaWZpZXIgOiBcInNoaWZ0XCIsXG5cdFx0XHRzZWxlY3RlZF9wYXJlbnRfY2xvc2UgOiBcInNlbGVjdF9wYXJlbnRcIiwgLy8gZmFsc2UsIFwiZGVzZWxlY3RcIiwgXCJzZWxlY3RfcGFyZW50XCJcblx0XHRcdHNlbGVjdGVkX3BhcmVudF9vcGVuIDogdHJ1ZSxcblx0XHRcdHNlbGVjdF9wcmV2X29uX2RlbGV0ZSA6IHRydWUsXG5cdFx0XHRkaXNhYmxlX3NlbGVjdGluZ19jaGlsZHJlbiA6IGZhbHNlLFxuXHRcdFx0aW5pdGlhbGx5X3NlbGVjdCA6IFtdXG5cdFx0fSxcblx0XHRfZm4gOiB7IFxuXHRcdFx0X2dldF9ub2RlIDogZnVuY3Rpb24gKG9iaiwgYWxsb3dfbXVsdGlwbGUpIHtcblx0XHRcdFx0aWYodHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvYmogPT09IG51bGwpIHsgcmV0dXJuIGFsbG93X211bHRpcGxlID8gdGhpcy5kYXRhLnVpLnNlbGVjdGVkIDogdGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWQ7IH1cblx0XHRcdFx0dmFyICRvYmogPSAkKG9iaiwgdGhpcy5nZXRfY29udGFpbmVyKCkpOyBcblx0XHRcdFx0aWYoJG9iai5pcyhcIi5qc3RyZWVcIikgfHwgb2JqID09IC0xKSB7IHJldHVybiAtMTsgfSBcblx0XHRcdFx0JG9iaiA9ICRvYmouY2xvc2VzdChcImxpXCIsIHRoaXMuZ2V0X2NvbnRhaW5lcigpKTsgXG5cdFx0XHRcdHJldHVybiAkb2JqLmxlbmd0aCA/ICRvYmogOiBmYWxzZTsgXG5cdFx0XHR9LFxuXHRcdFx0X3VpX25vdGlmeSA6IGZ1bmN0aW9uIChuLCBkYXRhKSB7XG5cdFx0XHRcdGlmKGRhdGEuc2VsZWN0ZWQpIHtcblx0XHRcdFx0XHR0aGlzLnNlbGVjdF9ub2RlKG4sIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHNhdmVfc2VsZWN0ZWQgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0XHRcdHRoaXMuZGF0YS51aS50b19zZWxlY3QgPSBbXTtcblx0XHRcdFx0dGhpcy5kYXRhLnVpLnNlbGVjdGVkLmVhY2goZnVuY3Rpb24gKCkgeyBpZih0aGlzLmlkKSB7IF90aGlzLmRhdGEudWkudG9fc2VsZWN0LnB1c2goXCIjXCIgKyB0aGlzLmlkLnRvU3RyaW5nKCkucmVwbGFjZSgvXiMvLFwiXCIpLnJlcGxhY2UoL1xcXFxcXC8vZyxcIi9cIikucmVwbGFjZSgvXFwvL2csXCJcXFxcXFwvXCIpLnJlcGxhY2UoL1xcXFxcXC4vZyxcIi5cIikucmVwbGFjZSgvXFwuL2csXCJcXFxcLlwiKS5yZXBsYWNlKC9cXDovZyxcIlxcXFw6XCIpKTsgfSB9KTtcblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHRoaXMuZGF0YS51aS50b19zZWxlY3QpO1xuXHRcdFx0fSxcblx0XHRcdHJlc2VsZWN0IDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgX3RoaXMgPSB0aGlzLFxuXHRcdFx0XHRcdHMgPSB0aGlzLmRhdGEudWkudG9fc2VsZWN0O1xuXHRcdFx0XHRzID0gJC5tYXAoJC5tYWtlQXJyYXkocyksIGZ1bmN0aW9uIChuKSB7IHJldHVybiBcIiNcIiArIG4udG9TdHJpbmcoKS5yZXBsYWNlKC9eIy8sXCJcIikucmVwbGFjZSgvXFxcXFxcLy9nLFwiL1wiKS5yZXBsYWNlKC9cXC8vZyxcIlxcXFxcXC9cIikucmVwbGFjZSgvXFxcXFxcLi9nLFwiLlwiKS5yZXBsYWNlKC9cXC4vZyxcIlxcXFwuXCIpLnJlcGxhY2UoL1xcOi9nLFwiXFxcXDpcIik7IH0pO1xuXHRcdFx0XHQvLyB0aGlzLmRlc2VsZWN0X2FsbCgpOyBXSFkgZGVzZWxlY3QsIGJyZWFrcyBwbHVnaW4gc3RhdGUgbm90aWZpZXI/XG5cdFx0XHRcdCQuZWFjaChzLCBmdW5jdGlvbiAoaSwgdmFsKSB7IGlmKHZhbCAmJiB2YWwgIT09IFwiI1wiKSB7IF90aGlzLnNlbGVjdF9ub2RlKHZhbCk7IH0gfSk7XG5cdFx0XHRcdHRoaXMuZGF0YS51aS5zZWxlY3RlZCA9IHRoaXMuZGF0YS51aS5zZWxlY3RlZC5maWx0ZXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXJlbnROb2RlOyB9KTtcblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKCk7XG5cdFx0XHR9LFxuXHRcdFx0cmVmcmVzaCA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0dGhpcy5zYXZlX3NlbGVjdGVkKCk7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9fY2FsbF9vbGQoKTtcblx0XHRcdH0sXG5cdFx0XHRob3Zlcl9ub2RlIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRpZighb2JqLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0Ly9pZih0aGlzLmRhdGEudWkuaG92ZXJlZCAmJiBvYmouZ2V0KDApID09PSB0aGlzLmRhdGEudWkuaG92ZXJlZC5nZXQoMCkpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdGlmKCFvYmouaGFzQ2xhc3MoXCJqc3RyZWUtaG92ZXJlZFwiKSkgeyB0aGlzLmRlaG92ZXJfbm9kZSgpOyB9XG5cdFx0XHRcdHRoaXMuZGF0YS51aS5ob3ZlcmVkID0gb2JqLmNoaWxkcmVuKFwiYVwiKS5hZGRDbGFzcyhcImpzdHJlZS1ob3ZlcmVkXCIpLnBhcmVudCgpO1xuXHRcdFx0XHR0aGlzLl9maXhfc2Nyb2xsKG9iaik7XG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiBvYmogfSk7XG5cdFx0XHR9LFxuXHRcdFx0ZGVob3Zlcl9ub2RlIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgb2JqID0gdGhpcy5kYXRhLnVpLmhvdmVyZWQsIHA7XG5cdFx0XHRcdGlmKCFvYmogfHwgIW9iai5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdHAgPSBvYmouY2hpbGRyZW4oXCJhXCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLWhvdmVyZWRcIikucGFyZW50KCk7XG5cdFx0XHRcdGlmKHRoaXMuZGF0YS51aS5ob3ZlcmVkWzBdID09PSBwWzBdKSB7IHRoaXMuZGF0YS51aS5ob3ZlcmVkID0gbnVsbDsgfVxuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogb2JqIH0pO1xuXHRcdFx0fSxcblx0XHRcdHNlbGVjdF9ub2RlIDogZnVuY3Rpb24gKG9iaiwgY2hlY2ssIGUpIHtcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0aWYob2JqID09IC0xIHx8ICFvYmogfHwgIW9iai5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdHZhciBzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkudWksXG5cdFx0XHRcdFx0aXNfbXVsdGlwbGUgPSAocy5zZWxlY3RfbXVsdGlwbGVfbW9kaWZpZXIgPT0gXCJvblwiIHx8IChzLnNlbGVjdF9tdWx0aXBsZV9tb2RpZmllciAhPT0gZmFsc2UgJiYgZSAmJiBlW3Muc2VsZWN0X211bHRpcGxlX21vZGlmaWVyICsgXCJLZXlcIl0pKSxcblx0XHRcdFx0XHRpc19yYW5nZSA9IChzLnNlbGVjdF9yYW5nZV9tb2RpZmllciAhPT0gZmFsc2UgJiYgZSAmJiBlW3Muc2VsZWN0X3JhbmdlX21vZGlmaWVyICsgXCJLZXlcIl0gJiYgdGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWQgJiYgdGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWRbMF0gIT09IG9ialswXSAmJiB0aGlzLmRhdGEudWkubGFzdF9zZWxlY3RlZC5wYXJlbnQoKVswXSA9PT0gb2JqLnBhcmVudCgpWzBdKSxcblx0XHRcdFx0XHRpc19zZWxlY3RlZCA9IHRoaXMuaXNfc2VsZWN0ZWQob2JqKSxcblx0XHRcdFx0XHRwcm9jZWVkID0gdHJ1ZSxcblx0XHRcdFx0XHR0ID0gdGhpcztcblx0XHRcdFx0aWYoY2hlY2spIHtcblx0XHRcdFx0XHRpZihzLmRpc2FibGVfc2VsZWN0aW5nX2NoaWxkcmVuICYmIGlzX211bHRpcGxlICYmIFxuXHRcdFx0XHRcdFx0KFxuXHRcdFx0XHRcdFx0XHQob2JqLnBhcmVudHNVbnRpbChcIi5qc3RyZWVcIixcImxpXCIpLmNoaWxkcmVuKFwiYS5qc3RyZWUtY2xpY2tlZFwiKS5sZW5ndGgpIHx8XG5cdFx0XHRcdFx0XHRcdChvYmouY2hpbGRyZW4oXCJ1bFwiKS5maW5kKFwiYS5qc3RyZWUtY2xpY2tlZDplcSgwKVwiKS5sZW5ndGgpXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHByb2NlZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRzd2l0Y2goITApIHtcblx0XHRcdFx0XHRcdGNhc2UgKGlzX3JhbmdlKTpcblx0XHRcdFx0XHRcdFx0dGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWQuYWRkQ2xhc3MoXCJqc3RyZWUtbGFzdC1zZWxlY3RlZFwiKTtcblx0XHRcdFx0XHRcdFx0b2JqID0gb2JqWyBvYmouaW5kZXgoKSA8IHRoaXMuZGF0YS51aS5sYXN0X3NlbGVjdGVkLmluZGV4KCkgPyBcIm5leHRVbnRpbFwiIDogXCJwcmV2VW50aWxcIiBdKFwiLmpzdHJlZS1sYXN0LXNlbGVjdGVkXCIpLmFuZFNlbGYoKTtcblx0XHRcdFx0XHRcdFx0aWYocy5zZWxlY3RfbGltaXQgPT0gLTEgfHwgb2JqLmxlbmd0aCA8IHMuc2VsZWN0X2xpbWl0KSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWQucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbGFzdC1zZWxlY3RlZFwiKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmRhdGEudWkuc2VsZWN0ZWQuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZih0aGlzICE9PSB0LmRhdGEudWkubGFzdF9zZWxlY3RlZFswXSkgeyB0LmRlc2VsZWN0X25vZGUodGhpcyk7IH1cblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRpc19zZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdHByb2NlZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHByb2NlZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgKGlzX3NlbGVjdGVkICYmICFpc19tdWx0aXBsZSk6IFxuXHRcdFx0XHRcdFx0XHR0aGlzLmRlc2VsZWN0X2FsbCgpO1xuXHRcdFx0XHRcdFx0XHRpc19zZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRwcm9jZWVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICghaXNfc2VsZWN0ZWQgJiYgIWlzX211bHRpcGxlKTogXG5cdFx0XHRcdFx0XHRcdGlmKHMuc2VsZWN0X2xpbWl0ID09IC0xIHx8IHMuc2VsZWN0X2xpbWl0ID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZGVzZWxlY3RfYWxsKCk7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIChpc19zZWxlY3RlZCAmJiBpc19tdWx0aXBsZSk6IFxuXHRcdFx0XHRcdFx0XHR0aGlzLmRlc2VsZWN0X25vZGUob2JqKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICghaXNfc2VsZWN0ZWQgJiYgaXNfbXVsdGlwbGUpOiBcblx0XHRcdFx0XHRcdFx0aWYocy5zZWxlY3RfbGltaXQgPT0gLTEgfHwgdGhpcy5kYXRhLnVpLnNlbGVjdGVkLmxlbmd0aCArIDEgPD0gcy5zZWxlY3RfbGltaXQpIHsgXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHByb2NlZWQgJiYgIWlzX3NlbGVjdGVkKSB7XG5cdFx0XHRcdFx0aWYoIWlzX3JhbmdlKSB7IHRoaXMuZGF0YS51aS5sYXN0X3NlbGVjdGVkID0gb2JqOyB9XG5cdFx0XHRcdFx0b2JqLmNoaWxkcmVuKFwiYVwiKS5hZGRDbGFzcyhcImpzdHJlZS1jbGlja2VkXCIpO1xuXHRcdFx0XHRcdGlmKHMuc2VsZWN0ZWRfcGFyZW50X29wZW4pIHtcblx0XHRcdFx0XHRcdG9iai5wYXJlbnRzKFwiLmpzdHJlZS1jbG9zZWRcIikuZWFjaChmdW5jdGlvbiAoKSB7IHQub3Blbl9ub2RlKHRoaXMsIGZhbHNlLCB0cnVlKTsgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuZGF0YS51aS5zZWxlY3RlZCA9IHRoaXMuZGF0YS51aS5zZWxlY3RlZC5hZGQob2JqKTtcblx0XHRcdFx0XHR0aGlzLl9maXhfc2Nyb2xsKG9iai5lcSgwKSk7XG5cdFx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHsgXCJvYmpcIiA6IG9iaiwgXCJlXCIgOiBlIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X2ZpeF9zY3JvbGwgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdHZhciBjID0gdGhpcy5nZXRfY29udGFpbmVyKClbMF0sIHQ7XG5cdFx0XHRcdGlmKGMuc2Nyb2xsSGVpZ2h0ID4gYy5vZmZzZXRIZWlnaHQpIHtcblx0XHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRcdGlmKCFvYmogfHwgb2JqID09PSAtMSB8fCAhb2JqLmxlbmd0aCB8fCAhb2JqLmlzKFwiOnZpc2libGVcIikpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdFx0dCA9IG9iai5vZmZzZXQoKS50b3AgLSB0aGlzLmdldF9jb250YWluZXIoKS5vZmZzZXQoKS50b3A7XG5cdFx0XHRcdFx0aWYodCA8IDApIHsgXG5cdFx0XHRcdFx0XHRjLnNjcm9sbFRvcCA9IGMuc2Nyb2xsVG9wICsgdCAtIDE7IFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZih0ICsgdGhpcy5kYXRhLmNvcmUubGlfaGVpZ2h0ICsgKGMuc2Nyb2xsV2lkdGggPiBjLm9mZnNldFdpZHRoID8gc2Nyb2xsYmFyX3dpZHRoIDogMCkgPiBjLm9mZnNldEhlaWdodCkgeyBcblx0XHRcdFx0XHRcdGMuc2Nyb2xsVG9wID0gYy5zY3JvbGxUb3AgKyAodCAtIGMub2Zmc2V0SGVpZ2h0ICsgdGhpcy5kYXRhLmNvcmUubGlfaGVpZ2h0ICsgMSArIChjLnNjcm9sbFdpZHRoID4gYy5vZmZzZXRXaWR0aCA/IHNjcm9sbGJhcl93aWR0aCA6IDApKTsgXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVzZWxlY3Rfbm9kZSA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0aWYoIW9iai5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdGlmKHRoaXMuaXNfc2VsZWN0ZWQob2JqKSkge1xuXHRcdFx0XHRcdG9iai5jaGlsZHJlbihcImFcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtY2xpY2tlZFwiKTtcblx0XHRcdFx0XHR0aGlzLmRhdGEudWkuc2VsZWN0ZWQgPSB0aGlzLmRhdGEudWkuc2VsZWN0ZWQubm90KG9iaik7XG5cdFx0XHRcdFx0aWYodGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWQuZ2V0KDApID09PSBvYmouZ2V0KDApKSB7IHRoaXMuZGF0YS51aS5sYXN0X3NlbGVjdGVkID0gdGhpcy5kYXRhLnVpLnNlbGVjdGVkLmVxKDApOyB9XG5cdFx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHsgXCJvYmpcIiA6IG9iaiB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHRvZ2dsZV9zZWxlY3QgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdGlmKCFvYmoubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRpZih0aGlzLmlzX3NlbGVjdGVkKG9iaikpIHsgdGhpcy5kZXNlbGVjdF9ub2RlKG9iaik7IH1cblx0XHRcdFx0ZWxzZSB7IHRoaXMuc2VsZWN0X25vZGUob2JqKTsgfVxuXHRcdFx0fSxcblx0XHRcdGlzX3NlbGVjdGVkIDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdGhpcy5kYXRhLnVpLnNlbGVjdGVkLmluZGV4KHRoaXMuX2dldF9ub2RlKG9iaikpID49IDA7IH0sXG5cdFx0XHRnZXRfc2VsZWN0ZWQgOiBmdW5jdGlvbiAoY29udGV4dCkgeyBcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQgPyAkKGNvbnRleHQpLmZpbmQoXCJhLmpzdHJlZS1jbGlja2VkXCIpLnBhcmVudCgpIDogdGhpcy5kYXRhLnVpLnNlbGVjdGVkOyBcblx0XHRcdH0sXG5cdFx0XHRkZXNlbGVjdF9hbGwgOiBmdW5jdGlvbiAoY29udGV4dCkge1xuXHRcdFx0XHR2YXIgcmV0ID0gY29udGV4dCA/ICQoY29udGV4dCkuZmluZChcImEuanN0cmVlLWNsaWNrZWRcIikucGFyZW50KCkgOiB0aGlzLmdldF9jb250YWluZXIoKS5maW5kKFwiYS5qc3RyZWUtY2xpY2tlZFwiKS5wYXJlbnQoKTtcblx0XHRcdFx0cmV0LmNoaWxkcmVuKFwiYS5qc3RyZWUtY2xpY2tlZFwiKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1jbGlja2VkXCIpO1xuXHRcdFx0XHR0aGlzLmRhdGEudWkuc2VsZWN0ZWQgPSAkKFtdKTtcblx0XHRcdFx0dGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHsgXCJvYmpcIiA6IHJldCB9KTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXHQvLyBpbmNsdWRlIHRoZSBzZWxlY3Rpb24gcGx1Z2luIGJ5IGRlZmF1bHRcblx0JC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFwidWlcIik7XG59KShqUXVlcnkpO1xuLy8qL1xuXG4vKiBcbiAqIGpzVHJlZSBDUlJNIHBsdWdpblxuICogSGFuZGxlcyBjcmVhdGluZy9yZW5hbWluZy9yZW1vdmluZy9tb3Zpbmcgbm9kZXMgYnkgdXNlciBpbnRlcmFjdGlvbi5cbiAqL1xuKGZ1bmN0aW9uICgkKSB7XG5cdCQuanN0cmVlLnBsdWdpbihcImNycm1cIiwgeyBcblx0XHRfX2luaXQgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmdldF9jb250YWluZXIoKVxuXHRcdFx0XHQuYmluZChcIm1vdmVfbm9kZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdGlmKHRoaXMuX2dldF9zZXR0aW5ncygpLmNycm0ubW92ZS5vcGVuX29ubW92ZSkge1xuXHRcdFx0XHRcdFx0dmFyIHQgPSB0aGlzO1xuXHRcdFx0XHRcdFx0ZGF0YS5yc2x0Lm5wLnBhcmVudHNVbnRpbChcIi5qc3RyZWVcIikuYW5kU2VsZigpLmZpbHRlcihcIi5qc3RyZWUtY2xvc2VkXCIpLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHR0Lm9wZW5fbm9kZSh0aGlzLCBmYWxzZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIHRoaXMpKTtcblx0XHR9LFxuXHRcdGRlZmF1bHRzIDoge1xuXHRcdFx0aW5wdXRfd2lkdGhfbGltaXQgOiAyMDAsXG5cdFx0XHRtb3ZlIDoge1xuXHRcdFx0XHRhbHdheXNfY29weVx0XHRcdDogZmFsc2UsIC8vIGZhbHNlLCB0cnVlIG9yIFwibXVsdGl0cmVlXCJcblx0XHRcdFx0b3Blbl9vbm1vdmVcdFx0XHQ6IHRydWUsXG5cdFx0XHRcdGRlZmF1bHRfcG9zaXRpb25cdDogXCJsYXN0XCIsXG5cdFx0XHRcdGNoZWNrX21vdmVcdFx0XHQ6IGZ1bmN0aW9uIChtKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRfZm4gOiB7XG5cdFx0XHRfc2hvd19pbnB1dCA6IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdHZhciBydGwgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5jb3JlLnJ0bCxcblx0XHRcdFx0XHR3ID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkuY3JybS5pbnB1dF93aWR0aF9saW1pdCxcblx0XHRcdFx0XHR3MSA9IG9iai5jaGlsZHJlbihcImluc1wiKS53aWR0aCgpLFxuXHRcdFx0XHRcdHcyID0gb2JqLmZpbmQoXCI+IGE6dmlzaWJsZSA+IGluc1wiKS53aWR0aCgpICogb2JqLmZpbmQoXCI+IGE6dmlzaWJsZSA+IGluc1wiKS5sZW5ndGgsXG5cdFx0XHRcdFx0dCA9IHRoaXMuZ2V0X3RleHQob2JqKSxcblx0XHRcdFx0XHRoMSA9ICQoXCI8ZGl2IC8+XCIsIHsgY3NzIDogeyBcInBvc2l0aW9uXCIgOiBcImFic29sdXRlXCIsIFwidG9wXCIgOiBcIi0yMDBweFwiLCBcImxlZnRcIiA6IChydGwgPyBcIjBweFwiIDogXCItMTAwMHB4XCIpLCBcInZpc2liaWxpdHlcIiA6IFwiaGlkZGVuXCIgfSB9KS5hcHBlbmRUbyhcImJvZHlcIiksXG5cdFx0XHRcdFx0aDIgPSBvYmouY3NzKFwicG9zaXRpb25cIixcInJlbGF0aXZlXCIpLmFwcGVuZChcblx0XHRcdFx0XHQkKFwiPGlucHV0IC8+XCIsIHsgXG5cdFx0XHRcdFx0XHRcInZhbHVlXCIgOiB0LFxuXHRcdFx0XHRcdFx0XCJjbGFzc1wiIDogXCJqc3RyZWUtcmVuYW1lLWlucHV0XCIsXG5cdFx0XHRcdFx0XHQvLyBcInNpemVcIiA6IHQubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XCJjc3NcIiA6IHtcblx0XHRcdFx0XHRcdFx0XCJwYWRkaW5nXCIgOiBcIjBcIixcblx0XHRcdFx0XHRcdFx0XCJib3JkZXJcIiA6IFwiMXB4IHNvbGlkIHNpbHZlclwiLFxuXHRcdFx0XHRcdFx0XHRcInBvc2l0aW9uXCIgOiBcImFic29sdXRlXCIsXG5cdFx0XHRcdFx0XHRcdFwibGVmdFwiICA6IChydGwgPyBcImF1dG9cIiA6ICh3MSArIHcyICsgNCkgKyBcInB4XCIpLFxuXHRcdFx0XHRcdFx0XHRcInJpZ2h0XCIgOiAocnRsID8gKHcxICsgdzIgKyA0KSArIFwicHhcIiA6IFwiYXV0b1wiKSxcblx0XHRcdFx0XHRcdFx0XCJ0b3BcIiA6IFwiMHB4XCIsXG5cdFx0XHRcdFx0XHRcdFwiaGVpZ2h0XCIgOiAodGhpcy5kYXRhLmNvcmUubGlfaGVpZ2h0IC0gMikgKyBcInB4XCIsXG5cdFx0XHRcdFx0XHRcdFwibGluZUhlaWdodFwiIDogKHRoaXMuZGF0YS5jb3JlLmxpX2hlaWdodCAtIDIpICsgXCJweFwiLFxuXHRcdFx0XHRcdFx0XHRcIndpZHRoXCIgOiBcIjE1MHB4XCIgLy8gd2lsbCBiZSBzZXQgYSBiaXQgZnVydGhlciBkb3duXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XCJibHVyXCIgOiAkLnByb3h5KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGkgPSBvYmouY2hpbGRyZW4oXCIuanN0cmVlLXJlbmFtZS1pbnB1dFwiKSxcblx0XHRcdFx0XHRcdFx0XHR2ID0gaS52YWwoKTtcblx0XHRcdFx0XHRcdFx0aWYodiA9PT0gXCJcIikgeyB2ID0gdDsgfVxuXHRcdFx0XHRcdFx0XHRoMS5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0aS5yZW1vdmUoKTsgLy8gcm9sbGJhY2sgcHVycG9zZXNcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRfdGV4dChvYmosdCk7IC8vIHJvbGxiYWNrIHB1cnBvc2VzXG5cdFx0XHRcdFx0XHRcdHRoaXMucmVuYW1lX25vZGUob2JqLCB2KTtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBvYmosIHYsIHQpO1xuXHRcdFx0XHRcdFx0XHRvYmouY3NzKFwicG9zaXRpb25cIixcIlwiKTtcblx0XHRcdFx0XHRcdH0sIHRoaXMpLFxuXHRcdFx0XHRcdFx0XCJrZXl1cFwiIDogZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0XHRcdFx0XHRcdHZhciBrZXkgPSBldmVudC5rZXlDb2RlIHx8IGV2ZW50LndoaWNoO1xuXHRcdFx0XHRcdFx0XHRpZihrZXkgPT0gMjcpIHsgdGhpcy52YWx1ZSA9IHQ7IHRoaXMuYmx1cigpOyByZXR1cm47IH1cblx0XHRcdFx0XHRcdFx0ZWxzZSBpZihrZXkgPT0gMTMpIHsgdGhpcy5ibHVyKCk7IHJldHVybjsgfVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRoMi53aWR0aChNYXRoLm1pbihoMS50ZXh0KFwicFdcIiArIHRoaXMudmFsdWUpLndpZHRoKCksdykpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XCJrZXlwcmVzc1wiIDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGtleSA9IGV2ZW50LmtleUNvZGUgfHwgZXZlbnQud2hpY2g7XG5cdFx0XHRcdFx0XHRcdGlmKGtleSA9PSAxMykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHQpLmNoaWxkcmVuKFwiLmpzdHJlZS1yZW5hbWUtaW5wdXRcIik7IFxuXHRcdFx0XHR0aGlzLnNldF90ZXh0KG9iaiwgXCJcIik7XG5cdFx0XHRcdGgxLmNzcyh7XG5cdFx0XHRcdFx0XHRmb250RmFtaWx5XHRcdDogaDIuY3NzKCdmb250RmFtaWx5JylcdFx0fHwgJycsXG5cdFx0XHRcdFx0XHRmb250U2l6ZVx0XHQ6IGgyLmNzcygnZm9udFNpemUnKVx0XHR8fCAnJyxcblx0XHRcdFx0XHRcdGZvbnRXZWlnaHRcdFx0OiBoMi5jc3MoJ2ZvbnRXZWlnaHQnKVx0XHR8fCAnJyxcblx0XHRcdFx0XHRcdGZvbnRTdHlsZVx0XHQ6IGgyLmNzcygnZm9udFN0eWxlJylcdFx0fHwgJycsXG5cdFx0XHRcdFx0XHRmb250U3RyZXRjaFx0XHQ6IGgyLmNzcygnZm9udFN0cmV0Y2gnKVx0XHR8fCAnJyxcblx0XHRcdFx0XHRcdGZvbnRWYXJpYW50XHRcdDogaDIuY3NzKCdmb250VmFyaWFudCcpXHRcdHx8ICcnLFxuXHRcdFx0XHRcdFx0bGV0dGVyU3BhY2luZ1x0OiBoMi5jc3MoJ2xldHRlclNwYWNpbmcnKVx0fHwgJycsXG5cdFx0XHRcdFx0XHR3b3JkU3BhY2luZ1x0XHQ6IGgyLmNzcygnd29yZFNwYWNpbmcnKVx0XHR8fCAnJ1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0aDIud2lkdGgoTWF0aC5taW4oaDEudGV4dChcInBXXCIgKyBoMlswXS52YWx1ZSkud2lkdGgoKSx3KSlbMF0uc2VsZWN0KCk7XG5cdFx0XHR9LFxuXHRcdFx0cmVuYW1lIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHR0aGlzLl9fcm9sbGJhY2soKTtcblx0XHRcdFx0dmFyIGYgPSB0aGlzLl9fY2FsbGJhY2s7XG5cdFx0XHRcdHRoaXMuX3Nob3dfaW5wdXQob2JqLCBmdW5jdGlvbiAob2JqLCBuZXdfbmFtZSwgb2xkX25hbWUpIHsgXG5cdFx0XHRcdFx0Zi5jYWxsKHRoaXMsIHsgXCJvYmpcIiA6IG9iaiwgXCJuZXdfbmFtZVwiIDogbmV3X25hbWUsIFwib2xkX25hbWVcIiA6IG9sZF9uYW1lIH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHRjcmVhdGUgOiBmdW5jdGlvbiAob2JqLCBwb3NpdGlvbiwganMsIGNhbGxiYWNrLCBza2lwX3JlbmFtZSkge1xuXHRcdFx0XHR2YXIgdCwgX3RoaXMgPSB0aGlzO1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRpZighb2JqKSB7IG9iaiA9IC0xOyB9XG5cdFx0XHRcdHRoaXMuX19yb2xsYmFjaygpO1xuXHRcdFx0XHR0ID0gdGhpcy5jcmVhdGVfbm9kZShvYmosIHBvc2l0aW9uLCBqcywgZnVuY3Rpb24gKHQpIHtcblx0XHRcdFx0XHR2YXIgcCA9IHRoaXMuX2dldF9wYXJlbnQodCksXG5cdFx0XHRcdFx0XHRwb3MgPSAkKHQpLmluZGV4KCk7XG5cdFx0XHRcdFx0aWYoY2FsbGJhY2spIHsgY2FsbGJhY2suY2FsbCh0aGlzLCB0KTsgfVxuXHRcdFx0XHRcdGlmKHAubGVuZ3RoICYmIHAuaGFzQ2xhc3MoXCJqc3RyZWUtY2xvc2VkXCIpKSB7IHRoaXMub3Blbl9ub2RlKHAsIGZhbHNlLCB0cnVlKTsgfVxuXHRcdFx0XHRcdGlmKCFza2lwX3JlbmFtZSkgeyBcblx0XHRcdFx0XHRcdHRoaXMuX3Nob3dfaW5wdXQodCwgZnVuY3Rpb24gKG9iaiwgbmV3X25hbWUsIG9sZF9uYW1lKSB7IFxuXHRcdFx0XHRcdFx0XHRfdGhpcy5fX2NhbGxiYWNrKHsgXCJvYmpcIiA6IG9iaiwgXCJuYW1lXCIgOiBuZXdfbmFtZSwgXCJwYXJlbnRcIiA6IHAsIFwicG9zaXRpb25cIiA6IHBvcyB9KTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHsgX3RoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiB0LCBcIm5hbWVcIiA6IHRoaXMuZ2V0X3RleHQodCksIFwicGFyZW50XCIgOiBwLCBcInBvc2l0aW9uXCIgOiBwb3MgfSk7IH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiB0O1xuXHRcdFx0fSxcblx0XHRcdHJlbW92ZSA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqLCB0cnVlKTtcblx0XHRcdFx0dmFyIHAgPSB0aGlzLl9nZXRfcGFyZW50KG9iaiksIHByZXYgPSB0aGlzLl9nZXRfcHJldihvYmopO1xuXHRcdFx0XHR0aGlzLl9fcm9sbGJhY2soKTtcblx0XHRcdFx0b2JqID0gdGhpcy5kZWxldGVfbm9kZShvYmopO1xuXHRcdFx0XHRpZihvYmogIT09IGZhbHNlKSB7IHRoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiBvYmosIFwicHJldlwiIDogcHJldiwgXCJwYXJlbnRcIiA6IHAgfSk7IH1cblx0XHRcdH0sXG5cdFx0XHRjaGVja19tb3ZlIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZighdGhpcy5fX2NhbGxfb2xkKCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdHZhciBzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkuY3JybS5tb3ZlO1xuXHRcdFx0XHRpZighcy5jaGVja19tb3ZlLmNhbGwodGhpcywgdGhpcy5fZ2V0X21vdmUoKSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdG1vdmVfbm9kZSA6IGZ1bmN0aW9uIChvYmosIHJlZiwgcG9zaXRpb24sIGlzX2NvcHksIGlzX3ByZXBhcmVkLCBza2lwX2NoZWNrKSB7XG5cdFx0XHRcdHZhciBzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkuY3JybS5tb3ZlO1xuXHRcdFx0XHRpZighaXNfcHJlcGFyZWQpIHsgXG5cdFx0XHRcdFx0aWYodHlwZW9mIHBvc2l0aW9uID09PSBcInVuZGVmaW5lZFwiKSB7IHBvc2l0aW9uID0gcy5kZWZhdWx0X3Bvc2l0aW9uOyB9XG5cdFx0XHRcdFx0aWYocG9zaXRpb24gPT09IFwiaW5zaWRlXCIgJiYgIXMuZGVmYXVsdF9wb3NpdGlvbi5tYXRjaCgvXihiZWZvcmV8YWZ0ZXIpJC8pKSB7IHBvc2l0aW9uID0gcy5kZWZhdWx0X3Bvc2l0aW9uOyB9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX19jYWxsX29sZCh0cnVlLCBvYmosIHJlZiwgcG9zaXRpb24sIGlzX2NvcHksIGZhbHNlLCBza2lwX2NoZWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpZiB0aGUgbW92ZSBpcyBhbHJlYWR5IHByZXBhcmVkXG5cdFx0XHRcdGlmKHMuYWx3YXlzX2NvcHkgPT09IHRydWUgfHwgKHMuYWx3YXlzX2NvcHkgPT09IFwibXVsdGl0cmVlXCIgJiYgb2JqLnJ0LmdldF9pbmRleCgpICE9PSBvYmoub3QuZ2V0X2luZGV4KCkgKSkge1xuXHRcdFx0XHRcdGlzX2NvcHkgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX19jYWxsX29sZCh0cnVlLCBvYmosIHJlZiwgcG9zaXRpb24sIGlzX2NvcHksIHRydWUsIHNraXBfY2hlY2spO1xuXHRcdFx0fSxcblxuXHRcdFx0Y3V0IDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0XHRpZighb2JqIHx8ICFvYmoubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHR0aGlzLmRhdGEuY3JybS5jcF9ub2RlcyA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLmRhdGEuY3JybS5jdF9ub2RlcyA9IG9iajtcblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHsgXCJvYmpcIiA6IG9iaiB9KTtcblx0XHRcdH0sXG5cdFx0XHRjb3B5IDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0XHRpZighb2JqIHx8ICFvYmoubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHR0aGlzLmRhdGEuY3JybS5jdF9ub2RlcyA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLmRhdGEuY3JybS5jcF9ub2RlcyA9IG9iajtcblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHsgXCJvYmpcIiA6IG9iaiB9KTtcblx0XHRcdH0sXG5cdFx0XHRwYXN0ZSA6IGZ1bmN0aW9uIChvYmopIHsgXG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdGlmKCFvYmogfHwgIW9iai5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdHZhciBub2RlcyA9IHRoaXMuZGF0YS5jcnJtLmN0X25vZGVzID8gdGhpcy5kYXRhLmNycm0uY3Rfbm9kZXMgOiB0aGlzLmRhdGEuY3JybS5jcF9ub2Rlcztcblx0XHRcdFx0aWYoIXRoaXMuZGF0YS5jcnJtLmN0X25vZGVzICYmICF0aGlzLmRhdGEuY3JybS5jcF9ub2RlcykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0aWYodGhpcy5kYXRhLmNycm0uY3Rfbm9kZXMpIHsgdGhpcy5tb3ZlX25vZGUodGhpcy5kYXRhLmNycm0uY3Rfbm9kZXMsIG9iaik7IHRoaXMuZGF0YS5jcnJtLmN0X25vZGVzID0gZmFsc2U7IH1cblx0XHRcdFx0aWYodGhpcy5kYXRhLmNycm0uY3Bfbm9kZXMpIHsgdGhpcy5tb3ZlX25vZGUodGhpcy5kYXRhLmNycm0uY3Bfbm9kZXMsIG9iaiwgZmFsc2UsIHRydWUpOyB9XG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiBvYmosIFwibm9kZXNcIiA6IG5vZGVzIH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdC8vIGluY2x1ZGUgdGhlIGNyciBwbHVnaW4gYnkgZGVmYXVsdFxuXHQvLyAkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXCJjcnJtXCIpO1xufSkoalF1ZXJ5KTtcbi8vKi9cblxuLyogXG4gKiBqc1RyZWUgdGhlbWVzIHBsdWdpblxuICogSGFuZGxlcyBsb2FkaW5nIGFuZCBzZXR0aW5nIHRoZW1lcywgYXMgd2VsbCBhcyBkZXRlY3RpbmcgcGF0aCB0byB0aGVtZXMsIGV0Yy5cbiAqL1xuKGZ1bmN0aW9uICgkKSB7XG5cdHZhciB0aGVtZXNfbG9hZGVkID0gW107XG5cdC8vIHRoaXMgdmFyaWFibGUgc3RvcmVzIHRoZSBwYXRoIHRvIHRoZSB0aGVtZXMgZm9sZGVyIC0gaWYgbGVmdCBhcyBmYWxzZSAtIGl0IHdpbGwgYmUgYXV0b2RldGVjdGVkXG5cdCQuanN0cmVlLl90aGVtZXMgPSBmYWxzZTtcblx0JC5qc3RyZWUucGx1Z2luKFwidGhlbWVzXCIsIHtcblx0XHRfX2luaXQgOiBmdW5jdGlvbiAoKSB7IFxuXHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKClcblx0XHRcdFx0LmJpbmQoXCJpbml0LmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHZhciBzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkudGhlbWVzO1xuXHRcdFx0XHRcdFx0dGhpcy5kYXRhLnRoZW1lcy5kb3RzID0gcy5kb3RzOyBcblx0XHRcdFx0XHRcdHRoaXMuZGF0YS50aGVtZXMuaWNvbnMgPSBzLmljb25zOyBcblx0XHRcdFx0XHRcdHRoaXMuc2V0X3RoZW1lKHMudGhlbWUsIHMudXJsKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJsb2FkZWQuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0Ly8gYm91bmQgaGVyZSB0b28sIGFzIHNpbXBsZSBIVE1MIHRyZWUncyB3b24ndCBob25vciBkb3RzICYgaWNvbnMgb3RoZXJ3aXNlXG5cdFx0XHRcdFx0XHRpZighdGhpcy5kYXRhLnRoZW1lcy5kb3RzKSB7IHRoaXMuaGlkZV9kb3RzKCk7IH1cblx0XHRcdFx0XHRcdGVsc2UgeyB0aGlzLnNob3dfZG90cygpOyB9XG5cdFx0XHRcdFx0XHRpZighdGhpcy5kYXRhLnRoZW1lcy5pY29ucykgeyB0aGlzLmhpZGVfaWNvbnMoKTsgfVxuXHRcdFx0XHRcdFx0ZWxzZSB7IHRoaXMuc2hvd19pY29ucygpOyB9XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdH0sXG5cdFx0ZGVmYXVsdHMgOiB7IFxuXHRcdFx0dGhlbWUgOiBcImRlZmF1bHRcIiwgXG5cdFx0XHR1cmwgOiBmYWxzZSxcblx0XHRcdGRvdHMgOiB0cnVlLFxuXHRcdFx0aWNvbnMgOiB0cnVlXG5cdFx0fSxcblx0XHRfZm4gOiB7XG5cdFx0XHRzZXRfdGhlbWUgOiBmdW5jdGlvbiAodGhlbWVfbmFtZSwgdGhlbWVfdXJsKSB7XG5cdFx0XHRcdGlmKCF0aGVtZV9uYW1lKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRpZighdGhlbWVfdXJsKSB7IHRoZW1lX3VybCA9ICQuanN0cmVlLl90aGVtZXMgKyB0aGVtZV9uYW1lICsgJy9zdHlsZS5jc3MnOyB9XG5cdFx0XHRcdGlmKCQuaW5BcnJheSh0aGVtZV91cmwsIHRoZW1lc19sb2FkZWQpID09IC0xKSB7XG5cdFx0XHRcdFx0JC52YWthdGEuY3NzLmFkZF9zaGVldCh7IFwidXJsXCIgOiB0aGVtZV91cmwgfSk7XG5cdFx0XHRcdFx0dGhlbWVzX2xvYWRlZC5wdXNoKHRoZW1lX3VybCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodGhpcy5kYXRhLnRoZW1lcy50aGVtZSAhPSB0aGVtZV9uYW1lKSB7XG5cdFx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkucmVtb3ZlQ2xhc3MoJ2pzdHJlZS0nICsgdGhpcy5kYXRhLnRoZW1lcy50aGVtZSk7XG5cdFx0XHRcdFx0dGhpcy5kYXRhLnRoZW1lcy50aGVtZSA9IHRoZW1lX25hbWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkuYWRkQ2xhc3MoJ2pzdHJlZS0nICsgdGhlbWVfbmFtZSk7XG5cdFx0XHRcdGlmKCF0aGlzLmRhdGEudGhlbWVzLmRvdHMpIHsgdGhpcy5oaWRlX2RvdHMoKTsgfVxuXHRcdFx0XHRlbHNlIHsgdGhpcy5zaG93X2RvdHMoKTsgfVxuXHRcdFx0XHRpZighdGhpcy5kYXRhLnRoZW1lcy5pY29ucykgeyB0aGlzLmhpZGVfaWNvbnMoKTsgfVxuXHRcdFx0XHRlbHNlIHsgdGhpcy5zaG93X2ljb25zKCk7IH1cblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKCk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0X3RoZW1lXHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGF0YS50aGVtZXMudGhlbWU7IH0sXG5cblx0XHRcdHNob3dfZG90c1x0OiBmdW5jdGlvbiAoKSB7IHRoaXMuZGF0YS50aGVtZXMuZG90cyA9IHRydWU7IHRoaXMuZ2V0X2NvbnRhaW5lcigpLmNoaWxkcmVuKFwidWxcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbm8tZG90c1wiKTsgfSxcblx0XHRcdGhpZGVfZG90c1x0OiBmdW5jdGlvbiAoKSB7IHRoaXMuZGF0YS50aGVtZXMuZG90cyA9IGZhbHNlOyB0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcInVsXCIpLmFkZENsYXNzKFwianN0cmVlLW5vLWRvdHNcIik7IH0sXG5cdFx0XHR0b2dnbGVfZG90c1x0OiBmdW5jdGlvbiAoKSB7IGlmKHRoaXMuZGF0YS50aGVtZXMuZG90cykgeyB0aGlzLmhpZGVfZG90cygpOyB9IGVsc2UgeyB0aGlzLnNob3dfZG90cygpOyB9IH0sXG5cblx0XHRcdHNob3dfaWNvbnNcdDogZnVuY3Rpb24gKCkgeyB0aGlzLmRhdGEudGhlbWVzLmljb25zID0gdHJ1ZTsgdGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1uby1pY29uc1wiKTsgfSxcblx0XHRcdGhpZGVfaWNvbnNcdDogZnVuY3Rpb24gKCkgeyB0aGlzLmRhdGEudGhlbWVzLmljb25zID0gZmFsc2U7IHRoaXMuZ2V0X2NvbnRhaW5lcigpLmNoaWxkcmVuKFwidWxcIikuYWRkQ2xhc3MoXCJqc3RyZWUtbm8taWNvbnNcIik7IH0sXG5cdFx0XHR0b2dnbGVfaWNvbnM6IGZ1bmN0aW9uICgpIHsgaWYodGhpcy5kYXRhLnRoZW1lcy5pY29ucykgeyB0aGlzLmhpZGVfaWNvbnMoKTsgfSBlbHNlIHsgdGhpcy5zaG93X2ljb25zKCk7IH0gfVxuXHRcdH1cblx0fSk7XG5cdC8vIGF1dG9kZXRlY3QgdGhlbWVzIHBhdGhcblx0JChmdW5jdGlvbiAoKSB7XG5cdFx0aWYoJC5qc3RyZWUuX3RoZW1lcyA9PT0gZmFsc2UpIHtcblx0XHRcdCQoXCJzY3JpcHRcIikuZWFjaChmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHRpZih0aGlzLnNyYy50b1N0cmluZygpLm1hdGNoKC9qcXVlcnlcXC5qc3RyZWVbXlxcL10qP1xcLmpzKFxcPy4qKT8kLykpIHsgXG5cdFx0XHRcdFx0JC5qc3RyZWUuX3RoZW1lcyA9IHRoaXMuc3JjLnRvU3RyaW5nKCkucmVwbGFjZSgvanF1ZXJ5XFwuanN0cmVlW15cXC9dKj9cXC5qcyhcXD8uKik/JC8sIFwiXCIpICsgJ3RoZW1lcy8nOyBcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7IFxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0aWYoJC5qc3RyZWUuX3RoZW1lcyA9PT0gZmFsc2UpIHsgJC5qc3RyZWUuX3RoZW1lcyA9IFwidGhlbWVzL1wiOyB9XG5cdH0pO1xuXHQvLyBpbmNsdWRlIHRoZSB0aGVtZXMgcGx1Z2luIGJ5IGRlZmF1bHRcblx0JC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFwidGhlbWVzXCIpO1xufSkoalF1ZXJ5KTtcbi8vKi9cblxuLypcbiAqIGpzVHJlZSBob3RrZXlzIHBsdWdpblxuICogRW5hYmxlcyBrZXlib2FyZCBuYXZpZ2F0aW9uIGZvciBhbGwgdHJlZSBpbnN0YW5jZXNcbiAqIERlcGVuZHMgb24gdGhlIGpzdHJlZSB1aSAmIGpxdWVyeSBob3RrZXlzIHBsdWdpbnNcbiAqL1xuKGZ1bmN0aW9uICgkKSB7XG5cdHZhciBib3VuZCA9IFtdO1xuXHRmdW5jdGlvbiBleGVjKGksIGV2ZW50KSB7XG5cdFx0dmFyIGYgPSAkLmpzdHJlZS5fZm9jdXNlZCgpLCB0bXA7XG5cdFx0aWYoZiAmJiBmLmRhdGEgJiYgZi5kYXRhLmhvdGtleXMgJiYgZi5kYXRhLmhvdGtleXMuZW5hYmxlZCkgeyBcblx0XHRcdHRtcCA9IGYuX2dldF9zZXR0aW5ncygpLmhvdGtleXNbaV07XG5cdFx0XHRpZih0bXApIHsgcmV0dXJuIHRtcC5jYWxsKGYsIGV2ZW50KTsgfVxuXHRcdH1cblx0fVxuXHQkLmpzdHJlZS5wbHVnaW4oXCJob3RrZXlzXCIsIHtcblx0XHRfX2luaXQgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZih0eXBlb2YgJC5ob3RrZXlzID09PSBcInVuZGVmaW5lZFwiKSB7IHRocm93IFwianNUcmVlIGhvdGtleXM6IGpRdWVyeSBob3RrZXlzIHBsdWdpbiBub3QgaW5jbHVkZWQuXCI7IH1cblx0XHRcdGlmKCF0aGlzLmRhdGEudWkpIHsgdGhyb3cgXCJqc1RyZWUgaG90a2V5czoganNUcmVlIFVJIHBsdWdpbiBub3QgaW5jbHVkZWQuXCI7IH1cblx0XHRcdCQuZWFjaCh0aGlzLl9nZXRfc2V0dGluZ3MoKS5ob3RrZXlzLCBmdW5jdGlvbiAoaSwgdikge1xuXHRcdFx0XHRpZih2ICE9PSBmYWxzZSAmJiAkLmluQXJyYXkoaSwgYm91bmQpID09IC0xKSB7XG5cdFx0XHRcdFx0JChkb2N1bWVudCkuYmluZChcImtleWRvd25cIiwgaSwgZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBleGVjKGksIGV2ZW50KTsgfSk7XG5cdFx0XHRcdFx0Ym91bmQucHVzaChpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmdldF9jb250YWluZXIoKVxuXHRcdFx0XHQuYmluZChcImxvY2suanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLmhvdGtleXMuZW5hYmxlZCkgeyB0aGlzLmRhdGEuaG90a2V5cy5lbmFibGVkID0gZmFsc2U7IHRoaXMuZGF0YS5ob3RrZXlzLnJldmVydCA9IHRydWU7IH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJ1bmxvY2suanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLmhvdGtleXMucmV2ZXJ0KSB7IHRoaXMuZGF0YS5ob3RrZXlzLmVuYWJsZWQgPSB0cnVlOyB9XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0dGhpcy5lbmFibGVfaG90a2V5cygpO1xuXHRcdH0sXG5cdFx0ZGVmYXVsdHMgOiB7XG5cdFx0XHRcInVwXCIgOiBmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHR2YXIgbyA9IHRoaXMuZGF0YS51aS5ob3ZlcmVkIHx8IHRoaXMuZGF0YS51aS5sYXN0X3NlbGVjdGVkIHx8IC0xO1xuXHRcdFx0XHR0aGlzLmhvdmVyX25vZGUodGhpcy5fZ2V0X3ByZXYobykpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7IFxuXHRcdFx0fSxcblx0XHRcdFwiY3RybCt1cFwiIDogZnVuY3Rpb24gKCkgeyBcblx0XHRcdFx0dmFyIG8gPSB0aGlzLmRhdGEudWkuaG92ZXJlZCB8fCB0aGlzLmRhdGEudWkubGFzdF9zZWxlY3RlZCB8fCAtMTtcblx0XHRcdFx0dGhpcy5ob3Zlcl9ub2RlKHRoaXMuX2dldF9wcmV2KG8pKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlOyBcblx0XHRcdH0sXG5cdFx0XHRcInNoaWZ0K3VwXCIgOiBmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHR2YXIgbyA9IHRoaXMuZGF0YS51aS5ob3ZlcmVkIHx8IHRoaXMuZGF0YS51aS5sYXN0X3NlbGVjdGVkIHx8IC0xO1xuXHRcdFx0XHR0aGlzLmhvdmVyX25vZGUodGhpcy5fZ2V0X3ByZXYobykpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7IFxuXHRcdFx0fSxcblx0XHRcdFwiZG93blwiIDogZnVuY3Rpb24gKCkgeyBcblx0XHRcdFx0dmFyIG8gPSB0aGlzLmRhdGEudWkuaG92ZXJlZCB8fCB0aGlzLmRhdGEudWkubGFzdF9zZWxlY3RlZCB8fCAtMTtcblx0XHRcdFx0dGhpcy5ob3Zlcl9ub2RlKHRoaXMuX2dldF9uZXh0KG8pKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdFwiY3RybCtkb3duXCIgOiBmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHR2YXIgbyA9IHRoaXMuZGF0YS51aS5ob3ZlcmVkIHx8IHRoaXMuZGF0YS51aS5sYXN0X3NlbGVjdGVkIHx8IC0xO1xuXHRcdFx0XHR0aGlzLmhvdmVyX25vZGUodGhpcy5fZ2V0X25leHQobykpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0XCJzaGlmdCtkb3duXCIgOiBmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHR2YXIgbyA9IHRoaXMuZGF0YS51aS5ob3ZlcmVkIHx8IHRoaXMuZGF0YS51aS5sYXN0X3NlbGVjdGVkIHx8IC0xO1xuXHRcdFx0XHR0aGlzLmhvdmVyX25vZGUodGhpcy5fZ2V0X25leHQobykpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0XCJsZWZ0XCIgOiBmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHR2YXIgbyA9IHRoaXMuZGF0YS51aS5ob3ZlcmVkIHx8IHRoaXMuZGF0YS51aS5sYXN0X3NlbGVjdGVkO1xuXHRcdFx0XHRpZihvKSB7XG5cdFx0XHRcdFx0aWYoby5oYXNDbGFzcyhcImpzdHJlZS1vcGVuXCIpKSB7IHRoaXMuY2xvc2Vfbm9kZShvKTsgfVxuXHRcdFx0XHRcdGVsc2UgeyB0aGlzLmhvdmVyX25vZGUodGhpcy5fZ2V0X3ByZXYobykpOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdFwiY3RybCtsZWZ0XCIgOiBmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHR2YXIgbyA9IHRoaXMuZGF0YS51aS5ob3ZlcmVkIHx8IHRoaXMuZGF0YS51aS5sYXN0X3NlbGVjdGVkO1xuXHRcdFx0XHRpZihvKSB7XG5cdFx0XHRcdFx0aWYoby5oYXNDbGFzcyhcImpzdHJlZS1vcGVuXCIpKSB7IHRoaXMuY2xvc2Vfbm9kZShvKTsgfVxuXHRcdFx0XHRcdGVsc2UgeyB0aGlzLmhvdmVyX25vZGUodGhpcy5fZ2V0X3ByZXYobykpOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdFwic2hpZnQrbGVmdFwiIDogZnVuY3Rpb24gKCkgeyBcblx0XHRcdFx0dmFyIG8gPSB0aGlzLmRhdGEudWkuaG92ZXJlZCB8fCB0aGlzLmRhdGEudWkubGFzdF9zZWxlY3RlZDtcblx0XHRcdFx0aWYobykge1xuXHRcdFx0XHRcdGlmKG8uaGFzQ2xhc3MoXCJqc3RyZWUtb3BlblwiKSkgeyB0aGlzLmNsb3NlX25vZGUobyk7IH1cblx0XHRcdFx0XHRlbHNlIHsgdGhpcy5ob3Zlcl9ub2RlKHRoaXMuX2dldF9wcmV2KG8pKTsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRcInJpZ2h0XCIgOiBmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHR2YXIgbyA9IHRoaXMuZGF0YS51aS5ob3ZlcmVkIHx8IHRoaXMuZGF0YS51aS5sYXN0X3NlbGVjdGVkO1xuXHRcdFx0XHRpZihvICYmIG8ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0aWYoby5oYXNDbGFzcyhcImpzdHJlZS1jbG9zZWRcIikpIHsgdGhpcy5vcGVuX25vZGUobyk7IH1cblx0XHRcdFx0XHRlbHNlIHsgdGhpcy5ob3Zlcl9ub2RlKHRoaXMuX2dldF9uZXh0KG8pKTsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRcImN0cmwrcmlnaHRcIiA6IGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdHZhciBvID0gdGhpcy5kYXRhLnVpLmhvdmVyZWQgfHwgdGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWQ7XG5cdFx0XHRcdGlmKG8gJiYgby5sZW5ndGgpIHtcblx0XHRcdFx0XHRpZihvLmhhc0NsYXNzKFwianN0cmVlLWNsb3NlZFwiKSkgeyB0aGlzLm9wZW5fbm9kZShvKTsgfVxuXHRcdFx0XHRcdGVsc2UgeyB0aGlzLmhvdmVyX25vZGUodGhpcy5fZ2V0X25leHQobykpOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdFwic2hpZnQrcmlnaHRcIiA6IGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdHZhciBvID0gdGhpcy5kYXRhLnVpLmhvdmVyZWQgfHwgdGhpcy5kYXRhLnVpLmxhc3Rfc2VsZWN0ZWQ7XG5cdFx0XHRcdGlmKG8gJiYgby5sZW5ndGgpIHtcblx0XHRcdFx0XHRpZihvLmhhc0NsYXNzKFwianN0cmVlLWNsb3NlZFwiKSkgeyB0aGlzLm9wZW5fbm9kZShvKTsgfVxuXHRcdFx0XHRcdGVsc2UgeyB0aGlzLmhvdmVyX25vZGUodGhpcy5fZ2V0X25leHQobykpOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdFwic3BhY2VcIiA6IGZ1bmN0aW9uICgpIHsgXG5cdFx0XHRcdGlmKHRoaXMuZGF0YS51aS5ob3ZlcmVkKSB7IHRoaXMuZGF0YS51aS5ob3ZlcmVkLmNoaWxkcmVuKFwiYTplcSgwKVwiKS5jbGljaygpOyB9IFxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7IFxuXHRcdFx0fSxcblx0XHRcdFwiY3RybCtzcGFjZVwiIDogZnVuY3Rpb24gKGV2ZW50KSB7IFxuXHRcdFx0XHRldmVudC50eXBlID0gXCJjbGlja1wiO1xuXHRcdFx0XHRpZih0aGlzLmRhdGEudWkuaG92ZXJlZCkgeyB0aGlzLmRhdGEudWkuaG92ZXJlZC5jaGlsZHJlbihcImE6ZXEoMClcIikudHJpZ2dlcihldmVudCk7IH0gXG5cdFx0XHRcdHJldHVybiBmYWxzZTsgXG5cdFx0XHR9LFxuXHRcdFx0XCJzaGlmdCtzcGFjZVwiIDogZnVuY3Rpb24gKGV2ZW50KSB7IFxuXHRcdFx0XHRldmVudC50eXBlID0gXCJjbGlja1wiO1xuXHRcdFx0XHRpZih0aGlzLmRhdGEudWkuaG92ZXJlZCkgeyB0aGlzLmRhdGEudWkuaG92ZXJlZC5jaGlsZHJlbihcImE6ZXEoMClcIikudHJpZ2dlcihldmVudCk7IH0gXG5cdFx0XHRcdHJldHVybiBmYWxzZTsgXG5cdFx0XHR9LFxuXHRcdFx0XCJmMlwiIDogZnVuY3Rpb24gKCkgeyB0aGlzLnJlbmFtZSh0aGlzLmRhdGEudWkuaG92ZXJlZCB8fCB0aGlzLmRhdGEudWkubGFzdF9zZWxlY3RlZCk7IH0sXG5cdFx0XHRcImRlbFwiIDogZnVuY3Rpb24gKCkgeyB0aGlzLnJlbW92ZSh0aGlzLmRhdGEudWkuaG92ZXJlZCB8fCB0aGlzLl9nZXRfbm9kZShudWxsKSk7IH1cblx0XHR9LFxuXHRcdF9mbiA6IHtcblx0XHRcdGVuYWJsZV9ob3RrZXlzIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLmRhdGEuaG90a2V5cy5lbmFibGVkID0gdHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlX2hvdGtleXMgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuZGF0YS5ob3RrZXlzLmVuYWJsZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufSkoalF1ZXJ5KTtcbi8vKi9cblxuLyogXG4gKiBqc1RyZWUgSlNPTiBwbHVnaW5cbiAqIFRoZSBKU09OIGRhdGEgc3RvcmUuIERhdGFzdG9yZXMgYXJlIGJ1aWxkIGJ5IG92ZXJyaWRpbmcgdGhlIGBsb2FkX25vZGVgIGFuZCBgX2lzX2xvYWRlZGAgZnVuY3Rpb25zLlxuICovXG4oZnVuY3Rpb24gKCQpIHtcblx0JC5qc3RyZWUucGx1Z2luKFwianNvbl9kYXRhXCIsIHtcblx0XHRfX2luaXQgOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkuanNvbl9kYXRhO1xuXHRcdFx0aWYocy5wcm9ncmVzc2l2ZV91bmxvYWQpIHtcblx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkuYmluZChcImFmdGVyX2Nsb3NlLmpzdHJlZVwiLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdGRhdGEucnNsdC5vYmouY2hpbGRyZW4oXCJ1bFwiKS5yZW1vdmUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkZWZhdWx0cyA6IHsgXG5cdFx0XHQvLyBgZGF0YWAgY2FuIGJlIGEgZnVuY3Rpb246XG5cdFx0XHQvLyAgKiBhY2NlcHRzIHR3byBhcmd1bWVudHMgLSBub2RlIGJlaW5nIGxvYWRlZCBhbmQgYSBjYWxsYmFjayB0byBwYXNzIHRoZSByZXN1bHQgdG9cblx0XHRcdC8vICAqIHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIGN1cnJlbnQgdHJlZSdzIHNjb3BlICYgYWpheCB3b24ndCBiZSBzdXBwb3J0ZWRcblx0XHRcdGRhdGEgOiBmYWxzZSwgXG5cdFx0XHRhamF4IDogZmFsc2UsXG5cdFx0XHRjb3JyZWN0X3N0YXRlIDogdHJ1ZSxcblx0XHRcdHByb2dyZXNzaXZlX3JlbmRlciA6IGZhbHNlLFxuXHRcdFx0cHJvZ3Jlc3NpdmVfdW5sb2FkIDogZmFsc2Vcblx0XHR9LFxuXHRcdF9mbiA6IHtcblx0XHRcdGxvYWRfbm9kZSA6IGZ1bmN0aW9uIChvYmosIHNfY2FsbCwgZV9jYWxsKSB7IHZhciBfdGhpcyA9IHRoaXM7IHRoaXMubG9hZF9ub2RlX2pzb24ob2JqLCBmdW5jdGlvbiAoKSB7IF90aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogX3RoaXMuX2dldF9ub2RlKG9iaikgfSk7IHNfY2FsbC5jYWxsKHRoaXMpOyB9LCBlX2NhbGwpOyB9LFxuXHRcdFx0X2lzX2xvYWRlZCA6IGZ1bmN0aW9uIChvYmopIHsgXG5cdFx0XHRcdHZhciBzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkuanNvbl9kYXRhO1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopOyBcblx0XHRcdFx0cmV0dXJuIG9iaiA9PSAtMSB8fCAhb2JqIHx8ICghcy5hamF4ICYmICFzLnByb2dyZXNzaXZlX3JlbmRlciAmJiAhJC5pc0Z1bmN0aW9uKHMuZGF0YSkpIHx8IG9iai5pcyhcIi5qc3RyZWUtb3BlbiwgLmpzdHJlZS1sZWFmXCIpIHx8IG9iai5jaGlsZHJlbihcInVsXCIpLmNoaWxkcmVuKFwibGlcIikubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cdFx0XHRyZWZyZXNoIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHR2YXIgcyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLmpzb25fZGF0YTtcblx0XHRcdFx0aWYob2JqICYmIG9iaiAhPT0gLTEgJiYgcy5wcm9ncmVzc2l2ZV91bmxvYWQgJiYgKCQuaXNGdW5jdGlvbihzLmRhdGEpIHx8ICEhcy5hamF4KSkge1xuXHRcdFx0XHRcdG9iai5yZW1vdmVEYXRhKFwianN0cmVlX2NoaWxkcmVuXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLl9fY2FsbF9vbGQoKTtcblx0XHRcdH0sXG5cdFx0XHRsb2FkX25vZGVfanNvbiA6IGZ1bmN0aW9uIChvYmosIHNfY2FsbCwgZV9jYWxsKSB7XG5cdFx0XHRcdHZhciBzID0gdGhpcy5nZXRfc2V0dGluZ3MoKS5qc29uX2RhdGEsIGQsXG5cdFx0XHRcdFx0ZXJyb3JfZnVuYyA9IGZ1bmN0aW9uICgpIHt9LFxuXHRcdFx0XHRcdHN1Y2Nlc3NfZnVuYyA9IGZ1bmN0aW9uICgpIHt9O1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXG5cdFx0XHRcdGlmKG9iaiAmJiBvYmogIT09IC0xICYmIChzLnByb2dyZXNzaXZlX3JlbmRlciB8fCBzLnByb2dyZXNzaXZlX3VubG9hZCkgJiYgIW9iai5pcyhcIi5qc3RyZWUtb3BlbiwgLmpzdHJlZS1sZWFmXCIpICYmIG9iai5jaGlsZHJlbihcInVsXCIpLmNoaWxkcmVuKFwibGlcIikubGVuZ3RoID09PSAwICYmIG9iai5kYXRhKFwianN0cmVlX2NoaWxkcmVuXCIpKSB7XG5cdFx0XHRcdFx0ZCA9IHRoaXMuX3BhcnNlX2pzb24ob2JqLmRhdGEoXCJqc3RyZWVfY2hpbGRyZW5cIiksIG9iaik7XG5cdFx0XHRcdFx0aWYoZCkge1xuXHRcdFx0XHRcdFx0b2JqLmFwcGVuZChkKTtcblx0XHRcdFx0XHRcdGlmKCFzLnByb2dyZXNzaXZlX3VubG9hZCkgeyBvYmoucmVtb3ZlRGF0YShcImpzdHJlZV9jaGlsZHJlblwiKTsgfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmNsZWFuX25vZGUob2JqKTtcblx0XHRcdFx0XHRpZihzX2NhbGwpIHsgc19jYWxsLmNhbGwodGhpcyk7IH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihvYmogJiYgb2JqICE9PSAtMSkge1xuXHRcdFx0XHRcdGlmKG9iai5kYXRhKFwianN0cmVlX2lzX2xvYWRpbmdcIikpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdFx0ZWxzZSB7IG9iai5kYXRhKFwianN0cmVlX2lzX2xvYWRpbmdcIix0cnVlKTsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN3aXRjaCghMCkge1xuXHRcdFx0XHRcdGNhc2UgKCFzLmRhdGEgJiYgIXMuYWpheCk6IHRocm93IFwiTmVpdGhlciBkYXRhIG5vciBhamF4IHNldHRpbmdzIHN1cHBsaWVkLlwiO1xuXHRcdFx0XHRcdC8vIGZ1bmN0aW9uIG9wdGlvbiBhZGRlZCBoZXJlIGZvciBlYXNpZXIgbW9kZWwgaW50ZWdyYXRpb24gKGFsc28gc3VwcG9ydGluZyBhc3luYyAtIHNlZSBjYWxsYmFjaylcblx0XHRcdFx0XHRjYXNlICgkLmlzRnVuY3Rpb24ocy5kYXRhKSk6XG5cdFx0XHRcdFx0XHRzLmRhdGEuY2FsbCh0aGlzLCBvYmosICQucHJveHkoZnVuY3Rpb24gKGQpIHtcblx0XHRcdFx0XHRcdFx0ZCA9IHRoaXMuX3BhcnNlX2pzb24oZCwgb2JqKTtcblx0XHRcdFx0XHRcdFx0aWYoIWQpIHsgXG5cdFx0XHRcdFx0XHRcdFx0aWYob2JqID09PSAtMSB8fCAhb2JqKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihzLmNvcnJlY3Rfc3RhdGUpIHsgdGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5lbXB0eSgpOyB9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0b2JqLmNoaWxkcmVuKFwiYS5qc3RyZWUtbG9hZGluZ1wiKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1sb2FkaW5nXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0b2JqLnJlbW92ZURhdGEoXCJqc3RyZWVfaXNfbG9hZGluZ1wiKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHMuY29ycmVjdF9zdGF0ZSkgeyB0aGlzLmNvcnJlY3Rfc3RhdGUob2JqKTsgfVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZihlX2NhbGwpIHsgZV9jYWxsLmNhbGwodGhpcyk7IH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRpZihvYmogPT09IC0xIHx8ICFvYmopIHsgdGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5lbXB0eSgpLmFwcGVuZChkLmNoaWxkcmVuKCkpOyB9XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSB7IG9iai5hcHBlbmQoZCkuY2hpbGRyZW4oXCJhLmpzdHJlZS1sb2FkaW5nXCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLWxvYWRpbmdcIik7IG9iai5yZW1vdmVEYXRhKFwianN0cmVlX2lzX2xvYWRpbmdcIik7IH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLmNsZWFuX25vZGUob2JqKTtcblx0XHRcdFx0XHRcdFx0XHRpZihzX2NhbGwpIHsgc19jYWxsLmNhbGwodGhpcyk7IH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAoISFzLmRhdGEgJiYgIXMuYWpheCkgfHwgKCEhcy5kYXRhICYmICEhcy5hamF4ICYmICghb2JqIHx8IG9iaiA9PT0gLTEpKTpcblx0XHRcdFx0XHRcdGlmKCFvYmogfHwgb2JqID09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGQgPSB0aGlzLl9wYXJzZV9qc29uKHMuZGF0YSwgb2JqKTtcblx0XHRcdFx0XHRcdFx0aWYoZCkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpLmNoaWxkcmVuKFwidWxcIikuZW1wdHkoKS5hcHBlbmQoZC5jaGlsZHJlbigpKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmNsZWFuX25vZGUoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHsgXG5cdFx0XHRcdFx0XHRcdFx0aWYocy5jb3JyZWN0X3N0YXRlKSB7IHRoaXMuZ2V0X2NvbnRhaW5lcigpLmNoaWxkcmVuKFwidWxcIikuZW1wdHkoKTsgfVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihzX2NhbGwpIHsgc19jYWxsLmNhbGwodGhpcyk7IH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgKCFzLmRhdGEgJiYgISFzLmFqYXgpIHx8ICghIXMuZGF0YSAmJiAhIXMuYWpheCAmJiBvYmogJiYgb2JqICE9PSAtMSk6XG5cdFx0XHRcdFx0XHRlcnJvcl9mdW5jID0gZnVuY3Rpb24gKHgsIHQsIGUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGVmID0gdGhpcy5nZXRfc2V0dGluZ3MoKS5qc29uX2RhdGEuYWpheC5lcnJvcjsgXG5cdFx0XHRcdFx0XHRcdGlmKGVmKSB7IGVmLmNhbGwodGhpcywgeCwgdCwgZSk7IH1cblx0XHRcdFx0XHRcdFx0aWYob2JqICE9IC0xICYmIG9iai5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRvYmouY2hpbGRyZW4oXCJhLmpzdHJlZS1sb2FkaW5nXCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLWxvYWRpbmdcIik7XG5cdFx0XHRcdFx0XHRcdFx0b2JqLnJlbW92ZURhdGEoXCJqc3RyZWVfaXNfbG9hZGluZ1wiKTtcblx0XHRcdFx0XHRcdFx0XHRpZih0ID09PSBcInN1Y2Nlc3NcIiAmJiBzLmNvcnJlY3Rfc3RhdGUpIHsgdGhpcy5jb3JyZWN0X3N0YXRlKG9iaik7IH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRpZih0ID09PSBcInN1Y2Nlc3NcIiAmJiBzLmNvcnJlY3Rfc3RhdGUpIHsgdGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5lbXB0eSgpOyB9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoZV9jYWxsKSB7IGVfY2FsbC5jYWxsKHRoaXMpOyB9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0c3VjY2Vzc19mdW5jID0gZnVuY3Rpb24gKGQsIHQsIHgpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHNmID0gdGhpcy5nZXRfc2V0dGluZ3MoKS5qc29uX2RhdGEuYWpheC5zdWNjZXNzOyBcblx0XHRcdFx0XHRcdFx0aWYoc2YpIHsgZCA9IHNmLmNhbGwodGhpcyxkLHQseCkgfHwgZDsgfVxuXHRcdFx0XHRcdFx0XHRpZihkID09PSBcIlwiIHx8IChkICYmIGQudG9TdHJpbmcgJiYgZC50b1N0cmluZygpLnJlcGxhY2UoL15bXFxzXFxuXSskLyxcIlwiKSA9PT0gXCJcIikgfHwgKCEkLmlzQXJyYXkoZCkgJiYgISQuaXNQbGFpbk9iamVjdChkKSkpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3JfZnVuYy5jYWxsKHRoaXMsIHgsIHQsIFwiXCIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGQgPSB0aGlzLl9wYXJzZV9qc29uKGQsIG9iaik7XG5cdFx0XHRcdFx0XHRcdGlmKGQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZihvYmogPT09IC0xIHx8ICFvYmopIHsgdGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5lbXB0eSgpLmFwcGVuZChkLmNoaWxkcmVuKCkpOyB9XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSB7IG9iai5hcHBlbmQoZCkuY2hpbGRyZW4oXCJhLmpzdHJlZS1sb2FkaW5nXCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLWxvYWRpbmdcIik7IG9iai5yZW1vdmVEYXRhKFwianN0cmVlX2lzX2xvYWRpbmdcIik7IH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLmNsZWFuX25vZGUob2JqKTtcblx0XHRcdFx0XHRcdFx0XHRpZihzX2NhbGwpIHsgc19jYWxsLmNhbGwodGhpcyk7IH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRpZihvYmogPT09IC0xIHx8ICFvYmopIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHMuY29ycmVjdF9zdGF0ZSkgeyBcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5lbXB0eSgpOyBcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoc19jYWxsKSB7IHNfY2FsbC5jYWxsKHRoaXMpOyB9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0b2JqLmNoaWxkcmVuKFwiYS5qc3RyZWUtbG9hZGluZ1wiKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1sb2FkaW5nXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0b2JqLnJlbW92ZURhdGEoXCJqc3RyZWVfaXNfbG9hZGluZ1wiKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHMuY29ycmVjdF9zdGF0ZSkgeyBcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5jb3JyZWN0X3N0YXRlKG9iaik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHNfY2FsbCkgeyBzX2NhbGwuY2FsbCh0aGlzKTsgfSBcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRzLmFqYXguY29udGV4dCA9IHRoaXM7XG5cdFx0XHRcdFx0XHRzLmFqYXguZXJyb3IgPSBlcnJvcl9mdW5jO1xuXHRcdFx0XHRcdFx0cy5hamF4LnN1Y2Nlc3MgPSBzdWNjZXNzX2Z1bmM7XG5cdFx0XHRcdFx0XHRpZighcy5hamF4LmRhdGFUeXBlKSB7IHMuYWpheC5kYXRhVHlwZSA9IFwianNvblwiOyB9XG5cdFx0XHRcdFx0XHRpZigkLmlzRnVuY3Rpb24ocy5hamF4LnVybCkpIHsgcy5hamF4LnVybCA9IHMuYWpheC51cmwuY2FsbCh0aGlzLCBvYmopOyB9XG5cdFx0XHRcdFx0XHRpZigkLmlzRnVuY3Rpb24ocy5hamF4LmRhdGEpKSB7IHMuYWpheC5kYXRhID0gcy5hamF4LmRhdGEuY2FsbCh0aGlzLCBvYmopOyB9XG5cdFx0XHRcdFx0XHQkLmFqYXgocy5hamF4KTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3BhcnNlX2pzb24gOiBmdW5jdGlvbiAoanMsIG9iaiwgaXNfY2FsbGJhY2spIHtcblx0XHRcdFx0dmFyIGQgPSBmYWxzZSwgXG5cdFx0XHRcdFx0cCA9IHRoaXMuX2dldF9zZXR0aW5ncygpLFxuXHRcdFx0XHRcdHMgPSBwLmpzb25fZGF0YSxcblx0XHRcdFx0XHR0ID0gcC5jb3JlLmh0bWxfdGl0bGVzLFxuXHRcdFx0XHRcdHRtcCwgaSwgaiwgdWwxLCB1bDI7XG5cblx0XHRcdFx0aWYoIWpzKSB7IHJldHVybiBkOyB9XG5cdFx0XHRcdGlmKHMucHJvZ3Jlc3NpdmVfdW5sb2FkICYmIG9iaiAmJiBvYmogIT09IC0xKSB7IFxuXHRcdFx0XHRcdG9iai5kYXRhKFwianN0cmVlX2NoaWxkcmVuXCIsIGQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCQuaXNBcnJheShqcykpIHtcblx0XHRcdFx0XHRkID0gJCgpO1xuXHRcdFx0XHRcdGlmKCFqcy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0ganMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0XHRcdFx0XHR0bXAgPSB0aGlzLl9wYXJzZV9qc29uKGpzW2ldLCBvYmosIHRydWUpO1xuXHRcdFx0XHRcdFx0aWYodG1wLmxlbmd0aCkgeyBkID0gZC5hZGQodG1wKTsgfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZih0eXBlb2YganMgPT0gXCJzdHJpbmdcIikgeyBqcyA9IHsgZGF0YSA6IGpzIH07IH1cblx0XHRcdFx0XHRpZighanMuZGF0YSAmJiBqcy5kYXRhICE9PSBcIlwiKSB7IHJldHVybiBkOyB9XG5cdFx0XHRcdFx0ZCA9ICQoXCI8bGkgLz5cIik7XG5cdFx0XHRcdFx0aWYoanMuYXR0cikgeyBkLmF0dHIoanMuYXR0cik7IH1cblx0XHRcdFx0XHRpZihqcy5tZXRhZGF0YSkgeyBkLmRhdGEoanMubWV0YWRhdGEpOyB9XG5cdFx0XHRcdFx0aWYoanMuc3RhdGUpIHsgZC5hZGRDbGFzcyhcImpzdHJlZS1cIiArIGpzLnN0YXRlKTsgfVxuXHRcdFx0XHRcdGlmKCEkLmlzQXJyYXkoanMuZGF0YSkpIHsgdG1wID0ganMuZGF0YTsganMuZGF0YSA9IFtdOyBqcy5kYXRhLnB1c2godG1wKTsgfVxuXHRcdFx0XHRcdCQuZWFjaChqcy5kYXRhLCBmdW5jdGlvbiAoaSwgbSkge1xuXHRcdFx0XHRcdFx0dG1wID0gJChcIjxhIC8+XCIpO1xuXHRcdFx0XHRcdFx0aWYoJC5pc0Z1bmN0aW9uKG0pKSB7IG0gPSBtLmNhbGwodGhpcywganMpOyB9XG5cdFx0XHRcdFx0XHRpZih0eXBlb2YgbSA9PSBcInN0cmluZ1wiKSB7IHRtcC5hdHRyKCdocmVmJywnIycpWyB0ID8gXCJodG1sXCIgOiBcInRleHRcIiBdKG0pOyB9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0aWYoIW0uYXR0cikgeyBtLmF0dHIgPSB7fTsgfVxuXHRcdFx0XHRcdFx0XHRpZighbS5hdHRyLmhyZWYpIHsgbS5hdHRyLmhyZWYgPSAnIyc7IH1cblx0XHRcdFx0XHRcdFx0dG1wLmF0dHIobS5hdHRyKVsgdCA/IFwiaHRtbFwiIDogXCJ0ZXh0XCIgXShtLnRpdGxlKTtcblx0XHRcdFx0XHRcdFx0aWYobS5sYW5ndWFnZSkgeyB0bXAuYWRkQ2xhc3MobS5sYW5ndWFnZSk7IH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRtcC5wcmVwZW5kKFwiPGlucyBjbGFzcz0nanN0cmVlLWljb24nPiYjMTYwOzwvaW5zPlwiKTtcblx0XHRcdFx0XHRcdGlmKCFtLmljb24gJiYganMuaWNvbikgeyBtLmljb24gPSBqcy5pY29uOyB9XG5cdFx0XHRcdFx0XHRpZihtLmljb24pIHsgXG5cdFx0XHRcdFx0XHRcdGlmKG0uaWNvbi5pbmRleE9mKFwiL1wiKSA9PT0gLTEpIHsgdG1wLmNoaWxkcmVuKFwiaW5zXCIpLmFkZENsYXNzKG0uaWNvbik7IH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7IHRtcC5jaGlsZHJlbihcImluc1wiKS5jc3MoXCJiYWNrZ3JvdW5kXCIsXCJ1cmwoJ1wiICsgbS5pY29uICsgXCInKSBjZW50ZXIgY2VudGVyIG5vLXJlcGVhdFwiKTsgfVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZC5hcHBlbmQodG1wKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRkLnByZXBlbmQoXCI8aW5zIGNsYXNzPSdqc3RyZWUtaWNvbic+JiMxNjA7PC9pbnM+XCIpO1xuXHRcdFx0XHRcdGlmKGpzLmNoaWxkcmVuKSB7IFxuXHRcdFx0XHRcdFx0aWYocy5wcm9ncmVzc2l2ZV9yZW5kZXIgJiYganMuc3RhdGUgIT09IFwib3BlblwiKSB7XG5cdFx0XHRcdFx0XHRcdGQuYWRkQ2xhc3MoXCJqc3RyZWUtY2xvc2VkXCIpLmRhdGEoXCJqc3RyZWVfY2hpbGRyZW5cIiwganMuY2hpbGRyZW4pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmKHMucHJvZ3Jlc3NpdmVfdW5sb2FkKSB7IGQuZGF0YShcImpzdHJlZV9jaGlsZHJlblwiLCBqcy5jaGlsZHJlbik7IH1cblx0XHRcdFx0XHRcdFx0aWYoJC5pc0FycmF5KGpzLmNoaWxkcmVuKSAmJiBqcy5jaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHR0bXAgPSB0aGlzLl9wYXJzZV9qc29uKGpzLmNoaWxkcmVuLCBvYmosIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdGlmKHRtcC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVsMiA9ICQoXCI8dWwgLz5cIik7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bDIuYXBwZW5kKHRtcCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRkLmFwcGVuZCh1bDIpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZighaXNfY2FsbGJhY2spIHtcblx0XHRcdFx0XHR1bDEgPSAkKFwiPHVsIC8+XCIpO1xuXHRcdFx0XHRcdHVsMS5hcHBlbmQoZCk7XG5cdFx0XHRcdFx0ZCA9IHVsMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZDtcblx0XHRcdH0sXG5cdFx0XHRnZXRfanNvbiA6IGZ1bmN0aW9uIChvYmosIGxpX2F0dHIsIGFfYXR0ciwgaXNfY2FsbGJhY2spIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFtdLCBcblx0XHRcdFx0XHRzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCksIFxuXHRcdFx0XHRcdF90aGlzID0gdGhpcyxcblx0XHRcdFx0XHR0bXAxLCB0bXAyLCBsaSwgYSwgdCwgbGFuZztcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0aWYoIW9iaiB8fCBvYmogPT09IC0xKSB7IG9iaiA9IHRoaXMuZ2V0X2NvbnRhaW5lcigpLmZpbmQoXCI+IHVsID4gbGlcIik7IH1cblx0XHRcdFx0bGlfYXR0ciA9ICQuaXNBcnJheShsaV9hdHRyKSA/IGxpX2F0dHIgOiBbIFwiaWRcIiwgXCJjbGFzc1wiIF07XG5cdFx0XHRcdGlmKCFpc19jYWxsYmFjayAmJiB0aGlzLmRhdGEudHlwZXMpIHsgbGlfYXR0ci5wdXNoKHMudHlwZXMudHlwZV9hdHRyKTsgfVxuXHRcdFx0XHRhX2F0dHIgPSAkLmlzQXJyYXkoYV9hdHRyKSA/IGFfYXR0ciA6IFsgXTtcblxuXHRcdFx0XHRvYmouZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bGkgPSAkKHRoaXMpO1xuXHRcdFx0XHRcdHRtcDEgPSB7IGRhdGEgOiBbXSB9O1xuXHRcdFx0XHRcdGlmKGxpX2F0dHIubGVuZ3RoKSB7IHRtcDEuYXR0ciA9IHsgfTsgfVxuXHRcdFx0XHRcdCQuZWFjaChsaV9hdHRyLCBmdW5jdGlvbiAoaSwgdikgeyBcblx0XHRcdFx0XHRcdHRtcDIgPSBsaS5hdHRyKHYpOyBcblx0XHRcdFx0XHRcdGlmKHRtcDIgJiYgdG1wMi5sZW5ndGggJiYgdG1wMi5yZXBsYWNlKC9qc3RyZWVbXiBdKi9pZywnJykubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdHRtcDEuYXR0clt2XSA9IChcIiBcIiArIHRtcDIpLnJlcGxhY2UoLyBqc3RyZWVbXiBdKi9pZywnJykucmVwbGFjZSgvXFxzKyQvaWcsXCIgXCIpLnJlcGxhY2UoL14gLyxcIlwiKS5yZXBsYWNlKC8gJC8sXCJcIik7IFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGlmKGxpLmhhc0NsYXNzKFwianN0cmVlLW9wZW5cIikpIHsgdG1wMS5zdGF0ZSA9IFwib3BlblwiOyB9XG5cdFx0XHRcdFx0aWYobGkuaGFzQ2xhc3MoXCJqc3RyZWUtY2xvc2VkXCIpKSB7IHRtcDEuc3RhdGUgPSBcImNsb3NlZFwiOyB9XG5cdFx0XHRcdFx0aWYobGkuZGF0YSgpKSB7IHRtcDEubWV0YWRhdGEgPSBsaS5kYXRhKCk7IH1cblx0XHRcdFx0XHRhID0gbGkuY2hpbGRyZW4oXCJhXCIpO1xuXHRcdFx0XHRcdGEuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHR0ID0gJCh0aGlzKTtcblx0XHRcdFx0XHRcdGlmKFxuXHRcdFx0XHRcdFx0XHRhX2F0dHIubGVuZ3RoIHx8IFxuXHRcdFx0XHRcdFx0XHQkLmluQXJyYXkoXCJsYW5ndWFnZXNcIiwgcy5wbHVnaW5zKSAhPT0gLTEgfHwgXG5cdFx0XHRcdFx0XHRcdHQuY2hpbGRyZW4oXCJpbnNcIikuZ2V0KDApLnN0eWxlLmJhY2tncm91bmRJbWFnZS5sZW5ndGggfHwgXG5cdFx0XHRcdFx0XHRcdCh0LmNoaWxkcmVuKFwiaW5zXCIpLmdldCgwKS5jbGFzc05hbWUgJiYgdC5jaGlsZHJlbihcImluc1wiKS5nZXQoMCkuY2xhc3NOYW1lLnJlcGxhY2UoL2pzdHJlZVteIF0qfCQvaWcsJycpLmxlbmd0aClcblx0XHRcdFx0XHRcdCkgeyBcblx0XHRcdFx0XHRcdFx0bGFuZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRpZigkLmluQXJyYXkoXCJsYW5ndWFnZXNcIiwgcy5wbHVnaW5zKSAhPT0gLTEgJiYgJC5pc0FycmF5KHMubGFuZ3VhZ2VzKSAmJiBzLmxhbmd1YWdlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHQkLmVhY2gocy5sYW5ndWFnZXMsIGZ1bmN0aW9uIChsLCBsdikge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYodC5oYXNDbGFzcyhsdikpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bGFuZyA9IGx2O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dG1wMiA9IHsgYXR0ciA6IHsgfSwgdGl0bGUgOiBfdGhpcy5nZXRfdGV4dCh0LCBsYW5nKSB9OyBcblx0XHRcdFx0XHRcdFx0JC5lYWNoKGFfYXR0ciwgZnVuY3Rpb24gKGssIHopIHtcblx0XHRcdFx0XHRcdFx0XHR0bXAyLmF0dHJbel0gPSAoXCIgXCIgKyAodC5hdHRyKHopIHx8IFwiXCIpKS5yZXBsYWNlKC8ganN0cmVlW14gXSovaWcsJycpLnJlcGxhY2UoL1xccyskL2lnLFwiIFwiKS5yZXBsYWNlKC9eIC8sXCJcIikucmVwbGFjZSgvICQvLFwiXCIpO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0aWYoJC5pbkFycmF5KFwibGFuZ3VhZ2VzXCIsIHMucGx1Z2lucykgIT09IC0xICYmICQuaXNBcnJheShzLmxhbmd1YWdlcykgJiYgcy5sYW5ndWFnZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0JC5lYWNoKHMubGFuZ3VhZ2VzLCBmdW5jdGlvbiAoaywgeikge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYodC5oYXNDbGFzcyh6KSkgeyB0bXAyLmxhbmd1YWdlID0gejsgcmV0dXJuIHRydWU7IH1cblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZih0LmNoaWxkcmVuKFwiaW5zXCIpLmdldCgwKS5jbGFzc05hbWUucmVwbGFjZSgvanN0cmVlW14gXSp8JC9pZywnJykucmVwbGFjZSgvXlxccyskL2lnLFwiXCIpLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdHRtcDIuaWNvbiA9IHQuY2hpbGRyZW4oXCJpbnNcIikuZ2V0KDApLmNsYXNzTmFtZS5yZXBsYWNlKC9qc3RyZWVbXiBdKnwkL2lnLCcnKS5yZXBsYWNlKC9cXHMrJC9pZyxcIiBcIikucmVwbGFjZSgvXiAvLFwiXCIpLnJlcGxhY2UoLyAkLyxcIlwiKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZih0LmNoaWxkcmVuKFwiaW5zXCIpLmdldCgwKS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0dG1wMi5pY29uID0gdC5jaGlsZHJlbihcImluc1wiKS5nZXQoMCkuc3R5bGUuYmFja2dyb3VuZEltYWdlLnJlcGxhY2UoXCJ1cmwoXCIsXCJcIikucmVwbGFjZShcIilcIixcIlwiKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRtcDIgPSBfdGhpcy5nZXRfdGV4dCh0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKGEubGVuZ3RoID4gMSkgeyB0bXAxLmRhdGEucHVzaCh0bXAyKTsgfVxuXHRcdFx0XHRcdFx0ZWxzZSB7IHRtcDEuZGF0YSA9IHRtcDI7IH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRsaSA9IGxpLmZpbmQoXCI+IHVsID4gbGlcIik7XG5cdFx0XHRcdFx0aWYobGkubGVuZ3RoKSB7IHRtcDEuY2hpbGRyZW4gPSBfdGhpcy5nZXRfanNvbihsaSwgbGlfYXR0ciwgYV9hdHRyLCB0cnVlKTsgfVxuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKHRtcDEpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufSkoalF1ZXJ5KTtcbi8vKi9cblxuLyogXG4gKiBqc1RyZWUgbGFuZ3VhZ2VzIHBsdWdpblxuICogQWRkcyBzdXBwb3J0IGZvciBtdWx0aXBsZSBsYW5ndWFnZSB2ZXJzaW9ucyBpbiBvbmUgdHJlZVxuICogVGhpcyBiYXNpY2FsbHkgYWxsb3dzIGZvciBtYW55IHRpdGxlcyBjb2V4aXN0aW5nIGluIG9uZSBub2RlLCBidXQgb25seSBvbmUgb2YgdGhlbSBiZWluZyB2aXNpYmxlIGF0IGFueSBnaXZlbiB0aW1lXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgbWFpbnRhaW5pbmcgdGhlIHNhbWUgc3RydWN0dXJlIGluIG1hbnkgbGFuZ3VhZ2VzIChoZW5jZSB0aGUgbmFtZSBvZiB0aGUgcGx1Z2luKVxuICovXG4oZnVuY3Rpb24gKCQpIHtcblx0dmFyIHNoID0gZmFsc2U7XG5cdCQuanN0cmVlLnBsdWdpbihcImxhbmd1YWdlc1wiLCB7XG5cdFx0X19pbml0IDogZnVuY3Rpb24gKCkgeyB0aGlzLl9sb2FkX2NzcygpOyAgfSxcblx0XHRkZWZhdWx0cyA6IFtdLFxuXHRcdF9mbiA6IHtcblx0XHRcdHNldF9sYW5nIDogZnVuY3Rpb24gKGkpIHsgXG5cdFx0XHRcdHZhciBsYW5ncyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLmxhbmd1YWdlcyxcblx0XHRcdFx0XHRzdCA9IGZhbHNlLFxuXHRcdFx0XHRcdHNlbGVjdG9yID0gXCIuanN0cmVlLVwiICsgdGhpcy5nZXRfaW5kZXgoKSArICcgYSc7XG5cdFx0XHRcdGlmKCEkLmlzQXJyYXkobGFuZ3MpIHx8IGxhbmdzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0aWYoJC5pbkFycmF5KGksbGFuZ3MpID09IC0xKSB7XG5cdFx0XHRcdFx0aWYoISFsYW5nc1tpXSkgeyBpID0gbGFuZ3NbaV07IH1cblx0XHRcdFx0XHRlbHNlIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoaSA9PSB0aGlzLmRhdGEubGFuZ3VhZ2VzLmN1cnJlbnRfbGFuZ3VhZ2UpIHsgcmV0dXJuIHRydWU7IH1cblx0XHRcdFx0c3QgPSAkLnZha2F0YS5jc3MuZ2V0X2NzcyhzZWxlY3RvciArIFwiLlwiICsgdGhpcy5kYXRhLmxhbmd1YWdlcy5jdXJyZW50X2xhbmd1YWdlLCBmYWxzZSwgc2gpO1xuXHRcdFx0XHRpZihzdCAhPT0gZmFsc2UpIHsgc3Quc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiOyB9XG5cdFx0XHRcdHN0ID0gJC52YWthdGEuY3NzLmdldF9jc3Moc2VsZWN0b3IgKyBcIi5cIiArIGksIGZhbHNlLCBzaCk7XG5cdFx0XHRcdGlmKHN0ICE9PSBmYWxzZSkgeyBzdC5zdHlsZS5kaXNwbGF5ID0gXCJcIjsgfVxuXHRcdFx0XHR0aGlzLmRhdGEubGFuZ3VhZ2VzLmN1cnJlbnRfbGFuZ3VhZ2UgPSBpO1xuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soaSk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdGdldF9sYW5nIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5kYXRhLmxhbmd1YWdlcy5jdXJyZW50X2xhbmd1YWdlO1xuXHRcdFx0fSxcblx0XHRcdF9nZXRfc3RyaW5nIDogZnVuY3Rpb24gKGtleSwgbGFuZykge1xuXHRcdFx0XHR2YXIgbGFuZ3MgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5sYW5ndWFnZXMsXG5cdFx0XHRcdFx0cyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLmNvcmUuc3RyaW5ncztcblx0XHRcdFx0aWYoJC5pc0FycmF5KGxhbmdzKSAmJiBsYW5ncy5sZW5ndGgpIHtcblx0XHRcdFx0XHRsYW5nID0gKGxhbmcgJiYgJC5pbkFycmF5KGxhbmcsbGFuZ3MpICE9IC0xKSA/IGxhbmcgOiB0aGlzLmRhdGEubGFuZ3VhZ2VzLmN1cnJlbnRfbGFuZ3VhZ2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoc1tsYW5nXSAmJiBzW2xhbmddW2tleV0pIHsgcmV0dXJuIHNbbGFuZ11ba2V5XTsgfVxuXHRcdFx0XHRpZihzW2tleV0pIHsgcmV0dXJuIHNba2V5XTsgfVxuXHRcdFx0XHRyZXR1cm4ga2V5O1xuXHRcdFx0fSxcblx0XHRcdGdldF90ZXh0IDogZnVuY3Rpb24gKG9iaiwgbGFuZykge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopIHx8IHRoaXMuZGF0YS51aS5sYXN0X3NlbGVjdGVkO1xuXHRcdFx0XHRpZighb2JqLnNpemUoKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0dmFyIGxhbmdzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkubGFuZ3VhZ2VzLFxuXHRcdFx0XHRcdHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5jb3JlLmh0bWxfdGl0bGVzO1xuXHRcdFx0XHRpZigkLmlzQXJyYXkobGFuZ3MpICYmIGxhbmdzLmxlbmd0aCkge1xuXHRcdFx0XHRcdGxhbmcgPSAobGFuZyAmJiAkLmluQXJyYXkobGFuZyxsYW5ncykgIT0gLTEpID8gbGFuZyA6IHRoaXMuZGF0YS5sYW5ndWFnZXMuY3VycmVudF9sYW5ndWFnZTtcblx0XHRcdFx0XHRvYmogPSBvYmouY2hpbGRyZW4oXCJhLlwiICsgbGFuZyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7IG9iaiA9IG9iai5jaGlsZHJlbihcImE6ZXEoMClcIik7IH1cblx0XHRcdFx0aWYocykge1xuXHRcdFx0XHRcdG9iaiA9IG9iai5jbG9uZSgpO1xuXHRcdFx0XHRcdG9iai5jaGlsZHJlbihcIklOU1wiKS5yZW1vdmUoKTtcblx0XHRcdFx0XHRyZXR1cm4gb2JqLmh0bWwoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRvYmogPSBvYmouY29udGVudHMoKS5maWx0ZXIoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm5vZGVUeXBlID09IDM7IH0pWzBdO1xuXHRcdFx0XHRcdHJldHVybiBvYmoubm9kZVZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2V0X3RleHQgOiBmdW5jdGlvbiAob2JqLCB2YWwsIGxhbmcpIHtcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKSB8fCB0aGlzLmRhdGEudWkubGFzdF9zZWxlY3RlZDtcblx0XHRcdFx0aWYoIW9iai5zaXplKCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdHZhciBsYW5ncyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLmxhbmd1YWdlcyxcblx0XHRcdFx0XHRzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkuY29yZS5odG1sX3RpdGxlcyxcblx0XHRcdFx0XHR0bXA7XG5cdFx0XHRcdGlmKCQuaXNBcnJheShsYW5ncykgJiYgbGFuZ3MubGVuZ3RoKSB7XG5cdFx0XHRcdFx0bGFuZyA9IChsYW5nICYmICQuaW5BcnJheShsYW5nLGxhbmdzKSAhPSAtMSkgPyBsYW5nIDogdGhpcy5kYXRhLmxhbmd1YWdlcy5jdXJyZW50X2xhbmd1YWdlO1xuXHRcdFx0XHRcdG9iaiA9IG9iai5jaGlsZHJlbihcImEuXCIgKyBsYW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHsgb2JqID0gb2JqLmNoaWxkcmVuKFwiYTplcSgwKVwiKTsgfVxuXHRcdFx0XHRpZihzKSB7XG5cdFx0XHRcdFx0dG1wID0gb2JqLmNoaWxkcmVuKFwiSU5TXCIpLmNsb25lKCk7XG5cdFx0XHRcdFx0b2JqLmh0bWwodmFsKS5wcmVwZW5kKHRtcCk7XG5cdFx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHsgXCJvYmpcIiA6IG9iaiwgXCJuYW1lXCIgOiB2YWwsIFwibGFuZ1wiIDogbGFuZyB9KTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRvYmogPSBvYmouY29udGVudHMoKS5maWx0ZXIoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm5vZGVUeXBlID09IDM7IH0pWzBdO1xuXHRcdFx0XHRcdHRoaXMuX19jYWxsYmFjayh7IFwib2JqXCIgOiBvYmosIFwibmFtZVwiIDogdmFsLCBcImxhbmdcIiA6IGxhbmcgfSk7XG5cdFx0XHRcdFx0cmV0dXJuIChvYmoubm9kZVZhbHVlID0gdmFsKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF9sb2FkX2NzcyA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGxhbmdzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkubGFuZ3VhZ2VzLFxuXHRcdFx0XHRcdHN0ciA9IFwiLyogbGFuZ3VhZ2VzIGNzcyAqL1wiLFxuXHRcdFx0XHRcdHNlbGVjdG9yID0gXCIuanN0cmVlLVwiICsgdGhpcy5nZXRfaW5kZXgoKSArICcgYScsXG5cdFx0XHRcdFx0bG47XG5cdFx0XHRcdGlmKCQuaXNBcnJheShsYW5ncykgJiYgbGFuZ3MubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dGhpcy5kYXRhLmxhbmd1YWdlcy5jdXJyZW50X2xhbmd1YWdlID0gbGFuZ3NbMF07XG5cdFx0XHRcdFx0Zm9yKGxuID0gMDsgbG4gPCBsYW5ncy5sZW5ndGg7IGxuKyspIHtcblx0XHRcdFx0XHRcdHN0ciArPSBzZWxlY3RvciArIFwiLlwiICsgbGFuZ3NbbG5dICsgXCIge1wiO1xuXHRcdFx0XHRcdFx0aWYobGFuZ3NbbG5dICE9IHRoaXMuZGF0YS5sYW5ndWFnZXMuY3VycmVudF9sYW5ndWFnZSkgeyBzdHIgKz0gXCIgZGlzcGxheTpub25lOyBcIjsgfVxuXHRcdFx0XHRcdFx0c3RyICs9IFwiIH0gXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNoID0gJC52YWthdGEuY3NzLmFkZF9zaGVldCh7ICdzdHInIDogc3RyLCAndGl0bGUnIDogXCJqc3RyZWUtbGFuZ3VhZ2VzXCIgfSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRjcmVhdGVfbm9kZSA6IGZ1bmN0aW9uIChvYmosIHBvc2l0aW9uLCBqcywgY2FsbGJhY2spIHtcblx0XHRcdFx0dmFyIHQgPSB0aGlzLl9fY2FsbF9vbGQodHJ1ZSwgb2JqLCBwb3NpdGlvbiwganMsIGZ1bmN0aW9uICh0KSB7XG5cdFx0XHRcdFx0dmFyIGxhbmdzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkubGFuZ3VhZ2VzLFxuXHRcdFx0XHRcdFx0YSA9IHQuY2hpbGRyZW4oXCJhXCIpLFxuXHRcdFx0XHRcdFx0bG47XG5cdFx0XHRcdFx0aWYoJC5pc0FycmF5KGxhbmdzKSAmJiBsYW5ncy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGZvcihsbiA9IDA7IGxuIDwgbGFuZ3MubGVuZ3RoOyBsbisrKSB7XG5cdFx0XHRcdFx0XHRcdGlmKCFhLmlzKFwiLlwiICsgbGFuZ3NbbG5dKSkge1xuXHRcdFx0XHRcdFx0XHRcdHQuYXBwZW5kKGEuZXEoMCkuY2xvbmUoKS5yZW1vdmVDbGFzcyhsYW5ncy5qb2luKFwiIFwiKSkuYWRkQ2xhc3MobGFuZ3NbbG5dKSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGEubm90KFwiLlwiICsgbGFuZ3Muam9pbihcIiwgLlwiKSkucmVtb3ZlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGNhbGxiYWNrKSB7IGNhbGxiYWNrLmNhbGwodGhpcywgdCk7IH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiB0O1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59KShqUXVlcnkpO1xuLy8qL1xuXG4vKlxuICoganNUcmVlIGNvb2tpZXMgcGx1Z2luXG4gKiBTdG9yZXMgdGhlIGN1cnJlbnRseSBvcGVuZWQvc2VsZWN0ZWQgbm9kZXMgaW4gYSBjb29raWUgYW5kIHRoZW4gcmVzdG9yZXMgdGhlbVxuICogRGVwZW5kcyBvbiB0aGUganF1ZXJ5LmNvb2tpZSBwbHVnaW5cbiAqL1xuKGZ1bmN0aW9uICgkKSB7XG5cdCQuanN0cmVlLnBsdWdpbihcImNvb2tpZXNcIiwge1xuXHRcdF9faW5pdCA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmKHR5cGVvZiAkLmNvb2tpZSA9PT0gXCJ1bmRlZmluZWRcIikgeyB0aHJvdyBcImpzVHJlZSBjb29raWU6IGpRdWVyeSBjb29raWUgcGx1Z2luIG5vdCBpbmNsdWRlZC5cIjsgfVxuXG5cdFx0XHR2YXIgcyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLmNvb2tpZXMsXG5cdFx0XHRcdHRtcDtcblx0XHRcdGlmKCEhcy5zYXZlX2xvYWRlZCkge1xuXHRcdFx0XHR0bXAgPSAkLmNvb2tpZShzLnNhdmVfbG9hZGVkKTtcblx0XHRcdFx0aWYodG1wICYmIHRtcC5sZW5ndGgpIHsgdGhpcy5kYXRhLmNvcmUudG9fbG9hZCA9IHRtcC5zcGxpdChcIixcIik7IH1cblx0XHRcdH1cblx0XHRcdGlmKCEhcy5zYXZlX29wZW5lZCkge1xuXHRcdFx0XHR0bXAgPSAkLmNvb2tpZShzLnNhdmVfb3BlbmVkKTtcblx0XHRcdFx0aWYodG1wICYmIHRtcC5sZW5ndGgpIHsgdGhpcy5kYXRhLmNvcmUudG9fb3BlbiA9IHRtcC5zcGxpdChcIixcIik7IH1cblx0XHRcdH1cblx0XHRcdGlmKCEhcy5zYXZlX3NlbGVjdGVkKSB7XG5cdFx0XHRcdHRtcCA9ICQuY29va2llKHMuc2F2ZV9zZWxlY3RlZCk7XG5cdFx0XHRcdGlmKHRtcCAmJiB0bXAubGVuZ3RoICYmIHRoaXMuZGF0YS51aSkgeyB0aGlzLmRhdGEudWkudG9fc2VsZWN0ID0gdG1wLnNwbGl0KFwiLFwiKTsgfVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKClcblx0XHRcdFx0Lm9uZSggKCB0aGlzLmRhdGEudWkgPyBcInJlc2VsZWN0XCIgOiBcInJlb3BlblwiICkgKyBcIi5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKClcblx0XHRcdFx0XHRcdC5iaW5kKFwib3Blbl9ub2RlLmpzdHJlZSBjbG9zZV9ub2RlLmpzdHJlZSBzZWxlY3Rfbm9kZS5qc3RyZWUgZGVzZWxlY3Rfbm9kZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkgeyBcblx0XHRcdFx0XHRcdFx0XHRpZih0aGlzLl9nZXRfc2V0dGluZ3MoKS5jb29raWVzLmF1dG9fc2F2ZSkgeyB0aGlzLnNhdmVfY29va2llKChlLmhhbmRsZU9iai5uYW1lc3BhY2UgKyBlLmhhbmRsZU9iai50eXBlKS5yZXBsYWNlKFwianN0cmVlXCIsXCJcIikpOyB9XG5cdFx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdH0sXG5cdFx0ZGVmYXVsdHMgOiB7XG5cdFx0XHRzYXZlX2xvYWRlZFx0XHQ6IFwianN0cmVlX2xvYWRcIixcblx0XHRcdHNhdmVfb3BlbmVkXHRcdDogXCJqc3RyZWVfb3BlblwiLFxuXHRcdFx0c2F2ZV9zZWxlY3RlZFx0OiBcImpzdHJlZV9zZWxlY3RcIixcblx0XHRcdGF1dG9fc2F2ZVx0XHQ6IHRydWUsXG5cdFx0XHRjb29raWVfb3B0aW9uc1x0OiB7fVxuXHRcdH0sXG5cdFx0X2ZuIDoge1xuXHRcdFx0c2F2ZV9jb29raWUgOiBmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRpZih0aGlzLmRhdGEuY29yZS5yZWZyZXNoaW5nKSB7IHJldHVybjsgfVxuXHRcdFx0XHR2YXIgcyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLmNvb2tpZXM7XG5cdFx0XHRcdGlmKCFjKSB7IC8vIGlmIGNhbGxlZCBtYW51YWxseSBhbmQgbm90IGJ5IGV2ZW50XG5cdFx0XHRcdFx0aWYocy5zYXZlX2xvYWRlZCkge1xuXHRcdFx0XHRcdFx0dGhpcy5zYXZlX2xvYWRlZCgpO1xuXHRcdFx0XHRcdFx0JC5jb29raWUocy5zYXZlX2xvYWRlZCwgdGhpcy5kYXRhLmNvcmUudG9fbG9hZC5qb2luKFwiLFwiKSwgcy5jb29raWVfb3B0aW9ucyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHMuc2F2ZV9vcGVuZWQpIHtcblx0XHRcdFx0XHRcdHRoaXMuc2F2ZV9vcGVuZWQoKTtcblx0XHRcdFx0XHRcdCQuY29va2llKHMuc2F2ZV9vcGVuZWQsIHRoaXMuZGF0YS5jb3JlLnRvX29wZW4uam9pbihcIixcIiksIHMuY29va2llX29wdGlvbnMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihzLnNhdmVfc2VsZWN0ZWQgJiYgdGhpcy5kYXRhLnVpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNhdmVfc2VsZWN0ZWQoKTtcblx0XHRcdFx0XHRcdCQuY29va2llKHMuc2F2ZV9zZWxlY3RlZCwgdGhpcy5kYXRhLnVpLnRvX3NlbGVjdC5qb2luKFwiLFwiKSwgcy5jb29raWVfb3B0aW9ucyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2goYykge1xuXHRcdFx0XHRcdGNhc2UgXCJvcGVuX25vZGVcIjpcblx0XHRcdFx0XHRjYXNlIFwiY2xvc2Vfbm9kZVwiOlxuXHRcdFx0XHRcdFx0aWYoISFzLnNhdmVfb3BlbmVkKSB7IFxuXHRcdFx0XHRcdFx0XHR0aGlzLnNhdmVfb3BlbmVkKCk7IFxuXHRcdFx0XHRcdFx0XHQkLmNvb2tpZShzLnNhdmVfb3BlbmVkLCB0aGlzLmRhdGEuY29yZS50b19vcGVuLmpvaW4oXCIsXCIpLCBzLmNvb2tpZV9vcHRpb25zKTsgXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZighIXMuc2F2ZV9sb2FkZWQpIHsgXG5cdFx0XHRcdFx0XHRcdHRoaXMuc2F2ZV9sb2FkZWQoKTsgXG5cdFx0XHRcdFx0XHRcdCQuY29va2llKHMuc2F2ZV9sb2FkZWQsIHRoaXMuZGF0YS5jb3JlLnRvX2xvYWQuam9pbihcIixcIiksIHMuY29va2llX29wdGlvbnMpOyBcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJzZWxlY3Rfbm9kZVwiOlxuXHRcdFx0XHRcdGNhc2UgXCJkZXNlbGVjdF9ub2RlXCI6XG5cdFx0XHRcdFx0XHRpZighIXMuc2F2ZV9zZWxlY3RlZCAmJiB0aGlzLmRhdGEudWkpIHsgXG5cdFx0XHRcdFx0XHRcdHRoaXMuc2F2ZV9zZWxlY3RlZCgpOyBcblx0XHRcdFx0XHRcdFx0JC5jb29raWUocy5zYXZlX3NlbGVjdGVkLCB0aGlzLmRhdGEudWkudG9fc2VsZWN0LmpvaW4oXCIsXCIpLCBzLmNvb2tpZV9vcHRpb25zKTsgXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdC8vIGluY2x1ZGUgY29va2llcyBieSBkZWZhdWx0XG5cdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcImNvb2tpZXNcIik7XG59KShqUXVlcnkpO1xuLy8qL1xuXG4vKlxuICoganNUcmVlIHNvcnQgcGx1Z2luXG4gKiBTb3J0cyBpdGVtcyBhbHBoYWJldGljYWxseSAob3IgdXNpbmcgYW55IG90aGVyIGZ1bmN0aW9uKVxuICovXG4oZnVuY3Rpb24gKCQpIHtcblx0JC5qc3RyZWUucGx1Z2luKFwic29ydFwiLCB7XG5cdFx0X19pbml0IDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKClcblx0XHRcdFx0LmJpbmQoXCJsb2FkX25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdHZhciBvYmogPSB0aGlzLl9nZXRfbm9kZShkYXRhLnJzbHQub2JqKTtcblx0XHRcdFx0XHRcdG9iaiA9IG9iaiA9PT0gLTEgPyB0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcInVsXCIpIDogb2JqLmNoaWxkcmVuKFwidWxcIik7XG5cdFx0XHRcdFx0XHR0aGlzLnNvcnQob2JqKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJyZW5hbWVfbm9kZS5qc3RyZWUgY3JlYXRlX25vZGUuanN0cmVlIGNyZWF0ZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0dGhpcy5zb3J0KGRhdGEucnNsdC5vYmoucGFyZW50KCkpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuYmluZChcIm1vdmVfbm9kZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0dmFyIG0gPSBkYXRhLnJzbHQubnAgPT0gLTEgPyB0aGlzLmdldF9jb250YWluZXIoKSA6IGRhdGEucnNsdC5ucDtcblx0XHRcdFx0XHRcdHRoaXMuc29ydChtLmNoaWxkcmVuKFwidWxcIikpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHR9LFxuXHRcdGRlZmF1bHRzIDogZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIHRoaXMuZ2V0X3RleHQoYSkgPiB0aGlzLmdldF90ZXh0KGIpID8gMSA6IC0xOyB9LFxuXHRcdF9mbiA6IHtcblx0XHRcdHNvcnQgOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdHZhciBzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkuc29ydCxcblx0XHRcdFx0XHR0ID0gdGhpcztcblx0XHRcdFx0b2JqLmFwcGVuZCgkLm1ha2VBcnJheShvYmouY2hpbGRyZW4oXCJsaVwiKSkuc29ydCgkLnByb3h5KHMsIHQpKSk7XG5cdFx0XHRcdG9iai5maW5kKFwiPiBsaSA+IHVsXCIpLmVhY2goZnVuY3Rpb24oKSB7IHQuc29ydCgkKHRoaXMpKTsgfSk7XG5cdFx0XHRcdHRoaXMuY2xlYW5fbm9kZShvYmopO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59KShqUXVlcnkpO1xuLy8qL1xuXG4vKlxuICoganNUcmVlIERORCBwbHVnaW5cbiAqIERyYWcgYW5kIGRyb3AgcGx1Z2luIGZvciBtb3ZpbmcvY29weWluZyBub2Rlc1xuICovXG4oZnVuY3Rpb24gKCQpIHtcblx0dmFyIG8gPSBmYWxzZSxcblx0XHRyID0gZmFsc2UsXG5cdFx0bSA9IGZhbHNlLFxuXHRcdG1sID0gZmFsc2UsXG5cdFx0c2xpID0gZmFsc2UsXG5cdFx0c3RpID0gZmFsc2UsXG5cdFx0ZGlyMSA9IGZhbHNlLFxuXHRcdGRpcjIgPSBmYWxzZSxcblx0XHRsYXN0X3BvcyA9IGZhbHNlO1xuXHQkLnZha2F0YS5kbmQgPSB7XG5cdFx0aXNfZG93biA6IGZhbHNlLFxuXHRcdGlzX2RyYWcgOiBmYWxzZSxcblx0XHRoZWxwZXIgOiBmYWxzZSxcblx0XHRzY3JvbGxfc3BkIDogMTAsXG5cdFx0aW5pdF94IDogMCxcblx0XHRpbml0X3kgOiAwLFxuXHRcdHRocmVzaG9sZCA6IDUsXG5cdFx0aGVscGVyX2xlZnQgOiA1LFxuXHRcdGhlbHBlcl90b3AgOiAxMCxcblx0XHR1c2VyX2RhdGEgOiB7fSxcblxuXHRcdGRyYWdfc3RhcnQgOiBmdW5jdGlvbiAoZSwgZGF0YSwgaHRtbCkgeyBcblx0XHRcdGlmKCQudmFrYXRhLmRuZC5pc19kcmFnKSB7ICQudmFrYXRhLmRyYWdfc3RvcCh7fSk7IH1cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGUuY3VycmVudFRhcmdldC51bnNlbGVjdGFibGUgPSBcIm9uXCI7XG5cdFx0XHRcdGUuY3VycmVudFRhcmdldC5vbnNlbGVjdHN0YXJ0ID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfTtcblx0XHRcdFx0aWYoZS5jdXJyZW50VGFyZ2V0LnN0eWxlKSB7IGUuY3VycmVudFRhcmdldC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gXCJub25lXCI7IH1cblx0XHRcdH0gY2F0Y2goZXJyKSB7IH1cblx0XHRcdCQudmFrYXRhLmRuZC5pbml0X3ggPSBlLnBhZ2VYO1xuXHRcdFx0JC52YWthdGEuZG5kLmluaXRfeSA9IGUucGFnZVk7XG5cdFx0XHQkLnZha2F0YS5kbmQudXNlcl9kYXRhID0gZGF0YTtcblx0XHRcdCQudmFrYXRhLmRuZC5pc19kb3duID0gdHJ1ZTtcblx0XHRcdCQudmFrYXRhLmRuZC5oZWxwZXIgPSAkKFwiPGRpdiBpZD0ndmFrYXRhLWRyYWdnZWQnIC8+XCIpLmh0bWwoaHRtbCk7IC8vLmZhZGVUbygxMCwwLjI1KTtcblx0XHRcdCQoZG9jdW1lbnQpLmJpbmQoXCJtb3VzZW1vdmVcIiwgJC52YWthdGEuZG5kLmRyYWcpO1xuXHRcdFx0JChkb2N1bWVudCkuYmluZChcIm1vdXNldXBcIiwgJC52YWthdGEuZG5kLmRyYWdfc3RvcCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRkcmFnIDogZnVuY3Rpb24gKGUpIHsgXG5cdFx0XHRpZighJC52YWthdGEuZG5kLmlzX2Rvd24pIHsgcmV0dXJuOyB9XG5cdFx0XHRpZighJC52YWthdGEuZG5kLmlzX2RyYWcpIHtcblx0XHRcdFx0aWYoTWF0aC5hYnMoZS5wYWdlWCAtICQudmFrYXRhLmRuZC5pbml0X3gpID4gNSB8fCBNYXRoLmFicyhlLnBhZ2VZIC0gJC52YWthdGEuZG5kLmluaXRfeSkgPiA1KSB7IFxuXHRcdFx0XHRcdCQudmFrYXRhLmRuZC5oZWxwZXIuYXBwZW5kVG8oXCJib2R5XCIpO1xuXHRcdFx0XHRcdCQudmFrYXRhLmRuZC5pc19kcmFnID0gdHJ1ZTtcblx0XHRcdFx0XHQkKGRvY3VtZW50KS50cmlnZ2VySGFuZGxlcihcImRyYWdfc3RhcnQudmFrYXRhXCIsIHsgXCJldmVudFwiIDogZSwgXCJkYXRhXCIgOiAkLnZha2F0YS5kbmQudXNlcl9kYXRhIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgeyByZXR1cm47IH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gbWF5YmUgdXNlIGEgc2Nyb2xsaW5nIHBhcmVudCBlbGVtZW50IGluc3RlYWQgb2YgZG9jdW1lbnQ/XG5cdFx0XHRpZihlLnR5cGUgPT09IFwibW91c2Vtb3ZlXCIpIHsgLy8gdGhvdWdodCBvZiBhZGRpbmcgc2Nyb2xsIGluIG9yZGVyIHRvIG1vdmUgdGhlIGhlbHBlciwgYnV0IG1vdXNlIHBvaXNpdGlvbiBpcyBuL2Fcblx0XHRcdFx0dmFyIGQgPSAkKGRvY3VtZW50KSwgdCA9IGQuc2Nyb2xsVG9wKCksIGwgPSBkLnNjcm9sbExlZnQoKTtcblx0XHRcdFx0aWYoZS5wYWdlWSAtIHQgPCAyMCkgeyBcblx0XHRcdFx0XHRpZihzdGkgJiYgZGlyMSA9PT0gXCJkb3duXCIpIHsgY2xlYXJJbnRlcnZhbChzdGkpOyBzdGkgPSBmYWxzZTsgfVxuXHRcdFx0XHRcdGlmKCFzdGkpIHsgZGlyMSA9IFwidXBcIjsgc3RpID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkgeyAkKGRvY3VtZW50KS5zY3JvbGxUb3AoJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgLSAkLnZha2F0YS5kbmQuc2Nyb2xsX3NwZCk7IH0sIDE1MCk7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHsgXG5cdFx0XHRcdFx0aWYoc3RpICYmIGRpcjEgPT09IFwidXBcIikgeyBjbGVhckludGVydmFsKHN0aSk7IHN0aSA9IGZhbHNlOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoJCh3aW5kb3cpLmhlaWdodCgpIC0gKGUucGFnZVkgLSB0KSA8IDIwKSB7XG5cdFx0XHRcdFx0aWYoc3RpICYmIGRpcjEgPT09IFwidXBcIikgeyBjbGVhckludGVydmFsKHN0aSk7IHN0aSA9IGZhbHNlOyB9XG5cdFx0XHRcdFx0aWYoIXN0aSkgeyBkaXIxID0gXCJkb3duXCI7IHN0aSA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHsgJChkb2N1bWVudCkuc2Nyb2xsVG9wKCQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpICsgJC52YWthdGEuZG5kLnNjcm9sbF9zcGQpOyB9LCAxNTApOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7IFxuXHRcdFx0XHRcdGlmKHN0aSAmJiBkaXIxID09PSBcImRvd25cIikgeyBjbGVhckludGVydmFsKHN0aSk7IHN0aSA9IGZhbHNlOyB9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihlLnBhZ2VYIC0gbCA8IDIwKSB7XG5cdFx0XHRcdFx0aWYoc2xpICYmIGRpcjIgPT09IFwicmlnaHRcIikgeyBjbGVhckludGVydmFsKHNsaSk7IHNsaSA9IGZhbHNlOyB9XG5cdFx0XHRcdFx0aWYoIXNsaSkgeyBkaXIyID0gXCJsZWZ0XCI7IHNsaSA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHsgJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgLSAkLnZha2F0YS5kbmQuc2Nyb2xsX3NwZCk7IH0sIDE1MCk7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHsgXG5cdFx0XHRcdFx0aWYoc2xpICYmIGRpcjIgPT09IFwibGVmdFwiKSB7IGNsZWFySW50ZXJ2YWwoc2xpKTsgc2xpID0gZmFsc2U7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZigkKHdpbmRvdykud2lkdGgoKSAtIChlLnBhZ2VYIC0gbCkgPCAyMCkge1xuXHRcdFx0XHRcdGlmKHNsaSAmJiBkaXIyID09PSBcImxlZnRcIikgeyBjbGVhckludGVydmFsKHNsaSk7IHNsaSA9IGZhbHNlOyB9XG5cdFx0XHRcdFx0aWYoIXNsaSkgeyBkaXIyID0gXCJyaWdodFwiOyBzbGkgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7ICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpICsgJC52YWthdGEuZG5kLnNjcm9sbF9zcGQpOyB9LCAxNTApOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7IFxuXHRcdFx0XHRcdGlmKHNsaSAmJiBkaXIyID09PSBcInJpZ2h0XCIpIHsgY2xlYXJJbnRlcnZhbChzbGkpOyBzbGkgPSBmYWxzZTsgfVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCQudmFrYXRhLmRuZC5oZWxwZXIuY3NzKHsgbGVmdCA6IChlLnBhZ2VYICsgJC52YWthdGEuZG5kLmhlbHBlcl9sZWZ0KSArIFwicHhcIiwgdG9wIDogKGUucGFnZVkgKyAkLnZha2F0YS5kbmQuaGVscGVyX3RvcCkgKyBcInB4XCIgfSk7XG5cdFx0XHQkKGRvY3VtZW50KS50cmlnZ2VySGFuZGxlcihcImRyYWcudmFrYXRhXCIsIHsgXCJldmVudFwiIDogZSwgXCJkYXRhXCIgOiAkLnZha2F0YS5kbmQudXNlcl9kYXRhIH0pO1xuXHRcdH0sXG5cdFx0ZHJhZ19zdG9wIDogZnVuY3Rpb24gKGUpIHtcblx0XHRcdGlmKHNsaSkgeyBjbGVhckludGVydmFsKHNsaSk7IH1cblx0XHRcdGlmKHN0aSkgeyBjbGVhckludGVydmFsKHN0aSk7IH1cblx0XHRcdCQoZG9jdW1lbnQpLnVuYmluZChcIm1vdXNlbW92ZVwiLCAkLnZha2F0YS5kbmQuZHJhZyk7XG5cdFx0XHQkKGRvY3VtZW50KS51bmJpbmQoXCJtb3VzZXVwXCIsICQudmFrYXRhLmRuZC5kcmFnX3N0b3ApO1xuXHRcdFx0JChkb2N1bWVudCkudHJpZ2dlckhhbmRsZXIoXCJkcmFnX3N0b3AudmFrYXRhXCIsIHsgXCJldmVudFwiIDogZSwgXCJkYXRhXCIgOiAkLnZha2F0YS5kbmQudXNlcl9kYXRhIH0pO1xuXHRcdFx0JC52YWthdGEuZG5kLmhlbHBlci5yZW1vdmUoKTtcblx0XHRcdCQudmFrYXRhLmRuZC5pbml0X3ggPSAwO1xuXHRcdFx0JC52YWthdGEuZG5kLmluaXRfeSA9IDA7XG5cdFx0XHQkLnZha2F0YS5kbmQudXNlcl9kYXRhID0ge307XG5cdFx0XHQkLnZha2F0YS5kbmQuaXNfZG93biA9IGZhbHNlO1xuXHRcdFx0JC52YWthdGEuZG5kLmlzX2RyYWcgPSBmYWxzZTtcblx0XHR9XG5cdH07XG5cdCQoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNzc19zdHJpbmcgPSAnI3Zha2F0YS1kcmFnZ2VkIHsgZGlzcGxheTpibG9jazsgbWFyZ2luOjAgMCAwIDA7IHBhZGRpbmc6NHB4IDRweCA0cHggMjRweDsgcG9zaXRpb246YWJzb2x1dGU7IHRvcDotMjAwMHB4OyBsaW5lLWhlaWdodDoxNnB4OyB6LWluZGV4OjEwMDAwOyB9ICc7XG5cdFx0JC52YWthdGEuY3NzLmFkZF9zaGVldCh7IHN0ciA6IGNzc19zdHJpbmcsIHRpdGxlIDogXCJ2YWthdGFcIiB9KTtcblx0fSk7XG5cblx0JC5qc3RyZWUucGx1Z2luKFwiZG5kXCIsIHtcblx0XHRfX2luaXQgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmRhdGEuZG5kID0ge1xuXHRcdFx0XHRhY3RpdmUgOiBmYWxzZSxcblx0XHRcdFx0YWZ0ZXIgOiBmYWxzZSxcblx0XHRcdFx0aW5zaWRlIDogZmFsc2UsXG5cdFx0XHRcdGJlZm9yZSA6IGZhbHNlLFxuXHRcdFx0XHRvZmYgOiBmYWxzZSxcblx0XHRcdFx0cHJlcGFyZWQgOiBmYWxzZSxcblx0XHRcdFx0dyA6IDAsXG5cdFx0XHRcdHRvMSA6IGZhbHNlLFxuXHRcdFx0XHR0bzIgOiBmYWxzZSxcblx0XHRcdFx0Y29mIDogZmFsc2UsXG5cdFx0XHRcdGN3IDogZmFsc2UsXG5cdFx0XHRcdGNoIDogZmFsc2UsXG5cdFx0XHRcdGkxIDogZmFsc2UsXG5cdFx0XHRcdGkyIDogZmFsc2UsXG5cdFx0XHRcdG10byA6IGZhbHNlXG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKClcblx0XHRcdFx0LmJpbmQoXCJtb3VzZWVudGVyLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRpZigkLnZha2F0YS5kbmQuaXNfZHJhZyAmJiAkLnZha2F0YS5kbmQudXNlcl9kYXRhLmpzdHJlZSkge1xuXHRcdFx0XHRcdFx0XHRpZih0aGlzLmRhdGEudGhlbWVzKSB7XG5cdFx0XHRcdFx0XHRcdFx0bS5hdHRyKFwiY2xhc3NcIiwgXCJqc3RyZWUtXCIgKyB0aGlzLmRhdGEudGhlbWVzLnRoZW1lKTsgXG5cdFx0XHRcdFx0XHRcdFx0aWYobWwpIHsgbWwuYXR0cihcImNsYXNzXCIsIFwianN0cmVlLVwiICsgdGhpcy5kYXRhLnRoZW1lcy50aGVtZSk7IH1cblx0XHRcdFx0XHRcdFx0XHQkLnZha2F0YS5kbmQuaGVscGVyLmF0dHIoXCJjbGFzc1wiLCBcImpzdHJlZS1kbmQtaGVscGVyIGpzdHJlZS1cIiArIHRoaXMuZGF0YS50aGVtZXMudGhlbWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdC8vaWYoJChlLmN1cnJlbnRUYXJnZXQpLmZpbmQoXCI+IHVsID4gbGlcIikubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGlmKGUuY3VycmVudFRhcmdldCA9PT0gZS50YXJnZXQgJiYgJC52YWthdGEuZG5kLnVzZXJfZGF0YS5vYmogJiYgJCgkLnZha2F0YS5kbmQudXNlcl9kYXRhLm9iaikubGVuZ3RoICYmICQoJC52YWthdGEuZG5kLnVzZXJfZGF0YS5vYmopLnBhcmVudHMoXCIuanN0cmVlOmVxKDApXCIpWzBdICE9PSBlLnRhcmdldCkgeyAvLyBub2RlIHNob3VsZCBub3QgYmUgZnJvbSB0aGUgc2FtZSB0cmVlXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHRyID0gJC5qc3RyZWUuX3JlZmVyZW5jZShlLnRhcmdldCksIGRjO1xuXHRcdFx0XHRcdFx0XHRcdGlmKHRyLmRhdGEuZG5kLmZvcmVpZ24pIHtcblx0XHRcdFx0XHRcdFx0XHRcdGRjID0gdHIuX2dldF9zZXR0aW5ncygpLmRuZC5kcmFnX2NoZWNrLmNhbGwodGhpcywgeyBcIm9cIiA6IG8sIFwiclwiIDogdHIuZ2V0X2NvbnRhaW5lcigpLCBpc19yb290IDogdHJ1ZSB9KTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKGRjID09PSB0cnVlIHx8IGRjLmluc2lkZSA9PT0gdHJ1ZSB8fCBkYy5iZWZvcmUgPT09IHRydWUgfHwgZGMuYWZ0ZXIgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0JC52YWthdGEuZG5kLmhlbHBlci5jaGlsZHJlbihcImluc1wiKS5hdHRyKFwiY2xhc3NcIixcImpzdHJlZS1va1wiKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0ci5wcmVwYXJlX21vdmUobywgdHIuZ2V0X2NvbnRhaW5lcigpLCBcImxhc3RcIik7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZih0ci5jaGVja19tb3ZlKCkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0JC52YWthdGEuZG5kLmhlbHBlci5jaGlsZHJlbihcImluc1wiKS5hdHRyKFwiY2xhc3NcIixcImpzdHJlZS1va1wiKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJtb3VzZXVwLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHQvL2lmKCQudmFrYXRhLmRuZC5pc19kcmFnICYmICQudmFrYXRhLmRuZC51c2VyX2RhdGEuanN0cmVlICYmICQoZS5jdXJyZW50VGFyZ2V0KS5maW5kKFwiPiB1bCA+IGxpXCIpLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0aWYoJC52YWthdGEuZG5kLmlzX2RyYWcgJiYgJC52YWthdGEuZG5kLnVzZXJfZGF0YS5qc3RyZWUgJiYgZS5jdXJyZW50VGFyZ2V0ID09PSBlLnRhcmdldCAmJiAkLnZha2F0YS5kbmQudXNlcl9kYXRhLm9iaiAmJiAkKCQudmFrYXRhLmRuZC51c2VyX2RhdGEub2JqKS5sZW5ndGggJiYgJCgkLnZha2F0YS5kbmQudXNlcl9kYXRhLm9iaikucGFyZW50cyhcIi5qc3RyZWU6ZXEoMClcIilbMF0gIT09IGUudGFyZ2V0KSB7IC8vIG5vZGUgc2hvdWxkIG5vdCBiZSBmcm9tIHRoZSBzYW1lIHRyZWVcblx0XHRcdFx0XHRcdFx0dmFyIHRyID0gJC5qc3RyZWUuX3JlZmVyZW5jZShlLmN1cnJlbnRUYXJnZXQpLCBkYztcblx0XHRcdFx0XHRcdFx0aWYodHIuZGF0YS5kbmQuZm9yZWlnbikge1xuXHRcdFx0XHRcdFx0XHRcdGRjID0gdHIuX2dldF9zZXR0aW5ncygpLmRuZC5kcmFnX2NoZWNrLmNhbGwodGhpcywgeyBcIm9cIiA6IG8sIFwiclwiIDogdHIuZ2V0X2NvbnRhaW5lcigpLCBpc19yb290IDogdHJ1ZSB9KTtcblx0XHRcdFx0XHRcdFx0XHRpZihkYyA9PT0gdHJ1ZSB8fCBkYy5pbnNpZGUgPT09IHRydWUgfHwgZGMuYmVmb3JlID09PSB0cnVlIHx8IGRjLmFmdGVyID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0ci5fZ2V0X3NldHRpbmdzKCkuZG5kLmRyYWdfZmluaXNoLmNhbGwodGhpcywgeyBcIm9cIiA6IG8sIFwiclwiIDogdHIuZ2V0X2NvbnRhaW5lcigpLCBpc19yb290IDogdHJ1ZSB9KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dHIubW92ZV9ub2RlKG8sIHRyLmdldF9jb250YWluZXIoKSwgXCJsYXN0XCIsIGVbdHIuX2dldF9zZXR0aW5ncygpLmRuZC5jb3B5X21vZGlmaWVyICsgXCJLZXlcIl0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwibW91c2VsZWF2ZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0aWYoZS5yZWxhdGVkVGFyZ2V0ICYmIGUucmVsYXRlZFRhcmdldC5pZCAmJiBlLnJlbGF0ZWRUYXJnZXQuaWQgPT09IFwianN0cmVlLW1hcmtlci1saW5lXCIpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlOyBcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKCQudmFrYXRhLmRuZC5pc19kcmFnICYmICQudmFrYXRhLmRuZC51c2VyX2RhdGEuanN0cmVlKSB7XG5cdFx0XHRcdFx0XHRcdGlmKHRoaXMuZGF0YS5kbmQuaTEpIHsgY2xlYXJJbnRlcnZhbCh0aGlzLmRhdGEuZG5kLmkxKTsgfVxuXHRcdFx0XHRcdFx0XHRpZih0aGlzLmRhdGEuZG5kLmkyKSB7IGNsZWFySW50ZXJ2YWwodGhpcy5kYXRhLmRuZC5pMik7IH1cblx0XHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZC50bzEpIHsgY2xlYXJUaW1lb3V0KHRoaXMuZGF0YS5kbmQudG8xKTsgfVxuXHRcdFx0XHRcdFx0XHRpZih0aGlzLmRhdGEuZG5kLnRvMikgeyBjbGVhclRpbWVvdXQodGhpcy5kYXRhLmRuZC50bzIpOyB9XG5cdFx0XHRcdFx0XHRcdGlmKCQudmFrYXRhLmRuZC5oZWxwZXIuY2hpbGRyZW4oXCJpbnNcIikuaGFzQ2xhc3MoXCJqc3RyZWUtb2tcIikpIHtcblx0XHRcdFx0XHRcdFx0XHQkLnZha2F0YS5kbmQuaGVscGVyLmNoaWxkcmVuKFwiaW5zXCIpLmF0dHIoXCJjbGFzc1wiLFwianN0cmVlLWludmFsaWRcIik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJtb3VzZW1vdmUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGlmKCQudmFrYXRhLmRuZC5pc19kcmFnICYmICQudmFrYXRhLmRuZC51c2VyX2RhdGEuanN0cmVlKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBjbnQgPSB0aGlzLmdldF9jb250YWluZXIoKVswXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBIb3Jpem9udGFsIHNjcm9sbFxuXHRcdFx0XHRcdFx0XHRpZihlLnBhZ2VYICsgMjQgPiB0aGlzLmRhdGEuZG5kLmNvZi5sZWZ0ICsgdGhpcy5kYXRhLmRuZC5jdykge1xuXHRcdFx0XHRcdFx0XHRcdGlmKHRoaXMuZGF0YS5kbmQuaTEpIHsgY2xlYXJJbnRlcnZhbCh0aGlzLmRhdGEuZG5kLmkxKTsgfVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQuaTEgPSBzZXRJbnRlcnZhbCgkLnByb3h5KGZ1bmN0aW9uICgpIHsgdGhpcy5zY3JvbGxMZWZ0ICs9ICQudmFrYXRhLmRuZC5zY3JvbGxfc3BkOyB9LCBjbnQpLCAxMDApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2UgaWYoZS5wYWdlWCAtIDI0IDwgdGhpcy5kYXRhLmRuZC5jb2YubGVmdCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmKHRoaXMuZGF0YS5kbmQuaTEpIHsgY2xlYXJJbnRlcnZhbCh0aGlzLmRhdGEuZG5kLmkxKTsgfVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQuaTEgPSBzZXRJbnRlcnZhbCgkLnByb3h5KGZ1bmN0aW9uICgpIHsgdGhpcy5zY3JvbGxMZWZ0IC09ICQudmFrYXRhLmRuZC5zY3JvbGxfc3BkOyB9LCBjbnQpLCAxMDApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGlmKHRoaXMuZGF0YS5kbmQuaTEpIHsgY2xlYXJJbnRlcnZhbCh0aGlzLmRhdGEuZG5kLmkxKTsgfVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gVmVydGljYWwgc2Nyb2xsXG5cdFx0XHRcdFx0XHRcdGlmKGUucGFnZVkgKyAyNCA+IHRoaXMuZGF0YS5kbmQuY29mLnRvcCArIHRoaXMuZGF0YS5kbmQuY2gpIHtcblx0XHRcdFx0XHRcdFx0XHRpZih0aGlzLmRhdGEuZG5kLmkyKSB7IGNsZWFySW50ZXJ2YWwodGhpcy5kYXRhLmRuZC5pMik7IH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLmkyID0gc2V0SW50ZXJ2YWwoJC5wcm94eShmdW5jdGlvbiAoKSB7IHRoaXMuc2Nyb2xsVG9wICs9ICQudmFrYXRhLmRuZC5zY3JvbGxfc3BkOyB9LCBjbnQpLCAxMDApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2UgaWYoZS5wYWdlWSAtIDI0IDwgdGhpcy5kYXRhLmRuZC5jb2YudG9wKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZC5pMikgeyBjbGVhckludGVydmFsKHRoaXMuZGF0YS5kbmQuaTIpOyB9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC5pMiA9IHNldEludGVydmFsKCQucHJveHkoZnVuY3Rpb24gKCkgeyB0aGlzLnNjcm9sbFRvcCAtPSAkLnZha2F0YS5kbmQuc2Nyb2xsX3NwZDsgfSwgY250KSwgMTAwKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRpZih0aGlzLmRhdGEuZG5kLmkyKSB7IGNsZWFySW50ZXJ2YWwodGhpcy5kYXRhLmRuZC5pMik7IH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwic2Nyb2xsLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7IFxuXHRcdFx0XHRcdFx0aWYoJC52YWthdGEuZG5kLmlzX2RyYWcgJiYgJC52YWthdGEuZG5kLnVzZXJfZGF0YS5qc3RyZWUgJiYgbSAmJiBtbCkge1xuXHRcdFx0XHRcdFx0XHRtLmhpZGUoKTtcblx0XHRcdFx0XHRcdFx0bWwuaGlkZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuZGVsZWdhdGUoXCJhXCIsIFwibW91c2Vkb3duLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7IFxuXHRcdFx0XHRcdFx0aWYoZS53aGljaCA9PT0gMSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnN0YXJ0X2RyYWcoZS5jdXJyZW50VGFyZ2V0LCBlKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuZGVsZWdhdGUoXCJhXCIsIFwibW91c2VlbnRlci5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkgeyBcblx0XHRcdFx0XHRcdGlmKCQudmFrYXRhLmRuZC5pc19kcmFnICYmICQudmFrYXRhLmRuZC51c2VyX2RhdGEuanN0cmVlKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZG5kX2VudGVyKGUuY3VycmVudFRhcmdldCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5kZWxlZ2F0ZShcImFcIiwgXCJtb3VzZW1vdmUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHsgXG5cdFx0XHRcdFx0XHRpZigkLnZha2F0YS5kbmQuaXNfZHJhZyAmJiAkLnZha2F0YS5kbmQudXNlcl9kYXRhLmpzdHJlZSkge1xuXHRcdFx0XHRcdFx0XHRpZighciB8fCAhci5sZW5ndGggfHwgci5jaGlsZHJlbihcImFcIilbMF0gIT09IGUuY3VycmVudFRhcmdldCkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZG5kX2VudGVyKGUuY3VycmVudFRhcmdldCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYodHlwZW9mIHRoaXMuZGF0YS5kbmQub2ZmLnRvcCA9PT0gXCJ1bmRlZmluZWRcIikgeyB0aGlzLmRhdGEuZG5kLm9mZiA9ICQoZS50YXJnZXQpLm9mZnNldCgpOyB9XG5cdFx0XHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQudyA9IChlLnBhZ2VZIC0gKHRoaXMuZGF0YS5kbmQub2ZmLnRvcCB8fCAwKSkgJSB0aGlzLmRhdGEuY29yZS5saV9oZWlnaHQ7XG5cdFx0XHRcdFx0XHRcdGlmKHRoaXMuZGF0YS5kbmQudyA8IDApIHsgdGhpcy5kYXRhLmRuZC53ICs9IHRoaXMuZGF0YS5jb3JlLmxpX2hlaWdodDsgfVxuXHRcdFx0XHRcdFx0XHR0aGlzLmRuZF9zaG93KCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5kZWxlZ2F0ZShcImFcIiwgXCJtb3VzZWxlYXZlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7IFxuXHRcdFx0XHRcdFx0aWYoJC52YWthdGEuZG5kLmlzX2RyYWcgJiYgJC52YWthdGEuZG5kLnVzZXJfZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRcdFx0aWYoZS5yZWxhdGVkVGFyZ2V0ICYmIGUucmVsYXRlZFRhcmdldC5pZCAmJiBlLnJlbGF0ZWRUYXJnZXQuaWQgPT09IFwianN0cmVlLW1hcmtlci1saW5lXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7IFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYobSkgeyBtLmhpZGUoKTsgfVxuXHRcdFx0XHRcdFx0XHRcdGlmKG1sKSB7IG1sLmhpZGUoKTsgfVxuXHRcdFx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdFx0XHR2YXIgZWMgPSAkKGUuY3VycmVudFRhcmdldCkuY2xvc2VzdChcImxpXCIpLCBcblx0XHRcdFx0XHRcdFx0XHRlciA9ICQoZS5yZWxhdGVkVGFyZ2V0KS5jbG9zZXN0KFwibGlcIik7XG5cdFx0XHRcdFx0XHRcdGlmKGVyWzBdICE9PSBlYy5wcmV2KClbMF0gJiYgZXJbMF0gIT09IGVjLm5leHQoKVswXSkge1xuXHRcdFx0XHRcdFx0XHRcdGlmKG0pIHsgbS5oaWRlKCk7IH1cblx0XHRcdFx0XHRcdFx0XHRpZihtbCkgeyBtbC5oaWRlKCk7IH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQqL1xuXHRcdFx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLm10byA9IHNldFRpbWVvdXQoIFxuXHRcdFx0XHRcdFx0XHRcdChmdW5jdGlvbiAodCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB0LmRuZF9sZWF2ZShlKTsgfTsgfSkodGhpcyksXG5cdFx0XHRcdFx0XHRcdDApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuZGVsZWdhdGUoXCJhLCAjanN0cmVlLW1hcmtlci1saW5lXCIsIFwibW91c2V1cC5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0aWYoJC52YWthdGEuZG5kLmlzX2RyYWcgJiYgJC52YWthdGEuZG5kLnVzZXJfZGF0YS5qc3RyZWUpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5kbmRfZmluaXNoKGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblxuXHRcdFx0JChkb2N1bWVudClcblx0XHRcdFx0LmJpbmQoXCJkcmFnX3N0b3AudmFrYXRhXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZC50bzEpIHsgY2xlYXJUaW1lb3V0KHRoaXMuZGF0YS5kbmQudG8xKTsgfVxuXHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZC50bzIpIHsgY2xlYXJUaW1lb3V0KHRoaXMuZGF0YS5kbmQudG8yKTsgfVxuXHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZC5pMSkgeyBjbGVhckludGVydmFsKHRoaXMuZGF0YS5kbmQuaTEpOyB9XG5cdFx0XHRcdFx0XHRpZih0aGlzLmRhdGEuZG5kLmkyKSB7IGNsZWFySW50ZXJ2YWwodGhpcy5kYXRhLmRuZC5pMik7IH1cblx0XHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQuYWZ0ZXJcdFx0PSBmYWxzZTtcblx0XHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQuYmVmb3JlXHQ9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC5pbnNpZGVcdD0gZmFsc2U7XG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLm9mZlx0XHQ9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC5wcmVwYXJlZFx0PSBmYWxzZTtcblx0XHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQud1x0XHRcdD0gZmFsc2U7XG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLnRvMVx0XHQ9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC50bzJcdFx0PSBmYWxzZTtcblx0XHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQuaTFcdFx0PSBmYWxzZTtcblx0XHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQuaTJcdFx0PSBmYWxzZTtcblx0XHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQuYWN0aXZlXHQ9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC5mb3JlaWduXHQ9IGZhbHNlO1xuXHRcdFx0XHRcdFx0aWYobSkgeyBtLmNzcyh7IFwidG9wXCIgOiBcIi0yMDAwcHhcIiB9KTsgfVxuXHRcdFx0XHRcdFx0aWYobWwpIHsgbWwuY3NzKHsgXCJ0b3BcIiA6IFwiLTIwMDBweFwiIH0pOyB9XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwiZHJhZ19zdGFydC52YWthdGFcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0aWYoZGF0YS5kYXRhLmpzdHJlZSkgeyBcblx0XHRcdFx0XHRcdFx0dmFyIGV0ID0gJChkYXRhLmV2ZW50LnRhcmdldCk7XG5cdFx0XHRcdFx0XHRcdGlmKGV0LmNsb3Nlc3QoXCIuanN0cmVlXCIpLmhhc0NsYXNzKFwianN0cmVlLVwiICsgdGhpcy5nZXRfaW5kZXgoKSkpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmRuZF9lbnRlcihldCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRcdC8qXG5cdFx0XHRcdC5iaW5kKFwia2V5ZG93bi5qc3RyZWUtXCIgKyB0aGlzLmdldF9pbmRleCgpICsgXCIga2V5dXAuanN0cmVlLVwiICsgdGhpcy5nZXRfaW5kZXgoKSwgJC5wcm94eShmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0XHRpZigkLnZha2F0YS5kbmQuaXNfZHJhZyAmJiAkLnZha2F0YS5kbmQudXNlcl9kYXRhLmpzdHJlZSAmJiAhdGhpcy5kYXRhLmRuZC5mb3JlaWduKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBoID0gJC52YWthdGEuZG5kLmhlbHBlci5jaGlsZHJlbihcImluc1wiKTtcblx0XHRcdFx0XHRcdFx0aWYoZVt0aGlzLl9nZXRfc2V0dGluZ3MoKS5kbmQuY29weV9tb2RpZmllciArIFwiS2V5XCJdICYmIGguaGFzQ2xhc3MoXCJqc3RyZWUtb2tcIikpIHtcblx0XHRcdFx0XHRcdFx0XHRoLnBhcmVudCgpLmh0bWwoaC5wYXJlbnQoKS5odG1sKCkucmVwbGFjZSgvIFxcKENvcHlcXCkkLywgXCJcIikgKyBcIiAoQ29weSlcIik7XG5cdFx0XHRcdFx0XHRcdH0gXG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGgucGFyZW50KCkuaHRtbChoLnBhcmVudCgpLmh0bWwoKS5yZXBsYWNlKC8gXFwoQ29weVxcKSQvLCBcIlwiKSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSk7ICovXG5cblxuXG5cdFx0XHR2YXIgcyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLmRuZDtcblx0XHRcdGlmKHMuZHJhZ190YXJnZXQpIHtcblx0XHRcdFx0JChkb2N1bWVudClcblx0XHRcdFx0XHQuZGVsZWdhdGUocy5kcmFnX3RhcmdldCwgXCJtb3VzZWRvd24uanN0cmVlLVwiICsgdGhpcy5nZXRfaW5kZXgoKSwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0byA9IGUudGFyZ2V0O1xuXHRcdFx0XHRcdFx0JC52YWthdGEuZG5kLmRyYWdfc3RhcnQoZSwgeyBqc3RyZWUgOiB0cnVlLCBvYmogOiBlLnRhcmdldCB9LCBcIjxpbnMgY2xhc3M9J2pzdHJlZS1pY29uJz48L2lucz5cIiArICQoZS50YXJnZXQpLnRleHQoKSApO1xuXHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLnRoZW1lcykgeyBcblx0XHRcdFx0XHRcdFx0aWYobSkgeyBtLmF0dHIoXCJjbGFzc1wiLCBcImpzdHJlZS1cIiArIHRoaXMuZGF0YS50aGVtZXMudGhlbWUpOyB9XG5cdFx0XHRcdFx0XHRcdGlmKG1sKSB7IG1sLmF0dHIoXCJjbGFzc1wiLCBcImpzdHJlZS1cIiArIHRoaXMuZGF0YS50aGVtZXMudGhlbWUpOyB9XG5cdFx0XHRcdFx0XHRcdCQudmFrYXRhLmRuZC5oZWxwZXIuYXR0cihcImNsYXNzXCIsIFwianN0cmVlLWRuZC1oZWxwZXIganN0cmVlLVwiICsgdGhpcy5kYXRhLnRoZW1lcy50aGVtZSk7IFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0JC52YWthdGEuZG5kLmhlbHBlci5jaGlsZHJlbihcImluc1wiKS5hdHRyKFwiY2xhc3NcIixcImpzdHJlZS1pbnZhbGlkXCIpO1xuXHRcdFx0XHRcdFx0dmFyIGNudCA9IHRoaXMuZ2V0X2NvbnRhaW5lcigpO1xuXHRcdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC5jb2YgPSBjbnQub2Zmc2V0KCk7XG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLmN3ID0gcGFyc2VJbnQoY250LndpZHRoKCksMTApO1xuXHRcdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC5jaCA9IHBhcnNlSW50KGNudC5oZWlnaHQoKSwxMCk7XG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLmZvcmVpZ24gPSB0cnVlO1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdH1cblx0XHRcdGlmKHMuZHJvcF90YXJnZXQpIHtcblx0XHRcdFx0JChkb2N1bWVudClcblx0XHRcdFx0XHQuZGVsZWdhdGUocy5kcm9wX3RhcmdldCwgXCJtb3VzZWVudGVyLmpzdHJlZS1cIiArIHRoaXMuZ2V0X2luZGV4KCksICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZC5hY3RpdmUgJiYgdGhpcy5fZ2V0X3NldHRpbmdzKCkuZG5kLmRyb3BfY2hlY2suY2FsbCh0aGlzLCB7IFwib1wiIDogbywgXCJyXCIgOiAkKGUudGFyZ2V0KSwgXCJlXCIgOiBlIH0pKSB7XG5cdFx0XHRcdFx0XHRcdFx0JC52YWthdGEuZG5kLmhlbHBlci5jaGlsZHJlbihcImluc1wiKS5hdHRyKFwiY2xhc3NcIixcImpzdHJlZS1va1wiKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdFx0LmRlbGVnYXRlKHMuZHJvcF90YXJnZXQsIFwibW91c2VsZWF2ZS5qc3RyZWUtXCIgKyB0aGlzLmdldF9pbmRleCgpLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRcdGlmKHRoaXMuZGF0YS5kbmQuYWN0aXZlKSB7XG5cdFx0XHRcdFx0XHRcdFx0JC52YWthdGEuZG5kLmhlbHBlci5jaGlsZHJlbihcImluc1wiKS5hdHRyKFwiY2xhc3NcIixcImpzdHJlZS1pbnZhbGlkXCIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0XHQuZGVsZWdhdGUocy5kcm9wX3RhcmdldCArIFwiLCAjanN0cmVlLW1hcmtlci1saW5lXCIsIFwibW91c2V1cC5qc3RyZWUtXCIgKyB0aGlzLmdldF9pbmRleCgpLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRcdGlmKHRoaXMuZGF0YS5kbmQuYWN0aXZlICYmICQudmFrYXRhLmRuZC5oZWxwZXIuY2hpbGRyZW4oXCJpbnNcIikuaGFzQ2xhc3MoXCJqc3RyZWUtb2tcIikpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9nZXRfc2V0dGluZ3MoKS5kbmQuZHJvcF9maW5pc2guY2FsbCh0aGlzLCB7IFwib1wiIDogbywgXCJyXCIgOiAkKGUudGFyZ2V0KSwgXCJlXCIgOiBlIH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkZWZhdWx0cyA6IHtcblx0XHRcdGNvcHlfbW9kaWZpZXJcdDogXCJjdHJsXCIsXG5cdFx0XHRjaGVja190aW1lb3V0XHQ6IDEwMCxcblx0XHRcdG9wZW5fdGltZW91dFx0OiA1MDAsXG5cdFx0XHRkcm9wX3RhcmdldFx0XHQ6IFwiLmpzdHJlZS1kcm9wXCIsXG5cdFx0XHRkcm9wX2NoZWNrXHRcdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIHRydWU7IH0sXG5cdFx0XHRkcm9wX2ZpbmlzaFx0XHQ6ICQubm9vcCxcblx0XHRcdGRyYWdfdGFyZ2V0XHRcdDogXCIuanN0cmVlLWRyYWdnYWJsZVwiLFxuXHRcdFx0ZHJhZ19maW5pc2hcdFx0OiAkLm5vb3AsXG5cdFx0XHRkcmFnX2NoZWNrXHRcdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIHsgYWZ0ZXIgOiBmYWxzZSwgYmVmb3JlIDogZmFsc2UsIGluc2lkZSA6IHRydWUgfTsgfVxuXHRcdH0sXG5cdFx0X19kZXN0cm95IDogZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gdW5iaW5kIGdsb2JhbCBldmVudCBoYW5kbGVycyB3aGVuIGxhc3QgaW5zdGFuY2UgaXMgcmVtb3ZlZFxuXHRcdFx0Ly8gKG5vIGFjY2VzcyB0byBwcml2YXRlICdpbnN0YW5jZXMnIHZhcmlhYmxlIGZyb20gaGVyZSlcblx0XHRcdGlmKCQoJy5qc3RyZWUnKS5sZW5ndGggPD0gMSkge1xuXHRcdFx0XHQkKGRvY3VtZW50KVxuXHRcdFx0XHRcdC51bmJpbmQoXCJkcmFnX3N0YXJ0LnZha2F0YVwiKVxuXHRcdFx0XHRcdC51bmJpbmQoXCJkcmFnX3N0b3AudmFrYXRhXCIpO1x0XG5cdFx0XHR9XG5cdFx0XHRvID0gZmFsc2U7XG5cdFx0fSxcblx0XHRfZm4gOiB7XG5cdFx0XHRkbmRfcHJlcGFyZSA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYoIXIgfHwgIXIubGVuZ3RoKSB7IHJldHVybjsgfVxuXHRcdFx0XHR0aGlzLmRhdGEuZG5kLm9mZiA9IHIub2Zmc2V0KCk7XG5cdFx0XHRcdGlmKHRoaXMuX2dldF9zZXR0aW5ncygpLmNvcmUucnRsKSB7XG5cdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC5vZmYucmlnaHQgPSB0aGlzLmRhdGEuZG5kLm9mZi5sZWZ0ICsgci53aWR0aCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHRoaXMuZGF0YS5kbmQuZm9yZWlnbikge1xuXHRcdFx0XHRcdHZhciBhID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkuZG5kLmRyYWdfY2hlY2suY2FsbCh0aGlzLCB7IFwib1wiIDogbywgXCJyXCIgOiByIH0pO1xuXHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQuYWZ0ZXIgPSBhLmFmdGVyO1xuXHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQuYmVmb3JlID0gYS5iZWZvcmU7XG5cdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC5pbnNpZGUgPSBhLmluc2lkZTtcblx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLnByZXBhcmVkID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5kbmRfc2hvdygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucHJlcGFyZV9tb3ZlKG8sIHIsIFwiYmVmb3JlXCIpO1xuXHRcdFx0XHR0aGlzLmRhdGEuZG5kLmJlZm9yZSA9IHRoaXMuY2hlY2tfbW92ZSgpO1xuXHRcdFx0XHR0aGlzLnByZXBhcmVfbW92ZShvLCByLCBcImFmdGVyXCIpO1xuXHRcdFx0XHR0aGlzLmRhdGEuZG5kLmFmdGVyID0gdGhpcy5jaGVja19tb3ZlKCk7XG5cdFx0XHRcdGlmKHRoaXMuX2lzX2xvYWRlZChyKSkge1xuXHRcdFx0XHRcdHRoaXMucHJlcGFyZV9tb3ZlKG8sIHIsIFwiaW5zaWRlXCIpO1xuXHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQuaW5zaWRlID0gdGhpcy5jaGVja19tb3ZlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC5pbnNpZGUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmRhdGEuZG5kLnByZXBhcmVkID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZG5kX3Nob3coKTtcblx0XHRcdH0sXG5cdFx0XHRkbmRfc2hvdyA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYoIXRoaXMuZGF0YS5kbmQucHJlcGFyZWQpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdHZhciBvID0gW1wiYmVmb3JlXCIsXCJpbnNpZGVcIixcImFmdGVyXCJdLFxuXHRcdFx0XHRcdHIgPSBmYWxzZSxcblx0XHRcdFx0XHRydGwgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5jb3JlLnJ0bCxcblx0XHRcdFx0XHRwb3M7XG5cdFx0XHRcdGlmKHRoaXMuZGF0YS5kbmQudyA8IHRoaXMuZGF0YS5jb3JlLmxpX2hlaWdodC8zKSB7IG8gPSBbXCJiZWZvcmVcIixcImluc2lkZVwiLFwiYWZ0ZXJcIl07IH1cblx0XHRcdFx0ZWxzZSBpZih0aGlzLmRhdGEuZG5kLncgPD0gdGhpcy5kYXRhLmNvcmUubGlfaGVpZ2h0KjIvMykge1xuXHRcdFx0XHRcdG8gPSB0aGlzLmRhdGEuZG5kLncgPCB0aGlzLmRhdGEuY29yZS5saV9oZWlnaHQvMiA/IFtcImluc2lkZVwiLFwiYmVmb3JlXCIsXCJhZnRlclwiXSA6IFtcImluc2lkZVwiLFwiYWZ0ZXJcIixcImJlZm9yZVwiXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHsgbyA9IFtcImFmdGVyXCIsXCJpbnNpZGVcIixcImJlZm9yZVwiXTsgfVxuXHRcdFx0XHQkLmVhY2gobywgJC5wcm94eShmdW5jdGlvbiAoaSwgdmFsKSB7IFxuXHRcdFx0XHRcdGlmKHRoaXMuZGF0YS5kbmRbdmFsXSkge1xuXHRcdFx0XHRcdFx0JC52YWthdGEuZG5kLmhlbHBlci5jaGlsZHJlbihcImluc1wiKS5hdHRyKFwiY2xhc3NcIixcImpzdHJlZS1va1wiKTtcblx0XHRcdFx0XHRcdHIgPSB2YWw7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRcdGlmKHIgPT09IGZhbHNlKSB7ICQudmFrYXRhLmRuZC5oZWxwZXIuY2hpbGRyZW4oXCJpbnNcIikuYXR0cihcImNsYXNzXCIsXCJqc3RyZWUtaW52YWxpZFwiKTsgfVxuXHRcdFx0XHRcblx0XHRcdFx0cG9zID0gcnRsID8gKHRoaXMuZGF0YS5kbmQub2ZmLnJpZ2h0IC0gMTgpIDogKHRoaXMuZGF0YS5kbmQub2ZmLmxlZnQgKyAxMCk7XG5cdFx0XHRcdHN3aXRjaChyKSB7XG5cdFx0XHRcdFx0Y2FzZSBcImJlZm9yZVwiOlxuXHRcdFx0XHRcdFx0bS5jc3MoeyBcImxlZnRcIiA6IHBvcyArIFwicHhcIiwgXCJ0b3BcIiA6ICh0aGlzLmRhdGEuZG5kLm9mZi50b3AgLSA2KSArIFwicHhcIiB9KS5zaG93KCk7XG5cdFx0XHRcdFx0XHRpZihtbCkgeyBtbC5jc3MoeyBcImxlZnRcIiA6IChwb3MgKyA4KSArIFwicHhcIiwgXCJ0b3BcIiA6ICh0aGlzLmRhdGEuZG5kLm9mZi50b3AgLSAxKSArIFwicHhcIiB9KS5zaG93KCk7IH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJhZnRlclwiOlxuXHRcdFx0XHRcdFx0bS5jc3MoeyBcImxlZnRcIiA6IHBvcyArIFwicHhcIiwgXCJ0b3BcIiA6ICh0aGlzLmRhdGEuZG5kLm9mZi50b3AgKyB0aGlzLmRhdGEuY29yZS5saV9oZWlnaHQgLSA2KSArIFwicHhcIiB9KS5zaG93KCk7XG5cdFx0XHRcdFx0XHRpZihtbCkgeyBtbC5jc3MoeyBcImxlZnRcIiA6IChwb3MgKyA4KSArIFwicHhcIiwgXCJ0b3BcIiA6ICh0aGlzLmRhdGEuZG5kLm9mZi50b3AgKyB0aGlzLmRhdGEuY29yZS5saV9oZWlnaHQgLSAxKSArIFwicHhcIiB9KS5zaG93KCk7IH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJpbnNpZGVcIjpcblx0XHRcdFx0XHRcdG0uY3NzKHsgXCJsZWZ0XCIgOiBwb3MgKyAoIHJ0bCA/IC00IDogNCkgKyBcInB4XCIsIFwidG9wXCIgOiAodGhpcy5kYXRhLmRuZC5vZmYudG9wICsgdGhpcy5kYXRhLmNvcmUubGlfaGVpZ2h0LzIgLSA1KSArIFwicHhcIiB9KS5zaG93KCk7XG5cdFx0XHRcdFx0XHRpZihtbCkgeyBtbC5oaWRlKCk7IH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRtLmhpZGUoKTtcblx0XHRcdFx0XHRcdGlmKG1sKSB7IG1sLmhpZGUoKTsgfVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGFzdF9wb3MgPSByO1xuXHRcdFx0XHRyZXR1cm4gcjtcblx0XHRcdH0sXG5cdFx0XHRkbmRfb3BlbiA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5kYXRhLmRuZC50bzIgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5vcGVuX25vZGUociwgJC5wcm94eSh0aGlzLmRuZF9wcmVwYXJlLHRoaXMpLCB0cnVlKTtcblx0XHRcdH0sXG5cdFx0XHRkbmRfZmluaXNoIDogZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZC5mb3JlaWduKSB7XG5cdFx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZC5hZnRlciB8fCB0aGlzLmRhdGEuZG5kLmJlZm9yZSB8fCB0aGlzLmRhdGEuZG5kLmluc2lkZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZ2V0X3NldHRpbmdzKCkuZG5kLmRyYWdfZmluaXNoLmNhbGwodGhpcywgeyBcIm9cIiA6IG8sIFwiclwiIDogciwgXCJwXCIgOiBsYXN0X3BvcyB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5kbmRfcHJlcGFyZSgpO1xuXHRcdFx0XHRcdHRoaXMubW92ZV9ub2RlKG8sIHIsIGxhc3RfcG9zLCBlW3RoaXMuX2dldF9zZXR0aW5ncygpLmRuZC5jb3B5X21vZGlmaWVyICsgXCJLZXlcIl0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG8gPSBmYWxzZTtcblx0XHRcdFx0ciA9IGZhbHNlO1xuXHRcdFx0XHRtLmhpZGUoKTtcblx0XHRcdFx0aWYobWwpIHsgbWwuaGlkZSgpOyB9XG5cdFx0XHR9LFxuXHRcdFx0ZG5kX2VudGVyIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRpZih0aGlzLmRhdGEuZG5kLm10bykgeyBcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5kYXRhLmRuZC5tdG8pO1xuXHRcdFx0XHRcdHRoaXMuZGF0YS5kbmQubXRvID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5kbmQ7XG5cdFx0XHRcdHRoaXMuZGF0YS5kbmQucHJlcGFyZWQgPSBmYWxzZTtcblx0XHRcdFx0ciA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdGlmKHMuY2hlY2tfdGltZW91dCkgeyBcblx0XHRcdFx0XHQvLyBkbyB0aGUgY2FsY3VsYXRpb25zIGFmdGVyIGEgbWluaW1hbCB0aW1lb3V0ICh1c2VycyB0ZW5kIHRvIGRyYWcgcXVpY2tseSB0byB0aGUgZGVzaXJlZCBsb2NhdGlvbilcblx0XHRcdFx0XHRpZih0aGlzLmRhdGEuZG5kLnRvMSkgeyBjbGVhclRpbWVvdXQodGhpcy5kYXRhLmRuZC50bzEpOyB9XG5cdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC50bzEgPSBzZXRUaW1lb3V0KCQucHJveHkodGhpcy5kbmRfcHJlcGFyZSwgdGhpcyksIHMuY2hlY2tfdGltZW91dCk7IFxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgeyBcblx0XHRcdFx0XHR0aGlzLmRuZF9wcmVwYXJlKCk7IFxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHMub3Blbl90aW1lb3V0KSB7IFxuXHRcdFx0XHRcdGlmKHRoaXMuZGF0YS5kbmQudG8yKSB7IGNsZWFyVGltZW91dCh0aGlzLmRhdGEuZG5kLnRvMik7IH1cblx0XHRcdFx0XHRpZihyICYmIHIubGVuZ3RoICYmIHIuaGFzQ2xhc3MoXCJqc3RyZWUtY2xvc2VkXCIpKSB7IFxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIG5vZGUgaXMgY2xvc2VkIC0gb3BlbiBpdCwgdGhlbiByZWNhbGN1bGF0ZVxuXHRcdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC50bzIgPSBzZXRUaW1lb3V0KCQucHJveHkodGhpcy5kbmRfb3BlbiwgdGhpcyksIHMub3Blbl90aW1lb3V0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYociAmJiByLmxlbmd0aCAmJiByLmhhc0NsYXNzKFwianN0cmVlLWNsb3NlZFwiKSkgeyBcblx0XHRcdFx0XHRcdHRoaXMuZG5kX29wZW4oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkbmRfbGVhdmUgOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHR0aGlzLmRhdGEuZG5kLmFmdGVyXHRcdD0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuZGF0YS5kbmQuYmVmb3JlXHQ9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLmRhdGEuZG5kLmluc2lkZVx0PSBmYWxzZTtcblx0XHRcdFx0JC52YWthdGEuZG5kLmhlbHBlci5jaGlsZHJlbihcImluc1wiKS5hdHRyKFwiY2xhc3NcIixcImpzdHJlZS1pbnZhbGlkXCIpO1xuXHRcdFx0XHRtLmhpZGUoKTtcblx0XHRcdFx0aWYobWwpIHsgbWwuaGlkZSgpOyB9XG5cdFx0XHRcdGlmKHIgJiYgclswXSA9PT0gZS50YXJnZXQucGFyZW50Tm9kZSkge1xuXHRcdFx0XHRcdGlmKHRoaXMuZGF0YS5kbmQudG8xKSB7XG5cdFx0XHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5kYXRhLmRuZC50bzEpO1xuXHRcdFx0XHRcdFx0dGhpcy5kYXRhLmRuZC50bzEgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYodGhpcy5kYXRhLmRuZC50bzIpIHtcblx0XHRcdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLmRhdGEuZG5kLnRvMik7XG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEuZG5kLnRvMiA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHN0YXJ0X2RyYWcgOiBmdW5jdGlvbiAob2JqLCBlKSB7XG5cdFx0XHRcdG8gPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRpZih0aGlzLmRhdGEudWkgJiYgdGhpcy5pc19zZWxlY3RlZChvKSkgeyBvID0gdGhpcy5fZ2V0X25vZGUobnVsbCwgdHJ1ZSk7IH1cblx0XHRcdFx0dmFyIGR0ID0gby5sZW5ndGggPiAxID8gdGhpcy5fZ2V0X3N0cmluZyhcIm11bHRpcGxlX3NlbGVjdGlvblwiKSA6IHRoaXMuZ2V0X3RleHQobyksXG5cdFx0XHRcdFx0Y250ID0gdGhpcy5nZXRfY29udGFpbmVyKCk7XG5cdFx0XHRcdGlmKCF0aGlzLl9nZXRfc2V0dGluZ3MoKS5jb3JlLmh0bWxfdGl0bGVzKSB7IGR0ID0gZHQucmVwbGFjZSgvPC9pZyxcIiZsdDtcIikucmVwbGFjZSgvPi9pZyxcIiZndDtcIik7IH1cblx0XHRcdFx0JC52YWthdGEuZG5kLmRyYWdfc3RhcnQoZSwgeyBqc3RyZWUgOiB0cnVlLCBvYmogOiBvIH0sIFwiPGlucyBjbGFzcz0nanN0cmVlLWljb24nPjwvaW5zPlwiICsgZHQgKTtcblx0XHRcdFx0aWYodGhpcy5kYXRhLnRoZW1lcykgeyBcblx0XHRcdFx0XHRpZihtKSB7IG0uYXR0cihcImNsYXNzXCIsIFwianN0cmVlLVwiICsgdGhpcy5kYXRhLnRoZW1lcy50aGVtZSk7IH1cblx0XHRcdFx0XHRpZihtbCkgeyBtbC5hdHRyKFwiY2xhc3NcIiwgXCJqc3RyZWUtXCIgKyB0aGlzLmRhdGEudGhlbWVzLnRoZW1lKTsgfVxuXHRcdFx0XHRcdCQudmFrYXRhLmRuZC5oZWxwZXIuYXR0cihcImNsYXNzXCIsIFwianN0cmVlLWRuZC1oZWxwZXIganN0cmVlLVwiICsgdGhpcy5kYXRhLnRoZW1lcy50aGVtZSk7IFxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuZGF0YS5kbmQuY29mID0gY250Lm9mZnNldCgpO1xuXHRcdFx0XHR0aGlzLmRhdGEuZG5kLmN3ID0gcGFyc2VJbnQoY250LndpZHRoKCksMTApO1xuXHRcdFx0XHR0aGlzLmRhdGEuZG5kLmNoID0gcGFyc2VJbnQoY250LmhlaWdodCgpLDEwKTtcblx0XHRcdFx0dGhpcy5kYXRhLmRuZC5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdCQoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNzc19zdHJpbmcgPSAnJyArIFxuXHRcdFx0JyN2YWthdGEtZHJhZ2dlZCBpbnMgeyBkaXNwbGF5OmJsb2NrOyB0ZXh0LWRlY29yYXRpb246bm9uZTsgd2lkdGg6MTZweDsgaGVpZ2h0OjE2cHg7IG1hcmdpbjowIDAgMCAwOyBwYWRkaW5nOjA7IHBvc2l0aW9uOmFic29sdXRlOyB0b3A6NHB4OyBsZWZ0OjRweDsgJyArIFxuXHRcdFx0JyAtbW96LWJvcmRlci1yYWRpdXM6NHB4OyBib3JkZXItcmFkaXVzOjRweDsgLXdlYmtpdC1ib3JkZXItcmFkaXVzOjRweDsgJyArXG5cdFx0XHQnfSAnICsgXG5cdFx0XHQnI3Zha2F0YS1kcmFnZ2VkIC5qc3RyZWUtb2sgeyBiYWNrZ3JvdW5kOmdyZWVuOyB9ICcgKyBcblx0XHRcdCcjdmFrYXRhLWRyYWdnZWQgLmpzdHJlZS1pbnZhbGlkIHsgYmFja2dyb3VuZDpyZWQ7IH0gJyArIFxuXHRcdFx0JyNqc3RyZWUtbWFya2VyIHsgcGFkZGluZzowOyBtYXJnaW46MDsgZm9udC1zaXplOjEycHg7IG92ZXJmbG93OmhpZGRlbjsgaGVpZ2h0OjEycHg7IHdpZHRoOjhweDsgcG9zaXRpb246YWJzb2x1dGU7IHRvcDotMzBweDsgei1pbmRleDoxMDAwMTsgYmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0OyBkaXNwbGF5Om5vbmU7IGJhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7IHRleHQtc2hhZG93OjFweCAxcHggMXB4IHdoaXRlOyBjb2xvcjpibGFjazsgbGluZS1oZWlnaHQ6MTBweDsgfSAnICsgXG5cdFx0XHQnI2pzdHJlZS1tYXJrZXItbGluZSB7IHBhZGRpbmc6MDsgbWFyZ2luOjA7IGxpbmUtaGVpZ2h0OjAlOyBmb250LXNpemU6MXB4OyBvdmVyZmxvdzpoaWRkZW47IGhlaWdodDoxcHg7IHdpZHRoOjEwMHB4OyBwb3NpdGlvbjphYnNvbHV0ZTsgdG9wOi0zMHB4OyB6LWluZGV4OjEwMDAwOyBiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7IGRpc3BsYXk6bm9uZTsgYmFja2dyb3VuZC1jb2xvcjojNDU2YzQzOyAnICsgXG5cdFx0XHQnIGN1cnNvcjpwb2ludGVyOyBib3JkZXI6MXB4IHNvbGlkICNlZWVlZWU7IGJvcmRlci1sZWZ0OjA7IC1tb3otYm94LXNoYWRvdzogMHB4IDBweCAycHggIzY2NjsgLXdlYmtpdC1ib3gtc2hhZG93OiAwcHggMHB4IDJweCAjNjY2OyBib3gtc2hhZG93OiAwcHggMHB4IDJweCAjNjY2OyAnICsgXG5cdFx0XHQnIC1tb3otYm9yZGVyLXJhZGl1czoxcHg7IGJvcmRlci1yYWRpdXM6MXB4OyAtd2Via2l0LWJvcmRlci1yYWRpdXM6MXB4OyAnICtcblx0XHRcdCd9JyArIFxuXHRcdFx0Jyc7XG5cdFx0JC52YWthdGEuY3NzLmFkZF9zaGVldCh7IHN0ciA6IGNzc19zdHJpbmcsIHRpdGxlIDogXCJqc3RyZWVcIiB9KTtcblx0XHRtID0gJChcIjxkaXYgLz5cIikuYXR0cih7IGlkIDogXCJqc3RyZWUtbWFya2VyXCIgfSkuaGlkZSgpLmh0bWwoXCImcmFxdW87XCIpXG5cdFx0XHQuYmluZChcIm1vdXNlbGVhdmUgbW91c2VlbnRlclwiLCBmdW5jdGlvbiAoZSkgeyBcblx0XHRcdFx0bS5oaWRlKCk7XG5cdFx0XHRcdG1sLmhpZGUoKTtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpOyBcblx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTsgXG5cdFx0XHRcdHJldHVybiBmYWxzZTsgXG5cdFx0XHR9KVxuXHRcdFx0LmFwcGVuZFRvKFwiYm9keVwiKTtcblx0XHRtbCA9ICQoXCI8ZGl2IC8+XCIpLmF0dHIoeyBpZCA6IFwianN0cmVlLW1hcmtlci1saW5lXCIgfSkuaGlkZSgpXG5cdFx0XHQuYmluZChcIm1vdXNldXBcIiwgZnVuY3Rpb24gKGUpIHsgXG5cdFx0XHRcdGlmKHIgJiYgci5sZW5ndGgpIHsgXG5cdFx0XHRcdFx0ci5jaGlsZHJlbihcImFcIikudHJpZ2dlcihlKTsgXG5cdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpOyBcblx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpOyBcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7IFxuXHRcdFx0XHR9IFxuXHRcdFx0fSlcblx0XHRcdC5iaW5kKFwibW91c2VsZWF2ZVwiLCBmdW5jdGlvbiAoZSkgeyBcblx0XHRcdFx0dmFyIHJ0ID0gJChlLnJlbGF0ZWRUYXJnZXQpO1xuXHRcdFx0XHRpZihydC5pcyhcIi5qc3RyZWVcIikgfHwgcnQuY2xvc2VzdChcIi5qc3RyZWVcIikubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0aWYociAmJiByLmxlbmd0aCkgeyBcblx0XHRcdFx0XHRcdHIuY2hpbGRyZW4oXCJhXCIpLnRyaWdnZXIoZSk7IFxuXHRcdFx0XHRcdFx0bS5oaWRlKCk7XG5cdFx0XHRcdFx0XHRtbC5oaWRlKCk7XG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7IFxuXHRcdFx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTsgXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7IFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC5hcHBlbmRUbyhcImJvZHlcIik7XG5cdFx0JChkb2N1bWVudCkuYmluZChcImRyYWdfc3RhcnQudmFrYXRhXCIsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRpZihkYXRhLmRhdGEuanN0cmVlKSB7IG0uc2hvdygpOyBpZihtbCkgeyBtbC5zaG93KCk7IH0gfVxuXHRcdH0pO1xuXHRcdCQoZG9jdW1lbnQpLmJpbmQoXCJkcmFnX3N0b3AudmFrYXRhXCIsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRpZihkYXRhLmRhdGEuanN0cmVlKSB7IG0uaGlkZSgpOyBpZihtbCkgeyBtbC5oaWRlKCk7IH0gfVxuXHRcdH0pO1xuXHR9KTtcbn0pKGpRdWVyeSk7XG4vLyovXG5cbi8qXG4gKiBqc1RyZWUgY2hlY2tib3ggcGx1Z2luXG4gKiBJbnNlcnRzIGNoZWNrYm94ZXMgaW4gZnJvbnQgb2YgZXZlcnkgbm9kZVxuICogRGVwZW5kcyBvbiB0aGUgdWkgcGx1Z2luXG4gKiBET0VTIE5PVCBXT1JLIE5JQ0VMWSBXSVRIIE1VTFRJVFJFRSBEUkFHJ04nRFJPUFxuICovXG4oZnVuY3Rpb24gKCQpIHtcblx0JC5qc3RyZWUucGx1Z2luKFwiY2hlY2tib3hcIiwge1xuXHRcdF9faW5pdCA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuZGF0YS5jaGVja2JveC5ub3VpID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkuY2hlY2tib3gub3ZlcnJpZGVfdWk7XG5cdFx0XHRpZih0aGlzLmRhdGEudWkgJiYgdGhpcy5kYXRhLmNoZWNrYm94Lm5vdWkpIHtcblx0XHRcdFx0dGhpcy5zZWxlY3Rfbm9kZSA9IHRoaXMuZGVzZWxlY3Rfbm9kZSA9IHRoaXMuZGVzZWxlY3RfYWxsID0gJC5ub29wO1xuXHRcdFx0XHR0aGlzLmdldF9zZWxlY3RlZCA9IHRoaXMuZ2V0X2NoZWNrZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpXG5cdFx0XHRcdC5iaW5kKFwib3Blbl9ub2RlLmpzdHJlZSBjcmVhdGVfbm9kZS5qc3RyZWUgY2xlYW5fbm9kZS5qc3RyZWUgcmVmcmVzaC5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkgeyBcblx0XHRcdFx0XHRcdHRoaXMuX3ByZXBhcmVfY2hlY2tib3hlcyhkYXRhLnJzbHQub2JqKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJsb2FkZWQuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3ByZXBhcmVfY2hlY2tib3hlcygpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuZGVsZWdhdGUoICh0aGlzLmRhdGEudWkgJiYgdGhpcy5kYXRhLmNoZWNrYm94Lm5vdWkgPyBcImFcIiA6IFwiaW5zLmpzdHJlZS1jaGVja2JveFwiKSAsIFwiY2xpY2suanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdGlmKHRoaXMuX2dldF9ub2RlKGUudGFyZ2V0KS5oYXNDbGFzcyhcImpzdHJlZS1jaGVja2VkXCIpKSB7IHRoaXMudW5jaGVja19ub2RlKGUudGFyZ2V0KTsgfVxuXHRcdFx0XHRcdFx0ZWxzZSB7IHRoaXMuY2hlY2tfbm9kZShlLnRhcmdldCk7IH1cblx0XHRcdFx0XHRcdGlmKHRoaXMuZGF0YS51aSAmJiB0aGlzLmRhdGEuY2hlY2tib3gubm91aSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNhdmVfc2VsZWN0ZWQoKTtcblx0XHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLmNvb2tpZXMpIHsgdGhpcy5zYXZlX2Nvb2tpZShcInNlbGVjdF9ub2RlXCIpOyB9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHR9LFxuXHRcdGRlZmF1bHRzIDoge1xuXHRcdFx0b3ZlcnJpZGVfdWkgOiBmYWxzZSxcblx0XHRcdHR3b19zdGF0ZSA6IGZhbHNlLFxuXHRcdFx0cmVhbF9jaGVja2JveGVzIDogZmFsc2UsXG5cdFx0XHRjaGVja2VkX3BhcmVudF9vcGVuIDogdHJ1ZSxcblx0XHRcdHJlYWxfY2hlY2tib3hlc19uYW1lcyA6IGZ1bmN0aW9uIChuKSB7IHJldHVybiBbIChcImNoZWNrX1wiICsgKG5bMF0uaWQgfHwgTWF0aC5jZWlsKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkpKSAsIDFdOyB9XG5cdFx0fSxcblx0XHRfX2Rlc3Ryb3kgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLmdldF9jb250YWluZXIoKVxuXHRcdFx0XHQuZmluZChcImlucHV0LmpzdHJlZS1yZWFsLWNoZWNrYm94XCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLXJlYWwtY2hlY2tib3hcIikuZW5kKClcblx0XHRcdFx0LmZpbmQoXCJpbnMuanN0cmVlLWNoZWNrYm94XCIpLnJlbW92ZSgpO1xuXHRcdH0sXG5cdFx0X2ZuIDoge1xuXHRcdFx0X2NoZWNrYm94X25vdGlmeSA6IGZ1bmN0aW9uIChuLCBkYXRhKSB7XG5cdFx0XHRcdGlmKGRhdGEuY2hlY2tlZCkge1xuXHRcdFx0XHRcdHRoaXMuY2hlY2tfbm9kZShuLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfcHJlcGFyZV9jaGVja2JveGVzIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRvYmogPSAhb2JqIHx8IG9iaiA9PSAtMSA/IHRoaXMuZ2V0X2NvbnRhaW5lcigpLmZpbmQoXCI+IHVsID4gbGlcIikgOiB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRpZihvYmogPT09IGZhbHNlKSB7IHJldHVybjsgfSAvLyBhZGRlZCBmb3IgcmVtb3Zpbmcgcm9vdCBub2Rlc1xuXHRcdFx0XHR2YXIgYywgX3RoaXMgPSB0aGlzLCB0LCB0cyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLmNoZWNrYm94LnR3b19zdGF0ZSwgcmMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5jaGVja2JveC5yZWFsX2NoZWNrYm94ZXMsIHJjbiA9IHRoaXMuX2dldF9zZXR0aW5ncygpLmNoZWNrYm94LnJlYWxfY2hlY2tib3hlc19uYW1lcztcblx0XHRcdFx0b2JqLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHQgPSAkKHRoaXMpO1xuXHRcdFx0XHRcdGMgPSB0LmlzKFwibGlcIikgJiYgKHQuaGFzQ2xhc3MoXCJqc3RyZWUtY2hlY2tlZFwiKSB8fCAocmMgJiYgdC5jaGlsZHJlbihcIjpjaGVja2VkXCIpLmxlbmd0aCkpID8gXCJqc3RyZWUtY2hlY2tlZFwiIDogXCJqc3RyZWUtdW5jaGVja2VkXCI7XG5cdFx0XHRcdFx0dC5maW5kKFwibGlcIikuYW5kU2VsZigpLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dmFyICR0ID0gJCh0aGlzKSwgbm07XG5cdFx0XHRcdFx0XHQkdC5jaGlsZHJlbihcImFcIiArIChfdGhpcy5kYXRhLmxhbmd1YWdlcyA/IFwiXCIgOiBcIjplcSgwKVwiKSApLm5vdChcIjpoYXMoLmpzdHJlZS1jaGVja2JveClcIikucHJlcGVuZChcIjxpbnMgY2xhc3M9J2pzdHJlZS1jaGVja2JveCc+JiMxNjA7PC9pbnM+XCIpLnBhcmVudCgpLm5vdChcIi5qc3RyZWUtY2hlY2tlZCwgLmpzdHJlZS11bmNoZWNrZWRcIikuYWRkQ2xhc3MoIHRzID8gXCJqc3RyZWUtdW5jaGVja2VkXCIgOiBjICk7XG5cdFx0XHRcdFx0XHRpZihyYykge1xuXHRcdFx0XHRcdFx0XHRpZighJHQuY2hpbGRyZW4oXCI6Y2hlY2tib3hcIikubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm0gPSByY24uY2FsbChfdGhpcywgJHQpO1xuXHRcdFx0XHRcdFx0XHRcdCR0LnByZXBlbmQoXCI8aW5wdXQgdHlwZT0nY2hlY2tib3gnIGNsYXNzPSdqc3RyZWUtcmVhbC1jaGVja2JveCcgaWQ9J1wiICsgbm1bMF0gKyBcIicgbmFtZT0nXCIgKyBubVswXSArIFwiJyB2YWx1ZT0nXCIgKyBubVsxXSArIFwiJyAvPlwiKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHQkdC5jaGlsZHJlbihcIjpjaGVja2JveFwiKS5hZGRDbGFzcyhcImpzdHJlZS1yZWFsLWNoZWNrYm94XCIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZighdHMpIHtcblx0XHRcdFx0XHRcdFx0aWYoYyA9PT0gXCJqc3RyZWUtY2hlY2tlZFwiIHx8ICR0Lmhhc0NsYXNzKFwianN0cmVlLWNoZWNrZWRcIikgfHwgJHQuY2hpbGRyZW4oJzpjaGVja2VkJykubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0JHQuZmluZChcImxpXCIpLmFuZFNlbGYoKS5hZGRDbGFzcyhcImpzdHJlZS1jaGVja2VkXCIpLmNoaWxkcmVuKFwiOmNoZWNrYm94XCIpLnByb3AoXCJjaGVja2VkXCIsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0aWYoJHQuaGFzQ2xhc3MoXCJqc3RyZWUtY2hlY2tlZFwiKSB8fCAkdC5jaGlsZHJlbignOmNoZWNrZWQnKS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHQkdC5hZGRDbGFzcyhcImpzdHJlZS1jaGVja2VkXCIpLmNoaWxkcmVuKFwiOmNoZWNrYm94XCIpLnByb3AoXCJjaGVja2VkXCIsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZighdHMpIHtcblx0XHRcdFx0XHRvYmouZmluZChcIi5qc3RyZWUtY2hlY2tlZFwiKS5wYXJlbnQoKS5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uICgpIHsgX3RoaXMuX3JlcGFpcl9zdGF0ZSh0aGlzKTsgfSk7IFxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Y2hhbmdlX3N0YXRlIDogZnVuY3Rpb24gKG9iaiwgc3RhdGUpIHtcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0dmFyIGNvbGwgPSBmYWxzZSwgcmMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5jaGVja2JveC5yZWFsX2NoZWNrYm94ZXM7XG5cdFx0XHRcdGlmKCFvYmogfHwgb2JqID09PSAtMSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0c3RhdGUgPSAoc3RhdGUgPT09IGZhbHNlIHx8IHN0YXRlID09PSB0cnVlKSA/IHN0YXRlIDogb2JqLmhhc0NsYXNzKFwianN0cmVlLWNoZWNrZWRcIik7XG5cdFx0XHRcdGlmKHRoaXMuX2dldF9zZXR0aW5ncygpLmNoZWNrYm94LnR3b19zdGF0ZSkge1xuXHRcdFx0XHRcdGlmKHN0YXRlKSB7IFxuXHRcdFx0XHRcdFx0b2JqLnJlbW92ZUNsYXNzKFwianN0cmVlLWNoZWNrZWRcIikuYWRkQ2xhc3MoXCJqc3RyZWUtdW5jaGVja2VkXCIpOyBcblx0XHRcdFx0XHRcdGlmKHJjKSB7IG9iai5jaGlsZHJlbihcIjpjaGVja2JveFwiKS5wcm9wKFwiY2hlY2tlZFwiLCBmYWxzZSk7IH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7IFxuXHRcdFx0XHRcdFx0b2JqLnJlbW92ZUNsYXNzKFwianN0cmVlLXVuY2hlY2tlZFwiKS5hZGRDbGFzcyhcImpzdHJlZS1jaGVja2VkXCIpOyBcblx0XHRcdFx0XHRcdGlmKHJjKSB7IG9iai5jaGlsZHJlbihcIjpjaGVja2JveFwiKS5wcm9wKFwiY2hlY2tlZFwiLCB0cnVlKTsgfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZihzdGF0ZSkgeyBcblx0XHRcdFx0XHRcdGNvbGwgPSBvYmouZmluZChcImxpXCIpLmFuZFNlbGYoKTtcblx0XHRcdFx0XHRcdGlmKCFjb2xsLmZpbHRlcihcIi5qc3RyZWUtY2hlY2tlZCwgLmpzdHJlZS11bmRldGVybWluZWRcIikubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRcdFx0Y29sbC5yZW1vdmVDbGFzcyhcImpzdHJlZS1jaGVja2VkIGpzdHJlZS11bmRldGVybWluZWRcIikuYWRkQ2xhc3MoXCJqc3RyZWUtdW5jaGVja2VkXCIpOyBcblx0XHRcdFx0XHRcdGlmKHJjKSB7IGNvbGwuY2hpbGRyZW4oXCI6Y2hlY2tib3hcIikucHJvcChcImNoZWNrZWRcIiwgZmFsc2UpOyB9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgeyBcblx0XHRcdFx0XHRcdGNvbGwgPSBvYmouZmluZChcImxpXCIpLmFuZFNlbGYoKTtcblx0XHRcdFx0XHRcdGlmKCFjb2xsLmZpbHRlcihcIi5qc3RyZWUtdW5jaGVja2VkLCAuanN0cmVlLXVuZGV0ZXJtaW5lZFwiKS5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdFx0XHRjb2xsLnJlbW92ZUNsYXNzKFwianN0cmVlLXVuY2hlY2tlZCBqc3RyZWUtdW5kZXRlcm1pbmVkXCIpLmFkZENsYXNzKFwianN0cmVlLWNoZWNrZWRcIik7IFxuXHRcdFx0XHRcdFx0aWYocmMpIHsgY29sbC5jaGlsZHJlbihcIjpjaGVja2JveFwiKS5wcm9wKFwiY2hlY2tlZFwiLCB0cnVlKTsgfVxuXHRcdFx0XHRcdFx0aWYodGhpcy5kYXRhLnVpKSB7IHRoaXMuZGF0YS51aS5sYXN0X3NlbGVjdGVkID0gb2JqOyB9XG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEuY2hlY2tib3gubGFzdF9zZWxlY3RlZCA9IG9iajtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0b2JqLnBhcmVudHNVbnRpbChcIi5qc3RyZWVcIiwgXCJsaVwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHZhciAkdGhpcyA9ICQodGhpcyk7XG5cdFx0XHRcdFx0XHRpZihzdGF0ZSkge1xuXHRcdFx0XHRcdFx0XHRpZigkdGhpcy5jaGlsZHJlbihcInVsXCIpLmNoaWxkcmVuKFwibGkuanN0cmVlLWNoZWNrZWQsIGxpLmpzdHJlZS11bmRldGVybWluZWRcIikubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0JHRoaXMucGFyZW50c1VudGlsKFwiLmpzdHJlZVwiLCBcImxpXCIpLmFuZFNlbGYoKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1jaGVja2VkIGpzdHJlZS11bmNoZWNrZWRcIikuYWRkQ2xhc3MoXCJqc3RyZWUtdW5kZXRlcm1pbmVkXCIpO1xuXHRcdFx0XHRcdFx0XHRcdGlmKHJjKSB7ICR0aGlzLnBhcmVudHNVbnRpbChcIi5qc3RyZWVcIiwgXCJsaVwiKS5hbmRTZWxmKCkuY2hpbGRyZW4oXCI6Y2hlY2tib3hcIikucHJvcChcImNoZWNrZWRcIiwgZmFsc2UpOyB9XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdCR0aGlzLnJlbW92ZUNsYXNzKFwianN0cmVlLWNoZWNrZWQganN0cmVlLXVuZGV0ZXJtaW5lZFwiKS5hZGRDbGFzcyhcImpzdHJlZS11bmNoZWNrZWRcIik7XG5cdFx0XHRcdFx0XHRcdFx0aWYocmMpIHsgJHRoaXMuY2hpbGRyZW4oXCI6Y2hlY2tib3hcIikucHJvcChcImNoZWNrZWRcIiwgZmFsc2UpOyB9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZigkdGhpcy5jaGlsZHJlbihcInVsXCIpLmNoaWxkcmVuKFwibGkuanN0cmVlLXVuY2hlY2tlZCwgbGkuanN0cmVlLXVuZGV0ZXJtaW5lZFwiKS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHQkdGhpcy5wYXJlbnRzVW50aWwoXCIuanN0cmVlXCIsIFwibGlcIikuYW5kU2VsZigpLnJlbW92ZUNsYXNzKFwianN0cmVlLWNoZWNrZWQganN0cmVlLXVuY2hlY2tlZFwiKS5hZGRDbGFzcyhcImpzdHJlZS11bmRldGVybWluZWRcIik7XG5cdFx0XHRcdFx0XHRcdFx0aWYocmMpIHsgJHRoaXMucGFyZW50c1VudGlsKFwiLmpzdHJlZVwiLCBcImxpXCIpLmFuZFNlbGYoKS5jaGlsZHJlbihcIjpjaGVja2JveFwiKS5wcm9wKFwiY2hlY2tlZFwiLCBmYWxzZSk7IH1cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0JHRoaXMucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtdW5jaGVja2VkIGpzdHJlZS11bmRldGVybWluZWRcIikuYWRkQ2xhc3MoXCJqc3RyZWUtY2hlY2tlZFwiKTtcblx0XHRcdFx0XHRcdFx0XHRpZihyYykgeyAkdGhpcy5jaGlsZHJlbihcIjpjaGVja2JveFwiKS5wcm9wKFwiY2hlY2tlZFwiLCB0cnVlKTsgfVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodGhpcy5kYXRhLnVpICYmIHRoaXMuZGF0YS5jaGVja2JveC5ub3VpKSB7IHRoaXMuZGF0YS51aS5zZWxlY3RlZCA9IHRoaXMuZ2V0X2NoZWNrZWQoKTsgfVxuXHRcdFx0XHR0aGlzLl9fY2FsbGJhY2sob2JqKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0Y2hlY2tfbm9kZSA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0aWYodGhpcy5jaGFuZ2Vfc3RhdGUob2JqLCBmYWxzZSkpIHsgXG5cdFx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0XHRpZih0aGlzLl9nZXRfc2V0dGluZ3MoKS5jaGVja2JveC5jaGVja2VkX3BhcmVudF9vcGVuKSB7XG5cdFx0XHRcdFx0XHR2YXIgdCA9IHRoaXM7XG5cdFx0XHRcdFx0XHRvYmoucGFyZW50cyhcIi5qc3RyZWUtY2xvc2VkXCIpLmVhY2goZnVuY3Rpb24gKCkgeyB0Lm9wZW5fbm9kZSh0aGlzLCBmYWxzZSwgdHJ1ZSk7IH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogb2JqIH0pOyBcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVuY2hlY2tfbm9kZSA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0aWYodGhpcy5jaGFuZ2Vfc3RhdGUob2JqLCB0cnVlKSkgeyB0aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogdGhpcy5fZ2V0X25vZGUob2JqKSB9KTsgfVxuXHRcdFx0fSxcblx0XHRcdGNoZWNrX2FsbCA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIF90aGlzID0gdGhpcywgXG5cdFx0XHRcdFx0Y29sbCA9IHRoaXMuX2dldF9zZXR0aW5ncygpLmNoZWNrYm94LnR3b19zdGF0ZSA/IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmZpbmQoXCJsaVwiKSA6IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKFwibGlcIik7XG5cdFx0XHRcdGNvbGwuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0X3RoaXMuY2hhbmdlX3N0YXRlKHRoaXMsIGZhbHNlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjaygpO1xuXHRcdFx0fSxcblx0XHRcdHVuY2hlY2tfYWxsIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgX3RoaXMgPSB0aGlzLFxuXHRcdFx0XHRcdGNvbGwgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5jaGVja2JveC50d29fc3RhdGUgPyB0aGlzLmdldF9jb250YWluZXJfdWwoKS5maW5kKFwibGlcIikgOiB0aGlzLmdldF9jb250YWluZXJfdWwoKS5jaGlsZHJlbihcImxpXCIpO1xuXHRcdFx0XHRjb2xsLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdF90aGlzLmNoYW5nZV9zdGF0ZSh0aGlzLCB0cnVlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjaygpO1xuXHRcdFx0fSxcblxuXHRcdFx0aXNfY2hlY2tlZCA6IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRyZXR1cm4gb2JqLmxlbmd0aCA/IG9iai5pcyhcIi5qc3RyZWUtY2hlY2tlZFwiKSA6IGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdGdldF9jaGVja2VkIDogZnVuY3Rpb24gKG9iaiwgZ2V0X2FsbCkge1xuXHRcdFx0XHRvYmogPSAhb2JqIHx8IG9iaiA9PT0gLTEgPyB0aGlzLmdldF9jb250YWluZXIoKSA6IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdHJldHVybiBnZXRfYWxsIHx8IHRoaXMuX2dldF9zZXR0aW5ncygpLmNoZWNrYm94LnR3b19zdGF0ZSA/IG9iai5maW5kKFwiLmpzdHJlZS1jaGVja2VkXCIpIDogb2JqLmZpbmQoXCI+IHVsID4gLmpzdHJlZS1jaGVja2VkLCAuanN0cmVlLXVuZGV0ZXJtaW5lZCA+IHVsID4gLmpzdHJlZS1jaGVja2VkXCIpO1xuXHRcdFx0fSxcblx0XHRcdGdldF91bmNoZWNrZWQgOiBmdW5jdGlvbiAob2JqLCBnZXRfYWxsKSB7IFxuXHRcdFx0XHRvYmogPSAhb2JqIHx8IG9iaiA9PT0gLTEgPyB0aGlzLmdldF9jb250YWluZXIoKSA6IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdHJldHVybiBnZXRfYWxsIHx8IHRoaXMuX2dldF9zZXR0aW5ncygpLmNoZWNrYm94LnR3b19zdGF0ZSA/IG9iai5maW5kKFwiLmpzdHJlZS11bmNoZWNrZWRcIikgOiBvYmouZmluZChcIj4gdWwgPiAuanN0cmVlLXVuY2hlY2tlZCwgLmpzdHJlZS11bmRldGVybWluZWQgPiB1bCA+IC5qc3RyZWUtdW5jaGVja2VkXCIpO1xuXHRcdFx0fSxcblxuXHRcdFx0c2hvd19jaGVja2JveGVzIDogZnVuY3Rpb24gKCkgeyB0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcInVsXCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLW5vLWNoZWNrYm94ZXNcIik7IH0sXG5cdFx0XHRoaWRlX2NoZWNrYm94ZXMgOiBmdW5jdGlvbiAoKSB7IHRoaXMuZ2V0X2NvbnRhaW5lcigpLmNoaWxkcmVuKFwidWxcIikuYWRkQ2xhc3MoXCJqc3RyZWUtbm8tY2hlY2tib3hlc1wiKTsgfSxcblxuXHRcdFx0X3JlcGFpcl9zdGF0ZSA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0aWYoIW9iai5sZW5ndGgpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdGlmKHRoaXMuX2dldF9zZXR0aW5ncygpLmNoZWNrYm94LnR3b19zdGF0ZSkge1xuXHRcdFx0XHRcdG9iai5maW5kKCdsaScpLmFuZFNlbGYoKS5ub3QoJy5qc3RyZWUtY2hlY2tlZCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtdW5kZXRlcm1pbmVkJykuYWRkQ2xhc3MoJ2pzdHJlZS11bmNoZWNrZWQnKS5jaGlsZHJlbignOmNoZWNrYm94JykucHJvcCgnY2hlY2tlZCcsIHRydWUpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgcmMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS5jaGVja2JveC5yZWFsX2NoZWNrYm94ZXMsXG5cdFx0XHRcdFx0YSA9IG9iai5maW5kKFwiPiB1bCA+IC5qc3RyZWUtY2hlY2tlZFwiKS5sZW5ndGgsXG5cdFx0XHRcdFx0YiA9IG9iai5maW5kKFwiPiB1bCA+IC5qc3RyZWUtdW5kZXRlcm1pbmVkXCIpLmxlbmd0aCxcblx0XHRcdFx0XHRjID0gb2JqLmZpbmQoXCI+IHVsID4gbGlcIikubGVuZ3RoO1xuXHRcdFx0XHRpZihjID09PSAwKSB7IGlmKG9iai5oYXNDbGFzcyhcImpzdHJlZS11bmRldGVybWluZWRcIikpIHsgdGhpcy5jaGFuZ2Vfc3RhdGUob2JqLCBmYWxzZSk7IH0gfVxuXHRcdFx0XHRlbHNlIGlmKGEgPT09IDAgJiYgYiA9PT0gMCkgeyB0aGlzLmNoYW5nZV9zdGF0ZShvYmosIHRydWUpOyB9XG5cdFx0XHRcdGVsc2UgaWYoYSA9PT0gYykgeyB0aGlzLmNoYW5nZV9zdGF0ZShvYmosIGZhbHNlKTsgfVxuXHRcdFx0XHRlbHNlIHsgXG5cdFx0XHRcdFx0b2JqLnBhcmVudHNVbnRpbChcIi5qc3RyZWVcIixcImxpXCIpLmFuZFNlbGYoKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1jaGVja2VkIGpzdHJlZS11bmNoZWNrZWRcIikuYWRkQ2xhc3MoXCJqc3RyZWUtdW5kZXRlcm1pbmVkXCIpO1xuXHRcdFx0XHRcdGlmKHJjKSB7IG9iai5wYXJlbnRzVW50aWwoXCIuanN0cmVlXCIsIFwibGlcIikuYW5kU2VsZigpLmNoaWxkcmVuKFwiOmNoZWNrYm94XCIpLnByb3AoXCJjaGVja2VkXCIsIGZhbHNlKTsgfVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVzZWxlY3QgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmKHRoaXMuZGF0YS51aSAmJiB0aGlzLmRhdGEuY2hlY2tib3gubm91aSkgeyBcblx0XHRcdFx0XHR2YXIgX3RoaXMgPSB0aGlzLFxuXHRcdFx0XHRcdFx0cyA9IHRoaXMuZGF0YS51aS50b19zZWxlY3Q7XG5cdFx0XHRcdFx0cyA9ICQubWFwKCQubWFrZUFycmF5KHMpLCBmdW5jdGlvbiAobikgeyByZXR1cm4gXCIjXCIgKyBuLnRvU3RyaW5nKCkucmVwbGFjZSgvXiMvLFwiXCIpLnJlcGxhY2UoL1xcXFxcXC8vZyxcIi9cIikucmVwbGFjZSgvXFwvL2csXCJcXFxcXFwvXCIpLnJlcGxhY2UoL1xcXFxcXC4vZyxcIi5cIikucmVwbGFjZSgvXFwuL2csXCJcXFxcLlwiKS5yZXBsYWNlKC9cXDovZyxcIlxcXFw6XCIpOyB9KTtcblx0XHRcdFx0XHR0aGlzLmRlc2VsZWN0X2FsbCgpO1xuXHRcdFx0XHRcdCQuZWFjaChzLCBmdW5jdGlvbiAoaSwgdmFsKSB7IF90aGlzLmNoZWNrX25vZGUodmFsKTsgfSk7XG5cdFx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7IFxuXHRcdFx0XHRcdHRoaXMuX19jYWxsX29sZCgpOyBcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHNhdmVfbG9hZGVkIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdFx0XHR0aGlzLmRhdGEuY29yZS50b19sb2FkID0gW107XG5cdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmZpbmQoXCJsaS5qc3RyZWUtY2xvc2VkLmpzdHJlZS11bmRldGVybWluZWRcIikuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0aWYodGhpcy5pZCkgeyBfdGhpcy5kYXRhLmNvcmUudG9fbG9hZC5wdXNoKFwiI1wiICsgdGhpcy5pZCk7IH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblx0JChmdW5jdGlvbigpIHtcblx0XHR2YXIgY3NzX3N0cmluZyA9ICcuanN0cmVlIC5qc3RyZWUtcmVhbC1jaGVja2JveCB7IGRpc3BsYXk6bm9uZTsgfSAnO1xuXHRcdCQudmFrYXRhLmNzcy5hZGRfc2hlZXQoeyBzdHIgOiBjc3Nfc3RyaW5nLCB0aXRsZSA6IFwianN0cmVlXCIgfSk7XG5cdH0pO1xufSkoalF1ZXJ5KTtcbi8vKi9cblxuLyogXG4gKiBqc1RyZWUgWE1MIHBsdWdpblxuICogVGhlIFhNTCBkYXRhIHN0b3JlLiBEYXRhc3RvcmVzIGFyZSBidWlsZCBieSBvdmVycmlkaW5nIHRoZSBgbG9hZF9ub2RlYCBhbmQgYF9pc19sb2FkZWRgIGZ1bmN0aW9ucy5cbiAqL1xuKGZ1bmN0aW9uICgkKSB7XG5cdCQudmFrYXRhLnhzbHQgPSBmdW5jdGlvbiAoeG1sLCB4c2wsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHJzID0gXCJcIiwgeG0sIHhzLCBwcm9jZXNzb3IsIHN1cHBvcnQ7XG5cdFx0Ly8gVE9ETzogSUU5IG5vIFhTTFRQcm9jZXNzb3IsIG5vIGRvY3VtZW50LnJlY2FsY1xuXHRcdGlmKGRvY3VtZW50LnJlY2FsYykge1xuXHRcdFx0eG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd4bWwnKTtcblx0XHRcdHhzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgneG1sJyk7XG5cdFx0XHR4bS5pbm5lckhUTUwgPSB4bWw7XG5cdFx0XHR4cy5pbm5lckhUTUwgPSB4c2w7XG5cdFx0XHQkKFwiYm9keVwiKS5hcHBlbmQoeG0pLmFwcGVuZCh4cyk7XG5cdFx0XHRzZXRUaW1lb3V0KCAoZnVuY3Rpb24gKHhtLCB4cywgY2FsbGJhY2spIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKG51bGwsIHhtLnRyYW5zZm9ybU5vZGUoeHMuWE1MRG9jdW1lbnQpKTtcblx0XHRcdFx0XHRzZXRUaW1lb3V0KCAoZnVuY3Rpb24gKHhtLCB4cykgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyAkKHhtKS5yZW1vdmUoKTsgJCh4cykucmVtb3ZlKCk7IH07IH0pKHhtLCB4cyksIDIwMCk7XG5cdFx0XHRcdH07XG5cdFx0XHR9KSh4bSwgeHMsIGNhbGxiYWNrKSwgMTAwKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRpZih0eXBlb2Ygd2luZG93LkRPTVBhcnNlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LlhNTEh0dHBSZXF1ZXN0ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuWFNMVFByb2Nlc3NvciA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0eG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh4bWwsIFwidGV4dC94bWxcIik7XG5cdFx0XHR4c2wgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHhzbCwgXCJ0ZXh0L3htbFwiKTtcblx0XHRcdC8vIGFsZXJ0KHhtbC50cmFuc2Zvcm1Ob2RlKCkpO1xuXHRcdFx0Ly8gY2FsbGJhY2suY2FsbChudWxsLCBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHJzKSk7XG5cdFx0XHRcblx0XHR9XG5cdFx0aWYodHlwZW9mIHdpbmRvdy5ET01QYXJzZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5YTUxIdHRwUmVxdWVzdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LlhTTFRQcm9jZXNzb3IgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHByb2Nlc3NvciA9IG5ldyBYU0xUUHJvY2Vzc29yKCk7XG5cdFx0XHRzdXBwb3J0ID0gJC5pc0Z1bmN0aW9uKHByb2Nlc3Nvci50cmFuc2Zvcm1Eb2N1bWVudCkgPyAodHlwZW9mIHdpbmRvdy5YTUxTZXJpYWxpemVyICE9PSBcInVuZGVmaW5lZFwiKSA6IHRydWU7XG5cdFx0XHRpZighc3VwcG9ydCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdHhtbCA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoeG1sLCBcInRleHQveG1sXCIpO1xuXHRcdFx0eHNsID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh4c2wsIFwidGV4dC94bWxcIik7XG5cdFx0XHRpZigkLmlzRnVuY3Rpb24ocHJvY2Vzc29yLnRyYW5zZm9ybURvY3VtZW50KSkge1xuXHRcdFx0XHRycyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50KFwiXCIsIFwiXCIsIG51bGwpO1xuXHRcdFx0XHRwcm9jZXNzb3IudHJhbnNmb3JtRG9jdW1lbnQoeG1sLCB4c2wsIHJzLCBudWxsKTtcblx0XHRcdFx0Y2FsbGJhY2suY2FsbChudWxsLCBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHJzKSk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHByb2Nlc3Nvci5pbXBvcnRTdHlsZXNoZWV0KHhzbCk7XG5cdFx0XHRcdHJzID0gcHJvY2Vzc29yLnRyYW5zZm9ybVRvRnJhZ21lbnQoeG1sLCBkb2N1bWVudCk7XG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwobnVsbCwgJChcIjxkaXYgLz5cIikuYXBwZW5kKHJzKS5odG1sKCkpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXHR2YXIgeHNsID0ge1xuXHRcdCduZXN0JyA6ICc8JyArICc/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cInV0Zi04XCIgPz4nICsgXG5cdFx0XHQnPHhzbDpzdHlsZXNoZWV0IHZlcnNpb249XCIxLjBcIiB4bWxuczp4c2w9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L1hTTC9UcmFuc2Zvcm1cIiA+JyArIFxuXHRcdFx0Jzx4c2w6b3V0cHV0IG1ldGhvZD1cImh0bWxcIiBlbmNvZGluZz1cInV0Zi04XCIgb21pdC14bWwtZGVjbGFyYXRpb249XCJ5ZXNcIiBzdGFuZGFsb25lPVwibm9cIiBpbmRlbnQ9XCJub1wiIG1lZGlhLXR5cGU9XCJ0ZXh0L2h0bWxcIiAvPicgKyBcblx0XHRcdCc8eHNsOnRlbXBsYXRlIG1hdGNoPVwiL1wiPicgKyBcblx0XHRcdCdcdDx4c2w6Y2FsbC10ZW1wbGF0ZSBuYW1lPVwibm9kZXNcIj4nICsgXG5cdFx0XHQnXHRcdDx4c2w6d2l0aC1wYXJhbSBuYW1lPVwibm9kZVwiIHNlbGVjdD1cIi9yb290XCIgLz4nICsgXG5cdFx0XHQnXHQ8L3hzbDpjYWxsLXRlbXBsYXRlPicgKyBcblx0XHRcdCc8L3hzbDp0ZW1wbGF0ZT4nICsgXG5cdFx0XHQnPHhzbDp0ZW1wbGF0ZSBuYW1lPVwibm9kZXNcIj4nICsgXG5cdFx0XHQnXHQ8eHNsOnBhcmFtIG5hbWU9XCJub2RlXCIgLz4nICsgXG5cdFx0XHQnXHQ8dWw+JyArIFxuXHRcdFx0J1x0PHhzbDpmb3ItZWFjaCBzZWxlY3Q9XCIkbm9kZS9pdGVtXCI+JyArIFxuXHRcdFx0J1x0XHQ8eHNsOnZhcmlhYmxlIG5hbWU9XCJjaGlsZHJlblwiIHNlbGVjdD1cImNvdW50KC4vaXRlbSkgJmd0OyAwXCIgLz4nICsgXG5cdFx0XHQnXHRcdDxsaT4nICsgXG5cdFx0XHQnXHRcdFx0PHhzbDphdHRyaWJ1dGUgbmFtZT1cImNsYXNzXCI+JyArIFxuXHRcdFx0J1x0XHRcdFx0PHhzbDppZiB0ZXN0PVwicG9zaXRpb24oKSA9IGxhc3QoKVwiPmpzdHJlZS1sYXN0IDwveHNsOmlmPicgKyBcblx0XHRcdCdcdFx0XHRcdDx4c2w6Y2hvb3NlPicgKyBcblx0XHRcdCdcdFx0XHRcdFx0PHhzbDp3aGVuIHRlc3Q9XCJAc3RhdGUgPSBcXCdvcGVuXFwnXCI+anN0cmVlLW9wZW4gPC94c2w6d2hlbj4nICsgXG5cdFx0XHQnXHRcdFx0XHRcdDx4c2w6d2hlbiB0ZXN0PVwiJGNoaWxkcmVuIG9yIEBoYXNDaGlsZHJlbiBvciBAc3RhdGUgPSBcXCdjbG9zZWRcXCdcIj5qc3RyZWUtY2xvc2VkIDwveHNsOndoZW4+JyArIFxuXHRcdFx0J1x0XHRcdFx0XHQ8eHNsOm90aGVyd2lzZT5qc3RyZWUtbGVhZiA8L3hzbDpvdGhlcndpc2U+JyArIFxuXHRcdFx0J1x0XHRcdFx0PC94c2w6Y2hvb3NlPicgKyBcblx0XHRcdCdcdFx0XHRcdDx4c2w6dmFsdWUtb2Ygc2VsZWN0PVwiQGNsYXNzXCIgLz4nICsgXG5cdFx0XHQnXHRcdFx0PC94c2w6YXR0cmlidXRlPicgKyBcblx0XHRcdCdcdFx0XHQ8eHNsOmZvci1lYWNoIHNlbGVjdD1cIkAqXCI+JyArIFxuXHRcdFx0J1x0XHRcdFx0PHhzbDppZiB0ZXN0PVwibmFtZSgpICE9IFxcJ2NsYXNzXFwnIGFuZCBuYW1lKCkgIT0gXFwnc3RhdGVcXCcgYW5kIG5hbWUoKSAhPSBcXCdoYXNDaGlsZHJlblxcJ1wiPicgKyBcblx0XHRcdCdcdFx0XHRcdFx0PHhzbDphdHRyaWJ1dGUgbmFtZT1cIntuYW1lKCl9XCI+PHhzbDp2YWx1ZS1vZiBzZWxlY3Q9XCIuXCIgLz48L3hzbDphdHRyaWJ1dGU+JyArIFxuXHRcdFx0J1x0XHRcdFx0PC94c2w6aWY+JyArIFxuXHRcdFx0J1x0XHRcdDwveHNsOmZvci1lYWNoPicgKyBcblx0XHRcdCdcdDxpbnMgY2xhc3M9XCJqc3RyZWUtaWNvblwiPjx4c2w6dGV4dD4mI3hhMDs8L3hzbDp0ZXh0PjwvaW5zPicgKyBcblx0XHRcdCdcdFx0XHQ8eHNsOmZvci1lYWNoIHNlbGVjdD1cImNvbnRlbnQvbmFtZVwiPicgKyBcblx0XHRcdCdcdFx0XHRcdDxhPicgKyBcblx0XHRcdCdcdFx0XHRcdDx4c2w6YXR0cmlidXRlIG5hbWU9XCJocmVmXCI+JyArIFxuXHRcdFx0J1x0XHRcdFx0XHQ8eHNsOmNob29zZT4nICsgXG5cdFx0XHQnXHRcdFx0XHRcdDx4c2w6d2hlbiB0ZXN0PVwiQGhyZWZcIj48eHNsOnZhbHVlLW9mIHNlbGVjdD1cIkBocmVmXCIgLz48L3hzbDp3aGVuPicgKyBcblx0XHRcdCdcdFx0XHRcdFx0PHhzbDpvdGhlcndpc2U+IzwveHNsOm90aGVyd2lzZT4nICsgXG5cdFx0XHQnXHRcdFx0XHRcdDwveHNsOmNob29zZT4nICsgXG5cdFx0XHQnXHRcdFx0XHQ8L3hzbDphdHRyaWJ1dGU+JyArIFxuXHRcdFx0J1x0XHRcdFx0PHhzbDphdHRyaWJ1dGUgbmFtZT1cImNsYXNzXCI+PHhzbDp2YWx1ZS1vZiBzZWxlY3Q9XCJAbGFuZ1wiIC8+IDx4c2w6dmFsdWUtb2Ygc2VsZWN0PVwiQGNsYXNzXCIgLz48L3hzbDphdHRyaWJ1dGU+JyArIFxuXHRcdFx0J1x0XHRcdFx0PHhzbDphdHRyaWJ1dGUgbmFtZT1cInN0eWxlXCI+PHhzbDp2YWx1ZS1vZiBzZWxlY3Q9XCJAc3R5bGVcIiAvPjwveHNsOmF0dHJpYnV0ZT4nICsgXG5cdFx0XHQnXHRcdFx0XHQ8eHNsOmZvci1lYWNoIHNlbGVjdD1cIkAqXCI+JyArIFxuXHRcdFx0J1x0XHRcdFx0XHQ8eHNsOmlmIHRlc3Q9XCJuYW1lKCkgIT0gXFwnc3R5bGVcXCcgYW5kIG5hbWUoKSAhPSBcXCdjbGFzc1xcJyBhbmQgbmFtZSgpICE9IFxcJ2hyZWZcXCdcIj4nICsgXG5cdFx0XHQnXHRcdFx0XHRcdFx0PHhzbDphdHRyaWJ1dGUgbmFtZT1cIntuYW1lKCl9XCI+PHhzbDp2YWx1ZS1vZiBzZWxlY3Q9XCIuXCIgLz48L3hzbDphdHRyaWJ1dGU+JyArIFxuXHRcdFx0J1x0XHRcdFx0XHQ8L3hzbDppZj4nICsgXG5cdFx0XHQnXHRcdFx0XHQ8L3hzbDpmb3ItZWFjaD4nICsgXG5cdFx0XHQnXHRcdFx0XHRcdDxpbnM+JyArIFxuXHRcdFx0J1x0XHRcdFx0XHRcdDx4c2w6YXR0cmlidXRlIG5hbWU9XCJjbGFzc1wiPmpzdHJlZS1pY29uICcgKyBcblx0XHRcdCdcdFx0XHRcdFx0XHRcdDx4c2w6aWYgdGVzdD1cInN0cmluZy1sZW5ndGgoYXR0cmlidXRlOjppY29uKSA+IDAgYW5kIG5vdChjb250YWlucyhAaWNvbixcXCcvXFwnKSlcIj48eHNsOnZhbHVlLW9mIHNlbGVjdD1cIkBpY29uXCIgLz48L3hzbDppZj4nICsgXG5cdFx0XHQnXHRcdFx0XHRcdFx0PC94c2w6YXR0cmlidXRlPicgKyBcblx0XHRcdCdcdFx0XHRcdFx0XHQ8eHNsOmlmIHRlc3Q9XCJzdHJpbmctbGVuZ3RoKGF0dHJpYnV0ZTo6aWNvbikgPiAwIGFuZCBjb250YWlucyhAaWNvbixcXCcvXFwnKVwiPjx4c2w6YXR0cmlidXRlIG5hbWU9XCJzdHlsZVwiPmJhY2tncm91bmQ6dXJsKDx4c2w6dmFsdWUtb2Ygc2VsZWN0PVwiQGljb25cIiAvPikgY2VudGVyIGNlbnRlciBuby1yZXBlYXQ7PC94c2w6YXR0cmlidXRlPjwveHNsOmlmPicgKyBcblx0XHRcdCdcdFx0XHRcdFx0XHQ8eHNsOnRleHQ+JiN4YTA7PC94c2w6dGV4dD4nICsgXG5cdFx0XHQnXHRcdFx0XHRcdDwvaW5zPicgKyBcblx0XHRcdCdcdFx0XHRcdFx0PHhzbDpjb3B5LW9mIHNlbGVjdD1cIi4vY2hpbGQ6Om5vZGUoKVwiIC8+JyArIFxuXHRcdFx0J1x0XHRcdFx0PC9hPicgKyBcblx0XHRcdCdcdFx0XHQ8L3hzbDpmb3ItZWFjaD4nICsgXG5cdFx0XHQnXHRcdFx0PHhzbDppZiB0ZXN0PVwiJGNoaWxkcmVuIG9yIEBoYXNDaGlsZHJlblwiPjx4c2w6Y2FsbC10ZW1wbGF0ZSBuYW1lPVwibm9kZXNcIj48eHNsOndpdGgtcGFyYW0gbmFtZT1cIm5vZGVcIiBzZWxlY3Q9XCJjdXJyZW50KClcIiAvPjwveHNsOmNhbGwtdGVtcGxhdGU+PC94c2w6aWY+JyArIFxuXHRcdFx0J1x0XHQ8L2xpPicgKyBcblx0XHRcdCdcdDwveHNsOmZvci1lYWNoPicgKyBcblx0XHRcdCdcdDwvdWw+JyArIFxuXHRcdFx0JzwveHNsOnRlbXBsYXRlPicgKyBcblx0XHRcdCc8L3hzbDpzdHlsZXNoZWV0PicsXG5cblx0XHQnZmxhdCcgOiAnPCcgKyAnP3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJ1dGYtOFwiID8+JyArIFxuXHRcdFx0Jzx4c2w6c3R5bGVzaGVldCB2ZXJzaW9uPVwiMS4wXCIgeG1sbnM6eHNsPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS9YU0wvVHJhbnNmb3JtXCIgPicgKyBcblx0XHRcdCc8eHNsOm91dHB1dCBtZXRob2Q9XCJodG1sXCIgZW5jb2Rpbmc9XCJ1dGYtOFwiIG9taXQteG1sLWRlY2xhcmF0aW9uPVwieWVzXCIgc3RhbmRhbG9uZT1cIm5vXCIgaW5kZW50PVwibm9cIiBtZWRpYS10eXBlPVwidGV4dC94bWxcIiAvPicgKyBcblx0XHRcdCc8eHNsOnRlbXBsYXRlIG1hdGNoPVwiL1wiPicgKyBcblx0XHRcdCdcdDx1bD4nICsgXG5cdFx0XHQnXHQ8eHNsOmZvci1lYWNoIHNlbGVjdD1cIi8vaXRlbVtub3QoQHBhcmVudF9pZCkgb3IgQHBhcmVudF9pZD0wIG9yIG5vdChAcGFyZW50X2lkID0gLy9pdGVtL0BpZCldXCI+JyArIC8qIHRoZSBsYXN0IGBvcmAgbWF5IGJlIHJlbW92ZWQgKi9cblx0XHRcdCdcdFx0PHhzbDpjYWxsLXRlbXBsYXRlIG5hbWU9XCJub2Rlc1wiPicgKyBcblx0XHRcdCdcdFx0XHQ8eHNsOndpdGgtcGFyYW0gbmFtZT1cIm5vZGVcIiBzZWxlY3Q9XCIuXCIgLz4nICsgXG5cdFx0XHQnXHRcdFx0PHhzbDp3aXRoLXBhcmFtIG5hbWU9XCJpc19sYXN0XCIgc2VsZWN0PVwibnVtYmVyKHBvc2l0aW9uKCkgPSBsYXN0KCkpXCIgLz4nICsgXG5cdFx0XHQnXHRcdDwveHNsOmNhbGwtdGVtcGxhdGU+JyArIFxuXHRcdFx0J1x0PC94c2w6Zm9yLWVhY2g+JyArIFxuXHRcdFx0J1x0PC91bD4nICsgXG5cdFx0XHQnPC94c2w6dGVtcGxhdGU+JyArIFxuXHRcdFx0Jzx4c2w6dGVtcGxhdGUgbmFtZT1cIm5vZGVzXCI+JyArIFxuXHRcdFx0J1x0PHhzbDpwYXJhbSBuYW1lPVwibm9kZVwiIC8+JyArIFxuXHRcdFx0J1x0PHhzbDpwYXJhbSBuYW1lPVwiaXNfbGFzdFwiIC8+JyArIFxuXHRcdFx0J1x0PHhzbDp2YXJpYWJsZSBuYW1lPVwiY2hpbGRyZW5cIiBzZWxlY3Q9XCJjb3VudCgvL2l0ZW1bQHBhcmVudF9pZD0kbm9kZS9hdHRyaWJ1dGU6OmlkXSkgJmd0OyAwXCIgLz4nICsgXG5cdFx0XHQnXHQ8bGk+JyArIFxuXHRcdFx0J1x0PHhzbDphdHRyaWJ1dGUgbmFtZT1cImNsYXNzXCI+JyArIFxuXHRcdFx0J1x0XHQ8eHNsOmlmIHRlc3Q9XCIkaXNfbGFzdCA9IHRydWUoKVwiPmpzdHJlZS1sYXN0IDwveHNsOmlmPicgKyBcblx0XHRcdCdcdFx0PHhzbDpjaG9vc2U+JyArIFxuXHRcdFx0J1x0XHRcdDx4c2w6d2hlbiB0ZXN0PVwiQHN0YXRlID0gXFwnb3BlblxcJ1wiPmpzdHJlZS1vcGVuIDwveHNsOndoZW4+JyArIFxuXHRcdFx0J1x0XHRcdDx4c2w6d2hlbiB0ZXN0PVwiJGNoaWxkcmVuIG9yIEBoYXNDaGlsZHJlbiBvciBAc3RhdGUgPSBcXCdjbG9zZWRcXCdcIj5qc3RyZWUtY2xvc2VkIDwveHNsOndoZW4+JyArIFxuXHRcdFx0J1x0XHRcdDx4c2w6b3RoZXJ3aXNlPmpzdHJlZS1sZWFmIDwveHNsOm90aGVyd2lzZT4nICsgXG5cdFx0XHQnXHRcdDwveHNsOmNob29zZT4nICsgXG5cdFx0XHQnXHRcdDx4c2w6dmFsdWUtb2Ygc2VsZWN0PVwiQGNsYXNzXCIgLz4nICsgXG5cdFx0XHQnXHQ8L3hzbDphdHRyaWJ1dGU+JyArIFxuXHRcdFx0J1x0PHhzbDpmb3ItZWFjaCBzZWxlY3Q9XCJAKlwiPicgKyBcblx0XHRcdCdcdFx0PHhzbDppZiB0ZXN0PVwibmFtZSgpICE9IFxcJ3BhcmVudF9pZFxcJyBhbmQgbmFtZSgpICE9IFxcJ2hhc0NoaWxkcmVuXFwnIGFuZCBuYW1lKCkgIT0gXFwnY2xhc3NcXCcgYW5kIG5hbWUoKSAhPSBcXCdzdGF0ZVxcJ1wiPicgKyBcblx0XHRcdCdcdFx0PHhzbDphdHRyaWJ1dGUgbmFtZT1cIntuYW1lKCl9XCI+PHhzbDp2YWx1ZS1vZiBzZWxlY3Q9XCIuXCIgLz48L3hzbDphdHRyaWJ1dGU+JyArIFxuXHRcdFx0J1x0XHQ8L3hzbDppZj4nICsgXG5cdFx0XHQnXHQ8L3hzbDpmb3ItZWFjaD4nICsgXG5cdFx0XHQnXHQ8aW5zIGNsYXNzPVwianN0cmVlLWljb25cIj48eHNsOnRleHQ+JiN4YTA7PC94c2w6dGV4dD48L2lucz4nICsgXG5cdFx0XHQnXHQ8eHNsOmZvci1lYWNoIHNlbGVjdD1cImNvbnRlbnQvbmFtZVwiPicgKyBcblx0XHRcdCdcdFx0PGE+JyArIFxuXHRcdFx0J1x0XHQ8eHNsOmF0dHJpYnV0ZSBuYW1lPVwiaHJlZlwiPicgKyBcblx0XHRcdCdcdFx0XHQ8eHNsOmNob29zZT4nICsgXG5cdFx0XHQnXHRcdFx0PHhzbDp3aGVuIHRlc3Q9XCJAaHJlZlwiPjx4c2w6dmFsdWUtb2Ygc2VsZWN0PVwiQGhyZWZcIiAvPjwveHNsOndoZW4+JyArIFxuXHRcdFx0J1x0XHRcdDx4c2w6b3RoZXJ3aXNlPiM8L3hzbDpvdGhlcndpc2U+JyArIFxuXHRcdFx0J1x0XHRcdDwveHNsOmNob29zZT4nICsgXG5cdFx0XHQnXHRcdDwveHNsOmF0dHJpYnV0ZT4nICsgXG5cdFx0XHQnXHRcdDx4c2w6YXR0cmlidXRlIG5hbWU9XCJjbGFzc1wiPjx4c2w6dmFsdWUtb2Ygc2VsZWN0PVwiQGxhbmdcIiAvPiA8eHNsOnZhbHVlLW9mIHNlbGVjdD1cIkBjbGFzc1wiIC8+PC94c2w6YXR0cmlidXRlPicgKyBcblx0XHRcdCdcdFx0PHhzbDphdHRyaWJ1dGUgbmFtZT1cInN0eWxlXCI+PHhzbDp2YWx1ZS1vZiBzZWxlY3Q9XCJAc3R5bGVcIiAvPjwveHNsOmF0dHJpYnV0ZT4nICsgXG5cdFx0XHQnXHRcdDx4c2w6Zm9yLWVhY2ggc2VsZWN0PVwiQCpcIj4nICsgXG5cdFx0XHQnXHRcdFx0PHhzbDppZiB0ZXN0PVwibmFtZSgpICE9IFxcJ3N0eWxlXFwnIGFuZCBuYW1lKCkgIT0gXFwnY2xhc3NcXCcgYW5kIG5hbWUoKSAhPSBcXCdocmVmXFwnXCI+JyArIFxuXHRcdFx0J1x0XHRcdFx0PHhzbDphdHRyaWJ1dGUgbmFtZT1cIntuYW1lKCl9XCI+PHhzbDp2YWx1ZS1vZiBzZWxlY3Q9XCIuXCIgLz48L3hzbDphdHRyaWJ1dGU+JyArIFxuXHRcdFx0J1x0XHRcdDwveHNsOmlmPicgKyBcblx0XHRcdCdcdFx0PC94c2w6Zm9yLWVhY2g+JyArIFxuXHRcdFx0J1x0XHRcdDxpbnM+JyArIFxuXHRcdFx0J1x0XHRcdFx0PHhzbDphdHRyaWJ1dGUgbmFtZT1cImNsYXNzXCI+anN0cmVlLWljb24gJyArIFxuXHRcdFx0J1x0XHRcdFx0XHQ8eHNsOmlmIHRlc3Q9XCJzdHJpbmctbGVuZ3RoKGF0dHJpYnV0ZTo6aWNvbikgPiAwIGFuZCBub3QoY29udGFpbnMoQGljb24sXFwnL1xcJykpXCI+PHhzbDp2YWx1ZS1vZiBzZWxlY3Q9XCJAaWNvblwiIC8+PC94c2w6aWY+JyArIFxuXHRcdFx0J1x0XHRcdFx0PC94c2w6YXR0cmlidXRlPicgKyBcblx0XHRcdCdcdFx0XHRcdDx4c2w6aWYgdGVzdD1cInN0cmluZy1sZW5ndGgoYXR0cmlidXRlOjppY29uKSA+IDAgYW5kIGNvbnRhaW5zKEBpY29uLFxcJy9cXCcpXCI+PHhzbDphdHRyaWJ1dGUgbmFtZT1cInN0eWxlXCI+YmFja2dyb3VuZDp1cmwoPHhzbDp2YWx1ZS1vZiBzZWxlY3Q9XCJAaWNvblwiIC8+KSBjZW50ZXIgY2VudGVyIG5vLXJlcGVhdDs8L3hzbDphdHRyaWJ1dGU+PC94c2w6aWY+JyArIFxuXHRcdFx0J1x0XHRcdFx0PHhzbDp0ZXh0PiYjeGEwOzwveHNsOnRleHQ+JyArIFxuXHRcdFx0J1x0XHRcdDwvaW5zPicgKyBcblx0XHRcdCdcdFx0XHQ8eHNsOmNvcHktb2Ygc2VsZWN0PVwiLi9jaGlsZDo6bm9kZSgpXCIgLz4nICsgXG5cdFx0XHQnXHRcdDwvYT4nICsgXG5cdFx0XHQnXHQ8L3hzbDpmb3ItZWFjaD4nICsgXG5cdFx0XHQnXHQ8eHNsOmlmIHRlc3Q9XCIkY2hpbGRyZW5cIj4nICsgXG5cdFx0XHQnXHRcdDx1bD4nICsgXG5cdFx0XHQnXHRcdDx4c2w6Zm9yLWVhY2ggc2VsZWN0PVwiLy9pdGVtW0BwYXJlbnRfaWQ9JG5vZGUvYXR0cmlidXRlOjppZF1cIj4nICsgXG5cdFx0XHQnXHRcdFx0PHhzbDpjYWxsLXRlbXBsYXRlIG5hbWU9XCJub2Rlc1wiPicgKyBcblx0XHRcdCdcdFx0XHRcdDx4c2w6d2l0aC1wYXJhbSBuYW1lPVwibm9kZVwiIHNlbGVjdD1cIi5cIiAvPicgKyBcblx0XHRcdCdcdFx0XHRcdDx4c2w6d2l0aC1wYXJhbSBuYW1lPVwiaXNfbGFzdFwiIHNlbGVjdD1cIm51bWJlcihwb3NpdGlvbigpID0gbGFzdCgpKVwiIC8+JyArIFxuXHRcdFx0J1x0XHRcdDwveHNsOmNhbGwtdGVtcGxhdGU+JyArIFxuXHRcdFx0J1x0XHQ8L3hzbDpmb3ItZWFjaD4nICsgXG5cdFx0XHQnXHRcdDwvdWw+JyArIFxuXHRcdFx0J1x0PC94c2w6aWY+JyArIFxuXHRcdFx0J1x0PC9saT4nICsgXG5cdFx0XHQnPC94c2w6dGVtcGxhdGU+JyArIFxuXHRcdFx0JzwveHNsOnN0eWxlc2hlZXQ+J1xuXHR9LFxuXHRlc2NhcGVfeG1sID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHN0cmluZ1xuXHRcdFx0LnRvU3RyaW5nKClcblx0XHRcdC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG5cdFx0XHQucmVwbGFjZSgvPC9nLCAnJmx0OycpXG5cdFx0XHQucmVwbGFjZSgvPi9nLCAnJmd0OycpXG5cdFx0XHQucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG5cdFx0XHQucmVwbGFjZSgvJy9nLCAnJmFwb3M7Jyk7XG5cdH07XG5cdCQuanN0cmVlLnBsdWdpbihcInhtbF9kYXRhXCIsIHtcblx0XHRkZWZhdWx0cyA6IHsgXG5cdFx0XHRkYXRhIDogZmFsc2UsXG5cdFx0XHRhamF4IDogZmFsc2UsXG5cdFx0XHR4c2wgOiBcImZsYXRcIixcblx0XHRcdGNsZWFuX25vZGUgOiBmYWxzZSxcblx0XHRcdGNvcnJlY3Rfc3RhdGUgOiB0cnVlLFxuXHRcdFx0Z2V0X3NraXBfZW1wdHkgOiBmYWxzZSxcblx0XHRcdGdldF9pbmNsdWRlX3ByZWFtYmxlIDogdHJ1ZVxuXHRcdH0sXG5cdFx0X2ZuIDoge1xuXHRcdFx0bG9hZF9ub2RlIDogZnVuY3Rpb24gKG9iaiwgc19jYWxsLCBlX2NhbGwpIHsgdmFyIF90aGlzID0gdGhpczsgdGhpcy5sb2FkX25vZGVfeG1sKG9iaiwgZnVuY3Rpb24gKCkgeyBfdGhpcy5fX2NhbGxiYWNrKHsgXCJvYmpcIiA6IF90aGlzLl9nZXRfbm9kZShvYmopIH0pOyBzX2NhbGwuY2FsbCh0aGlzKTsgfSwgZV9jYWxsKTsgfSxcblx0XHRcdF9pc19sb2FkZWQgOiBmdW5jdGlvbiAob2JqKSB7IFxuXHRcdFx0XHR2YXIgcyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLnhtbF9kYXRhO1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRyZXR1cm4gb2JqID09IC0xIHx8ICFvYmogfHwgKCFzLmFqYXggJiYgISQuaXNGdW5jdGlvbihzLmRhdGEpKSB8fCBvYmouaXMoXCIuanN0cmVlLW9wZW4sIC5qc3RyZWUtbGVhZlwiKSB8fCBvYmouY2hpbGRyZW4oXCJ1bFwiKS5jaGlsZHJlbihcImxpXCIpLnNpemUoKSA+IDA7XG5cdFx0XHR9LFxuXHRcdFx0bG9hZF9ub2RlX3htbCA6IGZ1bmN0aW9uIChvYmosIHNfY2FsbCwgZV9jYWxsKSB7XG5cdFx0XHRcdHZhciBzID0gdGhpcy5nZXRfc2V0dGluZ3MoKS54bWxfZGF0YSxcblx0XHRcdFx0XHRlcnJvcl9mdW5jID0gZnVuY3Rpb24gKCkge30sXG5cdFx0XHRcdFx0c3VjY2Vzc19mdW5jID0gZnVuY3Rpb24gKCkge307XG5cblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0aWYob2JqICYmIG9iaiAhPT0gLTEpIHtcblx0XHRcdFx0XHRpZihvYmouZGF0YShcImpzdHJlZV9pc19sb2FkaW5nXCIpKSB7IHJldHVybjsgfVxuXHRcdFx0XHRcdGVsc2UgeyBvYmouZGF0YShcImpzdHJlZV9pc19sb2FkaW5nXCIsdHJ1ZSk7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2goITApIHtcblx0XHRcdFx0XHRjYXNlICghcy5kYXRhICYmICFzLmFqYXgpOiB0aHJvdyBcIk5laXRoZXIgZGF0YSBub3IgYWpheCBzZXR0aW5ncyBzdXBwbGllZC5cIjtcblx0XHRcdFx0XHRjYXNlICgkLmlzRnVuY3Rpb24ocy5kYXRhKSk6XG5cdFx0XHRcdFx0XHRzLmRhdGEuY2FsbCh0aGlzLCBvYmosICQucHJveHkoZnVuY3Rpb24gKGQpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5wYXJzZV94bWwoZCwgJC5wcm94eShmdW5jdGlvbiAoZCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmKGQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGQgPSBkLnJlcGxhY2UoLyA/eG1sbnM9XCJbXlwiXSpcIi9pZywgXCJcIik7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihkLmxlbmd0aCA+IDEwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGQgPSAkKGQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihvYmogPT09IC0xIHx8ICFvYmopIHsgdGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5lbXB0eSgpLmFwcGVuZChkLmNoaWxkcmVuKCkpOyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVsc2UgeyBvYmouY2hpbGRyZW4oXCJhLmpzdHJlZS1sb2FkaW5nXCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLWxvYWRpbmdcIik7IG9iai5hcHBlbmQoZCk7IG9iai5yZW1vdmVEYXRhKFwianN0cmVlX2lzX2xvYWRpbmdcIik7IH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYocy5jbGVhbl9ub2RlKSB7IHRoaXMuY2xlYW5fbm9kZShvYmopOyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHNfY2FsbCkgeyBzX2NhbGwuY2FsbCh0aGlzKTsgfVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKG9iaiAmJiBvYmogIT09IC0xKSB7IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9iai5jaGlsZHJlbihcImEuanN0cmVlLWxvYWRpbmdcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvYmoucmVtb3ZlRGF0YShcImpzdHJlZV9pc19sb2FkaW5nXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHMuY29ycmVjdF9zdGF0ZSkgeyBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuY29ycmVjdF9zdGF0ZShvYmopO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoc19jYWxsKSB7IHNfY2FsbC5jYWxsKHRoaXMpOyB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZihzLmNvcnJlY3Rfc3RhdGUpIHsgXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcInVsXCIpLmVtcHR5KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZihzX2NhbGwpIHsgc19jYWxsLmNhbGwodGhpcyk7IH0gXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICghIXMuZGF0YSAmJiAhcy5hamF4KSB8fCAoISFzLmRhdGEgJiYgISFzLmFqYXggJiYgKCFvYmogfHwgb2JqID09PSAtMSkpOlxuXHRcdFx0XHRcdFx0aWYoIW9iaiB8fCBvYmogPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5wYXJzZV94bWwocy5kYXRhLCAkLnByb3h5KGZ1bmN0aW9uIChkKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYoZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZCA9IGQucmVwbGFjZSgvID94bWxucz1cIlteXCJdKlwiL2lnLCBcIlwiKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKGQubGVuZ3RoID4gMTApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZCA9ICQoZCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpLmNoaWxkcmVuKFwidWxcIikuZW1wdHkoKS5hcHBlbmQoZC5jaGlsZHJlbigpKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYocy5jbGVhbl9ub2RlKSB7IHRoaXMuY2xlYW5fbm9kZShvYmopOyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHNfY2FsbCkgeyBzX2NhbGwuY2FsbCh0aGlzKTsgfVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlIHsgXG5cdFx0XHRcdFx0XHRcdFx0XHRpZihzLmNvcnJlY3Rfc3RhdGUpIHsgXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpLmNoaWxkcmVuKFwidWxcIikuZW1wdHkoKTsgXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHNfY2FsbCkgeyBzX2NhbGwuY2FsbCh0aGlzKTsgfVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAoIXMuZGF0YSAmJiAhIXMuYWpheCkgfHwgKCEhcy5kYXRhICYmICEhcy5hamF4ICYmIG9iaiAmJiBvYmogIT09IC0xKTpcblx0XHRcdFx0XHRcdGVycm9yX2Z1bmMgPSBmdW5jdGlvbiAoeCwgdCwgZSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgZWYgPSB0aGlzLmdldF9zZXR0aW5ncygpLnhtbF9kYXRhLmFqYXguZXJyb3I7IFxuXHRcdFx0XHRcdFx0XHRpZihlZikgeyBlZi5jYWxsKHRoaXMsIHgsIHQsIGUpOyB9XG5cdFx0XHRcdFx0XHRcdGlmKG9iaiAhPT0gLTEgJiYgb2JqLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdG9iai5jaGlsZHJlbihcImEuanN0cmVlLWxvYWRpbmdcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKTtcblx0XHRcdFx0XHRcdFx0XHRvYmoucmVtb3ZlRGF0YShcImpzdHJlZV9pc19sb2FkaW5nXCIpO1xuXHRcdFx0XHRcdFx0XHRcdGlmKHQgPT09IFwic3VjY2Vzc1wiICYmIHMuY29ycmVjdF9zdGF0ZSkgeyB0aGlzLmNvcnJlY3Rfc3RhdGUob2JqKTsgfVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGlmKHQgPT09IFwic3VjY2Vzc1wiICYmIHMuY29ycmVjdF9zdGF0ZSkgeyB0aGlzLmdldF9jb250YWluZXIoKS5jaGlsZHJlbihcInVsXCIpLmVtcHR5KCk7IH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZihlX2NhbGwpIHsgZV9jYWxsLmNhbGwodGhpcyk7IH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRzdWNjZXNzX2Z1bmMgPSBmdW5jdGlvbiAoZCwgdCwgeCkge1xuXHRcdFx0XHRcdFx0XHRkID0geC5yZXNwb25zZVRleHQ7XG5cdFx0XHRcdFx0XHRcdHZhciBzZiA9IHRoaXMuZ2V0X3NldHRpbmdzKCkueG1sX2RhdGEuYWpheC5zdWNjZXNzOyBcblx0XHRcdFx0XHRcdFx0aWYoc2YpIHsgZCA9IHNmLmNhbGwodGhpcyxkLHQseCkgfHwgZDsgfVxuXHRcdFx0XHRcdFx0XHRpZihkID09PSBcIlwiIHx8IChkICYmIGQudG9TdHJpbmcgJiYgZC50b1N0cmluZygpLnJlcGxhY2UoL15bXFxzXFxuXSskLyxcIlwiKSA9PT0gXCJcIikpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3JfZnVuYy5jYWxsKHRoaXMsIHgsIHQsIFwiXCIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRoaXMucGFyc2VfeG1sKGQsICQucHJveHkoZnVuY3Rpb24gKGQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZihkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkID0gZC5yZXBsYWNlKC8gP3htbG5zPVwiW15cIl0qXCIvaWcsIFwiXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYoZC5sZW5ndGggPiAxMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRkID0gJChkKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYob2JqID09PSAtMSB8fCAhb2JqKSB7IHRoaXMuZ2V0X2NvbnRhaW5lcigpLmNoaWxkcmVuKFwidWxcIikuZW1wdHkoKS5hcHBlbmQoZC5jaGlsZHJlbigpKTsgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRlbHNlIHsgb2JqLmNoaWxkcmVuKFwiYS5qc3RyZWUtbG9hZGluZ1wiKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1sb2FkaW5nXCIpOyBvYmouYXBwZW5kKGQpOyBvYmoucmVtb3ZlRGF0YShcImpzdHJlZV9pc19sb2FkaW5nXCIpOyB9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHMuY2xlYW5fbm9kZSkgeyB0aGlzLmNsZWFuX25vZGUob2JqKTsgfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihzX2NhbGwpIHsgc19jYWxsLmNhbGwodGhpcyk7IH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihvYmogJiYgb2JqICE9PSAtMSkgeyBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvYmouY2hpbGRyZW4oXCJhLmpzdHJlZS1sb2FkaW5nXCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLWxvYWRpbmdcIik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b2JqLnJlbW92ZURhdGEoXCJqc3RyZWVfaXNfbG9hZGluZ1wiKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZihzLmNvcnJlY3Rfc3RhdGUpIHsgXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmNvcnJlY3Rfc3RhdGUob2JqKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHNfY2FsbCkgeyBzX2NhbGwuY2FsbCh0aGlzKTsgfSBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYocy5jb3JyZWN0X3N0YXRlKSB7IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5lbXB0eSgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoc19jYWxsKSB7IHNfY2FsbC5jYWxsKHRoaXMpOyB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHMuYWpheC5jb250ZXh0ID0gdGhpcztcblx0XHRcdFx0XHRcdHMuYWpheC5lcnJvciA9IGVycm9yX2Z1bmM7XG5cdFx0XHRcdFx0XHRzLmFqYXguc3VjY2VzcyA9IHN1Y2Nlc3NfZnVuYztcblx0XHRcdFx0XHRcdGlmKCFzLmFqYXguZGF0YVR5cGUpIHsgcy5hamF4LmRhdGFUeXBlID0gXCJ4bWxcIjsgfVxuXHRcdFx0XHRcdFx0aWYoJC5pc0Z1bmN0aW9uKHMuYWpheC51cmwpKSB7IHMuYWpheC51cmwgPSBzLmFqYXgudXJsLmNhbGwodGhpcywgb2JqKTsgfVxuXHRcdFx0XHRcdFx0aWYoJC5pc0Z1bmN0aW9uKHMuYWpheC5kYXRhKSkgeyBzLmFqYXguZGF0YSA9IHMuYWpheC5kYXRhLmNhbGwodGhpcywgb2JqKTsgfVxuXHRcdFx0XHRcdFx0JC5hamF4KHMuYWpheCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHBhcnNlX3htbCA6IGZ1bmN0aW9uICh4bWwsIGNhbGxiYWNrKSB7XG5cdFx0XHRcdHZhciBzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkueG1sX2RhdGE7XG5cdFx0XHRcdCQudmFrYXRhLnhzbHQoeG1sLCB4c2xbcy54c2xdLCBjYWxsYmFjayk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0X3htbCA6IGZ1bmN0aW9uICh0cCwgb2JqLCBsaV9hdHRyLCBhX2F0dHIsIGlzX2NhbGxiYWNrKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBcIlwiLCBcblx0XHRcdFx0XHRzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCksIFxuXHRcdFx0XHRcdF90aGlzID0gdGhpcyxcblx0XHRcdFx0XHR0bXAxLCB0bXAyLCBsaSwgYSwgbGFuZztcblx0XHRcdFx0aWYoIXRwKSB7IHRwID0gXCJmbGF0XCI7IH1cblx0XHRcdFx0aWYoIWlzX2NhbGxiYWNrKSB7IGlzX2NhbGxiYWNrID0gMDsgfVxuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRpZighb2JqIHx8IG9iaiA9PT0gLTEpIHsgb2JqID0gdGhpcy5nZXRfY29udGFpbmVyKCkuZmluZChcIj4gdWwgPiBsaVwiKTsgfVxuXHRcdFx0XHRsaV9hdHRyID0gJC5pc0FycmF5KGxpX2F0dHIpID8gbGlfYXR0ciA6IFsgXCJpZFwiLCBcImNsYXNzXCIgXTtcblx0XHRcdFx0aWYoIWlzX2NhbGxiYWNrICYmIHRoaXMuZGF0YS50eXBlcyAmJiAkLmluQXJyYXkocy50eXBlcy50eXBlX2F0dHIsIGxpX2F0dHIpID09PSAtMSkgeyBsaV9hdHRyLnB1c2gocy50eXBlcy50eXBlX2F0dHIpOyB9XG5cblx0XHRcdFx0YV9hdHRyID0gJC5pc0FycmF5KGFfYXR0cikgPyBhX2F0dHIgOiBbIF07XG5cblx0XHRcdFx0aWYoIWlzX2NhbGxiYWNrKSB7IFxuXHRcdFx0XHRcdGlmKHMueG1sX2RhdGEuZ2V0X2luY2x1ZGVfcHJlYW1ibGUpIHsgXG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gJzwnICsgJz94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIj8nICsgJz4nOyBcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0ICs9IFwiPHJvb3Q+XCI7IFxuXHRcdFx0XHR9XG5cdFx0XHRcdG9iai5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXN1bHQgKz0gXCI8aXRlbVwiO1xuXHRcdFx0XHRcdGxpID0gJCh0aGlzKTtcblx0XHRcdFx0XHQkLmVhY2gobGlfYXR0ciwgZnVuY3Rpb24gKGksIHYpIHsgXG5cdFx0XHRcdFx0XHR2YXIgdCA9IGxpLmF0dHIodik7XG5cdFx0XHRcdFx0XHRpZighcy54bWxfZGF0YS5nZXRfc2tpcF9lbXB0eSB8fCB0eXBlb2YgdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQgKz0gXCIgXCIgKyB2ICsgXCI9XFxcIlwiICsgZXNjYXBlX3htbCgoXCIgXCIgKyAodCB8fCBcIlwiKSkucmVwbGFjZSgvIGpzdHJlZVteIF0qL2lnLCcnKS5yZXBsYWNlKC9cXHMrJC9pZyxcIiBcIikucmVwbGFjZSgvXiAvLFwiXCIpLnJlcGxhY2UoLyAkLyxcIlwiKSkgKyBcIlxcXCJcIjsgXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0aWYobGkuaGFzQ2xhc3MoXCJqc3RyZWUtb3BlblwiKSkgeyByZXN1bHQgKz0gXCIgc3RhdGU9XFxcIm9wZW5cXFwiXCI7IH1cblx0XHRcdFx0XHRpZihsaS5oYXNDbGFzcyhcImpzdHJlZS1jbG9zZWRcIikpIHsgcmVzdWx0ICs9IFwiIHN0YXRlPVxcXCJjbG9zZWRcXFwiXCI7IH1cblx0XHRcdFx0XHRpZih0cCA9PT0gXCJmbGF0XCIpIHsgcmVzdWx0ICs9IFwiIHBhcmVudF9pZD1cXFwiXCIgKyBlc2NhcGVfeG1sKGlzX2NhbGxiYWNrKSArIFwiXFxcIlwiOyB9XG5cdFx0XHRcdFx0cmVzdWx0ICs9IFwiPlwiO1xuXHRcdFx0XHRcdHJlc3VsdCArPSBcIjxjb250ZW50PlwiO1xuXHRcdFx0XHRcdGEgPSBsaS5jaGlsZHJlbihcImFcIik7XG5cdFx0XHRcdFx0YS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHRtcDEgPSAkKHRoaXMpO1xuXHRcdFx0XHRcdFx0bGFuZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0cmVzdWx0ICs9IFwiPG5hbWVcIjtcblx0XHRcdFx0XHRcdGlmKCQuaW5BcnJheShcImxhbmd1YWdlc1wiLCBzLnBsdWdpbnMpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHQkLmVhY2gocy5sYW5ndWFnZXMsIGZ1bmN0aW9uIChrLCB6KSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYodG1wMS5oYXNDbGFzcyh6KSkgeyByZXN1bHQgKz0gXCIgbGFuZz1cXFwiXCIgKyBlc2NhcGVfeG1sKHopICsgXCJcXFwiXCI7IGxhbmcgPSB6OyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihhX2F0dHIubGVuZ3RoKSB7IFxuXHRcdFx0XHRcdFx0XHQkLmVhY2goYV9hdHRyLCBmdW5jdGlvbiAoaywgeikge1xuXHRcdFx0XHRcdFx0XHRcdHZhciB0ID0gdG1wMS5hdHRyKHopO1xuXHRcdFx0XHRcdFx0XHRcdGlmKCFzLnhtbF9kYXRhLmdldF9za2lwX2VtcHR5IHx8IHR5cGVvZiB0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQgKz0gXCIgXCIgKyB6ICsgXCI9XFxcIlwiICsgZXNjYXBlX3htbCgoXCIgXCIgKyB0IHx8IFwiXCIpLnJlcGxhY2UoLyBqc3RyZWVbXiBdKi9pZywnJykucmVwbGFjZSgvXFxzKyQvaWcsXCIgXCIpLnJlcGxhY2UoL14gLyxcIlwiKS5yZXBsYWNlKC8gJC8sXCJcIikpICsgXCJcXFwiXCI7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKHRtcDEuY2hpbGRyZW4oXCJpbnNcIikuZ2V0KDApLmNsYXNzTmFtZS5yZXBsYWNlKC9qc3RyZWVbXiBdKnwkL2lnLCcnKS5yZXBsYWNlKC9eXFxzKyQvaWcsXCJcIikubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdCArPSAnIGljb249XCInICsgZXNjYXBlX3htbCh0bXAxLmNoaWxkcmVuKFwiaW5zXCIpLmdldCgwKS5jbGFzc05hbWUucmVwbGFjZSgvanN0cmVlW14gXSp8JC9pZywnJykucmVwbGFjZSgvXFxzKyQvaWcsXCIgXCIpLnJlcGxhY2UoL14gLyxcIlwiKS5yZXBsYWNlKC8gJC8sXCJcIikpICsgJ1wiJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKHRtcDEuY2hpbGRyZW4oXCJpbnNcIikuZ2V0KDApLnN0eWxlLmJhY2tncm91bmRJbWFnZS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0ICs9ICcgaWNvbj1cIicgKyBlc2NhcGVfeG1sKHRtcDEuY2hpbGRyZW4oXCJpbnNcIikuZ2V0KDApLnN0eWxlLmJhY2tncm91bmRJbWFnZS5yZXBsYWNlKFwidXJsKFwiLFwiXCIpLnJlcGxhY2UoXCIpXCIsXCJcIikucmVwbGFjZSgvJy9pZyxcIlwiKS5yZXBsYWNlKC9cIi9pZyxcIlwiKSkgKyAnXCInO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVzdWx0ICs9IFwiPlwiO1xuXHRcdFx0XHRcdFx0cmVzdWx0ICs9IFwiPCFbQ0RBVEFbXCIgKyBfdGhpcy5nZXRfdGV4dCh0bXAxLCBsYW5nKSArIFwiXV0+XCI7XG5cdFx0XHRcdFx0XHRyZXN1bHQgKz0gXCI8L25hbWU+XCI7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cmVzdWx0ICs9IFwiPC9jb250ZW50PlwiO1xuXHRcdFx0XHRcdHRtcDIgPSBsaVswXS5pZCB8fCB0cnVlO1xuXHRcdFx0XHRcdGxpID0gbGkuZmluZChcIj4gdWwgPiBsaVwiKTtcblx0XHRcdFx0XHRpZihsaS5sZW5ndGgpIHsgdG1wMiA9IF90aGlzLmdldF94bWwodHAsIGxpLCBsaV9hdHRyLCBhX2F0dHIsIHRtcDIpOyB9XG5cdFx0XHRcdFx0ZWxzZSB7IHRtcDIgPSBcIlwiOyB9XG5cdFx0XHRcdFx0aWYodHAgPT0gXCJuZXN0XCIpIHsgcmVzdWx0ICs9IHRtcDI7IH1cblx0XHRcdFx0XHRyZXN1bHQgKz0gXCI8L2l0ZW0+XCI7XG5cdFx0XHRcdFx0aWYodHAgPT0gXCJmbGF0XCIpIHsgcmVzdWx0ICs9IHRtcDI7IH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmKCFpc19jYWxsYmFjaykgeyByZXN1bHQgKz0gXCI8L3Jvb3Q+XCI7IH1cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufSkoalF1ZXJ5KTtcbi8vKi9cblxuLypcbiAqIGpzVHJlZSBzZWFyY2ggcGx1Z2luXG4gKiBFbmFibGVzIGJvdGggc3luYyBhbmQgYXN5bmMgc2VhcmNoIG9uIHRoZSB0cmVlXG4gKiBET0VTIE5PVCBXT1JLIFdJVEggSlNPTiBQUk9HUkVTU0lWRSBSRU5ERVJcbiAqL1xuKGZ1bmN0aW9uICgkKSB7XG5cdCQuZXhwclsnOiddLmpzdHJlZV9jb250YWlucyA9IGZ1bmN0aW9uKGEsaSxtKXtcblx0XHRyZXR1cm4gKGEudGV4dENvbnRlbnQgfHwgYS5pbm5lclRleHQgfHwgXCJcIikudG9Mb3dlckNhc2UoKS5pbmRleE9mKG1bM10udG9Mb3dlckNhc2UoKSk+PTA7XG5cdH07XG5cdCQuZXhwclsnOiddLmpzdHJlZV90aXRsZV9jb250YWlucyA9IGZ1bmN0aW9uKGEsaSxtKSB7XG5cdFx0cmV0dXJuIChhLmdldEF0dHJpYnV0ZShcInRpdGxlXCIpIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihtWzNdLnRvTG93ZXJDYXNlKCkpPj0wO1xuXHR9O1xuXHQkLmpzdHJlZS5wbHVnaW4oXCJzZWFyY2hcIiwge1xuXHRcdF9faW5pdCA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuZGF0YS5zZWFyY2guc3RyID0gXCJcIjtcblx0XHRcdHRoaXMuZGF0YS5zZWFyY2gucmVzdWx0ID0gJCgpO1xuXHRcdFx0aWYodGhpcy5fZ2V0X3NldHRpbmdzKCkuc2VhcmNoLnNob3dfb25seV9tYXRjaGVzKSB7XG5cdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpXG5cdFx0XHRcdFx0LmJpbmQoXCJzZWFyY2guanN0cmVlXCIsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHQkKHRoaXMpLmNoaWxkcmVuKFwidWxcIikuZmluZChcImxpXCIpLmhpZGUoKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1sYXN0XCIpO1xuXHRcdFx0XHRcdFx0ZGF0YS5yc2x0Lm5vZGVzLnBhcmVudHNVbnRpbChcIi5qc3RyZWVcIikuYW5kU2VsZigpLnNob3coKVxuXHRcdFx0XHRcdFx0XHQuZmlsdGVyKFwidWxcIikuZWFjaChmdW5jdGlvbiAoKSB7ICQodGhpcykuY2hpbGRyZW4oXCJsaTp2aXNpYmxlXCIpLmVxKC0xKS5hZGRDbGFzcyhcImpzdHJlZS1sYXN0XCIpOyB9KTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5iaW5kKFwiY2xlYXJfc2VhcmNoLmpzdHJlZVwiLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHQkKHRoaXMpLmNoaWxkcmVuKFwidWxcIikuZmluZChcImxpXCIpLmNzcyhcImRpc3BsYXlcIixcIlwiKS5lbmQoKS5lbmQoKS5qc3RyZWUoXCJjbGVhbl9ub2RlXCIsIC0xKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRlZmF1bHRzIDoge1xuXHRcdFx0YWpheCA6IGZhbHNlLFxuXHRcdFx0c2VhcmNoX21ldGhvZCA6IFwianN0cmVlX2NvbnRhaW5zXCIsIC8vIGZvciBjYXNlIGluc2Vuc2l0aXZlIC0ganN0cmVlX2NvbnRhaW5zXG5cdFx0XHRzaG93X29ubHlfbWF0Y2hlcyA6IGZhbHNlXG5cdFx0fSxcblx0XHRfZm4gOiB7XG5cdFx0XHRzZWFyY2ggOiBmdW5jdGlvbiAoc3RyLCBza2lwX2FzeW5jKSB7XG5cdFx0XHRcdGlmKCQudHJpbShzdHIpID09PSBcIlwiKSB7IHRoaXMuY2xlYXJfc2VhcmNoKCk7IHJldHVybjsgfVxuXHRcdFx0XHR2YXIgcyA9IHRoaXMuZ2V0X3NldHRpbmdzKCkuc2VhcmNoLCBcblx0XHRcdFx0XHR0ID0gdGhpcyxcblx0XHRcdFx0XHRlcnJvcl9mdW5jID0gZnVuY3Rpb24gKCkgeyB9LFxuXHRcdFx0XHRcdHN1Y2Nlc3NfZnVuYyA9IGZ1bmN0aW9uICgpIHsgfTtcblx0XHRcdFx0dGhpcy5kYXRhLnNlYXJjaC5zdHIgPSBzdHI7XG5cblx0XHRcdFx0aWYoIXNraXBfYXN5bmMgJiYgcy5hamF4ICE9PSBmYWxzZSAmJiB0aGlzLmdldF9jb250YWluZXJfdWwoKS5maW5kKFwibGkuanN0cmVlLWNsb3NlZDpub3QoOmhhcyh1bCkpOmVxKDApXCIpLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHR0aGlzLnNlYXJjaC5zdXByZXNzX2NhbGxiYWNrID0gdHJ1ZTtcblx0XHRcdFx0XHRlcnJvcl9mdW5jID0gZnVuY3Rpb24gKCkgeyB9O1xuXHRcdFx0XHRcdHN1Y2Nlc3NfZnVuYyA9IGZ1bmN0aW9uIChkLCB0LCB4KSB7XG5cdFx0XHRcdFx0XHR2YXIgc2YgPSB0aGlzLmdldF9zZXR0aW5ncygpLnNlYXJjaC5hamF4LnN1Y2Nlc3M7IFxuXHRcdFx0XHRcdFx0aWYoc2YpIHsgZCA9IHNmLmNhbGwodGhpcyxkLHQseCkgfHwgZDsgfVxuXHRcdFx0XHRcdFx0dGhpcy5kYXRhLnNlYXJjaC50b19vcGVuID0gZDtcblx0XHRcdFx0XHRcdHRoaXMuX3NlYXJjaF9vcGVuKCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRzLmFqYXguY29udGV4dCA9IHRoaXM7XG5cdFx0XHRcdFx0cy5hamF4LmVycm9yID0gZXJyb3JfZnVuYztcblx0XHRcdFx0XHRzLmFqYXguc3VjY2VzcyA9IHN1Y2Nlc3NfZnVuYztcblx0XHRcdFx0XHRpZigkLmlzRnVuY3Rpb24ocy5hamF4LnVybCkpIHsgcy5hamF4LnVybCA9IHMuYWpheC51cmwuY2FsbCh0aGlzLCBzdHIpOyB9XG5cdFx0XHRcdFx0aWYoJC5pc0Z1bmN0aW9uKHMuYWpheC5kYXRhKSkgeyBzLmFqYXguZGF0YSA9IHMuYWpheC5kYXRhLmNhbGwodGhpcywgc3RyKTsgfVxuXHRcdFx0XHRcdGlmKCFzLmFqYXguZGF0YSkgeyBzLmFqYXguZGF0YSA9IHsgXCJzZWFyY2hfc3RyaW5nXCIgOiBzdHIgfTsgfVxuXHRcdFx0XHRcdGlmKCFzLmFqYXguZGF0YVR5cGUgfHwgL15qc29uLy5leGVjKHMuYWpheC5kYXRhVHlwZSkpIHsgcy5hamF4LmRhdGFUeXBlID0gXCJqc29uXCI7IH1cblx0XHRcdFx0XHQkLmFqYXgocy5hamF4KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodGhpcy5kYXRhLnNlYXJjaC5yZXN1bHQubGVuZ3RoKSB7IHRoaXMuY2xlYXJfc2VhcmNoKCk7IH1cblx0XHRcdFx0dGhpcy5kYXRhLnNlYXJjaC5yZXN1bHQgPSB0aGlzLmdldF9jb250YWluZXIoKS5maW5kKFwiYVwiICsgKHRoaXMuZGF0YS5sYW5ndWFnZXMgPyBcIi5cIiArIHRoaXMuZ2V0X2xhbmcoKSA6IFwiXCIgKSArIFwiOlwiICsgKHMuc2VhcmNoX21ldGhvZCkgKyBcIihcIiArIHRoaXMuZGF0YS5zZWFyY2guc3RyICsgXCIpXCIpO1xuXHRcdFx0XHR0aGlzLmRhdGEuc2VhcmNoLnJlc3VsdC5hZGRDbGFzcyhcImpzdHJlZS1zZWFyY2hcIikucGFyZW50KCkucGFyZW50cyhcIi5qc3RyZWUtY2xvc2VkXCIpLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHQub3Blbl9ub2RlKHRoaXMsIGZhbHNlLCB0cnVlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRoaXMuX19jYWxsYmFjayh7IG5vZGVzIDogdGhpcy5kYXRhLnNlYXJjaC5yZXN1bHQsIHN0ciA6IHN0ciB9KTtcblx0XHRcdH0sXG5cdFx0XHRjbGVhcl9zZWFyY2ggOiBmdW5jdGlvbiAoc3RyKSB7XG5cdFx0XHRcdHRoaXMuZGF0YS5zZWFyY2gucmVzdWx0LnJlbW92ZUNsYXNzKFwianN0cmVlLXNlYXJjaFwiKTtcblx0XHRcdFx0dGhpcy5fX2NhbGxiYWNrKHRoaXMuZGF0YS5zZWFyY2gucmVzdWx0KTtcblx0XHRcdFx0dGhpcy5kYXRhLnNlYXJjaC5yZXN1bHQgPSAkKCk7XG5cdFx0XHR9LFxuXHRcdFx0X3NlYXJjaF9vcGVuIDogZnVuY3Rpb24gKGlzX2NhbGxiYWNrKSB7XG5cdFx0XHRcdHZhciBfdGhpcyA9IHRoaXMsXG5cdFx0XHRcdFx0ZG9uZSA9IHRydWUsXG5cdFx0XHRcdFx0Y3VycmVudCA9IFtdLFxuXHRcdFx0XHRcdHJlbWFpbmluZyA9IFtdO1xuXHRcdFx0XHRpZih0aGlzLmRhdGEuc2VhcmNoLnRvX29wZW4ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0JC5lYWNoKHRoaXMuZGF0YS5zZWFyY2gudG9fb3BlbiwgZnVuY3Rpb24gKGksIHZhbCkge1xuXHRcdFx0XHRcdFx0aWYodmFsID09IFwiI1wiKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHRcdFx0XHRpZigkKHZhbCkubGVuZ3RoICYmICQodmFsKS5pcyhcIi5qc3RyZWUtY2xvc2VkXCIpKSB7IGN1cnJlbnQucHVzaCh2YWwpOyB9XG5cdFx0XHRcdFx0XHRlbHNlIHsgcmVtYWluaW5nLnB1c2godmFsKTsgfVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGlmKGN1cnJlbnQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmRhdGEuc2VhcmNoLnRvX29wZW4gPSByZW1haW5pbmc7XG5cdFx0XHRcdFx0XHQkLmVhY2goY3VycmVudCwgZnVuY3Rpb24gKGksIHZhbCkgeyBcblx0XHRcdFx0XHRcdFx0X3RoaXMub3Blbl9ub2RlKHZhbCwgZnVuY3Rpb24gKCkgeyBfdGhpcy5fc2VhcmNoX29wZW4odHJ1ZSk7IH0pOyBcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0ZG9uZSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZihkb25lKSB7IHRoaXMuc2VhcmNoKHRoaXMuZGF0YS5zZWFyY2guc3RyLCB0cnVlKTsgfVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59KShqUXVlcnkpO1xuLy8qL1xuXG4vKiBcbiAqIGpzVHJlZSBjb250ZXh0bWVudSBwbHVnaW5cbiAqL1xuKGZ1bmN0aW9uICgkKSB7XG5cdCQudmFrYXRhLmNvbnRleHQgPSB7XG5cdFx0aGlkZV9vbl9tb3VzZWxlYXZlIDogZmFsc2UsXG5cblx0XHRjbnRcdFx0OiAkKFwiPGRpdiBpZD0ndmFrYXRhLWNvbnRleHRtZW51JyAvPlwiKSxcblx0XHR2aXNcdFx0OiBmYWxzZSxcblx0XHR0Z3RcdFx0OiBmYWxzZSxcblx0XHRwYXJcdFx0OiBmYWxzZSxcblx0XHRmdW5jXHQ6IGZhbHNlLFxuXHRcdGRhdGFcdDogZmFsc2UsXG5cdFx0cnRsXHRcdDogZmFsc2UsXG5cdFx0c2hvd1x0OiBmdW5jdGlvbiAocywgdCwgeCwgeSwgZCwgcCwgcnRsKSB7XG5cdFx0XHQkLnZha2F0YS5jb250ZXh0LnJ0bCA9ICEhcnRsO1xuXHRcdFx0dmFyIGh0bWwgPSAkLnZha2F0YS5jb250ZXh0LnBhcnNlKHMpLCBoLCB3O1xuXHRcdFx0aWYoIWh0bWwpIHsgcmV0dXJuOyB9XG5cdFx0XHQkLnZha2F0YS5jb250ZXh0LnZpcyA9IHRydWU7XG5cdFx0XHQkLnZha2F0YS5jb250ZXh0LnRndCA9IHQ7XG5cdFx0XHQkLnZha2F0YS5jb250ZXh0LnBhciA9IHAgfHwgdCB8fCBudWxsO1xuXHRcdFx0JC52YWthdGEuY29udGV4dC5kYXRhID0gZCB8fCBudWxsO1xuXHRcdFx0JC52YWthdGEuY29udGV4dC5jbnRcblx0XHRcdFx0Lmh0bWwoaHRtbClcblx0XHRcdFx0LmNzcyh7IFwidmlzaWJpbGl0eVwiIDogXCJoaWRkZW5cIiwgXCJkaXNwbGF5XCIgOiBcImJsb2NrXCIsIFwibGVmdFwiIDogMCwgXCJ0b3BcIiA6IDAgfSk7XG5cblx0XHRcdGlmKCQudmFrYXRhLmNvbnRleHQuaGlkZV9vbl9tb3VzZWxlYXZlKSB7XG5cdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuY250XG5cdFx0XHRcdFx0Lm9uZShcIm1vdXNlbGVhdmVcIiwgZnVuY3Rpb24oZSkgeyAkLnZha2F0YS5jb250ZXh0LmhpZGUoKTsgfSk7XG5cdFx0XHR9XG5cblx0XHRcdGggPSAkLnZha2F0YS5jb250ZXh0LmNudC5oZWlnaHQoKTtcblx0XHRcdHcgPSAkLnZha2F0YS5jb250ZXh0LmNudC53aWR0aCgpO1xuXHRcdFx0aWYoeCArIHcgPiAkKGRvY3VtZW50KS53aWR0aCgpKSB7IFxuXHRcdFx0XHR4ID0gJChkb2N1bWVudCkud2lkdGgoKSAtICh3ICsgNSk7IFxuXHRcdFx0XHQkLnZha2F0YS5jb250ZXh0LmNudC5maW5kKFwibGkgPiB1bFwiKS5hZGRDbGFzcyhcInJpZ2h0XCIpOyBcblx0XHRcdH1cblx0XHRcdGlmKHkgKyBoID4gJChkb2N1bWVudCkuaGVpZ2h0KCkpIHsgXG5cdFx0XHRcdHkgPSB5IC0gKGggKyB0WzBdLm9mZnNldEhlaWdodCk7IFxuXHRcdFx0XHQkLnZha2F0YS5jb250ZXh0LmNudC5maW5kKFwibGkgPiB1bFwiKS5hZGRDbGFzcyhcImJvdHRvbVwiKTsgXG5cdFx0XHR9XG5cblx0XHRcdCQudmFrYXRhLmNvbnRleHQuY250XG5cdFx0XHRcdC5jc3MoeyBcImxlZnRcIiA6IHgsIFwidG9wXCIgOiB5IH0pXG5cdFx0XHRcdC5maW5kKFwibGk6aGFzKHVsKVwiKVxuXHRcdFx0XHRcdC5iaW5kKFwibW91c2VlbnRlclwiLCBmdW5jdGlvbiAoZSkgeyBcblx0XHRcdFx0XHRcdHZhciB3ID0gJChkb2N1bWVudCkud2lkdGgoKSxcblx0XHRcdFx0XHRcdFx0aCA9ICQoZG9jdW1lbnQpLmhlaWdodCgpLFxuXHRcdFx0XHRcdFx0XHR1bCA9ICQodGhpcykuY2hpbGRyZW4oXCJ1bFwiKS5zaG93KCk7IFxuXHRcdFx0XHRcdFx0aWYodyAhPT0gJChkb2N1bWVudCkud2lkdGgoKSkgeyB1bC50b2dnbGVDbGFzcyhcInJpZ2h0XCIpOyB9XG5cdFx0XHRcdFx0XHRpZihoICE9PSAkKGRvY3VtZW50KS5oZWlnaHQoKSkgeyB1bC50b2dnbGVDbGFzcyhcImJvdHRvbVwiKTsgfVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmJpbmQoXCJtb3VzZWxlYXZlXCIsIGZ1bmN0aW9uIChlKSB7IFxuXHRcdFx0XHRcdFx0JCh0aGlzKS5jaGlsZHJlbihcInVsXCIpLmhpZGUoKTsgXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuZW5kKClcblx0XHRcdFx0LmNzcyh7IFwidmlzaWJpbGl0eVwiIDogXCJ2aXNpYmxlXCIgfSlcblx0XHRcdFx0LnNob3coKTtcblx0XHRcdCQoZG9jdW1lbnQpLnRyaWdnZXJIYW5kbGVyKFwiY29udGV4dF9zaG93LnZha2F0YVwiKTtcblx0XHR9LFxuXHRcdGhpZGVcdDogZnVuY3Rpb24gKCkge1xuXHRcdFx0JC52YWthdGEuY29udGV4dC52aXMgPSBmYWxzZTtcblx0XHRcdCQudmFrYXRhLmNvbnRleHQuY250LmF0dHIoXCJjbGFzc1wiLFwiXCIpLmNzcyh7IFwidmlzaWJpbGl0eVwiIDogXCJoaWRkZW5cIiB9KTtcblx0XHRcdCQoZG9jdW1lbnQpLnRyaWdnZXJIYW5kbGVyKFwiY29udGV4dF9oaWRlLnZha2F0YVwiKTtcblx0XHR9LFxuXHRcdHBhcnNlXHQ6IGZ1bmN0aW9uIChzLCBpc19jYWxsYmFjaykge1xuXHRcdFx0aWYoIXMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHR2YXIgc3RyID0gXCJcIixcblx0XHRcdFx0dG1wID0gZmFsc2UsXG5cdFx0XHRcdHdhc19zZXAgPSB0cnVlO1xuXHRcdFx0aWYoIWlzX2NhbGxiYWNrKSB7ICQudmFrYXRhLmNvbnRleHQuZnVuYyA9IHt9OyB9XG5cdFx0XHRzdHIgKz0gXCI8dWw+XCI7XG5cdFx0XHQkLmVhY2gocywgZnVuY3Rpb24gKGksIHZhbCkge1xuXHRcdFx0XHRpZighdmFsKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuZnVuY1tpXSA9IHZhbC5hY3Rpb247XG5cdFx0XHRcdGlmKCF3YXNfc2VwICYmIHZhbC5zZXBhcmF0b3JfYmVmb3JlKSB7XG5cdFx0XHRcdFx0c3RyICs9IFwiPGxpIGNsYXNzPSd2YWthdGEtc2VwYXJhdG9yIHZha2F0YS1zZXBhcmF0b3ItYmVmb3JlJz48L2xpPlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdhc19zZXAgPSBmYWxzZTtcblx0XHRcdFx0c3RyICs9IFwiPGxpIGNsYXNzPSdcIiArICh2YWwuX2NsYXNzIHx8IFwiXCIpICsgKHZhbC5fZGlzYWJsZWQgPyBcIiBqc3RyZWUtY29udGV4dG1lbnUtZGlzYWJsZWQgXCIgOiBcIlwiKSArIFwiJz48aW5zIFwiO1xuXHRcdFx0XHRpZih2YWwuaWNvbiAmJiB2YWwuaWNvbi5pbmRleE9mKFwiL1wiKSA9PT0gLTEpIHsgc3RyICs9IFwiIGNsYXNzPSdcIiArIHZhbC5pY29uICsgXCInIFwiOyB9XG5cdFx0XHRcdGlmKHZhbC5pY29uICYmIHZhbC5pY29uLmluZGV4T2YoXCIvXCIpICE9PSAtMSkgeyBzdHIgKz0gXCIgc3R5bGU9J2JhY2tncm91bmQ6dXJsKFwiICsgdmFsLmljb24gKyBcIikgY2VudGVyIGNlbnRlciBuby1yZXBlYXQ7JyBcIjsgfVxuXHRcdFx0XHRzdHIgKz0gXCI+JiMxNjA7PC9pbnM+PGEgaHJlZj0nIycgcmVsPSdcIiArIGkgKyBcIic+XCI7XG5cdFx0XHRcdGlmKHZhbC5zdWJtZW51KSB7XG5cdFx0XHRcdFx0c3RyICs9IFwiPHNwYW4gc3R5bGU9J2Zsb2F0OlwiICsgKCQudmFrYXRhLmNvbnRleHQucnRsID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpICsgXCI7Jz4mcmFxdW87PC9zcGFuPlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0ciArPSB2YWwubGFiZWwgKyBcIjwvYT5cIjtcblx0XHRcdFx0aWYodmFsLnN1Ym1lbnUpIHtcblx0XHRcdFx0XHR0bXAgPSAkLnZha2F0YS5jb250ZXh0LnBhcnNlKHZhbC5zdWJtZW51LCB0cnVlKTtcblx0XHRcdFx0XHRpZih0bXApIHsgc3RyICs9IHRtcDsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0ciArPSBcIjwvbGk+XCI7XG5cdFx0XHRcdGlmKHZhbC5zZXBhcmF0b3JfYWZ0ZXIpIHtcblx0XHRcdFx0XHRzdHIgKz0gXCI8bGkgY2xhc3M9J3Zha2F0YS1zZXBhcmF0b3IgdmFrYXRhLXNlcGFyYXRvci1hZnRlcic+PC9saT5cIjtcblx0XHRcdFx0XHR3YXNfc2VwID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRzdHIgPSBzdHIucmVwbGFjZSgvPGxpIGNsYXNzXFw9J3Zha2F0YS1zZXBhcmF0b3IgdmFrYXRhLXNlcGFyYXRvci1hZnRlcidcXD48XFwvbGlcXD4kLyxcIlwiKTtcblx0XHRcdHN0ciArPSBcIjwvdWw+XCI7XG5cdFx0XHQkKGRvY3VtZW50KS50cmlnZ2VySGFuZGxlcihcImNvbnRleHRfcGFyc2UudmFrYXRhXCIpO1xuXHRcdFx0cmV0dXJuIHN0ci5sZW5ndGggPiAxMCA/IHN0ciA6IGZhbHNlO1xuXHRcdH0sXG5cdFx0ZXhlY1x0OiBmdW5jdGlvbiAoaSkge1xuXHRcdFx0aWYoJC5pc0Z1bmN0aW9uKCQudmFrYXRhLmNvbnRleHQuZnVuY1tpXSkpIHtcblx0XHRcdFx0Ly8gaWYgaXMgc3RyaW5nIC0gZXZhbCBhbmQgY2FsbCBpdCFcblx0XHRcdFx0JC52YWthdGEuY29udGV4dC5mdW5jW2ldLmNhbGwoJC52YWthdGEuY29udGV4dC5kYXRhLCAkLnZha2F0YS5jb250ZXh0LnBhcik7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblx0fTtcblx0JChmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNzc19zdHJpbmcgPSAnJyArIFxuXHRcdFx0JyN2YWthdGEtY29udGV4dG1lbnUgeyBkaXNwbGF5OmJsb2NrOyB2aXNpYmlsaXR5OmhpZGRlbjsgbGVmdDowOyB0b3A6LTIwMHB4OyBwb3NpdGlvbjphYnNvbHV0ZTsgbWFyZ2luOjA7IHBhZGRpbmc6MDsgbWluLXdpZHRoOjE4MHB4OyBiYWNrZ3JvdW5kOiNlYmViZWI7IGJvcmRlcjoxcHggc29saWQgc2lsdmVyOyB6LWluZGV4OjEwMDAwOyAqd2lkdGg6MTgwcHg7IH0gJyArIFxuXHRcdFx0JyN2YWthdGEtY29udGV4dG1lbnUgdWwgeyBtaW4td2lkdGg6MTgwcHg7ICp3aWR0aDoxODBweDsgfSAnICsgXG5cdFx0XHQnI3Zha2F0YS1jb250ZXh0bWVudSB1bCwgI3Zha2F0YS1jb250ZXh0bWVudSBsaSB7IG1hcmdpbjowOyBwYWRkaW5nOjA7IGxpc3Qtc3R5bGUtdHlwZTpub25lOyBkaXNwbGF5OmJsb2NrOyB9ICcgKyBcblx0XHRcdCcjdmFrYXRhLWNvbnRleHRtZW51IGxpIHsgbGluZS1oZWlnaHQ6MjBweDsgbWluLWhlaWdodDoyMHB4OyBwb3NpdGlvbjpyZWxhdGl2ZTsgcGFkZGluZzowcHg7IH0gJyArIFxuXHRcdFx0JyN2YWthdGEtY29udGV4dG1lbnUgbGkgYSB7IHBhZGRpbmc6MXB4IDZweDsgbGluZS1oZWlnaHQ6MTdweDsgZGlzcGxheTpibG9jazsgdGV4dC1kZWNvcmF0aW9uOm5vbmU7IG1hcmdpbjoxcHggMXB4IDAgMXB4OyB9ICcgKyBcblx0XHRcdCcjdmFrYXRhLWNvbnRleHRtZW51IGxpIGlucyB7IGZsb2F0OmxlZnQ7IHdpZHRoOjE2cHg7IGhlaWdodDoxNnB4OyB0ZXh0LWRlY29yYXRpb246bm9uZTsgbWFyZ2luLXJpZ2h0OjJweDsgfSAnICsgXG5cdFx0XHQnI3Zha2F0YS1jb250ZXh0bWVudSBsaSBhOmhvdmVyLCAjdmFrYXRhLWNvbnRleHRtZW51IGxpLnZha2F0YS1ob3ZlciA+IGEgeyBiYWNrZ3JvdW5kOmdyYXk7IGNvbG9yOndoaXRlOyB9ICcgKyBcblx0XHRcdCcjdmFrYXRhLWNvbnRleHRtZW51IGxpIHVsIHsgZGlzcGxheTpub25lOyBwb3NpdGlvbjphYnNvbHV0ZTsgdG9wOi0ycHg7IGxlZnQ6MTAwJTsgYmFja2dyb3VuZDojZWJlYmViOyBib3JkZXI6MXB4IHNvbGlkIGdyYXk7IH0gJyArIFxuXHRcdFx0JyN2YWthdGEtY29udGV4dG1lbnUgLnJpZ2h0IHsgcmlnaHQ6MTAwJTsgbGVmdDphdXRvOyB9ICcgKyBcblx0XHRcdCcjdmFrYXRhLWNvbnRleHRtZW51IC5ib3R0b20geyBib3R0b206LTFweDsgdG9wOmF1dG87IH0gJyArIFxuXHRcdFx0JyN2YWthdGEtY29udGV4dG1lbnUgbGkudmFrYXRhLXNlcGFyYXRvciB7IG1pbi1oZWlnaHQ6MDsgaGVpZ2h0OjFweDsgbGluZS1oZWlnaHQ6MXB4OyBmb250LXNpemU6MXB4OyBvdmVyZmxvdzpoaWRkZW47IG1hcmdpbjowIDJweDsgYmFja2dyb3VuZDpzaWx2ZXI7IC8qIGJvcmRlci10b3A6MXB4IHNvbGlkICNmZWZlZmU7ICovIHBhZGRpbmc6MDsgfSAnO1xuXHRcdCQudmFrYXRhLmNzcy5hZGRfc2hlZXQoeyBzdHIgOiBjc3Nfc3RyaW5nLCB0aXRsZSA6IFwidmFrYXRhXCIgfSk7XG5cdFx0JC52YWthdGEuY29udGV4dC5jbnRcblx0XHRcdC5kZWxlZ2F0ZShcImFcIixcImNsaWNrXCIsIGZ1bmN0aW9uIChlKSB7IGUucHJldmVudERlZmF1bHQoKTsgfSlcblx0XHRcdC5kZWxlZ2F0ZShcImFcIixcIm1vdXNldXBcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0aWYoISQodGhpcykucGFyZW50KCkuaGFzQ2xhc3MoXCJqc3RyZWUtY29udGV4dG1lbnUtZGlzYWJsZWRcIikgJiYgJC52YWthdGEuY29udGV4dC5leGVjKCQodGhpcykuYXR0cihcInJlbFwiKSkpIHtcblx0XHRcdFx0XHQkLnZha2F0YS5jb250ZXh0LmhpZGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHsgJCh0aGlzKS5ibHVyKCk7IH1cblx0XHRcdH0pXG5cdFx0XHQuZGVsZWdhdGUoXCJhXCIsXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQkLnZha2F0YS5jb250ZXh0LmNudC5maW5kKFwiLnZha2F0YS1ob3ZlclwiKS5yZW1vdmVDbGFzcyhcInZha2F0YS1ob3ZlclwiKTtcblx0XHRcdH0pXG5cdFx0XHQuYXBwZW5kVG8oXCJib2R5XCIpO1xuXHRcdCQoZG9jdW1lbnQpLmJpbmQoXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKGUpIHsgaWYoJC52YWthdGEuY29udGV4dC52aXMgJiYgISQuY29udGFpbnMoJC52YWthdGEuY29udGV4dC5jbnRbMF0sIGUudGFyZ2V0KSkgeyAkLnZha2F0YS5jb250ZXh0LmhpZGUoKTsgfSB9KTtcblx0XHRpZih0eXBlb2YgJC5ob3RrZXlzICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHQkKGRvY3VtZW50KVxuXHRcdFx0XHQuYmluZChcImtleWRvd25cIiwgXCJ1cFwiLCBmdW5jdGlvbiAoZSkgeyBcblx0XHRcdFx0XHRpZigkLnZha2F0YS5jb250ZXh0LnZpcykgeyBcblx0XHRcdFx0XHRcdHZhciBvID0gJC52YWthdGEuY29udGV4dC5jbnQuZmluZChcInVsOnZpc2libGVcIikubGFzdCgpLmNoaWxkcmVuKFwiLnZha2F0YS1ob3ZlclwiKS5yZW1vdmVDbGFzcyhcInZha2F0YS1ob3ZlclwiKS5wcmV2QWxsKFwibGk6bm90KC52YWthdGEtc2VwYXJhdG9yKVwiKS5maXJzdCgpO1xuXHRcdFx0XHRcdFx0aWYoIW8ubGVuZ3RoKSB7IG8gPSAkLnZha2F0YS5jb250ZXh0LmNudC5maW5kKFwidWw6dmlzaWJsZVwiKS5sYXN0KCkuY2hpbGRyZW4oXCJsaTpub3QoLnZha2F0YS1zZXBhcmF0b3IpXCIpLmxhc3QoKTsgfVxuXHRcdFx0XHRcdFx0by5hZGRDbGFzcyhcInZha2F0YS1ob3ZlclwiKTtcblx0XHRcdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7IFxuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdH0gXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5iaW5kKFwia2V5ZG93blwiLCBcImRvd25cIiwgZnVuY3Rpb24gKGUpIHsgXG5cdFx0XHRcdFx0aWYoJC52YWthdGEuY29udGV4dC52aXMpIHsgXG5cdFx0XHRcdFx0XHR2YXIgbyA9ICQudmFrYXRhLmNvbnRleHQuY250LmZpbmQoXCJ1bDp2aXNpYmxlXCIpLmxhc3QoKS5jaGlsZHJlbihcIi52YWthdGEtaG92ZXJcIikucmVtb3ZlQ2xhc3MoXCJ2YWthdGEtaG92ZXJcIikubmV4dEFsbChcImxpOm5vdCgudmFrYXRhLXNlcGFyYXRvcilcIikuZmlyc3QoKTtcblx0XHRcdFx0XHRcdGlmKCFvLmxlbmd0aCkgeyBvID0gJC52YWthdGEuY29udGV4dC5jbnQuZmluZChcInVsOnZpc2libGVcIikubGFzdCgpLmNoaWxkcmVuKFwibGk6bm90KC52YWthdGEtc2VwYXJhdG9yKVwiKS5maXJzdCgpOyB9XG5cdFx0XHRcdFx0XHRvLmFkZENsYXNzKFwidmFrYXRhLWhvdmVyXCIpO1xuXHRcdFx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTsgXG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fSBcblx0XHRcdFx0fSlcblx0XHRcdFx0LmJpbmQoXCJrZXlkb3duXCIsIFwicmlnaHRcIiwgZnVuY3Rpb24gKGUpIHsgXG5cdFx0XHRcdFx0aWYoJC52YWthdGEuY29udGV4dC52aXMpIHsgXG5cdFx0XHRcdFx0XHQkLnZha2F0YS5jb250ZXh0LmNudC5maW5kKFwiLnZha2F0YS1ob3ZlclwiKS5jaGlsZHJlbihcInVsXCIpLnNob3coKS5jaGlsZHJlbihcImxpOm5vdCgudmFrYXRhLXNlcGFyYXRvcilcIikucmVtb3ZlQ2xhc3MoXCJ2YWthdGEtaG92ZXJcIikuZmlyc3QoKS5hZGRDbGFzcyhcInZha2F0YS1ob3ZlclwiKTtcblx0XHRcdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7IFxuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdH0gXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5iaW5kKFwia2V5ZG93blwiLCBcImxlZnRcIiwgZnVuY3Rpb24gKGUpIHsgXG5cdFx0XHRcdFx0aWYoJC52YWthdGEuY29udGV4dC52aXMpIHsgXG5cdFx0XHRcdFx0XHQkLnZha2F0YS5jb250ZXh0LmNudC5maW5kKFwiLnZha2F0YS1ob3ZlclwiKS5jaGlsZHJlbihcInVsXCIpLmhpZGUoKS5jaGlsZHJlbihcIi52YWthdGEtc2VwYXJhdG9yXCIpLnJlbW92ZUNsYXNzKFwidmFrYXRhLWhvdmVyXCIpO1xuXHRcdFx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTsgXG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fSBcblx0XHRcdFx0fSlcblx0XHRcdFx0LmJpbmQoXCJrZXlkb3duXCIsIFwiZXNjXCIsIGZ1bmN0aW9uIChlKSB7IFxuXHRcdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuaGlkZSgpOyBcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5iaW5kKFwia2V5ZG93blwiLCBcInNwYWNlXCIsIGZ1bmN0aW9uIChlKSB7IFxuXHRcdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuY250LmZpbmQoXCIudmFrYXRhLWhvdmVyXCIpLmxhc3QoKS5jaGlsZHJlbihcImFcIikuY2xpY2soKTtcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cblx0JC5qc3RyZWUucGx1Z2luKFwiY29udGV4dG1lbnVcIiwge1xuXHRcdF9faW5pdCA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpXG5cdFx0XHRcdC5kZWxlZ2F0ZShcImFcIiwgXCJjb250ZXh0bWVudS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0aWYoISQoZS5jdXJyZW50VGFyZ2V0KS5oYXNDbGFzcyhcImpzdHJlZS1sb2FkaW5nXCIpKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2hvd19jb250ZXh0bWVudShlLmN1cnJlbnRUYXJnZXQsIGUucGFnZVgsIGUucGFnZVkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuZGVsZWdhdGUoXCJhXCIsIFwiY2xpY2suanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdGlmKHRoaXMuZGF0YS5jb250ZXh0bWVudSkge1xuXHRcdFx0XHRcdFx0XHQkLnZha2F0YS5jb250ZXh0LmhpZGUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJkZXN0cm95LmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdC8vIFRPRE86IG1vdmUgdGhpcyB0byBkZXNjcnVjdCBtZXRob2Rcblx0XHRcdFx0XHRcdGlmKHRoaXMuZGF0YS5jb250ZXh0bWVudSkge1xuXHRcdFx0XHRcdFx0XHQkLnZha2F0YS5jb250ZXh0LmhpZGUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHQkKGRvY3VtZW50KS5iaW5kKFwiY29udGV4dF9oaWRlLnZha2F0YVwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHsgdGhpcy5kYXRhLmNvbnRleHRtZW51ID0gZmFsc2U7IH0sIHRoaXMpKTtcblx0XHR9LFxuXHRcdF9fZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyB1bmJpbmQgZ2xvYmFsIGV2ZW50IGhhbmRsZXJzIHdoZW4gbGFzdCBpbnN0YW5jZSBpcyByZW1vdmVkXG5cdFx0XHQvLyAobm8gYWNjZXNzIHRvIHByaXZhdGUgJ2luc3RhbmNlcycgdmFyaWFibGUgZnJvbSBoZXJlKVxuXHRcdFx0aWYoJCgnLmpzdHJlZScpLmxlbmd0aCA8PSAxKSB7XG5cdFx0XHRcdCQoZG9jdW1lbnQpLnVuYmluZChcImNvbnRleHRfaGlkZS52YWthdGFcIik7XHRcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRlZmF1bHRzIDogeyBcblx0XHRcdHNlbGVjdF9ub2RlIDogZmFsc2UsIC8vIHJlcXVpcmVzIFVJIHBsdWdpblxuXHRcdFx0c2hvd19hdF9ub2RlIDogdHJ1ZSxcblx0XHRcdGl0ZW1zIDogeyAvLyBDb3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIHJldHVybiBhbiBvYmplY3QgbGlrZSB0aGlzIG9uZVxuXHRcdFx0XHRcImNyZWF0ZVwiIDoge1xuXHRcdFx0XHRcdFwic2VwYXJhdG9yX2JlZm9yZVwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFwic2VwYXJhdG9yX2FmdGVyXCJcdDogdHJ1ZSxcblx0XHRcdFx0XHRcImxhYmVsXCJcdFx0XHRcdDogXCJDcmVhdGVcIixcblx0XHRcdFx0XHRcImFjdGlvblwiXHRcdFx0OiBmdW5jdGlvbiAob2JqKSB7IHRoaXMuY3JlYXRlKG9iaik7IH1cblx0XHRcdFx0fSxcblx0XHRcdFx0XCJyZW5hbWVcIiA6IHtcblx0XHRcdFx0XHRcInNlcGFyYXRvcl9iZWZvcmVcIlx0OiBmYWxzZSxcblx0XHRcdFx0XHRcInNlcGFyYXRvcl9hZnRlclwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFwibGFiZWxcIlx0XHRcdFx0OiBcIlJlbmFtZVwiLFxuXHRcdFx0XHRcdFwiYWN0aW9uXCJcdFx0XHQ6IGZ1bmN0aW9uIChvYmopIHsgdGhpcy5yZW5hbWUob2JqKTsgfVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcInJlbW92ZVwiIDoge1xuXHRcdFx0XHRcdFwic2VwYXJhdG9yX2JlZm9yZVwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFwiaWNvblwiXHRcdFx0XHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFwic2VwYXJhdG9yX2FmdGVyXCJcdDogZmFsc2UsXG5cdFx0XHRcdFx0XCJsYWJlbFwiXHRcdFx0XHQ6IFwiRGVsZXRlXCIsXG5cdFx0XHRcdFx0XCJhY3Rpb25cIlx0XHRcdDogZnVuY3Rpb24gKG9iaikgeyBpZih0aGlzLmlzX3NlbGVjdGVkKG9iaikpIHsgdGhpcy5yZW1vdmUoKTsgfSBlbHNlIHsgdGhpcy5yZW1vdmUob2JqKTsgfSB9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2NwXCIgOiB7XG5cdFx0XHRcdFx0XCJzZXBhcmF0b3JfYmVmb3JlXCJcdDogdHJ1ZSxcblx0XHRcdFx0XHRcImljb25cIlx0XHRcdFx0OiBmYWxzZSxcblx0XHRcdFx0XHRcInNlcGFyYXRvcl9hZnRlclwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFwibGFiZWxcIlx0XHRcdFx0OiBcIkVkaXRcIixcblx0XHRcdFx0XHRcImFjdGlvblwiXHRcdFx0OiBmYWxzZSxcblx0XHRcdFx0XHRcInN1Ym1lbnVcIiA6IHsgXG5cdFx0XHRcdFx0XHRcImN1dFwiIDoge1xuXHRcdFx0XHRcdFx0XHRcInNlcGFyYXRvcl9iZWZvcmVcIlx0OiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XCJzZXBhcmF0b3JfYWZ0ZXJcIlx0OiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XCJsYWJlbFwiXHRcdFx0XHQ6IFwiQ3V0XCIsXG5cdFx0XHRcdFx0XHRcdFwiYWN0aW9uXCJcdFx0XHQ6IGZ1bmN0aW9uIChvYmopIHsgdGhpcy5jdXQob2JqKTsgfVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFwiY29weVwiIDoge1xuXHRcdFx0XHRcdFx0XHRcInNlcGFyYXRvcl9iZWZvcmVcIlx0OiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XCJpY29uXCJcdFx0XHRcdDogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFwic2VwYXJhdG9yX2FmdGVyXCJcdDogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFwibGFiZWxcIlx0XHRcdFx0OiBcIkNvcHlcIixcblx0XHRcdFx0XHRcdFx0XCJhY3Rpb25cIlx0XHRcdDogZnVuY3Rpb24gKG9iaikgeyB0aGlzLmNvcHkob2JqKTsgfVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFwicGFzdGVcIiA6IHtcblx0XHRcdFx0XHRcdFx0XCJzZXBhcmF0b3JfYmVmb3JlXCJcdDogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFwiaWNvblwiXHRcdFx0XHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcInNlcGFyYXRvcl9hZnRlclwiXHQ6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcImxhYmVsXCJcdFx0XHRcdDogXCJQYXN0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcImFjdGlvblwiXHRcdFx0OiBmdW5jdGlvbiAob2JqKSB7IHRoaXMucGFzdGUob2JqKTsgfVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0X2ZuIDoge1xuXHRcdFx0c2hvd19jb250ZXh0bWVudSA6IGZ1bmN0aW9uIChvYmosIHgsIHkpIHtcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0dmFyIHMgPSB0aGlzLmdldF9zZXR0aW5ncygpLmNvbnRleHRtZW51LFxuXHRcdFx0XHRcdGEgPSBvYmouY2hpbGRyZW4oXCJhOnZpc2libGU6ZXEoMClcIiksXG5cdFx0XHRcdFx0byA9IGZhbHNlLFxuXHRcdFx0XHRcdGkgPSBmYWxzZTtcblx0XHRcdFx0aWYocy5zZWxlY3Rfbm9kZSAmJiB0aGlzLmRhdGEudWkgJiYgIXRoaXMuaXNfc2VsZWN0ZWQob2JqKSkge1xuXHRcdFx0XHRcdHRoaXMuZGVzZWxlY3RfYWxsKCk7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3Rfbm9kZShvYmosIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHMuc2hvd19hdF9ub2RlIHx8IHR5cGVvZiB4ID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiB5ID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdFx0byA9IGEub2Zmc2V0KCk7XG5cdFx0XHRcdFx0eCA9IG8ubGVmdDtcblx0XHRcdFx0XHR5ID0gby50b3AgKyB0aGlzLmRhdGEuY29yZS5saV9oZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aSA9IG9iai5kYXRhKFwianN0cmVlXCIpICYmIG9iai5kYXRhKFwianN0cmVlXCIpLmNvbnRleHRtZW51ID8gb2JqLmRhdGEoXCJqc3RyZWVcIikuY29udGV4dG1lbnUgOiBzLml0ZW1zO1xuXHRcdFx0XHRpZigkLmlzRnVuY3Rpb24oaSkpIHsgaSA9IGkuY2FsbCh0aGlzLCBvYmopOyB9XG5cdFx0XHRcdHRoaXMuZGF0YS5jb250ZXh0bWVudSA9IHRydWU7XG5cdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuc2hvdyhpLCBhLCB4LCB5LCB0aGlzLCBvYmosIHRoaXMuX2dldF9zZXR0aW5ncygpLmNvcmUucnRsKTtcblx0XHRcdFx0aWYodGhpcy5kYXRhLnRoZW1lcykgeyAkLnZha2F0YS5jb250ZXh0LmNudC5hdHRyKFwiY2xhc3NcIiwgXCJqc3RyZWUtXCIgKyB0aGlzLmRhdGEudGhlbWVzLnRoZW1lICsgXCItY29udGV4dFwiKTsgfVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59KShqUXVlcnkpO1xuLy8qL1xuXG4vKiBcbiAqIGpzVHJlZSB0eXBlcyBwbHVnaW5cbiAqIEFkZHMgc3VwcG9ydCB0eXBlcyBvZiBub2Rlc1xuICogWW91IGNhbiBzZXQgYW4gYXR0cmlidXRlIG9uIGVhY2ggbGkgbm9kZSwgdGhhdCByZXByZXNlbnRzIGl0cyB0eXBlLlxuICogQWNjb3JkaW5nIHRvIHRoZSB0eXBlIHNldHRpbmcgdGhlIG5vZGUgbWF5IGdldCBjdXN0b20gaWNvbi92YWxpZGF0aW9uIHJ1bGVzXG4gKi9cbihmdW5jdGlvbiAoJCkge1xuXHQkLmpzdHJlZS5wbHVnaW4oXCJ0eXBlc1wiLCB7XG5cdFx0X19pbml0IDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS50eXBlcztcblx0XHRcdHRoaXMuZGF0YS50eXBlcy5hdHRhY2hfdG8gPSBbXTtcblx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpXG5cdFx0XHRcdC5iaW5kKFwiaW5pdC5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHRcdFx0dmFyIHR5cGVzID0gcy50eXBlcywgXG5cdFx0XHRcdFx0XHRcdGF0dHIgID0gcy50eXBlX2F0dHIsIFxuXHRcdFx0XHRcdFx0XHRpY29uc19jc3MgPSBcIlwiLCBcblx0XHRcdFx0XHRcdFx0X3RoaXMgPSB0aGlzO1xuXG5cdFx0XHRcdFx0XHQkLmVhY2godHlwZXMsIGZ1bmN0aW9uIChpLCB0cCkge1xuXHRcdFx0XHRcdFx0XHQkLmVhY2godHAsIGZ1bmN0aW9uIChrLCB2KSB7IFxuXHRcdFx0XHRcdFx0XHRcdGlmKCEvXihtYXhfZGVwdGh8bWF4X2NoaWxkcmVufGljb258dmFsaWRfY2hpbGRyZW4pJC8udGVzdChrKSkgeyBfdGhpcy5kYXRhLnR5cGVzLmF0dGFjaF90by5wdXNoKGspOyB9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRpZighdHAuaWNvbikgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdFx0XHRcdFx0XHRpZiggdHAuaWNvbi5pbWFnZSB8fCB0cC5pY29uLnBvc2l0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYoaSA9PSBcImRlZmF1bHRcIilcdHsgaWNvbnNfY3NzICs9ICcuanN0cmVlLScgKyBfdGhpcy5nZXRfaW5kZXgoKSArICcgYSA+IC5qc3RyZWUtaWNvbiB7ICc7IH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlXHRcdFx0XHR7IGljb25zX2NzcyArPSAnLmpzdHJlZS0nICsgX3RoaXMuZ2V0X2luZGV4KCkgKyAnIGxpWycgKyBhdHRyICsgJz1cIicgKyBpICsgJ1wiXSA+IGEgPiAuanN0cmVlLWljb24geyAnOyB9XG5cdFx0XHRcdFx0XHRcdFx0aWYodHAuaWNvbi5pbWFnZSlcdHsgaWNvbnNfY3NzICs9ICcgYmFja2dyb3VuZC1pbWFnZTp1cmwoJyArIHRwLmljb24uaW1hZ2UgKyAnKTsgJzsgfVxuXHRcdFx0XHRcdFx0XHRcdGlmKHRwLmljb24ucG9zaXRpb24peyBpY29uc19jc3MgKz0gJyBiYWNrZ3JvdW5kLXBvc2l0aW9uOicgKyB0cC5pY29uLnBvc2l0aW9uICsgJzsgJzsgfVxuXHRcdFx0XHRcdFx0XHRcdGVsc2VcdFx0XHRcdHsgaWNvbnNfY3NzICs9ICcgYmFja2dyb3VuZC1wb3NpdGlvbjowIDA7ICc7IH1cblx0XHRcdFx0XHRcdFx0XHRpY29uc19jc3MgKz0gJ30gJztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRpZihpY29uc19jc3MgIT09IFwiXCIpIHsgJC52YWthdGEuY3NzLmFkZF9zaGVldCh7ICdzdHInIDogaWNvbnNfY3NzLCB0aXRsZSA6IFwianN0cmVlLXR5cGVzXCIgfSk7IH1cblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJiZWZvcmUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHsgXG5cdFx0XHRcdFx0XHR2YXIgcywgdCwgXG5cdFx0XHRcdFx0XHRcdG8gPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS50eXBlcy51c2VfZGF0YSA/IHRoaXMuX2dldF9ub2RlKGRhdGEuYXJnc1swXSkgOiBmYWxzZSwgXG5cdFx0XHRcdFx0XHRcdGQgPSBvICYmIG8gIT09IC0xICYmIG8ubGVuZ3RoID8gby5kYXRhKFwianN0cmVlXCIpIDogZmFsc2U7XG5cdFx0XHRcdFx0XHRpZihkICYmIGQudHlwZXMgJiYgZC50eXBlc1tkYXRhLmZ1bmNdID09PSBmYWxzZSkgeyBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpOyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0XHRcdGlmKCQuaW5BcnJheShkYXRhLmZ1bmMsIHRoaXMuZGF0YS50eXBlcy5hdHRhY2hfdG8pICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRpZighZGF0YS5hcmdzWzBdIHx8ICghZGF0YS5hcmdzWzBdLnRhZ05hbWUgJiYgIWRhdGEuYXJnc1swXS5qcXVlcnkpKSB7IHJldHVybjsgfVxuXHRcdFx0XHRcdFx0XHRzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkudHlwZXMudHlwZXM7XG5cdFx0XHRcdFx0XHRcdHQgPSB0aGlzLl9nZXRfdHlwZShkYXRhLmFyZ3NbMF0pO1xuXHRcdFx0XHRcdFx0XHRpZihcblx0XHRcdFx0XHRcdFx0XHQoIFxuXHRcdFx0XHRcdFx0XHRcdFx0KHNbdF0gJiYgdHlwZW9mIHNbdF1bZGF0YS5mdW5jXSAhPT0gXCJ1bmRlZmluZWRcIikgfHwgXG5cdFx0XHRcdFx0XHRcdFx0XHQoc1tcImRlZmF1bHRcIl0gJiYgdHlwZW9mIHNbXCJkZWZhdWx0XCJdW2RhdGEuZnVuY10gIT09IFwidW5kZWZpbmVkXCIpIFxuXHRcdFx0XHRcdFx0XHRcdCkgJiYgdGhpcy5fY2hlY2soZGF0YS5mdW5jLCBkYXRhLmFyZ3NbMF0pID09PSBmYWxzZVxuXHRcdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdGlmKGlzX2llNikge1xuXHRcdFx0XHR0aGlzLmdldF9jb250YWluZXIoKVxuXHRcdFx0XHRcdC5iaW5kKFwibG9hZF9ub2RlLmpzdHJlZSBzZXRfdHlwZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgciA9IGRhdGEgJiYgZGF0YS5yc2x0ICYmIGRhdGEucnNsdC5vYmogJiYgZGF0YS5yc2x0Lm9iaiAhPT0gLTEgPyB0aGlzLl9nZXRfbm9kZShkYXRhLnJzbHQub2JqKS5wYXJlbnQoKSA6IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLFxuXHRcdFx0XHRcdFx0XHRcdGMgPSBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHRzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkudHlwZXM7XG5cdFx0XHRcdFx0XHRcdCQuZWFjaChzLnR5cGVzLCBmdW5jdGlvbiAoaSwgdHApIHtcblx0XHRcdFx0XHRcdFx0XHRpZih0cC5pY29uICYmICh0cC5pY29uLmltYWdlIHx8IHRwLmljb24ucG9zaXRpb24pKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjID0gaSA9PT0gXCJkZWZhdWx0XCIgPyByLmZpbmQoXCJsaSA+IGEgPiAuanN0cmVlLWljb25cIikgOiByLmZpbmQoXCJsaVtcIiArIHMudHlwZV9hdHRyICsgXCI9J1wiICsgaSArIFwiJ10gPiBhID4gLmpzdHJlZS1pY29uXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYodHAuaWNvbi5pbWFnZSkgeyBjLmNzcyhcImJhY2tncm91bmRJbWFnZVwiLFwidXJsKFwiICsgdHAuaWNvbi5pbWFnZSArIFwiKVwiKTsgfVxuXHRcdFx0XHRcdFx0XHRcdFx0Yy5jc3MoXCJiYWNrZ3JvdW5kUG9zaXRpb25cIiwgdHAuaWNvbi5wb3NpdGlvbiB8fCBcIjAgMFwiKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZGVmYXVsdHMgOiB7XG5cdFx0XHQvLyBkZWZpbmVzIG1heGltdW0gbnVtYmVyIG9mIHJvb3Qgbm9kZXMgKC0xIG1lYW5zIHVubGltaXRlZCwgLTIgbWVhbnMgZGlzYWJsZSBtYXhfY2hpbGRyZW4gY2hlY2tpbmcpXG5cdFx0XHRtYXhfY2hpbGRyZW5cdFx0OiAtMSxcblx0XHRcdC8vIGRlZmluZXMgdGhlIG1heGltdW0gZGVwdGggb2YgdGhlIHRyZWUgKC0xIG1lYW5zIHVubGltaXRlZCwgLTIgbWVhbnMgZGlzYWJsZSBtYXhfZGVwdGggY2hlY2tpbmcpXG5cdFx0XHRtYXhfZGVwdGhcdFx0XHQ6IC0xLFxuXHRcdFx0Ly8gZGVmaW5lcyB2YWxpZCBub2RlIHR5cGVzIGZvciB0aGUgcm9vdCBub2Rlc1xuXHRcdFx0dmFsaWRfY2hpbGRyZW5cdFx0OiBcImFsbFwiLFxuXG5cdFx0XHQvLyB3aGV0aGVyIHRvIHVzZSAkLmRhdGFcblx0XHRcdHVzZV9kYXRhIDogZmFsc2UsIFxuXHRcdFx0Ly8gd2hlcmUgaXMgdGhlIHR5cGUgc3RvcmVzICh0aGUgcmVsIGF0dHJpYnV0ZSBvZiB0aGUgTEkgZWxlbWVudClcblx0XHRcdHR5cGVfYXR0ciA6IFwicmVsXCIsXG5cdFx0XHQvLyBhIGxpc3Qgb2YgdHlwZXNcblx0XHRcdHR5cGVzIDoge1xuXHRcdFx0XHQvLyB0aGUgZGVmYXVsdCB0eXBlXG5cdFx0XHRcdFwiZGVmYXVsdFwiIDoge1xuXHRcdFx0XHRcdFwibWF4X2NoaWxkcmVuXCJcdDogLTEsXG5cdFx0XHRcdFx0XCJtYXhfZGVwdGhcIlx0XHQ6IC0xLFxuXHRcdFx0XHRcdFwidmFsaWRfY2hpbGRyZW5cIjogXCJhbGxcIlxuXG5cdFx0XHRcdFx0Ly8gQm91bmQgZnVuY3Rpb25zIC0geW91IGNhbiBiaW5kIGFueSBvdGhlciBmdW5jdGlvbiBoZXJlICh1c2luZyBib29sZWFuIG9yIGZ1bmN0aW9uKVxuXHRcdFx0XHRcdC8vXCJzZWxlY3Rfbm9kZVwiXHQ6IHRydWVcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0X2ZuIDoge1xuXHRcdFx0X3R5cGVzX25vdGlmeSA6IGZ1bmN0aW9uIChuLCBkYXRhKSB7XG5cdFx0XHRcdGlmKGRhdGEudHlwZSAmJiB0aGlzLl9nZXRfc2V0dGluZ3MoKS50eXBlcy51c2VfZGF0YSkge1xuXHRcdFx0XHRcdHRoaXMuc2V0X3R5cGUoZGF0YS50eXBlLCBuKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF9nZXRfdHlwZSA6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0cmV0dXJuICghb2JqIHx8ICFvYmoubGVuZ3RoKSA/IGZhbHNlIDogb2JqLmF0dHIodGhpcy5fZ2V0X3NldHRpbmdzKCkudHlwZXMudHlwZV9hdHRyKSB8fCBcImRlZmF1bHRcIjtcblx0XHRcdH0sXG5cdFx0XHRzZXRfdHlwZSA6IGZ1bmN0aW9uIChzdHIsIG9iaikge1xuXHRcdFx0XHRvYmogPSB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHR2YXIgcmV0ID0gKCFvYmoubGVuZ3RoIHx8ICFzdHIpID8gZmFsc2UgOiBvYmouYXR0cih0aGlzLl9nZXRfc2V0dGluZ3MoKS50eXBlcy50eXBlX2F0dHIsIHN0cik7XG5cdFx0XHRcdGlmKHJldCkgeyB0aGlzLl9fY2FsbGJhY2soeyBvYmogOiBvYmosIHR5cGUgOiBzdHJ9KTsgfVxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fSxcblx0XHRcdF9jaGVjayA6IGZ1bmN0aW9uIChydWxlLCBvYmosIG9wdHMpIHtcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0dmFyIHYgPSBmYWxzZSwgdCA9IHRoaXMuX2dldF90eXBlKG9iaiksIGQgPSAwLCBfdGhpcyA9IHRoaXMsIHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKS50eXBlcywgZGF0YSA9IGZhbHNlO1xuXHRcdFx0XHRpZihvYmogPT09IC0xKSB7IFxuXHRcdFx0XHRcdGlmKCEhc1tydWxlXSkgeyB2ID0gc1tydWxlXTsgfVxuXHRcdFx0XHRcdGVsc2UgeyByZXR1cm47IH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZih0ID09PSBmYWxzZSkgeyByZXR1cm47IH1cblx0XHRcdFx0XHRkYXRhID0gcy51c2VfZGF0YSA/IG9iai5kYXRhKFwianN0cmVlXCIpIDogZmFsc2U7XG5cdFx0XHRcdFx0aWYoZGF0YSAmJiBkYXRhLnR5cGVzICYmIHR5cGVvZiBkYXRhLnR5cGVzW3J1bGVdICE9PSBcInVuZGVmaW5lZFwiKSB7IHYgPSBkYXRhLnR5cGVzW3J1bGVdOyB9XG5cdFx0XHRcdFx0ZWxzZSBpZighIXMudHlwZXNbdF0gJiYgdHlwZW9mIHMudHlwZXNbdF1bcnVsZV0gIT09IFwidW5kZWZpbmVkXCIpIHsgdiA9IHMudHlwZXNbdF1bcnVsZV07IH1cblx0XHRcdFx0XHRlbHNlIGlmKCEhcy50eXBlc1tcImRlZmF1bHRcIl0gJiYgdHlwZW9mIHMudHlwZXNbXCJkZWZhdWx0XCJdW3J1bGVdICE9PSBcInVuZGVmaW5lZFwiKSB7IHYgPSBzLnR5cGVzW1wiZGVmYXVsdFwiXVtydWxlXTsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCQuaXNGdW5jdGlvbih2KSkgeyB2ID0gdi5jYWxsKHRoaXMsIG9iaik7IH1cblx0XHRcdFx0aWYocnVsZSA9PT0gXCJtYXhfZGVwdGhcIiAmJiBvYmogIT09IC0xICYmIG9wdHMgIT09IGZhbHNlICYmIHMubWF4X2RlcHRoICE9PSAtMiAmJiB2ICE9PSAwKSB7XG5cdFx0XHRcdFx0Ly8gYWxzbyBpbmNsdWRlIHRoZSBub2RlIGl0c2VsZiAtIG90aGVyd2lzZSBpZiByb290IG5vZGUgaXQgaXMgbm90IGNoZWNrZWRcblx0XHRcdFx0XHRvYmouY2hpbGRyZW4oXCJhOmVxKDApXCIpLnBhcmVudHNVbnRpbChcIi5qc3RyZWVcIixcImxpXCIpLmVhY2goZnVuY3Rpb24gKGkpIHtcblx0XHRcdFx0XHRcdC8vIGNoZWNrIGlmIGN1cnJlbnQgZGVwdGggYWxyZWFkeSBleGNlZWRzIGdsb2JhbCB0cmVlIGRlcHRoXG5cdFx0XHRcdFx0XHRpZihzLm1heF9kZXB0aCAhPT0gLTEgJiYgcy5tYXhfZGVwdGggLSAoaSArIDEpIDw9IDApIHsgdiA9IDA7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRcdFx0ZCA9IChpID09PSAwKSA/IHYgOiBfdGhpcy5fY2hlY2socnVsZSwgdGhpcywgZmFsc2UpO1xuXHRcdFx0XHRcdFx0Ly8gY2hlY2sgaWYgY3VycmVudCBub2RlIG1heCBkZXB0aCBpcyBhbHJlYWR5IG1hdGNoZWQgb3IgZXhjZWVkZWRcblx0XHRcdFx0XHRcdGlmKGQgIT09IC0xICYmIGQgLSAoaSArIDEpIDw9IDApIHsgdiA9IDA7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIC0gc2V0IHRoZSBtYXggZGVwdGggdG8gdGhlIGN1cnJlbnQgdmFsdWUgbWludXMgY3VycmVudCBkZXB0aFxuXHRcdFx0XHRcdFx0aWYoZCA+PSAwICYmIChkIC0gKGkgKyAxKSA8IHYgfHwgdiA8IDApICkgeyB2ID0gZCAtIChpICsgMSk7IH1cblx0XHRcdFx0XHRcdC8vIGlmIHRoZSBnbG9iYWwgdHJlZSBkZXB0aCBleGlzdHMgYW5kIGl0IG1pbnVzIHRoZSBub2RlcyBjYWxjdWxhdGVkIHNvIGZhciBpcyBsZXNzIHRoYW4gYHZgIG9yIGB2YCBpcyB1bmxpbWl0ZWRcblx0XHRcdFx0XHRcdGlmKHMubWF4X2RlcHRoID49IDAgJiYgKHMubWF4X2RlcHRoIC0gKGkgKyAxKSA8IHYgfHwgdiA8IDApICkgeyB2ID0gcy5tYXhfZGVwdGggLSAoaSArIDEpOyB9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHY7XG5cdFx0XHR9LFxuXHRcdFx0Y2hlY2tfbW92ZSA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYoIXRoaXMuX19jYWxsX29sZCgpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHR2YXIgbSAgPSB0aGlzLl9nZXRfbW92ZSgpLFxuXHRcdFx0XHRcdHMgID0gbS5ydC5fZ2V0X3NldHRpbmdzKCkudHlwZXMsXG5cdFx0XHRcdFx0bWMgPSBtLnJ0Ll9jaGVjayhcIm1heF9jaGlsZHJlblwiLCBtLmNyKSxcblx0XHRcdFx0XHRtZCA9IG0ucnQuX2NoZWNrKFwibWF4X2RlcHRoXCIsIG0uY3IpLFxuXHRcdFx0XHRcdHZjID0gbS5ydC5fY2hlY2soXCJ2YWxpZF9jaGlsZHJlblwiLCBtLmNyKSxcblx0XHRcdFx0XHRjaCA9IDAsIGQgPSAxLCB0O1xuXG5cdFx0XHRcdGlmKHZjID09PSBcIm5vbmVcIikgeyByZXR1cm4gZmFsc2U7IH0gXG5cdFx0XHRcdGlmKCQuaXNBcnJheSh2YykgJiYgbS5vdCAmJiBtLm90Ll9nZXRfdHlwZSkge1xuXHRcdFx0XHRcdG0uby5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGlmKCQuaW5BcnJheShtLm90Ll9nZXRfdHlwZSh0aGlzKSwgdmMpID09PSAtMSkgeyBkID0gZmFsc2U7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGlmKGQgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHMubWF4X2NoaWxkcmVuICE9PSAtMiAmJiBtYyAhPT0gLTEpIHtcblx0XHRcdFx0XHRjaCA9IG0uY3IgPT09IC0xID8gdGhpcy5nZXRfY29udGFpbmVyKCkuZmluZChcIj4gdWwgPiBsaVwiKS5ub3QobS5vKS5sZW5ndGggOiBtLmNyLmZpbmQoXCI+IHVsID4gbGlcIikubm90KG0ubykubGVuZ3RoO1xuXHRcdFx0XHRcdGlmKGNoICsgbS5vLmxlbmd0aCA+IG1jKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHMubWF4X2RlcHRoICE9PSAtMiAmJiBtZCAhPT0gLTEpIHtcblx0XHRcdFx0XHRkID0gMDtcblx0XHRcdFx0XHRpZihtZCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0XHRpZih0eXBlb2YgbS5vLmQgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdFx0XHRcdC8vIFRPRE86IGRlYWwgd2l0aCBwcm9ncmVzc2l2ZSByZW5kZXJpbmcgYW5kIGFzeW5jIHdoZW4gY2hlY2tpbmcgbWF4X2RlcHRoIChob3cgdG8ga25vdyB0aGUgZGVwdGggb2YgdGhlIG1vdmVkIG5vZGUpXG5cdFx0XHRcdFx0XHR0ID0gbS5vO1xuXHRcdFx0XHRcdFx0d2hpbGUodC5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0XHRcdHQgPSB0LmZpbmQoXCI+IHVsID4gbGlcIik7XG5cdFx0XHRcdFx0XHRcdGQgKys7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtLm8uZCA9IGQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKG1kIC0gbS5vLmQgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdGNyZWF0ZV9ub2RlIDogZnVuY3Rpb24gKG9iaiwgcG9zaXRpb24sIGpzLCBjYWxsYmFjaywgaXNfbG9hZGVkLCBza2lwX2NoZWNrKSB7XG5cdFx0XHRcdGlmKCFza2lwX2NoZWNrICYmIChpc19sb2FkZWQgfHwgdGhpcy5faXNfbG9hZGVkKG9iaikpKSB7XG5cdFx0XHRcdFx0dmFyIHAgID0gKHR5cGVvZiBwb3NpdGlvbiA9PSBcInN0cmluZ1wiICYmIHBvc2l0aW9uLm1hdGNoKC9eYmVmb3JlfGFmdGVyJC9pKSAmJiBvYmogIT09IC0xKSA/IHRoaXMuX2dldF9wYXJlbnQob2JqKSA6IHRoaXMuX2dldF9ub2RlKG9iaiksXG5cdFx0XHRcdFx0XHRzICA9IHRoaXMuX2dldF9zZXR0aW5ncygpLnR5cGVzLFxuXHRcdFx0XHRcdFx0bWMgPSB0aGlzLl9jaGVjayhcIm1heF9jaGlsZHJlblwiLCBwKSxcblx0XHRcdFx0XHRcdG1kID0gdGhpcy5fY2hlY2soXCJtYXhfZGVwdGhcIiwgcCksXG5cdFx0XHRcdFx0XHR2YyA9IHRoaXMuX2NoZWNrKFwidmFsaWRfY2hpbGRyZW5cIiwgcCksXG5cdFx0XHRcdFx0XHRjaDtcblx0XHRcdFx0XHRpZih0eXBlb2YganMgPT09IFwic3RyaW5nXCIpIHsganMgPSB7IGRhdGEgOiBqcyB9OyB9XG5cdFx0XHRcdFx0aWYoIWpzKSB7IGpzID0ge307IH1cblx0XHRcdFx0XHRpZih2YyA9PT0gXCJub25lXCIpIHsgcmV0dXJuIGZhbHNlOyB9IFxuXHRcdFx0XHRcdGlmKCQuaXNBcnJheSh2YykpIHtcblx0XHRcdFx0XHRcdGlmKCFqcy5hdHRyIHx8ICFqcy5hdHRyW3MudHlwZV9hdHRyXSkgeyBcblx0XHRcdFx0XHRcdFx0aWYoIWpzLmF0dHIpIHsganMuYXR0ciA9IHt9OyB9XG5cdFx0XHRcdFx0XHRcdGpzLmF0dHJbcy50eXBlX2F0dHJdID0gdmNbMF07IFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmKCQuaW5BcnJheShqcy5hdHRyW3MudHlwZV9hdHRyXSwgdmMpID09PSAtMSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYocy5tYXhfY2hpbGRyZW4gIT09IC0yICYmIG1jICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0Y2ggPSBwID09PSAtMSA/IHRoaXMuZ2V0X2NvbnRhaW5lcigpLmZpbmQoXCI+IHVsID4gbGlcIikubGVuZ3RoIDogcC5maW5kKFwiPiB1bCA+IGxpXCIpLmxlbmd0aDtcblx0XHRcdFx0XHRcdGlmKGNoICsgMSA+IG1jKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihzLm1heF9kZXB0aCAhPT0gLTIgJiYgbWQgIT09IC0xICYmIChtZCAtIDEpIDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fX2NhbGxfb2xkKHRydWUsIG9iaiwgcG9zaXRpb24sIGpzLCBjYWxsYmFjaywgaXNfbG9hZGVkLCBza2lwX2NoZWNrKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufSkoalF1ZXJ5KTtcbi8vKi9cblxuLyogXG4gKiBqc1RyZWUgSFRNTCBwbHVnaW5cbiAqIFRoZSBIVE1MIGRhdGEgc3RvcmUuIERhdGFzdG9yZXMgYXJlIGJ1aWxkIGJ5IHJlcGxhY2luZyB0aGUgYGxvYWRfbm9kZWAgYW5kIGBfaXNfbG9hZGVkYCBmdW5jdGlvbnMuXG4gKi9cbihmdW5jdGlvbiAoJCkge1xuXHQkLmpzdHJlZS5wbHVnaW4oXCJodG1sX2RhdGFcIiwge1xuXHRcdF9faW5pdCA6IGZ1bmN0aW9uICgpIHsgXG5cdFx0XHQvLyB0aGlzIHVzZWQgdG8gdXNlIGh0bWwoKSBhbmQgY2xlYW4gdGhlIHdoaXRlc3BhY2UsIGJ1dCB0aGlzIHdheSBhbnkgYXR0YWNoZWQgZGF0YSB3YXMgbG9zdFxuXHRcdFx0dGhpcy5kYXRhLmh0bWxfZGF0YS5vcmlnaW5hbF9jb250YWluZXJfaHRtbCA9IHRoaXMuZ2V0X2NvbnRhaW5lcigpLmZpbmQoXCIgPiB1bCA+IGxpXCIpLmNsb25lKHRydWUpO1xuXHRcdFx0Ly8gcmVtb3ZlIHdoaXRlIHNwYWNlIGZyb20gTEkgbm9kZSAtIG90aGVyd2lzZSBub2RlcyBhcHBlYXIgYSBiaXQgdG8gdGhlIHJpZ2h0XG5cdFx0XHR0aGlzLmRhdGEuaHRtbF9kYXRhLm9yaWdpbmFsX2NvbnRhaW5lcl9odG1sLmZpbmQoXCJsaVwiKS5hbmRTZWxmKCkuY29udGVudHMoKS5maWx0ZXIoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm5vZGVUeXBlID09IDM7IH0pLnJlbW92ZSgpO1xuXHRcdH0sXG5cdFx0ZGVmYXVsdHMgOiB7IFxuXHRcdFx0ZGF0YSA6IGZhbHNlLFxuXHRcdFx0YWpheCA6IGZhbHNlLFxuXHRcdFx0Y29ycmVjdF9zdGF0ZSA6IHRydWVcblx0XHR9LFxuXHRcdF9mbiA6IHtcblx0XHRcdGxvYWRfbm9kZSA6IGZ1bmN0aW9uIChvYmosIHNfY2FsbCwgZV9jYWxsKSB7IHZhciBfdGhpcyA9IHRoaXM7IHRoaXMubG9hZF9ub2RlX2h0bWwob2JqLCBmdW5jdGlvbiAoKSB7IF90aGlzLl9fY2FsbGJhY2soeyBcIm9ialwiIDogX3RoaXMuX2dldF9ub2RlKG9iaikgfSk7IHNfY2FsbC5jYWxsKHRoaXMpOyB9LCBlX2NhbGwpOyB9LFxuXHRcdFx0X2lzX2xvYWRlZCA6IGZ1bmN0aW9uIChvYmopIHsgXG5cdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7IFxuXHRcdFx0XHRyZXR1cm4gb2JqID09IC0xIHx8ICFvYmogfHwgKCF0aGlzLl9nZXRfc2V0dGluZ3MoKS5odG1sX2RhdGEuYWpheCAmJiAhJC5pc0Z1bmN0aW9uKHRoaXMuX2dldF9zZXR0aW5ncygpLmh0bWxfZGF0YS5kYXRhKSkgfHwgb2JqLmlzKFwiLmpzdHJlZS1vcGVuLCAuanN0cmVlLWxlYWZcIikgfHwgb2JqLmNoaWxkcmVuKFwidWxcIikuY2hpbGRyZW4oXCJsaVwiKS5zaXplKCkgPiAwO1xuXHRcdFx0fSxcblx0XHRcdGxvYWRfbm9kZV9odG1sIDogZnVuY3Rpb24gKG9iaiwgc19jYWxsLCBlX2NhbGwpIHtcblx0XHRcdFx0dmFyIGQsXG5cdFx0XHRcdFx0cyA9IHRoaXMuZ2V0X3NldHRpbmdzKCkuaHRtbF9kYXRhLFxuXHRcdFx0XHRcdGVycm9yX2Z1bmMgPSBmdW5jdGlvbiAoKSB7fSxcblx0XHRcdFx0XHRzdWNjZXNzX2Z1bmMgPSBmdW5jdGlvbiAoKSB7fTtcblx0XHRcdFx0b2JqID0gdGhpcy5fZ2V0X25vZGUob2JqKTtcblx0XHRcdFx0aWYob2JqICYmIG9iaiAhPT0gLTEpIHtcblx0XHRcdFx0XHRpZihvYmouZGF0YShcImpzdHJlZV9pc19sb2FkaW5nXCIpKSB7IHJldHVybjsgfVxuXHRcdFx0XHRcdGVsc2UgeyBvYmouZGF0YShcImpzdHJlZV9pc19sb2FkaW5nXCIsdHJ1ZSk7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2goITApIHtcblx0XHRcdFx0XHRjYXNlICgkLmlzRnVuY3Rpb24ocy5kYXRhKSk6XG5cdFx0XHRcdFx0XHRzLmRhdGEuY2FsbCh0aGlzLCBvYmosICQucHJveHkoZnVuY3Rpb24gKGQpIHtcblx0XHRcdFx0XHRcdFx0aWYoZCAmJiBkICE9PSBcIlwiICYmIGQudG9TdHJpbmcgJiYgZC50b1N0cmluZygpLnJlcGxhY2UoL15bXFxzXFxuXSskLyxcIlwiKSAhPT0gXCJcIikge1xuXHRcdFx0XHRcdFx0XHRcdGQgPSAkKGQpO1xuXHRcdFx0XHRcdFx0XHRcdGlmKCFkLmlzKFwidWxcIikpIHsgZCA9ICQoXCI8dWwgLz5cIikuYXBwZW5kKGQpOyB9XG5cdFx0XHRcdFx0XHRcdFx0aWYob2JqID09IC0xIHx8ICFvYmopIHsgdGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5lbXB0eSgpLmFwcGVuZChkLmNoaWxkcmVuKCkpLmZpbmQoXCJsaSwgYVwiKS5maWx0ZXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gIXRoaXMuZmlyc3RDaGlsZCB8fCAhdGhpcy5maXJzdENoaWxkLnRhZ05hbWUgfHwgdGhpcy5maXJzdENoaWxkLnRhZ05hbWUgIT09IFwiSU5TXCI7IH0pLnByZXBlbmQoXCI8aW5zIGNsYXNzPSdqc3RyZWUtaWNvbic+JiMxNjA7PC9pbnM+XCIpLmVuZCgpLmZpbHRlcihcImFcIikuY2hpbGRyZW4oXCJpbnM6Zmlyc3QtY2hpbGRcIikubm90KFwiLmpzdHJlZS1pY29uXCIpLmFkZENsYXNzKFwianN0cmVlLWljb25cIik7IH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlIHsgb2JqLmNoaWxkcmVuKFwiYS5qc3RyZWUtbG9hZGluZ1wiKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1sb2FkaW5nXCIpOyBvYmouYXBwZW5kKGQpLmNoaWxkcmVuKFwidWxcIikuZmluZChcImxpLCBhXCIpLmZpbHRlcihmdW5jdGlvbiAoKSB7IHJldHVybiAhdGhpcy5maXJzdENoaWxkIHx8ICF0aGlzLmZpcnN0Q2hpbGQudGFnTmFtZSB8fCB0aGlzLmZpcnN0Q2hpbGQudGFnTmFtZSAhPT0gXCJJTlNcIjsgfSkucHJlcGVuZChcIjxpbnMgY2xhc3M9J2pzdHJlZS1pY29uJz4mIzE2MDs8L2lucz5cIikuZW5kKCkuZmlsdGVyKFwiYVwiKS5jaGlsZHJlbihcImluczpmaXJzdC1jaGlsZFwiKS5ub3QoXCIuanN0cmVlLWljb25cIikuYWRkQ2xhc3MoXCJqc3RyZWUtaWNvblwiKTsgb2JqLnJlbW92ZURhdGEoXCJqc3RyZWVfaXNfbG9hZGluZ1wiKTsgfVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuY2xlYW5fbm9kZShvYmopO1xuXHRcdFx0XHRcdFx0XHRcdGlmKHNfY2FsbCkgeyBzX2NhbGwuY2FsbCh0aGlzKTsgfVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGlmKG9iaiAmJiBvYmogIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvYmouY2hpbGRyZW4oXCJhLmpzdHJlZS1sb2FkaW5nXCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLWxvYWRpbmdcIik7XG5cdFx0XHRcdFx0XHRcdFx0XHRvYmoucmVtb3ZlRGF0YShcImpzdHJlZV9pc19sb2FkaW5nXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYocy5jb3JyZWN0X3N0YXRlKSB7IFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmNvcnJlY3Rfc3RhdGUob2JqKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoc19jYWxsKSB7IHNfY2FsbC5jYWxsKHRoaXMpOyB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHMuY29ycmVjdF9zdGF0ZSkgeyBcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5lbXB0eSgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihzX2NhbGwpIHsgc19jYWxsLmNhbGwodGhpcyk7IH0gXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICghcy5kYXRhICYmICFzLmFqYXgpOlxuXHRcdFx0XHRcdFx0aWYoIW9iaiB8fCBvYmogPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKClcblx0XHRcdFx0XHRcdFx0XHQuY2hpbGRyZW4oXCJ1bFwiKS5lbXB0eSgpXG5cdFx0XHRcdFx0XHRcdFx0LmFwcGVuZCh0aGlzLmRhdGEuaHRtbF9kYXRhLm9yaWdpbmFsX2NvbnRhaW5lcl9odG1sKVxuXHRcdFx0XHRcdFx0XHRcdC5maW5kKFwibGksIGFcIikuZmlsdGVyKGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzLmZpcnN0Q2hpbGQgfHwgIXRoaXMuZmlyc3RDaGlsZC50YWdOYW1lIHx8IHRoaXMuZmlyc3RDaGlsZC50YWdOYW1lICE9PSBcIklOU1wiOyB9KS5wcmVwZW5kKFwiPGlucyBjbGFzcz0nanN0cmVlLWljb24nPiYjMTYwOzwvaW5zPlwiKS5lbmQoKVxuXHRcdFx0XHRcdFx0XHRcdC5maWx0ZXIoXCJhXCIpLmNoaWxkcmVuKFwiaW5zOmZpcnN0LWNoaWxkXCIpLm5vdChcIi5qc3RyZWUtaWNvblwiKS5hZGRDbGFzcyhcImpzdHJlZS1pY29uXCIpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLmNsZWFuX25vZGUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKHNfY2FsbCkgeyBzX2NhbGwuY2FsbCh0aGlzKTsgfVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAoISFzLmRhdGEgJiYgIXMuYWpheCkgfHwgKCEhcy5kYXRhICYmICEhcy5hamF4ICYmICghb2JqIHx8IG9iaiA9PT0gLTEpKTpcblx0XHRcdFx0XHRcdGlmKCFvYmogfHwgb2JqID09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGQgPSAkKHMuZGF0YSk7XG5cdFx0XHRcdFx0XHRcdGlmKCFkLmlzKFwidWxcIikpIHsgZCA9ICQoXCI8dWwgLz5cIikuYXBwZW5kKGQpOyB9XG5cdFx0XHRcdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpXG5cdFx0XHRcdFx0XHRcdFx0LmNoaWxkcmVuKFwidWxcIikuZW1wdHkoKS5hcHBlbmQoZC5jaGlsZHJlbigpKVxuXHRcdFx0XHRcdFx0XHRcdC5maW5kKFwibGksIGFcIikuZmlsdGVyKGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzLmZpcnN0Q2hpbGQgfHwgIXRoaXMuZmlyc3RDaGlsZC50YWdOYW1lIHx8IHRoaXMuZmlyc3RDaGlsZC50YWdOYW1lICE9PSBcIklOU1wiOyB9KS5wcmVwZW5kKFwiPGlucyBjbGFzcz0nanN0cmVlLWljb24nPiYjMTYwOzwvaW5zPlwiKS5lbmQoKVxuXHRcdFx0XHRcdFx0XHRcdC5maWx0ZXIoXCJhXCIpLmNoaWxkcmVuKFwiaW5zOmZpcnN0LWNoaWxkXCIpLm5vdChcIi5qc3RyZWUtaWNvblwiKS5hZGRDbGFzcyhcImpzdHJlZS1pY29uXCIpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLmNsZWFuX25vZGUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKHNfY2FsbCkgeyBzX2NhbGwuY2FsbCh0aGlzKTsgfVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAoIXMuZGF0YSAmJiAhIXMuYWpheCkgfHwgKCEhcy5kYXRhICYmICEhcy5hamF4ICYmIG9iaiAmJiBvYmogIT09IC0xKTpcblx0XHRcdFx0XHRcdG9iaiA9IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdFx0XHRlcnJvcl9mdW5jID0gZnVuY3Rpb24gKHgsIHQsIGUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGVmID0gdGhpcy5nZXRfc2V0dGluZ3MoKS5odG1sX2RhdGEuYWpheC5lcnJvcjsgXG5cdFx0XHRcdFx0XHRcdGlmKGVmKSB7IGVmLmNhbGwodGhpcywgeCwgdCwgZSk7IH1cblx0XHRcdFx0XHRcdFx0aWYob2JqICE9IC0xICYmIG9iai5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRvYmouY2hpbGRyZW4oXCJhLmpzdHJlZS1sb2FkaW5nXCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLWxvYWRpbmdcIik7XG5cdFx0XHRcdFx0XHRcdFx0b2JqLnJlbW92ZURhdGEoXCJqc3RyZWVfaXNfbG9hZGluZ1wiKTtcblx0XHRcdFx0XHRcdFx0XHRpZih0ID09PSBcInN1Y2Nlc3NcIiAmJiBzLmNvcnJlY3Rfc3RhdGUpIHsgdGhpcy5jb3JyZWN0X3N0YXRlKG9iaik7IH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRpZih0ID09PSBcInN1Y2Nlc3NcIiAmJiBzLmNvcnJlY3Rfc3RhdGUpIHsgdGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCJ1bFwiKS5lbXB0eSgpOyB9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYoZV9jYWxsKSB7IGVfY2FsbC5jYWxsKHRoaXMpOyB9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0c3VjY2Vzc19mdW5jID0gZnVuY3Rpb24gKGQsIHQsIHgpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHNmID0gdGhpcy5nZXRfc2V0dGluZ3MoKS5odG1sX2RhdGEuYWpheC5zdWNjZXNzOyBcblx0XHRcdFx0XHRcdFx0aWYoc2YpIHsgZCA9IHNmLmNhbGwodGhpcyxkLHQseCkgfHwgZDsgfVxuXHRcdFx0XHRcdFx0XHRpZihkID09PSBcIlwiIHx8IChkICYmIGQudG9TdHJpbmcgJiYgZC50b1N0cmluZygpLnJlcGxhY2UoL15bXFxzXFxuXSskLyxcIlwiKSA9PT0gXCJcIikpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZXJyb3JfZnVuYy5jYWxsKHRoaXMsIHgsIHQsIFwiXCIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmKGQpIHtcblx0XHRcdFx0XHRcdFx0XHRkID0gJChkKTtcblx0XHRcdFx0XHRcdFx0XHRpZighZC5pcyhcInVsXCIpKSB7IGQgPSAkKFwiPHVsIC8+XCIpLmFwcGVuZChkKTsgfVxuXHRcdFx0XHRcdFx0XHRcdGlmKG9iaiA9PSAtMSB8fCAhb2JqKSB7IHRoaXMuZ2V0X2NvbnRhaW5lcigpLmNoaWxkcmVuKFwidWxcIikuZW1wdHkoKS5hcHBlbmQoZC5jaGlsZHJlbigpKS5maW5kKFwibGksIGFcIikuZmlsdGVyKGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzLmZpcnN0Q2hpbGQgfHwgIXRoaXMuZmlyc3RDaGlsZC50YWdOYW1lIHx8IHRoaXMuZmlyc3RDaGlsZC50YWdOYW1lICE9PSBcIklOU1wiOyB9KS5wcmVwZW5kKFwiPGlucyBjbGFzcz0nanN0cmVlLWljb24nPiYjMTYwOzwvaW5zPlwiKS5lbmQoKS5maWx0ZXIoXCJhXCIpLmNoaWxkcmVuKFwiaW5zOmZpcnN0LWNoaWxkXCIpLm5vdChcIi5qc3RyZWUtaWNvblwiKS5hZGRDbGFzcyhcImpzdHJlZS1pY29uXCIpOyB9XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSB7IG9iai5jaGlsZHJlbihcImEuanN0cmVlLWxvYWRpbmdcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbG9hZGluZ1wiKTsgb2JqLmFwcGVuZChkKS5jaGlsZHJlbihcInVsXCIpLmZpbmQoXCJsaSwgYVwiKS5maWx0ZXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gIXRoaXMuZmlyc3RDaGlsZCB8fCAhdGhpcy5maXJzdENoaWxkLnRhZ05hbWUgfHwgdGhpcy5maXJzdENoaWxkLnRhZ05hbWUgIT09IFwiSU5TXCI7IH0pLnByZXBlbmQoXCI8aW5zIGNsYXNzPSdqc3RyZWUtaWNvbic+JiMxNjA7PC9pbnM+XCIpLmVuZCgpLmZpbHRlcihcImFcIikuY2hpbGRyZW4oXCJpbnM6Zmlyc3QtY2hpbGRcIikubm90KFwiLmpzdHJlZS1pY29uXCIpLmFkZENsYXNzKFwianN0cmVlLWljb25cIik7IG9iai5yZW1vdmVEYXRhKFwianN0cmVlX2lzX2xvYWRpbmdcIik7IH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLmNsZWFuX25vZGUob2JqKTtcblx0XHRcdFx0XHRcdFx0XHRpZihzX2NhbGwpIHsgc19jYWxsLmNhbGwodGhpcyk7IH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRpZihvYmogJiYgb2JqICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b2JqLmNoaWxkcmVuKFwiYS5qc3RyZWUtbG9hZGluZ1wiKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1sb2FkaW5nXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0b2JqLnJlbW92ZURhdGEoXCJqc3RyZWVfaXNfbG9hZGluZ1wiKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHMuY29ycmVjdF9zdGF0ZSkgeyBcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5jb3JyZWN0X3N0YXRlKG9iaik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHNfY2FsbCkgeyBzX2NhbGwuY2FsbCh0aGlzKTsgfSBcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihzLmNvcnJlY3Rfc3RhdGUpIHsgXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpLmNoaWxkcmVuKFwidWxcIikuZW1wdHkoKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoc19jYWxsKSB7IHNfY2FsbC5jYWxsKHRoaXMpOyB9IFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHMuYWpheC5jb250ZXh0ID0gdGhpcztcblx0XHRcdFx0XHRcdHMuYWpheC5lcnJvciA9IGVycm9yX2Z1bmM7XG5cdFx0XHRcdFx0XHRzLmFqYXguc3VjY2VzcyA9IHN1Y2Nlc3NfZnVuYztcblx0XHRcdFx0XHRcdGlmKCFzLmFqYXguZGF0YVR5cGUpIHsgcy5hamF4LmRhdGFUeXBlID0gXCJodG1sXCI7IH1cblx0XHRcdFx0XHRcdGlmKCQuaXNGdW5jdGlvbihzLmFqYXgudXJsKSkgeyBzLmFqYXgudXJsID0gcy5hamF4LnVybC5jYWxsKHRoaXMsIG9iaik7IH1cblx0XHRcdFx0XHRcdGlmKCQuaXNGdW5jdGlvbihzLmFqYXguZGF0YSkpIHsgcy5hamF4LmRhdGEgPSBzLmFqYXguZGF0YS5jYWxsKHRoaXMsIG9iaik7IH1cblx0XHRcdFx0XHRcdCQuYWpheChzLmFqYXgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXHQvLyBpbmNsdWRlIHRoZSBIVE1MIGRhdGEgcGx1Z2luIGJ5IGRlZmF1bHRcblx0JC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFwiaHRtbF9kYXRhXCIpO1xufSkoalF1ZXJ5KTtcbi8vKi9cblxuLyogXG4gKiBqc1RyZWUgdGhlbWVyb2xsZXIgcGx1Z2luXG4gKiBBZGRzIHN1cHBvcnQgZm9yIGpRdWVyeSBVSSB0aGVtZXMuIEluY2x1ZGUgdGhpcyBhdCB0aGUgZW5kIG9mIHlvdXIgcGx1Z2lucyBsaXN0LCBhbHNvIG1ha2Ugc3VyZSBcInRoZW1lc1wiIGlzIG5vdCBpbmNsdWRlZC5cbiAqL1xuKGZ1bmN0aW9uICgkKSB7XG5cdCQuanN0cmVlLnBsdWdpbihcInRoZW1lcm9sbGVyXCIsIHtcblx0XHRfX2luaXQgOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgcyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLnRoZW1lcm9sbGVyO1xuXHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKClcblx0XHRcdFx0LmFkZENsYXNzKFwidWktd2lkZ2V0LWNvbnRlbnRcIilcblx0XHRcdFx0LmFkZENsYXNzKFwianN0cmVlLXRoZW1lcm9sbGVyXCIpXG5cdFx0XHRcdC5kZWxlZ2F0ZShcImFcIixcIm1vdXNlZW50ZXIuanN0cmVlXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0aWYoISQoZS5jdXJyZW50VGFyZ2V0KS5oYXNDbGFzcyhcImpzdHJlZS1sb2FkaW5nXCIpKSB7XG5cdFx0XHRcdFx0XHQkKHRoaXMpLmFkZENsYXNzKHMuaXRlbV9oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5kZWxlZ2F0ZShcImFcIixcIm1vdXNlbGVhdmUuanN0cmVlXCIsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQkKHRoaXMpLnJlbW92ZUNsYXNzKHMuaXRlbV9oKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LmJpbmQoXCJpbml0LmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7IFxuXHRcdFx0XHRcdFx0ZGF0YS5pbnN0LmdldF9jb250YWluZXIoKS5maW5kKFwiPiB1bCA+IGxpID4gLmpzdHJlZS1sb2FkaW5nID4gaW5zXCIpLmFkZENsYXNzKFwidWktaWNvbi1yZWZyZXNoXCIpO1xuXHRcdFx0XHRcdFx0dGhpcy5fdGhlbWVyb2xsZXIoZGF0YS5pbnN0LmdldF9jb250YWluZXIoKS5maW5kKFwiPiB1bCA+IGxpXCIpKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJvcGVuX25vZGUuanN0cmVlIGNyZWF0ZV9ub2RlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7IFxuXHRcdFx0XHRcdFx0dGhpcy5fdGhlbWVyb2xsZXIoZGF0YS5yc2x0Lm9iaik7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwibG9hZGVkLmpzdHJlZSByZWZyZXNoLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90aGVtZXJvbGxlcigpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuYmluZChcImNsb3NlX25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RoZW1lcm9sbGVyKGRhdGEucnNsdC5vYmopO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuYmluZChcImRlbGV0ZV9ub2RlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90aGVtZXJvbGxlcihkYXRhLnJzbHQucGFyZW50KTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJjb3JyZWN0X3N0YXRlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRkYXRhLnJzbHQub2JqXG5cdFx0XHRcdFx0XHRcdC5jaGlsZHJlbihcImlucy5qc3RyZWUtaWNvblwiKS5yZW1vdmVDbGFzcyhzLm9wZW5lZCArIFwiIFwiICsgcy5jbG9zZWQgKyBcIiB1aS1pY29uXCIpLmVuZCgpXG5cdFx0XHRcdFx0XHRcdC5maW5kKFwiPiBhID4gaW5zLnVpLWljb25cIilcblx0XHRcdFx0XHRcdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkgeyBcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmNsYXNzTmFtZS50b1N0cmluZygpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKHMuaXRlbV9jbHNkLFwiXCIpLnJlcGxhY2Uocy5pdGVtX29wZW4sXCJcIikucmVwbGFjZShzLml0ZW1fbGVhZixcIlwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuaW5kZXhPZihcInVpLWljb24tXCIpID09PSAtMTsgXG5cdFx0XHRcdFx0XHRcdFx0fSkucmVtb3ZlQ2xhc3Mocy5pdGVtX29wZW4gKyBcIiBcIiArIHMuaXRlbV9jbHNkKS5hZGRDbGFzcyhzLml0ZW1fbGVhZiB8fCBcImpzdHJlZS1uby1pY29uXCIpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuYmluZChcInNlbGVjdF9ub2RlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRkYXRhLnJzbHQub2JqLmNoaWxkcmVuKFwiYVwiKS5hZGRDbGFzcyhzLml0ZW1fYSk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwiZGVzZWxlY3Rfbm9kZS5qc3RyZWUgZGVzZWxlY3RfYWxsLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmdldF9jb250YWluZXIoKVxuXHRcdFx0XHRcdFx0XHQuZmluZChcImEuXCIgKyBzLml0ZW1fYSkucmVtb3ZlQ2xhc3Mocy5pdGVtX2EpLmVuZCgpXG5cdFx0XHRcdFx0XHRcdC5maW5kKFwiYS5qc3RyZWUtY2xpY2tlZFwiKS5hZGRDbGFzcyhzLml0ZW1fYSk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwiZGVob3Zlcl9ub2RlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRkYXRhLnJzbHQub2JqLmNoaWxkcmVuKFwiYVwiKS5yZW1vdmVDbGFzcyhzLml0ZW1faCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwiaG92ZXJfbm9kZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xuXHRcdFx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKClcblx0XHRcdFx0XHRcdFx0LmZpbmQoXCJhLlwiICsgcy5pdGVtX2gpLm5vdChkYXRhLnJzbHQub2JqKS5yZW1vdmVDbGFzcyhzLml0ZW1faCk7XG5cdFx0XHRcdFx0XHRkYXRhLnJzbHQub2JqLmNoaWxkcmVuKFwiYVwiKS5hZGRDbGFzcyhzLml0ZW1faCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwibW92ZV9ub2RlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90aGVtZXJvbGxlcihkYXRhLnJzbHQubyk7XG5cdFx0XHRcdFx0XHR0aGlzLl90aGVtZXJvbGxlcihkYXRhLnJzbHQub3ApO1xuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHR9LFxuXHRcdF9fZGVzdHJveSA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzID0gdGhpcy5fZ2V0X3NldHRpbmdzKCkudGhlbWVyb2xsZXIsXG5cdFx0XHRcdGMgPSBbIFwidWktaWNvblwiIF07XG5cdFx0XHQkLmVhY2gocywgZnVuY3Rpb24gKGksIHYpIHtcblx0XHRcdFx0diA9IHYuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRpZih2Lmxlbmd0aCkgeyBjID0gYy5jb25jYXQodik7IH1cblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKClcblx0XHRcdFx0LnJlbW92ZUNsYXNzKFwidWktd2lkZ2V0LWNvbnRlbnRcIilcblx0XHRcdFx0LmZpbmQoXCIuXCIgKyBjLmpvaW4oXCIsIC5cIikpLnJlbW92ZUNsYXNzKGMuam9pbihcIiBcIikpO1xuXHRcdH0sXG5cdFx0X2ZuIDoge1xuXHRcdFx0X3RoZW1lcm9sbGVyIDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHR2YXIgcyA9IHRoaXMuX2dldF9zZXR0aW5ncygpLnRoZW1lcm9sbGVyO1xuXHRcdFx0XHRvYmogPSAoIW9iaiB8fCBvYmogPT0gLTEpID8gdGhpcy5nZXRfY29udGFpbmVyX3VsKCkgOiB0aGlzLl9nZXRfbm9kZShvYmopO1xuXHRcdFx0XHRvYmogPSAoIW9iaiB8fCBvYmogPT0gLTEpID8gdGhpcy5nZXRfY29udGFpbmVyX3VsKCkgOiBvYmoucGFyZW50KCk7XG5cdFx0XHRcdG9ialxuXHRcdFx0XHRcdC5maW5kKFwibGkuanN0cmVlLWNsb3NlZFwiKVxuXHRcdFx0XHRcdFx0LmNoaWxkcmVuKFwiaW5zLmpzdHJlZS1pY29uXCIpLnJlbW92ZUNsYXNzKHMub3BlbmVkKS5hZGRDbGFzcyhcInVpLWljb24gXCIgKyBzLmNsb3NlZCkuZW5kKClcblx0XHRcdFx0XHRcdC5jaGlsZHJlbihcImFcIikuYWRkQ2xhc3Mocy5pdGVtKVxuXHRcdFx0XHRcdFx0XHQuY2hpbGRyZW4oXCJpbnMuanN0cmVlLWljb25cIikuYWRkQ2xhc3MoXCJ1aS1pY29uXCIpXG5cdFx0XHRcdFx0XHRcdFx0LmZpbHRlcihmdW5jdGlvbigpIHsgXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5jbGFzc05hbWUudG9TdHJpbmcoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZShzLml0ZW1fY2xzZCxcIlwiKS5yZXBsYWNlKHMuaXRlbV9vcGVuLFwiXCIpLnJlcGxhY2Uocy5pdGVtX2xlYWYsXCJcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmluZGV4T2YoXCJ1aS1pY29uLVwiKSA9PT0gLTE7IFxuXHRcdFx0XHRcdFx0XHRcdH0pLnJlbW92ZUNsYXNzKHMuaXRlbV9sZWFmICsgXCIgXCIgKyBzLml0ZW1fb3BlbikuYWRkQ2xhc3Mocy5pdGVtX2Nsc2QgfHwgXCJqc3RyZWUtbm8taWNvblwiKVxuXHRcdFx0XHRcdFx0XHRcdC5lbmQoKVxuXHRcdFx0XHRcdFx0XHQuZW5kKClcblx0XHRcdFx0XHRcdC5lbmQoKVxuXHRcdFx0XHRcdC5lbmQoKVxuXHRcdFx0XHRcdC5maW5kKFwibGkuanN0cmVlLW9wZW5cIilcblx0XHRcdFx0XHRcdC5jaGlsZHJlbihcImlucy5qc3RyZWUtaWNvblwiKS5yZW1vdmVDbGFzcyhzLmNsb3NlZCkuYWRkQ2xhc3MoXCJ1aS1pY29uIFwiICsgcy5vcGVuZWQpLmVuZCgpXG5cdFx0XHRcdFx0XHQuY2hpbGRyZW4oXCJhXCIpLmFkZENsYXNzKHMuaXRlbSlcblx0XHRcdFx0XHRcdFx0LmNoaWxkcmVuKFwiaW5zLmpzdHJlZS1pY29uXCIpLmFkZENsYXNzKFwidWktaWNvblwiKVxuXHRcdFx0XHRcdFx0XHRcdC5maWx0ZXIoZnVuY3Rpb24oKSB7IFxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY2xhc3NOYW1lLnRvU3RyaW5nKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2Uocy5pdGVtX2Nsc2QsXCJcIikucmVwbGFjZShzLml0ZW1fb3BlbixcIlwiKS5yZXBsYWNlKHMuaXRlbV9sZWFmLFwiXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5pbmRleE9mKFwidWktaWNvbi1cIikgPT09IC0xOyBcblx0XHRcdFx0XHRcdFx0XHR9KS5yZW1vdmVDbGFzcyhzLml0ZW1fbGVhZiArIFwiIFwiICsgcy5pdGVtX2Nsc2QpLmFkZENsYXNzKHMuaXRlbV9vcGVuIHx8IFwianN0cmVlLW5vLWljb25cIilcblx0XHRcdFx0XHRcdFx0XHQuZW5kKClcblx0XHRcdFx0XHRcdFx0LmVuZCgpXG5cdFx0XHRcdFx0XHQuZW5kKClcblx0XHRcdFx0XHQuZW5kKClcblx0XHRcdFx0XHQuZmluZChcImxpLmpzdHJlZS1sZWFmXCIpXG5cdFx0XHRcdFx0XHQuY2hpbGRyZW4oXCJpbnMuanN0cmVlLWljb25cIikucmVtb3ZlQ2xhc3Mocy5jbG9zZWQgKyBcIiB1aS1pY29uIFwiICsgcy5vcGVuZWQpLmVuZCgpXG5cdFx0XHRcdFx0XHQuY2hpbGRyZW4oXCJhXCIpLmFkZENsYXNzKHMuaXRlbSlcblx0XHRcdFx0XHRcdFx0LmNoaWxkcmVuKFwiaW5zLmpzdHJlZS1pY29uXCIpLmFkZENsYXNzKFwidWktaWNvblwiKVxuXHRcdFx0XHRcdFx0XHRcdC5maWx0ZXIoZnVuY3Rpb24oKSB7IFxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY2xhc3NOYW1lLnRvU3RyaW5nKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2Uocy5pdGVtX2Nsc2QsXCJcIikucmVwbGFjZShzLml0ZW1fb3BlbixcIlwiKS5yZXBsYWNlKHMuaXRlbV9sZWFmLFwiXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5pbmRleE9mKFwidWktaWNvbi1cIikgPT09IC0xOyBcblx0XHRcdFx0XHRcdFx0XHR9KS5yZW1vdmVDbGFzcyhzLml0ZW1fY2xzZCArIFwiIFwiICsgcy5pdGVtX29wZW4pLmFkZENsYXNzKHMuaXRlbV9sZWFmIHx8IFwianN0cmVlLW5vLWljb25cIik7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkZWZhdWx0cyA6IHtcblx0XHRcdFwib3BlbmVkXCJcdDogXCJ1aS1pY29uLXRyaWFuZ2xlLTEtc2VcIixcblx0XHRcdFwiY2xvc2VkXCJcdDogXCJ1aS1pY29uLXRyaWFuZ2xlLTEtZVwiLFxuXHRcdFx0XCJpdGVtXCJcdFx0OiBcInVpLXN0YXRlLWRlZmF1bHRcIixcblx0XHRcdFwiaXRlbV9oXCJcdDogXCJ1aS1zdGF0ZS1ob3ZlclwiLFxuXHRcdFx0XCJpdGVtX2FcIlx0OiBcInVpLXN0YXRlLWFjdGl2ZVwiLFxuXHRcdFx0XCJpdGVtX29wZW5cIlx0OiBcInVpLWljb24tZm9sZGVyLW9wZW5cIixcblx0XHRcdFwiaXRlbV9jbHNkXCJcdDogXCJ1aS1pY29uLWZvbGRlci1jb2xsYXBzZWRcIixcblx0XHRcdFwiaXRlbV9sZWFmXCJcdDogXCJ1aS1pY29uLWRvY3VtZW50XCJcblx0XHR9XG5cdH0pO1xuXHQkKGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjc3Nfc3RyaW5nID0gJycgKyBcblx0XHRcdCcuanN0cmVlLXRoZW1lcm9sbGVyIC51aS1pY29uIHsgb3ZlcmZsb3c6dmlzaWJsZTsgfSAnICsgXG5cdFx0XHQnLmpzdHJlZS10aGVtZXJvbGxlciBhIHsgcGFkZGluZzowIDJweDsgfSAnICsgXG5cdFx0XHQnLmpzdHJlZS10aGVtZXJvbGxlciAuanN0cmVlLW5vLWljb24geyBkaXNwbGF5Om5vbmU7IH0nO1xuXHRcdCQudmFrYXRhLmNzcy5hZGRfc2hlZXQoeyBzdHIgOiBjc3Nfc3RyaW5nLCB0aXRsZSA6IFwianN0cmVlXCIgfSk7XG5cdH0pO1xufSkoalF1ZXJ5KTtcbi8vKi9cblxuLyogXG4gKiBqc1RyZWUgdW5pcXVlIHBsdWdpblxuICogRm9yY2VzIGRpZmZlcmVudCBuYW1lcyBhbW9uZ3N0IHNpYmxpbmdzIChzdGlsbCBhIGJpdCBleHBlcmltZW50YWwpXG4gKiBOT1RFOiBkb2VzIG5vdCBjaGVjayBsYW5ndWFnZSB2ZXJzaW9ucyAoaXQgd2lsbCBub3QgYmUgcG9zc2libGUgdG8gaGF2ZSBub2RlcyB3aXRoIHRoZSBzYW1lIHRpdGxlLCBldmVuIGluIGRpZmZlcmVudCBsYW5ndWFnZXMpXG4gKi9cbihmdW5jdGlvbiAoJCkge1xuXHQkLmpzdHJlZS5wbHVnaW4oXCJ1bmlxdWVcIiwge1xuXHRcdF9faW5pdCA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpXG5cdFx0XHRcdC5iaW5kKFwiYmVmb3JlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7IFxuXHRcdFx0XHRcdFx0dmFyIG5tcyA9IFtdLCByZXMgPSB0cnVlLCBwLCB0O1xuXHRcdFx0XHRcdFx0aWYoZGF0YS5mdW5jID09IFwibW92ZV9ub2RlXCIpIHtcblx0XHRcdFx0XHRcdFx0Ly8gb2JqLCByZWYsIHBvc2l0aW9uLCBpc19jb3B5LCBpc19wcmVwYXJlZCwgc2tpcF9jaGVja1xuXHRcdFx0XHRcdFx0XHRpZihkYXRhLmFyZ3NbNF0gPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0XHRpZihkYXRhLmFyZ3NbMF0ubyAmJiBkYXRhLmFyZ3NbMF0uby5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGEuYXJnc1swXS5vLmNoaWxkcmVuKFwiYVwiKS5lYWNoKGZ1bmN0aW9uICgpIHsgbm1zLnB1c2goJCh0aGlzKS50ZXh0KCkucmVwbGFjZSgvXlxccysvZyxcIlwiKSk7IH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzID0gdGhpcy5fY2hlY2tfdW5pcXVlKG5tcywgZGF0YS5hcmdzWzBdLm5wLmZpbmQoXCI+IHVsID4gbGlcIikubm90KGRhdGEuYXJnc1swXS5vKSwgXCJtb3ZlX25vZGVcIik7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihkYXRhLmZ1bmMgPT0gXCJjcmVhdGVfbm9kZVwiKSB7XG5cdFx0XHRcdFx0XHRcdC8vIG9iaiwgcG9zaXRpb24sIGpzLCBjYWxsYmFjaywgaXNfbG9hZGVkXG5cdFx0XHRcdFx0XHRcdGlmKGRhdGEuYXJnc1s0XSB8fCB0aGlzLl9pc19sb2FkZWQoZGF0YS5hcmdzWzBdKSkge1xuXHRcdFx0XHRcdFx0XHRcdHAgPSB0aGlzLl9nZXRfbm9kZShkYXRhLmFyZ3NbMF0pO1xuXHRcdFx0XHRcdFx0XHRcdGlmKGRhdGEuYXJnc1sxXSAmJiAoZGF0YS5hcmdzWzFdID09PSBcImJlZm9yZVwiIHx8IGRhdGEuYXJnc1sxXSA9PT0gXCJhZnRlclwiKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cCA9IHRoaXMuX2dldF9wYXJlbnQoZGF0YS5hcmdzWzBdKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCFwIHx8IHAgPT09IC0xKSB7IHAgPSB0aGlzLmdldF9jb250YWluZXIoKTsgfVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZih0eXBlb2YgZGF0YS5hcmdzWzJdID09PSBcInN0cmluZ1wiKSB7IG5tcy5wdXNoKGRhdGEuYXJnc1syXSk7IH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlIGlmKCFkYXRhLmFyZ3NbMl0gfHwgIWRhdGEuYXJnc1syXS5kYXRhKSB7IG5tcy5wdXNoKHRoaXMuX2dldF9zdHJpbmcoXCJuZXdfbm9kZVwiKSk7IH1cblx0XHRcdFx0XHRcdFx0XHRlbHNlIHsgbm1zLnB1c2goZGF0YS5hcmdzWzJdLmRhdGEpOyB9XG5cdFx0XHRcdFx0XHRcdFx0cmVzID0gdGhpcy5fY2hlY2tfdW5pcXVlKG5tcywgcC5maW5kKFwiPiB1bCA+IGxpXCIpLCBcImNyZWF0ZV9ub2RlXCIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihkYXRhLmZ1bmMgPT0gXCJyZW5hbWVfbm9kZVwiKSB7XG5cdFx0XHRcdFx0XHRcdC8vIG9iaiwgdmFsXG5cdFx0XHRcdFx0XHRcdG5tcy5wdXNoKGRhdGEuYXJnc1sxXSk7XG5cdFx0XHRcdFx0XHRcdHQgPSB0aGlzLl9nZXRfbm9kZShkYXRhLmFyZ3NbMF0pO1xuXHRcdFx0XHRcdFx0XHRwID0gdGhpcy5fZ2V0X3BhcmVudCh0KTtcblx0XHRcdFx0XHRcdFx0aWYoIXAgfHwgcCA9PT0gLTEpIHsgcCA9IHRoaXMuZ2V0X2NvbnRhaW5lcigpOyB9XG5cdFx0XHRcdFx0XHRcdHJlcyA9IHRoaXMuX2NoZWNrX3VuaXF1ZShubXMsIHAuZmluZChcIj4gdWwgPiBsaVwiKS5ub3QodCksIFwicmVuYW1lX25vZGVcIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZighcmVzKSB7XG5cdFx0XHRcdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0fSxcblx0XHRkZWZhdWx0cyA6IHsgXG5cdFx0XHRlcnJvcl9jYWxsYmFjayA6ICQubm9vcFxuXHRcdH0sXG5cdFx0X2ZuIDogeyBcblx0XHRcdF9jaGVja191bmlxdWUgOiBmdW5jdGlvbiAobm1zLCBwLCBmdW5jKSB7XG5cdFx0XHRcdHZhciBjbm1zID0gW10sIG9rID0gdHJ1ZTtcblx0XHRcdFx0cC5jaGlsZHJlbihcImFcIikuZWFjaChmdW5jdGlvbiAoKSB7IGNubXMucHVzaCgkKHRoaXMpLnRleHQoKS5yZXBsYWNlKC9eXFxzKy9nLFwiXCIpKTsgfSk7XG5cdFx0XHRcdGlmKCFjbm1zLmxlbmd0aCB8fCAhbm1zLmxlbmd0aCkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdFx0XHQkLmVhY2gobm1zLCBmdW5jdGlvbiAoaSwgdikge1xuXHRcdFx0XHRcdGlmKCQuaW5BcnJheSh2LCBjbm1zKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdG9rID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYoIW9rKSB7XG5cdFx0XHRcdFx0dGhpcy5fZ2V0X3NldHRpbmdzKCkudW5pcXVlLmVycm9yX2NhbGxiYWNrLmNhbGwobnVsbCwgbm1zLCBwLCBmdW5jKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb2s7XG5cdFx0XHR9LFxuXHRcdFx0Y2hlY2tfbW92ZSA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYoIXRoaXMuX19jYWxsX29sZCgpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHR2YXIgcCA9IHRoaXMuX2dldF9tb3ZlKCksIG5tcyA9IFtdO1xuXHRcdFx0XHRpZihwLm8gJiYgcC5vLmxlbmd0aCkge1xuXHRcdFx0XHRcdHAuby5jaGlsZHJlbihcImFcIikuZWFjaChmdW5jdGlvbiAoKSB7IG5tcy5wdXNoKCQodGhpcykudGV4dCgpLnJlcGxhY2UoL15cXHMrL2csXCJcIikpOyB9KTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fY2hlY2tfdW5pcXVlKG5tcywgcC5ucC5maW5kKFwiPiB1bCA+IGxpXCIpLm5vdChwLm8pLCBcImNoZWNrX21vdmVcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn0pKGpRdWVyeSk7XG4vLyovXG5cbi8qXG4gKiBqc1RyZWUgd2hvbGVyb3cgcGx1Z2luXG4gKiBNYWtlcyBzZWxlY3QgYW5kIGhvdmVyIHdvcmsgb24gdGhlIGVudGlyZSB3aWR0aCBvZiB0aGUgbm9kZVxuICogTUFZIEJFIEhFQVZZIElOIExBUkdFIERPTVxuICovXG4oZnVuY3Rpb24gKCQpIHtcblx0JC5qc3RyZWUucGx1Z2luKFwid2hvbGVyb3dcIiwge1xuXHRcdF9faW5pdCA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmKCF0aGlzLmRhdGEudWkpIHsgdGhyb3cgXCJqc1RyZWUgd2hvbGVyb3c6IGpzVHJlZSBVSSBwbHVnaW4gbm90IGluY2x1ZGVkLlwiOyB9XG5cdFx0XHR0aGlzLmRhdGEud2hvbGVyb3cuaHRtbCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5kYXRhLndob2xlcm93LnRvID0gZmFsc2U7XG5cdFx0XHR0aGlzLmdldF9jb250YWluZXIoKVxuXHRcdFx0XHQuYmluZChcImluaXQuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHsgXG5cdFx0XHRcdFx0XHR0aGlzLl9nZXRfc2V0dGluZ3MoKS5jb3JlLmFuaW1hdGlvbiA9IDA7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwib3Blbl9ub2RlLmpzdHJlZSBjcmVhdGVfbm9kZS5qc3RyZWUgY2xlYW5fbm9kZS5qc3RyZWUgbG9hZGVkLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7IFxuXHRcdFx0XHRcdFx0dGhpcy5fcHJlcGFyZV93aG9sZXJvd19zcGFuKCBkYXRhICYmIGRhdGEucnNsdCAmJiBkYXRhLnJzbHQub2JqID8gZGF0YS5yc2x0Lm9iaiA6IC0xICk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwic2VhcmNoLmpzdHJlZSBjbGVhcl9zZWFyY2guanN0cmVlIHJlb3Blbi5qc3RyZWUgYWZ0ZXJfb3Blbi5qc3RyZWUgYWZ0ZXJfY2xvc2UuanN0cmVlIGNyZWF0ZV9ub2RlLmpzdHJlZSBkZWxldGVfbm9kZS5qc3RyZWUgY2xlYW5fbm9kZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkgeyBcblx0XHRcdFx0XHRcdGlmKHRoaXMuZGF0YS50bykgeyBjbGVhclRpbWVvdXQodGhpcy5kYXRhLnRvKTsgfVxuXHRcdFx0XHRcdFx0dGhpcy5kYXRhLnRvID0gc2V0VGltZW91dCggKGZ1bmN0aW9uICh0LCBvKSB7IHJldHVybiBmdW5jdGlvbigpIHsgdC5fcHJlcGFyZV93aG9sZXJvd191bChvKTsgfTsgfSkodGhpcywgIGRhdGEgJiYgZGF0YS5yc2x0ICYmIGRhdGEucnNsdC5vYmogPyBkYXRhLnJzbHQub2JqIDogLTEpLCAwKTtcblx0XHRcdFx0XHR9LCB0aGlzKSlcblx0XHRcdFx0LmJpbmQoXCJkZXNlbGVjdF9hbGwuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHsgXG5cdFx0XHRcdFx0XHR0aGlzLmdldF9jb250YWluZXIoKS5maW5kKFwiID4gLmpzdHJlZS13aG9sZXJvdyAuanN0cmVlLWNsaWNrZWRcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtY2xpY2tlZCBcIiArICh0aGlzLmRhdGEudGhlbWVyb2xsZXIgPyB0aGlzLl9nZXRfc2V0dGluZ3MoKS50aGVtZXJvbGxlci5pdGVtX2EgOiBcIlwiICkpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuYmluZChcInNlbGVjdF9ub2RlLmpzdHJlZSBkZXNlbGVjdF9ub2RlLmpzdHJlZSBcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkgeyBcblx0XHRcdFx0XHRcdGRhdGEucnNsdC5vYmouZWFjaChmdW5jdGlvbiAoKSB7IFxuXHRcdFx0XHRcdFx0XHR2YXIgcmVmID0gZGF0YS5pbnN0LmdldF9jb250YWluZXIoKS5maW5kKFwiID4gLmpzdHJlZS13aG9sZXJvdyBsaTp2aXNpYmxlOmVxKFwiICsgKCBwYXJzZUludCgoKCQodGhpcykub2Zmc2V0KCkudG9wIC0gZGF0YS5pbnN0LmdldF9jb250YWluZXIoKS5vZmZzZXQoKS50b3AgKyBkYXRhLmluc3QuZ2V0X2NvbnRhaW5lcigpWzBdLnNjcm9sbFRvcCkgLyBkYXRhLmluc3QuZGF0YS5jb3JlLmxpX2hlaWdodCksMTApKSArIFwiKVwiKTtcblx0XHRcdFx0XHRcdFx0Ly8gcmVmLmNoaWxkcmVuKFwiYVwiKVtlLnR5cGUgPT09IFwic2VsZWN0X25vZGVcIiA/IFwiYWRkQ2xhc3NcIiA6IFwicmVtb3ZlQ2xhc3NcIl0oXCJqc3RyZWUtY2xpY2tlZFwiKTtcblx0XHRcdFx0XHRcdFx0cmVmLmNoaWxkcmVuKFwiYVwiKS5hdHRyKFwiY2xhc3NcIixkYXRhLnJzbHQub2JqLmNoaWxkcmVuKFwiYVwiKS5hdHRyKFwiY2xhc3NcIikpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5iaW5kKFwiaG92ZXJfbm9kZS5qc3RyZWUgZGVob3Zlcl9ub2RlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7IFxuXHRcdFx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkuZmluZChcIiA+IC5qc3RyZWUtd2hvbGVyb3cgLmpzdHJlZS1ob3ZlcmVkXCIpLnJlbW92ZUNsYXNzKFwianN0cmVlLWhvdmVyZWQgXCIgKyAodGhpcy5kYXRhLnRoZW1lcm9sbGVyID8gdGhpcy5fZ2V0X3NldHRpbmdzKCkudGhlbWVyb2xsZXIuaXRlbV9oIDogXCJcIiApKTtcblx0XHRcdFx0XHRcdGlmKGUudHlwZSA9PT0gXCJob3Zlcl9ub2RlXCIpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHJlZiA9IHRoaXMuZ2V0X2NvbnRhaW5lcigpLmZpbmQoXCIgPiAuanN0cmVlLXdob2xlcm93IGxpOnZpc2libGU6ZXEoXCIgKyAoIHBhcnNlSW50KCgoZGF0YS5yc2x0Lm9iai5vZmZzZXQoKS50b3AgLSB0aGlzLmdldF9jb250YWluZXIoKS5vZmZzZXQoKS50b3AgKyB0aGlzLmdldF9jb250YWluZXIoKVswXS5zY3JvbGxUb3ApIC8gdGhpcy5kYXRhLmNvcmUubGlfaGVpZ2h0KSwxMCkpICsgXCIpXCIpO1xuXHRcdFx0XHRcdFx0XHQvLyByZWYuY2hpbGRyZW4oXCJhXCIpLmFkZENsYXNzKFwianN0cmVlLWhvdmVyZWRcIik7XG5cdFx0XHRcdFx0XHRcdHJlZi5jaGlsZHJlbihcImFcIikuYXR0cihcImNsYXNzXCIsZGF0YS5yc2x0Lm9iai5jaGlsZHJlbihcIi5qc3RyZWUtaG92ZXJlZFwiKS5hdHRyKFwiY2xhc3NcIikpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0XHQuZGVsZWdhdGUoXCIuanN0cmVlLXdob2xlcm93LXNwYW4sIGlucy5qc3RyZWUtaWNvbiwgbGlcIiwgXCJjbGljay5qc3RyZWVcIiwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHRcdHZhciBuID0gJChlLmN1cnJlbnRUYXJnZXQpO1xuXHRcdFx0XHRcdFx0aWYoZS50YXJnZXQudGFnTmFtZSA9PT0gXCJBXCIgfHwgKGUudGFyZ2V0LnRhZ05hbWUgPT09IFwiSU5TXCIgJiYgbi5jbG9zZXN0KFwibGlcIikuaXMoXCIuanN0cmVlLW9wZW4sIC5qc3RyZWUtY2xvc2VkXCIpKSkgeyByZXR1cm47IH1cblx0XHRcdFx0XHRcdG4uY2xvc2VzdChcImxpXCIpLmNoaWxkcmVuKFwiYTp2aXNpYmxlOmVxKDApXCIpLmNsaWNrKCk7XG5cdFx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdC5kZWxlZ2F0ZShcImxpXCIsIFwibW91c2VvdmVyLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0aWYoJChlLmN1cnJlbnRUYXJnZXQpLmNoaWxkcmVuKFwiLmpzdHJlZS1ob3ZlcmVkLCAuanN0cmVlLWNsaWNrZWRcIikubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRcdFx0dGhpcy5ob3Zlcl9ub2RlKGUuY3VycmVudFRhcmdldCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fSwgdGhpcykpXG5cdFx0XHRcdC5kZWxlZ2F0ZShcImxpXCIsIFwibW91c2VsZWF2ZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0aWYoJChlLmN1cnJlbnRUYXJnZXQpLmNoaWxkcmVuKFwiYVwiKS5oYXNDbGFzcyhcImpzdHJlZS1ob3ZlcmVkXCIpLmxlbmd0aCkgeyByZXR1cm47IH1cblx0XHRcdFx0XHRcdHRoaXMuZGVob3Zlcl9ub2RlKGUuY3VycmVudFRhcmdldCk7XG5cdFx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0aWYoaXNfaWU3IHx8IGlzX2llNikge1xuXHRcdFx0XHQkLnZha2F0YS5jc3MuYWRkX3NoZWV0KHsgc3RyIDogXCIuanN0cmVlLVwiICsgdGhpcy5nZXRfaW5kZXgoKSArIFwiIHsgcG9zaXRpb246cmVsYXRpdmU7IH0gXCIsIHRpdGxlIDogXCJqc3RyZWVcIiB9KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRlZmF1bHRzIDoge1xuXHRcdH0sXG5cdFx0X19kZXN0cm95IDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCIuanN0cmVlLXdob2xlcm93XCIpLnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkuZmluZChcIi5qc3RyZWUtd2hvbGVyb3ctc3BhblwiKS5yZW1vdmUoKTtcblx0XHR9LFxuXHRcdF9mbiA6IHtcblx0XHRcdF9wcmVwYXJlX3dob2xlcm93X3NwYW4gOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdG9iaiA9ICFvYmogfHwgb2JqID09IC0xID8gdGhpcy5nZXRfY29udGFpbmVyKCkuZmluZChcIj4gdWwgPiBsaVwiKSA6IHRoaXMuX2dldF9ub2RlKG9iaik7XG5cdFx0XHRcdGlmKG9iaiA9PT0gZmFsc2UpIHsgcmV0dXJuOyB9IC8vIGFkZGVkIGZvciByZW1vdmluZyByb290IG5vZGVzXG5cdFx0XHRcdG9iai5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQkKHRoaXMpLmZpbmQoXCJsaVwiKS5hbmRTZWxmKCkuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHR2YXIgJHQgPSAkKHRoaXMpO1xuXHRcdFx0XHRcdFx0aWYoJHQuY2hpbGRyZW4oXCIuanN0cmVlLXdob2xlcm93LXNwYW5cIikubGVuZ3RoKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0XHRcdFx0XHQkdC5wcmVwZW5kKFwiPHNwYW4gY2xhc3M9J2pzdHJlZS13aG9sZXJvdy1zcGFuJyBzdHlsZT0nd2lkdGg6XCIgKyAoJHQucGFyZW50c1VudGlsKFwiLmpzdHJlZVwiLFwibGlcIikubGVuZ3RoICogMTgpICsgXCJweDsnPiYjMTYwOzwvc3Bhbj5cIik7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdF9wcmVwYXJlX3dob2xlcm93X3VsIDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgbyA9IHRoaXMuZ2V0X2NvbnRhaW5lcigpLmNoaWxkcmVuKFwidWxcIikuZXEoMCksIGggPSBvLmh0bWwoKTtcblx0XHRcdFx0by5hZGRDbGFzcyhcImpzdHJlZS13aG9sZXJvdy1yZWFsXCIpO1xuXHRcdFx0XHRpZih0aGlzLmRhdGEud2hvbGVyb3cubGFzdF9odG1sICE9PSBoKSB7XG5cdFx0XHRcdFx0dGhpcy5kYXRhLndob2xlcm93Lmxhc3RfaHRtbCA9IGg7XG5cdFx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyKCkuY2hpbGRyZW4oXCIuanN0cmVlLXdob2xlcm93XCIpLnJlbW92ZSgpO1xuXHRcdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcigpLmFwcGVuZChcblx0XHRcdFx0XHRcdG8uY2xvbmUoKS5yZW1vdmVDbGFzcyhcImpzdHJlZS13aG9sZXJvdy1yZWFsXCIpXG5cdFx0XHRcdFx0XHRcdC53cmFwQWxsKFwiPGRpdiBjbGFzcz0nanN0cmVlLXdob2xlcm93JyAvPlwiKS5wYXJlbnQoKVxuXHRcdFx0XHRcdFx0XHQud2lkdGgoby5wYXJlbnQoKVswXS5zY3JvbGxXaWR0aClcblx0XHRcdFx0XHRcdFx0LmNzcyhcInRvcFwiLCAoby5oZWlnaHQoKSArICggaXNfaWU3ID8gNSA6IDApKSAqIC0xIClcblx0XHRcdFx0XHRcdFx0LmZpbmQoXCJsaVtpZF1cIikuZWFjaChmdW5jdGlvbiAoKSB7IHRoaXMucmVtb3ZlQXR0cmlidXRlKFwiaWRcIik7IH0pLmVuZCgpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdCQoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNzc19zdHJpbmcgPSAnJyArIFxuXHRcdFx0Jy5qc3RyZWUgLmpzdHJlZS13aG9sZXJvdy1yZWFsIHsgcG9zaXRpb246cmVsYXRpdmU7IHotaW5kZXg6MTsgfSAnICsgXG5cdFx0XHQnLmpzdHJlZSAuanN0cmVlLXdob2xlcm93LXJlYWwgbGkgeyBjdXJzb3I6cG9pbnRlcjsgfSAnICsgXG5cdFx0XHQnLmpzdHJlZSAuanN0cmVlLXdob2xlcm93LXJlYWwgYSB7IGJvcmRlci1sZWZ0LWNvbG9yOnRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7IGJvcmRlci1yaWdodC1jb2xvcjp0cmFuc3BhcmVudCAhaW1wb3J0YW50OyB9ICcgKyBcblx0XHRcdCcuanN0cmVlIC5qc3RyZWUtd2hvbGVyb3cgeyBwb3NpdGlvbjpyZWxhdGl2ZTsgei1pbmRleDowOyBoZWlnaHQ6MDsgfSAnICsgXG5cdFx0XHQnLmpzdHJlZSAuanN0cmVlLXdob2xlcm93IHVsLCAuanN0cmVlIC5qc3RyZWUtd2hvbGVyb3cgbGkgeyB3aWR0aDoxMDAlOyB9ICcgKyBcblx0XHRcdCcuanN0cmVlIC5qc3RyZWUtd2hvbGVyb3csIC5qc3RyZWUgLmpzdHJlZS13aG9sZXJvdyB1bCwgLmpzdHJlZSAuanN0cmVlLXdob2xlcm93IGxpLCAuanN0cmVlIC5qc3RyZWUtd2hvbGVyb3cgYSB7IG1hcmdpbjowICFpbXBvcnRhbnQ7IHBhZGRpbmc6MCAhaW1wb3J0YW50OyB9ICcgKyBcblx0XHRcdCcuanN0cmVlIC5qc3RyZWUtd2hvbGVyb3csIC5qc3RyZWUgLmpzdHJlZS13aG9sZXJvdyB1bCwgLmpzdHJlZSAuanN0cmVlLXdob2xlcm93IGxpIHsgYmFja2dyb3VuZDp0cmFuc3BhcmVudCAhaW1wb3J0YW50OyB9JyArIFxuXHRcdFx0Jy5qc3RyZWUgLmpzdHJlZS13aG9sZXJvdyBpbnMsIC5qc3RyZWUgLmpzdHJlZS13aG9sZXJvdyBzcGFuLCAuanN0cmVlIC5qc3RyZWUtd2hvbGVyb3cgaW5wdXQgeyBkaXNwbGF5Om5vbmUgIWltcG9ydGFudDsgfScgKyBcblx0XHRcdCcuanN0cmVlIC5qc3RyZWUtd2hvbGVyb3cgYSwgLmpzdHJlZSAuanN0cmVlLXdob2xlcm93IGE6aG92ZXIgeyB0ZXh0LWluZGVudDotOTk5OXB4OyAhaW1wb3J0YW50OyB3aWR0aDoxMDAlOyBwYWRkaW5nOjAgIWltcG9ydGFudDsgYm9yZGVyLXJpZ2h0LXdpZHRoOjBweCAhaW1wb3J0YW50OyBib3JkZXItbGVmdC13aWR0aDowcHggIWltcG9ydGFudDsgfSAnICsgXG5cdFx0XHQnLmpzdHJlZSAuanN0cmVlLXdob2xlcm93LXNwYW4geyBwb3NpdGlvbjphYnNvbHV0ZTsgbGVmdDowOyBtYXJnaW46MHB4OyBwYWRkaW5nOjA7IGhlaWdodDoxOHB4OyBib3JkZXItd2lkdGg6MDsgcGFkZGluZzowOyB6LWluZGV4OjA7IH0nO1xuXHRcdGlmKGlzX2ZmMikge1xuXHRcdFx0Y3NzX3N0cmluZyArPSAnJyArIFxuXHRcdFx0XHQnLmpzdHJlZSAuanN0cmVlLXdob2xlcm93IGEgeyBkaXNwbGF5OmJsb2NrOyBoZWlnaHQ6MThweDsgbWFyZ2luOjA7IHBhZGRpbmc6MDsgYm9yZGVyOjA7IH0gJyArIFxuXHRcdFx0XHQnLmpzdHJlZSAuanN0cmVlLXdob2xlcm93LXJlYWwgYSB7IGJvcmRlci1jb2xvcjp0cmFuc3BhcmVudCAhaW1wb3J0YW50OyB9ICc7XG5cdFx0fVxuXHRcdGlmKGlzX2llNyB8fCBpc19pZTYpIHtcblx0XHRcdGNzc19zdHJpbmcgKz0gJycgKyBcblx0XHRcdFx0Jy5qc3RyZWUgLmpzdHJlZS13aG9sZXJvdywgLmpzdHJlZSAuanN0cmVlLXdob2xlcm93IGxpLCAuanN0cmVlIC5qc3RyZWUtd2hvbGVyb3cgdWwsIC5qc3RyZWUgLmpzdHJlZS13aG9sZXJvdyBhIHsgbWFyZ2luOjA7IHBhZGRpbmc6MDsgbGluZS1oZWlnaHQ6MThweDsgfSAnICsgXG5cdFx0XHRcdCcuanN0cmVlIC5qc3RyZWUtd2hvbGVyb3cgYSB7IGRpc3BsYXk6YmxvY2s7IGhlaWdodDoxOHB4OyBsaW5lLWhlaWdodDoxOHB4OyBvdmVyZmxvdzpoaWRkZW47IH0gJztcblx0XHR9XG5cdFx0JC52YWthdGEuY3NzLmFkZF9zaGVldCh7IHN0ciA6IGNzc19zdHJpbmcsIHRpdGxlIDogXCJqc3RyZWVcIiB9KTtcblx0fSk7XG59KShqUXVlcnkpO1xuLy8qL1xuXG4vKlxuKiBqc1RyZWUgbW9kZWwgcGx1Z2luXG4qIFRoaXMgcGx1Z2luIGdldHMganN0cmVlIHRvIHVzZSBhIGNsYXNzIG1vZGVsIHRvIHJldHJpZXZlIGRhdGEsIGNyZWF0aW5nIGdyZWF0IGR5bmFtaXNtXG4qL1xuKGZ1bmN0aW9uICgkKSB7XG5cdHZhciBub2RlSW50ZXJmYWNlID0gW1wiZ2V0Q2hpbGRyZW5cIixcImdldENoaWxkcmVuQ291bnRcIixcImdldEF0dHJcIixcImdldE5hbWVcIixcImdldFByb3BzXCJdLFxuXHRcdHZhbGlkYXRlSW50ZXJmYWNlID0gZnVuY3Rpb24ob2JqLCBpbnRlcikge1xuXHRcdFx0dmFyIHZhbGlkID0gdHJ1ZTtcblx0XHRcdG9iaiA9IG9iaiB8fCB7fTtcblx0XHRcdGludGVyID0gW10uY29uY2F0KGludGVyKTtcblx0XHRcdCQuZWFjaChpbnRlciwgZnVuY3Rpb24gKGksIHYpIHtcblx0XHRcdFx0aWYoISQuaXNGdW5jdGlvbihvYmpbdl0pKSB7IHZhbGlkID0gZmFsc2U7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gdmFsaWQ7XG5cdFx0fTtcblx0JC5qc3RyZWUucGx1Z2luKFwibW9kZWxcIiwge1xuXHRcdF9faW5pdCA6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmKCF0aGlzLmRhdGEuanNvbl9kYXRhKSB7IHRocm93IFwianNUcmVlIG1vZGVsOiBqc1RyZWUganNvbl9kYXRhIHBsdWdpbiBub3QgaW5jbHVkZWQuXCI7IH1cblx0XHRcdHRoaXMuX2dldF9zZXR0aW5ncygpLmpzb25fZGF0YS5kYXRhID0gZnVuY3Rpb24gKG4sIGIpIHtcblx0XHRcdFx0dmFyIG9iaiA9IChuID09IC0xKSA/IHRoaXMuX2dldF9zZXR0aW5ncygpLm1vZGVsLm9iamVjdCA6IG4uZGF0YShcImpzdHJlZV9tb2RlbFwiKTtcblx0XHRcdFx0aWYoIXZhbGlkYXRlSW50ZXJmYWNlKG9iaiwgbm9kZUludGVyZmFjZSkpIHsgcmV0dXJuIGIuY2FsbChudWxsLCBmYWxzZSk7IH1cblx0XHRcdFx0aWYodGhpcy5fZ2V0X3NldHRpbmdzKCkubW9kZWwuYXN5bmMpIHtcblx0XHRcdFx0XHRvYmouZ2V0Q2hpbGRyZW4oJC5wcm94eShmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0XHRcdFx0dGhpcy5tb2RlbF9kb25lKGRhdGEsIGIpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aGlzLm1vZGVsX2RvbmUob2JqLmdldENoaWxkcmVuKCksIGIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0sXG5cdFx0ZGVmYXVsdHMgOiB7XG5cdFx0XHRvYmplY3QgOiBmYWxzZSxcblx0XHRcdGlkX3ByZWZpeCA6IGZhbHNlLFxuXHRcdFx0YXN5bmMgOiBmYWxzZVxuXHRcdH0sXG5cdFx0X2ZuIDoge1xuXHRcdFx0bW9kZWxfZG9uZSA6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuXHRcdFx0XHR2YXIgcmV0ID0gW10sIFxuXHRcdFx0XHRcdHMgPSB0aGlzLl9nZXRfc2V0dGluZ3MoKSxcblx0XHRcdFx0XHRfdGhpcyA9IHRoaXM7XG5cblx0XHRcdFx0aWYoISQuaXNBcnJheShkYXRhKSkgeyBkYXRhID0gW2RhdGFdOyB9XG5cdFx0XHRcdCQuZWFjaChkYXRhLCBmdW5jdGlvbiAoaSwgbmQpIHtcblx0XHRcdFx0XHR2YXIgciA9IG5kLmdldFByb3BzKCkgfHwge307XG5cdFx0XHRcdFx0ci5hdHRyID0gbmQuZ2V0QXR0cigpIHx8IHt9O1xuXHRcdFx0XHRcdGlmKG5kLmdldENoaWxkcmVuQ291bnQoKSkgeyByLnN0YXRlID0gXCJjbG9zZWRcIjsgfVxuXHRcdFx0XHRcdHIuZGF0YSA9IG5kLmdldE5hbWUoKTtcblx0XHRcdFx0XHRpZighJC5pc0FycmF5KHIuZGF0YSkpIHsgci5kYXRhID0gW3IuZGF0YV07IH1cblx0XHRcdFx0XHRpZihfdGhpcy5kYXRhLnR5cGVzICYmICQuaXNGdW5jdGlvbihuZC5nZXRUeXBlKSkge1xuXHRcdFx0XHRcdFx0ci5hdHRyW3MudHlwZXMudHlwZV9hdHRyXSA9IG5kLmdldFR5cGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoci5hdHRyLmlkICYmIHMubW9kZWwuaWRfcHJlZml4KSB7IHIuYXR0ci5pZCA9IHMubW9kZWwuaWRfcHJlZml4ICsgci5hdHRyLmlkOyB9XG5cdFx0XHRcdFx0aWYoIXIubWV0YWRhdGEpIHsgci5tZXRhZGF0YSA9IHsgfTsgfVxuXHRcdFx0XHRcdHIubWV0YWRhdGEuanN0cmVlX21vZGVsID0gbmQ7XG5cdFx0XHRcdFx0cmV0LnB1c2gocik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRjYWxsYmFjay5jYWxsKG51bGwsIHJldCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn0pKGpRdWVyeSk7XG4vLyovXG5cbn0pKCk7IiwiLyoqXG4gKiBQcm92aWRlcyBtZXRob2RzIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBjbGllbnQgY29uZmlnLlxuICogVGhlIGNsaWVudCBjb25maWcgaXMgZGVmaW5lZCB1c2luZyB0aGUgWUFNTC9QSFAgY29uZmlnIHN5c3RlbS5cbiAqXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgQ29uZmlnIHtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHRoZSBjb25maWcgZm9yIGEgc3BlY2lmaWMgc2VjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdHJpbmcga2V5IC0gVGhlIHNlY3Rpb24gY29uZmlnIGtleS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gb2JqZWN0fHVuZGVmaW5lZFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTZWN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gd2luZG93LnNzLmNvbmZpZy5zZWN0aW9uc1trZXldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBkZS1kdXBlZCBsaXN0IG9mIHJvdXRlcyBmb3IgdG9wIGxldmVsIGNvbnRyb2xsZXJzLiBFLmcuICdhc3NldHMnLCAncGFnZXMnLCBldGMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGFycmF5XG4gICAgICovXG4gICAgc3RhdGljIGdldFRvcExldmVsUm91dGVzKCkge1xuICAgICAgICB2YXIgdG9wTGV2ZWxSb3V0ZXMgPSBbXTtcblxuICAgICAgICBPYmplY3Qua2V5cyh3aW5kb3cuc3MuY29uZmlnLnNlY3Rpb25zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gd2luZG93LnNzLmNvbmZpZy5zZWN0aW9uc1trZXldLnJvdXRlO1xuICAgICAgICAgICAgY29uc3QgaXNUb3BMZXZlbFJvdXRlID0gcm91dGUuaW5kZXhPZignLycpID09PSAtMTtcbiAgICAgICAgICAgIGNvbnN0IGlzVW5pcXVlID0gdG9wTGV2ZWxSb3V0ZXMuaW5kZXhPZihyb3V0ZSkgPT09IC0xO1xuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuZ2V0U2VjdGlvbihrZXkpLnJvdXRlKTtcblxuICAgICAgICAgICAgaWYgKGlzVG9wTGV2ZWxSb3V0ZSAmJiBpc1VuaXF1ZSkge1xuICAgICAgICAgICAgICAgIHRvcExldmVsUm91dGVzLnB1c2gocm91dGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdG9wTGV2ZWxSb3V0ZXM7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZztcbiIsIi8qXG4gKiBMaWdodHdlaWdodCBjbGllbnRzaWRlIGkxOG4gaW1wbGVtZW50YXRpb24uXG4gKiBDYXV0aW9uOiBPbmx5IGF2YWlsYWJsZSBhZnRlciBET00gbG9hZGVkIGJlY2F1c2Ugd2UgbmVlZCB0byBkZXRlY3QgdGhlIGxhbmd1YWdlXG4gKiBcbiAqIEZvciBub24taTE4biBzdHViIGltcGxlbWVudGF0aW9uLCBzZWUgZnJhbWV3b3JrL2phdmFzY3JpcHQvc3JjL2kxOG54LmpzXG4gKiBcbiAqIEJhc2VkIG9uIGpRdWVyeSBpMThuIHBsdWdpbjogMS4wLjAgIEZlYi0xMC0yMDA4XG4gKiBcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIGxpY2Vuc2VzOlxuICogICBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICogICBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvZ3BsLmh0bWxcbiAqXG4gKiBCYXNlZCBvbiAnamF2YXNjcmlwdCBpMThuIHRoYXQgYWxtb3N0IGRvZXNuJ3Qgc3VjaycgYnkgbWFya29zXG4gKiBodHRwOi8vbWFya29zLmdhaXZvLm5ldC9ibG9nLz9wPTEwMFxuICovXG5cbmNsYXNzIGkxOG4ge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLmN1cnJlbnRMb2NhbGUgPSBudWxsO1xuXHRcdHRoaXMuZGVmYXVsdExvY2FsZSA9ICdlbl9VUyc7XG5cdFx0dGhpcy5sYW5nID0ge307XG5cdH1cblxuXHQvKipcblx0ICogU2V0IGxvY2FsZSBpbiBsb25nIGZvcm1hdCwgZS5nLiBcImRlX0FUXCIgZm9yIEF1c3RyaWFuIEdlcm1hbi5cblx0ICpcblx0ICogQHBhcmFtIHN0cmluZyBsb2NhbGVcblx0ICovXG5cdHNldExvY2FsZShsb2NhbGUpIHtcblx0XHR0aGlzLmN1cnJlbnRMb2NhbGUgPSBsb2NhbGU7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IGxvY2FsZSBpbiBsb25nIGZvcm1hdC4gRmFsbHMgYmFjayB0byBpMThuLmRlZmF1dF9sb2NhbGUuXG5cdCAqXG5cdCAqIEByZXR1cm4gc3RyaW5nXG5cdCAqL1xuXHRnZXRMb2NhbGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY3VycmVudExvY2FsZSAhPT0gbnVsbCA/IHRoaXMuY3VycmVudExvY2FsZSA6IHRoaXMuZGVmYXVsdExvY2FsZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYWN0dWFsIHRyYW5zbGF0aW9uIGZ1bmN0aW9uLiBMb29rcyB0aGUgZ2l2ZW4gc3RyaW5nIHVwIGluIHRoZSBcblx0ICogZGljdGlvbmFyeSBhbmQgcmV0dXJucyB0aGUgdHJhbnNsYXRpb24gaWYgb25lIGV4aXN0cy4gSWYgYSB0cmFuc2xhdGlvbiBcblx0ICogaXMgbm90IGZvdW5kLCByZXR1cm5zIHRoZSBvcmlnaW5hbCB3b3JkLlxuXHQgKlxuXHQgKiBAcGFyYW0gc3RyaW5nIGVudGl0eSAtIEEgXCJsb25nXCIgbG9jYWxlIGZvcm1hdCwgZS5nLiBcImRlX0RFXCIgKFJlcXVpcmVkKVxuXHQgKiBAcGFyYW0gc3RyaW5nIGZhbGxiYWNrU3RyaW5nIC0gKFJlcXVpcmVkKVxuXHQgKiBAcGFyYW0gaW50IHByaW9yaXR5IC0gKG5vdCB1c2VkKVxuXHQgKiBAcGFyYW0gc3RyaW5nIGNvbnRleHQgLSBHaXZlIHRyYW5zbGF0b3JzIGNvbnRleHQgZm9yIHRoZSBzdHJpbmdcblx0ICogQHJldHVybiBzdHJpbmcgOiBUcmFuc2xhdGVkIHdvcmRcblx0ICovXG5cdF90KGVudGl0eSwgZmFsbGJhY2tTdHJpbmcsIHByaW9yaXR5LCBjb250ZXh0KSB7XG5cdFx0Y29uc3QgbGFuZ05hbWUgPSB0aGlzLmdldExvY2FsZSgpLnJlcGxhY2UoL19bXFx3XSsvaSwgJycpO1xuXHRcdGNvbnN0IGRlZmF1bHRsYW5nTmFtZSA9IHRoaXMuZGVmYXVsdExvY2FsZS5yZXBsYWNlKC9fW1xcd10rL2ksICcnKTtcblxuXHRcdGlmICh0aGlzLmxhbmcgJiYgdGhpcy5sYW5nW3RoaXMuZ2V0TG9jYWxlKCldICYmIHRoaXMubGFuZ1t0aGlzLmdldExvY2FsZSgpXVtlbnRpdHldKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5sYW5nW3RoaXMuZ2V0TG9jYWxlKCldW2VudGl0eV07XG5cdFx0fSBlbHNlIGlmICh0aGlzLmxhbmcgJiYgdGhpcy5sYW5nW2xhbmdOYW1lXSAmJiB0aGlzLmxhbmdbbGFuZ05hbWVdW2VudGl0eV0pIHtcblx0XHRcdHJldHVybiB0aGlzLmxhbmdbbGFuZ05hbWVdW2VudGl0eV07XG5cdFx0fSBlbHNlIGlmICh0aGlzLmxhbmcgJiYgdGhpcy5sYW5nW3RoaXMuZGVmYXVsdExvY2FsZV0gJiYgdGhpcy5sYW5nW3RoaXMuZGVmYXVsdExvY2FsZV1bZW50aXR5XSkge1xuXHRcdFx0cmV0dXJuIHRoaXMubGFuZ1t0aGlzLmRlZmF1bHRMb2NhbGVdW2VudGl0eV07XG5cdFx0fSBlbHNlIGlmICh0aGlzLmxhbmcgJiYgdGhpcy5sYW5nW2RlZmF1bHRsYW5nTmFtZV0gJiYgdGhpcy5sYW5nW2RlZmF1bHRsYW5nTmFtZV1bZW50aXR5XSkge1xuXHRcdFx0cmV0dXJuIHRoaXMubGFuZ1tkZWZhdWx0bGFuZ05hbWVdW2VudGl0eV07IFxuXHRcdH0gZWxzZSBpZihmYWxsYmFja1N0cmluZykge1xuXHRcdFx0cmV0dXJuIGZhbGxiYWNrU3RyaW5nO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCBlbnRpdGllcyB0byBhIGRpY3Rpb25hcnkuIElmIGEgZGljdGlvbmFyeSBkb2Vzbid0XG5cdCAqIGV4aXN0IGZvciB0aGlzIGxvY2FsZSwgaXRzIGF1dG9tYXRpY2FsbHkgY3JlYXRlZC5cblx0ICogRXhpc3RpbmcgZW50aXRpZXMgYXJlIG92ZXJ3cml0dGVuLlxuXHQgKiBcblx0ICogQHBhcmFtIHN0cmluZyBsb2NhbGVcblx0ICogQHBhcmFtIE9iamVjdCBkaWN0XG5cdCAqL1xuXHRhZGREaWN0aW9uYXJ5KGxvY2FsZSwgZGljdCkge1xuXHRcdGlmICh0eXBlb2YgdGhpcy5sYW5nW2xvY2FsZV0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHR0aGlzLmxhbmdbbG9jYWxlXSA9IHt9O1xuXHRcdH1cblxuXHRcdGZvciAobGV0IGVudGl0eSBpbiBkaWN0KSB7XG5cdFx0XHR0aGlzLmxhbmdbbG9jYWxlXVtlbnRpdHldID0gZGljdFtlbnRpdHldO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgZGljdGlvbmFyeSBmb3IgYSBzcGVjaWZpYyBsb2NhbGUuXG5cdCAqIFxuXHQgKiBAcGFyYW0gc3RyaW5nIGxvY2FsZVxuXHQgKi9cblx0Z2V0RGljdGlvbmFyeShsb2NhbGUpIHtcblx0XHRyZXR1cm4gdGhpcy5sYW5nW2xvY2FsZV07XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHN0cmluZyBzdHIgLSBUaGUgc3RyaW5nIHRvIHN0cmlwLlxuXHQgKiBAcmV0dXJuIHN0cmluZyByZXN1bHQgLSBTdHJpcHBlZCBzdHJpbmcuXG5cdCAqXG5cdCAqL1xuXHRzdHJpcFN0cihzdHIpIHtcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSBzdHJpbmcgc3RyIC0gVGhlIG11bHRpLWxpbmUgc3RyaW5nIHRvIHN0cmlwLlxuXHQgKiBAcmV0dXJuIHN0cmluZyByZXN1bHQgLSBTdHJpcHBlZCBzdHJpbmcuXG5cdCAqXG5cdCAqL1xuXHRzdHJpcFN0ck1MKHN0cikge1xuXHRcdC8vIFNwbGl0IGJlY2F1c2UgbSBmbGFnIGRvZXNuJ3QgZXhpc3QgYmVmb3JlIEpTMS41IGFuZCB3ZSBuZWVkIHRvXG5cdFx0Ly8gc3RyaXAgbmV3bGluZXMgYW55d2F5XG5cdFx0dmFyIHBhcnRzID0gc3RyLnNwbGl0KCdcXG4nKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdHBhcnRzW2ldID0gc3RyaXBTdHIocGFydHNbaV0pO1xuXHRcdH1cblxuXHRcdC8vIERvbid0IGpvaW4gd2l0aCBlbXB0eSBzdHJpbmdzLCBiZWNhdXNlIGl0IFwiY29uY2F0c1wiIHdvcmRzXG5cdFx0Ly8gQW5kIHN0cmlwIGFnYWluXG5cdFx0cmV0dXJuIHN0cmlwU3RyKHBhcnRzLmpvaW4oJyAnKSk7XG5cdH1cblxuXHQvKipcblx0ICogU3Vic3RpdHV0ZXMgJXMgd2l0aCBwYXJhbWV0ZXJzXG4gXHQgKiBnaXZlbiBpbiBsaXN0LiAlJXMgaXMgdXNlZCB0byBlc2NhcGUgJXMuXG4gXHQgKiBcblx0ICogQHBhcmFtIHN0cmluZyBzIC0gVGhlIHN0cmluZyB0byBwZXJmb3JtIHRoZSBzdWJzdGl0dXRpb25zIG9uLlxuXHQgKiBAcmV0dXJuIHN0cmluZyAtIFRoZSBuZXcgc3RyaW5nIHdpdGggc3Vic3RpdHV0aW9ucyBtYWRlLlxuXHQgKi9cblx0c3ByaW50ZihzLCAuLi5wYXJhbXMpIHtcblx0XHRpZiAocGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHM7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcmVneCA9IG5ldyBSZWdFeHAoJyguPykoJXMpJywgJ2cnKTtcblxuXHRcdGxldCBpID0gMDtcblxuXHRcdHJldHVybiBzLnJlcGxhY2UocmVneCwgZnVuY3Rpb24gKG1hdGNoLCBzdWJNYXRjaDEsIHN1Yk1hdGNoMiwgb2Zmc2V0LCBzdHJpbmcpIHtcblx0XHRcdC8vIHNraXAgJSVzXG5cdFx0XHRpZiAoc3ViTWF0Y2gxID09PSAnJScpIHtcblx0XHRcdFx0cmV0dXJuIG1hdGNoOyBcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHN1Yk1hdGNoMSArIHBhcmFtc1tpKytdO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN1YnN0aXR1dGVzIHZhcmlhYmxlcyB3aXRoIGEgbGlzdCBvZiBpbmplY3Rpb25zLiBcbiBcdCAqIFxuXHQgKiBAcGFyYW0gc3RyaW5nIHMgLSBUaGUgc3RyaW5nIHRvIHBlcmZvcm0gdGhlIHN1YnN0aXR1dGlvbnMgb24uXG5cdCAqIEBwYXJhbSBvYmplY3QgbWFwIC0gQW4gb2JqZWN0IHdpdGggdGhlIHN1YnN0aXRpb25zIG1hcCBlLmcuIHt2YXI6IHZhbHVlfS5cblx0ICogQHJldHVybiBzdHJpbmcgLSBUaGUgbmV3IHN0cmluZyB3aXRoIHN1YnN0aXR1dGlvbnMgbWFkZS5cblx0ICovXG5cdGluamVjdChzLCBtYXApIHtcblx0XHRjb25zdCByZWd4ID0gbmV3IFJlZ0V4cCgnXFx7KFtBLVphLXowLTlfXSopXFx9JywgJ2cnKTtcblxuXHRcdHJldHVybiBzLnJlcGxhY2UocmVneCwgZnVuY3Rpb24gKG1hdGNoLCBrZXksIG9mZnNldCwgc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gKG1hcFtrZXldKSA/IG1hcFtrZXldIDogbWF0Y2g7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogRGV0ZWN0IGRvY3VtZW50IGxhbmd1YWdlIHNldHRpbmdzIGJ5IGxvb2tpbmcgYXQgPG1ldGE+IHRhZ3MuXG5cdCAqIElmIG5vIG1hdGNoIGlzIGZvdW5kLCByZXR1cm5zIHRoaXMuZGVmYXVsdExvY2FsZS5cblx0ICogXG5cdCAqIEB0b2RvIGdldCBieSA8aHRtbCBsYW5nPScnPiAtIG5lZWRzIG1vZGlmaWNhdGlvbiBvZiBTU1ZpZXdlclxuXHQgKiBcblx0ICogQHJldHVybiBzdHJpbmcgLSBMb2NhbGUgaW4gbWl4ZWQgbG93ZXJjYXNlL3VwcGVyY2FzZSBmb3JtYXQgc3VpdGFibGVcblx0ICogZm9yIHVzYWdlIGluIGkxOG4ubGFuZyBhcnJheXMgKGUuZy4gJ2VuX1VTJykuXG5cdCAqL1xuXHRkZXRlY3RMb2NhbGUoKSB7XG5cdFx0dmFyIHJhd0xvY2FsZTtcblx0XHR2YXIgZGV0ZWN0ZWRMb2NhbGU7XG5cblx0XHQvLyBHZXQgYnkgY29udGFpbmVyIHRhZ1xuXHRcdHJhd0xvY2FsZSA9IGpRdWVyeSgnYm9keScpLmF0dHIoJ2xhbmcnKTtcblxuXHRcdC8vIEdldCBieSBtZXRhXG5cdFx0aWYgKCFyYXdMb2NhbGUpIHtcblx0XHRcdHZhciBtZXRhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdtZXRhJyk7XG5cblx0XHRcdGZvciAodmFyIGk9MDsgaTxtZXRhcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAobWV0YXNbaV0uYXR0cmlidXRlc1snaHR0cC1lcXVpdiddICYmIG1ldGFzW2ldLmF0dHJpYnV0ZXNbJ2h0dHAtZXF1aXYnXS5ub2RlVmFsdWUudG9Mb3dlckNhc2UoKSA9PSAnY29udGVudC1sYW5ndWFnZScpIHtcblx0XHRcdFx0XHRyYXdMb2NhbGUgPSBtZXRhc1tpXS5hdHRyaWJ1dGVzWydjb250ZW50J10ubm9kZVZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gZGVmYXVsdCBsb2NhbGVcblx0XHRpZiAoIXJhd0xvY2FsZSkge1xuXHRcdFx0cmF3TG9jYWxlID0gdGhpcy5kZWZhdWx0TG9jYWxlO1xuXHRcdH1cblxuXHRcdHZhciByYXdMb2NhbGVQYXJ0cyA9IHJhd0xvY2FsZS5tYXRjaCgvKFteLXxfXSopWy18X10oLiopLyk7XG5cdFx0Ly8gR2V0IGxvY2FsZSAoZS5nLiAnZW5fVVMnKSBmcm9tIGNvbW1vbiBuYW1lIChlLmcuICdlbicpXG5cdFx0Ly8gYnkgbG9va2luZyBhdCBpMThuLmxhbmcgdGFibGVzXG5cdFx0aWYgKHJhd0xvY2FsZS5sZW5ndGggPT0gMikge1xuXHRcdFx0Zm9yIChsZXQgY29tcGFyZUxvY2FsZSBpbiBpMThuLmxhbmcpIHtcblx0XHRcdFx0aWYgKGNvbXBhcmVMb2NhbGUuc3Vic3RyKDAsMikudG9Mb3dlckNhc2UoKSA9PSByYXdMb2NhbGUudG9Mb3dlckNhc2UoKSkge1xuXHRcdFx0XHRcdGRldGVjdGVkTG9jYWxlID0gY29tcGFyZUxvY2FsZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAocmF3TG9jYWxlUGFydHMpIHtcblx0XHRcdGRldGVjdGVkTG9jYWxlID0gcmF3TG9jYWxlUGFydHNbMV0udG9Mb3dlckNhc2UoKSArICdfJyArIHJhd0xvY2FsZVBhcnRzWzJdLnRvVXBwZXJDYXNlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRldGVjdGVkTG9jYWxlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEF0dGFjaCBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgZ2l2ZW4gb2JqZWN0LlxuXHQgKiBNb2RlbGVkIGFmdGVyIGJlaGF2aW91ci5qcywgYnV0IGV4dGVybmFsaXplZFxuXHQgKiB0byBrZWVwIHRoZSBpMThuIGxpYnJhcnkgc3RhbmRhbG9uZSBmb3Igbm93LlxuXHQgKi9cblx0YWRkRXZlbnQob2JqLCBldlR5cGUsIGZuLCB1c2VDYXB0dXJlKSB7XG5cdFx0aWYgKG9iai5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcihldlR5cGUsIGZuLCB1c2VDYXB0dXJlKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSBpZiAob2JqLmF0dGFjaEV2ZW50KSB7XG5cdFx0XHRyZXR1cm4gb2JqLmF0dGFjaEV2ZW50KCdvbicgKyBldlR5cGUsIGZuKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS5sb2coJ0hhbmRsZXIgY291bGQgbm90IGJlIGF0dGFjaGVkJyk7XG5cdFx0fVxuXHR9XG59XG5cbmxldCBfaTE4biA9IG5ldyBpMThuKCk7XG5cbi8vIFRoaXMgbW9kdWxlIGhhcyB0byBzdXBwb3J0IGxlZ2FjeSBsb2FkaW5nLi4uXG53aW5kb3cuc3MgPSB0eXBlb2Ygd2luZG93LnNzICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5zcyA6IHt9O1xud2luZG93LnNzLmkxOG4gPSB3aW5kb3cuaTE4biA9IF9pMThuO1xuXG5leHBvcnQgZGVmYXVsdCBfaTE4bjtcbiIsIi8qKlxuICogVGhpcyB3cmFwcyB0aGUgZ2xvYmFsIGpRdWVyeSBzbyBqUXVlcnkgY2FuIGJlIGltcG9ydGVkXG4gKiBsaWtlIG90aGVyIG1vZHVsZXMuIE9uY2UgalF1ZXJ5IGlzIHVwZGF0ZWQgYW5kIG1hbmFnZWRcbiAqIGJ5IG5wbSB3ZSBjYW4gZ2V0IHJpZCBvZiB0aGlzIHdyYXBwZXIuXG4gKi9cbnZhciBqUXVlcnkgPSB0eXBlb2Ygd2luZG93LmpRdWVyeSAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cualF1ZXJ5IDogbnVsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBqUXVlcnk7XG4iLCIvKipcbiAqIEhhbmRsZXMgY2xpZW50LXNpZGUgcm91dGluZy5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlzaW9ubWVkaWEvcGFnZS5qc1xuICovXG5pbXBvcnQgcGFnZSBmcm9tICdwYWdlLmpzJztcblxuLyoqXG4gKiBXcmFwcGVyIGZvciBgcGFnZS5zaG93KClgIHdpdGggU2lsdmVyU3RyaXBlIHNwZWNpZmljIGJlaGF2aW91ci5cbiAqL1xuZnVuY3Rpb24gc2hvdyhwYWdlU2hvdykge1xuICAgIHJldHVybiAocGF0aCwgc3RhdGUsIGRpc3BhdGNoLCBwdXNoKSA9PiB7XG4gICAgICAgIC8vIE5vcm1hbGlzZSBgcGF0aGAgc28gdGhhdCBwYXR0ZXJuIG1hdGNoaW5nIGlzIG1vcmUgcm9idXN0LlxuICAgICAgICAvLyBGb3IgZXhhbXBsZSBpZiB5b3VyIHJvdXRlIGlzICcvcGFnZXMnIGl0IHNob3VsZCBtYXRjaCB3aGVuIGBwYXRoYCBpc1xuICAgICAgICAvLyAnaHR0cDovL2Zvby5jb20vYWRtaW4vcGFnZXMnLCAnL3BhZ2VzJywgYW5kICdwYWdlcycuXG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgZWwuaHJlZiA9IHBhdGg7XG5cbiAgICAgICAgcmV0dXJuIHBhZ2VTaG93KGVsLnBhdGhuYW1lLCBzdGF0ZSwgZGlzcGF0Y2gsIHB1c2gpO1xuICAgIH1cbn1cblxucGFnZS5zaG93ID0gc2hvdyhwYWdlLnNob3cpO1xuXG5leHBvcnQgZGVmYXVsdCBwYWdlO1xuIl19
