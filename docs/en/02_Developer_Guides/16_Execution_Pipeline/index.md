summary: An overview of the steps involved in delivering a SilverStripe web page.

# Execution Pipeline

## Introduction

In order to transform a HTTP request or a command line execution into a response,
SilverStripe needs to boot its core and run through several stages of processing.

## Request Rewriting

The first step in most environments is a rewriting of the request path into parameters which then get passed to a PHP script. This allows writing friendly URLs instead of linking directly to PHP files.
The rewriting implementation depends on your web server; we'll show you the most common one here: 
Apache with [mod_rewrite](http://httpd.apache.org/docs/2.0/mod/mod_rewrite.html).
See our [installation guides](/getting_started/installation) on how other web servers like IIS or nginx handle request rewriting.

The standard SilverStripe project ships with a `.htaccess` file in your webroot for request rewriting (see below).
By default, requests for files existing in the filesystem will be passed through as is. Of course, some access control is in place to deny access to potentially sensitive files in the webroot, such as YAML configuration files. If no file in the file system matches the one requested, the request is then handed off to `framework/main.php` for rewriting.

	### SILVERSTRIPE START ###

	# Deny access to templates (but allow from localhost)
	<Files *.ss>
		Order deny,allow
		Deny from all
		Allow from 127.0.0.1
	</Files>

	# Deny access to IIS configuration
	<Files web.config>
		Order deny,allow
		Deny from all
	</Files>

	# Deny access to YAML configuration files which might include sensitive information
	<Files ~ "\.ya?ml$">
		Order allow,deny
		Deny from all
	</Files>

	# Route errors to static pages automatically generated by SilverStripe
	ErrorDocument 404 /assets/error-404.html
	ErrorDocument 500 /assets/error-500.html

	<IfModule mod_rewrite.c>
		SetEnv HTTP_MOD_REWRITE On
		RewriteEngine On

		# Deny access to potentially sensitive files and folders
		RewriteRule ^vendor(/|$) - [F,L,NC]
		RewriteRule silverstripe-cache(/|$) - [F,L,NC]
		RewriteRule composer\.(json|lock) - [F,L,NC]

		# If no file with the requested name exists, pass the request over to SilverStripe's main.php script, 
		# retaining any existing request parameters as well as adding the original path as a query parameter. 
		RewriteCond %{REQUEST_URI} ^(.*)$
		RewriteCond %{REQUEST_FILENAME} !-f
		RewriteRule .* framework/main.php?url=%1 [QSA]

		# If requesting SilverStripe's main.php script directly, rewrite request to the installer
		RewriteCond %{REQUEST_URI} ^(.*)/framework/main.php$
		RewriteCond %{REQUEST_FILENAME} !-f
		RewriteRule . %1/install.php? [R,L]

	</IfModule>
	### SILVERSTRIPE END ###

SilverStripe can also operate without this level of rewriting, in which case all dynamic requests go
through an `index.php` script in the webroot.

<div class="notice" markdown="1">
Running SilverStripe without web server based rewriting is not recommended since, in this case, the `RewriteRule` conditions above don't apply, potentially leaving sensitive files exposed to public access.
</div>

## Bootstrap

When requests are passed over to `framework/main.php`, the script sets up the execution environment as follows:

 * Tries to locate a `_ss_environment.php` [configuration file](/getting_started/environment_management) in the webroot, 
   or the two levels above it (to allow sharing a single configuration file across multiple webroots).
 * Sets constants based on the filesystem structure (e.g. `BASE_URL`, `BASE_PATH` and `TEMP_FOLDER`).
 * Normalises the `url` parameter in preparation for handing it off to `Director`.
 * Connects to a database, based on information stored in the global `$databaseConfig` variable, either defined in your `_config.php`, or through your `_ss_environment.php`.
 * Sets up [error handlers](../debugging/error_handling).
 * Optionally continues a [session](../cookies_and_sessions/sessions) if the request already contains a session identifier.
 * Loads manifests for PHP classes, templates, as well as any [YAML configuration](../configuration) files.
 * Optionally regenerates these manifests (when a ["flush" query parameter](flushable) is set).
 * Executes all procedural configurations defined in the `_config.php` files for each discovered module.
 * Loads the Composer PHP class autoloader.
 * Hands control over to `[api:Director]`.

While you usually don't need to modify the bootstrap on this level, some deeper customisations like
adding your own manifests or performance-optimised routing might require it.
An example of such customisations can be found in the ["staticpublisher" module](https://github.com/silverstripe-labs/silverstripe-staticpublisher/blob/master/main.php).
The module instructs web servers to route through its own `main.php` to determine which requests can be cached
before handing control off to SilverStripe's own `main.php`.

## Routing and Request Handling

The `main.php` script relies on `[api:Director]` to determine which [controller](../controllers/) should handle each request. The `main.php` script parses the URL, matching it to one of a number of patterns, 
and determines the controller, action and any arguments to be used ([Routing](../controllers/routing)):

 * Creates a `[api:SS_HTTPRequest]` object containing all request and environment information.
 * The [session](../cookies_and_sessions/sessions) stores an abstraction of the PHP session.
 * Instantiates a [controller](../controllers/) object.
 * The `[api:Injector]` is first referenced, and asks the registered 
   [RequestFilter](../controllers/requestfilters)
   to pre-process the request object (see below).
 * The `Controller` executes the actual business logic and populates an `[api:SS_HTTPResponse]`.
 * The `Controller` can optionally hand off control to additional, nested controllers.
 * The `Controller` optionally renders a response body through `SSViewer` [templates](../templates).
 * The `[api:RequestProcessor]` is called to post-process the request to allow 
further filtering before content is sent to the end user.
 * The response is output to the client.

## Request pre-processing and post-processing

The framework provides the ability to hook into the request both before and 
after it is handled, allowing the binding of custom logic. This can be used
to transform or filter request data, instantiate helpers, execute global logic,
or even short-circuit execution (e.g. to enforce custom authentication schemes).
The ["Request Filters" documentation](../controllers/requestfilters) shows you how.

## Flushing Manifests

If a `?flush=1` query parameter is added to a URL, a call to `flush()` will be triggered
on any classes implementing the [Flushable](flushable) interface.
This enables developers to clear [manifest caches](manifests) whenever they add new templates or PHP classes.
Note that you need to be in [dev mode](/getting_started/environment_management)
or logged-in as an administrator for flushing to take effect.

[CHILDREN]
