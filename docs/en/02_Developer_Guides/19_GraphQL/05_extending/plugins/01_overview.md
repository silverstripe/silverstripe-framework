---
title: What are plugins?
summary: An overview of how plugins work with the GraphQL schema
---

# What are plugins?

Plugins are used to distribute reusable functionality across your schema. Some examples of commonly used plugins include:

* Adding versioning arguments to versioned DataObjects
* Adding a custom filter/sort arguments to DataObject queries
* Adding a one-off `VerisionedStage` enum to the schema
* Ensuring `Member` is in the schema
* And many more...

## What plugins must do

There isn't a huge API surface to a plugin. They just have to:

* Implement at least one of several plugin interfaces
* Declare an identifier
* Apply themselves to the schema with the `apply(Schema $schema)` method
* Be registered with the `PluginRegistry`


## Available plugin interfaces

Plugin interfaces are all found in the namespace `SilverStripe\GraphQL\Schema\Interfaces`

* `SchemaUpdater`: Make a one-off, context-free update to the schema
* `QueryPlugin`: Update a generic query
* `MutationPlugin`: Update a generic mutation
* `TypePlugin`: Update a generic type
* `FieldPlugin`: Update a field on a generic type
* `ModelQueryPlugin`: Update queries generated by a model, e.g. `readSiteTrees`
* `ModelMutationPlugin`: Update mutations generated by a model, e.g. `createSiteTree`
* `ModelTypePlugin`: Update types that are generated by a model
* `ModelFieldPlugin`: Update a field on types generated by a model

Wow, that's a lot of interfaces, right? This is owing mostly to issues around strict typing between interfaces,
and allows for a more expressive developer experience. Almost all of these interfaces have the same requirements,
just for different types. It's pretty easy to navigate if you know what you want to accomplish.

## Registering plugins

Plugins have to be registered with Injector.

```yaml
SilverStripe\Core\Injector\Injector:
  SilverStripe\GraphQL\Schema\Registry\PluginRegistry:
    constructor:
      myPlugin: '%$MyProject\Plugins\MyPlugin'
```

[info]
The key `myPlugin` is arbitrary. The identifier of the plugin is obtained procedurally.
[/info]

## Resolver middleware and afterware

The real power of plugins is the ability to distribute not just configuration across the schema, but
more importantly, _functionality_.

Fields have their own resolvers already, so we can't really get into those to change
their functionality without a massive hack. This is where the idea of **resolver middleware** and
**resolver afterware** comes in really useful.

**Resolver middleware** runs _before_ the field's assigned resolver
**Resolver afterware** runs _after_ the field's assigned resolver

Middlewares and afterwares are pretty straightforward. They get the same `$args`, `$context`, and `$info`
parameters as the assigned resolver, but the first argument, `$result` is mutated with each resolver.

## Going futher

Ready to try them out? Check out the tutorials:

* [Writing a simple plugin](writing_a_simple_plugin)
* [Writing a complex plugin](writing_a_complex_plugin)
